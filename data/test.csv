id,function,location,description
199260," static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct net_device *rcv = NULL;
 	struct veth_priv *priv, *rcv_priv;
 	struct veth_net_stats *stats, *rcv_stats;
 	int length;
 
 	priv = netdev_priv(dev);
 	rcv = priv->peer;
 	rcv_priv = netdev_priv(rcv);
 
 	stats = this_cpu_ptr(priv->stats);
 	rcv_stats = this_cpu_ptr(rcv_priv->stats);
 
 	if (!(rcv->flags & IFF_UP))
 		goto tx_drop;
 
 	if (dev->features & NETIF_F_NO_CSUM)
 		skb->ip_summed = rcv_priv->ip_summed;
 
 	length = skb->len + ETH_HLEN;
 	if (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)
 		goto rx_drop;
 
 	stats->tx_bytes += length;
 	stats->tx_packets++;
 
 	rcv_stats->rx_bytes += length;
 	rcv_stats->rx_packets++;
 
 	return NETDEV_TX_OK;
 
 tx_drop:
 	kfree_skb(skb);
 	stats->tx_dropped++;
  	return NETDEV_TX_OK;
  
  rx_drop:
	kfree_skb(skb);
  	rcv_stats->rx_dropped++;
  	return NETDEV_TX_OK;
  }",[39],"The veth (aka virtual Ethernet) driver in the Linux kernel before 2.6.34 does not properly manage skbs during congestion, which allows remote attackers to cause a denial of service (system crash) by leveraging lack of skb consumption in conjunction with a double-free error."
206852,"     memory_handle(const media::BitstreamBuffer& input) {
   base::SharedMemoryHandle input_handle =
       base::SharedMemory::DuplicateHandle(input.handle());
   if (!base::SharedMemory::IsHandleValid(input_handle)) {
      DLOG(ERROR) << ""Failed to duplicate handle of BitstreamBuffer"";
      return mojo::ScopedSharedBufferHandle();
    }
  return mojo::WrapSharedMemoryHandle(input_handle, input.size(),
                                      true  );
 
    
    
    
   return mojo::WrapSharedMemoryHandle(
       input_handle, input.size(),
       mojo::UnwrappedSharedMemoryHandleProtection::kReadWrite);
  }","[10, 11, 12, 13, 14, 15, 16, 8, 9]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
207600," find_insert(png_const_charp what, png_charp param)
 {
    png_uint_32 chunk = 0;
    png_charp parameter_list[1024];
  int i, nparams;
 
   
  for (i=0; i<4; ++i)
  {
  char ch = what[i];
 
  if ((ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122))
          chunk = (chunk << 8) + what[i];
 
  else
  break;
  }
 
  if (i < 4 || what[4] != 0)
  {
       fprintf(stderr, ""makepng --insert \""%s\"": invalid chunk name\n"", what);
       exit(1);
  }
 
   
    nparams = find_parameters(what, param, parameter_list, 1024);
 
 #  define CHUNK(a,b,c,d) (((a)<<24)+((b)<<16)+((c)<<8)+(d))
 
  switch (chunk)
  {
  case CHUNK(105,67,67,80):  
  if (nparams == 2)
  return make_insert(what, insert_iCCP, nparams, parameter_list);
  break;
 
  case CHUNK(116,69,88,116):  
  if (nparams == 2)
  return make_insert(what, insert_tEXt, nparams, parameter_list);
  break;
 
  case CHUNK(122,84,88,116):  
  if (nparams == 2)
  return make_insert(what, insert_zTXt, nparams, parameter_list);
  break;
 
  case CHUNK(105,84,88,116):  
  if (nparams == 4)
  return make_insert(what, insert_iTXt, nparams, parameter_list);
  break;
 
  case CHUNK(104,73,83,84):  
  if (nparams <= 256)
 
              return make_insert(what, insert_hIST, nparams, parameter_list);
           break;
  
       case CHUNK(115,66,73,84):  
          if (nparams <= 4)
             return make_insert(what, insert_sBIT, nparams, parameter_list);
          break;
 
  #if 0
        case CHUNK(115,80,76,84):   
           return make_insert(what, insert_sPLT, nparams, parameter_list);
 #endif
 
  default:
          fprintf(stderr, ""makepng --insert \""%s\"": unrecognized chunk name\n"",
             what);
          exit(1);
  }
 
    bad_parameter_count(what, nparams);
 
     return NULL;
  }","[58, 59, 60, 61, 62]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
200736," void __detach_mounts(struct dentry *dentry)
 {
 	struct mountpoint *mp;
 	struct mount *mnt;
 
 	namespace_lock();
 	mp = lookup_mountpoint(dentry);
 	if (IS_ERR_OR_NULL(mp))
 		goto out_unlock;
 
 	lock_mount_hash();
 	while (!hlist_empty(&mp->m_list)) {
 		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
 		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
 			struct mount *p, *tmp;
 			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
 				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
  				umount_mnt(p);
  			}
  		}
		else umount_tree(mnt, 0);
 		else umount_tree(mnt, UMOUNT_CONNECTED);
  	}
  	unlock_mount_hash();
  	put_mountpoint(mp);
 out_unlock:
 	namespace_unlock();
 }","[22, 21]","fs/namespace.c in the Linux kernel before 4.0.2 does not properly support mount connectivity, which allows local users to read arbitrary files by leveraging user-namespace root access for deletion of a file or directory."
207451," static int skt_write(int fd, const void *p, size_t len)
 {
  int sent;
  struct pollfd pfd;
 
     FNLOG();
 
     pfd.fd = fd;
     pfd.events = POLLOUT;
 
 
       
  
       
    if (poll(&pfd, 1, 500) == 0)
     if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)
          return 0;
  
      ts_log(""skt_write"", len, NULL);
  
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)
      {
          ERROR(""write failed with errno=%d\n"", errno);
          return -1;
  }
 
  return sent;
 }","[16, 22, 15, 21]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
2579,"static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)
{
char buf[4096];
int len;
va_list args;

va_start(args, format);
len = vsnprintf(buf, sizeof(buf)-1, format, args);
va_end(args);
out->putBuf(out, buf, len);
}",[3],"gd_xbm.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in certain custom PHP 5.5.x configurations, allows context-dependent attackers to obtain sensitive information from process memory or cause a denial of service (stack-based buffer under-read and application crash) via a long name."
203338," static size_t optsize (lua_State *L, char opt, const char **fmt) {
   switch (opt) {
     case 'B': case 'b': return sizeof(char);
     case 'H': case 'h': return sizeof(short);
     case 'L': case 'l': return sizeof(long);
     case 'T': return sizeof(size_t);
      case 'f':  return sizeof(float);
      case 'd':  return sizeof(double);
      case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
     case 'c': return getnum(fmt, 1);
      case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
       int sz = getnum(fmt, sizeof(int));
        if (sz > MAXINTSIZE)
          luaL_error(L, ""integral size %d is larger than limit of %d"",
                         sz, MAXINTSIZE);
       return sz;
     }
     default: return 0;   
   }
 }","[11, 14, 10, 13]","An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking."
7563,"pixReadFromTiffStream(TIFF  *tif)
{
char      *text;
l_uint8   *linebuf, *data, *rowptr;
l_uint16   spp, bps, photometry, tiffcomp, orientation, sample_fmt;
l_uint16  *redmap, *greenmap, *bluemap;
l_int32    d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval;
l_int32    xres, yres, tiffbpl, packedbpl, halfsize;
l_uint32   w, h, tiffword, read_oriented;
l_uint32  *line, *ppixel, *tiffdata, *pixdata;
PIX       *pix, *pix1;
PIXCMAP   *cmap;

PROCNAME(""pixReadFromTiffStream"");

if (!tif)
return (PIX *)ERROR_PTR(""tif not defined"", procName, NULL);

read_oriented = 0;






TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt);
if (sample_fmt != SAMPLEFORMAT_UINT) {
L_ERROR(""sample format = %d is not uint\n"", procName, sample_fmt);
return NULL;
}






if (TIFFIsTiled(tif)) {
L_ERROR(""tiled format is not supported\n"", procName);
return NULL;
}








TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp);
if (tiffcomp == COMPRESSION_OJPEG) {
L_ERROR(""old style jpeg format is not supported\n"", procName);
return NULL;
}


TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps);
TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp);
if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) {
L_ERROR(""invalid bps = %d\n"", procName, bps);
return NULL;
}
if (spp == 2 && bps != 8) {
L_WARNING(""for 2 spp, only handle 8 bps\n"", procName);
return NULL;
}
if (spp == 1)
d = bps;
else if (spp == 2)
d = 32;
else if (spp == 3 || spp == 4)
d = 32;
else
return (PIX *)ERROR_PTR(""spp not in set {1,2,3,4}"", procName, NULL);

TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w);
TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h);
if (w > MaxTiffWidth) {
L_ERROR(""width = %d pixels; too large\n"", procName, w);
return NULL;
}
if (h > MaxTiffHeight) {
L_ERROR(""height = %d pixels; too large\n"", procName, h);
return NULL;
}







tiffbpl = TIFFScanlineSize(tif);
packedbpl = (bps * spp * w + 7) / 8;
halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8;
#if 0
if (halfsize)
L_INFO(""packedbpl = %d is approx. twice tiffbpl = %d\n"", procName,
packedbpl, tiffbpl);
#endif
if (tiffbpl != packedbpl && !halfsize) {
L_ERROR(""invalid tiffbpl: tiffbpl = %d, packedbpl = %d, ""
""bps = %d, spp = %d, w = %d\n"",
procName, tiffbpl, packedbpl, bps, spp, w);
return NULL;
}

if ((pix = pixCreate(w, h, d)) == NULL)
return (PIX *)ERROR_PTR(""pix not made"", procName, NULL);
pixSetInputFormat(pix, IFF_TIFF);
data = (l_uint8 *)pixGetData(pix);
wpl = pixGetWpl(pix);
bpl = 4 * wpl;

if (spp == 1) {
linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));
for (i = 0; i < h; i++) {
if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {
LEPT_FREE(linebuf);
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""line read fail"", procName, NULL);
}
memcpy(data, linebuf, tiffbpl);
data += bpl;
}
if (bps <= 8)
pixEndianByteSwap(pix);
else
pixEndianTwoByteSwap(pix);
LEPT_FREE(linebuf);
} else if (spp == 2 && bps == 8) {
L_INFO(""gray+alpha is not supported; converting to RGBA\n"", procName);
pixSetSpp(pix, 4);
linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));
pixdata = pixGetData(pix);
for (i = 0; i < h; i++) {
if (TIFFReadScanline(tif, linebuf, i, 0) < 0) {
LEPT_FREE(linebuf);
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""line read fail"", procName, NULL);
}
rowptr = linebuf;
ppixel = pixdata + i * wpl;
for (j = k = 0; j < w; j++) {

SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]);
SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]);
SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]);
SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]);
ppixel++;
}
}
LEPT_FREE(linebuf);
} else {
if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h,
sizeof(l_uint32))) == NULL) {
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""calloc fail for tiffdata"", procName, NULL);
}

if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata,
ORIENTATION_TOPLEFT, 0)) {
LEPT_FREE(tiffdata);
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""failed to read tiffdata"", procName, NULL);
} else {
read_oriented = 1;
}

if (spp == 4) pixSetSpp(pix, 4);
line = pixGetData(pix);
for (i = 0; i < h; i++, line += wpl) {
for (j = 0, ppixel = line; j < w; j++) {

tiffword = tiffdata[i * w + j];
rval = TIFFGetR(tiffword);
gval = TIFFGetG(tiffword);
bval = TIFFGetB(tiffword);
if (spp == 3) {
composeRGBPixel(rval, gval, bval, ppixel);
} else {
aval = TIFFGetA(tiffword);
composeRGBAPixel(rval, gval, bval, aval, ppixel);
}
ppixel++;
}
}
LEPT_FREE(tiffdata);
}

if (getTiffStreamResolution(tif, &xres, &yres) == 0) {
pixSetXRes(pix, xres);
pixSetYRes(pix, yres);
}


comptype = getTiffCompressedFormat(tiffcomp);
pixSetInputFormat(pix, comptype);

if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) {




if (bps > 8) {
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""colormap size > 256"", procName, NULL);
}
if ((cmap = pixcmapCreate(bps)) == NULL) {
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""colormap not made"", procName, NULL);
}
ncolors = 1 << bps;
for (i = 0; i < ncolors; i++)
pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8,
bluemap[i] >> 8);
if (pixSetColormap(pix, cmap)) {
pixDestroy(&pix);
return (PIX *)ERROR_PTR(""invalid colormap"", procName, NULL);
}


if (bps == 1) {
pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);
pixDestroy(&pix);
pix = pix1;
}
} else {
if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) {


if (tiffcomp == COMPRESSION_CCITTFAX3 ||
tiffcomp == COMPRESSION_CCITTFAX4 ||
tiffcomp == COMPRESSION_CCITTRLE ||
tiffcomp == COMPRESSION_CCITTRLEW) {
photometry = PHOTOMETRIC_MINISWHITE;
} else {
photometry = PHOTOMETRIC_MINISBLACK;
}
}
if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) ||
(d == 8 && photometry == PHOTOMETRIC_MINISWHITE))
pixInvert(pix, pix);
}

if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) {
if (orientation >= 1 && orientation <= 8) {
struct tiff_transform *transform = (read_oriented) ?
&tiff_partial_orientation_transforms[orientation - 1] :
&tiff_orientation_transforms[orientation - 1];
if (transform->vflip) pixFlipTB(pix, pix);
if (transform->hflip) pixFlipLR(pix, pix);
if (transform->rotate) {
PIX *oldpix = pix;
pix = pixRotate90(oldpix, transform->rotate);
pixDestroy(&oldpix);
}
}
}

text = NULL;
TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text);
if (text) pixSetText(pix, text);
return pix;
}",[133],"Leptonica before 1.80.0 allows a heap-based buffer over-read in pixReadFromTiffStream, related to tiffio.c."
206286," V4L2JpegEncodeAccelerator::JobRecord::JobRecord(
     scoped_refptr<VideoFrame> input_frame,
     scoped_refptr<VideoFrame> output_frame,
     int quality,
     int32_t task_id,
     BitstreamBuffer* exif_buffer)
     : input_frame(input_frame),
        output_frame(output_frame),
        quality(quality),
        task_id(task_id),
      output_shm(base::SharedMemoryHandle(), 0, true),   
       output_shm(base::subtle::PlatformSharedMemoryRegion(), 0, true),   
        exif_shm(nullptr) {
    if (exif_buffer) {
      exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),
                                              exif_buffer->size(), false));
     exif_offset = exif_buffer->offset();
   }
 }","[12, 11]","Inappropriate implementation in Omnibox in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to spoof the contents of the Omnibox via a crafted HTML page."
202403," INST_HANDLER (sbrx) {	 
  	int b = buf[0] & 0x7;
  	int r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);
	RAnalOp next_op;
 	RAnalOp next_op = {0};
  
 	avr_op_analyze (anal,
 			&next_op,
 			op->addr + op->size, buf + op->size, len - op->size,
 			cpu);
 	r_strbuf_fini (&next_op.esil);
 	op->jump = op->addr + next_op.size + 2;
 
 	op->cycles = 1;	 
 	ESIL_A (""%d,1,<<,r%d,&,"", b, r);			 
 	ESIL_A ((buf[1] & 0xe) == 0xc
 			? ""!,""		 
 			: ""!,!,"");	 
 	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	 
 }","[5, 4]",The avr_op_analyze() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.
201434," struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,
 		struct dentry *new_dir, const char *new_name)
  {
  	int error;
  	struct dentry *dentry = NULL, *trap;
	const char *old_name;
 	struct name_snapshot old_name;
  
  	trap = lock_rename(new_dir, old_dir);
  	 
 	if (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))
 		goto exit;
 	 
 	if (d_really_is_negative(old_dentry) || old_dentry == trap ||
 	    d_mountpoint(old_dentry))
 		goto exit;
 	dentry = lookup_one_len(new_name, new_dir, strlen(new_name));
 	 
  	if (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))
  		goto exit;
  
	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
 	take_dentry_name_snapshot(&old_name, old_dentry);
  
  	error = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),
  			      dentry, 0);
  	if (error) {
		fsnotify_oldname_free(old_name);
 		release_dentry_name_snapshot(&old_name);
  		goto exit;
  	}
  	d_move(old_dentry, dentry);
	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,
 	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,
  		d_is_dir(old_dentry),
  		NULL, old_dentry);
	fsnotify_oldname_free(old_name);
 	release_dentry_name_snapshot(&old_name);
  	unlock_rename(new_dir, old_dir);
  	dput(dentry);
  	return old_dentry;
 exit:
 	if (dentry && !IS_ERR(dentry))
 		dput(dentry);
 	unlock_rename(new_dir, old_dir);
 	return NULL;
 }","[7, 23, 29, 34, 38, 6, 22, 28, 33, 37]",Race condition in the fsnotify implementation in the Linux kernel through 4.12.4 allows local users to gain privileges or cause a denial of service (memory corruption) via a crafted application that leverages simultaneous execution of the inotify_handle_event and vfs_rename functions.
203172," http_splitheader(struct http *hp, int req)
 {
 	char *p, *q, **hh;
 	int n;
 	char buf[20];
 
 	CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);
 	if (req) {
 		memset(hp->req, 0, sizeof hp->req);
 		hh = hp->req;
 	} else {
 		memset(hp->resp, 0, sizeof hp->resp);
 		hh = hp->resp;
 	}
 
 	n = 0;
 	p = hp->rxbuf;
 
 	 
 	while (vct_islws(*p))
 		p++;
  	hh[n++] = p;
  	while (!vct_islws(*p))
  		p++;
	assert(!vct_iscrlf(*p));
 	assert(!vct_iscrlf(p));
  	*p++ = '\0';
  
  	 
  	while (vct_issp(*p))		 
  		p++;
	assert(!vct_iscrlf(*p));
 	assert(!vct_iscrlf(p));
  	hh[n++] = p;
  	while (!vct_islws(*p))
  		p++;
	if (vct_iscrlf(*p)) {
 	if (vct_iscrlf(p)) {
  		hh[n++] = NULL;
  		q = p;
  		p += vct_skipcrlf(p);
 		*q = '\0';
 	} else {
 		*p++ = '\0';
 		 
  		while (vct_issp(*p))		 
  			p++;
  		hh[n++] = p;
		while (!vct_iscrlf(*p))
 		while (!vct_iscrlf(p))
  			p++;
  		q = p;
  		p += vct_skipcrlf(p);
 		*q = '\0';
 	}
 	assert(n == 3);
  
  	while (*p != '\0') {
  		assert(n < MAX_HDR);
		if (vct_iscrlf(*p))
 		if (vct_iscrlf(p))
  			break;
  		hh[n++] = p++;
		while (*p != '\0' && !vct_iscrlf(*p))
 		while (*p != '\0' && !vct_iscrlf(p))
  			p++;
  		q = p;
  		p += vct_skipcrlf(p);
 		*q = '\0';
 	}
 	p += vct_skipcrlf(p);
 	assert(*p == '\0');
 
 	for (n = 0; n < 3 || hh[n] != NULL; n++) {
 		sprintf(buf, ""http[%2d] "", n);
 		vtc_dump(hp->vl, 4, buf, hh[n], -1);
 	}
 }","[26, 33, 38, 50, 61, 65, 25, 32, 37, 49, 60, 64]","Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request."
8325,"void Compute(OpKernelContext* ctx) override {
const Tensor& sorted_inputs_t = ctx->input(0);
const Tensor& values_t = ctx->input(1);


OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),
Status(error::INVALID_ARGUMENT,
""Leading dim_size of both tensors must match.""));


OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),
Status(error::INVALID_ARGUMENT,
""values tensor size must less than INT_MAX""));

Tensor* output_t;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));

if (output_t->dtype() == DT_INT32) {
OP_REQUIRES(ctx,
FastBoundsCheck(sorted_inputs_t.dim_size(1),
std::numeric_limits<int>::max()),
errors::InvalidArgument(""trailing dim_size must less than ""
""INT_MAX for int32 output type, was "",
sorted_inputs_t.dim_size(1)));
}

auto output = output_t->template flat<OutType>();
const auto sorted_inputs = sorted_inputs_t.template flat<T>();
const auto values = values_t.template flat<T>();
OP_REQUIRES_OK(
ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(
ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),
sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));
}",[6],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can read from outside of bounds of heap allocated data by sending specially crafted illegal arguments to `tf.raw_ops.UpperBound`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/searchsorted_op.cc#L85-L104) does not validate the rank of `sorted_input` argument. A similar issue occurs in `tf.raw_ops.LowerBound`. We have patched the issue in GitHub commit 42459e4273c2e47a3232cc16c4f4fff3b3a35c38. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
203191," int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
                      mbedtls_x509_crt *trust_ca,
                      mbedtls_x509_crl *ca_crl,
                      const mbedtls_x509_crt_profile *profile,
                      const char *cn, uint32_t *flags,
                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
                      void *p_vrfy )
 {
     size_t cn_len;
     int ret;
     int pathlen = 0, selfsigned = 0;
     mbedtls_x509_crt *parent;
     mbedtls_x509_name *name;
     mbedtls_x509_sequence *cur = NULL;
     mbedtls_pk_type_t pk_type;
 
     *flags = 0;
 
     if( profile == NULL )
     {
         ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
         goto exit;
     }
 
     if( cn != NULL )
     {
         name = &crt->subject;
         cn_len = strlen( cn );
 
         if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
         {
             cur = &crt->subject_alt_names;
 
             while( cur != NULL )
             {
                 if( cur->buf.len == cn_len &&
                     x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )
                     break;
 
                 if( cur->buf.len > 2 &&
                     memcmp( cur->buf.p, ""*."", 2 ) == 0 &&
                     x509_check_wildcard( cn, &cur->buf ) == 0 )
                 {
                     break;
                 }
 
                 cur = cur->next;
             }
 
             if( cur == NULL )
                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
         }
         else
         {
             while( name != NULL )
             {
                 if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )
                 {
                     if( name->val.len == cn_len &&
                         x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )
                         break;
 
                     if( name->val.len > 2 &&
                         memcmp( name->val.p, ""*."", 2 ) == 0 &&
                         x509_check_wildcard( cn, &name->val ) == 0 )
                         break;
                 }
 
                 name = name->next;
             }
 
             if( name == NULL )
                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
         }
     }
 
      
     pk_type = mbedtls_pk_get_type( &crt->pk );
 
     if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
         *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
 
     if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )
         *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
 
      
     for( parent = trust_ca; parent != NULL; parent = parent->next )
     {
         if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
             break;
     }
 
     if( parent != NULL )
     {
         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,
                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );
         if( ret != 0 )
             goto exit;
     }
     else
     {
          
         for( parent = crt->next; parent != NULL; parent = parent->next )
             if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )
                 break;
 
          
         if( parent != NULL )
         {
             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,
                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                 goto exit;
         }
         else
         {
             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,
                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );
             if( ret != 0 )
                 goto exit;
         }
      }
  
  exit:
      
     if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
         ret = MBEDTLS_ERR_X509_FATAL_ERROR;
 
      if( ret != 0 )
      {
          *flags = (uint32_t) -1;
         return( ret );
     }
 
     if( *flags != 0 )
         return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
 
     return( 0 );
 }","[125, 126, 127, 128]","ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected."
6133,"yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)
{
free(*param->value);
if (yylloc->first_line != -1) {
if (*param->data_node && (*param->data_node) == (*param->actual_node)) {
LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));
} else {
LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));
}
}
}",[4],"A double-free is present in libyang before v1.0-r1 in the function yyparse() when an organization field is not terminated. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution."
202304," static int msg_parse_fetch(struct ImapHeader *h, char *s)
 {
   char tmp[SHORT_STRING];
   char *ptmp = NULL;
 
   if (!s)
     return -1;
 
   while (*s)
   {
     SKIPWS(s);
 
     if (mutt_str_strncasecmp(""FLAGS"", s, 5) == 0)
     {
       s = msg_parse_flags(h, s);
       if (!s)
         return -1;
     }
     else if (mutt_str_strncasecmp(""UID"", s, 3) == 0)
     {
       s += 3;
       SKIPWS(s);
       if (mutt_str_atoui(s, &h->data->uid) < 0)
         return -1;
 
       s = imap_next_word(s);
     }
     else if (mutt_str_strncasecmp(""INTERNALDATE"", s, 12) == 0)
     {
       s += 12;
       SKIPWS(s);
       if (*s != '\""')
       {
         mutt_debug(1, ""bogus INTERNALDATE entry: %s\n"", s);
         return -1;
        }
        s++;
        ptmp = tmp;
      while (*s && *s != '\""')
       while (*s && (*s != '\""') && (ptmp != (tmp + sizeof(tmp) - 1)))
          *ptmp++ = *s++;
        if (*s != '\""')
          return -1;
       s++;  
       *ptmp = '\0';
       h->received = mutt_date_parse_imap(tmp);
     }
     else if (mutt_str_strncasecmp(""RFC822.SIZE"", s, 11) == 0)
     {
        s += 11;
        SKIPWS(s);
        ptmp = tmp;
      while (isdigit((unsigned char) *s))
       while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))
          *ptmp++ = *s++;
        *ptmp = '\0';
        if (mutt_str_atol(tmp, &h->content_length) < 0)
         return -1;
     }
     else if ((mutt_str_strncasecmp(""BODY"", s, 4) == 0) ||
              (mutt_str_strncasecmp(""RFC822.HEADER"", s, 13) == 0))
     {
        
       return -2;
     }
     else if (*s == ')')
       s++;  
     else if (*s)
     {
        
       imap_error(""msg_parse_fetch"", s);
       return -1;
     }
   }
 
   return 0;
 }","[40, 54, 39, 53]",An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/message.c has a stack-based buffer overflow for a FETCH response with a long RFC822.SIZE field.
207363," static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
 {
  if (parcel == NULL) {
  return NULL;
  }
 
  
      android::Parcel* p = android::parcelForJavaObject(env, parcel);
  
     const size_t size = p->readInt32();
     const void* regionData = p->readInplace(size);
     if (regionData == NULL) {
         return NULL;
     }
      SkRegion* region = new SkRegion;
    size_t size = p->readInt32();
    region->readFromMemory(p->readInplace(size), size);
     region->readFromMemory(regionData, size);
  
      return reinterpret_cast<jlong>(region);
  }","[10, 11, 12, 13, 14, 18, 16, 17]","The Region_createFromParcel function in core/jni/android/graphics/Region.cpp in Region in Android before 5.1.1 LMY48M does not check the return values of certain read operations, which allows attackers to execute arbitrary code via an application that sends a crafted message to a service, aka internal bug 21585255."
1154,"pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,
int timeout) {
if (!Available()) {

return ::waitpid(pid, stat_loc, options);
}

int id = GetId();
Lock lock(g_procs[id].m_procMutex);

fprintf(g_procs[id].m_fout, ""waitpid\n%"" PRId64 "" %d %d\n"", (int64_t)pid, options,
timeout);
fflush(g_procs[id].m_fout);

char buf[BUFFER_SIZE];
read_buf(g_procs[id].m_fin, buf);
if (!buf[0]) return -1;
int64_t ret;
int stat;
sscanf(buf, ""%"" PRId64 "" %d"", &ret, &stat);
*stat_loc = stat;
if (ret < 0) {
read_buf(g_procs[id].m_fin, buf);
sscanf(buf, ""%d"", &errno);
}
return (pid_t)ret;
}","[11, 12, 15, 16, 17, 20, 23, 24]",CRLF injection vulnerability in the LightProcess protocol implementation in hphp/util/light-process.cpp in Facebook HipHop Virtual Machine (HHVM) before 2.4.2 allows remote attackers to execute arbitrary commands by entering a \n (newline) character before the end of a string.
208192,"  bool InputWindowInfo::isTrustedOverlay() const {
      return layoutParamsType == TYPE_INPUT_METHOD
              || layoutParamsType == TYPE_INPUT_METHOD_DIALOG
              || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY
             || layoutParamsType == TYPE_STATUS_BAR
             || layoutParamsType == TYPE_NAVIGATION_BAR
              || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;
  }","[5, 6]","The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796."
9175,"static int tcp_mtu_probe(struct sock *sk)
{
struct inet_connection_sock *icsk = inet_csk(sk);
struct tcp_sock *tp = tcp_sk(sk);
struct sk_buff *skb, *nskb, *next;
struct net *net = sock_net(sk);
int probe_size;
int size_needed;
int copy, len;
int mss_now;
int interval;






if (likely(!icsk->icsk_mtup.enabled ||
icsk->icsk_mtup.probe_size ||
inet_csk(sk)->icsk_ca_state != TCP_CA_Open ||
tp->snd_cwnd < 11 ||
tp->rx_opt.num_sacks || tp->rx_opt.dsack))
return -1;





mss_now = tcp_current_mss(sk);
probe_size = tcp_mtu_to_mss(sk, (icsk->icsk_mtup.search_high +
icsk->icsk_mtup.search_low) >> 1);
size_needed = probe_size + (tp->reordering + 1) * tp->mss_cache;
interval = icsk->icsk_mtup.search_high - icsk->icsk_mtup.search_low;




if (probe_size > tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_high) ||
interval < net->ipv4.sysctl_tcp_probe_threshold) {



tcp_mtu_check_reprobe(sk);
return -1;
}


if (tp->write_seq - tp->snd_nxt < size_needed)
return -1;

if (tp->snd_wnd < size_needed)
return -1;
if (after(tp->snd_nxt + size_needed, tcp_wnd_end(tp)))
return 0;


if (tcp_packets_in_flight(tp) + 2 > tp->snd_cwnd) {
if (!tcp_packets_in_flight(tp))
return -1;
else
return 0;
}

if (!tcp_can_coalesce_send_queue_head(sk, probe_size))
return -1;


nskb = sk_stream_alloc_skb(sk, probe_size, GFP_ATOMIC, false);
if (!nskb)
return -1;
sk->sk_wmem_queued += nskb->truesize;
sk_mem_charge(sk, nskb->truesize);

skb = tcp_send_head(sk);

TCP_SKB_CB(nskb)->seq = TCP_SKB_CB(skb)->seq;
TCP_SKB_CB(nskb)->end_seq = TCP_SKB_CB(skb)->seq + probe_size;
TCP_SKB_CB(nskb)->tcp_flags = TCPHDR_ACK;
TCP_SKB_CB(nskb)->sacked = 0;
nskb->csum = 0;
nskb->ip_summed = CHECKSUM_PARTIAL;

tcp_insert_write_queue_before(nskb, skb, sk);
tcp_highest_sack_replace(sk, skb, nskb);

len = 0;
tcp_for_write_queue_from_safe(skb, next, sk) {
copy = min_t(int, skb->len, probe_size - len);
skb_copy_bits(skb, 0, skb_put(nskb, copy), copy);

if (skb->len <= copy) {


TCP_SKB_CB(nskb)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;



TCP_SKB_CB(nskb)->eor = TCP_SKB_CB(skb)->eor;
tcp_skb_collapse_tstamp(nskb, skb);
tcp_unlink_write_queue(skb, sk);
sk_wmem_free_skb(sk, skb);
} else {
TCP_SKB_CB(nskb)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags &
~(TCPHDR_FIN|TCPHDR_PSH);
if (!skb_shinfo(skb)->nr_frags) {
skb_pull(skb, copy);
} else {
__pskb_trim_head(skb, copy);
tcp_set_skb_tso_segs(skb, mss_now);
}
TCP_SKB_CB(skb)->seq += copy;
}

len += copy;

if (len >= probe_size)
break;
}
tcp_init_tso_segs(nskb, nskb->len);




if (!tcp_transmit_skb(sk, nskb, 1, GFP_ATOMIC)) {


tp->snd_cwnd--;
tcp_event_new_data_sent(sk, nskb);

icsk->icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb->len);
tp->mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)->seq;
tp->mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)->end_seq;

return 1;
}

return -1;
}",[68],"An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper update of sock reference in TCP pacing can lead to memory/netns leak, which can be used by remote clients."
5704,"void SavePayload(size_t handle, uint32_t *payload, uint32_t index)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return;

uint32_t *MP4buffer = NULL;
if (index < mp4->indexcount && mp4->mediafp && payload)
{
LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);
fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);
}
return;
}","[3, 4, 6, 7, 9, 10, 12]",GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.
207465," static inline int btif_hl_select_wake_reset(void){
 
      char sig_recv = 0;
  
      BTIF_TRACE_DEBUG(""btif_hl_select_wake_reset"");
    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
      return(int)sig_recv;
  }","[7, 6]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
9111,"de265_error video_usability_information::read(error_queue* errqueue, bitreader* br,
const seq_parameter_set* sps)
{
int vlc;




aspect_ratio_info_present_flag = get_bits(br, 1);
if (aspect_ratio_info_present_flag) {
int aspect_ratio_idc = get_bits(br, 8);
if (aspect_ratio_idc <= NUM_SAR_PRESETS) {
sar_width = sar_presets[aspect_ratio_idc][0];
sar_height = sar_presets[aspect_ratio_idc][1];
}
else if (aspect_ratio_idc == EXTENDED_SAR) {
sar_width = get_bits(br, 16);
sar_height = get_bits(br, 16);
}
else {
sar_width = 0;
sar_height = 0;
}
}
else {
sar_width = 0;
sar_height = 0;
}




overscan_info_present_flag = get_bits(br, 1);
if (overscan_info_present_flag) {
overscan_appropriate_flag = get_bits(br, 1);
}




{
video_format = VideoFormat_Unspecified;
video_full_range_flag = false;
colour_primaries = 2;
transfer_characteristics = 2;
matrix_coeffs = 2;
}

video_signal_type_present_flag = get_bits(br, 1);
if (video_signal_type_present_flag) {
int video_format_idc = get_bits(br, 3);
if (video_format_idc > 5) {
video_format_idc = VideoFormat_Unspecified;
}
video_format = (VideoFormat)video_format_idc;

video_full_range_flag = get_bits(br, 1);

colour_description_present_flag = get_bits(br, 1);
if (colour_description_present_flag) {
colour_primaries = get_bits(br, 8);
if (colour_primaries == 0 ||
colour_primaries == 3 ||
colour_primaries >= 11) {
colour_primaries = 2;
}

transfer_characteristics = get_bits(br, 8);
if (transfer_characteristics == 0 ||
transfer_characteristics == 3 ||
transfer_characteristics >= 18) {
transfer_characteristics = 2;
}

matrix_coeffs = get_bits(br, 8);

if (matrix_coeffs >= 11) {
matrix_coeffs = 2;
}
}
}




chroma_loc_info_present_flag = get_bits(br, 1);
if (chroma_loc_info_present_flag) {
READ_VLC(chroma_sample_loc_type_top_field, uvlc);
READ_VLC(chroma_sample_loc_type_bottom_field, uvlc);
}
else {
chroma_sample_loc_type_top_field = 0;
chroma_sample_loc_type_bottom_field = 0;
}

neutral_chroma_indication_flag = get_bits(br, 1);
field_seq_flag = get_bits(br, 1);
frame_field_info_present_flag = get_bits(br, 1);




default_display_window_flag = get_bits(br, 1);
if (default_display_window_flag) {
READ_VLC(def_disp_win_left_offset, uvlc);
READ_VLC(def_disp_win_right_offset, uvlc);
READ_VLC(def_disp_win_top_offset, uvlc);
READ_VLC(def_disp_win_bottom_offset, uvlc);
}
else {
def_disp_win_left_offset = 0;
def_disp_win_right_offset = 0;
def_disp_win_top_offset = 0;
def_disp_win_bottom_offset = 0;
}




vui_timing_info_present_flag = get_bits(br, 1);
if (vui_timing_info_present_flag) {
vui_num_units_in_tick = get_bits(br, 32);
vui_time_scale = get_bits(br, 32);

vui_poc_proportional_to_timing_flag = get_bits(br, 1);
if (vui_poc_proportional_to_timing_flag) {
READ_VLC_OFFSET(vui_num_ticks_poc_diff_one, uvlc, 1);
}



vui_hrd_parameters_present_flag = get_bits(br, 1);
if (vui_hrd_parameters_present_flag) {
de265_error err;
err = hrd_parameters(errqueue, br, sps);
}
}



bitstream_restriction_flag = get_bits(br,1);
if (bitstream_restriction_flag) {
tiles_fixed_structure_flag = get_bits(br,1);
motion_vectors_over_pic_boundaries_flag = get_bits(br,1);
restricted_ref_pic_lists_flag = get_bits(br,1);

READ_VLC(min_spatial_segmentation_idc, uvlc);
if (min_spatial_segmentation_idc > 4095) {
errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);
min_spatial_segmentation_idc = 0;
}

READ_VLC(max_bytes_per_pic_denom, uvlc);
if (max_bytes_per_pic_denom > 16) {
errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);
max_bytes_per_pic_denom = 2;
}

READ_VLC(max_bits_per_min_cu_denom, uvlc);
if (max_bits_per_min_cu_denom > 16) {
errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);
max_bits_per_min_cu_denom = 1;
}

READ_VLC(log2_max_mv_length_horizontal, uvlc);
if (log2_max_mv_length_horizontal > 15) {
errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);
log2_max_mv_length_horizontal = 15;
}

READ_VLC(log2_max_mv_length_vertical, uvlc);
if (log2_max_mv_length_vertical > 15) {
errqueue->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);
log2_max_mv_length_vertical = 15;
}
}
else {
tiles_fixed_structure_flag = false;
motion_vectors_over_pic_boundaries_flag = true;
restricted_ref_pic_lists_flag = false;

min_spatial_segmentation_idc = 0;
max_bytes_per_pic_denom   = 2;
max_bits_per_min_cu_denom = 1;
log2_max_mv_length_horizontal = 15;
log2_max_mv_length_vertical   = 15;
}



return DE265_OK;
}",[141],Heap-based Buffer Overflow in GitHub repository strukturag/libde265 prior to and including 1.0.8. The fix is established in commit 8e89fe0e175d2870c39486fdd09250b230ec10b8 but does not yet belong to an official release.
204888," void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
 {
     String stepString = String::number(m_parameters.step);
     String stepBaseString = String::number(m_parameters.stepBase, 11, WTF::TruncateTrailingZeros);
     IntRect anchorRectInScreen = m_chromeClient->rootViewToScreen(m_parameters.anchorRectInRootView);
     String todayLabelString;
     String otherDateLabelString;
     if (m_parameters.type == InputTypeNames::month) {
         todayLabelString = locale().queryString(WebLocalizedString::ThisMonthButtonLabel);
         otherDateLabelString = locale().queryString(WebLocalizedString::OtherMonthLabel);
     } else if (m_parameters.type == InputTypeNames::week) {
         todayLabelString = locale().queryString(WebLocalizedString::ThisWeekButtonLabel);
         otherDateLabelString = locale().queryString(WebLocalizedString::OtherWeekLabel);
     } else {
         todayLabelString = locale().queryString(WebLocalizedString::CalendarToday);
         otherDateLabelString = locale().queryString(WebLocalizedString::OtherDateLabel);
     }
 
     addString(""<!DOCTYPE html><head><meta charset='UTF-8'><style>\n"", data);
     data->append(Platform::current()->loadResource(""pickerCommon.css""));
     data->append(Platform::current()->loadResource(""pickerButton.css""));
     data->append(Platform::current()->loadResource(""suggestionPicker.css""));
     data->append(Platform::current()->loadResource(""calendarPicker.css""));
     addString(""</style></head><body><div id=main>Loading...</div><script>\n""
         ""window.dialogArguments = {\n"", data);
     addProperty(""anchorRectInScreen"", anchorRectInScreen, data);
     addProperty(""min"", valueToDateTimeString(m_parameters.minimum, m_parameters.type), data);
     addProperty(""max"", valueToDateTimeString(m_parameters.maximum, m_parameters.type), data);
     addProperty(""step"", stepString, data);
     addProperty(""stepBase"", stepBaseString, data);
     addProperty(""required"", m_parameters.required, data);
     addProperty(""currentValue"", valueToDateTimeString(m_parameters.doubleValue, m_parameters.type), data);
     addProperty(""locale"", m_parameters.locale.string(), data);
      addProperty(""todayLabel"", todayLabelString, data);
      addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
      addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
     addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
     addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
     addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
      addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
      addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
      addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);
     addProperty(""isLocaleRTL"", m_locale->isRTL(), data);
     addProperty(""isRTL"", m_parameters.isAnchorElementRTL, data);
     addProperty(""mode"", m_parameters.type.string(), data);
     if (m_parameters.suggestions.size()) {
         Vector<String> suggestionValues;
         Vector<String> localizedSuggestionValues;
         Vector<String> suggestionLabels;
         for (unsigned i = 0; i < m_parameters.suggestions.size(); i++) {
             suggestionValues.append(valueToDateTimeString(m_parameters.suggestions[i].value, m_parameters.type));
             localizedSuggestionValues.append(m_parameters.suggestions[i].localizedValue);
             suggestionLabels.append(m_parameters.suggestions[i].label);
         }
         addProperty(""suggestionValues"", suggestionValues, data);
         addProperty(""localizedSuggestionValues"", localizedSuggestionValues, data);
         addProperty(""suggestionLabels"", suggestionLabels, data);
         addProperty(""inputWidth"", static_cast<unsigned>(m_parameters.anchorRectInRootView.width()), data);
         addProperty(""showOtherDateEntry"", RenderTheme::theme().supportsCalendarPicker(m_parameters.type), data);
         addProperty(""otherDateLabel"", otherDateLabelString, data);
         addProperty(""suggestionHighlightColor"", RenderTheme::theme().activeListBoxSelectionBackgroundColor().serialized(), data);
         addProperty(""suggestionHighlightTextColor"", RenderTheme::theme().activeListBoxSelectionForegroundColor().serialized(), data);
     }
     addString(""}\n"", data);
 
     data->append(Platform::current()->loadResource(""pickerCommon.js""));
     data->append(Platform::current()->loadResource(""suggestionPicker.js""));
     data->append(Platform::current()->loadResource(""calendarPicker.js""));
     addString(""</script></body>\n"", data);
 }","[37, 38, 39]","The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name."
9784,"static void mark_ip_in_table(uint8_t d)
{
#if (debug_dhcps)   
printf(""\r\nmark ip %d\r\n"",d);
#endif	
xSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);
if (0 < d && d <= 32) {
ip_table.ip_range[0] = MARK_RANGE1_IP_BIT(ip_table, d);
#if (debug_dhcps)		
printf(""\r\n ip_table.ip_range[0] = 0x%x\r\n"",ip_table.ip_range[0]);
#endif	
} else if (32 < d && d <= 64) {
ip_table.ip_range[1] = MARK_RANGE2_IP_BIT(ip_table, (d - 32));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[1] = 0x%x\r\n"",ip_table.ip_range[1]);
#endif	
} else if (64 < d && d <= 96) {
ip_table.ip_range[2] = MARK_RANGE3_IP_BIT(ip_table, (d - 64));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[2] = 0x%x\r\n"",ip_table.ip_range[2]);
#endif	
} else if (96 < d && d <= 128) {
ip_table.ip_range[3] = MARK_RANGE4_IP_BIT(ip_table, (d - 96));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[3] = 0x%x\r\n"",ip_table.ip_range[3]);
#endif	
} else if(128 < d && d <= 160) {
ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);
#if (debug_dhcps)		
printf(""\r\n ip_table.ip_range[4] = 0x%x\r\n"",ip_table.ip_range[4]);
#endif	
} else if (160 < d && d <= 192) {
ip_table.ip_range[5] = MARK_RANGE6_IP_BIT(ip_table, (d - 160));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[5] = 0x%x\r\n"",ip_table.ip_range[5]);
#endif	
} else if (192 < d && d <= 224) {
ip_table.ip_range[6] = MARK_RANGE7_IP_BIT(ip_table, (d - 192));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[6] = 0x%x\r\n"",ip_table.ip_range[6]);
#endif	
} else if (224 < d) {
ip_table.ip_range[7] = MARK_RANGE8_IP_BIT(ip_table, (d - 224));
#if (debug_dhcps)	
printf(""\r\n ip_table.ip_range[7] = 0x%x\r\n"",ip_table.ip_range[7]);
#endif	
} else {
printf(""\r\n Request ip over the range(1-128) \r\n"");
}
xSemaphoreGive(dhcps_ip_table_semaphore);

}",[28],component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.
7999,"int PackMachBase<T>::canUnpack()
{
unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];
fi->seek(0, SEEK_SET);
fi->readx(&mhdri, sizeof(mhdri));

if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic
||  my_cputype   !=mhdri.cputype
||  my_filetype  !=mhdri.filetype
)
return false;
my_cpusubtype = mhdri.cpusubtype;

unsigned const ncmds = mhdri.ncmds;
int headway = (int)mhdri.sizeofcmds;


if ((2 == ncmds
&& headway < (int)(sizeof(Mach_segment_command) + 4*4))
||  (3 <= ncmds
&& headway < (int)(3 * sizeof(Mach_segment_command)
+ sizeof(Mach_main_command)))) {
infoWarning(""Mach_header.sizeofcmds = %d too small"", headway);
throwCantUnpack(""file corrupted"");
}
sz_mach_headers = headway + sizeof(mhdri);
if (2048 < headway) {
infoWarning(""Mach_header.sizeofcmds(%d) > 2048"", headway);
}
rawmseg_buf.alloc(mhdri.sizeofcmds);
rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();
fi->readx(rawmseg, mhdri.sizeofcmds);

Mach_segment_command const *ptrTEXT = nullptr;
upx_uint64_t rip = 0;
unsigned style = 0;
off_t offLINK = 0;
unsigned pos_next = 0;
unsigned nseg = 0;
Mach_command const *ptr = (Mach_command const *)rawmseg;
for (unsigned j= 0; j < ncmds;
ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {
if ((unsigned)headway < ptr->cmdsize) {
infoWarning(""bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx"",
j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
(unsigned long) file_size, (unsigned long)ptr->cmdsize);
throwCantUnpack(""file corrupted"");
}
if (lc_seg == ptr->cmd) {
Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;
if ((unsigned long)file_size < segptr->filesize
||  (unsigned long)file_size < segptr->fileoff
||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {
infoWarning(""bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx""
""  filesize=0x%lx  fileoff=0x%lx"",
j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
(unsigned long) file_size, (unsigned long)ptr->cmdsize,
(unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);
throwCantUnpack(""file corrupted"");
}
++nseg;
if (!strcmp(""__XHDR"", segptr->segname)) {

style = 391;
}
if (!strcmp(""__TEXT"", segptr->segname)) {
ptrTEXT = segptr;
style = 391;
}
if (!strcmp(""UPX_DATA"", segptr->segname)) {

style = 392;
}
if (!strcmp(""__LINKEDIT"", segptr->segname)) {
offLINK = segptr->fileoff;
if (segptr->filesize == blankLINK) {
style = 395;
}
if (offLINK < (off_t) pos_next) {
offLINK = pos_next;
}
}
pos_next = segptr->filesize + segptr->fileoff;
if ((headway -= ptr->cmdsize) < 0) {
infoWarning(""Mach_command[%u]{@%lu}.cmdsize = %u"", j,
(unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),
(unsigned)ptr->cmdsize);
throwCantUnpack(""sum(.cmdsize) exceeds .sizeofcmds"");
}
}
else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {
rip = entryVMA = threadc_getPC(ptr);
}
}
if (3==nseg && 395 != style) {
style = 392;
}
if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) {
offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;
}
if (0 == style || 0 == offLINK) {
return false;
}

int const small = 32 + sizeof(overlay_offset);
unsigned bufsize = 4096;
if (391 == style) {
fi->seek(offLINK - bufsize, SEEK_SET);
} else
if (392 == style) {
if (MH_DYLIB == my_filetype) {
fi->seek(fi->st_size() - bufsize, SEEK_SET);
}
else {
if ((off_t)bufsize > (fi->st_size() - offLINK)) {
bufsize = fi->st_size() - offLINK;
}
fi->seek(offLINK, SEEK_SET);
}
} else
if (395 == style) {
fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);
}
MemBuffer buf(bufsize);

fi->readx(buf, bufsize);
int i = bufsize;
while (i > small && 0 == buf[--i]) { }
i -= small;

if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {


upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;
if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {
fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);
fi->readx(buf, bufsize);
unsigned char const *b = &buf[0];
unsigned disp = *(TE32 const *)&b[1];

if (0xe8==b[0] && disp < bufsize
&&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {
unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];
if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {
struct b_info const *bptr = (struct b_info const *)&b[11+disp];


if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {
b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);

overlay_offset = *(TE32 const *)(32 + b);
if (overlay_offset < 0x1000) {
return true;
}
overlay_offset = 0;
}
}
}
}
if (391==style) {
TE32 const *uptr = (TE32 const *)&buf[bufsize];
while (0==*--uptr)           ;
overlay_offset = *uptr;
if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {
return true;
}
overlay_offset = 0;
return false;
}
if (392==style) {
overlay_offset = 0x100c;



fi->seek(overlay_offset, SEEK_SET);
fi->readx(buf, bufsize);
struct p_info const *const p_ptr = (struct p_info const *)&buf[0];
struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);
TE32 const *uptr = (TE32 const *)(1+ b_ptr);
if (b_ptr->sz_unc < 0x4000
&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
unsigned const method = b_ptr->b_method;
if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)
&&  (0xff>>2)==(uptr[0] >> (2+ 24))
&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {
return true;
}
unsigned const magic = get_te32(1+ (char const *)uptr);
if ((M_NRV2B_8 == method || M_NRV2E_8 == method)
&& 0xfc==(0xfc & uptr[0])
&&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {
return true;
}

}

overlay_offset = 0;



fi->seek(offLINK - 0x1000, SEEK_SET);
fi->readx(buf, 0x1000);
unsigned const *const lo = (unsigned const *)&buf[0];
unsigned const *p;
for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {
overlay_offset  = *(TE32 const *)p;
if ((off_t)overlay_offset < offLINK) {
overlay_offset = ((char const *)p - (char const *)lo) +
(offLINK - 0x1000) - overlay_offset + sizeof(l_info);
fi->seek(overlay_offset, SEEK_SET);
fi->readx(buf, bufsize);
if (b_ptr->sz_unc < 0x4000
&&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
return true;
}
}
}
}
}

overlay_offset = 0;
int l = ph.buf_offset + ph.getPackHeaderSize();
if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {
overlay_offset = get_te32(buf + i + l);
}
if (       overlay_offset < sz_mach_headers
||  (off_t)overlay_offset >= file_size) {
infoWarning(""file corrupted"");
MemBuffer buf2(umin(1<<14, file_size));
fi->seek(sz_mach_headers, SEEK_SET);
fi->readx(buf2, buf2.getSize());
unsigned const *p = (unsigned const *)&buf2[0];
unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];
for (; p <= e_buf2; ++p)
if (   0==p[0]
&&     0!=p[1]
&&  p[2]==p[1]
&&  (unsigned)file_size < get_te32(&p[1])
&&  sz_mach_headers==get_te32(&p[3])
) {
overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;
if (!(3&overlay_offset
||        overlay_offset < sz_mach_headers
|| (off_t)overlay_offset >= file_size)) {
infoWarning(""attempting recovery, overlay_offset = %#x"", overlay_offset);
return true;
}
}
throwCantUnpack(""file corrupted"");
}
return true;
}",[30],"An assertion abort was found in upx MemBuffer::alloc() in mem.cpp, in version UPX 4.0.0. The flow allows attackers to cause a denial of service (abort) via a crafted file."
206009," void AutofillPopupBaseView::DoShow() {
   const bool initialize_widget = !GetWidget();
   if (initialize_widget) {
     if (parent_widget_)
       parent_widget_->AddObserver(this);
 
     views::Widget* widget = new views::Widget;
     views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);
      params.delegate = this;
      params.parent = parent_widget_ ? parent_widget_->GetNativeView()
                                     : delegate_->container_view();
    AddExtraInitParams(&params);
      
     params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
     params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
      widget->Init(params);
    std::unique_ptr<views::View> wrapper = CreateWrapperView();
    if (wrapper)
      widget->SetContentsView(wrapper.release());
      widget->AddObserver(this);
  
     widget->SetVisibilityAnimationTransition(views::Widget::ANIMATE_HIDE);
 
     show_time_ = base::Time::Now();
   }
 
   GetWidget()->GetRootView()->SetBorder(CreateBorder());
   DoUpdateBoundsAndRedrawPopup();
   GetWidget()->Show();
 
   if (initialize_widget)
     views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
 }","[13, 14, 15, 12, 17, 18, 19]","Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android incorrectly allowed reentrance of FrameView::updateLifecyclePhasesInternal(), which allowed a remote attacker to perform an out of bounds memory read via crafted HTML pages."
198513,"   cid_parse_font_matrix( CID_Face     face,
                          CID_Parser*  parser )
   {
     CID_FaceDict  dict;
     FT_Face       root = (FT_Face)&face->root;
     FT_Fixed      temp[6];
     FT_Fixed      temp_scale;
 
 
     if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )
      {
        FT_Matrix*  matrix;
        FT_Vector*  offset;
       FT_Int      result;
  
  
        dict   = face->cid.font_dicts + parser->num_dict;
        matrix = &dict->font_matrix;
        offset = &dict->font_offset;
  
      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );
       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
 
       if ( result < 6 )
         return FT_THROW( Invalid_File_Format );
  
        temp_scale = FT_ABS( temp[3] );
  
       if ( temp_scale == 0 )
       {
         FT_ERROR(( ""cid_parse_font_matrix: invalid font matrix\n"" ));
         return FT_THROW( Invalid_File_Format );
       }
 
         
         
         
         temp[5] = FT_DivFix( temp[5], temp_scale );
         temp[3] = 0x10000L;
       }
 
       matrix->xx = temp[0];
       matrix->yx = temp[1];
       matrix->xy = temp[2];
       matrix->yy = temp[3];
          temp[2] = FT_DivFix( temp[2], temp_scale );
          temp[4] = FT_DivFix( temp[4], temp_scale );
          temp[5] = FT_DivFix( temp[5], temp_scale );
        temp[3] = 0x10000L;
         temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;
        }","[14, 22, 23, 24, 25, 29, 30, 31, 32, 33, 34, 50, 21, 49]","The (1) t1_parse_font_matrix function in type1/t1load.c, (2) cid_parse_font_matrix function in cid/cidload.c, (3) t42_parse_font_matrix function in type42/t42parse.c, and (4) ps_parser_load_field function in psaux/psobjs.c in FreeType before 2.5.4 do not check return values, which allows remote attackers to cause a denial of service (uninitialized memory access and application crash) or possibly have unspecified other impact via a crafted font."
199744," static struct rds_connection *__rds_conn_create(struct net *net,
 						__be32 laddr, __be32 faddr,
 				       struct rds_transport *trans, gfp_t gfp,
 				       int is_outgoing)
 {
 	struct rds_connection *conn, *parent = NULL;
 	struct hlist_head *head = rds_conn_bucket(laddr, faddr);
 	struct rds_transport *loop_trans;
 	unsigned long flags;
 	int ret;
 
 	rcu_read_lock();
 	conn = rds_conn_lookup(net, head, laddr, faddr, trans);
 	if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
 	    laddr == faddr && !is_outgoing) {
 		 
 		parent = conn;
 		conn = parent->c_passive;
 	}
 	rcu_read_unlock();
 	if (conn)
 		goto out;
 
 	conn = kmem_cache_zalloc(rds_conn_slab, gfp);
 	if (!conn) {
 		conn = ERR_PTR(-ENOMEM);
 		goto out;
 	}
 
 	INIT_HLIST_NODE(&conn->c_hash_node);
 	conn->c_laddr = laddr;
 	conn->c_faddr = faddr;
 	spin_lock_init(&conn->c_lock);
 	conn->c_next_tx_seq = 1;
 	rds_conn_net_set(conn, net);
 
 	init_waitqueue_head(&conn->c_waitq);
 	INIT_LIST_HEAD(&conn->c_send_queue);
 	INIT_LIST_HEAD(&conn->c_retrans);
 
 	ret = rds_cong_get_maps(conn);
 	if (ret) {
 		kmem_cache_free(rds_conn_slab, conn);
 		conn = ERR_PTR(ret);
 		goto out;
 	}
 
 	 
 	loop_trans = rds_trans_get_preferred(net, faddr);
 	if (loop_trans) {
 		rds_trans_put(loop_trans);
 		conn->c_loopback = 1;
 		if (is_outgoing && trans->t_prefer_loopback) {
 			 
 			trans = &rds_loop_transport;
  		}
  	}
  
	if (trans == NULL) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(-ENODEV);
		goto out;
	}
  	conn->c_trans = trans;
  
  	ret = trans->conn_alloc(conn, gfp);
 	if (ret) {
 		kmem_cache_free(rds_conn_slab, conn);
 		conn = ERR_PTR(ret);
 		goto out;
 	}
 
 	atomic_set(&conn->c_state, RDS_CONN_DOWN);
 	conn->c_send_gen = 0;
 	conn->c_outgoing = (is_outgoing ? 1 : 0);
 	conn->c_reconnect_jiffies = 0;
 	INIT_DELAYED_WORK(&conn->c_send_w, rds_send_worker);
 	INIT_DELAYED_WORK(&conn->c_recv_w, rds_recv_worker);
 	INIT_DELAYED_WORK(&conn->c_conn_w, rds_connect_worker);
 	INIT_WORK(&conn->c_down_w, rds_shutdown_worker);
 	mutex_init(&conn->c_cm_lock);
 	conn->c_flags = 0;
 
 	rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
 	  conn, &laddr, &faddr,
 	  trans->t_name ? trans->t_name : ""[unknown]"",
 	  is_outgoing ? ""(outgoing)"" : """");
 
 	 
 	spin_lock_irqsave(&rds_conn_lock, flags);
 	if (parent) {
 		 
 		if (parent->c_passive) {
 			trans->conn_free(conn->c_transport_data);
 			kmem_cache_free(rds_conn_slab, conn);
 			conn = parent->c_passive;
 		} else {
 			parent->c_passive = conn;
 			rds_cong_add_conn(conn);
 			rds_conn_count++;
 		}
 	} else {
 		 
 		struct rds_connection *found;
 
 		found = rds_conn_lookup(net, head, laddr, faddr, trans);
 		if (found) {
 			trans->conn_free(conn->c_transport_data);
 			kmem_cache_free(rds_conn_slab, conn);
 			conn = found;
 		} else {
 			hlist_add_head_rcu(&conn->c_hash_node, head);
 			rds_cong_add_conn(conn);
 			rds_conn_count++;
 		}
 	}
 	spin_unlock_irqrestore(&rds_conn_lock, flags);
 
 out:
 	return conn;
 }","[59, 60, 61, 62, 63]",Race condition in the rds_sendmsg function in net/rds/sendmsg.c in the Linux kernel before 4.3.3 allows local users to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by using a socket that was not properly bound.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2015-6937.
207330,"  xsltNumberFormatGetAnyLevel(xsltTransformContextPtr context,
  			    xmlNodePtr node,
  			    xsltCompMatchPtr countPat,
  			    xsltCompMatchPtr fromPat,
			    double *array,
			    xmlDocPtr doc,
			    xmlNodePtr elem)
 			    double *array)
  {
      int amount = 0;
      int cnt = 0;
     xmlNodePtr cur;
 
      
     switch (node->type) {
 	case XML_ELEMENT_NODE:
 	    cur = node;
 	    break;
 	case XML_ATTRIBUTE_NODE:
 	    cur = ((xmlAttrPtr) node)->parent;
 	    break;
 	case XML_TEXT_NODE:
 	case XML_PI_NODE:
 	case XML_COMMENT_NODE:
 	    cur = node->parent;
 	    break;
 	default:
 	    cur = NULL;
 	    break;
     }
  
      while (cur != NULL) {
  	 
	if (countPat == NULL) {
	    if ((node->type == cur->type) &&
		 
		xmlStrEqual(node->name, cur->name)) {
		    if ((node->ns == cur->ns) ||
		        ((node->ns != NULL) &&
			 (cur->ns != NULL) &&
		         (xmlStrEqual(node->ns->href,
		             cur->ns->href) )))
		        cnt++;
	    }
	} else {
	    if (xsltTestCompMatchList(context, cur, countPat))
		cnt++;
	}
 	if (xsltTestCompMatchCount(context, cur, countPat, node))
 	    cnt++;
  	if ((fromPat != NULL) &&
  	    xsltTestCompMatchList(context, cur, fromPat)) {
  	    break;  
 	}
 
 	 
 	if ((cur->type == XML_DOCUMENT_NODE) ||
 #ifdef LIBXML_DOCB_ENABLED
             (cur->type == XML_DOCB_DOCUMENT_NODE) ||
 #endif
             (cur->type == XML_HTML_DOCUMENT_NODE))
 	    break;  
 
 	while ((cur->prev != NULL) && ((cur->prev->type == XML_DTD_NODE) ||
 	       (cur->prev->type == XML_XINCLUDE_START) ||
 	       (cur->prev->type == XML_XINCLUDE_END)))
 	    cur = cur->prev;
 	if (cur->prev != NULL) {
 	    for (cur = cur->prev; cur->last != NULL; cur = cur->last);
 	} else {
 	    cur = cur->parent;
 	}
 
     }
 
     array[amount++] = (double) cnt;
 
     return(amount);
 }","[8, 49, 50, 5, 6, 7, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
205751,"  void PrintWebViewHelper::OnPrintForPrintPreview(
      const base::DictionaryValue& job_settings) {
   CHECK_LE(ipc_nesting_level_, 1);
    if (prep_frame_view_)
      return;
 
   if (!render_view()->GetWebView())
     return;
   blink::WebFrame* main_frame = render_view()->GetWebView()->mainFrame();
   if (!main_frame)
     return;
 
   blink::WebDocument document = main_frame->document();
   blink::WebElement pdf_element = document.getElementById(""pdf-viewer"");
   if (pdf_element.isNull()) {
     NOTREACHED();
     return;
   }
 
   blink::WebLocalFrame* plugin_frame = pdf_element.document().frame();
   blink::WebElement plugin_element = pdf_element;
   if (pdf_element.hasHTMLTagName(""iframe"")) {
     plugin_frame = blink::WebLocalFrame::fromFrameOwnerElement(pdf_element);
     plugin_element = delegate_->GetPdfElement(plugin_frame);
     if (plugin_element.isNull()) {
       NOTREACHED();
       return;
     }
   }
 
   base::AutoReset<bool> set_printing_flag(&print_for_preview_, true);
 
   if (!UpdatePrintSettings(plugin_frame, plugin_element, job_settings)) {
     LOG(ERROR) << ""UpdatePrintSettings failed"";
     DidFinishPrinting(FAIL_PRINT);
     return;
   }
 
   PrintMsg_Print_Params& print_params = print_pages_params_->params;
   print_params.printable_area = gfx::Rect(print_params.page_size);
 
   if (!RenderPagesForPrint(plugin_frame, plugin_element)) {
     LOG(ERROR) << ""RenderPagesForPrint failed"";
     DidFinishPrinting(FAIL_PRINT);
   }
 }",[3],"Multiple use-after-free vulnerabilities in the PrintWebViewHelper class in components/printing/renderer/print_web_view_helper.cc in Google Chrome before 45.0.2454.85 allow user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact by triggering nested IPC messages during preparation for printing, as demonstrated by messages associated with PDF documents in conjunction with messages about printer capabilities."
197876," gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)
 {
     int ecode, code;
     gx_device_pdf *pdev = (gx_device_pdf *) dev;
     float cl = (float)pdev->CompatibilityLevel;
     bool locked = pdev->params.LockDistillerParams, ForOPDFRead;
     gs_param_name param_name;
 
     pdev->pdf_memory = gs_memory_stable(pdev->memory);
      
 
     {
         gs_param_string_array ppa;
         gs_param_string pps;
 
         code = param_read_string_array(plist, (param_name = ""pdfmark""), &ppa);
         switch (code) {
             case 0:
                 code = pdfwrite_pdf_open_document(pdev);
                 if (code < 0)
                     return code;
                 code = pdfmark_process(pdev, &ppa);
                 if (code >= 0)
                     return code;
                  
             default:
                 param_signal_error(plist, param_name, code);
                 return code;
             case 1:
                 break;
         }
 
         code = param_read_string_array(plist, (param_name = ""DSC""), &ppa);
         switch (code) {
             case 0:
                 code = pdfwrite_pdf_open_document(pdev);
                 if (code < 0)
                     return code;
                 code = pdf_dsc_process(pdev, &ppa);
                 if (code >= 0)
                     return code;
                  
             default:
                 param_signal_error(plist, param_name, code);
                 return code;
             case 1:
                 break;
         }
 
         code = param_read_string(plist, (param_name = ""pdfpagelabels""), &pps);
         switch (code) {
             case 0:
                 {
                     if (!pdev->ForOPDFRead) {
                         cos_dict_t *const pcd = pdev->Catalog;
                         code = pdfwrite_pdf_open_document(pdev);
                         if (code < 0)
                             return code;
                         code = cos_dict_put_string(pcd, (const byte *)""/PageLabels"", 11,
                                    pps.data, pps.size);
                         if (code >= 0)
                             return code;
                     } else
                         return 0;
                  }
                  
             default:
                 param_signal_error(plist, param_name, code);
                 return code;
             case 1:
                 break;
         }
     }
 
      
    ecode = param_read_bool(plist, ""LockDistillerParams"", &locked);
     ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
      if (ecode < 0)
          param_signal_error(plist, param_name, ecode);
      
 
     {
         int efo = 1;
 
         ecode = param_put_int(plist, (param_name = "".EmbedFontObjects""), &efo, ecode);
         if (ecode < 0)
             param_signal_error(plist, param_name, ecode);
         if (efo != 1)
             param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
     }
     {
         int cdv = CoreDistVersion;
 
         ecode = param_put_int(plist, (param_name = ""CoreDistVersion""), &cdv, ecode);
         if (ecode < 0)
             return gs_note_error(ecode);
         if (cdv != CoreDistVersion)
             param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
     }
 
     switch (code = param_read_float(plist, (param_name = ""CompatibilityLevel""), &cl)) {
         default:
             ecode = code;
             param_signal_error(plist, param_name, ecode);
             break;
         case 0:
             if (!(locked && pdev->params.LockDistillerParams)) {
                  
                 if (cl < (float)1.15)
                     cl = (float)1.1;
                 else if (cl < (float)1.25)
                     cl = (float)1.2;
                 else if (cl < (float)1.35)
                     cl = (float)1.3;
                 else if (cl < (float)1.45)
                     cl = (float)1.4;
                 else if (cl < (float)1.55)
                     cl = (float)1.5;
                 else if (cl < (float)1.65)
                     cl = (float)1.6;
                 else if (cl < (float)1.75)
                     cl = (float)1.7;
                 else {
                     cl = (float)2.0;
                     if (pdev->params.TransferFunctionInfo == tfi_Preserve)
                         pdev->params.TransferFunctionInfo = tfi_Apply;
                 }
             }
         case 1:
             break;
     }
     {    
         gs_memory_t *mem = plist->memory;
 
         plist->memory = pdev->pdf_memory;
         code = gs_param_read_items(plist, pdev, pdf_param_items);
         if (code < 0 || (code = param_read_bool(plist, ""ForOPDFRead"", &ForOPDFRead)) < 0)
         {
         }
         if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))
             pdev->ForOPDFRead = ForOPDFRead;
         plist->memory = mem;
     }
     if (code < 0)
         ecode = code;
     {
          
         long fon = pdev->FirstObjectNumber;
 
         if (fon != save_dev->FirstObjectNumber) {
             if (fon <= 0 || fon > 0x7fff0000 ||
                 (pdev->next_id != 0 &&
                  pdev->next_id !=
                  save_dev->FirstObjectNumber + pdf_num_initial_ids)
                 ) {
                 ecode = gs_error_rangecheck;
                 param_signal_error(plist, ""FirstObjectNumber"", ecode);
             }
         }
     }
     {
          
         static const char *const pcm_names[] = {
             ""DeviceGray"", ""DeviceRGB"", ""DeviceCMYK"", ""DeviceN"", 0
         };
         int pcm = -1;
 
         ecode = param_put_enum(plist, ""ProcessColorModel"", &pcm,
                                pcm_names, ecode);
         if (pcm >= 0) {
             pdf_set_process_color_model(pdev, pcm);
             rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
             pdev->icc_struct = 0;
         }
     }
     if (ecode < 0)
         goto fail;
 
     if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
         param_signal_error(plist, param_name, code);
     }
 
      
     if (pdev->PDFA < 0 || pdev->PDFA > 3){
         ecode = gs_note_error(gs_error_rangecheck);
         param_signal_error(plist, ""PDFA"", ecode);
         goto fail;
     }
     if(pdev->PDFA != 0 && pdev->AbortPDFAX)
         pdev->PDFA = 0;
     if(pdev->PDFX && pdev->AbortPDFAX)
         pdev->PDFX = 0;
     if (pdev->PDFX && pdev->PDFA != 0) {
         ecode = gs_note_error(gs_error_rangecheck);
         param_signal_error(plist, ""PDFA"", ecode);
         goto fail;
     }
     if (pdev->PDFX && pdev->ForOPDFRead) {
         ecode = gs_note_error(gs_error_rangecheck);
         param_signal_error(plist, ""PDFX"", ecode);
         goto fail;
     }
     if (pdev->PDFA != 0 && pdev->ForOPDFRead) {
         ecode = gs_note_error(gs_error_rangecheck);
         param_signal_error(plist, ""PDFA"", ecode);
         goto fail;
     }
     if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {
          pdev->HaveTransparency = false;
          pdev->PreserveSMask = false;
     }
 
      
     if (pdev->PDFX)
         cl = (float)1.3;  
     if (pdev->PDFA != 0 && cl < 1.4)
         cl = (float)1.4;
     pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);
     if (pdev->ForOPDFRead) {
         pdev->ResourcesBeforeUsage = true;
         pdev->HaveCFF = false;
         pdev->HavePDFWidths = false;
         pdev->HaveStrokeColor = false;
         cl = (float)1.2;  
         pdev->MaxInlineImageSize = max_long;  
         pdev->version = psdf_version_level2;
     } else {
         pdev->ResourcesBeforeUsage = false;
         pdev->HaveCFF = true;
         pdev->HavePDFWidths = true;
         pdev->HaveStrokeColor = true;
     }
     pdev->ParamCompatibilityLevel = cl;
     if (cl < 1.2) {
         pdev->HaveCFF = false;
     }
     ecode = gdev_psdf_put_params(dev, plist);
     if (ecode < 0)
         goto fail;
 
     if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {
         pdev->params.TransferFunctionInfo = tfi_Apply;
         emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
     }
 
     if (pdev->params.ConvertCMYKImagesToRGB) {
         if (pdev->params.ColorConversionStrategy == ccs_CMYK) {
             emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
         } else {
             if (pdev->params.ColorConversionStrategy == ccs_Gray) {
                 emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n"");
             } else {
                 if (pdev->icc_struct)
                     rc_decrement(pdev->icc_struct,
                                  ""reset default profile\n"");
                 pdf_set_process_color_model(pdev,1);
                 ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                 if (ecode < 0)
                     goto fail;
             }
         }
     }
     switch (pdev->params.ColorConversionStrategy) {
         case ccs_ByObjectType:
         case ccs_LeaveColorUnchanged:
             break;
         case ccs_UseDeviceDependentColor:
         case ccs_UseDeviceIndependentColor:
         case ccs_UseDeviceIndependentColorForImages:
             pdev->params.TransferFunctionInfo = tfi_Apply;
             break;
         case ccs_CMYK:
             pdev->params.TransferFunctionInfo = tfi_Apply;
             if (pdev->icc_struct)
                 rc_decrement(pdev->icc_struct,
                              ""reset default profile\n"");
             pdf_set_process_color_model(pdev, 2);
             ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
             if (ecode < 0)
                 goto fail;
             break;
         case ccs_Gray:
             pdev->params.TransferFunctionInfo = tfi_Apply;
             if (pdev->icc_struct)
                 rc_decrement(pdev->icc_struct,
                              ""reset default profile\n"");
             pdf_set_process_color_model(pdev,0);
             ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
             if (ecode < 0)
                 goto fail;
             break;
         case ccs_sRGB:
         case ccs_RGB:
             pdev->params.TransferFunctionInfo = tfi_Apply;
              
             if (!pdev->params.ConvertCMYKImagesToRGB) {
                 if (pdev->icc_struct)
                     rc_decrement(pdev->icc_struct,
                                  ""reset default profile\n"");
                 pdf_set_process_color_model(pdev,1);
                 ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                 if (ecode < 0)
                     goto fail;
             }
             break;
         default:
             break;
     }
     if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&
             !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
         emprintf(pdev->memory,
                  ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
         ecode = gs_note_error(gs_error_rangecheck);
     }
     if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&
             !strcmp(pdev->params.GrayImage.Filter, ""JPXEncode"")) {
         emprintf(pdev->memory,
                  ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
         ecode = gs_note_error(gs_error_rangecheck);
     }
     if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&
             !strcmp(pdev->params.MonoImage.Filter, ""JBIG2Encode"")) {
         emprintf(pdev->memory,
                  ""JBIG2Encode requires CompatibilityLevel >= 1.4 .\n"");
         ecode = gs_note_error(gs_error_rangecheck);
     }
     if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {
         pdev->version = psdf_version_level2_with_TT ;
     }
     if (ecode < 0)
         goto fail;
 
     if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {
         if (pdev->xref.file != 0) {
             if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {
                 ecode = gs_error_ioerror;
                 goto fail;
             }
             pdf_initialize_ids(pdev);
         }
     }
      
     pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
     if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||
         (pdev->OwnerPassword.size != 0 &&
          memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,
          pdev->OwnerPassword.size) != 0)) {
         if (pdev->is_open) {
             if (pdev->PageCount == 0) {
                 gs_closedevice((gx_device *)save_dev);
                 return 0;
             }
             else
                 emprintf(pdev->memory, ""Owner Password changed mid-job, ignoring.\n"");
         }
     }
 
     if (pdev->Linearise && pdev->is_ps2write) {
         emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
         pdev->Linearise = false;
     }
 
     if (pdev->Linearise && pdev->OwnerPassword.size != 0) {
         emprintf(pdev->memory, ""Can't linearise encrypted PDF, ignoring\n"");
         pdev->Linearise = false;
     }
 
     if (pdev->FlattenFonts)
         pdev->PreserveTrMode = false;
     return 0;
  fail:
      
     pdev->version = save_dev->version;
     pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);
     pdev->saved_fill_color = save_dev->saved_fill_color;
     pdev->saved_stroke_color = save_dev->saved_fill_color;
     {
         const gs_param_item_t *ppi = pdf_param_items;
 
         for (; ppi->key; ++ppi)
             memcpy((char *)pdev + ppi->offset,
                    (char *)save_dev + ppi->offset,
                    gs_param_type_sizes[ppi->type]);
         pdev->ForOPDFRead = save_dev->ForOPDFRead;
     }
     return ecode;
 }","[77, 76]","In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use a type confusion in the LockDistillerParams parameter to crash the interpreter or execute code."
200593," static void show_object(struct object *object, struct strbuf *path,
			const char *last, void *data)
 static void show_object(struct object *object, const char *name, void *data)
  {
  	struct bitmap *base = data;
  	bitmap_set(base, find_object_pos(object->oid.hash));
 	mark_as_seen(object);
 }","[3, 2]","Integer overflow in Git before 2.7.4 allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, which triggers a heap-based buffer overflow."
203185," static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {
 	const char *section_name = """";
 	const char *link_section_name = """";
 	char *end = NULL;
 	Elf_(Shdr) *link_shdr = NULL;
 	ut8 dfs[sizeof (Elf_(Verdef))] = {0};
 	Sdb *sdb;
 	int cnt, i;
 	if (shdr->sh_link > bin->ehdr.e_shnum) {
 		return false;
 	}
 	link_shdr = &bin->shdr[shdr->sh_link];
 	if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {
 		return false;
 	}
 	Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));
 	if (!defs) {
 		return false;
 	}
 	if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {
 		section_name = &bin->shstrtab[shdr->sh_name];
 	}
 	if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {
 		link_section_name = &bin->shstrtab[link_shdr->sh_name];
 	}
 	if (!defs) {
 		bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n"");
 		return NULL;
 	}
 	sdb = sdb_new0 ();
 	end = (char *)defs + shdr->sh_size;
 	sdb_set (sdb, ""section_name"", section_name, 0);
 	sdb_num_set (sdb, ""entries"", shdr->sh_info, 0);
 	sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0);
 	sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0);
 	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);
 	sdb_set (sdb, ""link_section_name"", link_section_name, 0);
 
 	for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {
 		Sdb *sdb_verdef = sdb_new0 ();
 		char *vstart = ((char*)defs) + i;
 		char key[32] = {0};
 		Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;
 		Elf_(Verdaux) aux = {0};
 		int j = 0;
 		int isum = 0;
 
 		r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));
 		verdef->vd_version = READ16 (dfs, j)
 		verdef->vd_flags = READ16 (dfs, j)
 		verdef->vd_ndx = READ16 (dfs, j)
 		verdef->vd_cnt = READ16 (dfs, j)
 		verdef->vd_hash = READ32 (dfs, j)
  		verdef->vd_aux = READ32 (dfs, j)
  		verdef->vd_next = READ32 (dfs, j)
  		int vdaux = verdef->vd_aux;
		if (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {
 		if (vdaux < 1 || vstart + vdaux < vstart) {
  			sdb_free (sdb_verdef);
  			goto out_error;
  		}
 		vstart += vdaux;
 		if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 
 		j = 0;
 		aux.vda_name = READ32 (vstart, j)
 		aux.vda_next = READ32 (vstart, j)
 
 		isum = i + verdef->vd_aux;
 		if (aux.vda_name > bin->dynstr_size) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 
 		sdb_num_set (sdb_verdef, ""idx"", i, 0);
 		sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0);
 		sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0);
 		sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0);
 		sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
 		sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0);
 
 		for (j = 1; j < verdef->vd_cnt; ++j) {
 			int k;
 			Sdb *sdb_parent = sdb_new0 ();
 			isum += aux.vda_next;
 			vstart += aux.vda_next;
 			if (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
 			}
 			k = 0;
 			aux.vda_name = READ32 (vstart, k)
 			aux.vda_next = READ32 (vstart, k)
 			if (aux.vda_name > bin->dynstr_size) {
 				sdb_free (sdb_verdef);
 				sdb_free (sdb_parent);
 				goto out_error;
 			}
 			sdb_num_set (sdb_parent, ""idx"", isum, 0);
 			sdb_num_set (sdb_parent, ""parent"", j, 0);
 			sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0);
 			snprintf (key, sizeof (key), ""parent%d"", j - 1);
 			sdb_ns_set (sdb_verdef, key, sdb_parent);
 		}
 
 		snprintf (key, sizeof (key), ""verdef%d"", cnt);
 		sdb_ns_set (sdb, key, sdb_verdef);
 		if (!verdef->vd_next) {
 			sdb_free (sdb_verdef);
 			goto out_error;
 		}
 		if ((st32)verdef->vd_next < 1) {
 			eprintf (""Warning: Invalid vd_next in the ELF version\n"");
 			break;
 		}
 		i += verdef->vd_next;
 	}
 	free (defs);
 	return sdb;
 out_error:
 	free (defs);
 	sdb_free (sdb);
 	return NULL;
 }","[58, 57]","In radare 2.0.1, a pointer wraparound vulnerability exists in store_versioninfo_gnu_verdef() in libr/bin/format/elf/elf.c."
203177," static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) 
 static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)
  {
  	const gdFixed f_127 = gd_itofx(127);
  	register int c = src->tpixels[y][x];
 	c = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);
 	return _color_blend(bgColor, c);
 }",[2],"gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function."
198902," static void tun_net_init(struct net_device *dev)
 {
 	struct tun_struct *tun = netdev_priv(dev);
 
 	switch (tun->flags & TUN_TYPE_MASK) {
 	case TUN_TUN_DEV:
 		dev->netdev_ops = &tun_netdev_ops;
 
 		 
 		dev->hard_header_len = 0;
 		dev->addr_len = 0;
 		dev->mtu = 1500;
 
 		 
 		dev->type = ARPHRD_NONE;
 		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
 		dev->tx_queue_len = TUN_READQ_SIZE;   
 		break;
 
 	case TUN_TAP_DEV:
  		dev->netdev_ops = &tap_netdev_ops;
  		 
  		ether_setup(dev);
 		dev->priv_flags &= ~IFF_TX_SKB_SHARING;
  
  		random_ether_addr(dev->dev_addr);
  
 		dev->tx_queue_len = TUN_READQ_SIZE;   
 		break;
 	}
 }",[24],"The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface."
197833,"  static void reds_handle_ticket(void *opaque)
  {
      RedLinkInfo *link = (RedLinkInfo *)opaque;
    char password[SPICE_MAX_PASSWORD_LENGTH];
     char *password;
      time_t ltime;
     int password_size;
  
      time(&ltime);
    RSA_private_decrypt(link->tiTicketing.rsa_size,
                        link->tiTicketing.encrypted_ticket.encrypted_data,
                        (unsigned char *)password, link->tiTicketing.rsa, RSA_PKCS1_OAEP_PADDING);
     if (RSA_size(link->tiTicketing.rsa) < SPICE_MAX_PASSWORD_LENGTH) {
         spice_warning(""RSA modulus size is smaller than SPICE_MAX_PASSWORD_LENGTH (%d < %d), ""
                       ""SPICE ticket sent from client may be truncated"",
                       RSA_size(link->tiTicketing.rsa), SPICE_MAX_PASSWORD_LENGTH);
     }
 
     password = g_malloc0(RSA_size(link->tiTicketing.rsa) + 1);
     password_size = RSA_private_decrypt(link->tiTicketing.rsa_size,
                                         link->tiTicketing.encrypted_ticket.encrypted_data,
                                         (unsigned char *)password,
                                         link->tiTicketing.rsa,
                                         RSA_PKCS1_OAEP_PADDING);
     if (password_size == -1) {
         spice_warning(""failed to decrypt RSA encrypted password: %s"",
                       ERR_error_string(ERR_get_error(), NULL));
         goto error;
     }
     password[password_size] = '\0';
  
      if (ticketing_enabled && !link->skip_auth) {
          int expired =  taTicket.expiration_time < ltime;
  
          if (strlen(taTicket.password) == 0) {
            reds_send_link_result(link, SPICE_LINK_ERR_PERMISSION_DENIED);
              spice_warning(""Ticketing is enabled, but no password is set. ""
                        ""please set a ticket first"");
            reds_link_free(link);
            return;
                           ""please set a ticket first"");
             goto error;
          }
  
        if (expired || strncmp(password, taTicket.password, SPICE_MAX_PASSWORD_LENGTH) != 0) {
         if (expired || strcmp(password, taTicket.password) != 0) {
              if (expired) {
                  spice_warning(""Ticket has expired"");
              } else {
                  spice_warning(""Invalid password"");
              }
            reds_send_link_result(link, SPICE_LINK_ERR_PERMISSION_DENIED);
            reds_link_free(link);
            return;
             goto error;
          }
      }
  
      reds_handle_link(link);
     goto end;
 
 error:
     reds_send_link_result(link, SPICE_LINK_ERR_PERMISSION_DENIED);
     reds_link_free(link);
 
 end:
     g_free(password);
  }","[5, 7, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 41, 42, 46, 55, 60, 61, 62, 63, 64, 65, 66, 67, 4, 10, 11, 12, 36, 38, 39, 40, 45, 52, 53, 54]",Stack-based buffer overflow in the reds_handle_ticket function in server/reds.c in SPICE 0.12.0 allows remote attackers to cause a denial of service (crash) via a long password in a SPICE ticket.
206477," GURL DecorateFrontendURL(const GURL& base_url) {
   std::string frontend_url = base_url.spec();
   std::string url_string(
       frontend_url +
       ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
       ""dockSide=undocked"");  
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
      url_string += ""&experiments=true"";
  
    if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
     url_string += ""&"" + command_line->GetSwitchValueASCII(
         switches::kDevToolsFlags);
    }
  
  #if defined(DEBUG_DEVTOOLS)
   url_string += ""&debugFrontend=true"";
 #endif   
 
   return GURL(url_string);
 }","[16, 17, 12, 13, 14, 15]","Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android insufficiently sanitized DevTools URLs, which allowed a remote attacker to read local files via a crafted HTML page."
200192," static int sclp_ctl_ioctl_sccb(void __user *user_area)
  {
  	struct sclp_ctl_sccb ctl_sccb;
  	struct sccb_header *sccb;
 	unsigned long copied;
  	int rc;
  
  	if (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))
 		return -EFAULT;
 	if (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))
 		return -EOPNOTSUPP;
  	sccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);
  	if (!sccb)
  		return -ENOMEM;
	if (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {
 	copied = PAGE_SIZE -
 		copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), PAGE_SIZE);
 	if (offsetof(struct sccb_header, length) +
 	    sizeof(sccb->length) > copied || sccb->length > copied) {
  		rc = -EFAULT;
  		goto out_free;
  	}
	if (sccb->length > PAGE_SIZE || sccb->length < 8)
		return -EINVAL;
	if (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {
		rc = -EFAULT;
 	if (sccb->length < 8) {
 		rc = -EINVAL;
  		goto out_free;
  	}
  	rc = sclp_sync_request(ctl_sccb.cmdw, sccb);
 	if (rc)
 		goto out_free;
 	if (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))
 		rc = -EFAULT;
 out_free:
 	free_page((unsigned long) sccb);
 	return rc;
 }","[5, 16, 17, 18, 19, 27, 28, 15, 23, 24, 25, 26]","Race condition in the sclp_ctl_ioctl_sccb function in drivers/s390/char/sclp_ctl.c in the Linux kernel before 4.6 allows local users to obtain sensitive information from kernel memory by changing a certain length value, aka a *double fetch* vulnerability."
200180," static void commit_tree(struct mount *mnt, struct mount *shadows)
 {
 	struct mount *parent = mnt->mnt_parent;
 	struct mount *m;
 	LIST_HEAD(head);
 	struct mnt_namespace *n = parent->mnt_ns;
 
 	BUG_ON(parent == mnt);
 
 	list_add_tail(&head, &mnt->mnt_list);
 	list_for_each_entry(m, &head, mnt_list)
 		m->mnt_ns = n;
  
  	list_splice(&head, n->list.prev);
  
 	n->mounts += n->pending_mounts;
 	n->pending_mounts = 0;
 
  	attach_shadowed(mnt, parent, shadows);
  	touch_mnt_namespace(n);
  }","[16, 17, 18]","fs/namespace.c in the Linux kernel before 4.9 does not restrict how many mounts may exist in a mount namespace, which allows local users to cause a denial of service (memory consumption and deadlock) via MS_BIND mount system calls, as demonstrated by a loop that triggers exponential growth in the number of mounts."
197965," int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
 	     void *asn, EVP_PKEY *pkey)
 	{
 	EVP_MD_CTX ctx;
 	const EVP_MD *type = NULL;
 	unsigned char *buf_in=NULL;
 	int ret= -1,inl;
  
         int mdnid, pknid;
  
        if (!pkey)
                {
                ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
                return -1;
                }
 
         EVP_MD_CTX_init(&ctx);
  
          
 	if (type == NULL)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
 		goto err;
 		}
 
 	 
 	if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
 		goto err;
 		}
 
 	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		ret=0;
 		goto err;
 		}
 
 	inl = ASN1_item_i2d(asn, &buf_in, it);
 	
 	if (buf_in == NULL)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
 		goto err;
 		}
 
 	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);
 
 	OPENSSL_cleanse(buf_in,(unsigned int)inl);
 	OPENSSL_free(buf_in);
 
 	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
 			(unsigned int)signature->length,pkey) <= 0)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		ret=0;
 		goto err;
 		}
 	 
 	 
 	ret=1;
 err:
 	EVP_MD_CTX_cleanup(&ctx);
 	return(ret);
 	}","[11, 12, 13, 14, 15, 16]","OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key."
199265," static __inline__ int scm_check_creds(struct ucred *creds)
 {
 	const struct cred *cred = current_cred();
 	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
 	kgid_t gid = make_kgid(cred->user_ns, creds->gid);
 
  	if (!uid_valid(uid) || !gid_valid(gid))
  		return -EINVAL;
  
	if ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&
 	if ((creds->pid == task_tgid_vnr(current) ||
 	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
  	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
  	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
  	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
 	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
 	       return 0;
 	}
 	return -EPERM;
 }","[11, 12, 10]","The scm_check_creds function in net/core/scm.c in the Linux kernel before 3.8.6 does not properly enforce capability requirements for controlling the PID value associated with a UNIX domain socket, which allows local users to bypass intended access restrictions by leveraging the time interval during which a user namespace has been created but a PID namespace has not been created."
201886," int bmp_validate(jas_stream_t *in)
  {
  	int n;
  	int i;
	uchar buf[2];
 	jas_uchar buf[2];
  
  	assert(JAS_STREAM_MAXPUTBACK >= 2);
  
 	 
 	if ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {
 		return -1;
 	}
 	 
 	for (i = n - 1; i >= 0; --i) {
 		if (jas_stream_ungetc(in, buf[i]) == EOF) {
 			return -1;
 		}
 	}
 	 
 	if (n < 2) {
 		return -1;
 	}
 	 
 	if (buf[0] == (BMP_MAGIC & 0xff) && buf[1] == (BMP_MAGIC >> 8)) {
 		return 0;
 	}
 	return -1;
 }","[6, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
198081," static void coroutine_fn v9fs_xattrcreate(void *opaque)
 {
     int flags;
     int32_t fid;
     int64_t size;
     ssize_t err = 0;
     V9fsString name;
     size_t offset = 7;
     V9fsFidState *file_fidp;
     V9fsFidState *xattr_fidp;
     V9fsPDU *pdu = opaque;
 
     v9fs_string_init(&name);
     err = pdu_unmarshal(pdu, offset, ""dsqd"", &fid, &name, &size, &flags);
     if (err < 0) {
         goto out_nofid;
     }
     trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);
 
     file_fidp = get_fid(pdu, fid);
     if (file_fidp == NULL) {
         err = -EINVAL;
         goto out_nofid;
     }
      
     xattr_fidp = file_fidp;
     xattr_fidp->fid_type = P9_FID_XATTR;
     xattr_fidp->fs.xattr.copied_len = 0;
     xattr_fidp->fs.xattr.len = size;
      xattr_fidp->fs.xattr.flags = flags;
      v9fs_string_init(&xattr_fidp->fs.xattr.name);
      v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);
     g_free(xattr_fidp->fs.xattr.value);
      xattr_fidp->fs.xattr.value = g_malloc0(size);
      err = offset;
      put_fid(pdu, file_fidp);
     pdu_complete(pdu, err);
     v9fs_string_free(&name);
 }",[33],Memory leak in the v9fs_xattrcreate function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption and QEMU process crash) via a large number of Txattrcreate messages with the same fid number.
207106,"  void WebGL2RenderingContextBase::bindSampler(GLuint unit,
                                               WebGLSampler* sampler) {
  if (isContextLost())
    return;
    bool deleted;
    if (!CheckObjectToBeBound(""bindSampler"", sampler, deleted))
      return;
   if (deleted) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""bindSampler"",
                       ""attempted to bind a deleted sampler"");
     return;
   }
 
   if (unit >= sampler_units_.size()) {
     SynthesizeGLError(GL_INVALID_VALUE, ""bindSampler"",
                       ""texture unit out of range"");
     return;
   }
 
   sampler_units_[unit] = sampler;
 
   ContextGL()->BindSampler(unit, ObjectOrZero(sampler));
 }","[3, 4]",Insufficient data validation in WebGL in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
203068," static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
 		       int *sockaddr_len, int peer)
 {
 	struct sockaddr_atmpvc *addr;
 	struct atm_vcc *vcc = ATM_SD(sock);
 
 	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
  		return -ENOTCONN;
  	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
  	addr = (struct sockaddr_atmpvc *)sockaddr;
 	memset(addr, 0, sizeof(*addr));
  	addr->sap_family = AF_ATMPVC;
  	addr->sap_addr.itf = vcc->dev->number;
  	addr->sap_addr.vpi = vcc->vpi;
 	addr->sap_addr.vci = vcc->vci;
 	return 0;
 }",[11],"The ATM implementation in the Linux kernel before 3.6 does not initialize certain structures, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
208144," status_t OMXNodeInstance::emptyBuffer(
         OMX::buffer_id buffer,
         OMX_U32 rangeOffset, OMX_U32 rangeLength,
         OMX_U32 flags, OMX_TICKS timestamp) {
 
      Mutex::Autolock autoLock(mLock);
  
      OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
      
      
     if (rangeOffset > header->nAllocLen
             || rangeLength > header->nAllocLen - rangeOffset) {
         return BAD_VALUE;
     }
      header->nFilledLen = rangeLength;
      header->nOffset = rangeOffset;
  
  BufferMeta *buffer_meta =
  static_cast<BufferMeta *>(header->pAppPrivate);
     buffer_meta->CopyToOMX(header);
 
  return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);
 }","[9, 10, 11, 12, 13, 14]","Buffer overflow in the OMXNodeInstance::emptyBuffer function in omx/OMXNodeInstance.cpp in libstagefright in Android before 5.1.1 LMY48I allows attackers to execute arbitrary code via a crafted application, aka internal bug 20634516."
200749,"  static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
  	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
  {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
  	void *memory;
  
  	if (dma_alloc_from_coherent(dev, size, handle, &memory))
 		return memory;
 
 	return __dma_alloc(dev, size, handle, gfp, prot, true,
 			   __builtin_return_address(0));
 }","[5, 4]","arch/arm/mm/dma-mapping.c in the Linux kernel before 3.13 on ARM platforms, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not prevent executable DMA mappings, which might allow local users to gain privileges via a crafted application, aka Android internal bug 28803642 and Qualcomm internal bug CR642735."
205682," void FragmentPaintPropertyTreeBuilder::UpdateSvgLocalToBorderBoxTransform() {
   DCHECK(properties_);
   if (!object_.IsSVGRoot())
     return;
 
   if (NeedsPaintPropertyUpdate()) {
     AffineTransform transform_to_border_box =
         SVGRootPainter(ToLayoutSVGRoot(object_))
             .TransformToPixelSnappedBorderBox(context_.current.paint_offset);
      if (!transform_to_border_box.IsIdentity() &&
          NeedsSVGLocalToBorderBoxTransform(object_)) {
        OnUpdate(properties_->UpdateSvgLocalToBorderBoxTransform(
          context_.current.transform,
           *context_.current.transform,
            TransformPaintPropertyNode::State{transform_to_border_box}));
      } else {
        OnClear(properties_->ClearSvgLocalToBorderBoxTransform());
     }
   }
 
   if (properties_->SvgLocalToBorderBoxTransform()) {
     context_.current.transform = properties_->SvgLocalToBorderBoxTransform();
     context_.current.should_flatten_inherited_transform = false;
     context_.current.rendering_context_id = 0;
   }
   context_.current.paint_offset = LayoutPoint();
 }","[14, 13]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
8427,"bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,
struct net_device *dev)
{
struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
struct ieee80211_radiotap_iterator iterator;
struct ieee80211_radiotap_header *rthdr =
(struct ieee80211_radiotap_header *) skb->data;
struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
struct ieee80211_supported_band *sband =
local->hw.wiphy->bands[info->band];
int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,
NULL);
u16 txflags;
u16 rate = 0;
bool rate_found = false;
u8 rate_retries = 0;
u16 rate_flags = 0;
u8 mcs_known, mcs_flags, mcs_bw;
u16 vht_known;
u8 vht_mcs = 0, vht_nss = 0;
int i;


if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))
return false;


if (unlikely(rthdr->it_version))
return false;


if (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))
return false;

info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
IEEE80211_TX_CTL_DONTFRAG;







while (!ret) {
ret = ieee80211_radiotap_iterator_next(&iterator);

if (ret)
continue;


switch (iterator.this_arg_index) {






case IEEE80211_RADIOTAP_FLAGS:
if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {







if (skb->len < (iterator._max_length + FCS_LEN))
return false;

skb_trim(skb, skb->len - FCS_LEN);
}
if (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)
info->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;
if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)
info->flags &= ~IEEE80211_TX_CTL_DONTFRAG;
break;

case IEEE80211_RADIOTAP_TX_FLAGS:
txflags = get_unaligned_le16(iterator.this_arg);
if (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)
info->flags |= IEEE80211_TX_CTL_NO_ACK;
if (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)
info->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;
if (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)
info->control.flags |=
IEEE80211_TX_CTRL_DONT_REORDER;
break;

case IEEE80211_RADIOTAP_RATE:
rate = *iterator.this_arg;
rate_flags = 0;
rate_found = true;
break;

case IEEE80211_RADIOTAP_DATA_RETRIES:
rate_retries = *iterator.this_arg;
break;

case IEEE80211_RADIOTAP_MCS:
mcs_known = iterator.this_arg[0];
mcs_flags = iterator.this_arg[1];
if (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))
break;

rate_found = true;
rate = iterator.this_arg[2];
rate_flags = IEEE80211_TX_RC_MCS;

if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&
mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)
rate_flags |= IEEE80211_TX_RC_SHORT_GI;

mcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;
if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&
mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)
rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;

if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&
mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)
info->flags |= IEEE80211_TX_CTL_LDPC;

if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
u8 stbc = u8_get_bits(mcs_flags,
IEEE80211_RADIOTAP_MCS_STBC_MASK);

info->flags |=
u32_encode_bits(stbc,
IEEE80211_TX_CTL_STBC);
}
break;

case IEEE80211_RADIOTAP_VHT:
vht_known = get_unaligned_le16(iterator.this_arg);
rate_found = true;

rate_flags = IEEE80211_TX_RC_VHT_MCS;
if ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&
(iterator.this_arg[2] &
IEEE80211_RADIOTAP_VHT_FLAG_SGI))
rate_flags |= IEEE80211_TX_RC_SHORT_GI;
if (vht_known &
IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {
if (iterator.this_arg[3] == 1)
rate_flags |=
IEEE80211_TX_RC_40_MHZ_WIDTH;
else if (iterator.this_arg[3] == 4)
rate_flags |=
IEEE80211_TX_RC_80_MHZ_WIDTH;
else if (iterator.this_arg[3] == 11)
rate_flags |=
IEEE80211_TX_RC_160_MHZ_WIDTH;
}

vht_mcs = iterator.this_arg[4] >> 4;
vht_nss = iterator.this_arg[4] & 0xF;
break;







default:
break;
}
}

if (ret != -ENOENT)
return false;

if (rate_found) {
info->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;

for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
info->control.rates[i].idx = -1;
info->control.rates[i].flags = 0;
info->control.rates[i].count = 0;
}

if (rate_flags & IEEE80211_TX_RC_MCS) {
info->control.rates[0].idx = rate;
} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {
ieee80211_rate_set_vht(info->control.rates, vht_mcs,
vht_nss);
} else {
for (i = 0; i < sband->n_bitrates; i++) {
if (rate * 5 != sband->bitrates[i].bitrate)
continue;

info->control.rates[0].idx = i;
break;
}
}

if (info->control.rates[0].idx < 0)
info->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;

info->control.rates[0].flags = rate_flags;
info->control.rates[0].count = min_t(u8, rate_retries + 1,
local->hw.max_rate_tries);
}

return true;
}","[9, 10, 24, 25, 28, 29, 32, 33, 173, 186]","The mac80211 subsystem in the Linux kernel before 5.12.13, when a device supporting only 5 GHz is used, allows attackers to cause a denial of service (NULL pointer dereference in the radiotap parser) by injecting a frame with 802.11a rates."
200519," void __init acpi_initrd_override(void *data, size_t size)
 {
 	int sig, no, table_nr = 0, total_offset = 0;
 	long offset = 0;
 	struct acpi_table_header *table;
 	char cpio_path[32] = ""kernel/firmware/acpi/"";
 	struct cpio_data file;
 
 	if (data == NULL || size == 0)
 		return;
 
 	for (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {
 		file = find_cpio_data(cpio_path, data, size, &offset);
 		if (!file.data)
 			break;
 
 		data += offset;
 		size -= offset;
 
 		if (file.size < sizeof(struct acpi_table_header)) {
 			pr_err(""ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n"",
 				cpio_path, file.name);
 			continue;
 		}
 
 		table = file.data;
 
 		for (sig = 0; table_sigs[sig]; sig++)
 			if (!memcmp(table->signature, table_sigs[sig], 4))
 				break;
 
 		if (!table_sigs[sig]) {
 			pr_err(""ACPI OVERRIDE: Unknown signature [%s%s]\n"",
 				cpio_path, file.name);
 			continue;
 		}
 		if (file.size != table->length) {
 			pr_err(""ACPI OVERRIDE: File length does not match table length [%s%s]\n"",
 				cpio_path, file.name);
 			continue;
 		}
 		if (acpi_table_checksum(file.data, table->length)) {
 			pr_err(""ACPI OVERRIDE: Bad table checksum [%s%s]\n"",
 				cpio_path, file.name);
 			continue;
 		}
 
 		pr_info(""%4.4s ACPI table found in initrd [%s%s][0x%x]\n"",
 			table->signature, cpio_path, file.name, table->length);
 
 		all_tables_size += table->length;
 		acpi_initrd_files[table_nr].data = file.data;
 		acpi_initrd_files[table_nr].size = file.size;
 		table_nr++;
 	}
  	if (table_nr == 0)
  		return;
  
 	if (get_securelevel() > 0) {
 		pr_notice(PREFIX
 			""securelevel enabled, ignoring table override\n"");
 		return;
 	}
 
  	acpi_tables_addr =
  		memblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,
  				       all_tables_size, PAGE_SIZE);
 	if (!acpi_tables_addr) {
 		WARN_ON(1);
 		return;
 	}
 	 
 	memblock_reserve(acpi_tables_addr, all_tables_size);
 	arch_reserve_mem_area(acpi_tables_addr, all_tables_size);
 
 	 
 	for (no = 0; no < table_nr; no++) {
 		unsigned char *src_p = acpi_initrd_files[no].data;
 		phys_addr_t size = acpi_initrd_files[no].size;
 		phys_addr_t dest_addr = acpi_tables_addr + total_offset;
 		phys_addr_t slop, clen;
 		char *dest_p;
 
 		total_offset += size;
 
 		while (size) {
 			slop = dest_addr & ~PAGE_MASK;
 			clen = size;
 			if (clen > MAP_CHUNK_SIZE - slop)
 				clen = MAP_CHUNK_SIZE - slop;
 			dest_p = early_ioremap(dest_addr & PAGE_MASK,
 						 clen + slop);
 			memcpy(dest_p + slop, src_p, clen);
 			early_iounmap(dest_p, clen + slop);
 			src_p += clen;
 			dest_addr += clen;
 			size -= clen;
 		}
 	}
 }","[59, 60, 61, 62, 63, 64]","The Linux kernel, as used in Red Hat Enterprise Linux 7.2 and Red Hat Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended Secure Boot restrictions and execute untrusted code by appending ACPI tables to the initrd."
207487," static int process_cmd_sock(int h)
 
  {
      sock_cmd_t cmd = {-1, 0, 0, 0, 0};
      int fd = ts[h].cmd_fdr;
    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
     if(TEMP_FAILURE_RETRY(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL)) != sizeof(cmd))
      {
          APPL_TRACE_ERROR(""recv cmd errno:%d"", errno);
          return FALSE;
  }
     APPL_TRACE_DEBUG(""cmd.id:%d"", cmd.id);
  switch(cmd.id)
  {
  case CMD_ADD_FD:
             add_poll(h, cmd.fd, cmd.type, cmd.flags, cmd.user_id);
  break;
  case CMD_REMOVE_FD:
  for (int i = 1; i < MAX_POLL; ++i)
  {
  poll_slot_t *poll_slot = &ts[h].ps[i];
  if (poll_slot->pfd.fd == cmd.fd)
  {
                     remove_poll(h, poll_slot, poll_slot->flags);
  break;
  }
  }
             close(cmd.fd);
  break;
  case CMD_WAKEUP:
  break;
  case CMD_USER_PRIVATE:
             asrt(ts[h].cmd_callback);
  if(ts[h].cmd_callback)
                 ts[h].cmd_callback(fd, cmd.type, cmd.flags, cmd.user_id);
  break;
  case CMD_EXIT:
  return FALSE;
  default:
             APPL_TRACE_DEBUG(""unknown cmd: %d"", cmd.id);
  break;
  }
  return TRUE;
 }","[7, 6]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
204462," void LauncherView::CalculateIdealBounds(IdealBounds* bounds) {
   int available_size = primary_axis_coordinate(width(), height());
    if (!available_size)
      return;
  
  int x = primary_axis_coordinate(kLeadingInset, 0);
  int y = primary_axis_coordinate(0, kLeadingInset);
   int x = primary_axis_coordinate(leading_inset(), 0);
   int y = primary_axis_coordinate(0, leading_inset());
    for (int i = 0; i < view_model_->view_size(); ++i) {
     if (i < first_visible_index_) {
       view_model_->set_ideal_bounds(i, gfx::Rect(x, y, 0, 0));
       continue;
     }
 
      view_model_->set_ideal_bounds(i, gfx::Rect(
          x, y, kLauncherPreferredSize, kLauncherPreferredSize));
      x = primary_axis_coordinate(x + kLauncherPreferredSize + kButtonSpacing, 0);
      y = primary_axis_coordinate(0, y + kLauncherPreferredSize + kButtonSpacing);
    }
  
   int app_list_index = view_model_->view_size() - 1;
   if (is_overflow_mode()) {
     last_visible_index_ = app_list_index - 1;
     for (int i = 0; i < view_model_->view_size(); ++i) {
       view_model_->view_at(i)->SetVisible(
           i >= first_visible_index_ && i <= last_visible_index_);
     }
     return;
   }
 
    if (view_model_->view_size() > 0) {
      view_model_->set_ideal_bounds(0, gfx::Rect(gfx::Size(
        primary_axis_coordinate(kLeadingInset + kLauncherPreferredSize,
         primary_axis_coordinate(leading_inset() + kLauncherPreferredSize,
                                  kLauncherPreferredSize),
          primary_axis_coordinate(kLauncherPreferredSize,
                                kLeadingInset + kLauncherPreferredSize))));
                                 leading_inset() + kLauncherPreferredSize))));
    }
  
    bounds->overflow_bounds.set_size(
        gfx::Size(kLauncherPreferredSize, kLauncherPreferredSize));
    last_visible_index_ = DetermineLastVisibleIndex(
      available_size - kLeadingInset - kLauncherPreferredSize -
       available_size - leading_inset() - kLauncherPreferredSize -
        kButtonSpacing - kLauncherPreferredSize);
  int app_list_index = view_model_->view_size() - 1;
    bool show_overflow = (last_visible_index_ + 1 < app_list_index);
  
    for (int i = 0; i < view_model_->view_size(); ++i) {
     view_model_->view_at(i)->SetVisible(
         i == app_list_index || i <= last_visible_index_);
   }
 
   overflow_button_->SetVisible(show_overflow);
    if (show_overflow) {
      DCHECK_NE(0, view_model_->view_size());
      if (last_visible_index_ == -1) {
      x = primary_axis_coordinate(kLeadingInset, 0);
      y = primary_axis_coordinate(0, kLeadingInset);
       x = primary_axis_coordinate(leading_inset(), 0);
       y = primary_axis_coordinate(0, leading_inset());
      } else {
        x = primary_axis_coordinate(
            view_model_->ideal_bounds(last_visible_index_).right(), 0);
        y = primary_axis_coordinate(0,
            view_model_->ideal_bounds(last_visible_index_).bottom());
      }
      gfx::Rect app_list_bounds = view_model_->ideal_bounds(app_list_index);
     bounds->overflow_bounds.set_x(x);
     bounds->overflow_bounds.set_y(y);
     x = primary_axis_coordinate(x + kLauncherPreferredSize + kButtonSpacing, 0);
     y = primary_axis_coordinate(0, y + kLauncherPreferredSize + kButtonSpacing);
      app_list_bounds.set_x(x);
      app_list_bounds.set_y(y);
      view_model_->set_ideal_bounds(app_list_index, app_list_bounds);
    x = primary_axis_coordinate(x + kLauncherPreferredSize + kButtonSpacing, 0);
    y = primary_axis_coordinate(0, y + kLauncherPreferredSize + kButtonSpacing);
    bounds->overflow_bounds.set_x(x);
    bounds->overflow_bounds.set_y(y);
   } else {
     if (overflow_bubble_.get())
       overflow_bubble_->Hide();
    }
  }","[8, 9, 11, 12, 13, 14, 15, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 35, 39, 46, 62, 63, 71, 72, 73, 74, 82, 83, 84, 6, 7, 34, 38, 45, 48, 60, 61, 78, 79, 80, 81]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
7635,"int luaopen_x509(lua_State *L)
{
auxiliar_newclass(L, ""openssl.x509"", x509_funcs);

lua_newtable(L);
luaL_setfuncs(L, R, 0);

openssl_register_xname(L);
lua_setfield(L, -2, ""name"");
openssl_register_xattribute(L);
lua_setfield(L, -2, ""attribute"");
openssl_register_xextension(L);
lua_setfield(L, -2, ""extension"");
openssl_register_xstore(L);
lua_setfield(L, -2, ""store"");
openssl_register_xalgor(L);
lua_setfield(L, -2, ""algor"");

luaopen_x509_req(L);
lua_setfield(L, -2, ""req"");
luaopen_x509_crl(L);
lua_setfield(L, -2, ""crl"");

lua_pushliteral(L, ""version"");
lua_pushliteral(L, MYVERSION);
lua_settable(L, -3);

return 1;
}",[28],openssl_x509_check_host in lua-openssl 0.7.7-1 mishandles X.509 certificate validation because it uses lua_pushboolean for certain non-boolean return values.
8050,"GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_packed_samples)
{
u32 i, j, sampNum;
u64 *DTSs, curDTS;
Bool inserted;
GF_SttsEntry *ent;

GF_TimeToSampleBox *stts = stbl->TimeToSample;


stts->r_FirstSampleInEntry = 0;

*sampleNumber = 0;
if (!nb_packed_samples)
nb_packed_samples=1;


if (!stts->nb_entries) {

if (DTS) return GF_BAD_PARAM;
stts->alloc_size = 1;
stts->nb_entries = 1;
stts->entries = gf_malloc(sizeof(GF_SttsEntry));
if (!stts->entries) return GF_OUT_OF_MEM;
stts->entries[0].sampleCount = nb_packed_samples;
stts->entries[0].sampleDelta = (nb_packed_samples>1) ? 0 : LastAUDefDuration;
(*sampleNumber) = 1;
stts->w_currentSampleNum = nb_packed_samples;
return GF_OK;
}

if (DTS >= stts->w_LastDTS) {
u32 nb_extra = 0;
ent = &stts->entries[stts->nb_entries-1];
if (!ent->sampleDelta && (ent->sampleCount>1)) {
ent->sampleDelta = (u32) ( DTS / ent->sampleCount);
stts->w_LastDTS = DTS - ent->sampleDelta;
}

if ((DTS == stts->w_LastDTS + ent->sampleDelta)


|| ((nb_packed_samples>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))
) {
(*sampleNumber) = stts->w_currentSampleNum + 1;
ent->sampleCount += nb_packed_samples;
stts->w_currentSampleNum += nb_packed_samples;
stts->w_LastDTS = DTS + ent->sampleDelta * (nb_packed_samples-1);
return GF_OK;
}

if (ent->sampleCount == 1) {

#if 0
if (stts->w_LastDTS)
ent->sampleDelta += (u32) (DTS - stts->w_LastDTS);
else
ent->sampleDelta = (u32) DTS;
#else

ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
#endif

ent->sampleCount ++;

if ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {
stts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;
stts->nb_entries--;
}
stts->w_currentSampleNum ++;
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum;
return GF_OK;
}

ent->sampleCount --;

if (nb_packed_samples>1)
nb_extra = 1;

if (stts->alloc_size <= stts->nb_entries + nb_extra) {
ALLOC_INC(stts->alloc_size);
stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );
}

if (nb_extra)
nb_extra = stts->entries[stts->nb_entries-1].sampleDelta;

ent = &stts->entries[stts->nb_entries];
stts->nb_entries++;

if (nb_packed_samples==1) {
ent->sampleCount = 2;
ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum+1;
stts->w_currentSampleNum += 1;
return GF_OK;
}

ent->sampleCount = 1;
ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);

ent = &stts->entries[stts->nb_entries];
stts->nb_entries++;

ent->sampleCount = nb_packed_samples;
ent->sampleDelta = nb_extra;
stts->w_LastDTS = DTS;
(*sampleNumber) = stts->w_currentSampleNum + 1;
stts->w_currentSampleNum += nb_packed_samples;
return GF_OK;
}



DTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );
if (!DTSs) return GF_OUT_OF_MEM;
curDTS = 0;
sampNum = 0;
ent = NULL;
inserted = 0;
for (i=0; i<stts->nb_entries; i++) {
ent = & stts->entries[i];
for (j = 0; j<ent->sampleCount; j++) {
if (!inserted && (curDTS > DTS)) {
DTSs[sampNum] = DTS;
sampNum++;
*sampleNumber = sampNum;
inserted = 1;
}
DTSs[sampNum] = curDTS;
curDTS += ent->sampleDelta;
sampNum ++;
}
}
if (!inserted) {
gf_free(DTSs);
return GF_BAD_PARAM;
}


if (stts->nb_entries+3 >= stts->alloc_size) {
stts->alloc_size += 3;
stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );
}


j=0;
stts->nb_entries = 1;
stts->entries[0].sampleCount = 1;
stts->entries[0].sampleDelta = (u32) DTSs[1]                           ;
for (i=1; i<stbl->SampleSize->sampleCount+1; i++) {
if (i == stbl->SampleSize->sampleCount) {

stts->entries[j].sampleCount++;
} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {
stts->entries[j].sampleCount ++;
} else {
stts->nb_entries ++;
j++;
stts->entries[j].sampleCount = 1;
stts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);
}
}
gf_free(DTSs);


stts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;
return GF_OK;
}","[14, 15, 25, 26, 28, 43, 46, 47, 48, 78, 94, 109, 113]",Buffer overflow in the stbl_AppendSize function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.
205869," void VRDisplay::BeginPresent() {
   Document* doc = this->GetDocument();
   if (capabilities_->hasExternalDisplay()) {
     ForceExitPresent();
     DOMException* exception = DOMException::Create(
         kInvalidStateError,
         ""VR Presentation not implemented for this VRDisplay."");
     while (!pending_present_resolvers_.IsEmpty()) {
       ScriptPromiseResolver* resolver = pending_present_resolvers_.TakeFirst();
       resolver->Reject(exception);
     }
     ReportPresentationResult(
         PresentationResult::kPresentationNotSupportedByDisplay);
     return;
   } else {
     if (layer_.source().isHTMLCanvasElement()) {
     } else {
       DCHECK(layer_.source().isOffscreenCanvas());
       ForceExitPresent();
       DOMException* exception = DOMException::Create(
           kInvalidStateError, ""OffscreenCanvas presentation not implemented."");
       while (!pending_present_resolvers_.IsEmpty()) {
         ScriptPromiseResolver* resolver =
             pending_present_resolvers_.TakeFirst();
         resolver->Reject(exception);
       }
       ReportPresentationResult(
           PresentationResult::kPresentationNotSupportedByDisplay);
       return;
     }
   }
 
   if (doc) {
     Platform::Current()->RecordRapporURL(""VR.WebVR.PresentSuccess"",
                                          WebURL(doc->Url()));
   }
 
   is_presenting_ = true;
   ReportPresentationResult(PresentationResult::kSuccess);
 
   UpdateLayerBounds();
 
   while (!pending_present_resolvers_.IsEmpty()) {
     ScriptPromiseResolver* resolver = pending_present_resolvers_.TakeFirst();
      resolver->Resolve();
    }
    OnPresentChange();
 
    
    
    
   if (!pending_vrdisplay_raf_ && !capabilities_->hasExternalDisplay()) {
     double timestamp = WTF::MonotonicallyIncreasingTime();
     Platform::Current()->CurrentThread()->GetWebTaskRunner()->PostTask(
         BLINK_FROM_HERE, WTF::Bind(&VRDisplay::ProcessScheduledWindowAnimations,
                                    WrapWeakPersistent(this), timestamp));
   }
  }","[48, 49, 50, 51, 52, 53, 54, 55, 56, 57]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
6394,"void M_LoadDefaults (void)
{
int  i;
int  len;
FILE* f;
char def[80];
char strparm[100];
char* newstring;
int  parm;
boolean isstring;


numdefaults = sizeof(defaults)/sizeof(defaults[0]);
for (i=0 ; i<numdefaults ; i++)
*defaults[i].location = defaults[i].defaultvalue;


i = M_CheckParm (""-config"");
if (i && i<myargc-1)
{
defaultfile = myargv[i+1];
printf (""	default file: %s\n"",defaultfile);
}
else
defaultfile = basedefault;


f = fopen (defaultfile, ""r"");
if (f)
{
while (!feof(f))
{
isstring = false;
if (fscanf (f, ""%79s %[^\n]\n"", def, strparm) == 2)
{
if (strparm[0] == '""')
{

isstring = true;
len = strlen(strparm);
newstring = (char *) malloc(len);
strparm[len-1] = 0;
strcpy(newstring, strparm+1);
}
else if (strparm[0] == '0' && strparm[1] == 'x')
sscanf(strparm+2, ""%x"", &parm);
else
sscanf(strparm, ""%i"", &parm);
for (i=0 ; i<numdefaults ; i++)
if (!strcmp(def, defaults[i].name))
{
if (!isstring)
*defaults[i].location = parm;
else
*defaults[i].location =
(int) newstring;
break;
}
}
}

fclose (f);
}

for (i = 0; i < numdefaults; i++)
{
if (defaults[i].scantranslate)
{
parm = *defaults[i].location;
defaults[i].untranslated = parm;
*defaults[i].location = scantokey[parm];
}
}
}",[34],"A buffer overflow in the M_LoadDefaults function in m_misc.c in id Tech 1 (aka Doom engine) allows arbitrary code execution via an unsafe usage of fscanf, because it does not limit the number of characters to be read in a format argument."
202711," pcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,
     char *errbuf, int *err)
 {
 	bpf_u_int32 magic_int;
 	size_t amt_read;
 	bpf_u_int32 total_length;
 	bpf_u_int32 byte_order_magic;
 	struct block_header *bhdrp;
 	struct section_header_block *shbp;
 	pcap_t *p;
 	int swapped = 0;
 	struct pcap_ng_sf *ps;
 	int status;
 	struct block_cursor cursor;
 	struct interface_description_block *idbp;
 
 	 
 	*err = 0;
 
 	 
 	memcpy(&magic_int, magic, sizeof(magic_int));
 	if (magic_int != BT_SHB) {
 		 
 		return (NULL);	 
 	}
 
 	 
 	amt_read = fread(&total_length, 1, sizeof(total_length), fp);
 	if (amt_read < sizeof(total_length)) {
 		if (ferror(fp)) {
 			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, ""error reading dump file"");
 			*err = 1;
 			return (NULL);	 
 		}
 
 		 
 		return (NULL);
 	}
 	amt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);
 	if (amt_read < sizeof(byte_order_magic)) {
 		if (ferror(fp)) {
 			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
 			    errno, ""error reading dump file"");
 			*err = 1;
 			return (NULL);	 
 		}
 
 		 
 		return (NULL);
 	}
 	if (byte_order_magic != BYTE_ORDER_MAGIC) {
 		byte_order_magic = SWAPLONG(byte_order_magic);
 		if (byte_order_magic != BYTE_ORDER_MAGIC) {
 			 
 			return (NULL);
 		}
 		swapped = 1;
 		total_length = SWAPLONG(total_length);
 	}
 
 	 
  	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
              (total_length > BT_SHB_INSANE_MAX)) {
  		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
		    ""Section Header Block in pcapng dump file has invalid length %"" PRIsize "" < _%lu_ < %lu (BT_SHB_INSANE_MAX)"",
                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
                              total_length,
                              BT_SHB_INSANE_MAX);
 		    ""Section Header Block in pcapng dump file has invalid length %"" PRIsize "" < _%u_ < %u (BT_SHB_INSANE_MAX)"",
 		    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),
 		    total_length,
 		    BT_SHB_INSANE_MAX);
  
  		*err = 1;
  		return (NULL);
 	}
 
 
 
 	 
 	p = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));
 	if (p == NULL) {
 		 
 		*err = 1;
 		return (NULL);
 	}
 	p->swapped = swapped;
 	ps = p->priv;
 
 	 
 	switch (precision) {
 
 	case PCAP_TSTAMP_PRECISION_MICRO:
 		ps->user_tsresol = 1000000;
 		break;
 
 	case PCAP_TSTAMP_PRECISION_NANO:
 		ps->user_tsresol = 1000000000;
 		break;
 
 	default:
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    ""unknown time stamp resolution %u"", precision);
 		free(p);
 		*err = 1;
 		return (NULL);
 	}
 
 	p->opt.tstamp_precision = precision;
 
 	 
 	p->bufsize = 2048;
 	if (p->bufsize < total_length)
 		p->bufsize = total_length;
 	p->buffer = malloc(p->bufsize);
 	if (p->buffer == NULL) {
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""out of memory"");
 		free(p);
 		*err = 1;
 		return (NULL);
 	}
 	ps->max_blocksize = INITIAL_MAX_BLOCKSIZE;
 
 	 
 	bhdrp = (struct block_header *)p->buffer;
 	shbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));
 	bhdrp->block_type = magic_int;
 	bhdrp->total_length = total_length;
 	shbp->byte_order_magic = byte_order_magic;
 	if (read_bytes(fp,
 	    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
 	    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),
 	    1, errbuf) == -1)
 		goto fail;
 
 	if (p->swapped) {
 		 
 		shbp->major_version = SWAPSHORT(shbp->major_version);
 		shbp->minor_version = SWAPSHORT(shbp->minor_version);
 
 		 
 	}
 	 
 	if (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&
 	       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
 		    ""unsupported pcapng savefile version %u.%u"",
 		    shbp->major_version, shbp->minor_version);
 		goto fail;
 	}
 	p->version_major = shbp->major_version;
 	p->version_minor = shbp->minor_version;
 
 	 
 	p->opt.tstamp_precision = precision;
 
 	 
 	for (;;) {
 		 
 		status = read_block(fp, p, &cursor, errbuf);
 		if (status == 0) {
 			 
 			pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
 			    ""the capture file has no Interface Description Blocks"");
 			goto fail;
 		}
 		if (status == -1)
 			goto fail;	 
 		switch (cursor.block_type) {
 
 		case BT_IDB:
 			 
 			idbp = get_from_block_data(&cursor, sizeof(*idbp),
 			    errbuf);
 			if (idbp == NULL)
 				goto fail;	 
 
 			 
 			if (p->swapped) {
 				idbp->linktype = SWAPSHORT(idbp->linktype);
 				idbp->snaplen = SWAPLONG(idbp->snaplen);
 			}
 
 			 
 			if (!add_interface(p, &cursor, errbuf))
 				goto fail;
 
 			goto done;
 
 		case BT_EPB:
 		case BT_SPB:
 		case BT_PB:
 			 
 			pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,
 			    ""the capture file has a packet block before any Interface Description Blocks"");
 			goto fail;
 
 		default:
 			 
 			break;
 		}
 	}
 
 done:
 	p->tzoff = 0;	 
 	p->linktype = linktype_to_dlt(idbp->linktype);
 	p->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);
 	p->linktype_ext = 0;
 
 	 
 	if (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)
 		ps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));
 
 	p->next_packet_op = pcap_ng_next_packet;
 	p->cleanup_op = pcap_ng_cleanup;
 
 	return (p);
 
 fail:
 	free(ps->ifaces);
 	free(p->buffer);
 	free(p);
 	*err = 1;
 	return (NULL);
 }","[70, 71, 72, 73, 66, 67, 68, 69]",sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.
5994,"ast_for_arguments(struct compiling *c, const node *n)
{



















int i, j, k, nposargs = 0, nkwonlyargs = 0;
int nposdefaults = 0, found_default = 0;
asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
arg_ty vararg = NULL, kwarg = NULL;
arg_ty arg = NULL;
node *ch;

if (TYPE(n) == parameters) {
if (NCH(n) == 2)
return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);
n = CHILD(n, 1);
}
assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);





for (i = 0; i < NCH(n); i++) {
ch = CHILD(n, i);
if (TYPE(ch) == STAR) {

i++;
if (i < NCH(n) &&
(TYPE(CHILD(n, i)) == tfpdef ||
TYPE(CHILD(n, i)) == vfpdef)) {
i++;
}
break;
}
if (TYPE(ch) == DOUBLESTAR) break;
if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;
if (TYPE(ch) == EQUAL) nposdefaults++;
}


for ( ; i < NCH(n); ++i) {
ch = CHILD(n, i);
if (TYPE(ch) == DOUBLESTAR) break;
if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;
}
posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);
if (!posargs && nposargs)
return NULL;
kwonlyargs = (nkwonlyargs ?
_Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
if (!kwonlyargs && nkwonlyargs)
return NULL;
posdefaults = (nposdefaults ?
_Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);
if (!posdefaults && nposdefaults)
return NULL;



kwdefaults = (nkwonlyargs ?
_Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
if (!kwdefaults && nkwonlyargs)
return NULL;




i = 0;
j = 0;
k = 0;
while (i < NCH(n)) {
ch = CHILD(n, i);
switch (TYPE(ch)) {
case tfpdef:
case vfpdef:



if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));
if (!expression)
return NULL;
assert(posdefaults != NULL);
asdl_seq_SET(posdefaults, j++, expression);
i += 2;
found_default = 1;
}
else if (found_default) {
ast_error(c, n,
""non-default argument follows default argument"");
return NULL;
}
arg = ast_for_arg(c, ch);
if (!arg)
return NULL;
asdl_seq_SET(posargs, k++, arg);
i += 1;
if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
i += 1;
break;
case STAR:
if (i+1 >= NCH(n) ||
(i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA
|| TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {
ast_error(c, CHILD(n, i),
""named arguments must follow bare *"");
return NULL;
}
ch = CHILD(n, i+1);
if (TYPE(ch) == COMMA) {
int res = 0;
i += 2;

if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
ast_error(c, CHILD(n, i),
""bare * has associated type comment"");
return NULL;
}

res = handle_keywordonly_args(c, n, i,
kwonlyargs, kwdefaults);
if (res == -1) return NULL;
i = res;
}
else {
vararg = ast_for_arg(c, ch);
if (!vararg)
return NULL;

i += 2;
if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
i += 1;

if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));
if (!vararg->type_comment)
return NULL;
i += 1;
}

if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
|| TYPE(CHILD(n, i)) == vfpdef)) {
int res = 0;
res = handle_keywordonly_args(c, n, i,
kwonlyargs, kwdefaults);
if (res == -1) return NULL;
i = res;
}
}
break;
case DOUBLESTAR:
ch = CHILD(n, i+1);
assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);
kwarg = ast_for_arg(c, ch);
if (!kwarg)
return NULL;
i += 2;
if (TYPE(CHILD(n, i)) == COMMA)
i += 1;
break;
case TYPE_COMMENT:
assert(i);

if (kwarg)
arg = kwarg;


arg->type_comment = NEW_TYPE_COMMENT(ch);
if (!arg->type_comment)
return NULL;
i += 1;
break;
default:
PyErr_Format(PyExc_SystemError,
""unexpected node in varargslist: %d @ %d"",
TYPE(ch), i);
return NULL;
}
}
return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);
}",[175],"typed_ast 1.3.0 and 1.3.1 has a handle_keywordonly_args out-of-bounds read. An attacker with the ability to cause a Python interpreter to parse Python source (but not necessarily execute it) may be able to crash the interpreter process. This could be a concern, for example, in a web-based service that parses (but does not execute) Python code. (This issue also affected certain Python 3.8.0-alpha prereleases.)"
202170," static ssize_t map_write(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos,
 			 int cap_setid,
 			 struct uid_gid_map *map,
 			 struct uid_gid_map *parent_map)
 {
 	struct seq_file *seq = file->private_data;
 	struct user_namespace *ns = seq->private;
 	struct uid_gid_map new_map;
 	unsigned idx;
 	struct uid_gid_extent extent;
 	char *kbuf = NULL, *pos, *next_line;
 	ssize_t ret;
 
 	 
 	if ((*ppos != 0) || (count >= PAGE_SIZE))
 		return -EINVAL;
 
 	 
 	kbuf = memdup_user_nul(buf, count);
 	if (IS_ERR(kbuf))
 		return PTR_ERR(kbuf);
 
 	 
 	mutex_lock(&userns_state_mutex);
 
 	memset(&new_map, 0, sizeof(struct uid_gid_map));
 
 	ret = -EPERM;
 	 
 	if (map->nr_extents != 0)
 		goto out;
 
 	 
 	if (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN))
 		goto out;
 
 	 
 	ret = -EINVAL;
 	pos = kbuf;
 	for (; pos; pos = next_line) {
 
 		 
 		next_line = strchr(pos, '\n');
 		if (next_line) {
 			*next_line = '\0';
 			next_line++;
 			if (*next_line == '\0')
 				next_line = NULL;
 		}
 
 		pos = skip_spaces(pos);
 		extent.first = simple_strtoul(pos, &pos, 10);
 		if (!isspace(*pos))
 			goto out;
 
 		pos = skip_spaces(pos);
 		extent.lower_first = simple_strtoul(pos, &pos, 10);
 		if (!isspace(*pos))
 			goto out;
 
 		pos = skip_spaces(pos);
 		extent.count = simple_strtoul(pos, &pos, 10);
 		if (*pos && !isspace(*pos))
 			goto out;
 
 		 
 		pos = skip_spaces(pos);
 		if (*pos != '\0')
 			goto out;
 
 		 
 		if ((extent.first == (u32) -1) ||
 		    (extent.lower_first == (u32) -1))
 			goto out;
 
 		 
 		if ((extent.first + extent.count) <= extent.first)
 			goto out;
 		if ((extent.lower_first + extent.count) <=
 		     extent.lower_first)
 			goto out;
 
 		 
 		if (mappings_overlap(&new_map, &extent))
 			goto out;
 
 		if ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS &&
 		    (next_line != NULL))
 			goto out;
 
 		ret = insert_extent(&new_map, &extent);
 		if (ret < 0)
 			goto out;
 		ret = -EINVAL;
 	}
 	 
 	if (new_map.nr_extents == 0)
 		goto out;
 
 	ret = -EPERM;
 	 
  	if (!new_idmap_permitted(file, ns, cap_setid, &new_map))
  		goto out;
  
	ret = sort_idmaps(&new_map);
	if (ret < 0)
		goto out;
  	ret = -EPERM;
  	 
 	for (idx = 0; idx < new_map.nr_extents; idx++) {
 		struct uid_gid_extent *e;
 		u32 lower_first;
 
 		if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS)
 			e = &new_map.extent[idx];
 		else
 			e = &new_map.forward[idx];
 
 		lower_first = map_id_range_down(parent_map,
 						e->lower_first,
 						e->count);
 
 		 
 		if (lower_first == (u32) -1)
 			goto out;
 
  		e->lower_first = lower_first;
  	}
  
 	 
 	ret = sort_idmaps(&new_map);
 	if (ret < 0)
 		goto out;
 
  	 
  	if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {
  		memcpy(map->extent, new_map.extent,
 		       new_map.nr_extents * sizeof(new_map.extent[0]));
 	} else {
 		map->forward = new_map.forward;
 		map->reverse = new_map.reverse;
 	}
 	smp_wmb();
 	map->nr_extents = new_map.nr_extents;
 
 	*ppos = count;
 	ret = count;
 out:
 	if (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) {
 		kfree(new_map.forward);
 		kfree(new_map.reverse);
 		map->forward = NULL;
 		map->reverse = NULL;
 		map->nr_extents = 0;
 	}
 
 	mutex_unlock(&userns_state_mutex);
 	kfree(kbuf);
 	return ret;
 }","[131, 132, 133, 134, 135, 106, 107, 108]","In the Linux kernel 4.15.x through 4.19.x before 4.19.2, map_write() in kernel/user_namespace.c allows privilege escalation because it mishandles nested user namespaces with more than 5 UID or GID ranges. A user who has CAP_SYS_ADMIN in an affected user namespace can bypass access controls on resources outside the namespace, as demonstrated by reading /etc/shadow. This occurs because an ID transformation takes place properly for the namespaced-to-kernel direction but not for the kernel-to-namespaced direction."
206389," DataReductionProxyIOData::DataReductionProxyIOData(
     Client client,
     PrefService* prefs,
     network::NetworkConnectionTracker* network_connection_tracker,
     scoped_refptr<base::SingleThreadTaskRunner> io_task_runner,
     scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner,
     bool enabled,
     const std::string& user_agent,
     const std::string& channel)
     : client_(client),
       network_connection_tracker_(network_connection_tracker),
       io_task_runner_(io_task_runner),
       ui_task_runner_(ui_task_runner),
       enabled_(enabled),
       channel_(channel),
       effective_connection_type_(net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {
   DCHECK(io_task_runner_);
   DCHECK(ui_task_runner_);
   configurator_.reset(new DataReductionProxyConfigurator());
   configurator_->SetConfigUpdatedCallback(base::BindRepeating(
       &DataReductionProxyIOData::OnProxyConfigUpdated, base::Unretained(this)));
   DataReductionProxyMutableConfigValues* raw_mutable_config = nullptr;
     std::unique_ptr<DataReductionProxyMutableConfigValues> mutable_config =
         std::make_unique<DataReductionProxyMutableConfigValues>();
     raw_mutable_config = mutable_config.get();
     config_.reset(new DataReductionProxyConfig(
         io_task_runner, ui_task_runner, network_connection_tracker_,
         std::move(mutable_config), configurator_.get()));
     request_options_.reset(
         new DataReductionProxyRequestOptions(client_, config_.get()));
     request_options_->Init();
     request_options_->SetUpdateHeaderCallback(base::BindRepeating(
         &DataReductionProxyIOData::UpdateProxyRequestHeaders,
         base::Unretained(this)));
 
    config_client_.reset(new DataReductionProxyConfigServiceClient(
        GetBackoffPolicy(), request_options_.get(), raw_mutable_config,
        config_.get(), this, network_connection_tracker_,
        base::BindRepeating(&DataReductionProxyIOData::StoreSerializedConfig,
                            base::Unretained(this))));
     if (!params::IsIncludedInHoldbackFieldTrial()) {
       config_client_.reset(new DataReductionProxyConfigServiceClient(
           GetBackoffPolicy(), request_options_.get(), raw_mutable_config,
           config_.get(), this, network_connection_tracker_,
           base::BindRepeating(&DataReductionProxyIOData::StoreSerializedConfig,
                               base::Unretained(this))));
     }
  
      network_properties_manager_.reset(new NetworkPropertiesManager(
          base::DefaultClock::GetInstance(), prefs, ui_task_runner_));
 }","[41, 42, 43, 44, 45, 46, 47, 36, 37, 38, 39, 40]","A use after free in PDFium in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
200434," static __init int hardware_setup(void)
 {
 	int r = -ENOMEM, i, msr;
 
 	rdmsrl_safe(MSR_EFER, &host_efer);
 
 	for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)
 		kvm_define_shared_msr(i, vmx_msr_index[i]);
 
 	vmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_io_bitmap_a)
 		return r;
 
 	vmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_io_bitmap_b)
 		goto out;
 
 	vmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_msr_bitmap_legacy)
 		goto out1;
 
 	vmx_msr_bitmap_legacy_x2apic =
 				(unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_msr_bitmap_legacy_x2apic)
 		goto out2;
 
 	vmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_msr_bitmap_longmode)
 		goto out3;
 
 	vmx_msr_bitmap_longmode_x2apic =
 				(unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_msr_bitmap_longmode_x2apic)
 		goto out4;
 
 	if (nested) {
 		vmx_msr_bitmap_nested =
 			(unsigned long *)__get_free_page(GFP_KERNEL);
 		if (!vmx_msr_bitmap_nested)
 			goto out5;
 	}
 
 	vmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_vmread_bitmap)
 		goto out6;
 
 	vmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL);
 	if (!vmx_vmwrite_bitmap)
 		goto out7;
 
 	memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE);
 	memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE);
 
 	 
 	memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE);
 	clear_bit(0x80, vmx_io_bitmap_a);
 
 	memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE);
 
 	memset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE);
 	memset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE);
 	if (nested)
 		memset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE);
 
 	if (setup_vmcs_config(&vmcs_config) < 0) {
 		r = -EIO;
 		goto out8;
 	}
 
 	if (boot_cpu_has(X86_FEATURE_NX))
 		kvm_enable_efer_bits(EFER_NX);
 
 	if (!cpu_has_vmx_vpid())
 		enable_vpid = 0;
 	if (!cpu_has_vmx_shadow_vmcs())
 		enable_shadow_vmcs = 0;
 	if (enable_shadow_vmcs)
 		init_vmcs_shadow_fields();
 
 	if (!cpu_has_vmx_ept() ||
 	    !cpu_has_vmx_ept_4levels()) {
 		enable_ept = 0;
 		enable_unrestricted_guest = 0;
 		enable_ept_ad_bits = 0;
 	}
 
 	if (!cpu_has_vmx_ept_ad_bits())
 		enable_ept_ad_bits = 0;
 
 	if (!cpu_has_vmx_unrestricted_guest())
 		enable_unrestricted_guest = 0;
 
 	if (!cpu_has_vmx_flexpriority())
 		flexpriority_enabled = 0;
 
 	 
 	if (!flexpriority_enabled)
 		kvm_x86_ops->set_apic_access_page_addr = NULL;
 
 	if (!cpu_has_vmx_tpr_shadow())
 		kvm_x86_ops->update_cr8_intercept = NULL;
 
 	if (enable_ept && !cpu_has_vmx_ept_2m_page())
 		kvm_disable_largepages();
 
 	if (!cpu_has_vmx_ple())
 		ple_gap = 0;
 
 	if (!cpu_has_vmx_apicv())
 		enable_apicv = 0;
 
 	if (cpu_has_vmx_tsc_scaling()) {
 		kvm_has_tsc_control = true;
 		kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;
 		kvm_tsc_scaling_ratio_frac_bits = 48;
 	}
 
 	vmx_disable_intercept_for_msr(MSR_FS_BASE, false);
 	vmx_disable_intercept_for_msr(MSR_GS_BASE, false);
 	vmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true);
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false);
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false);
 	vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false);
 	vmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true);
 
 	memcpy(vmx_msr_bitmap_legacy_x2apic,
 			vmx_msr_bitmap_legacy, PAGE_SIZE);
 	memcpy(vmx_msr_bitmap_longmode_x2apic,
 			vmx_msr_bitmap_longmode, PAGE_SIZE);
  
  	set_bit(0, vmx_vpid_bitmap);  
  
	if (enable_apicv) {
		for (msr = 0x800; msr <= 0x8ff; msr++)
			vmx_disable_intercept_msr_read_x2apic(msr);
		 
		vmx_enable_intercept_msr_read_x2apic(0x802);
		 
		vmx_enable_intercept_msr_read_x2apic(0x839);
		 
		vmx_disable_intercept_msr_write_x2apic(0x808);
		 
		vmx_disable_intercept_msr_write_x2apic(0x80b);
		 
		vmx_disable_intercept_msr_write_x2apic(0x83f);
	}
 	for (msr = 0x800; msr <= 0x8ff; msr++)
 		vmx_disable_intercept_msr_read_x2apic(msr);
 
 	 
 	vmx_enable_intercept_msr_read_x2apic(0x802);
 	 
 	vmx_enable_intercept_msr_read_x2apic(0x839);
 	 
 	vmx_disable_intercept_msr_write_x2apic(0x808);
 	 
 	vmx_disable_intercept_msr_write_x2apic(0x80b);
 	 
 	vmx_disable_intercept_msr_write_x2apic(0x83f);
  
  	if (enable_ept) {
  		kvm_mmu_set_mask_ptes(0ull,
 			(enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull,
 			(enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull,
 			0ull, VMX_EPT_EXECUTABLE_MASK);
 		ept_set_mmio_spte_mask();
 		kvm_enable_tdp();
 	} else
 		kvm_disable_tdp();
 
 	update_ple_window_actual_max();
 
 	 
 	if (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())
 		enable_pml = 0;
 
 	if (!enable_pml) {
 		kvm_x86_ops->slot_enable_log_dirty = NULL;
 		kvm_x86_ops->slot_disable_log_dirty = NULL;
 		kvm_x86_ops->flush_log_dirty = NULL;
 		kvm_x86_ops->enable_log_dirty_pt_masked = NULL;
 	}
 
 	kvm_set_posted_intr_wakeup_handler(wakeup_handler);
 
 	return alloc_kvm_area();
 
 out8:
 	free_page((unsigned long)vmx_vmwrite_bitmap);
 out7:
 	free_page((unsigned long)vmx_vmread_bitmap);
 out6:
 	if (nested)
 		free_page((unsigned long)vmx_msr_bitmap_nested);
 out5:
 	free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);
 out4:
 	free_page((unsigned long)vmx_msr_bitmap_longmode);
 out3:
 	free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);
 out2:
 	free_page((unsigned long)vmx_msr_bitmap_legacy);
 out1:
 	free_page((unsigned long)vmx_io_bitmap_b);
 out:
 	free_page((unsigned long)vmx_io_bitmap_a);
 
     return r;
 }","[147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146]","arch/x86/kvm/vmx.c in the Linux kernel through 4.6.3 mishandles the APICv on/off state, which allows guest OS users to obtain direct APIC MSR access on the host OS, and consequently cause a denial of service (host OS crash) or possibly execute arbitrary code on the host OS, via x2APIC mode."
205215,"  void BrowserCommandController::TabReplacedAt(TabStripModel* tab_strip_model,
                                               TabContents* old_contents,
                                               TabContents* new_contents,
                                               int index) {
  RemoveInterstitialObservers(old_contents);
   RemoveInterstitialObservers(old_contents->web_contents());
    AddInterstitialObservers(new_contents->web_contents());
  }","[6, 5]","The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors."
204726," void RenderViewTest::SetUp() {
   if (!GetContentClient()->renderer())
     GetContentClient()->set_renderer(&mock_content_renderer_client_);
 
   if (!render_thread_.get())
     render_thread_.reset(new MockRenderThread());
   render_thread_->set_routing_id(kRouteId);
   render_thread_->set_surface_id(kSurfaceId);
   render_thread_->set_new_window_routing_id(kNewWindowRouteId);
 
   command_line_.reset(new CommandLine(CommandLine::NO_PROGRAM));
   params_.reset(new content::MainFunctionParams(*command_line_));
   platform_.reset(new RendererMainPlatformDelegate(*params_));
   platform_->PlatformInitialize();
 
    webkit_glue::SetJavaScriptFlags("" --expose-gc"");
    WebKit::initialize(&webkit_platform_support_);
  
    
    
   RenderThreadImpl::RegisterSchemes();
 
    mock_process_.reset(new MockRenderProcess);
  
   RenderViewImpl* view = RenderViewImpl::Create(
       0,
       kOpenerId,
       content::RendererPreferences(),
       WebPreferences(),
       new SharedRenderViewCounter(0),
       kRouteId,
       kSurfaceId,
       kInvalidSessionStorageNamespaceId,
       string16(),
       1,
       WebKit::WebScreenInfo(),
       false);
   view->AddRef();
   view_ = view;
 
   mock_keyboard_.reset(new MockKeyboard());
 }","[19, 20, 21, 22]","Google Chrome before 19.0.1084.46 does not properly perform window navigation, which has unspecified impact and remote attack vectors."
201949," MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)
 {
 #define MaxDirectoryStack  16
 #define EXIF_DELIMITER  ""\n""
 #define EXIF_NUM_FORMATS  12
 #define TAG_EXIF_OFFSET  0x8769
 #define TAG_INTEROP_OFFSET  0xa005
 
   typedef struct _DirectoryInfo
   {
     unsigned char
       *directory;
 
     size_t
       entry;
   } DirectoryInfo;
 
   DirectoryInfo
     directory_stack[MaxDirectoryStack];
 
   EndianType
     endian;
 
   size_t
     entry,
     length,
     number_entries;
 
   ssize_t
     id,
     level,
     offset;
 
   static int
     format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};
 
   unsigned char
     *directory,
     *exif;
 
    
   length=GetStringInfoLength(profile);
   exif=GetStringInfoDatum(profile);
   if (length < 16)
     return(MagickFalse);
   id=(ssize_t) ReadProfileShort(LSBEndian,exif);
   if ((id != 0x4949) && (id != 0x4D4D))
     {
       while (length != 0)
       {
         if (ReadProfileByte(&exif,&length) != 0x45)
           continue;
         if (ReadProfileByte(&exif,&length) != 0x78)
           continue;
         if (ReadProfileByte(&exif,&length) != 0x69)
           continue;
         if (ReadProfileByte(&exif,&length) != 0x66)
           continue;
         if (ReadProfileByte(&exif,&length) != 0x00)
           continue;
         if (ReadProfileByte(&exif,&length) != 0x00)
           continue;
         break;
       }
       if (length < 16)
         return(MagickFalse);
       id=(ssize_t) ReadProfileShort(LSBEndian,exif);
     }
   endian=LSBEndian;
   if (id == 0x4949)
     endian=LSBEndian;
   else
     if (id == 0x4D4D)
       endian=MSBEndian;
     else
       return(MagickFalse);
   if (ReadProfileShort(endian,exif+2) != 0x002a)
     return(MagickFalse);
    
   offset=(ssize_t) ReadProfileLong(endian,exif+4);
   if ((offset < 0) || (size_t) offset >= length)
     return(MagickFalse);
   directory=exif+offset;
   level=0;
   entry=0;
   do
   {
     if (level > 0)
       {
         level--;
         directory=directory_stack[level].directory;
         entry=directory_stack[level].entry;
       }
     if ((directory < exif) || (directory > (exif+length-2)))
       break;
      
     number_entries=ReadProfileShort(endian,directory);
     for ( ; entry < number_entries; entry++)
     {
       int
         components;
 
       register unsigned char
         *p,
         *q;
 
       size_t
         number_bytes;
 
       ssize_t
         format,
         tag_value;
 
       q=(unsigned char *) (directory+2+(12*entry));
       if (q > (exif+length-12))
          break;   
        tag_value=(ssize_t) ReadProfileShort(endian,q);
        format=(ssize_t) ReadProfileShort(endian,q+2);
      if ((format-1) >= EXIF_NUM_FORMATS)
       if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))
          break;
        components=(ssize_t) ReadProfileLong(endian,q+4);
        if (components < 0)
         break;   
       number_bytes=(size_t) components*format_bytes[format];
       if ((ssize_t) number_bytes < components)
         break;   
       if (number_bytes <= 4)
         p=q+8;
       else
         {
            
           offset=(ssize_t)  ReadProfileLong(endian,q+8);
           if ((size_t) (offset+number_bytes) > length)
             continue;
           if (~length < number_bytes)
             continue;   
           p=(unsigned char *) (exif+offset);
         }
       switch (tag_value)
       {
         case 0x011a:
         {
           (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);
           (void) WriteProfileLong(endian,1UL,p+4);
           break;
         }
         case 0x011b:
         {
           (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);
           (void) WriteProfileLong(endian,1UL,p+4);
           break;
         }
         case 0x0112:
         {
           if (number_bytes == 4)
             {
               (void) WriteProfileLong(endian,(size_t) image->orientation,p);
               break;
             }
           (void) WriteProfileShort(endian,(unsigned short) image->orientation,
             p);
           break;
         }
         case 0x0128:
         {
           if (number_bytes == 4)
             {
               (void) WriteProfileLong(endian,(size_t) (image->units+1),p);
               break;
             }
           (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);
           break;
         }
         default:
           break;
       }
       if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))
         {
           offset=(ssize_t)  ReadProfileLong(endian,p);
           if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))
             {
               directory_stack[level].directory=directory;
               entry++;
               directory_stack[level].entry=entry;
               level++;
               directory_stack[level].directory=exif+offset;
               directory_stack[level].entry=0;
               level++;
               if ((directory+2+(12*number_entries)) > (exif+length))
                 break;
               offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*
                 number_entries));
               if ((offset != 0) && ((size_t) offset < length) &&
                   (level < (MaxDirectoryStack-2)))
                 {
                   directory_stack[level].directory=exif+offset;
                   directory_stack[level].entry=0;
                   level++;
                 }
             }
           break;
         }
     }
   } while (level > 0);
   return(MagickTrue);
 }","[120, 119]",MagickCore/profile.c in ImageMagick before 7.0.3-2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
198246," static void php_snmp_error(zval *object, const char *docref, int type, const char *format, ...)
 {
 	va_list args;
 	php_snmp_object *snmp_object = NULL;
 
 	if (object) {
 		snmp_object = Z_SNMP_P(object);
 		if (type == PHP_SNMP_ERRNO_NOERROR) {
 			memset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr));
 		} else {
 			va_start(args, format);
 			vsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args);
 			va_end(args);
 		}
 		snmp_object->snmp_errno = type;
 	}
 
 	if (type == PHP_SNMP_ERRNO_NOERROR) {
 		return;
         }
  
         if (object && (snmp_object->exceptions_enabled & type)) {
               zend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr);
                zend_throw_exception_ex(php_snmp_exception_ce, type, ""%s"", snmp_object->snmp_errstr);
         } else {
                 va_start(args, format);
                 php_verror(docref, """", E_WARNING, format, args);
 		va_end(args);
 	}
 }","[24, 23]","Format string vulnerability in the php_snmp_error function in ext/snmp/snmp.c in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to execute arbitrary code via format string specifiers in an SNMP::get call."
197804,"  static void build_l4proto_tcp(const struct nf_conntrack *ct, struct nethdr *n)
  {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
  	if (!nfct_attr_is_set(ct, ATTR_TCP_STATE))
  		return;
  
 	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
 		      sizeof(struct nfct_attr_grp_port));
  	ct_build_u8(ct, ATTR_TCP_STATE, n, NTA_TCP_STATE);
  	if (CONFIG(sync).tcp_window_tracking) {
  		ct_build_u8(ct, ATTR_TCP_WSCALE_ORIG, n, NTA_TCP_WSCALE_ORIG);
 		ct_build_u8(ct, ATTR_TCP_WSCALE_REPL, n, NTA_TCP_WSCALE_REPL);
 	}
 }","[8, 9, 3, 4]","conntrackd in conntrack-tools 1.4.2 and earlier does not ensure that the optional kernel modules are loaded before using them, which allows remote attackers to cause a denial of service (crash) via a (1) DCCP, (2) SCTP, or (3) ICMPv6 packet."
4078,"static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,
unsigned int *pv)
{
unsigned int field_type;
unsigned int value_count;

field_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);
value_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);

if(value_count!=1) return 0;

if(field_type==3) {
*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);
return 1;
}
else if(field_type==4) {
*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);
return 1;
}

return 0;
}","[7, 8, 13, 17]","The iw_get_ui16le function in imagew-util.c:405:23 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (invalid read and SEGV) via a crafted image, related to imagew-jpeg.c."
206317," static bool ShouldAutofocus(const HTMLFormControlElement* element) {
   if (!element->isConnected())
     return false;
   if (!element->IsAutofocusable())
     return false;
 
 
 
    Document& doc = element->GetDocument();
  
   if (!doc.GetFrame())
     return false;
  
   if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {
     doc.AddConsoleMessage(ConsoleMessage::Create(
         mojom::ConsoleMessageSource::kSecurity,
         mojom::ConsoleMessageLevel::kError,
         ""Blocked autofocusing on a form control because the form's frame is ""
         ""sandboxed and the 'allow-scripts' permission is not set.""));
     return false;
   }
 
   if (!doc.IsInMainFrame() &&
       !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {
     doc.AddConsoleMessage(ConsoleMessage::Create(
         mojom::ConsoleMessageSource::kSecurity,
         mojom::ConsoleMessageLevel::kError,
         ""Blocked autofocusing on a form control in a cross-origin subframe.""));
     return false;
   }
 
   return true;
 }","[11, 12]","Type confusion in PDFium in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to potentially maliciously modify objects via a crafted PDF file."
9461,"xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,
xmlAttrPtr attr) {
xmlRefPtr ret;
xmlRefTablePtr table;
xmlListPtr ref_list;

if (doc == NULL) {
return(NULL);
}
if (value == NULL) {
return(NULL);
}
if (attr == NULL) {
return(NULL);
}




table = (xmlRefTablePtr) doc->refs;
if (table == NULL) {
doc->refs = table = xmlHashCreateDict(0, doc->dict);
}
if (table == NULL) {
xmlVErrMemory(ctxt,
""xmlAddRef: Table creation failed!\n"");
return(NULL);
}

ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));
if (ret == NULL) {
xmlVErrMemory(ctxt, ""malloc failed"");
return(NULL);
}




ret->value = xmlStrdup(value);
if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {



ret->name = xmlStrdup(attr->name);
ret->attr = NULL;
} else {
ret->name = NULL;
ret->attr = attr;
}
ret->lineno = xmlGetLineNo(attr->parent);








if (NULL == (ref_list = xmlHashLookup(table, value))) {
if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list creation failed!\n"",
NULL);
goto failed;
}
if (xmlHashAddEntry(table, value, ref_list) < 0) {
xmlListDelete(ref_list);
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list insertion failed!\n"",
NULL);
goto failed;
}
}
if (xmlListAppend(ref_list, ret) != 0) {
xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,
""xmlAddRef: Reference list insertion failed!\n"",
NULL);
goto failed;
}
return(ret);
failed:
if (ret != NULL) {
if (ret->value != NULL)
xmlFree((char *)ret->value);
if (ret->name != NULL)
xmlFree((char *)ret->name);
xmlFree(ret);
}
return(NULL);
}",[40],valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.
199568," hstore_from_array(PG_FUNCTION_ARGS)
 {
 	ArrayType  *in_array = PG_GETARG_ARRAYTYPE_P(0);
 	int			ndims = ARR_NDIM(in_array);
 	int			count;
 	int32		buflen;
 	HStore	   *out;
 	Pairs	   *pairs;
 	Datum	   *in_datums;
 	bool	   *in_nulls;
 	int			in_count;
 	int			i;
 
 	Assert(ARR_ELEMTYPE(in_array) == TEXTOID);
 
 	switch (ndims)
 	{
 		case 0:
 			out = hstorePairs(NULL, 0, 0);
 			PG_RETURN_POINTER(out);
 
 		case 1:
 			if ((ARR_DIMS(in_array)[0]) % 2)
 				ereport(ERROR,
 						(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 						 errmsg(""array must have even number of elements"")));
 			break;
 
 		case 2:
 			if ((ARR_DIMS(in_array)[1]) != 2)
 				ereport(ERROR,
 						(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 						 errmsg(""array must have two columns"")));
 			break;
 
 		default:
 			ereport(ERROR,
 					(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),
 					 errmsg(""wrong number of array subscripts"")));
 	}
 
 	deconstruct_array(in_array,
 					  TEXTOID, -1, false, 'i',
 					  &in_datums, &in_nulls, &in_count);
  
  	count = in_count / 2;
  
 	 
 	if (count > MaxAllocSize / sizeof(Pairs))
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 			  errmsg(""number of pairs (%d) exceeds the maximum allowed (%d)"",
 					 count, (int) (MaxAllocSize / sizeof(Pairs)))));
 
  	pairs = palloc(count * sizeof(Pairs));
  
  	for (i = 0; i < count; ++i)
 	{
 		if (in_nulls[i * 2])
 			ereport(ERROR,
 					(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
 					 errmsg(""null value not allowed for hstore key"")));
 
 		if (in_nulls[i * 2 + 1])
 		{
 			pairs[i].key = VARDATA_ANY(in_datums[i * 2]);
 			pairs[i].val = NULL;
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));
 			pairs[i].vallen = 4;
 			pairs[i].isnull = true;
 			pairs[i].needfree = false;
 		}
 		else
 		{
 			pairs[i].key = VARDATA_ANY(in_datums[i * 2]);
 			pairs[i].val = VARDATA_ANY(in_datums[i * 2 + 1]);
 			pairs[i].keylen = hstoreCheckKeyLen(VARSIZE_ANY_EXHDR(in_datums[i * 2]));
 			pairs[i].vallen = hstoreCheckValLen(VARSIZE_ANY_EXHDR(in_datums[i * 2 + 1]));
 			pairs[i].isnull = false;
 			pairs[i].needfree = false;
 		}
 	}
 
 	count = hstoreUniquePairs(pairs, count, &buflen);
 
 	out = hstorePairs(pairs, count, buflen);
 
 	PG_RETURN_POINTER(out);
 }","[48, 49, 50, 51, 52, 53, 54]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
197874," void aes_crypt_ecb( aes_context *ctx,
                     int mode,
                     const unsigned char input[16],
                     unsigned char output[16] )
 {
     int i;
     unsigned long *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
 
 #if defined(XYSSL_PADLOCK_C) && defined(XYSSL_HAVE_X86)
     if( padlock_supports( PADLOCK_ACE ) )
     {
         if( padlock_xcryptecb( ctx, mode, input, output ) == 0 )
             return;
      }
  #endif
  
     if (ctx == NULL || ctx->rk == NULL)
         return;
 
      RK = ctx->rk;
  
      GET_ULONG_LE( X0, input,  0 ); X0 ^= *RK++;
 
     if( mode == AES_DECRYPT )
     {
         for( i = (ctx->nr >> 1) - 1; i > 0; i-- )
         {
             AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
             AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
         }
 
         AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 
         X0 = *RK++ ^ ( RSb[ ( Y0       ) & 0xFF ]       ) ^
                      ( RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)RSb[ ( Y1 >> 24 ) & 0xFF ]) << 24 );
 
         X1 = *RK++ ^ ( RSb[ ( Y1       ) & 0xFF ]       ) ^
                      ( RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)RSb[ ( Y2 >> 24 ) & 0xFF ]) << 24 );
 
         X2 = *RK++ ^ ( RSb[ ( Y2       ) & 0xFF ]       ) ^
                      ( RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)RSb[ ( Y3 >> 24 ) & 0xFF ]) << 24 );
 
         X3 = *RK++ ^ ( RSb[ ( Y3       ) & 0xFF ]       ) ^
                      ( RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)RSb[ ( Y0 >> 24 ) & 0xFF ]) << 24 );
     }
     else  
     {
         for( i = (ctx->nr >> 1) - 1; i > 0; i-- )
         {
             AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
             AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
         }
 
         AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
 
         X0 = *RK++ ^ ( FSb[ ( Y0       ) & 0xFF ]       ) ^
                      ( FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)FSb[ ( Y3 >> 24 ) & 0xFF ]) << 24 );
 
         X1 = *RK++ ^ ( FSb[ ( Y1       ) & 0xFF ]       ) ^
                      ( FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)FSb[ ( Y0 >> 24 ) & 0xFF ]) << 24 );
 
         X2 = *RK++ ^ ( FSb[ ( Y2       ) & 0xFF ]       ) ^
                      ( FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)FSb[ ( Y1 >> 24 ) & 0xFF ]) << 24 );
 
         X3 = *RK++ ^ ( FSb[ ( Y3       ) & 0xFF ]       ) ^
                      ( FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
                      ( FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
                      ( ((unsigned int)FSb[ ( Y2 >> 24 ) & 0xFF ]) << 24 );
     }
 
     PUT_ULONG_LE( X0, output,  0 );
     PUT_ULONG_LE( X1, output,  4 );
     PUT_ULONG_LE( X2, output,  8 );
     PUT_ULONG_LE( X3, output, 12 );
 }","[17, 18, 19]","In Artifex Ghostscript 9.23 before 2018-08-24, attackers able to supply crafted PostScript could use uninitialized memory access in the aesdecode operator to crash the interpreter or potentially execute code."
205124,"  void LocalFileSystem::fileSystemAllowedInternal(
      PassRefPtrWillBeRawPtr<ExecutionContext> context,
      FileSystemType type,
    PassRefPtr<CallbackWrapper> callbacks)
     CallbackWrapper* callbacks)
  {
      if (!fileSystem()) {
          fileSystemNotAvailable(context, callbacks);
         return;
     }
 
     KURL storagePartition = KURL(KURL(), context->securityOrigin()->toString());
     fileSystem()->openFileSystem(storagePartition, static_cast<WebFileSystemType>(type), callbacks->release());
 }","[5, 4]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
199409," __switch_to(struct task_struct *prev_p, struct task_struct *next_p)
 {
 	struct thread_struct *prev = &prev_p->thread;
 	struct thread_struct *next = &next_p->thread;
 	int cpu = smp_processor_id();
 	struct tss_struct *tss = &per_cpu(init_tss, cpu);
 	unsigned fsindex, gsindex;
 	fpu_switch_t fpu;
  
  	fpu = switch_fpu_prepare(prev_p, next_p, cpu);
  
 	 
  	load_sp0(tss, next);
  
	 
	savesegment(es, prev->es);
	if (unlikely(next->es | prev->es))
		loadsegment(es, next->es);
	savesegment(ds, prev->ds);
	if (unlikely(next->ds | prev->ds))
		loadsegment(ds, next->ds);
  	 
  	savesegment(fs, fsindex);
  	savesegment(gs, gsindex);
  
 	 
  	load_TLS(next, cpu);
  
  	 
  	arch_end_context_switch(next_p);
  
 	 
 	savesegment(es, prev->es);
 	if (unlikely(next->es | prev->es))
 		loadsegment(es, next->es);
 
 	savesegment(ds, prev->ds);
 	if (unlikely(next->ds | prev->ds))
 		loadsegment(ds, next->ds);
 
  	 
  	if (unlikely(fsindex | next->fsindex | prev->fs)) {
  		loadsegment(fs, next->fsindex);
 
  		 
  		if (fsindex)
  			prev->fs = 0;
  	}
	 
  	if (next->fs)
  		wrmsrl(MSR_FS_BASE, next->fs);
  	prev->fsindex = fsindex;
  
  	if (unlikely(gsindex | next->gsindex | prev->gs)) {
  		load_gs_index(next->gsindex);
 
 		 
  		if (gsindex)
  			prev->gs = 0;
  	}
 	if (next->gs)
 		wrmsrl(MSR_KERNEL_GS_BASE, next->gs);
 	prev->gsindex = gsindex;
 
 	switch_fpu_finish(next_p, fpu);
 
 	 
 	prev->usersp = this_cpu_read(old_rsp);
 	this_cpu_write(old_rsp, next->usersp);
 	this_cpu_write(current_task, next_p);
 
 	 
 	task_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);
 	this_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);
 
 	this_cpu_write(kernel_stack,
 		  (unsigned long)task_stack_page(next_p) +
 		  THREAD_SIZE - KERNEL_STACK_OFFSET);
 
 	 
 	if (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||
 		     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))
 		__switch_to_xtra(prev_p, next_p, tss);
 
 	return prev_p;
 }","[26, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 56, 57, 15, 16, 17, 18, 19, 20, 21, 49]","The __switch_to function in arch/x86/kernel/process_64.c in the Linux kernel through 3.18.1 does not ensure that Thread Local Storage (TLS) descriptors are loaded before proceeding with other steps, which makes it easier for local users to bypass the ASLR protection mechanism via a crafted application that reads a TLS base address."
200415," MagickExport MagickBooleanType DrawClipPath(Image *image,
   const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)
 {
   char
     filename[MagickPathExtent];
 
   Image
     *clip_mask;
 
   const char
     *value;
 
   DrawInfo
     *clone_info;
 
   MagickStatusType
     status;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   assert(draw_info != (const DrawInfo *) NULL);
   (void) FormatLocaleString(filename,MagickPathExtent,""%s"",name);
   value=GetImageArtifact(image,filename);
   if (value == (const char *) NULL)
     return(MagickFalse);
   clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);
   if (clip_mask == (Image *) NULL)
      return(MagickFalse);
    (void) QueryColorCompliance(""#0000"",AllCompliance,
      &clip_mask->background_color,exception);
  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;
   clip_mask->background_color.alpha=(MagickRealType) TransparentAlpha;
    (void) SetImageBackgroundColor(clip_mask,exception);
    if (image->debug != MagickFalse)
      (void) LogMagickEvent(DrawEvent,GetMagickModule(),""\nbegin clip-path %s"",
       draw_info->clip_mask);
   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   (void) CloneString(&clone_info->primitive,value);
   (void) QueryColorCompliance(""#ffffff"",AllCompliance,&clone_info->fill,
     exception);
   clone_info->clip_mask=(char *) NULL;
   status=NegateImage(clip_mask,MagickFalse,exception);
   (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);
   clip_mask=DestroyImage(clip_mask);
   status&=DrawImage(image,clone_info,exception);
   clone_info=DestroyDrawInfo(clone_info);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),""end clip-path"");
   return(status != 0 ? MagickTrue : MagickFalse);
 }","[34, 33]","The DrawImage function in MagickCore/draw.c in ImageMagick before 6.9.4-0 and 7.x before 7.0.1-2 makes an incorrect function call in attempting to locate the next token, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
201317,"  static int copy_cred(struct svc_cred *target, struct svc_cred *source)
  {
	int ret;
 	target->cr_principal = kstrdup(source->cr_principal, GFP_KERNEL);
 	target->cr_raw_principal = kstrdup(source->cr_raw_principal,
 								GFP_KERNEL);
 	if ((source->cr_principal && ! target->cr_principal) ||
 	    (source->cr_raw_principal && ! target->cr_raw_principal))
 		return -ENOMEM;
  
	ret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);
	if (ret)
		return ret;
	ret = strdup_if_nonnull(&target->cr_raw_principal,
					source->cr_raw_principal);
	if (ret)
		return ret;
  	target->cr_flavor = source->cr_flavor;
  	target->cr_uid = source->cr_uid;
  	target->cr_gid = source->cr_gid;
 	target->cr_group_info = source->cr_group_info;
 	get_group_info(target->cr_group_info);
 	target->cr_gss_mech = source->cr_gss_mech;
 	if (source->cr_gss_mech)
 		gss_mech_get(source->cr_gss_mech);
 	return 0;
 }","[4, 5, 6, 7, 8, 9, 3, 11, 12, 13, 14, 15, 16, 17]","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
199157,"  void ipc_rcu_putref(void *ptr)
  {
	if (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)
 	if (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))
  		return;
  
  	if (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {
 		call_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,
 				ipc_schedule_free);
 	} else {
 		kfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);
 	}
 }","[4, 3]","The ipc_rcu_putref function in ipc/util.c in the Linux kernel before 3.10 does not properly manage a reference count, which allows local users to cause a denial of service (memory consumption or system crash) via a crafted application."
8236,"static enum vfp_status v_matchproto_(vfp_pull_f)
h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)
{
struct h2_req *r2;
struct h2_sess *h2;
unsigned l;
enum vfp_status retval = VFP_OK;

CHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);
CHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);
CAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);
h2 = r2->h2sess;

AN(ptr);
AN(lp);
l = *lp;
*lp = 0;

Lck_Lock(&h2->sess->mtx);
assert (r2->state == H2_S_OPEN);
r2->cond = &vc->wrk->cond;
while (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)
AZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));
r2->cond = NULL;
if (h2->error || r2->error) {
retval = VFP_ERROR;
} else {
assert(h2->mailcall == r2);
if (l > h2->rxf_len)
l = h2->rxf_len;
if (l > 0) {
memcpy(ptr, h2->rxf_data, l);
h2->rxf_data += l;
h2->rxf_len -= l;
}
*lp = l;
if (h2->rxf_len > 0) {


Lck_Unlock(&h2->sess->mtx);
return (VFP_OK);
}
if (h2->rxf_len == 0) {
if (h2->rxf_flags & H2FF_DATA_END_STREAM) {
retval = VFP_END;
r2->state = H2_S_CLOS_REM;
}
}
h2->mailcall = NULL;
AZ(pthread_cond_signal(h2->cond));
}
Lck_Unlock(&h2->sess->mtx);
return (retval);
}","[7, 20, 43, 44, 45, 46]","Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8."
205039," void PPB_Buffer_Proxy::OnMsgCreate(
     PP_Instance instance,
     uint32_t size,
     HostResource* result_resource,
     ppapi::proxy::SerializedHandle* result_shm_handle) {
   result_shm_handle->set_null_shmem();
    HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);
    if (!dispatcher)
      return;
   if (!dispatcher->permissions().HasPermission(ppapi::PERMISSION_DEV))
     return;
  
    thunk::EnterResourceCreation enter(instance);
    if (enter.failed())
     return;
   PP_Resource local_buffer_resource = enter.functions()->CreateBuffer(instance,
                                                                       size);
   if (local_buffer_resource == 0)
     return;
 
   thunk::EnterResourceNoLock<thunk::PPB_BufferTrusted_API> trusted_buffer(
       local_buffer_resource, false);
   if (trusted_buffer.failed())
     return;
   int local_fd;
   if (trusted_buffer.object()->GetSharedMemory(&local_fd) != PP_OK)
     return;
 
   result_resource->SetHostResource(instance, local_buffer_resource);
 
   base::PlatformFile platform_file =
 #if defined(OS_WIN)
       reinterpret_cast<HANDLE>(static_cast<intptr_t>(local_fd));
 #elif defined(OS_POSIX)
       local_fd;
 #else
   #error Not implemented.
 #endif
   result_shm_handle->set_shmem(
       dispatcher->ShareHandleWithRemote(platform_file, false), size);
 }","[10, 11]","Use-after-free vulnerability in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to databases."
198665,"  jbig2_decode_mmr_init(Jbig2MmrCtx *mmr, int width, int height, const byte *data, size_t size)
  {
    int i;
     size_t i;
      uint32_t word = 0;
  
      mmr->width = width;
     mmr->size = size;
     mmr->data_index = 0;
     mmr->bit_index = 0;
 
     for (i = 0; i < size && i < 4; i++)
         word |= (data[i] << ((3 - i) << 3));
     mmr->word = word;
 }","[4, 3]","ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript."
200608," static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct net_device *netdev;
 	struct atl2_adapter *adapter;
 	static int cards_found;
 	unsigned long mmio_start;
 	int mmio_len;
 	int err;
 
 	cards_found = 0;
 
 	err = pci_enable_device(pdev);
 	if (err)
 		return err;
 
 	 
 	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) &&
 		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {
 		printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n"");
 		goto err_dma;
 	}
 
 	 
 	err = pci_request_regions(pdev, atl2_driver_name);
 	if (err)
 		goto err_pci_reg;
 
 	 
 	pci_set_master(pdev);
 
 	err = -ENOMEM;
 	netdev = alloc_etherdev(sizeof(struct atl2_adapter));
 	if (!netdev)
 		goto err_alloc_etherdev;
 
 	SET_NETDEV_DEV(netdev, &pdev->dev);
 
 	pci_set_drvdata(pdev, netdev);
 	adapter = netdev_priv(netdev);
 	adapter->netdev = netdev;
 	adapter->pdev = pdev;
 	adapter->hw.back = adapter;
 
 	mmio_start = pci_resource_start(pdev, 0x0);
 	mmio_len = pci_resource_len(pdev, 0x0);
 
 	adapter->hw.mem_rang = (u32)mmio_len;
 	adapter->hw.hw_addr = ioremap(mmio_start, mmio_len);
 	if (!adapter->hw.hw_addr) {
 		err = -EIO;
 		goto err_ioremap;
 	}
 
 	atl2_setup_pcicmd(pdev);
 
 	netdev->netdev_ops = &atl2_netdev_ops;
 	netdev->ethtool_ops = &atl2_ethtool_ops;
 	netdev->watchdog_timeo = 5 * HZ;
 	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);
 
 	netdev->mem_start = mmio_start;
 	netdev->mem_end = mmio_start + mmio_len;
 	adapter->bd_number = cards_found;
 	adapter->pci_using_64 = false;
 
 	 
 	err = atl2_sw_init(adapter);
 	if (err)
 		goto err_sw_init;
  
  	err = -EIO;
  
	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;
 	netdev->hw_features = NETIF_F_HW_VLAN_CTAG_RX;
  	netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
  
  	 
 	atl2_phy_init(&adapter->hw);
 
 	 
 
 	if (atl2_reset_hw(&adapter->hw)) {
 		err = -EIO;
 		goto err_reset;
 	}
 
 	 
 	atl2_read_mac_addr(&adapter->hw);
 	memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len);
 	if (!is_valid_ether_addr(netdev->dev_addr)) {
 		err = -EIO;
 		goto err_eeprom;
 	}
 
 	atl2_check_options(adapter);
 
 	setup_timer(&adapter->watchdog_timer, atl2_watchdog,
 		    (unsigned long)adapter);
 
 	setup_timer(&adapter->phy_config_timer, atl2_phy_config,
 		    (unsigned long)adapter);
 
 	INIT_WORK(&adapter->reset_task, atl2_reset_task);
 	INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task);
 
 	strcpy(netdev->name, ""eth%d"");  
 	err = register_netdev(netdev);
 	if (err)
 		goto err_register;
 
 	 
 	netif_carrier_off(netdev);
 	netif_stop_queue(netdev);
 
 	cards_found++;
 
 	return 0;
 
 err_reset:
 err_register:
 err_sw_init:
 err_eeprom:
 	iounmap(adapter->hw.hw_addr);
 err_ioremap:
 	free_netdev(netdev);
 err_alloc_etherdev:
 	pci_release_regions(pdev);
 err_pci_reg:
 err_dma:
 	pci_disable_device(pdev);
 	return err;
 }","[74, 73]","The atl2_probe function in drivers/net/ethernet/atheros/atlx/atl2.c in the Linux kernel through 4.5.2 incorrectly enables scatter/gather I/O, which allows remote attackers to obtain sensitive information from kernel memory by reading packet data."
8383,"enum sctp_disposition sctp_sf_do_8_5_1_E_sa(struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const union sctp_subtype type,
void *arg,
struct sctp_cmd_seq *commands)
{
struct sctp_chunk *chunk = arg;


if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))
return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
commands);






SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);

return sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);
}",[11],A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.
206501," error::Error GLES2DecoderPassthroughImpl::DoBeginQueryEXT(
     GLenum target,
     GLuint id,
     int32_t sync_shm_id,
     uint32_t sync_shm_offset) {
   GLuint service_id = GetQueryServiceID(id, &query_id_map_);
   QueryInfo* query_info = &query_info_map_[service_id];
 
   scoped_refptr<gpu::Buffer> buffer = GetSharedMemoryBuffer(sync_shm_id);
   if (!buffer)
     return error::kInvalidArguments;
   QuerySync* sync = static_cast<QuerySync*>(
       buffer->GetDataAddress(sync_shm_offset, sizeof(QuerySync)));
    if (!sync)
      return error::kOutOfBounds;
  
   if (target == GL_PROGRAM_COMPLETION_QUERY_CHROMIUM) {
     linking_program_service_id_ = 0u;
   }
    if (IsEmulatedQueryTarget(target)) {
      if (active_queries_.find(target) != active_queries_.end()) {
        InsertError(GL_INVALID_OPERATION, ""Query already active on target."");
       return error::kNoError;
     }
 
     if (id == 0) {
       InsertError(GL_INVALID_OPERATION, ""Query id is 0."");
       return error::kNoError;
     }
 
     if (query_info->type != GL_NONE && query_info->type != target) {
       InsertError(GL_INVALID_OPERATION,
                   ""Query type does not match the target."");
       return error::kNoError;
     }
   } else {
     CheckErrorCallbackState();
 
     api()->glBeginQueryFn(target, service_id);
 
     if (CheckErrorCallbackState()) {
       return error::kNoError;
     }
   }
 
   query_info->type = target;
 
   RemovePendingQuery(service_id);
 
   ActiveQuery query;
   query.service_id = service_id;
   query.shm = std::move(buffer);
   query.sync = sync;
   active_queries_[target] = std::move(query);
 
   return error::kNoError;
 }","[17, 18, 19]","A heap use after free in V8 in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
198322," static int interface_get_command(QXLInstance *sin, struct QXLCommandExt *ext)
 {
     SimpleSpiceDisplay *ssd = container_of(sin, SimpleSpiceDisplay, qxl);
      info->num_memslots = NUM_MEMSLOTS;
      info->num_memslots_groups = NUM_MEMSLOTS_GROUPS;
      info->internal_groupslot_id = 0;
    info->qxl_ram_size = ssd->bufsize;
     info->qxl_ram_size = 16 * 1024 * 1024;
      info->n_surfaces = ssd->num_surfaces;
  }","[8, 7]",The VGA emulator in QEMU allows local guest users to read host memory by setting the display to a high resolution.
7848,"inline void ComputeInterpolationWeights(
const int64 out_size, const int64 in_size, const float scale,
const int resolution, InterpolationCache<T_SCALE>* interpolation) {
const Scaler scaler;
interpolation->lower.resize(out_size + 1);
interpolation->upper.resize(out_size + 1);
interpolation->lerp.resize(out_size + 1);
interpolation->ilerp.resize(out_size + 1);

interpolation->lower[out_size] = 0;
interpolation->upper[out_size] = 0;
for (int64 i = out_size - 1; i >= 0; --i) {
const float in = scaler(i, scale);
const float in_f = std::floor(in);
interpolation->lower[i] =
std::max(static_cast<int64>(in_f), static_cast<int64>(0));
interpolation->upper[i] =
std::min(static_cast<int64>(std::ceil(in)), in_size - 1);
interpolation->lerp[i] = in - in_f;
interpolation->ilerp[i] =
static_cast<T_SCALE>((in - in_f) * (1 << resolution));
}
}",[19],"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in `tf.raw_ops.QuantizedResizeBilinear` by manipulating input values so that float rounding results in off-by-one error in accessing image elements. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L62-L66) computes two integers (representing the upper and lower bounds for interpolation) by ceiling and flooring a floating point value. For some values of `in`, `interpolation->upper[i]` might be smaller than `interpolation->lower[i]`. This is an issue if `interpolation->upper[i]` is capped at `in_size-1` as it means that `interpolation->lower[i]` points outside of the image. Then, in the interpolation code(https://github.com/tensorflow/tensorflow/blob/44b7f486c0143f68b56c34e2d01e146ee445134a/tensorflow/core/kernels/quantized_resize_bilinear_op.cc#L245-L264), this would result in heap buffer overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
198113," vcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)
 {
     VCardAPDU *new_apdu;
 
     *status = VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE;
     if (len < 4) {
         *status = VCARD7816_STATUS_ERROR_WRONG_LENGTH;
         return NULL;
     }
 
     new_apdu = g_new(VCardAPDU, 1);
     new_apdu->a_data = g_memdup(raw_apdu, len);
      new_apdu->a_len = len;
      *status = vcard_apdu_set_class(new_apdu);
      if (*status != VCARD7816_STATUS_SUCCESS) {
        g_free(new_apdu);
         vcard_apdu_delete(new_apdu);
          return NULL;
      }
      *status = vcard_apdu_set_length(new_apdu);
      if (*status != VCARD7816_STATUS_SUCCESS) {
        g_free(new_apdu);
         vcard_apdu_delete(new_apdu);
          new_apdu = NULL;
      }
      return new_apdu;
 }","[17, 23, 16, 22]",Memory leak in the vcard_apdu_new function in card_7816.c in libcacard before 2.5.3 allows local guest OS users to cause a denial of service (host memory consumption) via vectors related to allocating a new APDU object.
199117,"  void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
  {
  	u32 data;
	void *vapic;
  
  	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
  		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
  
  	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
  		return;
  
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
 	kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
 				sizeof(u32));
  
  	apic_set_tpr(vcpu->arch.apic, data & 0xff);
  }","[15, 16, 4, 12, 13, 14]",The KVM subsystem in the Linux kernel through 3.12.5 allows local users to gain privileges or cause a denial of service (system crash) via a VAPIC synchronization operation involving a page-end address.
203210," static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   char
     colorspace[MagickPathExtent],
     text[MagickPathExtent];
 
   Image
     *image;
 
   long
     x_offset,
     y_offset;
 
   PixelInfo
     pixel;
 
   MagickBooleanType
     status;
 
   QuantumAny
     range;
 
   register ssize_t
     i,
     x;
 
   register Quantum
     *q;
 
   ssize_t
     count,
     type,
     y;
 
   unsigned long
     depth,
     height,
     max_value,
     width;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   (void) ResetMagickMemory(text,0,sizeof(text));
   (void) ReadBlobString(image,text);
   if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   do
   {
     width=0;
     height=0;
     max_value=0;
     *colorspace='\0';
     count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value,
       colorspace);
     if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     image->columns=width;
     image->rows=height;
     for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;
     image->depth=depth;
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     LocaleLower(colorspace);
     i=(ssize_t) strlen(colorspace)-1;
     image->alpha_trait=UndefinedPixelTrait;
     if ((i > 0) && (colorspace[i] == 'a'))
       {
         colorspace[i]='\0';
         image->alpha_trait=BlendPixelTrait;
       }
     type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);
     if (type < 0)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     (void) SetImageBackgroundColor(image,exception);
     (void) SetImageColorspace(image,(ColorspaceType) type,exception);
     GetPixelInfo(image,&pixel);
     range=GetQuantumRange(image->depth);
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       double
         alpha,
         black,
         blue,
         green,
         red;
 
       red=0.0;
       green=0.0;
       blue=0.0;
       black=0.0;
       alpha=0.0;
       for (x=0; x < (ssize_t) image->columns; x++)
       {
         if (ReadBlobString(image,text) == (char *) NULL)
           break;
         switch (image->colorspace)
         {
           case GRAYColorspace:
           {
             if (image->alpha_trait != UndefinedPixelTrait)
               {
                 count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"",
                   &x_offset,&y_offset,&red,&alpha);
                 green=red;
                 blue=red;
                 break;
               }
             count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset,
               &y_offset,&red);
             green=red;
             blue=red;
             break;       
           }
           case CMYKColorspace:
           {
             if (image->alpha_trait != UndefinedPixelTrait)
               {
                 count=(ssize_t) sscanf(text,
                   ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                   &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);
                 break;
               }
             count=(ssize_t) sscanf(text,
               ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
               &y_offset,&red,&green,&blue,&black);
             break;
           }
           default:
           {
             if (image->alpha_trait != UndefinedPixelTrait)
               {
                 count=(ssize_t) sscanf(text,
                   ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",
                   &x_offset,&y_offset,&red,&green,&blue,&alpha);
                 break;
               }
             count=(ssize_t) sscanf(text,
               ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset,
               &y_offset,&red,&green,&blue);
             break;       
           }
         }
         if (strchr(text,'%') != (char *) NULL)
           {
             red*=0.01*range;
             green*=0.01*range;
             blue*=0.01*range;
             black*=0.01*range;
             alpha*=0.01*range;
           }
         if (image->colorspace == LabColorspace)
           {
             green+=(range+1)/2.0;
             blue+=(range+1)/2.0;
           }
         pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),
           range);
         pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),
           range);
         pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),
           range);
         pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),
           range);
         pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),
           range);
         q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,
           exception);
         if (q == (Quantum *) NULL)
           continue;
         SetPixelViaPixelInfo(image,&pixel,q);
         if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
        }
      }
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
      (void) ReadBlobString(image,text);
      if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)
        {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[189, 190, 191, 192, 193, 194]","The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered."
7406,"__Pyx_PyMODINIT_FUNC initvarint(void)
#else
__Pyx_PyMODINIT_FUNC PyInit_varint(void) CYTHON_SMALL_CODE;
__Pyx_PyMODINIT_FUNC PyInit_varint(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
#if PY_VERSION_HEX >= 0x030700A1
static PY_INT64_T main_interpreter_id = -1;
PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
if (main_interpreter_id == -1) {
main_interpreter_id = current_id;
return (unlikely(current_id == -1)) ? -1 : 0;
} else if (unlikely(main_interpreter_id != current_id))
#else
static PyInterpreterState *main_interpreter = NULL;
PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
if (!main_interpreter) {
main_interpreter = current_interpreter;
} else if (unlikely(main_interpreter != current_interpreter))
#endif
{
PyErr_SetString(
PyExc_ImportError,
""Interpreter change detected - this module can only be loaded into one interpreter per process."");
return -1;
}
return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
PyObject *value = PyObject_GetAttrString(spec, from_name);
int result = 0;
if (likely(value)) {
if (allow_none || value != Py_None) {
result = PyDict_SetItemString(moddict, to_name, value);
}
Py_DECREF(value);
} else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
PyErr_Clear();
} else {
result = -1;
}
return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
PyObject *module = NULL, *moddict, *modname;
if (__Pyx_check_single_interpreter())
return NULL;
if (__pyx_m)
return __Pyx_NewRef(__pyx_m);
modname = PyObject_GetAttrString(spec, ""name"");
if (unlikely(!modname)) goto bad;
module = PyModule_NewObject(modname);
Py_DECREF(modname);
if (unlikely(!module)) goto bad;
moddict = PyModule_GetDict(module);
if (unlikely(!moddict)) goto bad;
if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, ""loader"", ""__loader__"", 1) < 0)) goto bad;
if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, ""origin"", ""__file__"", 1) < 0)) goto bad;
if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, ""parent"", ""__package__"", 1) < 0)) goto bad;
if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, ""submodule_search_locations"", ""__path__"", 0) < 0)) goto bad;
return module;
bad:
Py_XDECREF(module);
return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec_varint(PyObject *__pyx_pyinit_module)
#endif
#endif
{
PyObject *__pyx_t_1 = NULL;
__Pyx_RefNannyDeclarations
#if CYTHON_PEP489_MULTI_PHASE_INIT
if (__pyx_m) {
if (__pyx_m == __pyx_pyinit_module) return 0;
PyErr_SetString(PyExc_RuntimeError, ""Module 'varint' has already been imported. Re-initialisation is not supported."");
return -1;
}
#elif PY_MAJOR_VERSION >= 3
if (__pyx_m) return __Pyx_NewRef(__pyx_m);
#endif
#if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI(""refnanny"");
if (!__Pyx_RefNanny) {
PyErr_Clear();
__Pyx_RefNanny = __Pyx_RefNannyImportAPI(""Cython.Runtime.refnanny"");
if (!__Pyx_RefNanny)
Py_FatalError(""failed to import 'refnanny' module"");
}
#endif
__Pyx_RefNannySetupContext(""__Pyx_PyMODINIT_FUNC PyInit_varint(void)"", 0);
if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#ifdef __Pxy_PyFrame_Initialize_Offsets
__Pxy_PyFrame_Initialize_Offsets();
#endif
__pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
__pyx_empty_bytes = PyBytes_FromStringAndSize("""", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
__pyx_empty_unicode = PyUnicode_FromStringAndSize("""", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
#ifdef __Pyx_CyFunction_USED
if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
#ifdef __Pyx_FusedFunction_USED
if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
#ifdef __Pyx_Coroutine_USED
if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
#ifdef __Pyx_Generator_USED
if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
#ifdef __Pyx_AsyncGen_USED
if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
#ifdef __Pyx_StopAsyncIteration_USED
if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif


#if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
#ifdef WITH_THREAD /* Python build with threading support? */
PyEval_InitThreads();
#endif
#endif

#if CYTHON_PEP489_MULTI_PHASE_INIT
__pyx_m = __pyx_pyinit_module;
Py_INCREF(__pyx_m);
#else
#if PY_MAJOR_VERSION < 3
__pyx_m = Py_InitModule4(""varint"", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
#else
__pyx_m = PyModule_Create(&__pyx_moduledef);
#endif
if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
__pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
Py_INCREF(__pyx_d);
__pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
Py_INCREF(__pyx_b);
__pyx_cython_runtime = PyImport_AddModule((char *) ""cython_runtime""); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
Py_INCREF(__pyx_cython_runtime);
if (PyObject_SetAttrString(__pyx_m, ""__builtins__"", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);

if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif
if (__pyx_module_is_main_clickhouse_driver__varint) {
if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
}
#if PY_MAJOR_VERSION >= 3
{
PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
if (!PyDict_GetItemString(modules, ""clickhouse_driver.varint"")) {
if (unlikely(PyDict_SetItemString(modules, ""clickhouse_driver.varint"", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
}
}
#endif

if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;

if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;

(void)__Pyx_modinit_global_init_code();
(void)__Pyx_modinit_variable_export_code();
(void)__Pyx_modinit_function_export_code();
(void)__Pyx_modinit_type_init_code();
if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;
(void)__Pyx_modinit_variable_import_code();
(void)__Pyx_modinit_function_import_code();

#if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
#endif








__pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_6varint_1write_varint, NULL, __pyx_n_s_clickhouse_driver_varint); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
__Pyx_GOTREF(__pyx_t_1);
if (PyDict_SetItem(__pyx_d, __pyx_n_s_write_varint, __pyx_t_1) < 0) __PYX_ERR(0, 4, __pyx_L1_error)
__Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;








__pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_17clickhouse_driver_6varint_3read_varint, NULL, __pyx_n_s_clickhouse_driver_varint); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 29, __pyx_L1_error)
__Pyx_GOTREF(__pyx_t_1);
if (PyDict_SetItem(__pyx_d, __pyx_n_s_read_varint, __pyx_t_1) < 0) __PYX_ERR(0, 29, __pyx_L1_error)
__Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;






__pyx_t_1 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1, __pyx_L1_error)
__Pyx_GOTREF(__pyx_t_1);
if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_1) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
__Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;



goto __pyx_L0;
__pyx_L1_error:;
__Pyx_XDECREF(__pyx_t_1);
if (__pyx_m) {
if (__pyx_d) {
__Pyx_AddTraceback(""init clickhouse_driver.varint"", __pyx_clineno, __pyx_lineno, __pyx_filename);
}
Py_CLEAR(__pyx_m);
} else if (!PyErr_Occurred()) {
PyErr_SetString(PyExc_ImportError, ""init clickhouse_driver.varint"");
}
__pyx_L0:;
__Pyx_RefNannyFinishContext();
#if CYTHON_PEP489_MULTI_PHASE_INIT
return (__pyx_m != NULL) ? 0 : -1;
#elif PY_MAJOR_VERSION >= 3
return __pyx_m;
#else
return;
#endif
}","[199, 201]","clickhouse-driver before 0.1.5 allows a malicious clickhouse server to trigger a crash or execute arbitrary code (on a database client) via a crafted server response, due to a buffer overflow."
207356," PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
      : content::RenderFrameObserver(render_frame),
        logging_state_active_(false),
        was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
       was_password_autofilled_(false) {
    Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
  }","[7, 5, 6]","The Autofill implementation in Google Chrome before 51.0.2704.63 mishandles the interaction between field updates and JavaScript code that triggers a frame deletion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site, a different vulnerability than CVE-2016-1701."
199845," spnego_gss_wrap_iov(OM_uint32 *minor_status,
 		    gss_ctx_id_t context_handle,
 		    int conf_req_flag,
 		    gss_qop_t qop_req,
 		    int *conf_state,
 		    gss_iov_buffer_desc *iov,
  		    int iov_count)
  {
  	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
 
 	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
 		return (GSS_S_NO_CONTEXT);
 
  	ret = gss_wrap_iov(minor_status,
			   context_handle,
 			   sc->ctx_handle,
  			   conf_req_flag,
  			   qop_req,
  			   conf_state,
 			   iov,
 			   iov_count);
 	return (ret);
 }","[10, 11, 12, 13, 14, 17, 16]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
198153," PS_SERIALIZER_DECODE_FUNC(php_binary)  
 {
 	const char *p;
 	char *name;
 	const char *endptr = val + vallen;
 	zval *current;
 	int namelen;
 	int has_value;
 	php_unserialize_data_t var_hash;
 
 	PHP_VAR_UNSERIALIZE_INIT(var_hash);
 
 	for (p = val; p < endptr; ) {
 		zval **tmp;
                 namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
  
                 if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
                        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
                         return FAILURE;
                 }
 
 		name = estrndup(p + 1, namelen);
 
 		p += namelen + 1;
 
 		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
 			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
 				efree(name);
 				continue;
 			}
 		}
 
 		if (has_value) {
 			ALLOC_INIT_ZVAL(current);
 			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
 				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
 			} else {
 				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 				return FAILURE;
 			}
 			var_push_dtor_no_addref(&var_hash, &current);
 		}
 		PS_ADD_VARL(name, namelen);
 		efree(name);
 	}
 
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 
 	return SUCCESS;
 }
  ",[18],"ext/session/session.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 does not properly maintain a certain hash data structure, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via vectors related to session deserialization."
200625," long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct tty_struct *tty = file_tty(file);
 	struct tty_struct *real_tty;
 	void __user *p = (void __user *)arg;
 	int retval;
 	struct tty_ldisc *ld;
 
 	if (tty_paranoia_check(tty, file_inode(file), ""tty_ioctl""))
 		return -EINVAL;
 
 	real_tty = tty_pair_get_tty(tty);
 
 	 
 	switch (cmd) {
 	case TIOCSETD:
 	case TIOCSBRK:
 	case TIOCCBRK:
 	case TCSBRK:
 	case TCSBRKP:
 		retval = tty_check_change(tty);
 		if (retval)
 			return retval;
 		if (cmd != TIOCCBRK) {
 			tty_wait_until_sent(tty, 0);
 			if (signal_pending(current))
 				return -EINTR;
 		}
 		break;
 	}
 
 	 
 	switch (cmd) {
 	case TIOCSTI:
 		return tiocsti(tty, p);
 	case TIOCGWINSZ:
 		return tiocgwinsz(real_tty, p);
 	case TIOCSWINSZ:
 		return tiocswinsz(real_tty, p);
 	case TIOCCONS:
 		return real_tty != tty ? -EINVAL : tioccons(file);
 	case FIONBIO:
 		return fionbio(file, p);
 	case TIOCEXCL:
 		set_bit(TTY_EXCLUSIVE, &tty->flags);
 		return 0;
 	case TIOCNXCL:
 		clear_bit(TTY_EXCLUSIVE, &tty->flags);
 		return 0;
 	case TIOCGEXCL:
 	{
 		int excl = test_bit(TTY_EXCLUSIVE, &tty->flags);
 		return put_user(excl, (int __user *)p);
 	}
 	case TIOCNOTTY:
 		if (current->signal->tty != tty)
 			return -ENOTTY;
 		no_tty();
 		return 0;
 	case TIOCSCTTY:
 		return tiocsctty(real_tty, file, arg);
 	case TIOCGPGRP:
 		return tiocgpgrp(tty, real_tty, p);
 	case TIOCSPGRP:
 		return tiocspgrp(tty, real_tty, p);
  	case TIOCGSID:
  		return tiocgsid(tty, real_tty, p);
  	case TIOCGETD:
		return put_user(tty->ldisc->ops->num, (int __user *)p);
 		return tiocgetd(tty, p);
  	case TIOCSETD:
  		return tiocsetd(tty, p);
  	case TIOCVHANGUP:
 		if (!capable(CAP_SYS_ADMIN))
 			return -EPERM;
 		tty_vhangup(tty);
 		return 0;
 	case TIOCGDEV:
 	{
 		unsigned int ret = new_encode_dev(tty_devnum(real_tty));
 		return put_user(ret, (unsigned int __user *)p);
 	}
 	 
 	case TIOCSBRK:	 
 		if (tty->ops->break_ctl)
 			return tty->ops->break_ctl(tty, -1);
 		return 0;
 	case TIOCCBRK:	 
 		if (tty->ops->break_ctl)
 			return tty->ops->break_ctl(tty, 0);
 		return 0;
 	case TCSBRK:    
 		 
 		if (!arg)
 			return send_break(tty, 250);
 		return 0;
 	case TCSBRKP:	 
 		return send_break(tty, arg ? arg*100 : 250);
 
 	case TIOCMGET:
 		return tty_tiocmget(tty, p);
 	case TIOCMSET:
 	case TIOCMBIC:
 	case TIOCMBIS:
 		return tty_tiocmset(tty, cmd, p);
 	case TIOCGICOUNT:
 		retval = tty_tiocgicount(tty, p);
 		 
         	if (retval != -EINVAL)
 			return retval;
 		break;
 	case TCFLSH:
 		switch (arg) {
 		case TCIFLUSH:
 		case TCIOFLUSH:
 		 
 			tty_buffer_flush(tty, NULL);
 			break;
 		}
 		break;
 	case TIOCSSERIAL:
 		tty_warn_deprecated_flags(p);
 		break;
 	}
 	if (tty->ops->ioctl) {
 		retval = tty->ops->ioctl(tty, cmd, arg);
 		if (retval != -ENOIOCTLCMD)
 			return retval;
 	}
 	ld = tty_ldisc_ref_wait(tty);
 	retval = -EINVAL;
 	if (ld->ops->ioctl) {
 		retval = ld->ops->ioctl(tty, file, cmd, arg);
 		if (retval == -ENOIOCTLCMD)
 			retval = -ENOTTY;
 	}
 	tty_ldisc_deref(ld);
 	return retval;
 }","[70, 69]",Race condition in the tty_ioctl function in drivers/tty/tty_io.c in the Linux kernel through 4.4.1 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free and system crash) by making a TIOCGETD ioctl call during processing of a TIOCSETD ioctl call.
203238," psf_close (SF_PRIVATE *psf)
 {	uint32_t k ;
 	int	error = 0 ;
 
 	if (psf->codec_close)
 	{	error = psf->codec_close (psf) ;
 		 
 		psf->codec_close = NULL ;
 		} ;
 
 	if (psf->container_close)
 		error = psf->container_close (psf) ;
 
 	error = psf_fclose (psf) ;
  	psf_close_rsrc (psf) ;
  
  	 
 	free (psf->header.ptr) ;
  	free (psf->container_data) ;
  	free (psf->codec_data) ;
  	free (psf->interleave) ;
 	free (psf->dither) ;
 	free (psf->peak_info) ;
 	free (psf->broadcast_16k) ;
 	free (psf->loop_info) ;
 	free (psf->instrument) ;
 	free (psf->cues) ;
 	free (psf->channel_map) ;
 	free (psf->format_desc) ;
 	free (psf->strings.storage) ;
 
 	if (psf->wchunks.chunks)
 		for (k = 0 ; k < psf->wchunks.used ; k++)
 			free (psf->wchunks.chunks [k].data) ;
 	free (psf->rchunks.chunks) ;
 	free (psf->wchunks.chunks) ;
 	free (psf->iterator) ;
 	free (psf->cart_16k) ;
 
 	memset (psf, 0, sizeof (SF_PRIVATE)) ;
 	free (psf) ;
 
 	return error ;
 }  ",[18],"In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."
202843," ZSTD_buildCTable(void* dst, size_t dstCapacity,
                 FSE_CTable* nextCTable, U32 FSELog, symbolEncodingType_e type,
                 U32* count, U32 max,
                 const BYTE* codeTable, size_t nbSeq,
                 const S16* defaultNorm, U32 defaultNormLog, U32 defaultMax,
                 const FSE_CTable* prevCTable, size_t prevCTableSize,
                 void* workspace, size_t workspaceSize)
  {
      BYTE* op = (BYTE*)dst;
      const BYTE* const oend = op + dstCapacity;
     DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);
  
      switch (type) {
      case set_rle:
        *op = codeTable[0];
          CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
         if (dstCapacity==0) return ERROR(dstSize_tooSmall);
         *op = codeTable[0];
          return 1;
      case set_repeat:
          memcpy(nextCTable, prevCTable, prevCTableSize);
         return 0;
     case set_basic:
         CHECK_F(FSE_buildCTable_wksp(nextCTable, defaultNorm, defaultMax, defaultNormLog, workspace, workspaceSize));   
         return 0;
     case set_compressed: {
         S16 norm[MaxSeq + 1];
         size_t nbSeq_1 = nbSeq;
         const U32 tableLog = FSE_optimalTableLog(FSELog, nbSeq, max);
         if (count[codeTable[nbSeq-1]] > 1) {
             count[codeTable[nbSeq-1]]--;
             nbSeq_1--;
         }
         assert(nbSeq_1 > 1);
         CHECK_F(FSE_normalizeCount(norm, tableLog, count, nbSeq_1, max));
         {   size_t const NCountSize = FSE_writeNCount(op, oend - op, norm, max, tableLog);    
             if (FSE_isError(NCountSize)) return NCountSize;
             CHECK_F(FSE_buildCTable_wksp(nextCTable, norm, max, tableLog, workspace, workspaceSize));
             return NCountSize;
         }
     }
     default: return assert(0), ERROR(GENERIC);
     }
 }","[11, 17, 18, 15]",A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.
200409," static int snd_timer_user_params(struct file *file,
 				 struct snd_timer_params __user *_params)
 {
 	struct snd_timer_user *tu;
 	struct snd_timer_params params;
 	struct snd_timer *t;
 	struct snd_timer_read *tr;
 	struct snd_timer_tread *ttr;
 	int err;
 
 	tu = file->private_data;
 	if (!tu->timeri)
 		return -EBADFD;
 	t = tu->timeri->timer;
 	if (!t)
 		return -EBADFD;
 	if (copy_from_user(&params, _params, sizeof(params)))
 		return -EFAULT;
 	if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {
 		err = -EINVAL;
 		goto _end;
 	}
 	if (params.queue_size > 0 &&
 	    (params.queue_size < 32 || params.queue_size > 1024)) {
 		err = -EINVAL;
 		goto _end;
 	}
 	if (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|
 			      (1<<SNDRV_TIMER_EVENT_TICK)|
 			      (1<<SNDRV_TIMER_EVENT_START)|
 			      (1<<SNDRV_TIMER_EVENT_STOP)|
 			      (1<<SNDRV_TIMER_EVENT_CONTINUE)|
 			      (1<<SNDRV_TIMER_EVENT_PAUSE)|
 			      (1<<SNDRV_TIMER_EVENT_SUSPEND)|
 			      (1<<SNDRV_TIMER_EVENT_RESUME)|
 			      (1<<SNDRV_TIMER_EVENT_MSTART)|
 			      (1<<SNDRV_TIMER_EVENT_MSTOP)|
 			      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|
 			      (1<<SNDRV_TIMER_EVENT_MPAUSE)|
 			      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|
 			      (1<<SNDRV_TIMER_EVENT_MRESUME))) {
 		err = -EINVAL;
 		goto _end;
 	}
 	snd_timer_stop(tu->timeri);
 	spin_lock_irq(&t->lock);
 	tu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|
 			       SNDRV_TIMER_IFLG_EXCLUSIVE|
 			       SNDRV_TIMER_IFLG_EARLY_EVENT);
 	if (params.flags & SNDRV_TIMER_PSFLG_AUTO)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;
 	if (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;
 	if (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)
 		tu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;
 	spin_unlock_irq(&t->lock);
 	if (params.queue_size > 0 &&
 	    (unsigned int)tu->queue_size != params.queue_size) {
 		if (tu->tread) {
 			ttr = kmalloc(params.queue_size * sizeof(*ttr),
 				      GFP_KERNEL);
 			if (ttr) {
 				kfree(tu->tqueue);
 				tu->queue_size = params.queue_size;
 				tu->tqueue = ttr;
 			}
 		} else {
 			tr = kmalloc(params.queue_size * sizeof(*tr),
 				     GFP_KERNEL);
 			if (tr) {
 				kfree(tu->queue);
 				tu->queue_size = params.queue_size;
 				tu->queue = tr;
 			}
 		}
 	}
 	tu->qhead = tu->qtail = tu->qused = 0;
  	if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {
  		if (tu->tread) {
  			struct snd_timer_tread tread;
 			memset(&tread, 0, sizeof(tread));
  			tread.event = SNDRV_TIMER_EVENT_EARLY;
  			tread.tstamp.tv_sec = 0;
  			tread.tstamp.tv_nsec = 0;
 			tread.val = 0;
 			snd_timer_user_append_to_tqueue(tu, &tread);
 		} else {
 			struct snd_timer_read *r = &tu->queue[0];
 			r->resolution = 0;
 			r->ticks = 0;
 			tu->qused++;
 			tu->qtail++;
 		}
 	}
 	tu->filter = params.filter;
 	tu->ticks = params.ticks;
 	err = 0;
  _end:
 	if (copy_to_user(_params, &params, sizeof(params)))
 		return -EFAULT;
 	return err;
 }",[81],"The snd_timer_user_params function in sound/core/timer.c in the Linux kernel through 4.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface."
201869,"  void jas_matrix_asl(jas_matrix_t *matrix, int n)
  {
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	jas_seqent_t *rowstart;
	int rowstep;
 	jas_matind_t rowstep;
  	jas_seqent_t *data;
  
  	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
 		assert(matrix->rows_);
 		rowstep = jas_matrix_rowstep(matrix);
 		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
 		  rowstart += rowstep) {
 			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
 			  ++data) {
 				*data = jas_seqent_asl(*data, n);
 			}
 		}
 	}
 }","[5, 6, 9, 3, 4, 8]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
204395,"  void PrintPreviewDataService::GetDataEntry(
    const std::string& preview_ui_addr_str,
     int32 preview_ui_id,
      int index,
      scoped_refptr<base::RefCountedBytes>* data_bytes) {
    *data_bytes = NULL;
  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);
   PreviewDataStoreMap::const_iterator it = data_store_map_.find(preview_ui_id);
    if (it != data_store_map_.end())
      it->second->GetPreviewDataForIndex(index, data_bytes);
  }","[3, 8, 2, 7]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
203013," babel_print_v2(netdissect_options *ndo,
                const u_char *cp, u_int length)
 {
     u_int i;
     u_short bodylen;
     u_char v4_prefix[16] =
         {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0, 0, 0, 0 };
     u_char v6_prefix[16] = {0};
 
     ND_TCHECK2(*cp, 4);
     if (length < 4)
         goto invalid;
     bodylen = EXTRACT_16BITS(cp + 2);
     ND_PRINT((ndo, "" (%u)"", bodylen));
 
      
     i = 0;
     while(i < bodylen) {
         const u_char *message;
         u_int type, len;
 
         message = cp + 4 + i;
 
         ND_TCHECK2(*message, 1);
         if((type = message[0]) == MESSAGE_PAD1) {
             ND_PRINT((ndo, ndo->ndo_vflag ? ""\n\tPad 1"" : "" pad1""));
             i += 1;
             continue;
         }
 
         ND_TCHECK2(*message, 2);
         ICHECK(i, 2);
         len = message[1];
 
         ND_TCHECK2(*message, 2 + len);
         ICHECK(i, 2 + len);
 
         switch(type) {
         case MESSAGE_PADN: {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" padN""));
             else
                 ND_PRINT((ndo, ""\n\tPad %d"", len + 2));
         }
             break;
 
         case MESSAGE_ACK_REQ: {
             u_short nonce, interval;
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" ack-req""));
             else {
                 ND_PRINT((ndo, ""\n\tAcknowledgment Request ""));
                 if(len < 6) goto invalid;
                 nonce = EXTRACT_16BITS(message + 4);
                 interval = EXTRACT_16BITS(message + 6);
                 ND_PRINT((ndo, ""%04x %s"", nonce, format_interval(interval)));
             }
         }
             break;
 
         case MESSAGE_ACK: {
             u_short nonce;
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" ack""));
             else {
                 ND_PRINT((ndo, ""\n\tAcknowledgment ""));
                 if(len < 2) goto invalid;
                 nonce = EXTRACT_16BITS(message + 2);
                 ND_PRINT((ndo, ""%04x"", nonce));
             }
         }
             break;
 
         case MESSAGE_HELLO:  {
             u_short seqno, interval;
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" hello""));
             else {
                 ND_PRINT((ndo, ""\n\tHello ""));
                 if(len < 6) goto invalid;
                 seqno = EXTRACT_16BITS(message + 4);
                 interval = EXTRACT_16BITS(message + 6);
                 ND_PRINT((ndo, ""seqno %u interval %s"", seqno, format_interval(interval)));
                  
                 if(len > 6)
                     subtlvs_print(ndo, message + 8, message + 2 + len, type);
             }
         }
             break;
 
         case MESSAGE_IHU: {
             unsigned short txcost, interval;
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" ihu""));
             else {
                 u_char address[16];
                 int rc;
                 ND_PRINT((ndo, ""\n\tIHU ""));
                 if(len < 6) goto invalid;
                 txcost = EXTRACT_16BITS(message + 4);
                 interval = EXTRACT_16BITS(message + 6);
                 rc = network_address(message[2], message + 8, len - 6, address);
                 if(rc < 0) { ND_PRINT((ndo, ""%s"", tstr)); break; }
                 ND_PRINT((ndo, ""%s txcost %u interval %s"",
                        format_address(ndo, address), txcost, format_interval(interval)));
                  
                 if((u_int)rc < len - 6)
                     subtlvs_print(ndo, message + 8 + rc, message + 2 + len,
                                   type);
             }
         }
             break;
 
         case MESSAGE_ROUTER_ID: {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" router-id""));
             else {
                 ND_PRINT((ndo, ""\n\tRouter Id""));
                 if(len < 10) goto invalid;
                 ND_PRINT((ndo, "" %s"", format_id(message + 4)));
             }
         }
             break;
 
         case MESSAGE_NH: {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" nh""));
             else {
                 int rc;
                 u_char nh[16];
                 ND_PRINT((ndo, ""\n\tNext Hop""));
                 if(len < 2) goto invalid;
                 rc = network_address(message[2], message + 4, len - 2, nh);
                 if(rc < 0) goto invalid;
                 ND_PRINT((ndo, "" %s"", format_address(ndo, nh)));
             }
         }
             break;
 
          case MESSAGE_UPDATE: {
              if (!ndo->ndo_vflag) {
                  ND_PRINT((ndo, "" update""));
                if(len < 1)
                 if(len < 10)
                      ND_PRINT((ndo, ""/truncated""));
                  else
                      ND_PRINT((ndo, ""%s%s%s"",
                            (message[3] & 0x80) ? ""/prefix"": """",
                            (message[3] & 0x40) ? ""/id"" : """",
                            (message[3] & 0x3f) ? ""/unknown"" : """"));
             } else {
                 u_short interval, seqno, metric;
                 u_char plen;
                 int rc;
                 u_char prefix[16];
                 ND_PRINT((ndo, ""\n\tUpdate""));
                 if(len < 10) goto invalid;
                 plen = message[4] + (message[2] == 1 ? 96 : 0);
                 rc = network_prefix(message[2], message[4], message[5],
                                     message + 12,
                                     message[2] == 1 ? v4_prefix : v6_prefix,
                                     len - 10, prefix);
                 if(rc < 0) goto invalid;
                 interval = EXTRACT_16BITS(message + 6);
                 seqno = EXTRACT_16BITS(message + 8);
                 metric = EXTRACT_16BITS(message + 10);
                 ND_PRINT((ndo, ""%s%s%s %s metric %u seqno %u interval %s"",
                        (message[3] & 0x80) ? ""/prefix"": """",
                        (message[3] & 0x40) ? ""/id"" : """",
                        (message[3] & 0x3f) ? ""/unknown"" : """",
                        format_prefix(ndo, prefix, plen),
                        metric, seqno, format_interval_update(interval)));
                 if(message[3] & 0x80) {
                     if(message[2] == 1)
                         memcpy(v4_prefix, prefix, 16);
                     else
                         memcpy(v6_prefix, prefix, 16);
                 }
                  
                 if((u_int)rc < len - 10)
                     subtlvs_print(ndo, message + 12 + rc, message + 2 + len, type);
             }
         }
             break;
 
         case MESSAGE_REQUEST: {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" request""));
             else {
                 int rc;
                 u_char prefix[16], plen;
                 ND_PRINT((ndo, ""\n\tRequest ""));
                 if(len < 2) goto invalid;
                 plen = message[3] + (message[2] == 1 ? 96 : 0);
                 rc = network_prefix(message[2], message[3], 0,
                                     message + 4, NULL, len - 2, prefix);
                 if(rc < 0) goto invalid;
                 ND_PRINT((ndo, ""for %s"",
                        message[2] == 0 ? ""any"" : format_prefix(ndo, prefix, plen)));
             }
         }
             break;
 
         case MESSAGE_MH_REQUEST : {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" mh-request""));
             else {
                 int rc;
                 u_short seqno;
                 u_char prefix[16], plen;
                 ND_PRINT((ndo, ""\n\tMH-Request ""));
                 if(len < 14) goto invalid;
                 seqno = EXTRACT_16BITS(message + 4);
                 rc = network_prefix(message[2], message[3], 0,
                                     message + 16, NULL, len - 14, prefix);
                 if(rc < 0) goto invalid;
                 plen = message[3] + (message[2] == 1 ? 96 : 0);
                 ND_PRINT((ndo, ""(%u hops) for %s seqno %u id %s"",
                        message[6], format_prefix(ndo, prefix, plen),
                        seqno, format_id(message + 8)));
             }
         }
             break;
         case MESSAGE_TSPC :
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" tspc""));
             else {
                 ND_PRINT((ndo, ""\n\tTS/PC ""));
                 if(len < 6) goto invalid;
                 ND_PRINT((ndo, ""timestamp %u packetcounter %u"", EXTRACT_32BITS (message + 4),
                        EXTRACT_16BITS(message + 2)));
             }
             break;
         case MESSAGE_HMAC : {
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" hmac""));
             else {
                 unsigned j;
                 ND_PRINT((ndo, ""\n\tHMAC ""));
                 if(len < 18) goto invalid;
                 ND_PRINT((ndo, ""key-id %u digest-%u "", EXTRACT_16BITS(message + 2), len - 2));
                 for (j = 0; j < len - 2; j++)
                     ND_PRINT((ndo, ""%02X"", message[4 + j]));
             }
         }
             break;
 
         case MESSAGE_UPDATE_SRC_SPECIFIC : {
             if(!ndo->ndo_vflag) {
                 ND_PRINT((ndo, "" ss-update""));
             } else {
                 u_char prefix[16], src_prefix[16];
                 u_short interval, seqno, metric;
                 u_char ae, plen, src_plen, omitted;
                 int rc;
                 int parsed_len = 10;
                 ND_PRINT((ndo, ""\n\tSS-Update""));
                 if(len < 10) goto invalid;
                 ae = message[2];
                 src_plen = message[3];
                 plen = message[4];
                 omitted = message[5];
                 interval = EXTRACT_16BITS(message + 6);
                 seqno = EXTRACT_16BITS(message + 8);
                 metric = EXTRACT_16BITS(message + 10);
                 rc = network_prefix(ae, plen, omitted, message + 2 + parsed_len,
                                     ae == 1 ? v4_prefix : v6_prefix,
                                     len - parsed_len, prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     plen += 96;
                 parsed_len += rc;
                 rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len,
                                     NULL, len - parsed_len, src_prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     src_plen += 96;
                 parsed_len += rc;
 
                 ND_PRINT((ndo, "" %s from"", format_prefix(ndo, prefix, plen)));
                 ND_PRINT((ndo, "" %s metric %u seqno %u interval %s"",
                           format_prefix(ndo, src_prefix, src_plen),
                           metric, seqno, format_interval_update(interval)));
                  
                 if((u_int)parsed_len < len)
                     subtlvs_print(ndo, message + 2 + parsed_len,
                                   message + 2 + len, type);
             }
         }
             break;
 
         case MESSAGE_REQUEST_SRC_SPECIFIC : {
             if(!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" ss-request""));
             else {
                 int rc, parsed_len = 3;
                 u_char ae, plen, src_plen, prefix[16], src_prefix[16];
                 ND_PRINT((ndo, ""\n\tSS-Request ""));
                 if(len < 3) goto invalid;
                 ae = message[2];
                 plen = message[3];
                 src_plen = message[4];
                 rc = network_prefix(ae, plen, 0, message + 2 + parsed_len,
                                     NULL, len - parsed_len, prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     plen += 96;
                 parsed_len += rc;
                 rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len,
                                     NULL, len - parsed_len, src_prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     src_plen += 96;
                 parsed_len += rc;
                 if(ae == 0) {
                     ND_PRINT((ndo, ""for any""));
                 } else {
                     ND_PRINT((ndo, ""for (%s, "", format_prefix(ndo, prefix, plen)));
                     ND_PRINT((ndo, ""%s)"", format_prefix(ndo, src_prefix, src_plen)));
                 }
             }
         }
             break;
 
         case MESSAGE_MH_REQUEST_SRC_SPECIFIC : {
             if(!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" ss-mh-request""));
             else {
                 int rc, parsed_len = 14;
                 u_short seqno;
                 u_char ae, plen, src_plen, prefix[16], src_prefix[16], hopc;
                 const u_char *router_id = NULL;
                 ND_PRINT((ndo, ""\n\tSS-MH-Request ""));
                 if(len < 14) goto invalid;
                 ae = message[2];
                 plen = message[3];
                 seqno = EXTRACT_16BITS(message + 4);
                 hopc = message[6];
                 src_plen = message[7];
                 router_id = message + 8;
                 rc = network_prefix(ae, plen, 0, message + 2 + parsed_len,
                                     NULL, len - parsed_len, prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     plen += 96;
                 parsed_len += rc;
                 rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len,
                                     NULL, len - parsed_len, src_prefix);
                 if(rc < 0) goto invalid;
                 if(ae == 1)
                     src_plen += 96;
                 ND_PRINT((ndo, ""(%u hops) for (%s, "",
                           hopc, format_prefix(ndo, prefix, plen)));
                 ND_PRINT((ndo, ""%s) seqno %u id %s"",
                           format_prefix(ndo, src_prefix, src_plen),
                           seqno, format_id(router_id)));
             }
         }
             break;
 
         default:
             if (!ndo->ndo_vflag)
                 ND_PRINT((ndo, "" unknown""));
             else
                 ND_PRINT((ndo, ""\n\tUnknown message type %d"", type));
         }
         i += len + 2;
     }
     return;
 
  trunc:
     ND_PRINT((ndo, "" %s"", tstr));
     return;
 
  invalid:
     ND_PRINT((ndo, ""%s"", istr));
     return;
 }","[144, 143]",The Babel parser in tcpdump before 4.9.3 has a buffer over-read in print-babel.c:babel_print_v2().
198702," static void tcp_illinois_info(struct sock *sk, u32 ext,
 			      struct sk_buff *skb)
 {
 	const struct illinois *ca = inet_csk_ca(sk);
 
 	if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {
 		struct tcpvegas_info info = {
 			.tcpv_enabled = 1,
  			.tcpv_rttcnt = ca->cnt_rtt,
  			.tcpv_minrtt = ca->base_rtt,
  		};
		u64 t = ca->sum_rtt;
  
		do_div(t, ca->cnt_rtt);
		info.tcpv_rtt = t;
 		if (info.tcpv_rttcnt > 0) {
 			u64 t = ca->sum_rtt;
  
 			do_div(t, info.tcpv_rttcnt);
 			info.tcpv_rtt = t;
 		}
  		nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);
  	}
  }","[16, 17, 19, 20, 21, 12, 14, 15]","The tcp_illinois_info function in net/ipv4/tcp_illinois.c in the Linux kernel before 3.4.19, when the net.ipv4.tcp_congestion_control illinois setting is enabled, allows local users to cause a denial of service (divide-by-zero error and OOPS) by reading TCP stats."
10011,"TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {
TF_ASSERT_OK(NodeDefBuilder(""quantize_down_and_shrink_range_op"",
""QuantizeDownAndShrinkRange"")
.Input(FakeInput(DT_QINT32))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Attr(""Tinput"", DataTypeToEnum<qint32>::v())
.Attr(""out_type"", DataTypeToEnum<quint8>::v())
.Finalize(node_def()));
TF_ASSERT_OK(InitOp());






const int value_count = 3;
AddInputFromArray<qint32>(TensorShape({value_count}),
{-(1 << 23), 0, (1 << 23)});
AddInputFromArray<float>(TensorShape({1}), {-256.0f});
AddInputFromArray<float>(TensorShape({1}), {256.0f});
TF_ASSERT_OK(RunOpKernel());
Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));
test::FillValues<quint8>(&expected, {0, 128, 255});
test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));
Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));
test::FillValues<float>(&expected_min, {-1.0f});
test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));
Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));
test::FillValues<float>(&expected_max, {1.0f});
test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));
}","[20, 21]","TensorFlow is an open source platform for machine learning. If `QuantizeDownAndShrinkRange` is given nonscalar inputs for `input_min` or `input_max`, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 73ad1815ebcfeb7c051f9c2f7ab5024380ca8613. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
202124," static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
         struct ipddp_route __user *rt = ifr->ifr_data;
         struct ipddp_route rcp, rcp2, *rp;
 
         if(!capable(CAP_NET_ADMIN))
                 return -EPERM;
 
 	if(copy_from_user(&rcp, rt, sizeof(rcp)))
 		return -EFAULT;
 
         switch(cmd)
         {
 		case SIOCADDIPDDPRT:
                         return ipddp_create(&rcp);
 
                  case SIOCFINDIPDDPRT:
  			spin_lock_bh(&ipddp_route_lock);
  			rp = __ipddp_find_route(&rcp);
			if (rp)
				memcpy(&rcp2, rp, sizeof(rcp2));
 			if (rp) {
 				memset(&rcp2, 0, sizeof(rcp2));
 				rcp2.ip    = rp->ip;
 				rcp2.at    = rp->at;
 				rcp2.flags = rp->flags;
 			}
  			spin_unlock_bh(&ipddp_route_lock);
  
  			if (rp) {
 				if (copy_to_user(rt, &rcp2,
 						 sizeof(struct ipddp_route)))
 					return -EFAULT;
 				return 0;
 			} else
 				return -ENOENT;
 
                 case SIOCDELIPDDPRT:
                         return ipddp_delete(&rcp);
 
                 default:
                         return -EINVAL;
         }
 }","[22, 23, 24, 25, 26, 27, 20, 21]",An issue was discovered in the Linux kernel before 4.18.11. The ipddp_ioctl function in drivers/net/appletalk/ipddp.c allows local users to obtain sensitive kernel address information by leveraging CAP_NET_ADMIN to read the ipddp_route dev and next fields via an SIOCFINDIPDDPRT ioctl call.
199949,"  dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,
    int num, size_t size, off_t fsize, int *flags)
     int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)
  {
  	Elf32_Phdr ph32;
  	Elf64_Phdr ph64;
 	size_t offset, len;
 	unsigned char nbuf[BUFSIZ];
 	ssize_t bufsize;
 
 	if (size != xph_sizeof) {
 		if (file_printf(ms, "", corrupted program header size"") == -1)
 			return -1;
 		return 0;
 	}
 
 	 
 	for ( ; num; num--) {
 		if (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {
 			file_badread(ms);
 			return -1;
 		}
 		off += size;
 
 		if (fsize != SIZE_UNKNOWN && xph_offset > fsize) {
 			 
 			continue;
 		}
 
 		if (xph_type != PT_NOTE)
 			continue;
 
 		 
 		len = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);
 		if ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {
 			file_badread(ms);
 			return -1;
 		}
 		offset = 0;
 		for (;;) {
  			if (offset >= (size_t)bufsize)
  				break;
  			offset = donote(ms, nbuf, offset, (size_t)bufsize,
			    clazz, swap, 4, flags);
 			    clazz, swap, 4, flags, notecount);
  			if (offset == 0)
  				break;
  
 		}
 	}
 	return 0;
 }","[3, 45, 2, 44]",The ELF parser in file 5.08 through 5.21 allows remote attackers to cause a denial of service via a large number of notes.
201956," lrmd_remote_client_msg(gpointer data)
 {
     int id = 0;
     int rc = 0;
     int disconnected = 0;
     xmlNode *request = NULL;
     crm_client_t *client = data;
 
     if (client->remote->tls_handshake_complete == FALSE) {
         int rc = 0;
 
          
         do {
             rc = gnutls_handshake(*client->remote->tls_session);
 
             if (rc < 0 && rc != GNUTLS_E_AGAIN) {
                 crm_err(""Remote lrmd tls handshake failed"");
                 return -1;
             }
         } while (rc == GNUTLS_E_INTERRUPTED);
 
         if (rc == 0) {
             crm_debug(""Remote lrmd tls handshake completed"");
             client->remote->tls_handshake_complete = TRUE;
             if (client->remote->auth_timeout) {
                  g_source_remove(client->remote->auth_timeout);
              }
              client->remote->auth_timeout = 0;
 
              
             notify_of_new_client(client);
          }
          return 0;
      }
 
     rc = crm_remote_ready(client->remote, 0);
     if (rc == 0) {
          
         return 0;
     } else if (rc < 0) {
         crm_info(""Client disconnected during remote client read"");
         return -1;
     }
 
     crm_remote_recv(client->remote, -1, &disconnected);
 
     request = crm_remote_parse_buffer(client->remote);
     while (request) {
         crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);
         crm_trace(""processing request from remote client with remote msg id %d"", id);
         if (!client->name) {
             const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);
 
             if (value) {
                 client->name = strdup(value);
             }
         }
 
         lrmd_call_id++;
         if (lrmd_call_id < 1) {
             lrmd_call_id = 1;
         }
 
         crm_xml_add(request, F_LRMD_CLIENTID, client->id);
         crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);
         crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);
 
         process_lrmd_message(client, id, request);
         free_xml(request);
 
          
         request = crm_remote_parse_buffer(client->remote);
     }
 
     if (disconnected) {
         crm_info(""Client disconnect detected in tls msg dispatcher."");
         return -1;
     }
 
     return 0;
 }","[29, 30, 31]","Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection."
199539," mconvert(struct magic_set *ms, struct magic *m, int flip)
 {
 	union VALUETYPE *p = &ms->ms_value;
 	uint8_t type;
 
 	switch (type = cvt_flip(m->type, flip)) {
 	case FILE_BYTE:
 		cvt_8(p, m);
 		return 1;
 	case FILE_SHORT:
 		cvt_16(p, m);
 		return 1;
 	case FILE_LONG:
 	case FILE_DATE:
 	case FILE_LDATE:
 		cvt_32(p, m);
 		return 1;
 	case FILE_QUAD:
 	case FILE_QDATE:
 	case FILE_QLDATE:
 	case FILE_QWDATE:
 		cvt_64(p, m);
 		return 1;
 	case FILE_STRING:
 	case FILE_BESTRING16:
 	case FILE_LESTRING16: {
 		 
 		p->s[sizeof(p->s) - 1] = '\0';
  		return 1;
  	}
  	case FILE_PSTRING: {
		char *ptr1 = p->s, *ptr2 = ptr1 + file_pstring_length_size(m);
 		size_t sz = file_pstring_length_size(m);
 		char *ptr1 = p->s, *ptr2 = ptr1 + sz;
  		size_t len = file_pstring_get_length(m, ptr1);
		if (len >= sizeof(p->s))
			len = sizeof(p->s) - 1;
 		if (len >= sizeof(p->s)) {
 			  
 			len = sizeof(p->s) - sz;
 		}
  		while (len--)
  			*ptr1++ = *ptr2++;
  		*ptr1 = '\0';
 		return 1;
 	}
 	case FILE_BESHORT:
 		p->h = (short)((p->hs[0]<<8)|(p->hs[1]));
 		cvt_16(p, m);
 		return 1;
 	case FILE_BELONG:
 	case FILE_BEDATE:
 	case FILE_BELDATE:
 		p->l = (int32_t)
 		    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));
 		if (type == FILE_BELONG)
 			cvt_32(p, m);
 		return 1;
 	case FILE_BEQUAD:
 	case FILE_BEQDATE:
 	case FILE_BEQLDATE:
 	case FILE_BEQWDATE:
 		p->q = (uint64_t)
 		    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
 		     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
 		     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
 		     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));
 		if (type == FILE_BEQUAD)
 			cvt_64(p, m);
 		return 1;
 	case FILE_LESHORT:
 		p->h = (short)((p->hs[1]<<8)|(p->hs[0]));
 		cvt_16(p, m);
 		return 1;
 	case FILE_LELONG:
 	case FILE_LEDATE:
 	case FILE_LELDATE:
 		p->l = (int32_t)
 		    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));
 		if (type == FILE_LELONG)
 			cvt_32(p, m);
 		return 1;
 	case FILE_LEQUAD:
 	case FILE_LEQDATE:
 	case FILE_LEQLDATE:
 	case FILE_LEQWDATE:
 		p->q = (uint64_t)
 		    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
 		     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
 		     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
 		     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));
 		if (type == FILE_LEQUAD)
 			cvt_64(p, m);
 		return 1;
 	case FILE_MELONG:
 	case FILE_MEDATE:
 	case FILE_MELDATE:
 		p->l = (int32_t)
 		    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));
 		if (type == FILE_MELONG)
 			cvt_32(p, m);
 		return 1;
 	case FILE_FLOAT:
 		cvt_float(p, m);
 		return 1;
 	case FILE_BEFLOAT:
 		p->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|
 			((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);
 		cvt_float(p, m);
 		return 1;
 	case FILE_LEFLOAT:
 		p->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|
 			((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);
 		cvt_float(p, m);
 		return 1;
 	case FILE_DOUBLE:
 		cvt_double(p, m);
 		return 1;
 	case FILE_BEDOUBLE:
 		p->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
 			((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
 			((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
 			((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);
 		cvt_double(p, m);
 		return 1;
 	case FILE_LEDOUBLE:
 		p->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
 			((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
 			((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
 			((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);
 		cvt_double(p, m);
 		return 1;
 	case FILE_REGEX:
 	case FILE_SEARCH:
 	case FILE_DEFAULT:
 	case FILE_CLEAR:
 	case FILE_NAME:
 	case FILE_USE:
 		return 1;
 	default:
 		file_magerror(ms, ""invalid type %d in mconvert()"", m->type);
 		return 0;
 	}
 }","[33, 34, 38, 39, 40, 41, 32, 36, 37]","Buffer overflow in the mconvert function in softmagic.c in file before 5.19, as used in the Fileinfo component in PHP before 5.4.30 and 5.5.x before 5.5.14, allows remote attackers to cause a denial of service (application crash) via a crafted Pascal string in a FILE_PSTRING conversion."
200079," struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
 				 struct udphdr *uh)
 {
 	struct udp_offload_priv *uo_priv;
 	struct sk_buff *p, **pp = NULL;
 	struct udphdr *uh2;
  	unsigned int off = skb_gro_offset(skb);
  	int flush = 1;
  
	if (NAPI_GRO_CB(skb)->udp_mark ||
 	if (NAPI_GRO_CB(skb)->encap_mark ||
  	    (skb->ip_summed != CHECKSUM_PARTIAL &&
  	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
  	     !NAPI_GRO_CB(skb)->csum_valid))
  		goto out;
  
 	 
	NAPI_GRO_CB(skb)->udp_mark = 1;
 	NAPI_GRO_CB(skb)->encap_mark = 1;
  
  	rcu_read_lock();
  	uo_priv = rcu_dereference(udp_offload_base);
 	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
 		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
 		    uo_priv->offload->port == uh->dest &&
 		    uo_priv->offload->callbacks.gro_receive)
 			goto unflush;
 	}
 	goto out_unlock;
 
 unflush:
 	flush = 0;
 
 	for (p = *head; p; p = p->next) {
 		if (!NAPI_GRO_CB(p)->same_flow)
 			continue;
 
 		uh2 = (struct udphdr   *)(p->data + off);
 
 		 
 		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
 		    (!uh->check ^ !uh2->check)) {
 			NAPI_GRO_CB(p)->same_flow = 0;
 			continue;
 		}
 	}
 
 	skb_gro_pull(skb, sizeof(struct udphdr));  
 	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
 	NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
 	pp = uo_priv->offload->callbacks.gro_receive(head, skb,
 						     uo_priv->offload);
 
 out_unlock:
 	rcu_read_unlock();
 out:
 	NAPI_GRO_CB(skb)->flush |= flush;
 	return pp;
 }","[11, 19, 10, 18]","The IP stack in the Linux kernel before 4.6 allows remote attackers to cause a denial of service (stack consumption and panic) or possibly have unspecified other impact by triggering use of the GRO path for packets with tunnel stacking, as demonstrated by interleaved IPv4 headers and GRE headers, a related issue to CVE-2016-7039."
204820," static v8::Handle<v8::Value> uniformHelperi(const v8::Arguments& args,
                                             FunctionToCall functionToCall) {
  
      if (args.Length() != 2)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
  
      WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
      if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
         V8Proxy::throwTypeError();
         return notHandledByInterceptor();
     }
     bool ok = false;
     WebGLUniformLocation* location = toWebGLUniformLocation(args[0], ok);
 
     if (V8Int32Array::HasInstance(args[1])) {
         Int32Array* array = V8Int32Array::toNative(args[1]->ToObject());
         ASSERT(array != NULL);
         ExceptionCode ec = 0;
         switch (functionToCall) {
             case kUniform1v: context->uniform1iv(location, array, ec); break;
             case kUniform2v: context->uniform2iv(location, array, ec); break;
             case kUniform3v: context->uniform3iv(location, array, ec); break;
             case kUniform4v: context->uniform4iv(location, array, ec); break;
             default: ASSERT_NOT_REACHED(); break;
         }
         if (ec)
             V8Proxy::setDOMException(ec, args.GetIsolate());
         return v8::Undefined();
     }
 
     if (args[1].IsEmpty() || !args[1]->IsArray()) {
         V8Proxy::throwTypeError();
         return notHandledByInterceptor();
     }
     v8::Handle<v8::Array> array =
       v8::Local<v8::Array>::Cast(args[1]);
     uint32_t len = array->Length();
     int* data = jsArrayToIntArray(array, len);
     if (!data) {
         V8Proxy::setDOMException(SYNTAX_ERR, args.GetIsolate());
         return notHandledByInterceptor();
     }
     ExceptionCode ec = 0;
     switch (functionToCall) {
         case kUniform1v: context->uniform1iv(location, data, len, ec); break;
         case kUniform2v: context->uniform2iv(location, data, len, ec); break;
         case kUniform3v: context->uniform3iv(location, data, len, ec); break;
         case kUniform4v: context->uniform4iv(location, data, len, ec); break;
         default: ASSERT_NOT_REACHED(); break;
     }
     fastFree(data);
     if (ec)
         V8Proxy::setDOMException(ec, args.GetIsolate());
     return v8::Undefined();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
204433," xsltAttrListTemplateProcess(xsltTransformContextPtr ctxt, 
 	                    xmlNodePtr target, xmlAttrPtr attrs)
 {
     xmlAttrPtr attr, copy, last;
     xmlNodePtr oldInsert, text;
     xmlNsPtr origNs = NULL, copyNs = NULL;
     const xmlChar *value;
     xmlChar *valueAVT;
 
     if ((ctxt == NULL) || (target == NULL) || (attrs == NULL))
 	return(NULL);
 
     oldInsert = ctxt->insert;
     ctxt->insert = target;        
 
      
     if (target->properties) {
 	last = target->properties;
 	while (last->next != NULL)
 	    last = last->next;
     } else {
 	last = NULL;
     }
     attr = attrs;
     do {
 	 
 #ifdef XSLT_REFACTORED
 	if (attr->psvi == xsltXSLTAttrMarker) {
 	    goto next_attribute;
 	}
 #else
 	if ((attr->ns != NULL) &&
 	    xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))
 	{
 	    goto next_attribute;
 	}
 #endif
 	 
 	if (attr->children != NULL) {
 	    if ((attr->children->type != XML_TEXT_NODE) ||
 		(attr->children->next != NULL))
 	    {
 		xsltTransformError(ctxt, NULL, attr->parent,
 		    ""Internal error: The children of an attribute node of a ""
 		    ""literal result element are not in the expected form.\n"");
 		goto error;
 	    }
 	    value = attr->children->content;
 	    if (value == NULL)
 		value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0);
 	} else
 	    value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0);
 
 	 
 	copy = xmlNewDocProp(target->doc, attr->name, NULL);
 	if (copy == NULL) {
 	    if (attr->ns) {
 		xsltTransformError(ctxt, NULL, attr->parent,
 		    ""Internal error: Failed to create attribute '{%s}%s'.\n"",
 		    attr->ns->href, attr->name);
 	    } else {
 		xsltTransformError(ctxt, NULL, attr->parent,
 		    ""Internal error: Failed to create attribute '%s'.\n"",
 		    attr->name);
 	    }
 	    goto error;
 	}
 	 
 	copy->parent = target;
 	if (last == NULL) {
 	    target->properties = copy;
 	    last = copy;
 	} else {
 	    last->next = copy;
 	    copy->prev = last;
 	    last = copy;
 	}
 	 
 	if (attr->ns != origNs) {
 	    origNs = attr->ns;
 	    if (attr->ns != NULL) {
 #ifdef XSLT_REFACTORED
 		copyNs = xsltGetSpecialNamespace(ctxt, attr->parent,
 		    attr->ns->href, attr->ns->prefix, target);
 #else
 		copyNs = xsltGetNamespace(ctxt, attr->parent,
 		    attr->ns, target);
 #endif
 		if (copyNs == NULL)
 		    goto error;
 	    } else
 		copyNs = NULL;
 	}
 	copy->ns = copyNs;
 
 	 
 	text = xmlNewText(NULL);
 	if (text != NULL) {
 	    copy->last = copy->children = text;
 	    text->parent = (xmlNodePtr) copy;
 	    text->doc = copy->doc;
 
 	    if (attr->psvi != NULL) {
 		 
 		valueAVT = xsltEvalAVT(ctxt, attr->psvi, attr->parent);
 		if (valueAVT == NULL) {
 		     
 		    if (attr->ns) {
 			xsltTransformError(ctxt, NULL, attr->parent,
 			    ""Internal error: Failed to evaluate the AVT ""
 			    ""of attribute '{%s}%s'.\n"",
 			    attr->ns->href, attr->name);
 		    } else {
 			xsltTransformError(ctxt, NULL, attr->parent,
 			    ""Internal error: Failed to evaluate the AVT ""
 			    ""of attribute '%s'.\n"",
 			    attr->name);
 		    }
 		    text->content = xmlStrdup(BAD_CAST """");
 		    goto error;
 		} else {
 		    text->content = valueAVT;
  		}
  	    } else if ((ctxt->internalized) &&
  		(target->doc != NULL) &&
		(target->doc->dict == ctxt->dict))
 		(target->doc->dict == ctxt->dict) &&
 		xmlDictOwns(ctxt->dict, value))
  	    {
  		text->content = (xmlChar *) value;
  	    } else {
 		text->content = xmlStrdup(value);
 	    }
             if ((copy != NULL) && (text != NULL) &&
                 (xmlIsID(copy->doc, copy->parent, copy)))
                 xmlAddID(NULL, copy->doc, text->content, copy);
 	}
 
 next_attribute:
 	attr = attr->next;
     } while (attr != NULL);
 
      
     attr = attrs;
     do {
 #ifdef XSLT_REFACTORED
 	if ((attr->psvi == xsltXSLTAttrMarker) &&
 	    xmlStrEqual(attr->name, (const xmlChar *)""use-attribute-sets""))
 	{
 	    xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);
 	}
 #else
 	if ((attr->ns != NULL) &&
 	    xmlStrEqual(attr->name, (const xmlChar *)""use-attribute-sets"") &&
 	    xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))
 	{
 	    xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);
 	}
 #endif
 	attr = attr->next;
     } while (attr != NULL);
 
     ctxt->insert = oldInsert;
     return(target->properties);
 
 error:
     ctxt->insert = oldInsert;
     return(NULL);
 }","[127, 128, 126]","Double free vulnerability in libxslt, as used in Google Chrome before 22.0.1229.79, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XSL transforms."
199370," static int load_script(struct linux_binprm *bprm)
 {
 	const char *i_arg, *i_name;
 	char *cp;
 	struct file *file;
 	char interp[BINPRM_BUF_SIZE];
 	int retval;
 
 	if ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))
 		return -ENOEXEC;
 	 
 
 	allow_write_access(bprm->file);
 	fput(bprm->file);
 	bprm->file = NULL;
 
 	bprm->buf[BINPRM_BUF_SIZE - 1] = '\0';
 	if ((cp = strchr(bprm->buf, '\n')) == NULL)
 		cp = bprm->buf+BINPRM_BUF_SIZE-1;
 	*cp = '\0';
 	while (cp > bprm->buf) {
 		cp--;
 		if ((*cp == ' ') || (*cp == '\t'))
 			*cp = '\0';
 		else
 			break;
 	}
 	for (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\t'); cp++);
 	if (*cp == '\0') 
 		return -ENOEXEC;  
 	i_name = cp;
 	i_arg = NULL;
 	for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++)
 		  ;
 	while ((*cp == ' ') || (*cp == '\t'))
 		*cp++ = '\0';
 	if (*cp)
 		i_arg = cp;
 	strcpy (interp, i_name);
 	 
 	retval = remove_arg_zero(bprm);
 	if (retval)
 		return retval;
 	retval = copy_strings_kernel(1, &bprm->interp, bprm);
 	if (retval < 0) return retval; 
 	bprm->argc++;
 	if (i_arg) {
 		retval = copy_strings_kernel(1, &i_arg, bprm);
 		if (retval < 0) return retval; 
 		bprm->argc++;
 	}
  	retval = copy_strings_kernel(1, &i_name, bprm);
  	if (retval) return retval; 
  	bprm->argc++;
	bprm->interp = interp;
 	retval = bprm_change_interp(interp, bprm);
 	if (retval < 0)
 		return retval;
  
  	 
 	file = open_exec(interp);
 	if (IS_ERR(file))
 		return PTR_ERR(file);
 
 	bprm->file = file;
 	retval = prepare_binprm(bprm);
 	if (retval < 0)
 		return retval;
 	return search_binary_handler(bprm);
 }","[56, 57, 58, 55]","The load_script function in fs/binfmt_script.c in the Linux kernel before 3.7.2 does not properly handle recursion, which allows local users to obtain sensitive information from kernel stack memory via a crafted application."
7630,"int init_aliases(void)
{
FILE *fp;
char alias[MAXALIASLEN + 1U];
char dir[PATH_MAX + 1U];

if ((fp = fopen(ALIASES_FILE, ""r"")) == NULL) {
return 0;
}
while (fgets(alias, sizeof alias, fp) != NULL) {
if (*alias == '#' || *alias == '\n' || *alias == 0) {
continue;
}
{
char * const z = alias + strlen(alias) - 1U;

if (*z != '\n') {
goto bad;
}
*z = 0;
}
do {
if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {
goto bad;
}
{
char * const z = dir + strlen(dir) - 1U;

if (*z == '\n') {
*z = 0;
}
}
} while (*dir == '#' || *dir == 0);
if (head == NULL) {
if ((head = tail = malloc(sizeof *head)) == NULL ||
(tail->alias = strdup(alias)) == NULL ||
(tail->dir = strdup(dir)) == NULL) {
die_mem();
}
tail->next = NULL;
} else {
DirAlias *curr;

if ((curr = malloc(sizeof *curr)) == NULL ||
(curr->alias = strdup(alias)) == NULL ||
(curr->dir = strdup(dir)) == NULL) {
die_mem();
}
tail->next = curr;
tail = curr;
}
}
fclose(fp);
aliases_up++;

return 0;

bad:
fclose(fp);
logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE "" ["" ALIASES_FILE ""]"");

return -1;
}","[40, 53]","An issue was discovered in Pure-FTPd 1.0.49. An uninitialized pointer vulnerability has been detected in the diraliases linked list. When the *lookup_alias(const char alias) or print_aliases(void) function is called, they fail to correctly detect the end of the linked list and try to access a non-existent list member. This is related to init_aliases in diraliases.c."
206550," void InlineSigninHelper::OnClientOAuthSuccessAndBrowserOpened(
     const ClientOAuthResult& result,
     Profile* profile,
     Profile::CreateStatus status) {
   if (is_force_sign_in_with_usermanager_)
     UnlockProfileAndHideLoginUI(profile_->GetPath(), handler_.get());
   Browser* browser = NULL;
   if (handler_) {
     browser = handler_->GetDesktopBrowser();
   }
 
   AboutSigninInternals* about_signin_internals =
       AboutSigninInternalsFactory::GetForProfile(profile_);
   about_signin_internals->OnRefreshTokenReceived(""Successful"");
 
   std::string account_id =
       AccountTrackerServiceFactory::GetForProfile(profile_)
           ->SeedAccountInfo(gaia_id_, email_);
 
   signin_metrics::AccessPoint access_point =
       signin::GetAccessPointForPromoURL(current_url_);
   signin_metrics::Reason reason =
       signin::GetSigninReasonForPromoURL(current_url_);
 
   SigninManager* signin_manager = SigninManagerFactory::GetForProfile(profile_);
   std::string primary_email =
       signin_manager->GetAuthenticatedAccountInfo().email;
   if (gaia::AreEmailsSame(email_, primary_email) &&
       (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||
        reason == signin_metrics::Reason::REASON_UNLOCK) &&
       !password_.empty() && profiles::IsLockAvailable(profile_)) {
     LocalAuth::SetLocalAuthCredentials(profile_, password_);
   }
 
 #if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
   if (!password_.empty()) {
     scoped_refptr<password_manager::PasswordStore> password_store =
         PasswordStoreFactory::GetForProfile(profile_,
                                             ServiceAccessType::EXPLICIT_ACCESS);
     if (password_store && !primary_email.empty()) {
       password_store->SaveGaiaPasswordHash(
           primary_email, base::UTF8ToUTF16(password_),
           password_manager::metrics_util::SyncPasswordHashChange::
               SAVED_ON_CHROME_SIGNIN);
     }
   }
 #endif
 
    if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||
        reason == signin_metrics::Reason::REASON_UNLOCK ||
        reason == signin_metrics::Reason::REASON_ADD_SECONDARY_ACCOUNT) {
    ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)->
        UpdateCredentials(account_id, result.refresh_token);
     ProfileOAuth2TokenServiceFactory::GetForProfile(profile_)
         ->UpdateCredentials(account_id, result.refresh_token,
                             signin_metrics::SourceForRefreshTokenOperation::
                                 kInlineLoginHandler_Signin);
  
      if (signin::IsAutoCloseEnabledInURL(current_url_)) {
       bool show_account_management = ShouldShowAccountManagement(
           current_url_,
           AccountConsistencyModeManager::IsMirrorEnabledForProfile(profile_));
       base::ThreadTaskRunnerHandle::Get()->PostTask(
           FROM_HERE, base::BindOnce(&InlineLoginHandlerImpl::CloseTab, handler_,
                                     show_account_management));
     }
 
     if (reason == signin_metrics::Reason::REASON_REAUTHENTICATION ||
         reason == signin_metrics::Reason::REASON_UNLOCK) {
       signin_manager->MergeSigninCredentialIntoCookieJar();
     }
     LogSigninReason(reason);
   } else {
     browser_sync::ProfileSyncService* sync_service =
         ProfileSyncServiceFactory::GetForProfile(profile_);
     SigninErrorController* error_controller =
         SigninErrorControllerFactory::GetForProfile(profile_);
 
     OneClickSigninSyncStarter::StartSyncMode start_mode =
         OneClickSigninSyncStarter::CONFIRM_SYNC_SETTINGS_FIRST;
     if (access_point == signin_metrics::AccessPoint::ACCESS_POINT_SETTINGS ||
         choose_what_to_sync_) {
       bool show_settings_without_configure =
           error_controller->HasError() && sync_service &&
           sync_service->IsFirstSetupComplete();
       if (!show_settings_without_configure)
         start_mode = OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST;
     }
 
     OneClickSigninSyncStarter::ConfirmationRequired confirmation_required =
         confirm_untrusted_signin_ ?
             OneClickSigninSyncStarter::CONFIRM_UNTRUSTED_SIGNIN :
             OneClickSigninSyncStarter::CONFIRM_AFTER_SIGNIN;
 
     bool start_signin = !HandleCrossAccountError(
         result.refresh_token, confirmation_required, start_mode);
     if (start_signin) {
       CreateSyncStarter(browser, current_url_, result.refresh_token,
                         OneClickSigninSyncStarter::CURRENT_PROFILE, start_mode,
                         confirmation_required);
       base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE, this);
     }
   }
 }","[54, 55, 56, 57, 52, 53]","The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code."
199082," SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)
 {
 	struct shmid_kernel *shp;
 	int err, version;
 	struct ipc_namespace *ns;
 
 	if (cmd < 0 || shmid < 0)
 		return -EINVAL;
 
 	version = ipc_parse_version(&cmd);
 	ns = current->nsproxy->ipc_ns;
 
 	switch (cmd) {
 	case IPC_INFO:
 	case SHM_INFO:
 	case SHM_STAT:
 	case IPC_STAT:
 		return shmctl_nolock(ns, shmid, cmd, version, buf);
 	case IPC_RMID:
 	case IPC_SET:
 		return shmctl_down(ns, shmid, cmd, buf, version);
 	case SHM_LOCK:
 	case SHM_UNLOCK:
 	{
 		struct file *shm_file;
 
 		rcu_read_lock();
 		shp = shm_obtain_object_check(ns, shmid);
 		if (IS_ERR(shp)) {
 			err = PTR_ERR(shp);
 			goto out_unlock1;
 		}
 
 		audit_ipc_obj(&(shp->shm_perm));
 		err = security_shm_shmctl(shp, cmd);
 		if (err)
 			goto out_unlock1;
 
 		ipc_lock_object(&shp->shm_perm);
 		if (!ns_capable(ns->user_ns, CAP_IPC_LOCK)) {
 			kuid_t euid = current_euid();
 			err = -EPERM;
 			if (!uid_eq(euid, shp->shm_perm.uid) &&
 			    !uid_eq(euid, shp->shm_perm.cuid))
 				goto out_unlock0;
 			if (cmd == SHM_LOCK && !rlimit(RLIMIT_MEMLOCK))
 				goto out_unlock0;
  		}
  
  		shm_file = shp->shm_file;
 
 		 
 		if (shm_file == NULL) {
 			err = -EIDRM;
 			goto out_unlock0;
 		}
 
  		if (is_file_hugepages(shm_file))
  			goto out_unlock0;
  
 		if (cmd == SHM_LOCK) {
 			struct user_struct *user = current_user();
 			err = shmem_lock(shm_file, 1, user);
 			if (!err && !(shp->shm_perm.mode & SHM_LOCKED)) {
 				shp->shm_perm.mode |= SHM_LOCKED;
 				shp->mlock_user = user;
 			}
 			goto out_unlock0;
 		}
 
 		 
 		if (!(shp->shm_perm.mode & SHM_LOCKED))
 			goto out_unlock0;
 		shmem_lock(shm_file, 0, shp->mlock_user);
 		shp->shm_perm.mode &= ~SHM_LOCKED;
 		shp->mlock_user = NULL;
 		get_file(shm_file);
 		ipc_unlock_object(&shp->shm_perm);
 		rcu_read_unlock();
 		shmem_unlock_mapping(shm_file->f_mapping);
 
 		fput(shm_file);
 		return err;
 	}
 	default:
 		return -EINVAL;
 	}
 
 out_unlock0:
 	ipc_unlock_object(&shp->shm_perm);
 out_unlock1:
 	rcu_read_unlock();
 	return err;
 }","[51, 52, 53, 54, 55, 56, 57]",Multiple race conditions in ipc/shm.c in the Linux kernel before 3.12.2 allow local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted application that uses shmctl IPC_RMID operations in conjunction with other shm system calls.
206803,"  PlatformSensorAndroid::PlatformSensorAndroid(
      mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     SensorReadingSharedBuffer* reading_buffer,
      PlatformSensorProvider* provider,
      const JavaRef<jobject>& java_sensor)
    : PlatformSensor(type, std::move(mapping), provider) {
     : PlatformSensor(type, reading_buffer, provider) {
    JNIEnv* env = AttachCurrentThread();
    j_object_.Reset(java_sensor);
  
   Java_PlatformSensor_initPlatformSensorAndroid(env, j_object_,
                                                 reinterpret_cast<jlong>(this));
 }","[4, 8, 3, 7]",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
198005,"  SchedulerObject::release(std::string key, std::string &reason, std::string &text)
  {
         PROC_ID id = getProcByString(key.c_str());
       if (id.cluster < 0 || id.proc < 0) {
        if (id.cluster <= 0 || id.proc < 0) {
                 dprintf(D_FULLDEBUG, ""Release: Failed to parse id: %s\n"", key.c_str());
                 text = ""Invalid Id"";
                 return false;
 	}
 
 	if (!releaseJob(id.cluster,
 					id.proc,
 					reason.c_str(),
 					true,  
 					false,  
 					false  
 					)) {
 		text = ""Failed to release job"";
 		return false;
 	}
 
 	return true;
 }","[5, 4]","aviary/jobcontrol.py in Condor, as used in Red Hat Enterprise MRG 2.3, when removing a job, allows remote attackers to cause a denial of service (condor_schedd restart) via square brackets in the cproc option."
208626,"  void WT_NoiseGenerator (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
  {
     EAS_PCM *pOutputBuffer;
     EAS_I32 phaseInc;
     EAS_I32 tmp0;
     EAS_I32 tmp1;
     EAS_I32 nInterpolatedSample;
     EAS_I32 numSamples;
 
   
 
      numSamples = pWTIntFrame->numSamples;
      if (numSamples <= 0) {
          ALOGE(""b/26366256"");
         android_errorWriteLog(0x534e4554, ""26366256"");
          return;
      }
      pOutputBuffer = pWTIntFrame->pAudioBuffer;
     phaseInc = pWTIntFrame->frame.phaseIncrement;
 
   
   
     tmp0 = (EAS_I32) (pWTVoice->phaseAccum) >> 18;
   
     tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;
 
   
  while (numSamples--) {
         nInterpolatedSample = MULT_AUDIO_COEF( tmp0, (PHASE_ONE - pWTVoice->phaseFrac));
         nInterpolatedSample += MULT_AUDIO_COEF( tmp1, pWTVoice->phaseFrac);
  *pOutputBuffer++ = (EAS_PCM) nInterpolatedSample;
 
   
         pWTVoice->phaseFrac += (EAS_U32) phaseInc;
  if (GET_PHASE_INT_PART(pWTVoice->phaseFrac)) {
             tmp0 = tmp1;
             pWTVoice->phaseAccum = pWTVoice->loopEnd;
             pWTVoice->loopEnd = (5 * pWTVoice->loopEnd + 1);
             tmp1 = (EAS_I32) (pWTVoice->loopEnd) >> 18;
             pWTVoice->phaseFrac = GET_PHASE_FRAC_PART(pWTVoice->phaseFrac);
  }
 
  }
 }",[15],"Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
205680," void FragmentPaintPropertyTreeBuilder::UpdatePerspective() {
   DCHECK(properties_);
 
   if (NeedsPaintPropertyUpdate()) {
     if (NeedsPerspective(object_)) {
       const ComputedStyle& style = object_.StyleRef();
       TransformPaintPropertyNode::State state;
       state.matrix.ApplyPerspective(style.Perspective());
       state.origin = PerspectiveOrigin(ToLayoutBox(object_)) +
                      ToLayoutSize(context_.current.paint_offset);
       state.flattens_inherited_transform =
           context_.current.should_flatten_inherited_transform;
        if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
            RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())
          state.rendering_context_id = context_.current.rendering_context_id;
      OnUpdate(properties_->UpdatePerspective(context_.current.transform,
       OnUpdate(properties_->UpdatePerspective(*context_.current.transform,
                                                std::move(state)));
      } else {
        OnClear(properties_->ClearPerspective());
     }
   }
 
   if (properties_->Perspective()) {
     context_.current.transform = properties_->Perspective();
     context_.current.should_flatten_inherited_transform = false;
   }
 }","[17, 16]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
202826," int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
 {
 	struct nfc_llcp_local *local;
 	struct sk_buff *skb;
 	u8 *service_name_tlv = NULL, service_name_tlv_length;
 	u8 *miux_tlv = NULL, miux_tlv_length;
 	u8 *rw_tlv = NULL, rw_tlv_length, rw;
 	int err;
 	u16 size = 0;
 	__be16 miux;
 
 	pr_debug(""Sending CONNECT\n"");
 
 	local = sock->local;
 	if (local == NULL)
 		return -ENODEV;
 
 	if (sock->service_name != NULL) {
 		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
  						      sock->service_name,
  						      sock->service_name_len,
  						      &service_name_tlv_length);
 		if (!service_name_tlv) {
 			err = -ENOMEM;
 			goto error_tlv;
 		}
  		size += service_name_tlv_length;
  	}
  
 	 
 	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
 		local->miux : sock->miux;
 	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
  
  	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
  				      &miux_tlv_length);
 	if (!miux_tlv) {
 		err = -ENOMEM;
 		goto error_tlv;
 	}
  	size += miux_tlv_length;
  
  	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
 	if (!rw_tlv) {
 		err = -ENOMEM;
 		goto error_tlv;
 	}
  	size += rw_tlv_length;
  
  	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);
 
 	skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);
 	if (skb == NULL) {
 		err = -ENOMEM;
 		goto error_tlv;
 	}
 
 	llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);
 	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
 	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);
 
 	skb_queue_tail(&local->tx_queue, skb);
 
 	err = 0;
 
 error_tlv:
 	if (err)
 		pr_err(""error %d\n"", err);
 
 	kfree(service_name_tlv);
 	kfree(miux_tlv);
 	kfree(rw_tlv);
 
 	return err;
 }","[23, 24, 25, 26, 37, 38, 39, 40, 44, 45, 46, 47]","An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c."
201189," gss_inquire_context(
 	    OM_uint32 *minor_status,
 	    gss_ctx_id_t context_handle,
 	    gss_name_t *src_name,
 	    gss_name_t *targ_name,
 	    OM_uint32 *lifetime_rec,
 	    gss_OID *mech_type,
 	    OM_uint32 *ctx_flags,
 	    int *locally_initiated,
 	    int *opened)
 {
     gss_union_ctx_id_t	ctx;
     gss_mechanism	mech;
     OM_uint32		status, temp_minor;
     gss_OID		actual_mech;
     gss_name_t localTargName = NULL, localSourceName = NULL;
 
     status = val_inq_ctx_args(minor_status,
 			      context_handle,
 			      src_name, targ_name,
 			      lifetime_rec,
 			      mech_type, ctx_flags,
 			      locally_initiated, opened);
     if (status != GSS_S_COMPLETE)
 	return (status);
 
      
  
      ctx = (gss_union_ctx_id_t) context_handle;
     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
 	return (GSS_S_NO_CONTEXT);
      mech = gssint_get_mechanism (ctx->mech_type);
  
      if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||
 	!mech->gss_release_name) {
 	return (GSS_S_UNAVAILABLE);
     }
 
     status = mech->gss_inquire_context(
 			minor_status,
 			ctx->internal_ctx_id,
 			(src_name ? &localSourceName : NULL),
 			(targ_name ? &localTargName : NULL),
 			lifetime_rec,
 			&actual_mech,
 			ctx_flags,
 			locally_initiated,
 			opened);
 
     if (status != GSS_S_COMPLETE) {
 	map_error(minor_status, mech);
 	return status;
     }
 
      
 
     if (src_name) {
 	if (localSourceName) {
 	    status = gssint_convert_name_to_union_name(minor_status, mech,
 						      localSourceName, src_name);
 
 	    if (status != GSS_S_COMPLETE) {
 		if (localTargName)
 		    mech->gss_release_name(&temp_minor, &localTargName);
 		return (status);
 	    }
 	} else {
 	    *src_name = GSS_C_NO_NAME;
 	}
     }
 
     if (targ_name) {
         if (localTargName) {
 	    status = gssint_convert_name_to_union_name(minor_status, mech,
 						      localTargName, targ_name);
 
 	    if (status != GSS_S_COMPLETE) {
 		if (src_name)
 		    (void) gss_release_name(&temp_minor, src_name);
 
 		return (status);
 	    }
         }
         else {
             *targ_name = GSS_C_NO_NAME;
         }
     }
 
     if (mech_type)
 	*mech_type = gssint_get_public_oid(actual_mech);
 
     return(GSS_S_COMPLETE);
 }","[30, 31]",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
201800,"  static MagickBooleanType ConcatenateImages(int argc,char **argv,
     ExceptionInfo *exception )
   ExceptionInfo *exception )
  {
    FILE
      *input,
      *output;
  
   MagickBooleanType
     status;
 
    int
      c;
  
   register ssize_t
     i;
  
    if (ExpandFilenames(&argc,&argv) == MagickFalse)
      ThrowFileException(exception,ResourceLimitError,""MemoryAllocationFailed"",
         GetExceptionMessage(errno));
       GetExceptionMessage(errno));
    output=fopen_utf8(argv[argc-1],""wb"");
  if (output == (FILE *) NULL) {
    ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",argv[argc-1]);
    return(MagickFalse);
  }
  for (i=2; i < (ssize_t) (argc-1); i++) {
#if 0
    fprintf(stderr, ""DEBUG: Concatenate Image: \""%s\""\n"", argv[i]);
#endif
   if (output == (FILE *) NULL)
     {
       ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",
         argv[argc-1]);
       return(MagickFalse);
     }
   status=MagickTrue;
   for (i=2; i < (ssize_t) (argc-1); i++)
   {
      input=fopen_utf8(argv[i],""rb"");
    if (input == (FILE *) NULL) {
     if (input == (FILE *) NULL)
       {
          ThrowFileException(exception,FileOpenError,""UnableToOpenFile"",argv[i]);
          continue;
        }
      for (c=fgetc(input); c != EOF; c=fgetc(input))
      (void) fputc((char) c,output);
       if (fputc((char) c,output) != c)
         status=MagickFalse;
      (void) fclose(input);
      (void) remove_utf8(argv[i]);
    }
    (void) fclose(output);
  return(MagickTrue);
   return(status);
  }","[3, 9, 10, 11, 21, 31, 32, 33, 34, 35, 36, 37, 38, 39, 42, 43, 49, 50, 56, 2, 20, 23, 24, 25, 26, 27, 28, 29, 30, 41, 48, 55]","The ConcatenateImages function in MagickWand/magick-cli.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (application crash) via a crafted file."
200013," sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 {
 	int mxsize, cmd_size, k;
 	int input_size, blocking;
 	unsigned char opcode;
 	Sg_device *sdp;
 	Sg_fd *sfp;
 	Sg_request *srp;
 	struct sg_header old_hdr;
  	sg_io_hdr_t *hp;
  	unsigned char cmnd[SG_MAX_CDB_SIZE];
  
 	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))
 		return -EINVAL;
 
  	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
  		return -ENXIO;
  	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
 				      ""sg_write: count=%d\n"", (int) count));
 	if (atomic_read(&sdp->detaching))
 		return -ENODEV;
 	if (!((filp->f_flags & O_NONBLOCK) ||
 	      scsi_block_when_processing_errors(sdp->device)))
 		return -ENXIO;
 
 	if (!access_ok(VERIFY_READ, buf, count))
 		return -EFAULT;	 
 	if (count < SZ_SG_HEADER)
 		return -EIO;
 	if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))
 		return -EFAULT;
 	blocking = !(filp->f_flags & O_NONBLOCK);
 	if (old_hdr.reply_len < 0)
 		return sg_new_write(sfp, filp, buf, count,
 				    blocking, 0, 0, NULL);
 	if (count < (SZ_SG_HEADER + 6))
 		return -EIO;	 
 
 	if (!(srp = sg_add_request(sfp))) {
 		SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp,
 					      ""sg_write: queue full\n""));
 		return -EDOM;
 	}
 	buf += SZ_SG_HEADER;
 	__get_user(opcode, buf);
 	if (sfp->next_cmd_len > 0) {
 		cmd_size = sfp->next_cmd_len;
 		sfp->next_cmd_len = 0;	 
 	} else {
 		cmd_size = COMMAND_SIZE(opcode);	 
 		if ((opcode >= 0xc0) && old_hdr.twelve_byte)
 			cmd_size = 12;
 	}
 	SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp,
 		""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size));
  
 	input_size = count - cmd_size;
 	mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;
 	mxsize -= SZ_SG_HEADER;
 	input_size -= SZ_SG_HEADER;
 	if (input_size < 0) {
 		sg_remove_request(sfp, srp);
 		return -EIO;	 
 	}
 	hp = &srp->header;
 	hp->interface_id = '\0';	 
 	hp->cmd_len = (unsigned char) cmd_size;
 	hp->iovec_count = 0;
 	hp->mx_sb_len = 0;
 	if (input_size > 0)
 		hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?
 		    SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
 	else
 		hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
 	hp->dxfer_len = mxsize;
 	if ((hp->dxfer_direction == SG_DXFER_TO_DEV) ||
 	    (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV))
 		hp->dxferp = (char __user *)buf + cmd_size;
 	else
 		hp->dxferp = NULL;
 	hp->sbp = NULL;
 	hp->timeout = old_hdr.reply_len;	 
 	hp->flags = input_size;	 
 	hp->pack_id = old_hdr.pack_id;
 	hp->usr_ptr = NULL;
 	if (__copy_from_user(cmnd, buf, cmd_size))
 		return -EFAULT;
 	 
 	if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {
 		static char cmd[TASK_COMM_LEN];
 		if (strcmp(current->comm, cmd)) {
 			printk_ratelimited(KERN_WARNING
 					   ""sg_write: data in/out %d/%d bytes ""
 					   ""for SCSI command 0x%x-- guessing ""
 					   ""data in;\n   program %s not setting ""
 					   ""count and/or reply_len properly\n"",
 					   old_hdr.reply_len - (int)SZ_SG_HEADER,
 					   input_size, (unsigned int) cmnd[0],
 					   current->comm);
 			strcpy(cmd, current->comm);
 		}
 	}
 	k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);
 	return (k < 0) ? k : count;
 }","[13, 14, 15]","The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576."
5866,"archive_read_format_rar_read_data(struct archive_read *a, const void **buff,
size_t *size, int64_t *offset)
{
struct rar *rar = (struct rar *)(a->format->data);
int ret;

if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {
rar->has_encrypted_entries = 0;
}

if (rar->bytes_unconsumed > 0) {

__archive_read_consume(a, rar->bytes_unconsumed);
rar->bytes_unconsumed = 0;
}

*buff = NULL;
if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {
*size = 0;
*offset = rar->offset;
if (*offset < rar->unp_size)
*offset = rar->unp_size;
return (ARCHIVE_EOF);
}

switch (rar->compression_method)
{
case COMPRESS_METHOD_STORE:
ret = read_data_stored(a, buff, size, offset);
break;

case COMPRESS_METHOD_FASTEST:
case COMPRESS_METHOD_FAST:
case COMPRESS_METHOD_NORMAL:
case COMPRESS_METHOD_GOOD:
case COMPRESS_METHOD_BEST:
ret = read_data_compressed(a, buff, size, offset);
if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)
__archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);
break;

default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
""Unsupported compression method for RAR file."");
ret = ARCHIVE_FATAL;
break;
}
return (ret);
}","[38, 40]","archive_read_format_rar_read_data in archive_read_support_format_rar.c in libarchive before 3.4.0 has a use-after-free in a certain ARCHIVE_FAILED situation, related to Ppmd7_DecodeSymbol."
202931," GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)
 {
 	GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);
 	if (e) {
  		return e;
  	}
  	if (!((GF_DataInformationBox *)s)->dref) {
 		GF_Box* dref;
  		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n""));
		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
 		dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
 		((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
 		gf_isom_box_add_for_dump_mode(s, dref);
  	}
  	return GF_OK;
  }","[8, 11, 12, 13, 10]",GPAC 0.7.1 has a memory leak in dinf_Read in isomedia/box_code_base.c.
205051,"  void AcceleratedSurfaceBuffersSwappedCompleted(int host_id,
                                                 int route_id,
                                                 int surface_id,
                                                uint64 surface_handle,
                                                 bool alive,
                                                 base::TimeTicks timebase,
                                                 base::TimeDelta interval) {
    AcceleratedSurfaceBuffersSwappedCompletedForGPU(host_id, route_id,
                                                  alive, true  );
                                                   alive, surface_handle);
    AcceleratedSurfaceBuffersSwappedCompletedForRenderer(surface_id, timebase,
                                                         interval);
  }","[4, 10, 9]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
202996," icmp6_print(netdissect_options *ndo,
             const u_char *bp, u_int length, const u_char *bp2, int fragmented)
 {
 	const struct icmp6_hdr *dp;
 	const struct ip6_hdr *ip;
 	const struct ip6_hdr *oip;
 	const struct udphdr *ouh;
 	int dport;
 	const u_char *ep;
 	u_int prot;
 
 	dp = (const struct icmp6_hdr *)bp;
 	ip = (const struct ip6_hdr *)bp2;
 	oip = (const struct ip6_hdr *)(dp + 1);
 	 
 	ep = ndo->ndo_snapend;
 
 	ND_TCHECK(dp->icmp6_cksum);
 
 	if (ndo->ndo_vflag && !fragmented) {
 		uint16_t sum, udp_sum;
 
 		if (ND_TTEST2(bp[0], length)) {
 			udp_sum = EXTRACT_16BITS(&dp->icmp6_cksum);
 			sum = icmp6_cksum(ndo, ip, dp, length);
 			if (sum != 0)
 				ND_PRINT((ndo,""[bad icmp6 cksum 0x%04x -> 0x%04x!] "",
                                                 udp_sum,
                                                 in_cksum_shouldbe(udp_sum, sum)));
 			else
 				ND_PRINT((ndo,""[icmp6 sum ok] ""));
 		}
 	}
 
         ND_PRINT((ndo,""ICMP6, %s"", tok2str(icmp6_type_values,""unknown icmp6 type (%u)"",dp->icmp6_type)));
 
          
         if (ndo->ndo_vflag && (dp->icmp6_type == ND_ROUTER_SOLICIT ||
                       dp->icmp6_type == ND_ROUTER_ADVERT ||
                       dp->icmp6_type == ND_NEIGHBOR_ADVERT ||
                       dp->icmp6_type == ND_NEIGHBOR_SOLICIT ||
                       dp->icmp6_type == ND_REDIRECT ||
                       dp->icmp6_type == ICMP6_HADISCOV_REPLY ||
                       dp->icmp6_type == ICMP6_MOBILEPREFIX_ADVERT ))
                 ND_PRINT((ndo,"", length %u"", length));
 
 	switch (dp->icmp6_type) {
 	case ICMP6_DST_UNREACH:
 		ND_TCHECK(oip->ip6_dst);
                 ND_PRINT((ndo,"", %s"", tok2str(icmp6_dst_unreach_code_values,""unknown unreach code (%u)"",dp->icmp6_code)));
 		switch (dp->icmp6_code) {
 
 		case ICMP6_DST_UNREACH_NOROUTE:  
 		case ICMP6_DST_UNREACH_ADMIN:
 		case ICMP6_DST_UNREACH_ADDR:
                         ND_PRINT((ndo,"" %s"",ip6addr_string(ndo, &oip->ip6_dst)));
                         break;
 		case ICMP6_DST_UNREACH_BEYONDSCOPE:
 			ND_PRINT((ndo,"" %s, source address %s"",
 			       ip6addr_string(ndo, &oip->ip6_dst),
                                   ip6addr_string(ndo, &oip->ip6_src)));
 			break;
 		case ICMP6_DST_UNREACH_NOPORT:
 			if ((ouh = get_upperlayer(ndo, (const u_char *)oip, &prot))
 			    == NULL)
 				goto trunc;
 
 			dport = EXTRACT_16BITS(&ouh->uh_dport);
 			switch (prot) {
 			case IPPROTO_TCP:
 				ND_PRINT((ndo,"", %s tcp port %s"",
 					ip6addr_string(ndo, &oip->ip6_dst),
                                           tcpport_string(ndo, dport)));
 				break;
 			case IPPROTO_UDP:
 				ND_PRINT((ndo,"", %s udp port %s"",
 					ip6addr_string(ndo, &oip->ip6_dst),
                                           udpport_string(ndo, dport)));
 				break;
 			default:
 				ND_PRINT((ndo,"", %s protocol %d port %d unreachable"",
 					ip6addr_string(ndo, &oip->ip6_dst),
                                           oip->ip6_nxt, dport));
 				break;
 			}
 			break;
 		default:
                   if (ndo->ndo_vflag <= 1) {
                     print_unknown_data(ndo, bp,""\n\t"",length);
                     return;
                   }
                     break;
 		}
 		break;
 	case ICMP6_PACKET_TOO_BIG:
 		ND_TCHECK(dp->icmp6_mtu);
 		ND_PRINT((ndo,"", mtu %u"", EXTRACT_32BITS(&dp->icmp6_mtu)));
 		break;
 	case ICMP6_TIME_EXCEEDED:
 		ND_TCHECK(oip->ip6_dst);
 		switch (dp->icmp6_code) {
 		case ICMP6_TIME_EXCEED_TRANSIT:
 			ND_PRINT((ndo,"" for %s"",
                                   ip6addr_string(ndo, &oip->ip6_dst)));
 			break;
 		case ICMP6_TIME_EXCEED_REASSEMBLY:
 			ND_PRINT((ndo,"" (reassembly)""));
 			break;
 		default:
                         ND_PRINT((ndo,"", unknown code (%u)"", dp->icmp6_code));
 			break;
 		}
 		break;
 	case ICMP6_PARAM_PROB:
 		ND_TCHECK(oip->ip6_dst);
 		switch (dp->icmp6_code) {
 		case ICMP6_PARAMPROB_HEADER:
                         ND_PRINT((ndo,"", erroneous - octet %u"", EXTRACT_32BITS(&dp->icmp6_pptr)));
                         break;
 		case ICMP6_PARAMPROB_NEXTHEADER:
                         ND_PRINT((ndo,"", next header - octet %u"", EXTRACT_32BITS(&dp->icmp6_pptr)));
                         break;
 		case ICMP6_PARAMPROB_OPTION:
                         ND_PRINT((ndo,"", option - octet %u"", EXTRACT_32BITS(&dp->icmp6_pptr)));
                         break;
 		default:
                         ND_PRINT((ndo,"", code-#%d"",
                                   dp->icmp6_code));
                         break;
 		}
 		break;
 	case ICMP6_ECHO_REQUEST:
 	case ICMP6_ECHO_REPLY:
                 ND_TCHECK(dp->icmp6_seq);
                 ND_PRINT((ndo,"", seq %u"", EXTRACT_16BITS(&dp->icmp6_seq)));
 		break;
 	case ICMP6_MEMBERSHIP_QUERY:
 		if (length == MLD_MINLEN) {
 			mld6_print(ndo, (const u_char *)dp);
 		} else if (length >= MLDV2_MINLEN) {
 			ND_PRINT((ndo,"" v2""));
 			mldv2_query_print(ndo, (const u_char *)dp, length);
 		} else {
                         ND_PRINT((ndo,"" unknown-version (len %u) "", length));
 		}
 		break;
 	case ICMP6_MEMBERSHIP_REPORT:
 		mld6_print(ndo, (const u_char *)dp);
 		break;
 	case ICMP6_MEMBERSHIP_REDUCTION:
 		mld6_print(ndo, (const u_char *)dp);
 		break;
 	case ND_ROUTER_SOLICIT:
 #define RTSOLLEN 8
 		if (ndo->ndo_vflag) {
 			icmp6_opt_print(ndo, (const u_char *)dp + RTSOLLEN,
 					length - RTSOLLEN);
 		}
 		break;
 	case ND_ROUTER_ADVERT:
 #define RTADVLEN 16
 		if (ndo->ndo_vflag) {
 			const struct nd_router_advert *p;
 
 			p = (const struct nd_router_advert *)dp;
 			ND_TCHECK(p->nd_ra_retransmit);
 			ND_PRINT((ndo,""\n\thop limit %u, Flags [%s]"" \
                                   "", pref %s, router lifetime %us, reachable time %ums, retrans timer %ums"",
                                   (u_int)p->nd_ra_curhoplimit,
                                   bittok2str(icmp6_opt_ra_flag_values,""none"",(p->nd_ra_flags_reserved)),
                                   get_rtpref(p->nd_ra_flags_reserved),
                                   EXTRACT_16BITS(&p->nd_ra_router_lifetime),
                                   EXTRACT_32BITS(&p->nd_ra_reachable),
                                   EXTRACT_32BITS(&p->nd_ra_retransmit)));
 
 			icmp6_opt_print(ndo, (const u_char *)dp + RTADVLEN,
 					length - RTADVLEN);
 		}
 		break;
 	case ND_NEIGHBOR_SOLICIT:
 	    {
 		const struct nd_neighbor_solicit *p;
 		p = (const struct nd_neighbor_solicit *)dp;
 		ND_TCHECK(p->nd_ns_target);
 		ND_PRINT((ndo,"", who has %s"", ip6addr_string(ndo, &p->nd_ns_target)));
 		if (ndo->ndo_vflag) {
 #define NDSOLLEN 24
 			icmp6_opt_print(ndo, (const u_char *)dp + NDSOLLEN,
 					length - NDSOLLEN);
 		}
 	    }
 		break;
 	case ND_NEIGHBOR_ADVERT:
 	    {
 		const struct nd_neighbor_advert *p;
 
 		p = (const struct nd_neighbor_advert *)dp;
 		ND_TCHECK(p->nd_na_target);
 		ND_PRINT((ndo,"", tgt is %s"",
                           ip6addr_string(ndo, &p->nd_na_target)));
 		if (ndo->ndo_vflag) {
                         ND_PRINT((ndo,"", Flags [%s]"",
                                   bittok2str(icmp6_nd_na_flag_values,
                                              ""none"",
                                              EXTRACT_32BITS(&p->nd_na_flags_reserved))));
 #define NDADVLEN 24
 			icmp6_opt_print(ndo, (const u_char *)dp + NDADVLEN,
 					length - NDADVLEN);
 #undef NDADVLEN
 		}
 	    }
 		break;
 	case ND_REDIRECT:
 #define RDR(i) ((const struct nd_redirect *)(i))
                          ND_TCHECK(RDR(dp)->nd_rd_dst);
                          ND_PRINT((ndo,"", %s"", ip6addr_string(ndo, &RDR(dp)->nd_rd_dst)));
 		ND_TCHECK(RDR(dp)->nd_rd_target);
 		ND_PRINT((ndo,"" to %s"",
                           ip6addr_string(ndo, &RDR(dp)->nd_rd_target)));
 #define REDIRECTLEN 40
 		if (ndo->ndo_vflag) {
 			icmp6_opt_print(ndo, (const u_char *)dp + REDIRECTLEN,
 					length - REDIRECTLEN);
 		}
 		break;
 #undef REDIRECTLEN
 #undef RDR
 	case ICMP6_ROUTER_RENUMBERING:
 		icmp6_rrenum_print(ndo, bp, ep);
 		break;
 	case ICMP6_NI_QUERY:
 	case ICMP6_NI_REPLY:
 		icmp6_nodeinfo_print(ndo, length, bp, ep);
 		break;
 	case IND_SOLICIT:
 	case IND_ADVERT:
 		break;
 	case ICMP6_V2_MEMBERSHIP_REPORT:
 		mldv2_report_print(ndo, (const u_char *) dp, length);
 		break;
 	case ICMP6_MOBILEPREFIX_SOLICIT:  
 	case ICMP6_HADISCOV_REQUEST:
                 ND_TCHECK(dp->icmp6_data16[0]);
                 ND_PRINT((ndo,"", id 0x%04x"", EXTRACT_16BITS(&dp->icmp6_data16[0])));
                 break;
 	case ICMP6_HADISCOV_REPLY:
 		if (ndo->ndo_vflag) {
 			const struct in6_addr *in6;
 			const u_char *cp;
 
 			ND_TCHECK(dp->icmp6_data16[0]);
 			ND_PRINT((ndo,"", id 0x%04x"", EXTRACT_16BITS(&dp->icmp6_data16[0])));
 			cp = (const u_char *)dp + length;
 			in6 = (const struct in6_addr *)(dp + 1);
 			for (; (const u_char *)in6 < cp; in6++) {
 				ND_TCHECK(*in6);
 				ND_PRINT((ndo,"", %s"", ip6addr_string(ndo, in6)));
 			}
 		}
 		break;
 	case ICMP6_MOBILEPREFIX_ADVERT:
 		if (ndo->ndo_vflag) {
 			ND_TCHECK(dp->icmp6_data16[0]);
 			ND_PRINT((ndo,"", id 0x%04x"", EXTRACT_16BITS(&dp->icmp6_data16[0])));
 			ND_TCHECK(dp->icmp6_data16[1]);
 			if (dp->icmp6_data16[1] & 0xc0)
 				ND_PRINT((ndo,"" ""));
 			if (dp->icmp6_data16[1] & 0x80)
 				ND_PRINT((ndo,""M""));
 			if (dp->icmp6_data16[1] & 0x40)
 				ND_PRINT((ndo,""O""));
 #define MPADVLEN 8
 			icmp6_opt_print(ndo, (const u_char *)dp + MPADVLEN,
 					length - MPADVLEN);
 		}
 		break;
         case ND_RPL_MESSAGE:
                  
                 rpl_print(ndo, dp, &dp->icmp6_data8[0], length-sizeof(struct icmp6_hdr)+4);
                 break;
 	default:
                 ND_PRINT((ndo,"", length %u"", length));
                 if (ndo->ndo_vflag <= 1)
                         print_unknown_data(ndo, bp,""\n\t"", length);
                 return;
         }
         if (!ndo->ndo_vflag)
                  ND_PRINT((ndo,"", length %u"", length));
  	return;
  trunc:
	ND_PRINT((ndo, ""[|icmp6]""));
 	ND_PRINT((ndo, ""%s"", icmp6_tstr));
  }","[292, 291]",The ICMPv6 parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp6.c.
206623," InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
    if (!profile)
      return nullptr;
    return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
       profile);
  }","[6, 5]",Incorrect object lifecycle in Extensions in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
199378," pkinit_server_return_padata(krb5_context context,
                             krb5_pa_data * padata,
                             krb5_data *req_pkt,
                             krb5_kdc_req * request,
                             krb5_kdc_rep * reply,
                             krb5_keyblock * encrypting_key,
                             krb5_pa_data ** send_pa,
                             krb5_kdcpreauth_callbacks cb,
                             krb5_kdcpreauth_rock rock,
                             krb5_kdcpreauth_moddata moddata,
                             krb5_kdcpreauth_modreq modreq)
 {
     krb5_error_code retval = 0;
     krb5_data scratch = {0, 0, NULL};
     krb5_pa_pk_as_req *reqp = NULL;
     krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
     int i = 0;
 
     unsigned char *subjectPublicKey = NULL;
     unsigned char *dh_pubkey = NULL, *server_key = NULL;
     unsigned int subjectPublicKey_len = 0;
     unsigned int server_key_len = 0, dh_pubkey_len = 0;
 
     krb5_kdc_dh_key_info dhkey_info;
     krb5_data *encoded_dhkey_info = NULL;
     krb5_pa_pk_as_rep *rep = NULL;
     krb5_pa_pk_as_rep_draft9 *rep9 = NULL;
     krb5_data *out_data = NULL;
     krb5_octet_data secret;
 
     krb5_enctype enctype = -1;
 
     krb5_reply_key_pack *key_pack = NULL;
     krb5_reply_key_pack_draft9 *key_pack9 = NULL;
     krb5_data *encoded_key_pack = NULL;
 
     pkinit_kdc_context plgctx;
     pkinit_kdc_req_context reqctx;
 
     int fixed_keypack = 0;
 
     *send_pa = NULL;
     if (padata->pa_type == KRB5_PADATA_PKINIT_KX) {
         return return_pkinit_kx(context, request, reply,
                                 encrypting_key, send_pa);
     }
     if (padata->length <= 0 || padata->contents == NULL)
         return 0;
 
     if (modreq == NULL) {
         pkiDebug(""missing request context \n"");
         return EINVAL;
     }
 
     plgctx = pkinit_find_realm_context(context, moddata, request->server);
     if (plgctx == NULL) {
         pkiDebug(""Unable to locate correct realm context\n"");
         return ENOENT;
     }
 
     pkiDebug(""pkinit_return_padata: entered!\n"");
     reqctx = (pkinit_kdc_req_context)modreq;
 
     if (encrypting_key->contents) {
         free(encrypting_key->contents);
         encrypting_key->length = 0;
         encrypting_key->contents = NULL;
     }
 
     for(i = 0; i < request->nktypes; i++) {
         enctype = request->ktype[i];
         if (!krb5_c_valid_enctype(enctype))
             continue;
         else {
             pkiDebug(""KDC picked etype = %d\n"", enctype);
             break;
         }
     }
 
     if (i == request->nktypes) {
         retval = KRB5KDC_ERR_ETYPE_NOSUPP;
         goto cleanup;
     }
 
     switch((int)reqctx->pa_type) {
     case KRB5_PADATA_PK_AS_REQ:
         init_krb5_pa_pk_as_rep(&rep);
         if (rep == NULL) {
             retval = ENOMEM;
             goto cleanup;
         }
          
         rep->choice = choice_pa_pk_as_rep_encKeyPack;
         break;
     case KRB5_PADATA_PK_AS_REP_OLD:
     case KRB5_PADATA_PK_AS_REQ_OLD:
         init_krb5_pa_pk_as_rep_draft9(&rep9);
         if (rep9 == NULL) {
             retval = ENOMEM;
             goto cleanup;
         }
         rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;
         break;
     default:
         retval = KRB5KDC_ERR_PREAUTH_FAILED;
         goto cleanup;
     }
 
     if (reqctx->rcv_auth_pack != NULL &&
         reqctx->rcv_auth_pack->clientPublicValue != NULL) {
         subjectPublicKey =
             reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.data;
         subjectPublicKey_len =
             reqctx->rcv_auth_pack->clientPublicValue->subjectPublicKey.length;
         rep->choice = choice_pa_pk_as_rep_dhInfo;
     } else if (reqctx->rcv_auth_pack9 != NULL &&
                reqctx->rcv_auth_pack9->clientPublicValue != NULL) {
         subjectPublicKey =
             reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.data;
         subjectPublicKey_len =
             reqctx->rcv_auth_pack9->clientPublicValue->subjectPublicKey.length;
         rep9->choice = choice_pa_pk_as_rep_draft9_dhSignedData;
     }
 
      
     if (rep != NULL && (rep->choice == choice_pa_pk_as_rep_dhInfo ||
                         rep->choice == choice_pa_pk_as_rep_draft9_dhSignedData)) {
         pkiDebug(""received DH key delivery AS REQ\n"");
         retval = server_process_dh(context, plgctx->cryptoctx,
                                    reqctx->cryptoctx, plgctx->idctx, subjectPublicKey,
                                    subjectPublicKey_len, &dh_pubkey, &dh_pubkey_len,
                                    &server_key, &server_key_len);
         if (retval) {
             pkiDebug(""failed to process/create dh paramters\n"");
             goto cleanup;
         }
     }
     if ((rep9 != NULL &&
          rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||
         (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {
 
          
 
         dhkey_info.subjectPublicKey.length = dh_pubkey_len;
         dhkey_info.subjectPublicKey.data = dh_pubkey;
         dhkey_info.nonce = request->nonce;
         dhkey_info.dhKeyExpiration = 0;
 
         retval = k5int_encode_krb5_kdc_dh_key_info(&dhkey_info,
                                                    &encoded_dhkey_info);
         if (retval) {
             pkiDebug(""encode_krb5_kdc_dh_key_info failed\n"");
             goto cleanup;
         }
 #ifdef DEBUG_ASN1
         print_buffer_bin((unsigned char *)encoded_dhkey_info->data,
                          encoded_dhkey_info->length,
                          ""/tmp/kdc_dh_key_info"");
 #endif
 
         switch ((int)padata->pa_type) {
         case KRB5_PADATA_PK_AS_REQ:
             retval = cms_signeddata_create(context, plgctx->cryptoctx,
                                            reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_SERVER, 1,
                                            (unsigned char *)encoded_dhkey_info->data,
                                            encoded_dhkey_info->length,
                                            &rep->u.dh_Info.dhSignedData.data,
                                            &rep->u.dh_Info.dhSignedData.length);
             if (retval) {
                 pkiDebug(""failed to create pkcs7 signed data\n"");
                 goto cleanup;
             }
             break;
         case KRB5_PADATA_PK_AS_REP_OLD:
         case KRB5_PADATA_PK_AS_REQ_OLD:
             retval = cms_signeddata_create(context, plgctx->cryptoctx,
                                            reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9, 1,
                                            (unsigned char *)encoded_dhkey_info->data,
                                            encoded_dhkey_info->length,
                                            &rep9->u.dhSignedData.data,
                                            &rep9->u.dhSignedData.length);
             if (retval) {
                 pkiDebug(""failed to create pkcs7 signed data\n"");
                 goto cleanup;
             }
             break;
         }
 
     } else {
         pkiDebug(""received RSA key delivery AS REQ\n"");
 
         retval = krb5_c_make_random_key(context, enctype, encrypting_key);
         if (retval) {
             pkiDebug(""unable to make a session key\n"");
             goto cleanup;
         }
 
          
         for (i = 0; request->padata[i] != NULL; i++) {
             pkiDebug(""%s: Checking pa_type 0x%08x\n"",
                      __FUNCTION__, request->padata[i]->pa_type);
             if (request->padata[i]->pa_type == 132)
                 fixed_keypack = 1;
         }
         pkiDebug(""%s: return checksum instead of nonce = %d\n"",
                  __FUNCTION__, fixed_keypack);
 
          
         if ((int)padata->pa_type == KRB5_PADATA_PK_AS_REQ || fixed_keypack) {
             init_krb5_reply_key_pack(&key_pack);
             if (key_pack == NULL) {
                 retval = ENOMEM;
                 goto cleanup;
             }
 
             retval = krb5_c_make_checksum(context, 0,
                                           encrypting_key, KRB5_KEYUSAGE_TGS_REQ_AUTH_CKSUM,
                                           req_pkt, &key_pack->asChecksum);
             if (retval) {
                 pkiDebug(""unable to calculate AS REQ checksum\n"");
                 goto cleanup;
             }
 #ifdef DEBUG_CKSUM
             pkiDebug(""calculating checksum on buf size = %d\n"", req_pkt->length);
             print_buffer(req_pkt->data, req_pkt->length);
             pkiDebug(""checksum size = %d\n"", key_pack->asChecksum.length);
             print_buffer(key_pack->asChecksum.contents,
                          key_pack->asChecksum.length);
             pkiDebug(""encrypting key (%d)\n"", encrypting_key->length);
             print_buffer(encrypting_key->contents, encrypting_key->length);
 #endif
 
             krb5_copy_keyblock_contents(context, encrypting_key,
                                         &key_pack->replyKey);
 
             retval = k5int_encode_krb5_reply_key_pack(key_pack,
                                                       &encoded_key_pack);
             if (retval) {
                 pkiDebug(""failed to encode reply_key_pack\n"");
                 goto cleanup;
             }
         }
 
         switch ((int)padata->pa_type) {
         case KRB5_PADATA_PK_AS_REQ:
             rep->choice = choice_pa_pk_as_rep_encKeyPack;
             retval = cms_envelopeddata_create(context, plgctx->cryptoctx,
                                               reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,
                                               (unsigned char *)encoded_key_pack->data,
                                               encoded_key_pack->length,
                                               &rep->u.encKeyPack.data, &rep->u.encKeyPack.length);
             break;
         case KRB5_PADATA_PK_AS_REP_OLD:
         case KRB5_PADATA_PK_AS_REQ_OLD:
              
             if (!fixed_keypack) {
                 init_krb5_reply_key_pack_draft9(&key_pack9);
                 if (key_pack9 == NULL) {
                     retval = ENOMEM;
                     goto cleanup;
                 }
                 key_pack9->nonce = reqctx->rcv_auth_pack9->pkAuthenticator.nonce;
                 krb5_copy_keyblock_contents(context, encrypting_key,
                                             &key_pack9->replyKey);
 
                 retval = k5int_encode_krb5_reply_key_pack_draft9(key_pack9,
                                                                  &encoded_key_pack);
                 if (retval) {
                     pkiDebug(""failed to encode reply_key_pack\n"");
                     goto cleanup;
                 }
             }
 
             rep9->choice = choice_pa_pk_as_rep_draft9_encKeyPack;
             retval = cms_envelopeddata_create(context, plgctx->cryptoctx,
                                               reqctx->cryptoctx, plgctx->idctx, padata->pa_type, 1,
                                               (unsigned char *)encoded_key_pack->data,
                                               encoded_key_pack->length,
                                               &rep9->u.encKeyPack.data, &rep9->u.encKeyPack.length);
             break;
         }
         if (retval) {
             pkiDebug(""failed to create pkcs7 enveloped data: %s\n"",
                      error_message(retval));
             goto cleanup;
         }
 #ifdef DEBUG_ASN1
         print_buffer_bin((unsigned char *)encoded_key_pack->data,
                          encoded_key_pack->length,
                          ""/tmp/kdc_key_pack"");
         switch ((int)padata->pa_type) {
         case KRB5_PADATA_PK_AS_REQ:
             print_buffer_bin(rep->u.encKeyPack.data,
                              rep->u.encKeyPack.length,
                              ""/tmp/kdc_enc_key_pack"");
             break;
         case KRB5_PADATA_PK_AS_REP_OLD:
         case KRB5_PADATA_PK_AS_REQ_OLD:
             print_buffer_bin(rep9->u.encKeyPack.data,
                              rep9->u.encKeyPack.length,
                              ""/tmp/kdc_enc_key_pack"");
             break;
         }
 #endif
     }
 
     if ((rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo) &&
         ((reqctx->rcv_auth_pack != NULL &&
           reqctx->rcv_auth_pack->supportedKDFs != NULL))) {
 
          
         if (reqctx->rcv_auth_pack != NULL &&
             reqctx->rcv_auth_pack->supportedKDFs != NULL) {
             retval = pkinit_pick_kdf_alg(context, reqctx->rcv_auth_pack->supportedKDFs,
                                          &(rep->u.dh_Info.kdfID));
             if (retval) {
                 pkiDebug(""pkinit_pick_kdf_alg failed: %s\n"",
                          error_message(retval));
                 goto cleanup;
             }
         }
     }
 
     switch ((int)padata->pa_type) {
     case KRB5_PADATA_PK_AS_REQ:
         retval = k5int_encode_krb5_pa_pk_as_rep(rep, &out_data);
         break;
     case KRB5_PADATA_PK_AS_REP_OLD:
     case KRB5_PADATA_PK_AS_REQ_OLD:
         retval = k5int_encode_krb5_pa_pk_as_rep_draft9(rep9, &out_data);
         break;
     }
     if (retval) {
         pkiDebug(""failed to encode AS_REP\n"");
         goto cleanup;
     }
 #ifdef DEBUG_ASN1
     if (out_data != NULL)
         print_buffer_bin((unsigned char *)out_data->data, out_data->length,
                          ""/tmp/kdc_as_rep"");
 #endif
 
      
     if ((rep9 != NULL &&
           rep9->choice == choice_pa_pk_as_rep_draft9_dhSignedData) ||
          (rep != NULL && rep->choice == choice_pa_pk_as_rep_dhInfo)) {
  
          
        if (rep->u.dh_Info.kdfID) {
            secret.data = server_key;
         if (rep != NULL && rep->u.dh_Info.kdfID) {
             secret.data = (char *)server_key;
              secret.length = server_key_len;
  
              retval = pkinit_alg_agility_kdf(context, &secret,
                                             rep->u.dh_Info.kdfID,
                                             request->client, request->server,
                                             enctype,
                                             (krb5_octet_data *)req_pkt,
                                             (krb5_octet_data *)out_data,
                                             encrypting_key);
             if (retval) {
                 pkiDebug(""pkinit_alg_agility_kdf failed: %s\n"",
                          error_message(retval));
                 goto cleanup;
             }
 
              
         } else {
             retval = pkinit_octetstring2key(context, enctype, server_key,
                                             server_key_len, encrypting_key);
             if (retval) {
                 pkiDebug(""pkinit_octetstring2key failed: %s\n"",
                          error_message(retval));
                 goto cleanup;
             }
         }
     }
 
     *send_pa = malloc(sizeof(krb5_pa_data));
     if (*send_pa == NULL) {
         retval = ENOMEM;
         free(out_data->data);
         free(out_data);
         out_data = NULL;
         goto cleanup;
     }
     (*send_pa)->magic = KV5M_PA_DATA;
     switch ((int)padata->pa_type) {
     case KRB5_PADATA_PK_AS_REQ:
         (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP;
         break;
     case KRB5_PADATA_PK_AS_REQ_OLD:
     case KRB5_PADATA_PK_AS_REP_OLD:
         (*send_pa)->pa_type = KRB5_PADATA_PK_AS_REP_OLD;
         break;
     }
     (*send_pa)->length = out_data->length;
     (*send_pa)->contents = (krb5_octet *) out_data->data;
 
 cleanup:
     pkinit_fini_kdc_req_context(context, reqctx);
     free(scratch.data);
     free(out_data);
     if (encoded_dhkey_info != NULL)
         krb5_free_data(context, encoded_dhkey_info);
     if (encoded_key_pack != NULL)
         krb5_free_data(context, encoded_key_pack);
     free(dh_pubkey);
     free(server_key);
 
     switch ((int)padata->pa_type) {
     case KRB5_PADATA_PK_AS_REQ:
         free_krb5_pa_pk_as_req(&reqp);
         free_krb5_pa_pk_as_rep(&rep);
         free_krb5_reply_key_pack(&key_pack);
         break;
     case KRB5_PADATA_PK_AS_REP_OLD:
     case KRB5_PADATA_PK_AS_REQ_OLD:
         free_krb5_pa_pk_as_req_draft9(&reqp9);
         free_krb5_pa_pk_as_rep_draft9(&rep9);
         if (!fixed_keypack)
             free_krb5_reply_key_pack_draft9(&key_pack9);
         else
             free_krb5_reply_key_pack(&key_pack);
         break;
     }
 
     if (retval)
         pkiDebug(""pkinit_verify_padata failure"");
 
     return retval;
 }","[351, 352, 349, 350]","The pkinit_server_return_padata function in plugins/preauth/pkinit/pkinit_srv.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 attempts to find an agility KDF identifier in inappropriate circumstances, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted Draft 9 request."
199903," xfs_attr_leaf_addname(xfs_da_args_t *args)
 {
 	xfs_inode_t *dp;
 	struct xfs_buf *bp;
 	int retval, error, committed, forkoff;
 
 	trace_xfs_attr_leaf_addname(args);
 
 	 
 	dp = args->dp;
 	args->blkno = 0;
 	error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);
 	if (error)
 		return error;
 
 	 
 	retval = xfs_attr3_leaf_lookup_int(bp, args);
 	if ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {
 		xfs_trans_brelse(args->trans, bp);
 		return retval;
 	} else if (retval == EEXIST) {
 		if (args->flags & ATTR_CREATE) {	 
 			xfs_trans_brelse(args->trans, bp);
 			return retval;
 		}
  
  		trace_xfs_attr_leaf_replace(args);
  
 		 
  		args->op_flags |= XFS_DA_OP_RENAME;	 
  		args->blkno2 = args->blkno;		 
  		args->index2 = args->index;
  		args->rmtblkno2 = args->rmtblkno;
  		args->rmtblkcnt2 = args->rmtblkcnt;
 		args->rmtvaluelen2 = args->rmtvaluelen;
 
 		 
 		args->rmtblkno = 0;
 		args->rmtblkcnt = 0;
 		args->rmtvaluelen = 0;
  	}
  
  	 
 	retval = xfs_attr3_leaf_add(bp, args);
 	if (retval == ENOSPC) {
 		 
 		xfs_bmap_init(args->flist, args->firstblock);
 		error = xfs_attr3_leaf_to_node(args);
 		if (!error) {
 			error = xfs_bmap_finish(&args->trans, args->flist,
 						&committed);
 		}
 		if (error) {
 			ASSERT(committed);
 			args->trans = NULL;
 			xfs_bmap_cancel(args->flist);
 			return(error);
 		}
 
 		 
 		if (committed)
 			xfs_trans_ijoin(args->trans, dp, 0);
 
 		 
 		error = xfs_trans_roll(&args->trans, dp);
 		if (error)
 			return (error);
 
 		 
 		error = xfs_attr_node_addname(args);
 		return(error);
 	}
 
 	 
 	error = xfs_trans_roll(&args->trans, dp);
 	if (error)
 		return (error);
 
 	 
 	if (args->rmtblkno > 0) {
 		error = xfs_attr_rmtval_set(args);
 		if (error)
 			return(error);
 	}
 
 	 
 	if (args->op_flags & XFS_DA_OP_RENAME) {
 		 
 		error = xfs_attr3_leaf_flipflags(args);
 		if (error)
 			return(error);
 
 		 
 		args->index = args->index2;
  		args->blkno = args->blkno2;
  		args->rmtblkno = args->rmtblkno2;
  		args->rmtblkcnt = args->rmtblkcnt2;
 		args->rmtvaluelen = args->rmtvaluelen2;
  		if (args->rmtblkno) {
  			error = xfs_attr_rmtval_remove(args);
  			if (error)
 				return(error);
 		}
 
 		 
 		error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,
 					   -1, &bp);
 		if (error)
 			return error;
 
 		xfs_attr3_leaf_remove(bp, args);
 
 		 
 		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
 			xfs_bmap_init(args->flist, args->firstblock);
 			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
 			 
 			if (!error) {
 				error = xfs_bmap_finish(&args->trans,
 							args->flist,
 							&committed);
 			}
 			if (error) {
 				ASSERT(committed);
 				args->trans = NULL;
 				xfs_bmap_cancel(args->flist);
 				return(error);
 			}
 
 			 
 			if (committed)
 				xfs_trans_ijoin(args->trans, dp, 0);
 		}
 
 		 
 		error = xfs_trans_roll(&args->trans, dp);
 
 	} else if (args->rmtblkno > 0) {
 		 
 		error = xfs_attr3_leaf_clearflag(args);
 	}
 	return error;
 }","[29, 35, 36, 37, 38, 39, 40, 98]","The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access."
198058,"  validate_body_helper (DBusTypeReader       *reader,
                        int                   byte_order,
                        dbus_bool_t           walk_reader_to_end,
                       int                   total_depth,
                        const unsigned char  *p,
                        const unsigned char  *end,
                        const unsigned char **new_p)
  {
    int current_type;
  
    
   if (total_depth > (DBUS_MAXIMUM_TYPE_RECURSION_DEPTH * 2))
     {
       return DBUS_INVALID_NESTED_TOO_DEEPLY;
     }
 
    while ((current_type = _dbus_type_reader_get_current_type (reader)) != DBUS_TYPE_INVALID)
      {
        const unsigned char *a;
         case DBUS_TYPE_BYTE:
           ++p;
           break;
 
         case DBUS_TYPE_BOOLEAN:
         case DBUS_TYPE_INT16:
         case DBUS_TYPE_UINT16:
         case DBUS_TYPE_INT32:
         case DBUS_TYPE_UINT32:
         case DBUS_TYPE_UNIX_FD:
         case DBUS_TYPE_INT64:
         case DBUS_TYPE_UINT64:
         case DBUS_TYPE_DOUBLE:
           alignment = _dbus_type_get_alignment (current_type);
           a = _DBUS_ALIGN_ADDRESS (p, alignment);
           if (a >= end)
             return DBUS_INVALID_NOT_ENOUGH_DATA;
           while (p != a)
             {
               if (*p != '\0')
                 return DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
               ++p;
             }
           
           if (current_type == DBUS_TYPE_BOOLEAN)
             {
               dbus_uint32_t v = _dbus_unpack_uint32 (byte_order,
                                                      p);
               if (!(v == 0 || v == 1))
                 return DBUS_INVALID_BOOLEAN_NOT_ZERO_OR_ONE;
             }
           
           p += alignment;
           break;
 
         case DBUS_TYPE_ARRAY:
         case DBUS_TYPE_STRING:
         case DBUS_TYPE_OBJECT_PATH:
           {
             dbus_uint32_t claimed_len;
 
             a = _DBUS_ALIGN_ADDRESS (p, 4);
             if (a + 4 > end)
               return DBUS_INVALID_NOT_ENOUGH_DATA;
             while (p != a)
               {
                 if (*p != '\0')
                   return DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
                 ++p;
               }
 
             claimed_len = _dbus_unpack_uint32 (byte_order, p);
             p += 4;
 
              
             _dbus_assert (p <= end);
 
             if (current_type == DBUS_TYPE_ARRAY)
               {
                 int array_elem_type = _dbus_type_reader_get_element_type (reader);
 
                 if (!_dbus_type_is_valid (array_elem_type))
                   {
                     return DBUS_INVALID_UNKNOWN_TYPECODE;
                   }
 
                 alignment = _dbus_type_get_alignment (array_elem_type);
 
                 a = _DBUS_ALIGN_ADDRESS (p, alignment);
 
                  
                 if (a > end)
                   return DBUS_INVALID_NOT_ENOUGH_DATA;
 
                 while (p != a)
                   {
                     if (*p != '\0')
                       return DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
                     ++p;
                   }
               }
 
             if (claimed_len > (unsigned long) (end - p))
               return DBUS_INVALID_LENGTH_OUT_OF_BOUNDS;
 
             if (current_type == DBUS_TYPE_OBJECT_PATH)
               {
                 DBusString str;
                 _dbus_string_init_const_len (&str, p, claimed_len);
                 if (!_dbus_validate_path (&str, 0,
                                           _dbus_string_get_length (&str)))
                   return DBUS_INVALID_BAD_PATH;
 
                 p += claimed_len;
               }
             else if (current_type == DBUS_TYPE_STRING)
               {
                 DBusString str;
                 _dbus_string_init_const_len (&str, p, claimed_len);
                 if (!_dbus_string_validate_utf8 (&str, 0,
                                                  _dbus_string_get_length (&str)))
                   return DBUS_INVALID_BAD_UTF8_IN_STRING;
 
                 p += claimed_len;
               }
             else if (current_type == DBUS_TYPE_ARRAY && claimed_len > 0)
               {
                 DBusTypeReader sub;
                 DBusValidity validity;
                 const unsigned char *array_end;
                 int array_elem_type;
 
                 if (claimed_len > DBUS_MAXIMUM_ARRAY_LENGTH)
                   return DBUS_INVALID_ARRAY_LENGTH_EXCEEDS_MAXIMUM;
                 
                  
                 _dbus_type_reader_recurse (reader, &sub);
 
                 array_end = p + claimed_len;
 
                 array_elem_type = _dbus_type_reader_get_element_type (reader);
 
                   
                 if (dbus_type_is_fixed (array_elem_type))
                   {
                      
                     if (array_elem_type == DBUS_TYPE_BOOLEAN)
                       {
                         dbus_uint32_t v;
                         alignment = _dbus_type_get_alignment (array_elem_type);
 
                         while (p < array_end)
                           {
                             v = _dbus_unpack_uint32 (byte_order, p);
 
                             if (!(v == 0 || v == 1))
                               return DBUS_INVALID_BOOLEAN_NOT_ZERO_OR_ONE;
 
                             p += alignment;
                           }
                       }
 
                     else
                       {
                         p = array_end;
                       }
                   }
 
                 else
                   {
                     while (p < array_end)
                       {
                         validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
                         if (validity != DBUS_VALID)
                           return validity;
                       }
                   }
 
                 if (p != array_end)
                   return DBUS_INVALID_ARRAY_LENGTH_INCORRECT;
               }
 
              
                    {
                      while (p < array_end)
                        {
                        validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
                         validity = validate_body_helper (&sub, byte_order, FALSE,
                                                          total_depth + 1,
                                                          p, end, &p);
                          if (validity != DBUS_VALID)
                            return validity;
                        }
           }
           break;
 
         case DBUS_TYPE_SIGNATURE:
           {
             dbus_uint32_t claimed_len;
             DBusString str;
             DBusValidity validity;
 
             claimed_len = *p;
             ++p;
 
              
             if (claimed_len + 1 > (unsigned long) (end - p))
               return DBUS_INVALID_SIGNATURE_LENGTH_OUT_OF_BOUNDS;
 
             _dbus_string_init_const_len (&str, p, claimed_len);
             validity =
               _dbus_validate_signature_with_reason (&str, 0,
                                                     _dbus_string_get_length (&str));
 
             if (validity != DBUS_VALID)
               return validity;
 
             p += claimed_len;
 
             _dbus_assert (p < end);
             if (*p != DBUS_TYPE_INVALID)
               return DBUS_INVALID_SIGNATURE_MISSING_NUL;
 
             ++p;
 
             _dbus_verbose (""p = %p end = %p claimed_len %u\n"", p, end, claimed_len);
           }
           break;
 
         case DBUS_TYPE_VARIANT:
           {
              
 
              
             dbus_uint32_t claimed_len;
             DBusString sig;
             DBusTypeReader sub;
             DBusValidity validity;
             int contained_alignment;
             int contained_type;
             DBusValidity reason;
 
             claimed_len = *p;
             ++p;
 
              
             if (claimed_len + 1 > (unsigned long) (end - p))
               return DBUS_INVALID_VARIANT_SIGNATURE_LENGTH_OUT_OF_BOUNDS;
 
             _dbus_string_init_const_len (&sig, p, claimed_len);
             reason = _dbus_validate_signature_with_reason (&sig, 0,
                                            _dbus_string_get_length (&sig));
             if (!(reason == DBUS_VALID))
               {
                 if (reason == DBUS_VALIDITY_UNKNOWN_OOM_ERROR)
                   return reason;
                 else 
                   return DBUS_INVALID_VARIANT_SIGNATURE_BAD;
               }
 
             p += claimed_len;
             
             if (*p != DBUS_TYPE_INVALID)
               return DBUS_INVALID_VARIANT_SIGNATURE_MISSING_NUL;
             ++p;
 
             contained_type = _dbus_first_type_in_signature (&sig, 0);
             if (contained_type == DBUS_TYPE_INVALID)
               return DBUS_INVALID_VARIANT_SIGNATURE_EMPTY;
             
             contained_alignment = _dbus_type_get_alignment (contained_type);
             
             a = _DBUS_ALIGN_ADDRESS (p, contained_alignment);
             if (a > end)
               return DBUS_INVALID_NOT_ENOUGH_DATA;
             while (p != a)
               {
                 if (*p != '\0')
                   return DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
                 ++p;
               }
 
             _dbus_type_reader_init_types_only (&sub, &sig, 0);
 
             _dbus_assert (_dbus_type_reader_get_current_type (&sub) != DBUS_TYPE_INVALID);
 
             validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
             if (validity != DBUS_VALID)
               return validity;
 
             if (_dbus_type_reader_next (&sub))
               return DBUS_INVALID_VARIANT_SIGNATURE_SPECIFIES_MULTIPLE_VALUES;
 
             _dbus_assert (_dbus_type_reader_get_current_type (&sub) == DBUS_TYPE_INVALID);
           }
           break;
 
         case DBUS_TYPE_DICT_ENTRY:
         case DBUS_TYPE_STRUCT:
  
              _dbus_assert (_dbus_type_reader_get_current_type (&sub) != DBUS_TYPE_INVALID);
  
            validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);
             validity = validate_body_helper (&sub, byte_order, FALSE,
                                              total_depth + 1,
                                              p, end, &p);
              if (validity != DBUS_VALID)
                return validity;
  
                 if (*p != '\0')
                   return DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
                 ++p;
               }
 
             _dbus_type_reader_recurse (reader, &sub);
 
             validity = validate_body_helper (&sub, byte_order, TRUE, p, end, &p);
             if (validity != DBUS_VALID)
               return validity;
           }
           break;
 
         default:
           _dbus_assert_not_reached (""invalid typecode in supposedly-validated signature"");
           break;
         }","[4, 11, 12, 13, 14, 15, 16, 187, 188, 189, 303, 304, 305, 186, 302]",Stack consumption vulnerability in D-Bus (aka DBus) before 1.4.1 allows local users to cause a denial of service (daemon crash) via a message containing many nested variants.
206887," IDNSpoofChecker::IDNSpoofChecker() {
   UErrorCode status = U_ZERO_ERROR;
   checker_ = uspoof_open(&status);
   if (U_FAILURE(status)) {
     checker_ = nullptr;
     return;
   }
 
 
   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
   SetAllowedUnicodeSet(&status);
 
   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;
   uspoof_setChecks(checker_, checks, &status);
 
   deviation_characters_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u00df\\u03c2\\u200c\\u200d]""), status);
   deviation_characters_.freeze();
 
   non_ascii_latin_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Latin:] - [a-zA-Z]]""), status);
   non_ascii_latin_letters_.freeze();
 
   kana_letters_exceptions_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb-\\u30fe]""),
       status);
   kana_letters_exceptions_.freeze();
   combining_diacritics_exceptions_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[\\u0300-\\u0339]""), status);
   combining_diacritics_exceptions_.freeze();
 
   cyrillic_letters_latin_alike_ = icu::UnicodeSet(
       icu::UnicodeString::fromUTF8(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);
   cyrillic_letters_latin_alike_.freeze();
 
   cyrillic_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
   cyrillic_letters_.freeze();
 
   DCHECK(U_SUCCESS(status));
   lgc_letters_n_ascii_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[[:Latin:][:Greek:][:Cyrillic:][0-9\\u002e_""
                             ""\\u002d][\\u0300-\\u0339]]""),
       status);
   lgc_letters_n_ascii_.freeze();
 
   UParseError parse_error;
   diacritic_remover_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""DropAcc""),
       icu::UnicodeString::fromUTF8(""::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;""
                                    "" ł > l; ø > o; đ > d;""),
        UTRANS_FORWARD, parse_error, status));
  
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(
        UNICODE_STRING_SIMPLE(""ExtraConf""),
      icu::UnicodeString::fromUTF8(
          ""ӏ > l; [кĸκ] > k; п > n; [ƅь] > b; в > b; м > m; н > h; ""
          ""т > t; [шщ] > w; ട > s;""),
       icu::UnicodeString::fromUTF8(""[þϼҏ] > p; [ħнћңҥӈԧԩ] > h;""
                                    ""[ĸκкқҝҟҡӄԟ] > k; [ŧтҭ] > t;""
                                    ""[ƅьҍв] > b;  [ωшщ] > w; [мӎ] > m;""
                                    ""п > n; ћ > h; ґ > r; ғ > f; ҫ > c;""
                                    ""ұ > y; [χҳӽӿ] > x; [ҽҿ] > e; ӏ > l;""
                                    ""ԃ  > d; ԍ > g; ട > s""),
        UTRANS_FORWARD, parse_error, status));
    DCHECK(U_SUCCESS(status))
        << ""Spoofchecker initalization failed due to an error: ""
       << u_errorName(status);
 }","[55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 78, 79, 80, 81, 82, 83, 75, 76, 77]",Incorrect handling of confusable characters in Omnibox in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted domain name.
201266," mark_context_stack(mrb_state *mrb, struct mrb_context *c)
  {
    size_t i;
    size_t e;
   mrb_value nil;
  
    if (c->stack == NULL) return;
    e = c->stack - c->stbase;
   if (c->ci) e += c->ci->nregs;
   if (c->stbase + e > c->stend) e = c->stend - c->stbase;
   for (i=0; i<e; i++) {
      mrb_value v = c->stbase[i];
  
      if (!mrb_immediate_p(v)) {
      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {
        c->stbase[i] = mrb_nil_value();
      }
      else {
        mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
       mrb_gc_mark(mrb, mrb_basic_ptr(v));
      }
    }
   e = c->stend - c->stbase;
   nil = mrb_nil_value();
   for (; i<e; i++) {
     c->stbase[i] = nil;
   }
  }","[5, 21, 24, 25, 26, 27, 28, 15, 16, 17, 18, 19, 20]",The mark_context_stack function in gc.c in mruby through 1.2.0 allows attackers to cause a denial of service (heap-based use-after-free and application crash) or possibly have unspecified other impact via a crafted .rb file.
204966," xmlParseCharData(xmlParserCtxtPtr ctxt, int cdata) {
     const xmlChar *in;
     int nbchar = 0;
     int line = ctxt->input->line;
     int col = ctxt->input->col;
     int ccol;
 
     SHRINK;
     GROW;
      
     if (!cdata) {
 	in = ctxt->input->cur;
 	do {
 get_more_space:
 	    while (*in == 0x20) { in++; ctxt->input->col++; }
 	    if (*in == 0xA) {
 		do {
 		    ctxt->input->line++; ctxt->input->col = 1;
 		    in++;
 		} while (*in == 0xA);
 		goto get_more_space;
 	    }
 	    if (*in == '<') {
 		nbchar = in - ctxt->input->cur;
 		if (nbchar > 0) {
 		    const xmlChar *tmp = ctxt->input->cur;
 		    ctxt->input->cur = in;
 
 		    if ((ctxt->sax != NULL) &&
 		        (ctxt->sax->ignorableWhitespace !=
 		         ctxt->sax->characters)) {
 			if (areBlanks(ctxt, tmp, nbchar, 1)) {
 			    if (ctxt->sax->ignorableWhitespace != NULL)
 				ctxt->sax->ignorableWhitespace(ctxt->userData,
 						       tmp, nbchar);
 			} else {
 			    if (ctxt->sax->characters != NULL)
 				ctxt->sax->characters(ctxt->userData,
 						      tmp, nbchar);
 			    if (*ctxt->space == -1)
 			        *ctxt->space = -2;
 			}
 		    } else if ((ctxt->sax != NULL) &&
 		               (ctxt->sax->characters != NULL)) {
 			ctxt->sax->characters(ctxt->userData,
 					      tmp, nbchar);
 		    }
 		}
 		return;
 	    }
 
 get_more:
             ccol = ctxt->input->col;
 	    while (test_char_data[*in]) {
 		in++;
 		ccol++;
 	    }
 	    ctxt->input->col = ccol;
 	    if (*in == 0xA) {
 		do {
 		    ctxt->input->line++; ctxt->input->col = 1;
 		    in++;
 		} while (*in == 0xA);
 		goto get_more;
 	    }
 	    if (*in == ']') {
 		if ((in[1] == ']') && (in[2] == '>')) {
 		    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 		    ctxt->input->cur = in;
 		    return;
 		}
 		in++;
 		ctxt->input->col++;
 		goto get_more;
 	    }
 	    nbchar = in - ctxt->input->cur;
 	    if (nbchar > 0) {
 		if ((ctxt->sax != NULL) &&
 		    (ctxt->sax->ignorableWhitespace !=
 		     ctxt->sax->characters) &&
 		    (IS_BLANK_CH(*ctxt->input->cur))) {
 		    const xmlChar *tmp = ctxt->input->cur;
 		    ctxt->input->cur = in;
 
 		    if (areBlanks(ctxt, tmp, nbchar, 0)) {
 		        if (ctxt->sax->ignorableWhitespace != NULL)
 			    ctxt->sax->ignorableWhitespace(ctxt->userData,
 							   tmp, nbchar);
 		    } else {
 		        if (ctxt->sax->characters != NULL)
 			    ctxt->sax->characters(ctxt->userData,
 						  tmp, nbchar);
 			if (*ctxt->space == -1)
 			    *ctxt->space = -2;
 		    }
                     line = ctxt->input->line;
                     col = ctxt->input->col;
 		} else if (ctxt->sax != NULL) {
 		    if (ctxt->sax->characters != NULL)
 			ctxt->sax->characters(ctxt->userData,
 					      ctxt->input->cur, nbchar);
                     line = ctxt->input->line;
                     col = ctxt->input->col;
 		}
                  
                 if (ctxt->instate != XML_PARSER_CONTENT)
                     return;
 	    }
 	    ctxt->input->cur = in;
 	    if (*in == 0xD) {
 		in++;
 		if (*in == 0xA) {
 		    ctxt->input->cur = in;
 		    in++;
 		    ctxt->input->line++; ctxt->input->col = 1;
 		    continue;  
 		}
 		in--;
 	    }
 	    if (*in == '<') {
 		return;
 	    }
 	    if (*in == '&') {
 		return;
  	    }
  	    SHRINK;
  	    GROW;
             if (ctxt->instate == XML_PARSER_EOF)
 		return;
  	    in = ctxt->input->cur;
  	} while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09));
  	nbchar = 0;
     }
     ctxt->input->line = line;
     ctxt->input->col = col;
     xmlParseCharDataComplex(ctxt, cdata);
 }","[128, 129]","parser.c in libxml2 before 2.9.0, as used in Google Chrome before 28.0.1500.71 and other products, allows remote attackers to cause a denial of service (out-of-bounds read) via a document that ends abruptly, related to the lack of certain checks for the XML_PARSER_EOF state."
198572," open_patch_file (char const *filename)
 {
     file_offset file_pos = 0;
     file_offset pos;
     struct stat st;
 
     if (!filename || !*filename || strEQ (filename, ""-""))
       pfp = stdin;
     else
       {
 	pfp = fopen (filename, binary_transput ? ""rb"" : ""r"");
 	if (!pfp)
 	  pfatal (""Can't open patch file %s"", quotearg (filename));
       }
 #if HAVE_SETMODE_DOS
     if (binary_transput)
       {
 	if (isatty (fileno (pfp)))
 	  fatal (""cannot read binary data from tty on this platform"");
 	setmode (fileno (pfp), O_BINARY);
       }
 #endif
     if (fstat (fileno (pfp), &st) != 0)
       pfatal (""fstat"");
     if (S_ISREG (st.st_mode) && (pos = file_tell (pfp)) != -1)
       file_pos = pos;
     else
       {
 	size_t charsread;
 	int fd = make_tempfile (&TMPPATNAME, 'p', NULL, O_RDWR | O_BINARY, 0);
 	FILE *read_pfp = pfp;
 	TMPPATNAME_needs_removal = true;
 	pfp = fdopen (fd, ""w+b"");
 	if (! pfp)
 	  pfatal (""Can't open stream for file %s"", quotearg (TMPPATNAME));
 	for (st.st_size = 0;
 	     (charsread = fread (buf, 1, bufsize, read_pfp)) != 0;
 	     st.st_size += charsread)
 	  if (fwrite (buf, 1, charsread, pfp) != charsread)
 	    write_fatal ();
 	if (ferror (read_pfp) || fclose (read_pfp) != 0)
 	  read_fatal ();
 	if (fflush (pfp) != 0
 	    || file_seek (pfp, (file_offset) 0, SEEK_SET) != 0)
 	  write_fatal ();
       }
     p_filesize = st.st_size;
      if (p_filesize != (file_offset) p_filesize)
        fatal (""patch file is too long"");
      next_intuit_at (file_pos, 1);
    set_hunkmax();
  }",[51],GNU patch 2.7.2 and earlier allows remote attackers to cause a denial of service (memory consumption and segmentation fault) via a crafted diff file.
8712,"static int handle_input_expect_headers(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end,
const char **err_desc)
{
struct st_h2o_http3_server_conn_t *conn = get_conn(stream);
h2o_http3_read_frame_t frame;
int header_exists_map = 0, ret;
uint8_t header_ack[H2O_HPACK_ENCODE_INT_MAX_LENGTH];
size_t header_ack_len;


if ((ret = h2o_http3_read_frame(&frame, 0, H2O_HTTP3_STREAM_TYPE_REQUEST, src, src_end, err_desc)) != 0)
return ret;
if (frame.type != H2O_HTTP3_FRAME_TYPE_HEADERS) {
switch (frame.type) {
case H2O_HTTP3_FRAME_TYPE_DATA:
return H2O_HTTP3_ERROR_FRAME_UNEXPECTED;
default:
break;
}
return 0;
}
stream->recvbuf.handle_input = handle_input_expect_data;


if ((ret = h2o_qpack_parse_request(&stream->req.pool, get_conn(stream)->h3.qpack.dec, stream->quic->stream_id,
&stream->req.input.method, &stream->req.input.scheme, &stream->req.input.authority,
&stream->req.input.path, &stream->req.headers, &header_exists_map,
&stream->req.content_length, NULL                         , header_ack, &header_ack_len,
frame.payload, frame.length, err_desc)) != 0 &&
ret != H2O_HTTP2_ERROR_INVALID_HEADER_CHAR)
return ret;
if (header_ack_len != 0)
h2o_http3_send_qpack_header_ack(&conn->h3, header_ack, header_ack_len);

if (stream->req.input.scheme == NULL)
stream->req.input.scheme = &H2O_URL_SCHEME_HTTPS;

h2o_probe_log_request(&stream->req, stream->quic->stream_id);

int is_connect = h2o_memis(stream->req.input.method.base, stream->req.input.method.len, H2O_STRLIT(""CONNECT""));


int expected_map = H2O_HPACK_PARSE_HEADERS_METHOD_EXISTS | H2O_HPACK_PARSE_HEADERS_AUTHORITY_EXISTS;
if (!is_connect)
expected_map |= H2O_HPACK_PARSE_HEADERS_SCHEME_EXISTS | H2O_HPACK_PARSE_HEADERS_PATH_EXISTS;
if (header_exists_map != expected_map) {
shutdown_stream(stream, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, 0);
return 0;
}


if (ret == H2O_HTTP2_ERROR_INVALID_HEADER_CHAR)
return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"", *err_desc, err_desc);


if (stream->req.content_length != SIZE_MAX && stream->req.content_length > conn->super.ctx->globalconf->max_request_entity_size)
return handle_input_expect_headers_send_http_error(stream, h2o_send_error_413, ""Request Entity Too Large"",
""request entity is too large"", err_desc);


assert(!h2o_linklist_is_linked(&stream->scheduler.link));
if (!stream->received_priority_update) {
ssize_t index;
if ((index = h2o_find_header(&stream->req.headers, H2O_TOKEN_PRIORITY, -1)) != -1) {
h2o_iovec_t *value = &stream->req.headers.entries[index].value;
h2o_absprio_parse_priority(value->base, value->len, &stream->scheduler.priority);
}
}


if (is_connect) {
if (stream->req.content_length != SIZE_MAX)
return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"",
""CONNECT request cannot have request body"", err_desc);
set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS, 0);
stream->tunnel = h2o_mem_alloc(sizeof(*stream->tunnel));
stream->tunnel->tunnel = NULL;
stream->tunnel->stream = stream;
stream->tunnel->up.is_inflight = 0;
stream->tunnel->up.delayed_write = (h2o_timer_t){.cb = tunnel_write_delayed};
h2o_process_request(&stream->req);
return 0;
}


set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK, 0);

return 0;
}","[2, 4]","h2o is an open source http server. In code prior to the `8c0eca3` commit h2o may attempt to access uninitialized memory. When receiving QUIC frames in certain order, HTTP/3 server-side implementation of h2o can be misguided to treat uninitialized memory as HTTP/3 frames that have been received. When h2o is used as a reverse proxy, an attacker can abuse this vulnerability to send internal state of h2o to backend servers controlled by the attacker or third party. Also, if there is an HTTP endpoint that reflects the traffic sent from the client, an attacker can use that reflector to obtain internal state of h2o. This internal state includes traffic of other connections in unencrypted form and TLS session tickets. This vulnerability exists in h2o server with HTTP/3 support, between commit 93af138 and d1f0f65. None of the released versions of h2o are affected by this vulnerability. There are no known workarounds. Users of unreleased versions of h2o using HTTP/3 are advised to upgrade immediately."
201407," ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
 	ut64 addr = 0LL;
 	struct symbol_t *symbols;
 	int i;
 
 	if (!(symbols = MACH0_(get_symbols) (bin))) {
 		return 0;
 	}
 	for (i = 0; !symbols[i].last; i++) {
 		if (!strcmp (symbols[i].name, ""_main"")) {
 			addr = symbols[i].addr;
 			break;
 		}
 	}
 	free (symbols);
 
 	if (!addr && bin->main_cmd.cmd == LC_MAIN) {
 		addr = bin->entry + bin->baddr;
 	}
 
 	if (!addr) {
  		ut8 b[128];
  		ut64 entry = addr_to_offset(bin, bin->entry);
		if (entry > bin->size || entry + sizeof (b) > bin->size)
 		if (entry > bin->size || entry + sizeof (b) > bin->size) {
  			return 0;
 		}
  		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
  		if (i < 1) {
  			return 0;
 		}
 		for (i = 0; i < 64; i++) {
 			if (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {
 				int delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);
 				return bin->entry + i + 5 + delta;
 
 			}
 		}
 	}
 	return addr;
 }","[25, 27, 24]",The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.
203041," static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
 static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)
  {
 	if (sta_id >= IWLAGN_STATION_COUNT) {
 		IWL_ERR(priv, ""invalid sta_id %u"", sta_id);
 		return -EINVAL;
 	}
  	if (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))
  		IWL_ERR(priv, ""ACTIVATE a non DRIVER active station id %u ""
  			""addr %pM\n"",
 			sta_id, priv->stations[sta_id].sta.sta.addr);
 
 	if (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {
 		IWL_DEBUG_ASSOC(priv,
 				""STA id %u addr %pM already present in uCode ""
 				""(according to driver)\n"",
 				sta_id, priv->stations[sta_id].sta.sta.addr);
 	} else {
 		priv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;
  		IWL_DEBUG_ASSOC(priv, ""Added STA id %u addr %pM to uCode\n"",
  				sta_id, priv->stations[sta_id].sta.sta.addr);
  	}
 	return 0;
  }","[2, 4, 5, 6, 7, 23]","In the Linux kernel before 3.4, a buffer overflow occurs in drivers/net/wireless/iwlwifi/iwl-agn-sta.c, which will cause at least memory corruption."
202854," int ipmi_si_port_setup(struct si_sm_io *io)
 {
 	unsigned int addr = io->addr_data;
 	int          idx;
 
  	if (!addr)
  		return -ENODEV;
  
	io->io_cleanup = port_cleanup;
  	 
 	switch (io->regsize) {
 	case 1:
 		io->inputb = port_inb;
 		io->outputb = port_outb;
 		break;
 	case 2:
 		io->inputb = port_inw;
 		io->outputb = port_outw;
 		break;
 	case 4:
 		io->inputb = port_inl;
 		io->outputb = port_outl;
 		break;
 	default:
 		dev_warn(io->dev, ""Invalid register size: %d\n"",
 			 io->regsize);
 		return -EINVAL;
 	}
 
 	 
 	for (idx = 0; idx < io->io_size; idx++) {
 		if (request_region(addr + idx * io->regspacing,
 				   io->regsize, DEVICE_NAME) == NULL) {
 			 
 			while (idx--)
 				release_region(addr + idx * io->regspacing,
 					       io->regsize);
  			return -EIO;
  		}
  	}
 
 	io->io_cleanup = port_cleanup;
 
  	return 0;
  }","[41, 42, 43, 9]","An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c."
6143,"static void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
u32 info_length, pos, desc_len, evt_type, nb_es,i;
u32 nb_sections;
u32 data_size;
u32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;
unsigned char *data;
GF_M2TS_Section *section;
GF_Err e = GF_OK;


if (!(status&GF_M2TS_TABLE_END)) return;

nb_es = 0;


if ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {
if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
return;
}

if (pmt->sec->demux_restarted) {
pmt->sec->demux_restarted = 0;
return;
}
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PMT Found or updated\n""));

nb_sections = gf_list_count(sections);
if (nb_sections > 1) {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PMT on multiple sections not supported\n""));
}

section = (GF_M2TS_Section *)gf_list_get(sections, 0);
data = section->data;
data_size = section->data_size;

pmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];

info_length = ((data[2]&0xf)<<8) | data[3];
if (info_length != 0) {

u8 tag, len;
u32 first_loop_len = 0;
tag = data[4];
len = data[5];
while (info_length > first_loop_len) {
if (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {
u32 size;
GF_BitStream *iod_bs;
iod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);
if (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
e = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);
gf_bs_del(iod_bs );
if (e==GF_OK) {

if (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;

if (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {
gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);
pmt->program->pmt_iod = NULL;
}
}
} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {
GF_BitStream *metadatapd_bs;
GF_M2TS_MetadataPointerDescriptor *metapd;
metadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);
metapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);
gf_bs_del(metadatapd_bs);
if (metapd->application_format_identifier == GF_M2TS_META_ID3 &&
metapd->format_identifier == GF_M2TS_META_ID3 &&
metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {

pmt->program->metadata_pointer_descriptor = metapd;
} else {

gf_m2ts_metadata_pointer_descriptor_del(metapd);
}
} else {
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\n"", tag));
}
first_loop_len += 2 + len;
}
}
if (data_size <= 4 + info_length) return;
data += 4 + info_length;
data_size -= 4 + info_length;
pos = 0;


for(i=0; i<gf_list_count(ts->programs); i++) {
GF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);
if(prog->pmt_pid == pmt->pid) {
break;
}
}

nb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;
while (pos<data_size) {
GF_M2TS_PES *pes = NULL;
GF_M2TS_SECTION_ES *ses = NULL;
GF_M2TS_ES *es = NULL;
Bool inherit_pcr = 0;
u32 pid, stream_type, reg_desc_format;

if (pos + 5 > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT! size %d but position %d and need at least 5 bytes to declare es\n"", data_size, pos));
break;
}

stream_type = data[0];
pid = ((data[1] & 0x1f) << 8) | data[2];
desc_len = ((data[3] & 0xf) << 8) | data[4];

GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""stream_type :%d \n"",stream_type));
switch (stream_type) {


case GF_M2TS_VIDEO_MPEG1:
case GF_M2TS_VIDEO_MPEG2:
case GF_M2TS_VIDEO_DCII:
case GF_M2TS_VIDEO_MPEG4:
case GF_M2TS_SYSTEMS_MPEG4_PES:
case GF_M2TS_VIDEO_H264:
case GF_M2TS_VIDEO_SVC:
case GF_M2TS_VIDEO_MVCD:
case GF_M2TS_VIDEO_HEVC:
case GF_M2TS_VIDEO_HEVC_MCTS:
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
case GF_M2TS_VIDEO_SHVC:
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
case GF_M2TS_VIDEO_MHVC:
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
inherit_pcr = 1;
case GF_M2TS_AUDIO_MPEG1:
case GF_M2TS_AUDIO_MPEG2:
case GF_M2TS_AUDIO_AAC:
case GF_M2TS_AUDIO_LATM_AAC:
case GF_M2TS_AUDIO_AC3:
case GF_M2TS_AUDIO_DTS:
case GF_M2TS_MHAS_MAIN:
case GF_M2TS_MHAS_AUX:
case GF_M2TS_SUBTITLE_DVB:
case GF_M2TS_METADATA_PES:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
if (inherit_pcr)
pes->flags |= GF_M2TS_INHERIT_PCR;
es = (GF_M2TS_ES *)pes;
break;
case GF_M2TS_PRIVATE_DATA:
GF_SAFEALLOC(pes, GF_M2TS_PES);
if (!pes) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
pes->cc = -1;
pes->flags = GF_M2TS_ES_IS_PES;
es = (GF_M2TS_ES *)pes;
break;

case GF_M2TS_SYSTEMS_MPEG4_SECTIONS:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;

if (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {


ses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);

if (!pmt->program->additional_ods) {
pmt->program->additional_ods = gf_list_new();
ts->has_4on2 = 1;
}
}
break;

case GF_M2TS_13818_6_ANNEX_A:
case GF_M2TS_13818_6_ANNEX_B:
case GF_M2TS_13818_6_ANNEX_C:
case GF_M2TS_13818_6_ANNEX_D:
case GF_M2TS_PRIVATE_SECTION:
case GF_M2TS_QUALITY_SEC:
case GF_M2TS_MORE_SEC:
GF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);
if (!ses) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG2TS] Failed to allocate ES for pid %d\n"", pid));
return;
}
es = (GF_M2TS_ES *)ses;
es->flags |= GF_M2TS_ES_IS_SECTION;
es->pid = pid;
es->service_id = pmt->program->number;
if (stream_type == GF_M2TS_PRIVATE_SECTION) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""AIT sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_QUALITY_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Quality metadata sections on pid %d\n"", pid));
} else if (stream_type == GF_M2TS_MORE_SEC) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""MORE sections on pid %d\n"", pid));
} else {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type DSM CC user private sections on pid %d \n"", pid));
}

ses->sec = gf_m2ts_section_filter_new(NULL, 1);

break;

case GF_M2TS_MPE_SECTIONS:
if (! ts->prefix_present) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""stream type MPE found : pid = %d \n"", pid));
#ifdef GPAC_ENABLE_MPE
es = gf_dvb_mpe_section_new();
if (es->flags & GF_M2TS_ES_IS_SECTION) {

((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);
}
#endif
break;
}

default:
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );

break;
}

if (es) {
es->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;
es->program = pmt->program;
es->pid = pid;
es->component_tag = -1;
}

pos += 5;
data += 5;

while (desc_len) {
if (pos + 2 > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT descriptor! size %d but position %d and need at least 2 bytes to parse descritpor\n"", data_size, pos));
break;
}
u8 tag = data[0];
u32 len = data[1];

if (pos + 2 + len > data_size) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PMT descriptor! size %d, desc size %d but position %d\n"", data_size, len, pos));
break;
}

if (es) {
switch (tag) {
case GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:
if (pes && (len>=3) )
pes->lang = GF_4CC(' ', data[2], data[3], data[4]);
break;
case GF_M2TS_MPEG4_SL_DESCRIPTOR:
if (len>=2) {
es->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];
es->flags |= GF_M2TS_ES_IS_SL;
}
break;
case GF_M2TS_REGISTRATION_DESCRIPTOR:
if (len>=4) {
reg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);

switch (reg_desc_format) {
case GF_M2TS_RA_STREAM_AC3:
es->stream_type = GF_M2TS_AUDIO_AC3;
break;
case GF_M2TS_RA_STREAM_VC1:
es->stream_type = GF_M2TS_VIDEO_VC1;
break;
case GF_M2TS_RA_STREAM_GPAC:
if (len==8) {
es->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);
es->flags |= GF_M2TS_GPAC_CODEC_ID;
break;
}
default:
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""Unknown registration descriptor %s\n"", gf_4cc_to_str(reg_desc_format) ));
break;
}
}
break;
case GF_M2TS_DVB_EAC3_DESCRIPTOR:
es->stream_type = GF_M2TS_AUDIO_EC3;
break;
case GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:
if (len>=2) {
u32 id = data[2]<<8 | data[3];
if ((id == 0xB) && ses && !ses->sec) {
ses->sec = gf_m2ts_section_filter_new(NULL, 1);
}
}
break;
case GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:
if (pes && (len>=8)) {
pes->sub.language[0] = data[2];
pes->sub.language[1] = data[3];
pes->sub.language[2] = data[4];
pes->sub.type = data[5];
pes->sub.composition_page_id = (data[6]<<8) | data[7];
pes->sub.ancillary_page_id = (data[8]<<8) | data[9];
}
es->stream_type = GF_M2TS_DVB_SUBTITLE;
break;
case GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:
if (len>=1) {
es->component_tag = data[2];
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""Component Tag: %d on Program %d\n"", es->component_tag, es->program->number));
}
break;
case GF_M2TS_DVB_TELETEXT_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_TELETEXT;
break;
case GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:
es->stream_type = GF_M2TS_DVB_VBI;
break;
case GF_M2TS_HIERARCHY_DESCRIPTOR:
if (pes && (len>=4)) {
u8 hierarchy_embedded_layer_index;
GF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);
gf_bs_read_int(hbs, 16);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 4);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 1);
gf_bs_read_int(hbs, 1);
hierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);
gf_bs_read_int(hbs, 2);
gf_bs_read_int(hbs, 6);
gf_bs_del(hbs);

pes->depends_on_pid = 1+hierarchy_embedded_layer_index;
}
break;
case GF_M2TS_METADATA_DESCRIPTOR:
{
GF_BitStream *metadatad_bs;
GF_M2TS_MetadataDescriptor *metad;
metadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);
metad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);
gf_bs_del(metadatad_bs);
if (metad->application_format_identifier == GF_M2TS_META_ID3 &&
metad->format_identifier == GF_M2TS_META_ID3) {

if (pes) {
pes->metadata_descriptor = metad;
pes->stream_type = GF_M2TS_METADATA_ID3_HLS;
}
} else {

gf_m2ts_metadata_descriptor_del(metad);
}
}
break;

default:
GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] skipping descriptor (0x%x) not supported\n"", tag));
break;
}
}

data += len+2;
pos += len+2;
if (desc_len < len+2) {
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\n"", pid ) );
break;
}
desc_len-=len+2;
}

if (es && !es->stream_type) {
gf_free(es);
es = NULL;
GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\n"", stream_type, pid ) );
}

if (!es) continue;

if (ts->ess[pid]) {

if (status & GF_M2TS_TABLE_FOUND) {
GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\n"", pid, ts->ess[pid]->program->number, es->program->number ) );


gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);

nb_es++;

es = NULL;
}

else {

GF_M2TS_ES *o_es = ts->ess[es->pid];

if ((o_es->stream_type == es->stream_type)
&& ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))
&& (o_es->mpeg4_es_id == es->mpeg4_es_id)
&& ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)
) {
gf_free(es);
es = NULL;
} else {
gf_m2ts_es_del(o_es, ts);
ts->ess[es->pid] = NULL;
}
}
}

if (es) {
ts->ess[es->pid] = es;
gf_list_add(pmt->program->streams, es);
if (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);

nb_es++;

if (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;
else if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;
else if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;
else if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;
}
}


if (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {
for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (es->depends_on_pid) continue;

switch (es->stream_type) {
case GF_M2TS_VIDEO_HEVC_TEMPORAL:
es->depends_on_pid = 1;
break;
case GF_M2TS_VIDEO_SHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_SHVC_TEMPORAL:
es->depends_on_pid = 3;
break;
case GF_M2TS_VIDEO_MHVC:
if (!nb_hevc_temp) es->depends_on_pid = 1;
else es->depends_on_pid = 2;
break;
case GF_M2TS_VIDEO_MHVC_TEMPORAL:
if (!nb_hevc_temp) es->depends_on_pid = 2;
else es->depends_on_pid = 3;
break;
}
}
}

if (nb_es) {
u32 i;


for (i=0; i<gf_list_count(pmt->program->streams); i++) {
GF_M2TS_PES *an_es = NULL;
GF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);
if ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;
if (!es->depends_on_pid) continue;



an_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);
if (an_es) {
es->depends_on_pid = an_es->pid;
} else {
GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\n""));
es->depends_on_pid = 0;
}
}

evt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;
if (ts->on_event) ts->on_event(ts, evt_type, pmt->program);
} else {

if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);
}
}","[40, 48, 49, 50, 51, 52, 53, 54, 56, 58, 59, 60, 63]","An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in BS_ReadByte (called from gf_bs_read_bit) in utils/bitstream.c that can cause a denial of service via a crafted MP4 file."
207606," main(int argc, char **argv)
 {
  FILE *fp = stdout;
 
     const char *file_name = NULL;
     int color_type = 8;  
     int bit_depth = 32;  
    int small = 0;  
    int tRNS = 0;  
     unsigned int colors[5];
     unsigned int filters = PNG_ALL_FILTERS;
     png_fixed_point gamma = 0;  
    chunk_insert *head_insert = NULL;
    chunk_insert **insert_ptr = &head_insert;
 
    memset(colors, 0, sizeof colors);
 
  while (--argc > 0)
 
     {
        char *arg = *++argv;
  
       if (strcmp(arg, ""--small"") == 0)
       {
          small = 1;
          continue;
       }
 
       if (strcmp(arg, ""--tRNS"") == 0)
       {
          tRNS = 1;
          continue;
       }
 
        if (strcmp(arg, ""--sRGB"") == 0)
        {
           gamma = PNG_DEFAULT_sRGB;
  continue;
  }
 
  if (strcmp(arg, ""--linear"") == 0)
  {
          gamma = PNG_FP_1;
  continue;
  }
 
  if (strcmp(arg, ""--1.8"") == 0)
  {
          gamma = PNG_GAMMA_MAC_18;
  continue;
  }
 
  if (strcmp(arg, ""--nofilters"") == 0)
  {
          filters = PNG_FILTER_NONE;
  continue;
  }
 
  if (strncmp(arg, ""--color="", 8) == 0)
  {
           parse_color(arg+8, colors);
  continue;
  }
 
  if (argc >= 3 && strcmp(arg, ""--insert"") == 0)
  {
          png_const_charp what = *++argv;
          png_charp param = *++argv;
          chunk_insert *new_insert;
 
          argc -= 2;
 
          new_insert = find_insert(what, param);
 
  if (new_insert != NULL)
  {
  *insert_ptr = new_insert;
             insert_ptr = &new_insert->next;
  }
 
  continue;
  }
 
  if (arg[0] == '-')
  {
          fprintf(stderr, ""makepng: %s: invalid option\n"", arg);
          exit(1);
  }
 
  if (strcmp(arg, ""palette"") == 0)
  {
          color_type = PNG_COLOR_TYPE_PALETTE;
  continue;
  }
 
  if (strncmp(arg, ""gray"", 4) == 0)
  {
  if (arg[4] == 0)
  {
             color_type = PNG_COLOR_TYPE_GRAY;
  continue;
  }
 
  else if (strcmp(arg+4, ""a"") == 0 ||
             strcmp(arg+4, ""alpha"") == 0 ||
             strcmp(arg+4, ""-alpha"") == 0)
  {
             color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
  continue;
  }
  }
 
  if (strncmp(arg, ""rgb"", 3) == 0)
  {
  if (arg[3] == 0)
  {
             color_type = PNG_COLOR_TYPE_RGB;
  continue;
  }
 
  else if (strcmp(arg+3, ""a"") == 0 ||
             strcmp(arg+3, ""alpha"") == 0 ||
             strcmp(arg+3, ""-alpha"") == 0)
  {
             color_type = PNG_COLOR_TYPE_RGB_ALPHA;
  continue;
  }
  }
 
  if (color_type == 8 && isdigit(arg[0]))
  {
          color_type = atoi(arg);
  if (color_type < 0 || color_type > 6 || color_type == 1 ||
             color_type == 5)
  {
             fprintf(stderr, ""makepng: %s: not a valid color type\n"", arg);
             exit(1);
  }
 
  continue;
  }
 
  if (bit_depth == 32 && isdigit(arg[0]))
  {
          bit_depth = atoi(arg);
  if (bit_depth <= 0 || bit_depth > 16 ||
  (bit_depth & -bit_depth) != bit_depth)
  {
             fprintf(stderr, ""makepng: %s: not a valid bit depth\n"", arg);
             exit(1);
  }
 
  continue;
  }
 
  if (argc == 1)  
  {
          fp = fopen(arg, ""wb"");
  if (fp == NULL)
  {
             fprintf(stderr, ""%s: %s: could not open\n"", arg, strerror(errno));
             exit(1);
  }
 
          file_name = arg;
  continue;
  }
 
       fprintf(stderr, ""makepng: %s: unknown argument\n"", arg);
       exit(1);
  }  
 
  
     if (color_type == 8 || bit_depth == 32)
     {
      fprintf(stderr, ""usage: makepng [--sRGB|--linear|--1.8] ""
       fprintf(stderr, ""usage: makepng [--small] [--sRGB|--linear|--1.8] ""
           ""[--color=...] color-type bit-depth [file-name]\n""
         ""  Make a test PNG file, by default writes to stdout.\n"");
          ""  Make a test PNG file, by default writes to stdout.\n""
          ""  Other options are available, UTSL.\n"");
        exit(1);
     }
  
   
  {
  const unsigned int lim = (color_type == PNG_COLOR_TYPE_PALETTE ? 255U :
  (1U<<bit_depth)-1);
  unsigned int i;
 
  for (i=1; i<=colors[0]; ++i)
  if (colors[i] > lim)
  {
             fprintf(stderr, ""makepng: --color=...: %u out of range [0..%u]\n"",
                colors[i], lim);
             exit(1);
 
           }
     }
  
     
    if (small && colors[0] != 0)
    {
       fprintf(stderr, ""makepng: --color --small: only one at a time!\n"");
       exit(1);
    }
 
      
   if (filters == PNG_ALL_FILTERS)
    if (filters == PNG_ALL_FILTERS && !small )
     {
        if ((color_type & PNG_COLOR_MASK_PALETTE) != 0 || bit_depth < 8)
           filters = PNG_FILTER_NONE;
 
  else if (color_type & PNG_COLOR_MASK_COLOR)  
  {
  if (bit_depth == 8)
             filters &= ~(PNG_FILTER_NONE | PNG_FILTER_AVG);
 
  else
             filters = PNG_FILTER_SUB | PNG_FILTER_PAETH;
  }
 
  else  
 
           filters &= ~PNG_FILTER_NONE;
     }
  
     
    {
       static png_const_charp copyright[] =
       {
          COPYRIGHT,  
          NULL
       };
       static png_const_charp licensing[] =
       {
          IMAGE_LICENSING,  
          NULL
       };
 
       chunk_insert *new_insert;
 
       new_insert = add_tEXt(""Copyright"", copyright);
       if (new_insert != NULL)
       {
          *insert_ptr = new_insert;
          insert_ptr = &new_insert->next;
       }
 
       new_insert = add_iTXt(""Licensing"", ""en"", NULL, licensing);
       if (new_insert != NULL)
       {
          *insert_ptr = new_insert;
          insert_ptr = &new_insert->next;
       }
    }
 
     {
        int ret = write_png(&file_name, fp, color_type, bit_depth, gamma,
         head_insert, filters, colors);
          head_insert, filters, colors, small, tRNS);
  
        if (ret != 0 && file_name != NULL)
           remove(file_name);
 
  return ret;
  }
 }","[8, 9, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 177, 180, 181, 201, 202, 203, 204, 205, 206, 207, 210, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 262, 176, 179, 209, 261]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
206656," void WebGL2RenderingContextBase::texSubImage3D(
     GLenum target,
     GLint level,
     GLint xoffset,
     GLint yoffset,
     GLint zoffset,
     GLsizei width,
     GLsizei height,
     GLsizei depth,
     GLenum format,
     GLenum type,
     MaybeShared<DOMArrayBufferView> pixels,
     GLuint src_offset) {
   if (isContextLost())
     return;
   if (bound_pixel_unpack_buffer_) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""texSubImage3D"",
                        ""a buffer is bound to PIXEL_UNPACK_BUFFER"");
      return;
    }
   if (unpack_flip_y_ || unpack_premultiply_alpha_) {
     DCHECK(pixels);
     SynthesizeGLError(
         GL_INVALID_OPERATION, ""texSubImage3D"",
         ""FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures"");
     return;
   }
 
    TexImageHelperDOMArrayBufferView(
        kTexSubImage3D, target, level, 0, width, height, depth, 0, format, type,
        xoffset, yoffset, zoffset, pixels.View(), kNullNotReachable, src_offset);
 }","[21, 22, 23, 24, 25, 26, 27, 28]",Heap buffer overflow in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
208033,"  SoftMPEG4Encoder::~SoftMPEG4Encoder() {
      ALOGV(""Destruct SoftMPEG4Encoder"");
     onReset();
      releaseEncoder();
      List<BufferInfo *> &outQueue = getPortQueue(1);
      List<BufferInfo *> &inQueue = getPortQueue(0);
     CHECK(outQueue.empty());
     CHECK(inQueue.empty());
 }",[3],"An elevation of privilege vulnerability in libstagefright in Mediaserver could enable a local malicious application to execute arbitrary code within the context of a privileged process. This issue is rated as High because it could be used to gain local access to elevated capabilities, which are not normally accessible to a third-party application. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34749392."
199830," spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,
  			      gss_ctx_id_t context_handle, gss_qop_t qop_req,
  			      gss_iov_buffer_desc *iov, int iov_count)
  {
    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
     spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
 
     if (sc->ctx_handle == GSS_C_NO_CONTEXT)
 	    return (GSS_S_NO_CONTEXT);
 
     return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,
  				  iov_count);
  }","[6, 7, 8, 9, 10, 11, 5]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
206309,"  void LockScreenMediaControlsView::OnMouseExited(const ui::MouseEvent& event) {
    if (is_in_drag_ || contents_view_->layer()->GetAnimator()->is_animating())
      return;
  
  close_button_->SetVisible(false);
   header_row_->SetCloseButtonVisibility(false);
  }","[6, 5]","A timing attack in SVG rendering in Google Chrome prior to 60.0.3112.78 for Linux, Windows, and Mac allowed a remote attacker to extract pixel values from a cross-origin page being iframe'd via a crafted HTML page."
9473,"TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node,
TfLiteFullyConnectedParams* params, OpData* data,
const TfLiteTensor* input, const TfLiteTensor* filter,
const TfLiteTensor* bias, TfLiteTensor* output) {
float output_activation_min, output_activation_max;
CalculateActivationRange(params->activation, &output_activation_min,
&output_activation_max);
if (kernel_type == kReference) {
FullyConnectedParams op_params;
op_params.float_activation_min = output_activation_min;
op_params.float_activation_max = output_activation_max;
if (filter->sparsity != nullptr) {
const auto& sparsity = *filter->sparsity;
reference_ops::FullyConnectedSparseWeight(
sparsity, op_params, GetTensorShape(input),
GetTensorData<float>(input), GetTensorShape(filter),
GetTensorData<float>(filter), GetTensorShape(bias),
GetTensorData<float>(bias), GetTensorShape(output),
GetTensorData<float>(output));
} else {
reference_ops::FullyConnected(
op_params, GetTensorShape(input), GetTensorData<float>(input),
GetTensorShape(filter), GetTensorData<float>(filter),
GetTensorShape(bias), GetTensorData<float>(bias),
GetTensorShape(output), GetTensorData<float>(output));
}
} else if (kernel_type == kLegacyPie) {
return EvalPie(context, node, params, data, input, filter, bias, output);
} else {
FullyConnectedParams op_params;
op_params.float_activation_min = output_activation_min;
op_params.float_activation_max = output_activation_max;
if (filter->sparsity != nullptr) {
const auto& sparsity = *filter->sparsity;
if (!SupportedSparsityFormat(sparsity)) {
TF_LITE_KERNEL_LOG(context,
""Unsupported sparse fully-connected weight format."");
return kTfLiteError;
}

if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) {

optimized_ops::FullyConnectedSparseWeight(
sparsity, op_params, GetTensorShape(input),
GetTensorData<float>(input), GetTensorShape(filter),
GetTensorData<float>(filter), GetTensorShape(bias),
GetTensorData<float>(bias), GetTensorShape(output),
GetTensorData<float>(output));
} else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse &&
sparsity.dim_metadata[2].dense_size == 4) {

optimized_ops::FullyConnectedSparseWeight1x4(
sparsity, op_params, GetTensorShape(input),
GetTensorData<float>(input), GetTensorShape(filter),
GetTensorData<float>(filter), GetTensorShape(bias),
GetTensorData<float>(bias), GetTensorShape(output),
GetTensorData<float>(output),
CpuBackendContext::GetFromContext(context));
} else {
TF_LITE_KERNEL_LOG(context,
""Unsupported sparse fully-connected weight format."");
return kTfLiteError;
}

} else {
op_params.lhs_cacheable = IsConstantTensor(filter);
op_params.rhs_cacheable = IsConstantTensor(input);
optimized_ops::FullyConnected(
op_params, GetTensorShape(input), GetTensorData<float>(input),
GetTensorShape(filter), GetTensorData<float>(filter),
GetTensorShape(bias), GetTensorData<float>(bias),
GetTensorShape(output), GetTensorData<float>(output),
CpuBackendContext::GetFromContext(context));
}
}

return kTfLiteOk;
}","[41, 44, 45, 46, 47, 48, 53, 54, 55, 56, 57]","Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause a write outside of bounds of an array in TFLite. In fact, the attacker can override the linked list used by the memory allocator. This can be leveraged for an arbitrary write primitive under certain conditions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
206077,"  GLSurfaceEGLSurfaceControl::GLSurfaceEGLSurfaceControl(
      ANativeWindow* window,
      scoped_refptr<base::SingleThreadTaskRunner> task_runner)
    : root_surface_(new SurfaceControl::Surface(window, kRootSurfaceName)),
     : window_rect_(0,
                    0,
                    ANativeWindow_getWidth(window),
                    ANativeWindow_getHeight(window)),
       root_surface_(new SurfaceControl::Surface(window, kRootSurfaceName)),
        gpu_task_runner_(std::move(task_runner)),
        weak_factory_(this) {}","[5, 6, 7, 8, 9, 4]",Multiple unspecified vulnerabilities in Google Chrome before 52.0.2743.82 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
203265," static void skel(const char *homedir, uid_t u, gid_t g) {
 	char *fname;
 
 	if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
 		if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
  		if (stat(fname, &s) == 0)
  			return;
  		if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.zshrc"");
			}
 			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.zshrc"");
  		}
		else {  
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
 		else {
 			touch_file_as_user(fname, u, g, 0644);
 			fs_logger2(""touch"", fname);
  		}
  		free(fname);
  	}
 	else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
 		if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
  		if (stat(fname, &s) == 0)
  			return;
  		if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.cshrc"");
			}
 			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.cshrc"");
  		}
		else {  
			 
			FILE *fp = fopen(fname, ""w"");
			if (fp) {
				fprintf(fp, ""\n"");
				SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
				fclose(fp);
				fs_logger2(""touch"", fname);
			}
 		else {
 			touch_file_as_user(fname, u, g, 0644);
 			fs_logger2(""touch"", fname);
  		}
  		free(fname);
  	}
 	else {
 		if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
 			errExit(""asprintf"");
 		struct stat s;
  		if (stat(fname, &s) == 0) 
  			return;
  		if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) {
				fs_logger(""clone /etc/skel/.bashrc"");
			}
 			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
 			fs_logger(""clone /etc/skel/.bashrc"");
  		}
  		free(fname);
  	}
 }","[14, 15, 25, 26, 27, 41, 42, 53, 54, 55, 69, 70, 11, 12, 13, 17, 18, 19, 20, 21, 22, 23, 24, 38, 39, 40, 44, 45, 46, 47, 48, 49, 50, 51, 52, 66, 67, 68]","Firejail before 0.9.44.6 and 0.9.38.x LTS before 0.9.38.10 LTS does not comprehensively address dotfile cases during its attempt to prevent accessing user files with an euid of zero, which allows local users to conduct sandbox-escape attacks via vectors involving a symlink and the --private option. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-5180."
205096,"  void BlobURLRequestJob::CountSize() {
    error_ = false;
    pending_get_file_info_count_ = 0;
   total_size_ = 0;
   item_length_list_.resize(blob_data_->items().size());
 
   for (size_t i = 0; i < blob_data_->items().size(); ++i) {
     const BlobData::Item& item = blob_data_->items().at(i);
     if (IsFileType(item.type())) {
       ++pending_get_file_info_count_;
       GetFileStreamReader(i)->GetLength(
           base::Bind(&BlobURLRequestJob::DidGetFileItemLength,
                       weak_factory_.GetWeakPtr(), i));
        continue;
      }
    int64 item_length = static_cast<int64>(item.length());
    item_length_list_[i] = item_length;
    total_size_ += item_length;
 
     if (!AddItemLength(i, item.length()))
       return;
    }
  
    if (pending_get_file_info_count_ == 0)
     DidCountSize(net::OK);
 }","[19, 20, 21, 16, 17, 18]","Integer overflow in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a blob."
203204," parse_elements(netdissect_options *ndo,
                struct mgmt_body_t *pbody, const u_char *p, int offset,
                u_int length)
 {
 	u_int elementlen;
 	struct ssid_t ssid;
 	struct challenge_t challenge;
 	struct rates_t rates;
 	struct ds_t ds;
 	struct cf_t cf;
 	struct tim_t tim;
 
 	 
 	pbody->challenge_present = 0;
 	pbody->ssid_present = 0;
 	pbody->rates_present = 0;
 	pbody->ds_present = 0;
 	pbody->cf_present = 0;
 	pbody->tim_present = 0;
 
 	while (length != 0) {
 		 
 		if (!ND_TTEST2(*(p + offset), 2))
 			return 0;
 		if (length < 2)
 			return 0;
 		elementlen = *(p + offset + 1);
 
 		 
 		if (!ND_TTEST2(*(p + offset + 2), elementlen))
 			return 0;
 		if (length < elementlen + 2)
 			return 0;
 
 		switch (*(p + offset)) {
 		case E_SSID:
 			memcpy(&ssid, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (ssid.length != 0) {
 				if (ssid.length > sizeof(ssid.ssid) - 1)
 					return 0;
 				if (!ND_TTEST2(*(p + offset), ssid.length))
 					return 0;
 				if (length < ssid.length)
 					return 0;
 				memcpy(&ssid.ssid, p + offset, ssid.length);
 				offset += ssid.length;
 				length -= ssid.length;
 			}
 			ssid.ssid[ssid.length] = '\0';
 			 
 			if (!pbody->ssid_present) {
 				pbody->ssid = ssid;
 				pbody->ssid_present = 1;
 			}
 			break;
 		case E_CHALLENGE:
 			memcpy(&challenge, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (challenge.length != 0) {
 				if (challenge.length >
 				    sizeof(challenge.text) - 1)
 					return 0;
 				if (!ND_TTEST2(*(p + offset), challenge.length))
 					return 0;
 				if (length < challenge.length)
 					return 0;
 				memcpy(&challenge.text, p + offset,
 				    challenge.length);
 				offset += challenge.length;
 				length -= challenge.length;
 			}
 			challenge.text[challenge.length] = '\0';
 			 
 			if (!pbody->challenge_present) {
 				pbody->challenge = challenge;
 				pbody->challenge_present = 1;
 			}
 			break;
 		case E_RATES:
 			memcpy(&rates, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (rates.length != 0) {
 				if (rates.length > sizeof rates.rate)
 					return 0;
 				if (!ND_TTEST2(*(p + offset), rates.length))
 					return 0;
 				if (length < rates.length)
 					return 0;
 				memcpy(&rates.rate, p + offset, rates.length);
 				offset += rates.length;
 				length -= rates.length;
 			}
 			 
 			if (!pbody->rates_present && rates.length != 0) {
 				pbody->rates = rates;
 				pbody->rates_present = 1;
 			}
 			break;
 		case E_DS:
 			memcpy(&ds, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (ds.length != 1) {
 				offset += ds.length;
 				length -= ds.length;
 				break;
 			}
 			ds.channel = *(p + offset);
 			offset += 1;
 			length -= 1;
 			 
 			if (!pbody->ds_present) {
 				pbody->ds = ds;
 				pbody->ds_present = 1;
 			}
 			break;
 		case E_CF:
 			memcpy(&cf, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (cf.length != 6) {
 				offset += cf.length;
 				length -= cf.length;
 				break;
 			}
 			memcpy(&cf.count, p + offset, 6);
 			offset += 6;
 			length -= 6;
 			 
 			if (!pbody->cf_present) {
 				pbody->cf = cf;
 				pbody->cf_present = 1;
 			}
 			break;
 		case E_TIM:
 			memcpy(&tim, p + offset, 2);
 			offset += 2;
 			length -= 2;
 			if (tim.length <= 3) {
 				offset += tim.length;
 				length -= tim.length;
 				break;
 			}
 			if (tim.length - 3 > (int)sizeof tim.bitmap)
 				return 0;
 			memcpy(&tim.count, p + offset, 3);
  			offset += 3;
  			length -= 3;
  
			memcpy(tim.bitmap, p + (tim.length - 3),
			    (tim.length - 3));
 			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);
  			offset += tim.length - 3;
  			length -= tim.length - 3;
  			 
 			if (!pbody->tim_present) {
 				pbody->tim = tim;
 				pbody->tim_present = 1;
 			}
 			break;
 		default:
 #if 0
 			ND_PRINT((ndo, ""(1) unhandled element_id (%d)  "",
 			    *(p + offset)));
 #endif
 			offset += 2 + elementlen;
 			length -= 2 + elementlen;
 			break;
 		}
 	}
 
 	 
 	return 1;
 }","[156, 154, 155]",The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().
202286,"  int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,
                       PacketQueue *pq)
 {
     SCEnter();
 
     DEBUG_ASSERT_FLOW_LOCKED(p->flow);
 
     SCLogDebug(""p->pcap_cnt %""PRIu64, p->pcap_cnt);
 
      
     if (unlikely(p->flow->thread_id == 0)) {
         p->flow->thread_id = (FlowThreadId)tv->id;
 #ifdef DEBUG
     } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {
         SCLogDebug(""wrong thread: flow has %u, we are %d"", p->flow->thread_id, tv->id);
 #endif
     }
 
     TcpSession *ssn = (TcpSession *)p->flow->protoctx;
 
      
     if (ssn != NULL) {
         ssn->tcp_packet_flags |= p->tcph->th_flags;
         if (PKT_IS_TOSERVER(p))
             ssn->client.tcp_flags |= p->tcph->th_flags;
         else if (PKT_IS_TOCLIENT(p))
             ssn->server.tcp_flags |= p->tcph->th_flags;
 
          
         if (ssn->flags & STREAMTCP_FLAG_ASYNC &&
             ssn->client.tcp_flags != 0 &&
             ssn->server.tcp_flags != 0)
         {
             SCLogDebug(""ssn %p: removing ASYNC flag as we have packets on both sides"", ssn);
             ssn->flags &= ~STREAMTCP_FLAG_ASYNC;
         }
     }
 
      
     if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {
         StatsIncr(tv, stt->counter_tcp_synack);
     } else if (p->tcph->th_flags & (TH_SYN)) {
         StatsIncr(tv, stt->counter_tcp_syn);
     }
     if (p->tcph->th_flags & (TH_RST)) {
         StatsIncr(tv, stt->counter_tcp_rst);
     }
 
      
     if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {
         StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);
     }
 
      
     if (StreamTcpCheckFlowDrops(p) == 1) {
         SCLogDebug(""This flow/stream triggered a drop rule"");
         FlowSetNoPacketInspectionFlag(p->flow);
         DecodeSetNoPacketInspectionFlag(p);
         StreamTcpDisableAppLayer(p->flow);
         PACKET_DROP(p);
          
         StreamTcpSessionPktFree(p);
         SCReturnInt(0);
     }
 
     if (ssn == NULL || ssn->state == TCP_NONE) {
         if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {
             goto error;
         }
 
         if (ssn != NULL)
             SCLogDebug(""ssn->alproto %""PRIu16"""", p->flow->alproto);
     } else {
          
         if (p->flags & PKT_PSEUDO_STREAM_END) {
             if (PKT_IS_TOCLIENT(p)) {
                 ssn->client.last_ack = TCP_GET_ACK(p);
                 StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,
                         &ssn->server, p, pq);
             } else {
                 ssn->server.last_ack = TCP_GET_ACK(p);
                 StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,
                         &ssn->client, p, pq);
             }
              
             goto skip;
         }
 
          
         if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)
             StreamTcpPacketSwitchDir(ssn, p);
 
         if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {
             goto skip;
         }
         if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {
             StreamTcpClearKeepAliveFlag(ssn, p);
             goto skip;
         }
         StreamTcpClearKeepAliveFlag(ssn, p);
 
          
         if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)
             if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)
                  if (StreamTcpPacketIsBadWindowUpdate(ssn,p))
                      goto skip;
  
        switch (ssn->state) {
            case TCP_SYN_SENT:
                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_SYN_RECV:
                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_ESTABLISHED:
                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_FIN_WAIT1:
                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_FIN_WAIT2:
                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_CLOSING:
                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_CLOSE_WAIT:
                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_LAST_ACK:
                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_TIME_WAIT:
                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {
                    goto error;
                }
                break;
            case TCP_CLOSED:
                 
                SCLogDebug(""packet received on closed state"");
                break;
            default:
                SCLogDebug(""packet received on default state"");
                break;
        }
          
         if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0)
             goto error;
 
      skip:
         StreamTcpPacketCheckPostRst(ssn, p);
  
          if (ssn->state >= TCP_ESTABLISHED) {
              p->flags |= PKT_STREAM_EST;
         }
     }
 
      
     if (ssn != NULL) {
         while (stt->pseudo_queue.len > 0) {
             SCLogDebug(""processing pseudo packet / stream end"");
             Packet *np = PacketDequeue(&stt->pseudo_queue);
             if (np != NULL) {
                  
                 if (PKT_IS_TOSERVER(np)) {
                     SCLogDebug(""pseudo packet is to server"");
                     StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,
                             &ssn->client, np, NULL);
                 } else {
                     SCLogDebug(""pseudo packet is to client"");
                     StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,
                             &ssn->server, np, NULL);
                 }
 
                  
                 PacketEnqueue(pq, np);
             }
             SCLogDebug(""processing pseudo packet / stream end done"");
         }
 
          
         if (p->flags & PKT_STREAM_MODIFIED) {
             ReCalculateChecksum(p);
         }
 
          
 
          
         if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&
              (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))
         {
              
             if (StreamTcpBypassEnabled()) {
                 PacketBypassCallback(p);
             }
         }
 
         if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||
              (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))
         {
             p->flags |= PKT_STREAM_NOPCAPLOG;
         }
 
          
         if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||
             (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))
         {
             p->flags |= PKT_STREAM_NOPCAPLOG;
         }
 
         if (ssn->flags & STREAMTCP_FLAG_BYPASS) {
              
             if (StreamTcpBypassEnabled()) {
                 PacketBypassCallback(p);
             }
 
          
         } else if (g_detect_disabled &&
                 (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&
                 (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&
                 StreamTcpBypassEnabled())
         {
             SCLogDebug(""bypass as stream is dead and we have no rules"");
             PacketBypassCallback(p);
         }
     }
 
     SCReturnInt(0);
 
 error:
      
     while (stt->pseudo_queue.len > 0) {
         Packet *np = PacketDequeue(&stt->pseudo_queue);
         if (np != NULL) {
             PacketEnqueue(pq, np);
         }
     }
 
      
     if (p->flags & PKT_STREAM_MODIFIED) {
         ReCalculateChecksum(p);
     }
 
     if (StreamTcpInlineDropInvalid()) {
          
         DecodeSetNoPayloadInspectionFlag(p);
         PACKET_DROP(p);
     }
     SCReturnInt(-1);
 }","[162, 163, 164, 165, 167, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161]","Suricata before 4.0.5 stops TCP stream inspection upon a TCP RST from a server. This allows detection bypass because Windows TCP clients proceed with normal processing of TCP data that arrives shortly after an RST (i.e., they act as if the RST had not yet been received)."
206776,"  VaapiVideoDecodeAccelerator::VaapiVP9Accelerator::CreateVP9Picture() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
    scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();
    if (!va_surface)
      return nullptr;
 
   return new VaapiVP9Picture(std::move(va_surface));
 }",[2],A race in the handling of SharedArrayBuffers in WebAssembly in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
10091,"void Compute(OpKernelContext* ctx) override {
const Tensor& gradient = ctx->input(0);
const Tensor& input = ctx->input(1);
Tensor* input_backprop = nullptr;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, input.shape(), &input_backprop));
OP_REQUIRES(
ctx, axis_ >= -1,
errors::InvalidArgument(""Axis must be at least -1. Found "", axis_));
OP_REQUIRES(ctx, (axis_ == -1 || axis_ < input.shape().dims()),
errors::InvalidArgument(
""Axis should be -1 or 0 or a positive value less than "",
input.shape().dims(), ""but given axis value was "", axis_));

OP_REQUIRES(
ctx, input.IsSameSize(gradient),
errors::InvalidArgument(""gradient and input must be the same size""));
const int depth = (axis_ == -1) ? 1 : input.dim_size(axis_);
const Tensor& input_min_tensor = ctx->input(2);
OP_REQUIRES(ctx,
input_min_tensor.dims() == 0 || input_min_tensor.dims() == 1,
errors::InvalidArgument(
""Input min tensor must have dimension 0 or 1. Received "",
input_min_tensor.dims(), "".""));
const Tensor& input_max_tensor = ctx->input(3);
OP_REQUIRES(ctx,
input_max_tensor.dims() == 0 || input_max_tensor.dims() == 1,
errors::InvalidArgument(
""Input max tensor must have dimension 0 or 1. Received "",
input_max_tensor.dims(), "".""));
if (axis_ != -1) {
OP_REQUIRES(
ctx, input_min_tensor.dim_size(0) == depth,
errors::InvalidArgument(""min has incorrect size, expected "", depth,
"" was "", input_min_tensor.dim_size(0)));
OP_REQUIRES(
ctx, input_max_tensor.dim_size(0) == depth,
errors::InvalidArgument(""max has incorrect size, expected "", depth,
"" was "", input_max_tensor.dim_size(0)));
}

TensorShape min_max_shape(input_min_tensor.shape());
Tensor* input_min_backprop;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(1, min_max_shape, &input_min_backprop));

Tensor* input_max_backprop;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(2, min_max_shape, &input_max_backprop));

if (axis_ == -1) {
OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_min_tensor.shape()),
errors::InvalidArgument(
""input_min must be a scalar if axis is unspecified""));
OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(input_max_tensor.shape()),
errors::InvalidArgument(
""input_max must be a scalar if axis is unspecified""));
functor::QuantizeAndDequantizeOneScaleGradientFunctor<Device, T> f;
f(ctx->eigen_device<Device>(), gradient.template flat<T>(),
input.template flat<T>(), input_min_tensor.scalar<T>(),
input_max_tensor.scalar<T>(), input_backprop->template flat<T>(),
input_min_backprop->template scalar<T>(),
input_max_backprop->template scalar<T>());
} else {
functor::QuantizeAndDequantizePerChannelGradientFunctor<Device, T> f;
f(ctx->eigen_device<Device>(),
gradient.template flat_inner_outer_dims<T, 3>(axis_ - 1),
input.template flat_inner_outer_dims<T, 3>(axis_ - 1),
&input_min_tensor, &input_max_tensor,
input_backprop->template flat_inner_outer_dims<T, 3>(axis_ - 1),
input_min_backprop->template flat<T>(),
input_max_backprop->template flat<T>());
}
}","[7, 8, 9, 11, 15, 16, 17, 22, 28, 32, 33, 34, 36, 37, 38, 52, 53, 54, 55, 56, 57]","TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
202025," static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
   int texel_size,ExceptionInfo *exception)
 {
   register ssize_t
     i;
 
   MagickOffsetType
     offset;
 
   size_t
     h,
     w;
 
    
   if (EOFBlob(image) != MagickFalse)
     {
       ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
         image->filename);
       return(MagickFalse);
     }
   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
     {
       w = DIV2(dds_info->width);
       h = DIV2(dds_info->height);
 
        
        for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
        {
          offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         if (SeekBlob(image,offset,SEEK_CUR) < 0)
           break;
          w = DIV2(w);
          h = DIV2(h);
        }
     }
   return(MagickTrue);
 }","[33, 34, 32]",coders/dds.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (CPU consumption) via a crafted DDS file.
208128," WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
   
 
  dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);
 
     WORD32 i4_err_status = 0;
     UWORD8 *pu1_buf = NULL;
     WORD32 buflen;
     UWORD32 u4_max_ofst, u4_length_of_start_code = 0;
 
     UWORD32 bytes_consumed = 0;
     UWORD32 cur_slice_is_nonref = 0;
     UWORD32 u4_next_is_aud;
     UWORD32 u4_first_start_code_found = 0;
     WORD32 ret = 0,api_ret_value = IV_SUCCESS;
     WORD32 header_data_left = 0,frame_data_left = 0;
     UWORD8 *pu1_bitstrm_buf;
  ivd_video_decode_ip_t *ps_dec_ip;
  ivd_video_decode_op_t *ps_dec_op;
 
     ithread_set_name((void*)""Parse_thread"");
 
     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;
 
  {
         UWORD32 u4_size;
         u4_size = ps_dec_op->u4_size;
         memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
         ps_dec_op->u4_size = u4_size;
  }
 
     ps_dec->pv_dec_out = ps_dec_op;
  if(ps_dec->init_done != 1)
  {
  return IV_FAIL;
  }
 
   
     DATA_SYNC();
 
  if(0 == ps_dec->u1_flushfrm)
  {
  if(ps_dec_ip->pv_stream_buffer == NULL)
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
  return IV_FAIL;
  }
  if(ps_dec_ip->u4_num_Bytes <= 0)
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
  return IV_FAIL;
 
  }
  }
     ps_dec->u1_pic_decode_done = 0;
 
     ps_dec_op->u4_num_bytes_consumed = 0;
 
     ps_dec->ps_out_buffer = NULL;
 
  if(ps_dec_ip->u4_size
  >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
     ps_dec->u4_fmt_conv_cur_row = 0;
 
     ps_dec->u4_output_present = 0;
     ps_dec->s_disp_op.u4_error_code = 1;
     ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
  if(0 == ps_dec->u4_share_disp_buf
  && ps_dec->i4_decode_header == 0)
  {
         UWORD32 i;
  if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||
  (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))
  {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
  return IV_FAIL;
  }
 
  for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
  {
  if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
  {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
  return IV_FAIL;
  }
 
  if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
  {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |=
                                 IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
  return IV_FAIL;
  }
  }
  }
 
  if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
  {
         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
  return IV_FAIL;
  }
 
   
     ps_dec->u4_ts = ps_dec_ip->u4_ts;
 
     ps_dec_op->u4_error_code = 0;
     ps_dec_op->e_pic_type = -1;
     ps_dec_op->u4_output_present = 0;
     ps_dec_op->u4_frame_decoded_flag = 0;
 
     ps_dec->i4_frametype = -1;
     ps_dec->i4_content_type = -1;
 
     ps_dec->u4_slice_start_code_found = 0;
 
   
 
  if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1
  && ps_dec->u1_flushfrm == 0)
  {
         UWORD32 i;
 
         WORD32 disp_avail = 0, free_id;
 
   
   
  for(i = 0; i < ps_dec->u1_pic_bufs; i++)
  {
  if(0 == ps_dec->u4_disp_buf_mapping[i]
  || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
  {
                 disp_avail = 1;
  break;
  }
 
  }
 
  if(0 == disp_avail)
  {
   
 
             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
  return (IV_FAIL);
  }
 
  while(1)
  {
  pic_buffer_t *ps_pic_buf;
             ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);
 
  if(ps_pic_buf == NULL)
  {
                 UWORD32 i, display_queued = 0;
 
   
  for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
  {
  if(0 != ps_dec->u4_disp_buf_mapping[i])
  {
                         display_queued = 1;
  break;
  }
  }
   
 
  if(1 == display_queued)
  {
   
                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                     ps_dec_op->u4_error_code |= (1
  << IVD_UNSUPPORTEDPARAM);
  return (IV_FAIL);
  }
  }
  else
  {
   
  if(1 == ps_dec->u4_disp_buf_mapping[free_id])
  {
                     ih264_buf_mgr_set_status(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                     free_id,
                                     BUF_MGR_IO);
  }
  else
  {
   
                     ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                           free_id,
                                           BUF_MGR_IO);
  break;
  }
  }
  }
 
  }
 
  if(ps_dec->u1_flushfrm)
  {
  if(ps_dec->u1_init_dec_flag == 0)
  {
   
             ps_dec->u1_flushfrm = 0;
  return (IV_FAIL);
  }
 
 
 
         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
   
  if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
  {
                 ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
  return (IV_FAIL);
  }
 
             ps_dec->u4_fmt_conv_cur_row = 0;
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
             ps_dec->u4_output_present = 1;
 
  }
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
 
         ps_dec_op->u4_new_seq = 0;
 
         ps_dec_op->u4_output_present = ps_dec->u4_output_present;
         ps_dec_op->u4_progressive_frame_flag =
                         ps_dec->s_disp_op.u4_progressive_frame_flag;
         ps_dec_op->e_output_format =
                         ps_dec->s_disp_op.e_output_format;
         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
   
         ps_dec_op->u4_is_ref_flag = -1;
         ps_dec_op->e_pic_type = IV_NA_FRAME;
         ps_dec_op->u4_frame_decoded_flag = 0;
 
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
  return (IV_SUCCESS);
  }
  else
  return (IV_FAIL);
 
  }
  if(ps_dec->u1_res_changed == 1)
  {
   
         ih264d_init_decoder(ps_dec);
  }
 
     ps_dec->u4_prev_nal_skipped = 0;
 
     ps_dec->u2_cur_mb_addr = 0;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->u2_cur_slice_num = 0;
     ps_dec->cur_dec_mb_num = 0;
     ps_dec->cur_recon_mb_num = 0;
     ps_dec->u4_first_slice_in_pic = 1;
     ps_dec->u1_slice_header_done = 0;
     ps_dec->u1_dangling_field = 0;
 
     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
     ps_dec->u4_cur_bs_mb_num = 0;
     ps_dec->u4_start_recon_deblk  = 0;
     ps_dec->u4_sps_cnt_in_process = 0;
 
     DEBUG_THREADS_PRINTF("" Starting process call\n"");
 
 
     ps_dec->u4_pic_buf_got = 0;
 
  do
  {
         WORD32 buf_size;
 
         pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer
  + ps_dec_op->u4_num_bytes_consumed;
 
         u4_max_ofst = ps_dec_ip->u4_num_Bytes
  - ps_dec_op->u4_num_bytes_consumed;
 
   
  if((NULL == ps_dec->pu1_bits_buf_dynamic) &&
  (ps_dec->i4_header_decoded & 1))
  {
             WORD32 size;
 
 
              void *pv_buf;
              void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;
              size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);
            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);
             pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,
                                               size + EXTRA_BS_OFFSET);
              RETURN_IF((NULL == pv_buf), IV_FAIL);
              ps_dec->pu1_bits_buf_dynamic = pv_buf;
              ps_dec->u4_dynamic_bits_buf_size = size;
  }
 
  if(ps_dec->pu1_bits_buf_dynamic)
  {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;
             buf_size = ps_dec->u4_dynamic_bits_buf_size;
  }
  else
  {
             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;
             buf_size = ps_dec->u4_static_bits_buf_size;
  }
 
         u4_next_is_aud = 0;
 
         buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,
  &u4_length_of_start_code,
  &u4_next_is_aud);
 
  if(buflen == -1)
             buflen = 0;
   
   
         buflen = MIN(buflen, buf_size - 8);
 
         bytes_consumed = buflen + u4_length_of_start_code;
         ps_dec_op->u4_num_bytes_consumed += bytes_consumed;
 
  {
             UWORD8 u1_firstbyte, u1_nal_ref_idc;
 
  if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)
  {
                 u1_firstbyte = *(pu1_buf + u4_length_of_start_code);
                 u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));
  if(u1_nal_ref_idc == 0)
  {
   
                     cur_slice_is_nonref = 1;
  continue;
  }
  else
  {
  if(1 == cur_slice_is_nonref)
  {
   
                         ps_dec_op->u4_num_bytes_consumed -=
                                         bytes_consumed;
                         ps_dec_op->e_pic_type = IV_B_FRAME;
                         ps_dec_op->u4_error_code =
                                         IVD_DEC_FRM_SKIPPED;
                         ps_dec_op->u4_error_code |= (1
  << IVD_UNSUPPORTEDPARAM);
                         ps_dec_op->u4_frame_decoded_flag = 0;
                         ps_dec_op->u4_size =
  sizeof(ivd_video_decode_op_t);
   
                         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
                             ih264d_signal_bs_deblk_thread(ps_dec);
  }
 
  return (IV_FAIL);
  }
  }
 
  }
 
  }
 
 
  if(buflen)
  {
             memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,
                    buflen);
   
  if((buflen + 8) < buf_size)
  {
                 memset(pu1_bitstrm_buf + buflen, 0, 8);
  }
             u4_first_start_code_found = 1;
 
  }
  else
  {
   
 
  if(u4_first_start_code_found == 0)
  {
   
 
                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;
 
  if(ps_dec->u4_pic_buf_got == 0)
  {
 
                     ih264d_fill_output_struct_from_context(ps_dec,
                                                            ps_dec_op);
 
                     ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                     ps_dec_op->u4_frame_decoded_flag = 0;
 
  return (IV_FAIL);
  }
  else
  {
                     ps_dec->u1_pic_decode_done = 1;
  continue;
  }
  }
  else
  {
   
                 frame_data_left = 0;
                 header_data_left = 0;
  continue;
  }
 
  }
 
         ps_dec->u4_return_to_app = 0;
         ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,
                               pu1_bitstrm_buf, buflen);
  if(ret != OK)
  {
             UWORD32 error =  ih264d_map_error(ret);
             ps_dec_op->u4_error_code = error | ret;
             api_ret_value = IV_FAIL;
 
  if((ret == IVD_RES_CHANGED)
  || (ret == IVD_MEM_ALLOC_FAILED)
  || (ret == ERROR_UNAVAIL_PICBUF_T)
  || (ret == ERROR_UNAVAIL_MVBUF_T)
  || (ret == ERROR_INV_SPS_PPS_T)
  || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))
  {
                 ps_dec->u4_slice_start_code_found = 0;
  break;
  }
 
  if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
  {
                 ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                 api_ret_value = IV_FAIL;
  break;
  }
 
  if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
  {
                 api_ret_value = IV_FAIL;
  break;
  }
 
  }
 
  if(ps_dec->u4_return_to_app)
  {
   
             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
             ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
             ps_dec_op->u4_frame_decoded_flag = 0;
             ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
   
             ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
                 ih264d_signal_bs_deblk_thread(ps_dec);
  }
  return (IV_FAIL);
 
  }
 
 
 
         header_data_left = ((ps_dec->i4_decode_header == 1)
  && (ps_dec->i4_header_decoded != 3)
  && (ps_dec_op->u4_num_bytes_consumed
  < ps_dec_ip->u4_num_Bytes));
         frame_data_left = (((ps_dec->i4_decode_header == 0)
  && ((ps_dec->u1_pic_decode_done == 0)
  || (u4_next_is_aud == 1)))
  && (ps_dec_op->u4_num_bytes_consumed
  < ps_dec_ip->u4_num_Bytes));
  }
  while(( header_data_left == 1)||(frame_data_left == 1));
 
  if((ps_dec->u4_pic_buf_got == 1)
  && (ret != IVD_MEM_ALLOC_FAILED)
  && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
         WORD32 num_mb_skipped;
         WORD32 prev_slice_err;
  pocstruct_t temp_poc;
         WORD32 ret1;
         WORD32 ht_in_mbs;
         ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);
         num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  - ps_dec->u2_total_mbs_coded;
 
  if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
             prev_slice_err = 1;
  else
             prev_slice_err = 2;
 
  if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))
             prev_slice_err = 1;
 
         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,
  &temp_poc, prev_slice_err);
 
  if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||
  (ret1 == ERROR_INV_SPS_PPS_T))
  {
             ret = ret1;
  }
  }
 
  if((ret == IVD_RES_CHANGED)
  || (ret == IVD_MEM_ALLOC_FAILED)
  || (ret == ERROR_UNAVAIL_PICBUF_T)
  || (ret == ERROR_UNAVAIL_MVBUF_T)
  || (ret == ERROR_INV_SPS_PPS_T))
  {
 
   
         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
   
  if(ret == IVD_RES_CHANGED)
  {
             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
  }
  return IV_FAIL;
  }
 
 
  if(ps_dec->u1_separate_parse)
  {
   
  if(ps_dec->u4_num_cores == 2)
  {
 
   
  if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
  {
                 UWORD32 u4_num_mbs,u4_max_addr;
  tfr_ctxt_t s_tfr_ctxt;
  tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
  pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;
 
   
                 u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                 ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;
 
 
                 ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                            ps_dec->u2_frm_wd_in_mbs, 0);
 
 
                 u4_num_mbs = u4_max_addr
  - ps_dec->u4_cur_deblk_mb_num + 1;
 
                 DEBUG_PERF_PRINTF(""mbs left for deblocking= %d \n"",u4_num_mbs);
 
  if(u4_num_mbs != 0)
                     ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,
                                                    ps_tfr_cxt,1);
 
                 ps_dec->u4_start_recon_deblk  = 0;
 
  }
 
  }
 
   
         ih264d_signal_decode_thread(ps_dec);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
  }
 
 
     DATA_SYNC();
 
 
  if((ps_dec_op->u4_error_code & 0xff)
  != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
  {
         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;
  }
 
  if(ps_dec->i4_header_decoded != 3)
  {
         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
 
  }
 
  if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
  {
         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
 
  }
  if(ps_dec->u4_prev_nal_skipped)
  {
   
         ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;
         ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
         ps_dec_op->u4_frame_decoded_flag = 0;
         ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);
   
  if(ps_dec->u4_num_cores == 3)
  {
             ih264d_signal_bs_deblk_thread(ps_dec);
  }
  return (IV_FAIL);
 
  }
 
  if((ps_dec->u4_pic_buf_got == 1)
  && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
  {
   
 
  if(ps_dec->ps_cur_slice->u1_field_pic_flag)
  {
  if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
  {
                 ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
  }
  else
  {
                 ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
  }
  }
  else
  {
                 ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
  }
 
   
  if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
  {
   
             ret = ih264d_deblock_display(ps_dec);
  }
 
 
   
  if(ps_dec->i4_header_decoded == 3)
  {
             ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
  }
 
   
  if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
  {
             ps_dec->i4_frametype = IV_IDR_FRAME;
  }
  else if(ps_dec->i4_pic_type == B_SLICE)
  {
             ps_dec->i4_frametype = IV_B_FRAME;
  }
  else if(ps_dec->i4_pic_type == P_SLICE)
  {
             ps_dec->i4_frametype = IV_P_FRAME;
  }
  else if(ps_dec->i4_pic_type == I_SLICE)
  {
             ps_dec->i4_frametype = IV_I_FRAME;
  }
  else
  {
             H264_DEC_DEBUG_PRINT(""Shouldn't come here\n"");
  }
 
         ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded
  - ps_dec->ps_cur_slice->u1_field_pic_flag;
 
  }
 
   
  if(ps_dec->u4_num_cores == 3)
  {
         ih264d_signal_bs_deblk_thread(ps_dec);
  }
 
 
  {
   
 
  if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)
  && ps_dec->u1_init_dec_flag)
  {
 
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
  if(0 == ps_dec->s_disp_op.u4_error_code)
  {
                 ps_dec->u4_fmt_conv_cur_row = 0;
                 ps_dec->u4_output_present = 1;
  }
  }
 
         ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);
 
   
  if(ps_dec->u4_output_present &&
  (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
  {
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht
  - ps_dec->u4_fmt_conv_cur_row;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),
                                   ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
  }
 
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
  }
 
  if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
  {
         ps_dec_op->u4_progressive_frame_flag = 1;
  if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
  {
  if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)
  && (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                 ps_dec_op->u4_progressive_frame_flag = 0;
 
  }
  }
 
  if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
  {
         ps_dec->u1_top_bottom_decoded = 0;
  }
   
   
   
   
  if(ps_dec->u4_pic_buf_got == 1)
  {
  if(1 == ps_dec->u1_last_pic_not_decoded)
  {
             ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
 
  if(ret != OK)
  return ret;
 
             ret = ih264d_end_of_pic(ps_dec);
  if(ret != OK)
  return ret;
  }
  else
  {
             ret = ih264d_end_of_pic(ps_dec);
  if(ret != OK)
  return ret;
  }
 
  }
 
 
   
     DATA_SYNC();
 
     H264_DEC_DEBUG_PRINT(""The num bytes consumed: %d\n"",
                          ps_dec_op->u4_num_bytes_consumed);
  return api_ret_value;
 }","[318, 319, 317]","An information disclosure vulnerability in the Android media framework (libavc). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-63122634."
7853,"void Compute(OpKernelContext* context) override {
const Tensor& images = context->input(0);
const Tensor& boxes = context->input(1);
const int64 depth = images.dim_size(3);

OP_REQUIRES(context, images.dims() == 4,
errors::InvalidArgument(""The rank of the images should be 4""));
OP_REQUIRES(
context, boxes.dims() == 3,
errors::InvalidArgument(""The rank of the boxes tensor should be 3""));
OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),
errors::InvalidArgument(""The batch sizes should be the same""));

OP_REQUIRES(
context, depth == 4 || depth == 1 || depth == 3,
errors::InvalidArgument(""Channel depth should be either 1 (GRY), ""
""3 (RGB), or 4 (RGBA)""));

const int64 batch_size = images.dim_size(0);
const int64 height = images.dim_size(1);
const int64 width = images.dim_size(2);
std::vector<std::vector<float>> color_table;
if (context->num_inputs() == 3) {
const Tensor& colors_tensor = context->input(2);
OP_REQUIRES(context, colors_tensor.shape().dims() == 2,
errors::InvalidArgument(""colors must be a 2-D matrix"",
colors_tensor.shape().DebugString()));
OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,
errors::InvalidArgument(""colors must have equal or more "",
""channels than the image provided: "",
colors_tensor.shape().DebugString()));
if (colors_tensor.NumElements() != 0) {
color_table.clear();

auto colors = colors_tensor.matrix<float>();
for (int64 i = 0; i < colors.dimension(0); i++) {
std::vector<float> color_value(4);
for (int64 j = 0; j < 4; j++) {
color_value[j] = colors(i, j);
}
color_table.emplace_back(color_value);
}
}
}
if (color_table.empty()) {
color_table = DefaultColorTable(depth);
}
Tensor* output;
OP_REQUIRES_OK(
context,
context->allocate_output(
0, TensorShape({batch_size, height, width, depth}), &output));

output->tensor<T, 4>() = images.tensor<T, 4>();
auto canvas = output->tensor<T, 4>();

for (int64 b = 0; b < batch_size; ++b) {
const int64 num_boxes = boxes.dim_size(1);
const auto tboxes = boxes.tensor<T, 3>();
for (int64 bb = 0; bb < num_boxes; ++bb) {
int64 color_index = bb % color_table.size();
const int64 min_box_row =
static_cast<float>(tboxes(b, bb, 0)) * (height - 1);
const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0});
const int64 max_box_row =
static_cast<float>(tboxes(b, bb, 2)) * (height - 1);
const int64 max_box_row_clamp =
std::min<int64>(max_box_row, height - 1);
const int64 min_box_col =
static_cast<float>(tboxes(b, bb, 1)) * (width - 1);
const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0});
const int64 max_box_col =
static_cast<float>(tboxes(b, bb, 3)) * (width - 1);
const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1);

if (min_box_row > max_box_row || min_box_col > max_box_col) {
LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col
<< "","" << max_box_row << "","" << max_box_col
<< "") is inverted and will not be drawn."";
continue;
}
if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||
max_box_col < 0) {
LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col
<< "","" << max_box_row << "","" << max_box_col
<< "") is completely outside the image""
<< "" and will not be drawn."";
continue;
}



CHECK_GE(min_box_row_clamp, 0);
CHECK_GE(max_box_row_clamp, 0);
CHECK_LT(min_box_row_clamp, height);
CHECK_LT(max_box_row_clamp, height);
CHECK_GE(min_box_col_clamp, 0);
CHECK_GE(max_box_col_clamp, 0);
CHECK_LT(min_box_col_clamp, width);
CHECK_LT(max_box_col_clamp, width);




CHECK_LT(min_box_row, height);
CHECK_GE(max_box_row, 0);
CHECK_LT(min_box_col, width);
CHECK_GE(max_box_col, 0);


if (min_box_row >= 0) {
for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)
for (int64 c = 0; c < depth; c++) {
canvas(b, min_box_row, j, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (max_box_row < height) {
for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j)
for (int64 c = 0; c < depth; c++) {
canvas(b, max_box_row, j, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (min_box_col >= 0) {
for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)
for (int64 c = 0; c < depth; c++) {
canvas(b, i, min_box_col, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (max_box_col < width) {
for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i)
for (int64 c = 0; c < depth; c++) {
canvas(b, i, max_box_col, c) =
static_cast<T>(color_table[color_index][c]);
}
}
}
}
}","[93, 94, 95, 96, 97, 98, 99, 100, 105, 106, 107, 108]","TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK` failure by passing an empty image to `tf.raw_ops.DrawBoundingBoxes`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/ea34a18dc3f5c8d80a40ccca1404f343b5d55f91/tensorflow/core/kernels/image/draw_bounding_box_op.cc#L148-L165) uses `CHECK_*` assertions instead of `OP_REQUIRES` to validate user controlled inputs. Whereas `OP_REQUIRES` allows returning an error condition back to the user, the `CHECK_*` macros result in a crash if the condition is false, similar to `assert`. In this case, `height` is 0 from the `images` input. This results in `max_box_row_clamp` being negative and the assertion being falsified, followed by aborting program execution. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
7438,"static void bits2int(uECC_word_t *native,
const uint8_t *bits,
unsigned bits_size,
uECC_Curve curve) {
unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
int shift;
uECC_word_t carry;
uECC_word_t *ptr;

if (bits_size > num_n_bytes) {
bits_size = num_n_bytes;
}

uECC_vli_clear(native, num_n_words);
#if uECC_VLI_NATIVE_LITTLE_ENDIAN
bcopy((uint8_t *) native, bits, bits_size);
#else
uECC_vli_bytesToNative(native, bits, bits_size);
#endif    
if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
return;
}
shift = bits_size * 8 - curve->num_n_bits;
carry = 0;
ptr = native + num_n_words;
while (ptr-- > native) {
uECC_word_t temp = *ptr;
*ptr = (temp >> shift) | carry;
carry = temp << (uECC_WORD_BITS - shift);
}


if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
uECC_vli_sub(native, native, curve->n, num_n_words);
}
}",[20],The ECDSA operation of the micro-ecc library 1.0 is vulnerable to simple power analysis attacks which allows an adversary to extract the private ECC key.
205163," void RenderBox::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)
 {
     RenderStyle* oldStyle = style();
      if (oldStyle) {
        if (diff >= StyleDifferenceRepaint && node() &&
            (isHTMLHtmlElement(*node()) || isHTMLBodyElement(*node()))) {
         if ((diff.needsRepaint() || diff.needsLayout()) && node()
             && (isHTMLHtmlElement(*node()) || isHTMLBodyElement(*node()))) {
              view()->repaint();
  
              if (oldStyle->hasEntirelyFixedBackground() != newStyle.hasEntirelyFixedBackground())
                 view()->compositor()->setNeedsUpdateFixedBackground();
         }
  
        if (diff == StyleDifferenceLayout && parent() && oldStyle->position() != newStyle.position()) {
         if (diff.needsFullLayout() && parent() && oldStyle->position() != newStyle.position()) {
              markContainingBlocksForLayout();
              if (oldStyle->position() == StaticPosition)
                  repaint();
             else if (newStyle.hasOutOfFlowPosition())
                 parent()->setChildNeedsLayout();
             if (isFloating() && !isOutOfFlowPositioned() && newStyle.hasOutOfFlowPosition())
                 removeFloatingOrPositionedChildFromBlockLists();
         }
     } else if (isBody())
         view()->repaint();
 
     RenderBoxModelObject::styleWillChange(diff, newStyle);
 }","[7, 8, 16, 5, 6, 15]",The Web Audio implementation in Google Chrome before 25.0.1364.152 allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors.
199468," static int snd_ctl_elem_add(struct snd_ctl_file *file,
 			    struct snd_ctl_elem_info *info, int replace)
 {
 	struct snd_card *card = file->card;
 	struct snd_kcontrol kctl, *_kctl;
 	unsigned int access;
 	long private_size;
 	struct user_element *ue;
 	int idx, err;
 
 	if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)
 		return -ENOMEM;
 	if (info->count < 1)
 		return -EINVAL;
 	access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
 		(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|
 				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
 				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
 	info->id.numid = 0;
 	memset(&kctl, 0, sizeof(kctl));
 	down_write(&card->controls_rwsem);
 	_kctl = snd_ctl_find_id(card, &info->id);
 	err = 0;
 	if (_kctl) {
 		if (replace)
 			err = snd_ctl_remove(card, _kctl);
 		else
 			err = -EBUSY;
 	} else {
 		if (replace)
 			err = -ENOENT;
 	}
 	up_write(&card->controls_rwsem);
 	if (err < 0)
 		return err;
 	memcpy(&kctl.id, &info->id, sizeof(info->id));
 	kctl.count = info->owner ? info->owner : 1;
 	access |= SNDRV_CTL_ELEM_ACCESS_USER;
 	if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)
 		kctl.info = snd_ctl_elem_user_enum_info;
 	else
 		kctl.info = snd_ctl_elem_user_info;
 	if (access & SNDRV_CTL_ELEM_ACCESS_READ)
 		kctl.get = snd_ctl_elem_user_get;
 	if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)
 		kctl.put = snd_ctl_elem_user_put;
 	if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {
 		kctl.tlv.c = snd_ctl_elem_user_tlv;
 		access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
 	}
 	switch (info->type) {
 	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
 	case SNDRV_CTL_ELEM_TYPE_INTEGER:
 		private_size = sizeof(long);
 		if (info->count > 128)
 			return -EINVAL;
 		break;
 	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
 		private_size = sizeof(long long);
 		if (info->count > 64)
 			return -EINVAL;
 		break;
 	case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
 		private_size = sizeof(unsigned int);
 		if (info->count > 128 || info->value.enumerated.items == 0)
 			return -EINVAL;
 		break;
 	case SNDRV_CTL_ELEM_TYPE_BYTES:
 		private_size = sizeof(unsigned char);
 		if (info->count > 512)
 			return -EINVAL;
 		break;
 	case SNDRV_CTL_ELEM_TYPE_IEC958:
 		private_size = sizeof(struct snd_aes_iec958);
 		if (info->count != 1)
 			return -EINVAL;
 		break;
 	default:
 		return -EINVAL;
 	}
 	private_size *= info->count;
  	ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);
  	if (ue == NULL)
  		return -ENOMEM;
 	ue->card = card;
  	ue->info = *info;
  	ue->info.access = 0;
  	ue->elem_data = (char *)ue + sizeof(*ue);
 	ue->elem_data_size = private_size;
 	if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
 		err = snd_ctl_elem_init_enum_names(ue);
 		if (err < 0) {
 			kfree(ue);
 			return err;
 		}
 	}
 	kctl.private_free = snd_ctl_elem_user_free;
 	_kctl = snd_ctl_new(&kctl, access);
 	if (_kctl == NULL) {
 		kfree(ue->priv_data);
 		kfree(ue);
 		return -ENOMEM;
 	}
 	_kctl->private_data = ue;
 	for (idx = 0; idx < _kctl->count; idx++)
 		_kctl->vd[idx].owner = file;
 	err = snd_ctl_add(card, _kctl);
 	if (err < 0)
 		return err;
 
 	down_write(&card->controls_rwsem);
 	card->user_ctl_count++;
 	up_write(&card->controls_rwsem);
 
 	return 0;
 }",[85],Race condition in the tlv handler functionality in the snd_ctl_elem_user_tlv function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 allows local users to obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.
204974," xmlParseDocument(xmlParserCtxtPtr ctxt) {
     xmlChar start[4];
     xmlCharEncoding enc;
 
     xmlInitParser();
 
     if ((ctxt == NULL) || (ctxt->input == NULL))
         return(-1);
 
     GROW;
 
      
     xmlDetectSAX2(ctxt);
 
      
      if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))
          ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);
     if (ctxt->instate == XML_PARSER_EOF)
 	return(-1);
  
      if ((ctxt->encoding == (const xmlChar *)XML_CHAR_ENCODING_NONE) &&
          ((ctxt->input->end - ctxt->input->cur) >= 4)) {
 	 
 	start[0] = RAW;
 	start[1] = NXT(1);
 	start[2] = NXT(2);
 	start[3] = NXT(3);
 	enc = xmlDetectCharEncoding(&start[0], 4);
 	if (enc != XML_CHAR_ENCODING_NONE) {
 	    xmlSwitchEncoding(ctxt, enc);
 	}
     }
 
 
     if (CUR == 0) {
 	xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);
     }
 
      
     if ((ctxt->input->end - ctxt->input->cur) < 35) {
        GROW;
     }
     if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {
 
 	 
 	xmlParseXMLDecl(ctxt);
 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 	     
 	    return(-1);
 	}
 	ctxt->standalone = ctxt->input->standalone;
 	SKIP_BLANKS;
     } else {
 	ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);
      }
      if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))
          ctxt->sax->startDocument(ctxt->userData);
     if (ctxt->instate == XML_PARSER_EOF)
 	return(-1);
  
       
     GROW;
     xmlParseMisc(ctxt);
 
      
     GROW;
     if (CMP9(CUR_PTR, '<', '!', 'D', 'O', 'C', 'T', 'Y', 'P', 'E')) {
 
 	ctxt->inSubset = 1;
 	xmlParseDocTypeDecl(ctxt);
  	if (RAW == '[') {
  	    ctxt->instate = XML_PARSER_DTD;
  	    xmlParseInternalSubset(ctxt);
 	    if (ctxt->instate == XML_PARSER_EOF)
 		return(-1);
  	}
  
  	 
 	ctxt->inSubset = 2;
 	if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&
  	    (!ctxt->disableSAX))
  	    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,
  	                              ctxt->extSubSystem, ctxt->extSubURI);
 	if (ctxt->instate == XML_PARSER_EOF)
 	    return(-1);
  	ctxt->inSubset = 0;
  
          xmlCleanSpecialAttr(ctxt);
 
 	ctxt->instate = XML_PARSER_PROLOG;
 	xmlParseMisc(ctxt);
     }
 
      
     GROW;
     if (RAW != '<') {
 	xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,
 		       ""Start tag expected, '<' not found\n"");
     } else {
 	ctxt->instate = XML_PARSER_CONTENT;
 	xmlParseElement(ctxt);
 	ctxt->instate = XML_PARSER_EPILOG;
 
 
 	 
 	xmlParseMisc(ctxt);
 
 	if (RAW != 0) {
 	    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);
 	}
 	ctxt->instate = XML_PARSER_EOF;
     }
 
      
     if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))
         ctxt->sax->endDocument(ctxt->userData);
 
      
     if ((ctxt->myDoc != NULL) &&
 	(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
 	xmlFreeDoc(ctxt->myDoc);
 	ctxt->myDoc = NULL;
     }
 
     if ((ctxt->wellFormed) && (ctxt->myDoc != NULL)) {
         ctxt->myDoc->properties |= XML_DOC_WELLFORMED;
 	if (ctxt->valid)
 	    ctxt->myDoc->properties |= XML_DOC_DTDVALID;
 	if (ctxt->nsWellFormed)
 	    ctxt->myDoc->properties |= XML_DOC_NSVALID;
 	if (ctxt->options & XML_PARSE_OLD10)
 	    ctxt->myDoc->properties |= XML_DOC_OLD10;
     }
     if (! ctxt->wellFormed) {
 	ctxt->valid = 0;
 	return(-1);
     }
     return(0);
 }","[18, 19, 58, 59, 74, 75, 84, 85]","parser.c in libxml2 before 2.9.0, as used in Google Chrome before 28.0.1500.71 and other products, allows remote attackers to cause a denial of service (out-of-bounds read) via a document that ends abruptly, related to the lack of certain checks for the XML_PARSER_EOF state."
198337," static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 {
 	st_entry 			*ent1, *ent2;
 	wddx_stack 			*stack = (wddx_stack *)user_data;
 	HashTable 			*target_hash;
 	zend_class_entry 	**pce;
 	zval				*obj;
 	zval				*tmp;
 	TSRMLS_FETCH();
 
  
 	if (stack->top == 0) {
 		return;
 	}
 
 	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
 		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
 	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
 		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
                 !strcmp(name, EL_DATETIME)) {
                 wddx_stack_top(stack, (void**)&ent1);
  
                if (!ent1->data) {
                        if (stack->top > 1) {
                                stack->top--;
                        } else {
                                stack->done = 1;
                        }
                        efree(ent1);
                        return;
                }
 
                 if (!strcmp(name, EL_BINARY)) {
                         int new_len=0;
                         unsigned char *new_str;
 
 			MAKE_STD_ZVAL(fname);
 			ZVAL_STRING(fname, ""__wakeup"", 1);
 
 			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);
 
 			zval_dtor(fname);
 			FREE_ZVAL(fname);
 			if (retval) {
 				zval_ptr_dtor(&retval);
 			}
 		}
 
 		if (stack->top > 1) {
 			stack->top--;
 			wddx_stack_top(stack, (void**)&ent2);
 
 			 
 			if (ent2->type == ST_FIELD && ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
 			}
 
 			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
 				target_hash = HASH_OF(ent2->data);
 
 				if (ent1->varname) {
 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
 						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
 						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
 						zend_bool incomplete_class = 0;
 
 						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
 						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
 										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
 							incomplete_class = 1;
 							pce = &PHP_IC_ENTRY;
 						}
 
 						 
 						MAKE_STD_ZVAL(obj);
 						object_init_ex(obj, *pce);
 
 						 
 						zend_hash_merge(Z_OBJPROP_P(obj),
 										Z_ARRVAL_P(ent2->data),
 										(void (*)(void *)) zval_add_ref,
 										(void *) &tmp, sizeof(zval *), 0);
 
 						if (incomplete_class) {
 							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
 						}
 
 						 
 						zval_ptr_dtor(&ent2->data);
 
 						 
 						ent2->data = obj;
 
 						 
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
 						zend_class_entry *old_scope = EG(scope);
 
 						EG(scope) = Z_OBJCE_P(ent2->data);
 						Z_DELREF_P(ent1->data);
 						add_property_zval(ent2->data, ent1->varname, ent1->data);
 						EG(scope) = old_scope;
 					} else {
 						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
 					}
 					efree(ent1->varname);
 				} else	{
 					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
 				}
 			}
 			efree(ent1);
 		} else {
 			stack->done = 1;
 		}
 	} else if (!strcmp(name, EL_VAR) && stack->varname) {
 		efree(stack->varname);
 	} else if (!strcmp(name, EL_FIELD)) {
 		st_entry *ent;
 		wddx_stack_top(stack, (void **)&ent);
 		efree(ent);
 		stack->top--;
 	}
 }","[23, 24, 25, 26, 27, 28, 29, 30, 31, 32]",Use-after-free vulnerability in wddx.c in the WDDX extension in PHP before 5.5.33 and 5.6.x before 5.6.19 allows remote attackers to cause a denial of service (memory corruption and application crash) or possibly have unspecified other impact by triggering a wddx_deserialize call on XML data containing a crafted var element.
202284," static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
 			     struct mschmd_header *chm, int entire)
 {
   unsigned int section, name_len, x, errors, num_chunks;
   unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;
   struct mschmd_file *fi, *link = NULL;
   off_t offset, length;
   int num_entries;
 
    
   chm->files         = NULL;
   chm->sysfiles      = NULL;
   chm->chunk_cache   = NULL;
   chm->sec0.base.chm = chm;
   chm->sec0.base.id  = 0;
   chm->sec1.base.chm = chm;
   chm->sec1.base.id  = 1;
   chm->sec1.content  = NULL;
   chm->sec1.control  = NULL;
   chm->sec1.spaninfo = NULL;
   chm->sec1.rtable   = NULL;
 
    
   if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
    
   if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {
     return MSPACK_ERR_SIGNATURE;
   }
 
    
   if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {
     D((""incorrect GUIDs""))
     return MSPACK_ERR_SIGNATURE;
   }
 
   chm->version   = EndGetI32(&buf[chmhead_Version]);
   chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);
   chm->language  = EndGetI32(&buf[chmhead_LanguageID]);
   if (chm->version > 3) {
     sys->message(fh, ""WARNING; CHM version > 3"");
   }
 
    
   if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
    
   if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||
       read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||
       read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))
   {
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {
     return MSPACK_ERR_SEEK;
   }
 
    
   if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {
     return MSPACK_ERR_READ;
   }
   if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {
     return MSPACK_ERR_SEEK;
   }
 
    
   if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
   chm->dir_offset = sys->tell(fh);
   chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);
   chm->density    = EndGetI32(&buf[chmhs1_Density]);
   chm->depth      = EndGetI32(&buf[chmhs1_Depth]);
   chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);
   chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);
   chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);
   chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);
 
   if (chm->version < 3) {
      
     chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);
   }
 
    
   if (chm->sec0.offset > chm->length) {
     D((""content section begins after file has ended""))
     return MSPACK_ERR_DATAFORMAT;
   }
   
    
   if (chm->chunk_size < (pmgl_Entries + 2)) {
     D((""chunk size not large enough""))
     return MSPACK_ERR_DATAFORMAT;
   }
   if (chm->num_chunks == 0) {
     D((""no chunks""))
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (chm->num_chunks > 100000) {
     D((""more than 100,000 chunks""))
     return MSPACK_ERR_DATAFORMAT;
   }   
   if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {
     D((""chunks larger than entire file""))
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {
     sys->message(fh, ""WARNING; chunk size is not a power of two"");
   }
   if (chm->first_pmgl != 0) {
     sys->message(fh, ""WARNING; first PMGL chunk is not zero"");
   }
   if (chm->first_pmgl > chm->last_pmgl) {
      D((""first pmgl chunk is after last pmgl chunk""))
      return MSPACK_ERR_DATAFORMAT;
    }
  if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) {
   if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {
      D((""index_root outside valid range""))
      return MSPACK_ERR_DATAFORMAT;
    }
 
    
   if (!entire) {
     return MSPACK_ERR_OK;
   }
 
    
   if ((x = chm->first_pmgl) != 0) {
     if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {
       return MSPACK_ERR_SEEK;
     }
   }
   num_chunks = chm->last_pmgl - x + 1;
 
   if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {
     return MSPACK_ERR_NOMEMORY;
   }
 
    
   errors = 0;
   while (num_chunks--) {
      
     if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {
       sys->free(chunk);
       return MSPACK_ERR_READ;
     }
 
      
     if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;
 
     if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {
       sys->message(fh, ""WARNING; PMGL quickref area is too small"");
     }
     if (EndGetI32(&chunk[pmgl_QuickRefSize]) > 
 	((int)chm->chunk_size - pmgl_Entries))
     {
       sys->message(fh, ""WARNING; PMGL quickref area is too large"");
     }
 
     p = &chunk[pmgl_Entries];
     end = &chunk[chm->chunk_size - 2];
     num_entries = EndGetI16(end);
 
      while (num_entries--) {
        READ_ENCINT(name_len);
        if (name_len > (unsigned int) (end - p)) goto chunk_end;
        
       if (name_len == 0) goto chunk_end;
        name = p; p += name_len;
 
        READ_ENCINT(section);
        READ_ENCINT(offset);
        READ_ENCINT(length);
 
        
       if ((offset == 0) && (length == 0)) {
 	if ((name_len > 0) && (name[name_len-1] == '/')) continue;
       }
 
       if (section > 1) {
 	sys->message(fh, ""invalid section number '%u'."", section);
 	continue;
       }
 
       if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {
 	sys->free(chunk);
 	return MSPACK_ERR_NOMEMORY;
       }
 
       fi->next     = NULL;
       fi->filename = (char *) &fi[1];
       fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)
 		                     : (struct mschmd_section *) (&chm->sec1));
       fi->offset   = offset;
       fi->length   = length;
       sys->copy(name, fi->filename, (size_t) name_len);
       fi->filename[name_len] = '\0';
 
       if (name[0] == ':' && name[1] == ':') {
 	 
 	if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {
 	  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {
 	    chm->sec1.content = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {
 	    chm->sec1.control = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {
 	    chm->sec1.spaninfo = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {
 	    chm->sec1.rtable = fi;
 	  }
 	}
 	fi->next = chm->sysfiles;
 	chm->sysfiles = fi;
       }
       else {
 	 
 	if (link) link->next = fi; else chm->files = fi;
 	link = fi;
       }
     }
 
      
   chunk_end:
     if (num_entries >= 0) {
       D((""chunk ended before all entries could be read""))
       errors++;
     }
 
   }
   sys->free(chunk);
   return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;
 }","[134, 184, 185, 187, 133]",An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. It does not reject blank CHM filenames.
10003,"TEST_F(QuantizedMatMulTest, VerySmall_BadRange) {


const bool transpose_a = true;
const int a_rows = 1;
const int a_cols = 1;
const int b_rows = 1;
const int b_cols = 1;
const bool transpose_b = false;
TF_ASSERT_OK(NodeDefBuilder(""quantized_mat_mul_op"", ""QuantizedMatMul"")
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_QUINT8))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Input(FakeInput(DT_FLOAT))
.Attr(""Toutput"", DataTypeToEnum<qint32>::v())
.Attr(""transpose_a"", transpose_a)
.Attr(""transpose_b"", transpose_b)
.Finalize(node_def()));
TF_ASSERT_OK(InitOp());


AddInputFromArray<quint8>(TensorShape({a_rows, a_cols}), {11});



AddInputFromArray<quint8>(TensorShape({b_rows, b_cols}), {0});
AddInputFromArray<float>(TensorShape({1}), {-12.0f});
AddInputFromArray<float>(TensorShape({1}), {243.0f});


AddInputFromArray<float>(TensorShape({1}), {1.0f});
AddInputFromArray<float>(TensorShape({1}), {1.0f});
EXPECT_EQ(::tensorflow::error::INVALID_ARGUMENT, RunOpKernel().code());
}","[29, 30, 33, 34]","TensorFlow is an open source platform for machine learning. If `QuantizedMatMul` is given nonscalar input for: `min_a`, `max_a`, `min_b`, or `max_b` It gives a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit aca766ac7693bf29ed0df55ad6bfcc78f35e7f48. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
201001," bgp_attr_print(netdissect_options *ndo,
                u_int atype, const u_char *pptr, u_int len)
 {
 	int i;
 	uint16_t af;
 	uint8_t safi, snpa, nhlen;
         union {  
             float f;
             uint32_t i;
         } bw;
 	int advance;
 	u_int tlen;
 	const u_char *tptr;
 	char buf[MAXHOSTNAMELEN + 100];
         int  as_size;
 
         tptr = pptr;
         tlen=len;
 
 	switch (atype) {
 	case BGPTYPE_ORIGIN:
 		if (len != 1)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK(*tptr);
 			ND_PRINT((ndo, ""%s"", tok2str(bgp_origin_values,
 						""Unknown Origin Typecode"",
 						tptr[0])));
 		}
 		break;
 
          
 	case BGPTYPE_AS4_PATH:
 	case BGPTYPE_AS_PATH:
 		if (len % 2) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 if (!len) {
 			ND_PRINT((ndo, ""empty""));
 			break;
                 }
 
                  
                 as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);
 
 		while (tptr < pptr + len) {
 			ND_TCHECK(tptr[0]);
                         ND_PRINT((ndo, ""%s"", tok2str(bgp_as_path_segment_open_values,
 						""?"", tptr[0])));
 			ND_TCHECK(tptr[1]);
                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
                             ND_TCHECK2(tptr[2 + i], as_size);
 			    ND_PRINT((ndo, ""%s "",
 				as_printf(ndo, astostr, sizeof(astostr),
 				as_size == 2 ?
 				EXTRACT_16BITS(&tptr[2 + i]) :
 				EXTRACT_32BITS(&tptr[2 + i]))));
                         }
 			ND_TCHECK(tptr[0]);
                         ND_PRINT((ndo, ""%s"", tok2str(bgp_as_path_segment_close_values,
 						""?"", tptr[0])));
                         ND_TCHECK(tptr[1]);
                         tptr += 2 + tptr[1] * as_size;
 		}
 		break;
 	case BGPTYPE_NEXT_HOP:
 		if (len != 4)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK2(tptr[0], 4);
 			ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr)));
 		}
 		break;
 	case BGPTYPE_MULTI_EXIT_DISC:
 	case BGPTYPE_LOCAL_PREF:
 		if (len != 4)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK2(tptr[0], 4);
 			ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(tptr)));
 		}
 		break;
 	case BGPTYPE_ATOMIC_AGGREGATE:
 		if (len != 0)
 			ND_PRINT((ndo, ""invalid len""));
 		break;
         case BGPTYPE_AGGREGATOR:
 
                  
                 if (len != 6 && len != 8) {
                     ND_PRINT((ndo, ""invalid len""));
                     break;
                 }
                 ND_TCHECK2(tptr[0], len);
                 if (len == 6) {
 		    ND_PRINT((ndo, "" AS #%s, origin %s"",
 			as_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),
 			ipaddr_string(ndo, tptr + 2)));
                 } else {
 		    ND_PRINT((ndo, "" AS #%s, origin %s"",
 			as_printf(ndo, astostr, sizeof(astostr),
 			EXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));
                 }
                 break;
 	case BGPTYPE_AGGREGATOR4:
 		if (len != 8) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_TCHECK2(tptr[0], 8);
 		ND_PRINT((ndo, "" AS #%s, origin %s"",
 	   	    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),
 		    ipaddr_string(ndo, tptr + 4)));
 		break;
 	case BGPTYPE_COMMUNITIES:
 		if (len % 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		while (tlen>0) {
 			uint32_t comm;
 			ND_TCHECK2(tptr[0], 4);
 			comm = EXTRACT_32BITS(tptr);
 			switch (comm) {
 			case BGP_COMMUNITY_NO_EXPORT:
 				ND_PRINT((ndo, "" NO_EXPORT""));
 				break;
 			case BGP_COMMUNITY_NO_ADVERT:
 				ND_PRINT((ndo, "" NO_ADVERTISE""));
 				break;
 			case BGP_COMMUNITY_NO_EXPORT_SUBCONFED:
 				ND_PRINT((ndo, "" NO_EXPORT_SUBCONFED""));
 				break;
 			default:
 				ND_PRINT((ndo, ""%u:%u%s"",
                                        (comm >> 16) & 0xffff,
                                        comm & 0xffff,
                                        (tlen>4) ? "", "" : """"));
 				break;
 			}
                         tlen -=4;
                         tptr +=4;
 		}
 		break;
         case BGPTYPE_ORIGINATOR_ID:
 		if (len != 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_TCHECK2(tptr[0], 4);
                 ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, tptr)));
                 break;
         case BGPTYPE_CLUSTER_LIST:
 		if (len % 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 while (tlen>0) {
 			ND_TCHECK2(tptr[0], 4);
                         ND_PRINT((ndo, ""%s%s"",
                                ipaddr_string(ndo, tptr),
                                 (tlen>4) ? "", "" : """"));
                         tlen -=4;
                         tptr +=4;
                 }
                 break;
 	case BGPTYPE_MP_REACH_NLRI:
 		ND_TCHECK2(tptr[0], 3);
 		af = EXTRACT_16BITS(tptr);
 		safi = tptr[2];
 
                 ND_PRINT((ndo, ""\n\t    AFI: %s (%u), %sSAFI: %s (%u)"",
                        tok2str(af_values, ""Unknown AFI"", af),
                        af,
                        (safi>128) ? ""vendor specific "" : """",  
                        tok2str(bgp_safi_values, ""Unknown SAFI"", safi),
                        safi));
 
                 switch(af<<8 | safi) {
                 case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                 case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):
 		case (AFNUM_INET<<8 | SAFNUM_MDT):
                 case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     break;
                 default:
                     ND_TCHECK2(tptr[0], tlen);
                     ND_PRINT((ndo, ""\n\t    no AFI %u / SAFI %u decoder"", af, safi));
                     if (ndo->ndo_vflag <= 1)
                         print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                     goto done;
                     break;
                 }
 
                 tptr +=3;
 
 		ND_TCHECK(tptr[0]);
 		nhlen = tptr[0];
                 tlen = nhlen;
                 tptr++;
 
 		if (tlen) {
                     int nnh = 0;
                     ND_PRINT((ndo, ""\n\t    nexthop: ""));
                     while (tlen > 0) {
                         if ( nnh++ > 0 ) {
                             ND_PRINT((ndo,  "", "" ));
                         }
                         switch(af<<8 | safi) {
                         case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                         case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):
                         case (AFNUM_INET<<8 | SAFNUM_MDT):
 			    if (tlen < (int)sizeof(struct in_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr));
                                 ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, tptr)));
                                 tlen -= sizeof(struct in_addr);
                                 tptr += sizeof(struct in_addr);
                             }
                             break;
                         case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));
                                 tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                                 tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                             }
                             break;
                         case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                             if (tlen < (int)sizeof(struct in6_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in6_addr));
                                 ND_PRINT((ndo, ""%s"", ip6addr_string(ndo, tptr)));
                                 tlen -= sizeof(struct in6_addr);
                                 tptr += sizeof(struct in6_addr);
                             }
                             break;
                         case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));
                                 tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                                 tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                             }
                             break;
                         case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)sizeof(struct in_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr));
                                 ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr)));
                                 tlen -= (sizeof(struct in_addr));
                                 tptr += (sizeof(struct in_addr));
                             }
                             break;
                         case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                             ND_TCHECK2(tptr[0], tlen);
                             ND_PRINT((ndo, ""%s"", isonsap_string(ndo, tptr, tlen)));
                             tptr += tlen;
                             tlen = 0;
                             break;
 
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < BGP_VPN_RD_LEN+1) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], tlen);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));
                                  
                                 if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
                                     ND_PRINT((ndo, "" = %s"", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));
                                  
                                 else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
                                     ND_PRINT((ndo, "" = %s"", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));
                                 tptr += tlen;
                                 tlen = 0;
                             }
                             break;
                         default:
                             ND_TCHECK2(tptr[0], tlen);
                             ND_PRINT((ndo, ""no AFI %u/SAFI %u decoder"", af, safi));
                             if (ndo->ndo_vflag <= 1)
                                 print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                             tptr += tlen;
                             tlen = 0;
                             goto done;
                             break;
                         }
                     }
 		}
 		ND_PRINT((ndo, "", nh-length: %u"", nhlen));
 		tptr += tlen;
 
 		ND_TCHECK(tptr[0]);
 		snpa = tptr[0];
 		tptr++;
 
 		if (snpa) {
 			ND_PRINT((ndo, ""\n\t    %u SNPA"", snpa));
 			for ( ; snpa > 0; snpa--) {
 				ND_TCHECK(tptr[0]);
 				ND_PRINT((ndo, ""\n\t      %d bytes"", tptr[0]));
 				tptr += tptr[0] + 1;
 			}
 		} else {
 			ND_PRINT((ndo, "", no SNPA""));
                 }
 
 		while (tptr < pptr + len) {
                     switch (af<<8 | safi) {
                     case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                         advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):  
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):
                         advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
 
 		    case (AFNUM_INET<<8 | SAFNUM_MDT):
 		      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));
 		      if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
 		       break;
                     case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     default:
                         ND_TCHECK2(*tptr,tlen);
                         ND_PRINT((ndo, ""\n\t    no AFI %u / SAFI %u decoder"", af, safi));
                         if (ndo->ndo_vflag <= 1)
                             print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                         advance = 0;
                         tptr = pptr + len;
                         break;
                     }
                     if (advance < 0)
                         break;
                     tptr += advance;
 		}
         done:
 		break;
 
 	case BGPTYPE_MP_UNREACH_NLRI:
 		ND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);
 		af = EXTRACT_16BITS(tptr);
 		safi = tptr[2];
 
                 ND_PRINT((ndo, ""\n\t    AFI: %s (%u), %sSAFI: %s (%u)"",
                        tok2str(af_values, ""Unknown AFI"", af),
                        af,
                        (safi>128) ? ""vendor specific "" : """",  
                        tok2str(bgp_safi_values, ""Unknown SAFI"", safi),
                        safi));
 
                 if (len == BGP_MP_NLRI_MINSIZE)
                     ND_PRINT((ndo, ""\n\t      End-of-Rib Marker (empty NLRI)""));
 
 		tptr += 3;
 
 		while (tptr < pptr + len) {
                     switch (af<<8 | safi) {
                     case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
 		    case (AFNUM_INET<<8 | SAFNUM_MDT):
 		      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));
 		      if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
 		       break;
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):  
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):
                         advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     default:
                         ND_TCHECK2(*(tptr-3),tlen);
                         ND_PRINT((ndo, ""no AFI %u / SAFI %u decoder"", af, safi));
                         if (ndo->ndo_vflag <= 1)
                             print_unknown_data(ndo, tptr-3, ""\n\t    "", tlen);
                         advance = 0;
                         tptr = pptr + len;
                         break;
                     }
                     if (advance < 0)
                         break;
                     tptr += advance;
 		}
 		break;
         case BGPTYPE_EXTD_COMMUNITIES:
 		if (len % 8) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 while (tlen>0) {
                     uint16_t extd_comm;
 
                     ND_TCHECK2(tptr[0], 2);
                     extd_comm=EXTRACT_16BITS(tptr);
 
 		    ND_PRINT((ndo, ""\n\t    %s (0x%04x), Flags [%s]"",
 			   tok2str(bgp_extd_comm_subtype_values,
 				      ""unknown extd community typecode"",
 				      extd_comm),
 			   extd_comm,
 			   bittok2str(bgp_extd_comm_flag_values, ""none"", extd_comm)));
 
                     ND_TCHECK2(*(tptr+2), 6);
                     switch(extd_comm) {
                     case BGP_EXT_COM_RT_0:
                     case BGP_EXT_COM_RO_0:
                     case BGP_EXT_COM_L2VPN_RT_0:
                         ND_PRINT((ndo, "": %u:%u (= %s)"",
                                EXTRACT_16BITS(tptr+2),
                                EXTRACT_32BITS(tptr+4),
                                ipaddr_string(ndo, tptr+4)));
                         break;
                     case BGP_EXT_COM_RT_1:
                     case BGP_EXT_COM_RO_1:
                     case BGP_EXT_COM_L2VPN_RT_1:
                     case BGP_EXT_COM_VRF_RT_IMP:
                         ND_PRINT((ndo, "": %s:%u"",
                                ipaddr_string(ndo, tptr+2),
                                EXTRACT_16BITS(tptr+6)));
                         break;
                     case BGP_EXT_COM_RT_2:
                     case BGP_EXT_COM_RO_2:
 			ND_PRINT((ndo, "": %s:%u"",
 			    as_printf(ndo, astostr, sizeof(astostr),
 			    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));
 			break;
                     case BGP_EXT_COM_LINKBAND:
 		        bw.i = EXTRACT_32BITS(tptr+2);
                         ND_PRINT((ndo, "": bandwidth: %.3f Mbps"",
                                bw.f*8/1000000));
                         break;
                     case BGP_EXT_COM_VPN_ORIGIN:
                     case BGP_EXT_COM_VPN_ORIGIN2:
                     case BGP_EXT_COM_VPN_ORIGIN3:
                     case BGP_EXT_COM_VPN_ORIGIN4:
                     case BGP_EXT_COM_OSPF_RID:
                     case BGP_EXT_COM_OSPF_RID2:
                         ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr+2)));
                         break;
                     case BGP_EXT_COM_OSPF_RTYPE:
                     case BGP_EXT_COM_OSPF_RTYPE2:
                         ND_PRINT((ndo, "": area:%s, router-type:%s, metric-type:%s%s"",
                                ipaddr_string(ndo, tptr+2),
                                tok2str(bgp_extd_comm_ospf_rtype_values,
 					  ""unknown (0x%02x)"",
 					  *(tptr+6)),
                                (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? ""E2"" : """",
                                ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? ""E1"" : """"));
                         break;
                     case BGP_EXT_COM_L2INFO:
                         ND_PRINT((ndo, "": %s Control Flags [0x%02x]:MTU %u"",
                                tok2str(l2vpn_encaps_values,
 					  ""unknown encaps"",
 					  *(tptr+2)),
                                        *(tptr+3),
                                EXTRACT_16BITS(tptr+4)));
                         break;
                     case BGP_EXT_COM_SOURCE_AS:
                         ND_PRINT((ndo, "": AS %u"", EXTRACT_16BITS(tptr+2)));
                         break;
                     default:
                         ND_TCHECK2(*tptr,8);
                         print_unknown_data(ndo, tptr, ""\n\t      "", 8);
                         break;
                     }
                     tlen -=8;
                     tptr +=8;
                 }
                 break;
 
         case BGPTYPE_PMSI_TUNNEL:
          {
                  uint8_t tunnel_type, flags;
  
                 ND_TCHECK2(tptr[0], 5);
                  tunnel_type = *(tptr+1);
                  flags = *tptr;
                  tlen = len;
  
                ND_TCHECK2(tptr[0], 5);
                  ND_PRINT((ndo, ""\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u"",
                         tok2str(bgp_pmsi_tunnel_values, ""Unknown"", tunnel_type),
                         tunnel_type,
                        bittok2str(bgp_pmsi_flag_values, ""none"", flags),
                        EXTRACT_24BITS(tptr+2)>>4));
 
                 tptr +=5;
                 tlen -= 5;
 
                 switch (tunnel_type) {
                 case BGP_PMSI_TUNNEL_PIM_SM:  
                 case BGP_PMSI_TUNNEL_PIM_BIDIR:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Sender %s, P-Group %s"",
                            ipaddr_string(ndo, tptr),
                            ipaddr_string(ndo, tptr+4)));
                     break;
 
                 case BGP_PMSI_TUNNEL_PIM_SSM:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Root-Node %s, P-Group %s"",
                            ipaddr_string(ndo, tptr),
                            ipaddr_string(ndo, tptr+4)));
                     break;
                 case BGP_PMSI_TUNNEL_INGRESS:
                     ND_TCHECK2(tptr[0], 4);
                     ND_PRINT((ndo, ""\n\t      Tunnel-Endpoint %s"",
                            ipaddr_string(ndo, tptr)));
                     break;
                 case BGP_PMSI_TUNNEL_LDP_P2MP:  
                 case BGP_PMSI_TUNNEL_LDP_MP2MP:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Root-Node %s, LSP-ID 0x%08x"",
                            ipaddr_string(ndo, tptr),
                            EXTRACT_32BITS(tptr+4)));
                     break;
                 case BGP_PMSI_TUNNEL_RSVP_P2MP:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x"",
                            ipaddr_string(ndo, tptr),
                            EXTRACT_32BITS(tptr+4)));
                     break;
                 default:
                     if (ndo->ndo_vflag <= 1) {
                         print_unknown_data(ndo, tptr, ""\n\t      "", tlen);
                     }
                 }
                 break;
         }
 	case BGPTYPE_AIGP:
 	{
 		uint8_t type;
 		uint16_t length;
 
 		tlen = len;
 
 		while (tlen >= 3) {
 
 		    ND_TCHECK2(tptr[0], 3);
 
 		    type = *tptr;
 		    length = EXTRACT_16BITS(tptr+1);
 		    tptr += 3;
 		    tlen -= 3;
 
 		    ND_PRINT((ndo, ""\n\t    %s TLV (%u), length %u"",
 			      tok2str(bgp_aigp_values, ""Unknown"", type),
 			      type, length));
 
 		    if (length < 3)
 			goto trunc;
 		    length -= 3;
 
 		     
 		    ND_TCHECK2(tptr[3], length);
 
 		    switch (type) {
 
 		    case BGP_AIGP_TLV:
 		        if (length < 8)
 		            goto trunc;
 			ND_PRINT((ndo, "", metric %"" PRIu64,
 				  EXTRACT_64BITS(tptr)));
 			break;
 
 		    default:
 			if (ndo->ndo_vflag <= 1) {
 			    print_unknown_data(ndo, tptr,""\n\t      "", length);
 			}
 		    }
 
 		    tptr += length;
 		    tlen -= length;
 		}
 		break;
 	}
         case BGPTYPE_ATTR_SET:
                 ND_TCHECK2(tptr[0], 4);
                 if (len < 4)
                 	goto trunc;
 		ND_PRINT((ndo, ""\n\t    Origin AS: %s"",
 		    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));
 		tptr+=4;
                 len -=4;
 
                 while (len) {
                     u_int aflags, alenlen, alen;
 
                     ND_TCHECK2(tptr[0], 2);
                     if (len < 2)
                         goto trunc;
                     aflags = *tptr;
                     atype = *(tptr + 1);
                     tptr += 2;
                     len -= 2;
                     alenlen = bgp_attr_lenlen(aflags, tptr);
                     ND_TCHECK2(tptr[0], alenlen);
                     if (len < alenlen)
                         goto trunc;
                     alen = bgp_attr_len(aflags, tptr);
                     tptr += alenlen;
                     len -= alenlen;
 
                     ND_PRINT((ndo, ""\n\t      %s (%u), length: %u"",
                            tok2str(bgp_attr_values,
                                       ""Unknown Attribute"", atype),
                            atype,
                            alen));
 
                     if (aflags) {
                         ND_PRINT((ndo, "", Flags [%s%s%s%s"",
                                aflags & 0x80 ? ""O"" : """",
                                aflags & 0x40 ? ""T"" : """",
                                aflags & 0x20 ? ""P"" : """",
                                aflags & 0x10 ? ""E"" : """"));
                         if (aflags & 0xf)
                             ND_PRINT((ndo, ""+%x"", aflags & 0xf));
                         ND_PRINT((ndo, ""]: ""));
                     }
                      
                     if (!bgp_attr_print(ndo, atype, tptr, alen))
                         return 0;
                     tptr += alen;
                     len -= alen;
 		}
                 break;
 
 	case BGPTYPE_LARGE_COMMUNITY:
 		if (len == 0 || len % 12) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_PRINT((ndo, ""\n\t    ""));
 		while (len > 0) {
 			ND_TCHECK2(*tptr, 12);
 			ND_PRINT((ndo, ""%u:%u:%u%s"",
 				 EXTRACT_32BITS(tptr),
 				 EXTRACT_32BITS(tptr + 4),
 				 EXTRACT_32BITS(tptr + 8),
 				 (len > 12) ? "", "" : """"));
                         tptr += 12;
                         len -= 12;
 		}
 		break;
 	default:
 	    ND_TCHECK2(*pptr,len);
             ND_PRINT((ndo, ""\n\t    no Attribute %u decoder"", atype));  
             if (ndo->ndo_vflag <= 1)
                 print_unknown_data(ndo, pptr, ""\n\t    "", len);
             break;
 	}
         if (ndo->ndo_vflag > 1 && len) {  
             ND_TCHECK2(*pptr,len);
             print_unknown_data(ndo, pptr, ""\n\t    "", len);
         }
         return 1;
 
 trunc:
         return 0;
 }","[765, 770]",The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().
203195," static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   const char
     *option;
 
   Image
     *image;
 
   int
     jp2_status;
 
   MagickBooleanType
     status;
 
   opj_codec_t
     *jp2_codec;
 
   opj_codestream_index_t
     *codestream_index = (opj_codestream_index_t *) NULL;
 
   opj_dparameters_t
     parameters;
 
   opj_image_t
     *jp2_image;
 
   opj_stream_t
     *jp2_stream;
 
   register ssize_t
     i;
 
   ssize_t
     y;
 
   unsigned char
     sans[4];
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   if (ReadBlob(image,4,sans) != 4)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   (void) SeekBlob(image,SEEK_SET,0);
   if (LocaleCompare(image_info->magick,""JPT"") == 0)
     jp2_codec=opj_create_decompress(OPJ_CODEC_JPT);
   else
     if (IsJ2K(sans,4) != MagickFalse)
       jp2_codec=opj_create_decompress(OPJ_CODEC_J2K);
     else
       jp2_codec=opj_create_decompress(OPJ_CODEC_JP2);
   opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);
   opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);
   opj_set_default_decoder_parameters(&parameters);
   option=GetImageOption(image_info,""jp2:reduce-factor"");
   if (option != (const char *) NULL)
     parameters.cp_reduce=StringToInteger(option);
   option=GetImageOption(image_info,""jp2:quality-layers"");
   if (option == (const char *) NULL)
     option=GetImageOption(image_info,""jp2:layer-number"");
   if (option != (const char *) NULL)
     parameters.cp_layer=StringToInteger(option);
   if (opj_setup_decoder(jp2_codec,&parameters) == 0)
     {
       opj_destroy_codec(jp2_codec);
       ThrowReaderException(DelegateError,""UnableToManageJP2Stream"");
     }
   jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE);
   opj_stream_set_read_function(jp2_stream,JP2ReadHandler);
   opj_stream_set_write_function(jp2_stream,JP2WriteHandler);
   opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);
   opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);
   opj_stream_set_user_data(jp2_stream,image,NULL);
   opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image));
   if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0)
     {
       opj_stream_destroy(jp2_stream);
       opj_destroy_codec(jp2_codec);
       ThrowReaderException(DelegateError,""UnableToDecodeImageFile"");
     }
   jp2_status=1;
   if ((image->columns != 0) && (image->rows != 0))
     {
        
       jp2_status=opj_set_decode_area(jp2_codec,jp2_image,
         (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y,
         (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns,
         (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows);
       if (jp2_status == 0)
         {
           opj_stream_destroy(jp2_stream);
           opj_destroy_codec(jp2_codec);
           opj_image_destroy(jp2_image);
           ThrowReaderException(DelegateError,""UnableToDecodeImageFile"");
         }
     }
   if ((image_info->number_scenes != 0) && (image_info->scene != 0))
     jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image,
       (unsigned int) image_info->scene-1);
   else
     if (image->ping == MagickFalse)
       {
         jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image);
         if (jp2_status != 0)
           jp2_status=opj_end_decompress(jp2_codec,jp2_stream);
       }
   if (jp2_status == 0)
     {
       opj_stream_destroy(jp2_stream);
       opj_destroy_codec(jp2_codec);
       opj_image_destroy(jp2_image);
       ThrowReaderException(DelegateError,""UnableToDecodeImageFile"");
     }
    opj_stream_destroy(jp2_stream);
    for (i=0; i < (ssize_t) jp2_image->numcomps; i++)
    {
    if ((jp2_image->comps[i].dx == 0) || (jp2_image->comps[i].dy == 0))
     if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||
         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||
         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||
         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||
         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))
        {
          opj_destroy_codec(jp2_codec);
          opj_image_destroy(jp2_image);
         ThrowReaderException(CoderError,""IrregularChannelGeometryNotSupported"")
       }
   }
    
   image->columns=(size_t) jp2_image->comps[0].w;
   image->rows=(size_t) jp2_image->comps[0].h;
   image->depth=jp2_image->comps[0].prec;
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
   image->compression=JPEG2000Compression;
   if (jp2_image->color_space == 2)
     {
       SetImageColorspace(image,GRAYColorspace);
       if (jp2_image->numcomps > 1)
         image->matte=MagickTrue;
     }
   else
     if (jp2_image->color_space == 3)
       SetImageColorspace(image,Rec601YCbCrColorspace);
   if (jp2_image->numcomps > 3)
     image->matte=MagickTrue;
   if (jp2_image->icc_profile_buf != (unsigned char *) NULL)
     {
       StringInfo
         *profile;
 
       profile=BlobToStringInfo(jp2_image->icc_profile_buf,
         jp2_image->icc_profile_len);
       if (profile != (StringInfo *) NULL)
         SetImageProfile(image,""icc"",profile);
     }
   if (image->ping != MagickFalse)
     {
       opj_destroy_codec(jp2_codec);
       opj_image_destroy(jp2_image);
       opj_destroy_cstr_index(&codestream_index);
       return(GetFirstImageInList(image));
     }
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register PixelPacket
       *magick_restrict q;
 
     register ssize_t
       x;
 
     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       register ssize_t
         i;
 
       for (i=0; i < (ssize_t) jp2_image->numcomps; i++)
       {
         double
           pixel,
           scale;
 
         scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1);
         pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy*
           image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+
           (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0));
         switch (i)
         {
            case 0:
            {
              q->red=ClampToQuantum(pixel);
              q->green=q->red;
              q->blue=q->red;
              q->opacity=OpaqueOpacity;
              break;
            }
            case 1:
            {
              if (jp2_image->numcomps == 2)
                {
                  q->opacity=ClampToQuantum(QuantumRange-pixel);
                  break;
                }
              q->green=ClampToQuantum(pixel);
              break;
            }
            case 2:
            {
              q->blue=ClampToQuantum(pixel);
              break;
            }
            case 3:
            {
              q->opacity=ClampToQuantum(QuantumRange-pixel);
              break;
            }
         }
       }
       q++;
     }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       break;
   }
    
   opj_destroy_codec(jp2_codec);
   opj_image_destroy(jp2_image);
   opj_destroy_cstr_index(&codestream_index);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[134, 135, 136, 137, 138, 133]","In ImageMagick before 6.9.8-8 and 7.x before 7.0.5-9, the ReadJP2Image function in coders/jp2.c does not properly validate the channel geometry, leading to a crash."
200487," iperf_on_connect(struct iperf_test *test)
 {
     time_t now_secs;
     const char* rfc1123_fmt = ""%a, %d %b %Y %H:%M:%S GMT"";
     char now_str[100];
     char ipr[INET6_ADDRSTRLEN];
     int port;
     struct sockaddr_storage sa;
     struct sockaddr_in *sa_inP;
     struct sockaddr_in6 *sa_in6P;
     socklen_t len;
     int opt;
 
     now_secs = time((time_t*) 0);
     (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&now_secs));
     if (test->json_output)
 	cJSON_AddItemToObject(test->json_start, ""timestamp"", iperf_json_printf(""time: %s  timesecs: %d"", now_str, (int64_t) now_secs));
     else if (test->verbose)
 	iprintf(test, report_time, now_str);
 
     if (test->role == 'c') {
 	if (test->json_output)
 	    cJSON_AddItemToObject(test->json_start, ""connecting_to"", iperf_json_printf(""host: %s  port: %d"", test->server_hostname, (int64_t) test->server_port));
 	else {
 	    iprintf(test, report_connecting, test->server_hostname, test->server_port);
 	    if (test->reverse)
 		iprintf(test, report_reverse, test->server_hostname);
 	}
     } else {
         len = sizeof(sa);
         getpeername(test->ctrl_sck, (struct sockaddr *) &sa, &len);
         if (getsockdomain(test->ctrl_sck) == AF_INET) {
 	    sa_inP = (struct sockaddr_in *) &sa;
             inet_ntop(AF_INET, &sa_inP->sin_addr, ipr, sizeof(ipr));
 	    port = ntohs(sa_inP->sin_port);
         } else {
 	    sa_in6P = (struct sockaddr_in6 *) &sa;
             inet_ntop(AF_INET6, &sa_in6P->sin6_addr, ipr, sizeof(ipr));
 	    port = ntohs(sa_in6P->sin6_port);
         }
 	mapped_v4_to_regular_v4(ipr);
 	if (test->json_output)
 	    cJSON_AddItemToObject(test->json_start, ""accepted_connection"", iperf_json_printf(""host: %s  port: %d"", ipr, (int64_t) port));
 	else
 	    iprintf(test, report_accepted, ipr, port);
     }
     if (test->json_output) {
  	cJSON_AddStringToObject(test->json_start, ""cookie"", test->cookie);
          if (test->protocol->id == SOCK_STREAM) {
  	    if (test->settings->mss)
		cJSON_AddIntToObject(test->json_start, ""tcp_mss"", test->settings->mss);
 		cJSON_AddNumberToObject(test->json_start, ""tcp_mss"", test->settings->mss);
  	    else {
  		len = sizeof(opt);
  		getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);
		cJSON_AddIntToObject(test->json_start, ""tcp_mss_default"", opt);
 		cJSON_AddNumberToObject(test->json_start, ""tcp_mss_default"", opt);
  	    }
  	}
      } else if (test->verbose) {
         iprintf(test, report_cookie, test->cookie);
         if (test->protocol->id == SOCK_STREAM) {
             if (test->settings->mss)
                 iprintf(test, ""      TCP MSS: %d\n"", test->settings->mss);
             else {
                 len = sizeof(opt);
                 getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);
                 iprintf(test, ""      TCP MSS: %d (default)\n"", opt);
             }
         }
 
     }
 }","[52, 57, 51, 56]","The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow."
202211," static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define ThrowDCMException(exception,message) \
 { \
   if (info.scale != (Quantum *) NULL) \
     info.scale=(Quantum *) RelinquishMagickMemory(info.scale); \
   if (data != (unsigned char *) NULL) \
     data=(unsigned char *) RelinquishMagickMemory(data); \
   if (graymap != (int *) NULL) \
     graymap=(int *) RelinquishMagickMemory(graymap); \
   if (bluemap != (int *) NULL) \
     bluemap=(int *) RelinquishMagickMemory(bluemap); \
   if (greenmap != (int *) NULL) \
     greenmap=(int *) RelinquishMagickMemory(greenmap); \
   if (redmap != (int *) NULL) \
     redmap=(int *) RelinquishMagickMemory(redmap); \
   if (stream_info->offsets != (ssize_t *) NULL) \
     stream_info->offsets=(ssize_t *) RelinquishMagickMemory( \
       stream_info->offsets); \
   if (stream_info != (DCMStreamInfo *) NULL) \
     stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info); \
   ThrowReaderException((exception),(message)); \
 }
 
   char
     explicit_vr[MagickPathExtent],
     implicit_vr[MagickPathExtent],
     magick[MagickPathExtent],
     photometric[MagickPathExtent];
 
   DCMInfo
     info;
 
   DCMStreamInfo
     *stream_info;
 
   Image
     *image;
 
   int
     *bluemap,
     datum,
     *greenmap,
     *graymap,
     *redmap;
 
   MagickBooleanType
     explicit_file,
     explicit_retry,
     use_explicit;
 
   MagickOffsetType
     offset;
 
   register unsigned char
     *p;
 
   register ssize_t
     i;
 
   size_t
     colors,
     height,
     length,
     number_scenes,
     quantum,
     status,
     width;
 
   ssize_t
     count,
     scene;
 
   unsigned char
     *data;
 
   unsigned short
     group,
     element;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   image->depth=8UL;
   image->endian=LSBEndian;
    
   (void) memset(&info,0,sizeof(info));
   data=(unsigned char *) NULL;
   graymap=(int *) NULL;
   redmap=(int *) NULL;
   greenmap=(int *) NULL;
   bluemap=(int *) NULL;
   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));
   if (stream_info == (DCMStreamInfo *) NULL)
     ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
   (void) memset(stream_info,0,sizeof(*stream_info));
   count=ReadBlob(image,128,(unsigned char *) magick);
   if (count != 128)
     ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
   count=ReadBlob(image,4,(unsigned char *) magick);
   if ((count != 4) || (LocaleNCompare(magick,""DICM"",4) != 0))
     {
       offset=SeekBlob(image,0L,SEEK_SET);
       if (offset < 0)
         ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
     }
    
   (void) CopyMagickString(photometric,""MONOCHROME1 "",MagickPathExtent);
   info.bits_allocated=8;
   info.bytes_per_pixel=1;
   info.depth=8;
   info.mask=0xffff;
   info.max_value=255UL;
   info.samples_per_pixel=1;
   info.signed_data=(~0UL);
   info.rescale_slope=1.0;
   data=(unsigned char *) NULL;
   element=0;
   explicit_vr[2]='\0';
   explicit_file=MagickFalse;
   colors=0;
   redmap=(int *) NULL;
   greenmap=(int *) NULL;
   bluemap=(int *) NULL;
   graymap=(int *) NULL;
   height=0;
   number_scenes=1;
   use_explicit=MagickFalse;
   explicit_retry = MagickFalse;
   width=0;
   while (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))
   {
     for (group=0; (group != 0x7FE0) || (element != 0x0010) ; )
     {
        
       image->offset=(ssize_t) TellBlob(image);
       group=ReadBlobLSBShort(image);
       element=ReadBlobLSBShort(image);
       if ((group == 0xfffc) && (element == 0xfffc))
         break;
       if ((group != 0x0002) && (image->endian == MSBEndian))
         {
           group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));
           element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));
         }
       quantum=0;
        
       for (i=0; dicom_info[i].group < 0xffff; i++)
         if ((group == dicom_info[i].group) &&
             (element == dicom_info[i].element))
           break;
       (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MagickPathExtent);
       count=ReadBlob(image,2,(unsigned char *) explicit_vr);
       if (count != 2)
         ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
        
       if ((explicit_file == MagickFalse) && (group != 0x0002))
         explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&
           (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?
           MagickTrue : MagickFalse;
       use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||
         (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;
       if ((use_explicit != MagickFalse) && (strncmp(implicit_vr,""xs"",2) == 0))
         (void) CopyMagickString(implicit_vr,explicit_vr,MagickPathExtent);
       if ((use_explicit == MagickFalse) || (strncmp(implicit_vr,""!!"",2) == 0))
         {
           offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);
           if (offset < 0)
             ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
           quantum=4;
         }
       else
         {
            
           quantum=2;
           if ((strncmp(explicit_vr,""OB"",2) == 0) ||
               (strncmp(explicit_vr,""UN"",2) == 0) ||
               (strncmp(explicit_vr,""OW"",2) == 0) ||
               (strncmp(explicit_vr,""SQ"",2) == 0))
             {
               (void) ReadBlobLSBShort(image);
               quantum=4;
             }
         }
       datum=0;
       if (quantum == 4)
         {
           if (group == 0x0002)
             datum=ReadBlobLSBSignedLong(image);
           else
             datum=ReadBlobSignedLong(image);
         }
       else
         if (quantum == 2)
           {
             if (group == 0x0002)
               datum=ReadBlobLSBSignedShort(image);
             else
               datum=ReadBlobSignedShort(image);
           }
       quantum=0;
       length=1;
       if (datum != 0)
         {
           if ((strncmp(implicit_vr,""OW"",2) == 0) ||
                (strncmp(implicit_vr,""SS"",2) == 0) ||
                (strncmp(implicit_vr,""US"",2) == 0))
              quantum=2;
          else 
           else
              if ((strncmp(implicit_vr,""FL"",2) == 0) ||
                  (strncmp(implicit_vr,""OF"",2) == 0) ||
                  (strncmp(implicit_vr,""SL"",2) == 0) ||
                  (strncmp(implicit_vr,""UL"",2) == 0))
                quantum=4;
            else 
             else
                if (strncmp(implicit_vr,""FD"",2) == 0)
                  quantum=8;
                else
                 quantum=1;
           if (datum != ~0)
             length=(size_t) datum/quantum;
           else
             {
                
               quantum=0;
               length=0;
             }
         }
       if (image_info->verbose != MagickFalse)
         {
            
           if (use_explicit == MagickFalse)
             explicit_vr[0]='\0';
           for (i=0; dicom_info[i].description != (char *) NULL; i++)
             if ((group == dicom_info[i].group) &&
                 (element == dicom_info[i].element))
               break;
           (void) FormatLocaleFile(stdout,""0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)"",
             (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,
             (unsigned long) group,(unsigned long) element);
           if (dicom_info[i].description != (char *) NULL)
             (void) FormatLocaleFile(stdout,"" %s"",dicom_info[i].description);
           (void) FormatLocaleFile(stdout,"": "");
         }
       if ((group == 0x7FE0) && (element == 0x0010))
         {
           if (image_info->verbose != MagickFalse)
             (void) FormatLocaleFile(stdout,""\n"");
           break;
         }
        
       data=(unsigned char *) NULL;
       if ((length == 1) && (quantum == 1))
         datum=ReadBlobByte(image);
       else
         if ((length == 1) && (quantum == 2))
           {
             if (group == 0x0002)
               datum=ReadBlobLSBSignedShort(image);
             else
               datum=ReadBlobSignedShort(image);
           }
         else
           if ((length == 1) && (quantum == 4))
             {
               if (group == 0x0002)
                 datum=ReadBlobLSBSignedLong(image);
               else
                 datum=ReadBlobSignedLong(image);
             }
           else
             if ((quantum != 0) && (length != 0))
               {
                 if (length > (size_t) GetBlobSize(image))
                   ThrowDCMException(CorruptImageError,
                     ""InsufficientImageDataInFile"");
                 if (~length >= 1)
                   data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*
                     sizeof(*data));
                 if (data == (unsigned char *) NULL)
                   ThrowDCMException(ResourceLimitError,
                     ""MemoryAllocationFailed"");
                 count=ReadBlob(image,(size_t) quantum*length,data);
                 if (count != (ssize_t) (quantum*length))
                   {
                     if (image_info->verbose != MagickFalse)
                       (void) FormatLocaleFile(stdout,""count=%d quantum=%d ""
                         ""length=%d group=%d\n"",(int) count,(int) quantum,(int)
                         length,(int) group);
                      ThrowDCMException(CorruptImageError,
                        ""InsufficientImageDataInFile"");
                   }
                 data[length*quantum]='\0';
               }
       if ((((unsigned int) group << 16) | element) == 0xFFFEE0DD)
         {
           if (data != (unsigned char *) NULL)
             data=(unsigned char *) RelinquishMagickMemory(data);
           continue;
         }
       switch (group)
       {
         case 0x0002:
         {
           switch (element)
           {
             case 0x0010:
             {
               char
                 transfer_syntax[MagickPathExtent];
 
                
               if ((datum == 0) && (explicit_retry == MagickFalse))
                 {
                   explicit_retry=MagickTrue;
                   (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);
                   group=0;
                   element=0;
                   if (image_info->verbose != MagickFalse)
                     (void) FormatLocaleFile(stdout,
                       ""Corrupted image - trying explicit format\n"");
                   break;
                 }
               *transfer_syntax='\0';
               if (data != (unsigned char *) NULL)
                 (void) CopyMagickString(transfer_syntax,(char *) data,
                   MagickPathExtent);
               if (image_info->verbose != MagickFalse)
                 (void) FormatLocaleFile(stdout,""transfer_syntax=%s\n"",
                   (const char *) transfer_syntax);
               if (strncmp(transfer_syntax,""1.2.840.10008.1.2"",17) == 0)
                 {
                   int
                     subtype,
                     type;
 
                   type=1;
                   subtype=0;
                   if (strlen(transfer_syntax) > 17)
                     {
                       count=(ssize_t) sscanf(transfer_syntax+17,"".%d.%d"",&type,
                         &subtype);
                       if (count < 1)
                         ThrowDCMException(CorruptImageError,
                           ""ImproperImageHeader"");
                     }
                   switch (type)
                   {
                     case 1:
                     {
                       image->endian=LSBEndian;
                       break;
                     }
                     case 2:
                     {
                       image->endian=MSBEndian;
                       break;
                     }
                     case 4:
                     {
                       if ((subtype >= 80) && (subtype <= 81))
                         image->compression=JPEGCompression;
                       else
                         if ((subtype >= 90) && (subtype <= 93))
                           image->compression=JPEG2000Compression;
                         else
                           image->compression=JPEGCompression;
                       break;
                     }
                     case 5:
                     {
                       image->compression=RLECompression;
                       break;
                     }
                   }
                 }
               break;
             }
             default:
               break;
           }
           break;
         }
         case 0x0028:
         {
           switch (element)
           {
             case 0x0002:
             {
                
               info.samples_per_pixel=(size_t) datum;
               if ((info.samples_per_pixel == 0) || (info.samples_per_pixel > 4))
                 ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
               break;
             }
             case 0x0004:
             {
                
               if (data == (unsigned char *) NULL)
                 break;
               for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)
                 photometric[i]=(char) data[i];
               photometric[i]='\0';
               info.polarity=LocaleCompare(photometric,""MONOCHROME1 "") == 0 ?
                 MagickTrue : MagickFalse;
               break;
             }
             case 0x0006:
             {
                
               if (datum == 1)
                 image->interlace=PlaneInterlace;
               break;
             }
             case 0x0008:
             {
                
               if (data == (unsigned char *) NULL)
                 break;
               number_scenes=StringToUnsignedLong((char *) data);
               break;
             }
             case 0x0010:
             {
                
               height=(size_t) datum;
               break;
             }
             case 0x0011:
             {
                
               width=(size_t) datum;
               break;
             }
             case 0x0100:
             {
                
               info.bits_allocated=(size_t) datum;
               info.bytes_per_pixel=1;
               if (datum > 8)
                 info.bytes_per_pixel=2;
               info.depth=info.bits_allocated;
               if ((info.depth == 0) || (info.depth > 32))
                 ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
               info.max_value=(1UL << info.bits_allocated)-1;
               image->depth=info.depth;
               break;
             }
             case 0x0101:
             {
                
               info.significant_bits=(size_t) datum;
               info.bytes_per_pixel=1;
               if (info.significant_bits > 8)
                 info.bytes_per_pixel=2;
               info.depth=info.significant_bits;
               if ((info.depth == 0) || (info.depth > 16))
                 ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
               info.max_value=(1UL << info.significant_bits)-1;
               info.mask=(size_t) GetQuantumRange(info.significant_bits);
               image->depth=info.depth;
               break;
             }
             case 0x0102:
             {
                
               break;
             }
             case 0x0103:
             {
                
               info.signed_data=(size_t) datum;
               break;
             }
             case 0x1050:
             {
                
               if (data != (unsigned char *) NULL)
                 info.window_center=StringToDouble((char *) data,(char **) NULL);
               break;
             }
             case 0x1051:
             {
                
               if (data != (unsigned char *) NULL)
                 info.window_width=StringToDouble((char *) data,(char **) NULL);
               break;
             }
             case 0x1052:
             {
                
               if (data != (unsigned char *) NULL)
                 info.rescale_intercept=StringToDouble((char *) data,
                   (char **) NULL);
               break;
             }
             case 0x1053:
             {
                
               if (data != (unsigned char *) NULL)
                 info.rescale_slope=StringToDouble((char *) data,(char **) NULL);
               break;
             }
             case 0x1200:
             case 0x3006:
             {
                
               if (data == (unsigned char *) NULL)
                 break;
               colors=(size_t) (length/info.bytes_per_pixel);
               datum=(int) colors;
               if (graymap != (int *) NULL)
                 graymap=(int *) RelinquishMagickMemory(graymap);
               graymap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),
                 sizeof(*graymap));
               if (graymap == (int *) NULL)
                 ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
               (void) memset(graymap,0,MagickMax(colors,65536)*
                 sizeof(*graymap));
               for (i=0; i < (ssize_t) colors; i++)
                 if (info.bytes_per_pixel == 1)
                   graymap[i]=(int) data[i];
                 else
                   graymap[i]=(int) ((short *) data)[i];
               break;
             }
             case 0x1201:
             {
               unsigned short
                 index;
 
                
               if (data == (unsigned char *) NULL)
                 break;
               colors=(size_t) (length/2);
               datum=(int) colors;
               if (redmap != (int *) NULL)
                 redmap=(int *) RelinquishMagickMemory(redmap);
               redmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),
                 sizeof(*redmap));
               if (redmap == (int *) NULL)
                 ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
               (void) memset(redmap,0,MagickMax(colors,65536)*
                 sizeof(*redmap));
               p=data;
               for (i=0; i < (ssize_t) colors; i++)
               {
                 if (image->endian == MSBEndian)
                   index=(unsigned short) ((*p << 8) | *(p+1));
                 else
                   index=(unsigned short) (*p | (*(p+1) << 8));
                 redmap[i]=(int) index;
                 p+=2;
               }
               break;
             }
             case 0x1202:
             {
               unsigned short
                 index;
 
                
               if (data == (unsigned char *) NULL)
                 break;
               colors=(size_t) (length/2);
               datum=(int) colors;
               if (greenmap != (int *) NULL)
                 greenmap=(int *) RelinquishMagickMemory(greenmap);
               greenmap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),
                 sizeof(*greenmap));
               if (greenmap == (int *) NULL)
                 ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
               (void) memset(greenmap,0,MagickMax(colors,65536)*
                 sizeof(*greenmap));
               p=data;
               for (i=0; i < (ssize_t) colors; i++)
               {
                 if (image->endian == MSBEndian)
                   index=(unsigned short) ((*p << 8) | *(p+1));
                 else
                   index=(unsigned short) (*p | (*(p+1) << 8));
                 greenmap[i]=(int) index;
                 p+=2;
               }
               break;
             }
             case 0x1203:
             {
               unsigned short
                 index;
 
                
               if (data == (unsigned char *) NULL)
                 break;
               colors=(size_t) (length/2);
               datum=(int) colors;
               if (bluemap != (int *) NULL)
                 bluemap=(int *) RelinquishMagickMemory(bluemap);
               bluemap=(int *) AcquireQuantumMemory(MagickMax(colors,65536),
                 sizeof(*bluemap));
               if (bluemap == (int *) NULL)
                 ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
               (void) memset(bluemap,0,MagickMax(colors,65536)*
                 sizeof(*bluemap));
               p=data;
               for (i=0; i < (ssize_t) colors; i++)
               {
                 if (image->endian == MSBEndian)
                   index=(unsigned short) ((*p << 8) | *(p+1));
                 else
                   index=(unsigned short) (*p | (*(p+1) << 8));
                 bluemap[i]=(int) index;
                 p+=2;
               }
               break;
             }
             default:
               break;
           }
           break;
         }
         case 0x2050:
         {
           switch (element)
           {
             case 0x0020:
             {
               if ((data != (unsigned char *) NULL) &&
                   (strncmp((char *) data,""INVERSE"",7) == 0))
                 info.polarity=MagickTrue;
               break;
             }
             default:
               break;
           }
           break;
         }
         default:
           break;
       }
       if (data != (unsigned char *) NULL)
         {
           char
             *attribute;
 
           for (i=0; dicom_info[i].description != (char *) NULL; i++)
             if ((group == dicom_info[i].group) &&
                 (element == dicom_info[i].element))
               break;
           if (dicom_info[i].description != (char *) NULL)
             {
               attribute=AcquireString(""dcm:"");
               (void) ConcatenateString(&attribute,dicom_info[i].description);
               for (i=0; i < (ssize_t) MagickMax(length,4); i++)
                 if (isprint((int) data[i]) == MagickFalse)
                   break;
               if ((i == (ssize_t) length) || (length > 4))
                 {
                   (void) SubstituteString(&attribute,"" "","""");
                   (void) SetImageProperty(image,attribute,(char *) data,
                     exception);
                 }
               attribute=DestroyString(attribute);
             }
         }
       if (image_info->verbose != MagickFalse)
         {
           if (data == (unsigned char *) NULL)
             (void) FormatLocaleFile(stdout,""%d\n"",datum);
           else
             {
                
               for (i=0; i < (ssize_t) MagickMax(length,4); i++)
                 if (isprint((int) data[i]) == MagickFalse)
                   break;
               if ((i != (ssize_t) length) && (length <= 4))
                 {
                   ssize_t
                     j;
 
                   datum=0;
                   for (j=(ssize_t) length-1; j >= 0; j--)
                     datum=(256*datum+data[j]);
                   (void) FormatLocaleFile(stdout,""%d"",datum);
                 }
               else
                 for (i=0; i < (ssize_t) length; i++)
                   if (isprint((int) data[i]) != MagickFalse)
                     (void) FormatLocaleFile(stdout,""%c"",data[i]);
                   else
                     (void) FormatLocaleFile(stdout,""%c"",'.');
               (void) FormatLocaleFile(stdout,""\n"");
             }
         }
       if (data != (unsigned char *) NULL)
         data=(unsigned char *) RelinquishMagickMemory(data);
       if (EOFBlob(image) != MagickFalse)
         {
           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
             image->filename);
           break;
         }
     }
     if ((group == 0xfffc) && (element == 0xfffc))
       {
         Image
           *last;
 
         last=RemoveLastImageFromList(&image);
         if (last != (Image *) NULL)
           last=DestroyImage(last);
         break;
       }
     if ((width == 0) || (height == 0))
       ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
     image->columns=(size_t) width;
     image->rows=(size_t) height;
     if (info.signed_data == 0xffff)
       info.signed_data=(size_t) (info.significant_bits == 16 ? 1 : 0);
     if ((image->compression == JPEGCompression) ||
         (image->compression == JPEG2000Compression))
       {
         Image
           *images;
 
         ImageInfo
           *read_info;
 
         int
           c;
 
          
         for (i=0; i < (ssize_t) stream_info->remaining; i++)
           if (ReadBlobByte(image) == EOF)
             break;
         (void) (((ssize_t) ReadBlobLSBShort(image) << 16) |
           ReadBlobLSBShort(image));
         length=(size_t) ReadBlobLSBLong(image);
         if (length > (size_t) GetBlobSize(image))
           ThrowDCMException(CorruptImageError,""InsufficientImageDataInFile"");
         stream_info->offset_count=length >> 2;
         if (stream_info->offset_count != 0)
           {
             if (stream_info->offsets != (ssize_t *) NULL)
               stream_info->offsets=(ssize_t *) RelinquishMagickMemory(
                 stream_info->offsets);
             stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
               stream_info->offset_count,sizeof(*stream_info->offsets));
             if (stream_info->offsets == (ssize_t *) NULL)
               ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
             for (i=0; i < (ssize_t) stream_info->offset_count; i++)
               stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);
             offset=TellBlob(image);
             for (i=0; i < (ssize_t) stream_info->offset_count; i++)
               stream_info->offsets[i]+=offset;
           }
          
         read_info=CloneImageInfo(image_info);
         SetImageInfoBlob(read_info,(void *) NULL,0);
         images=NewImageList();
         for (scene=0; scene < (ssize_t) number_scenes; scene++)
         {
           char
             filename[MagickPathExtent];
 
           const char
             *property;
 
           FILE
             *file;
 
           Image
             *jpeg_image;
 
           int
             unique_file;
 
           unsigned int
             tag;
 
           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |
             ReadBlobLSBShort(image);
           length=(size_t) ReadBlobLSBLong(image);
           if (tag == 0xFFFEE0DD)
             break;  
           if (tag != 0xFFFEE000)
             {
               read_info=DestroyImageInfo(read_info);
               ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
             }
           file=(FILE *) NULL;
           unique_file=AcquireUniqueFileResource(filename);
           if (unique_file != -1)
             file=fdopen(unique_file,""wb"");
           if (file == (FILE *) NULL)
             {
               (void) RelinquishUniqueFileResource(filename);
               ThrowFileException(exception,FileOpenError,
                 ""UnableToCreateTemporaryFile"",filename);
               break;
             }
           for (c=EOF; length != 0; length--)
           {
             c=ReadBlobByte(image);
             if (c == EOF)
               {
                 ThrowFileException(exception,CorruptImageError,
                    ""UnexpectedEndOfFile"",image->filename);
                  break;
                }
            (void) fputc(c,file);
             if (fputc(c,file) != c)
               break;
            }
            (void) fclose(file);
            if (c == EOF)
             break;
           (void) FormatLocaleString(read_info->filename,MagickPathExtent,
             ""jpeg:%s"",filename);
           if (image->compression == JPEG2000Compression)
             (void) FormatLocaleString(read_info->filename,MagickPathExtent,
               ""j2k:%s"",filename);
           jpeg_image=ReadImage(read_info,exception);
           if (jpeg_image != (Image *) NULL)
             {
               ResetImagePropertyIterator(image);
               property=GetNextImageProperty(image);
               while (property != (const char *) NULL)
               {
                 (void) SetImageProperty(jpeg_image,property,
                   GetImageProperty(image,property,exception),exception);
                 property=GetNextImageProperty(image);
               }
               AppendImageToList(&images,jpeg_image);
             }
           (void) RelinquishUniqueFileResource(filename);
         }
         read_info=DestroyImageInfo(read_info);
         if (stream_info->offsets != (ssize_t *) NULL)
           stream_info->offsets=(ssize_t *)
             RelinquishMagickMemory(stream_info->offsets);
         stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
         if (info.scale != (Quantum *) NULL)
           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);
         if (graymap != (int *) NULL)
           graymap=(int *) RelinquishMagickMemory(graymap);
         if (bluemap != (int *) NULL)
           bluemap=(int *) RelinquishMagickMemory(bluemap);
         if (greenmap != (int *) NULL)
           greenmap=(int *) RelinquishMagickMemory(greenmap);
         if (redmap != (int *) NULL)
           redmap=(int *) RelinquishMagickMemory(redmap);
         image=DestroyImageList(image);
         return(GetFirstImageInList(images));
       }
     if (info.depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))
       {
         QuantumAny
           range;
 
          
          length=(size_t) (GetQuantumRange(info.depth)+1);
          if (length > (size_t) GetBlobSize(image))
            ThrowDCMException(CorruptImageError,""InsufficientImageDataInFile"");
        if (info.scale != (Quantum *) NULL) 
         if (info.scale != (Quantum *) NULL)
            info.scale=(Quantum *) RelinquishMagickMemory(info.scale);
          info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),
            sizeof(*info.scale));
         if (info.scale == (Quantum *) NULL)
           ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) memset(info.scale,0,MagickMax(length,256)*
           sizeof(*info.scale));
         range=GetQuantumRange(info.depth);
         for (i=0; i <= (ssize_t) GetQuantumRange(info.depth); i++)
           info.scale[i]=ScaleAnyToQuantum((size_t) i,range);
       }
     if (image->compression == RLECompression)
       {
         unsigned int
           tag;
 
          
         for (i=0; i < (ssize_t) stream_info->remaining; i++)
         {
           int
             c;
 
           c=ReadBlobByte(image);
           if (c == EOF)
             break;
         }
         tag=((unsigned int) ReadBlobLSBShort(image) << 16) |
           ReadBlobLSBShort(image);
         (void) tag;
         length=(size_t) ReadBlobLSBLong(image);
         if (length > (size_t) GetBlobSize(image))
           ThrowDCMException(CorruptImageError,""InsufficientImageDataInFile"");
         stream_info->offset_count=length >> 2;
         if (stream_info->offset_count != 0)
           {
             stream_info->offsets=(ssize_t *) AcquireQuantumMemory(
               stream_info->offset_count,sizeof(*stream_info->offsets));
             if (stream_info->offsets == (ssize_t *) NULL)
               ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
             for (i=0; i < (ssize_t) stream_info->offset_count; i++)
             {
               stream_info->offsets[i]=(ssize_t) ReadBlobLSBSignedLong(image);
               if (EOFBlob(image) != MagickFalse)
                 break;
             }
             offset=TellBlob(image)+8;
             for (i=0; i < (ssize_t) stream_info->offset_count; i++)
               stream_info->offsets[i]+=offset;
           }
       }
     for (scene=0; scene < (ssize_t) number_scenes; scene++)
     {
       if (image_info->ping != MagickFalse)
         break;
       image->columns=(size_t) width;
       image->rows=(size_t) height;
       image->depth=info.depth;
       status=SetImageExtent(image,image->columns,image->rows,exception);
       if (status == MagickFalse)
         break;
       image->colorspace=RGBColorspace;
       (void) SetImageBackgroundColor(image,exception);
       if ((image->colormap == (PixelInfo *) NULL) &&
           (info.samples_per_pixel == 1))
         {
           int
             index;
 
           size_t
             one;
 
           one=1;
           if (colors == 0)
             colors=one << info.depth;
           if (AcquireImageColormap(image,colors,exception) == MagickFalse)
             ThrowDCMException(ResourceLimitError,""MemoryAllocationFailed"");
           if (redmap != (int *) NULL)
             for (i=0; i < (ssize_t) colors; i++)
             {
               index=redmap[i];
               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&
                   (index <= (int) info.max_value))
                 index=(int) info.scale[index];
               image->colormap[i].red=(MagickRealType) index;
             }
           if (greenmap != (int *) NULL)
             for (i=0; i < (ssize_t) colors; i++)
             {
               index=greenmap[i];
               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&
                   (index <= (int) info.max_value))
                 index=(int) info.scale[index];
               image->colormap[i].green=(MagickRealType) index;
             }
           if (bluemap != (int *) NULL)
             for (i=0; i < (ssize_t) colors; i++)
             {
               index=bluemap[i];
               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&
                   (index <= (int) info.max_value))
                 index=(int) info.scale[index];
               image->colormap[i].blue=(MagickRealType) index;
             }
           if (graymap != (int *) NULL)
             for (i=0; i < (ssize_t) colors; i++)
             {
               index=graymap[i];
               if ((info.scale != (Quantum *) NULL) && (index >= 0) &&
                   (index <= (int) info.max_value))
                 index=(int) info.scale[index];
               image->colormap[i].red=(MagickRealType) index;
               image->colormap[i].green=(MagickRealType) index;
               image->colormap[i].blue=(MagickRealType) index;
             }
         }
       if (image->compression == RLECompression)
         {
           unsigned int
             tag;
 
            
           for (i=0; i < (ssize_t) stream_info->remaining; i++)
           {
             int
               c;
 
             c=ReadBlobByte(image);
             if (c == EOF)
               break;
           }
           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |
             ReadBlobLSBShort(image);
           stream_info->remaining=(size_t) ReadBlobLSBLong(image);
           if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||
               (EOFBlob(image) != MagickFalse))
             {
               if (stream_info->offsets != (ssize_t *) NULL)
                 stream_info->offsets=(ssize_t *)
                   RelinquishMagickMemory(stream_info->offsets);
               ThrowDCMException(CorruptImageError,""ImproperImageHeader"");
             }
           stream_info->count=0;
           stream_info->segment_count=ReadBlobLSBLong(image);
           for (i=0; i < 15; i++)
             stream_info->segments[i]=(ssize_t) ReadBlobLSBSignedLong(image);
           stream_info->remaining-=64;
           if (stream_info->segment_count > 1)
             {
               info.bytes_per_pixel=1;
               info.depth=8;
               if (stream_info->offset_count > 0)
                 (void) SeekBlob(image,(MagickOffsetType)
                   stream_info->offsets[0]+stream_info->segments[0],SEEK_SET);
             }
         }
       if ((info.samples_per_pixel > 1) && (image->interlace == PlaneInterlace))
         {
           register ssize_t
             x;
 
           register Quantum
             *q;
 
           ssize_t
             y;
 
            
           for (i=0; i < (ssize_t) info.samples_per_pixel; i++)
           {
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 switch ((int) i)
                 {
                   case 0:
                   {
                     SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                       ReadDCMByte(stream_info,image)),q);
                     break;
                   }
                   case 1:
                   {
                     SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                       ReadDCMByte(stream_info,image)),q);
                     break;
                   }
                   case 2:
                   {
                     SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                       ReadDCMByte(stream_info,image)),q);
                     break;
                   }
                   case 3:
                   {
                     SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                       ReadDCMByte(stream_info,image)),q);
                     break;
                   }
                   default:
                     break;
                 }
                 q+=GetPixelChannels(image);
               }
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                     y,image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
           }
         }
       else
         {
           const char
             *option;
 
            
           option=GetImageOption(image_info,""dcm:display-range"");
           if (option != (const char *) NULL)
             {
               if (LocaleCompare(option,""reset"") == 0)
                 info.window_width=0;
             }
           option=GetImageOption(image_info,""dcm:window"");
           if (option != (char *) NULL)
             {
               GeometryInfo
                 geometry_info;
 
               MagickStatusType
                 flags;
 
               flags=ParseGeometry(option,&geometry_info);
               if (flags & RhoValue)
                 info.window_center=geometry_info.rho;
               if (flags & SigmaValue)
                 info.window_width=geometry_info.sigma;
               info.rescale=MagickTrue;
             }
           option=GetImageOption(image_info,""dcm:rescale"");
           if (option != (char *) NULL)
             info.rescale=IsStringTrue(option);
           if ((info.window_center != 0) && (info.window_width == 0))
             info.window_width=info.window_center;
           status=ReadDCMPixels(image,&info,stream_info,MagickTrue,exception);
           if ((status != MagickFalse) && (stream_info->segment_count > 1))
             {
               if (stream_info->offset_count > 0)
                 (void) SeekBlob(image,(MagickOffsetType)
                   stream_info->offsets[0]+stream_info->segments[1],SEEK_SET);
               (void) ReadDCMPixels(image,&info,stream_info,MagickFalse,
                 exception);
             }
         }
       if (SetImageGray(image,exception) != MagickFalse)
         (void) SetImageColorspace(image,GRAYColorspace,exception);
       if (EOFBlob(image) != MagickFalse)
         {
           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
             image->filename);
           break;
         }
        
       if (image_info->number_scenes != 0)
         if (image->scene >= (image_info->scene+image_info->number_scenes-1))
           break;
       if (scene < (ssize_t) (number_scenes-1))
         {
            
           AcquireNextImage(image_info,image,exception);
           if (GetNextImageInList(image) == (Image *) NULL)
             {
               status=MagickFalse;
               break;
             }
           image=SyncNextImageInList(image);
           status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
             GetBlobSize(image));
           if (status == MagickFalse)
             break;
         }
     }
     if (TellBlob(image) < (MagickOffsetType) GetBlobSize(image))
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             status=MagickFalse;
             break;
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
      }
   }
    
   if (stream_info->offsets != (ssize_t *) NULL)
     stream_info->offsets=(ssize_t *)
       RelinquishMagickMemory(stream_info->offsets);
   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);
   if (info.scale != (Quantum *) NULL)
     info.scale=(Quantum *) RelinquishMagickMemory(info.scale);
   if (graymap != (int *) NULL)
     graymap=(int *) RelinquishMagickMemory(graymap);
   if (bluemap != (int *) NULL)
     bluemap=(int *) RelinquishMagickMemory(bluemap);
   if (greenmap != (int *) NULL)
     greenmap=(int *) RelinquishMagickMemory(greenmap);
   if (redmap != (int *) NULL)
     redmap=(int *) RelinquishMagickMemory(redmap);
   (void) CloseBlob(image);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   return(GetFirstImageInList(image));
 }","[222, 229, 826, 827, 880, 221, 228, 825, 879]","The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file."
204126," void FindBarController::EndFindSession(SelectionAction action) {
   find_bar_->Hide(true);
 
    if (tab_contents_) {
    FindManager* find_manager = tab_contents_->GetFindManager();
     FindTabHelper* find_tab_helper = tab_contents_->find_tab_helper();
  
    find_manager->StopFinding(action);
     find_tab_helper->StopFinding(action);
  
      if (action != kKeepSelection)
      find_bar_->ClearResults(find_manager->find_result());
       find_bar_->ClearResults(find_tab_helper->find_result());
  
      find_bar_->RestoreSavedFocus();
   }
 }","[6, 9, 13, 5, 8, 12]","Google Chrome before 10.0.648.204 does not properly handle SVG text, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors that lead to a *stale pointer.*"
198194," int ssl3_get_server_hello(SSL *s)
 	{
 	STACK_OF(SSL_CIPHER) *sk;
 	const SSL_CIPHER *c;
 	unsigned char *p,*d;
 	int i,al,ok;
 	unsigned int j;
 	long n;
 #ifndef OPENSSL_NO_COMP
 	SSL_COMP *comp;
 #endif
 
 	n=s->method->ssl_get_message(s,
 		SSL3_ST_CR_SRVR_HELLO_A,
 		SSL3_ST_CR_SRVR_HELLO_B,
 		-1,
 		20000,  
 		&ok);
 
 	if (!ok) return((int)n);
 
 	if ( SSL_version(s) == DTLS1_VERSION || SSL_version(s) == DTLS1_BAD_VER)
 		{
 		if ( s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST)
 			{
 			if ( s->d1->send_cookie == 0)
 				{
 				s->s3->tmp.reuse_message = 1;
 				return 1;
 				}
 			else  
 				{
 				al=SSL_AD_UNEXPECTED_MESSAGE;
 				SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
 				goto f_err;
 				}
 			}
 		}
 	
 	if ( s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO)
 		{
 		al=SSL_AD_UNEXPECTED_MESSAGE;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_MESSAGE_TYPE);
 		goto f_err;
 		}
 
 	d=p=(unsigned char *)s->init_msg;
 
 	if ((p[0] != (s->version>>8)) || (p[1] != (s->version&0xff)))
 		{
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_SSL_VERSION);
 		s->version=(s->version&0xff00)|p[1];
 		al=SSL_AD_PROTOCOL_VERSION;
 		goto f_err;
 		}
 	p+=2;
 
 	 
 	 
 	memcpy(s->s3->server_random,p,SSL3_RANDOM_SIZE);
 	p+=SSL3_RANDOM_SIZE;
 
 	 
 	j= *(p++);
 
 	if ((j > sizeof s->session->session_id) || (j > SSL3_SESSION_ID_SIZE))
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SSL3_SESSION_ID_TOO_LONG);
 		goto f_err;
 		}
 
 #ifndef OPENSSL_NO_TLSEXT
 	 
 	if (s->version >= TLS1_VERSION && s->tls_session_secret_cb)
 		{
 		SSL_CIPHER *pref_cipher=NULL;
 		s->session->master_key_length=sizeof(s->session->master_key);
 		if (s->tls_session_secret_cb(s, s->session->master_key,
 					     &s->session->master_key_length,
 					     NULL, &pref_cipher,
 					     s->tls_session_secret_cb_arg))
 			{
 			s->session->cipher = pref_cipher ?
 				pref_cipher : ssl_get_cipher_by_char(s, p+j);
 	    		s->s3->flags |= SSL3_FLAGS_CCS_OK;
 			}
 		}
 #endif  
 
 	if (j != 0 && j == s->session->session_id_length
 	    && memcmp(p,s->session->session_id,j) == 0)
 	    {
 	    if(s->sid_ctx_length != s->session->sid_ctx_length
 	       || memcmp(s->session->sid_ctx,s->sid_ctx,s->sid_ctx_length))
 		{
 		 
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);
 		goto f_err;
 		}
 	    s->s3->flags |= SSL3_FLAGS_CCS_OK;
 	    s->hit=1;
 	    }
 	else	 
 		{
 		 
 		s->hit=0;
 		if (s->session->session_id_length > 0)
 			{
 			if (!ssl_get_new_session(s,0))
 				{
 				al=SSL_AD_INTERNAL_ERROR;
 				goto f_err;
 				}
 			}
 		s->session->session_id_length=j;
 		memcpy(s->session->session_id,p,j);  
 		}
 	p+=j;
 	c=ssl_get_cipher_by_char(s,p);
 	if (c == NULL)
 		{
 		 
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNKNOWN_CIPHER_RETURNED);
 		goto f_err;
 		}
 	 
 	if ((c->algorithm_ssl & SSL_TLSV1_2) && 
 		(TLS1_get_version(s) < TLS1_2_VERSION))
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
                 SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
                 goto f_err;
                 }
 #ifndef OPENSSL_NO_SRP
        if (((c->algorithm_mkey & SSL_kSRP) || (c->algorithm_auth & SSL_aSRP)) &&
                    !(s->srp_ctx.srp_Mask & SSL_kSRP))
                {
                al=SSL_AD_ILLEGAL_PARAMETER;
                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_WRONG_CIPHER_RETURNED);
                goto f_err;
                }
 #endif  
         p+=ssl_put_cipher_by_char(s,NULL,NULL);
  
         sk=ssl_get_ciphers_by_id(s);
 	 
 	if (s->session->cipher)
 		s->session->cipher_id = s->session->cipher->id;
 	if (s->hit && (s->session->cipher_id != c->id))
 		{
  
 #if 0
 		if (!(s->options &
 			SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG))
 #endif
 			{
 			al=SSL_AD_ILLEGAL_PARAMETER;
 			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);
 			goto f_err;
 			}
 		}
 	s->s3->tmp.new_cipher=c;
 	 
 	if (TLS1_get_version(s) < TLS1_2_VERSION && !ssl3_digest_cached_records(s))
 		{
 		al = SSL_AD_INTERNAL_ERROR;
 		goto f_err;
 		}
 	 
 	 
 #ifdef OPENSSL_NO_COMP
 	if (*(p++) != 0)
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
 		goto f_err;
 		}
 	 
 	if (s->session->compress_meth != 0)
 		{
 		al=SSL_AD_INTERNAL_ERROR;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_INCONSISTENT_COMPRESSION);
 		goto f_err;
 		}
 #else
 	j= *(p++);
 	if (s->hit && j != s->session->compress_meth)
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);
 		goto f_err;
 		}
 	if (j == 0)
 		comp=NULL;
 	else if (s->options & SSL_OP_NO_COMPRESSION)
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_COMPRESSION_DISABLED);
 		goto f_err;
 		}
 	else
 		comp=ssl3_comp_find(s->ctx->comp_methods,j);
 	
 	if ((j != 0) && (comp == NULL))
 		{
 		al=SSL_AD_ILLEGAL_PARAMETER;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);
 		goto f_err;
 		}
 	else
 		{
 		s->s3->tmp.new_compression=comp;
 		}
 #endif
 
 #ifndef OPENSSL_NO_TLSEXT
 	 
 	if (s->version >= SSL3_VERSION)
 		{
 		if (!ssl_parse_serverhello_tlsext(s,&p,d,n, &al))
 			{
 			 
 			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_PARSE_TLSEXT);
 			goto f_err; 
 			}
 		if (ssl_check_serverhello_tlsext(s) <= 0)
 			{
 			SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_SERVERHELLO_TLSEXT);
 				goto err;
 			}
 		}
 #endif
 
 	if (p != (d+n))
 		{
 		 
 		al=SSL_AD_DECODE_ERROR;
 		SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,SSL_R_BAD_PACKET_LENGTH);
 		goto f_err;
 		}
 
 	return(1);
 f_err:
 	ssl3_send_alert(s,SSL3_AL_FATAL,al);
 err:
 	return(-1);
 	}","[137, 138, 139, 140, 141, 142, 143, 144, 145]",The ssl_set_client_disabled function in t1_lib.c in OpenSSL 1.0.1 before 1.0.1i allows remote SSL servers to cause a denial of service (NULL pointer dereference and client application crash) via a ServerHello message that includes an SRP ciphersuite without the required negotiation of that ciphersuite with the client.
7855,"void Compute(OpKernelContext* context) override {
const Tensor& x = context->input(0);
const Tensor& y = context->input(1);
const float min_x = context->input(2).flat<float>()(0);
const float max_x = context->input(3).flat<float>()(0);
const float min_y = context->input(4).flat<float>()(0);
const float max_y = context->input(5).flat<float>()(0);

BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));
if (!bcast.IsValid()) {
context->SetStatus(errors::InvalidArgument(
""Incompatible shapes: "", x.shape().DebugString(), "" vs. "",
y.shape().DebugString()));
return;
}
Tensor* z;
OP_REQUIRES_OK(context, context->allocate_output(
0, BCast::ToShape(bcast.output_shape()), &z));




OP_REQUIRES(context, (max_x > min_x),
errors::InvalidArgument(""max_x must be larger than min_a.""));
OP_REQUIRES(context, (max_y > min_y),
errors::InvalidArgument(""max_x must be larger than min_b.""));
const int32 offset_x = FloatToQuantizedUnclamped<T>(0.0f, min_x, max_x);
const int32 offset_y = FloatToQuantizedUnclamped<T>(0.0f, min_y, max_y);
const T* x_data = x.flat<T>().data();
const T* y_data = y.flat<T>().data();
Toutput* z_data = z->flat<Toutput>().data();

const int ndims = bcast.x_reshape().size();
if (ndims <= 1) {
if (x.NumElements() == 1) {
ScalarMultiply<T, Toutput>(context, y_data, offset_y, y.NumElements(),
x_data[0], offset_x, z_data);
} else if (y.NumElements() == 1) {
ScalarMultiply<T, Toutput>(context, x_data, offset_x, x.NumElements(),
y_data[0], offset_y, z_data);
} else {
VectorMultiply<T, Toutput>(context, x_data, offset_x, y_data, offset_y,
x.NumElements(), z_data);
}
} else if (ndims == 2) {
const T* vector_data;
int64 vector_num_elements;
int32 vector_offset;
const T* tensor_data;
int64 tensor_num_elements;
int32 tensor_offset;
if (x.NumElements() < y.NumElements()) {
vector_data = x_data;
vector_num_elements = x.NumElements();
vector_offset = offset_x;
tensor_data = y_data;
tensor_num_elements = y.NumElements();
tensor_offset = offset_y;
} else {
vector_data = y_data;
vector_num_elements = y.NumElements();
vector_offset = offset_y;
tensor_data = x_data;
tensor_num_elements = x.NumElements();
tensor_offset = offset_x;
}
if (vector_num_elements == 0) {
context->SetStatus(
errors::InvalidArgument(""vector must have at least 1 element""));
return;
}
VectorTensorMultiply<T, Toutput>(
vector_data, vector_offset, vector_num_elements, tensor_data,
tensor_offset, tensor_num_elements, z_data);
} else {
LOG(INFO) << ""ndims="" << ndims;
LOG(INFO) << ""bcast.x_reshape()=""
<< TensorShape(bcast.x_reshape()).DebugString();
LOG(INFO) << ""bcast.y_reshape()=""
<< TensorShape(bcast.y_reshape()).DebugString();
LOG(INFO) << ""bcast.x_bcast()=""
<< TensorShape(bcast.x_bcast()).DebugString();
LOG(INFO) << ""bcast.y_bcast()=""
<< TensorShape(bcast.y_bcast()).DebugString();

context->SetStatus(errors::Unimplemented(
""Broadcast between "", context->input(0).shape().DebugString(),
"" and "", context->input(1).shape().DebugString(),
"" is not supported yet.""));
return;
}

float min_z_value;
float max_z_value;
QuantizationRangeForMultiplication<T, T, Toutput>(
min_x, max_x, min_y, max_y, &min_z_value, &max_z_value);
Tensor* z_min = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));
z_min->flat<float>()(0) = min_z_value;

Tensor* z_max = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));
z_max->flat<float>()(0) = max_z_value;
}","[4, 5, 6, 7]","TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a heap buffer overflow in `QuantizedMul` by passing in invalid thresholds for the quantization. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/87cf4d3ea9949051e50ca3f071fc909538a51cd0/tensorflow/core/kernels/quantized_mul_op.cc#L287-L290) assumes that the 4 arguments are always valid scalars and tries to access the numeric value directly. However, if any of these tensors is empty, then `.flat<T>()` is an empty buffer and accessing the element at position 0 results in overflow. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
10093,"explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {
OP_REQUIRES_OK(ctx, ctx->GetAttr(""signed_input"", &signed_input_));
OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_bits"", &num_bits_));
OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),
errors::InvalidArgument(""num_bits is out of range: "", num_bits_,
"" with signed_input_ "", signed_input_));
OP_REQUIRES_OK(ctx, ctx->GetAttr(""range_given"", &range_given_));
OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_min"", &input_min_));
OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_max"", &input_max_));
if (range_given_) {
OP_REQUIRES(
ctx, input_min_ <= input_max_,
errors::InvalidArgument(""Invalid range: input_min "", input_min_,
"" > input_max "", input_max_));
}
}","[5, 6, 11, 12, 13]","TensorFlow is an open source platform for machine learning. If `QuantizeAndDequantizeV3` is given a nonscalar `num_bits` input tensor, it results in a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit f3f9cb38ecfe5a8a703f2c4a8fead434ef291713. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
199605," static long media_device_enum_entities(struct media_device *mdev,
 				       struct media_entity_desc __user *uent)
 {
  	struct media_entity *ent;
  	struct media_entity_desc u_ent;
  
 	memset(&u_ent, 0, sizeof(u_ent));
  	if (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))
  		return -EFAULT;
  
 	ent = find_entity(mdev, u_ent.id);
 
 	if (ent == NULL)
 		return -EINVAL;
 
 	u_ent.id = ent->id;
 	if (ent->name) {
 		strncpy(u_ent.name, ent->name, sizeof(u_ent.name));
 		u_ent.name[sizeof(u_ent.name) - 1] = '\0';
 	} else {
 		memset(u_ent.name, 0, sizeof(u_ent.name));
 	}
 	u_ent.type = ent->type;
 	u_ent.revision = ent->revision;
 	u_ent.flags = ent->flags;
 	u_ent.group_id = ent->group_id;
 	u_ent.pads = ent->num_pads;
 	u_ent.links = ent->num_links - ent->num_backlinks;
 	memcpy(&u_ent.raw, &ent->info, sizeof(ent->info));
 	if (copy_to_user(uent, &u_ent, sizeof(u_ent)))
 		return -EFAULT;
 	return 0;
 }",[7],"The media_device_enum_entities function in drivers/media/media-device.c in the Linux kernel before 3.14.6 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory by leveraging /dev/media0 read access for a MEDIA_IOC_ENUM_ENTITIES ioctl call."
199478," static bool parse_notify(struct pool *pool, json_t *val)
 {
 	char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,
 	     *ntime, header[228];
 	unsigned char *cb1 = NULL, *cb2 = NULL;
 	size_t cb1_len, cb2_len, alloc_len;
 	bool clean, ret = false;
 	int merkles, i;
 	json_t *arr;
 
 	arr = json_array_get(val, 4);
 	if (!arr || !json_is_array(arr))
 		goto out;
 
 	merkles = json_array_size(arr);
 
 	job_id = json_array_string(val, 0);
 	prev_hash = __json_array_string(val, 1);
 	coinbase1 = json_array_string(val, 2);
 	coinbase2 = json_array_string(val, 3);
 	bbversion = __json_array_string(val, 5);
 	nbit = __json_array_string(val, 6);
  	ntime = __json_array_string(val, 7);
  	clean = json_is_true(json_array_get(val, 8));
  
	if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {
 	if (!valid_hex(job_id) || !valid_hex(prev_hash) || !valid_hex(coinbase1) ||
 	    !valid_hex(coinbase2) || !valid_hex(bbversion) || !valid_hex(nbit) ||
 	    !valid_hex(ntime)) {
  		 
		if (job_id)
			free(job_id);
		if (coinbase1)
			free(coinbase1);
		if (coinbase2)
			free(coinbase2);
 		free(job_id);
 		free(coinbase1);
 		free(coinbase2);
  		goto out;
  	}
  
 	cg_wlock(&pool->data_lock);
 	free(pool->swork.job_id);
 	pool->swork.job_id = job_id;
 	snprintf(pool->prev_hash, 65, ""%s"", prev_hash);
 	cb1_len = strlen(coinbase1) / 2;
 	cb2_len = strlen(coinbase2) / 2;
 	snprintf(pool->bbversion, 9, ""%s"", bbversion);
 	snprintf(pool->nbit, 9, ""%s"", nbit);
 	snprintf(pool->ntime, 9, ""%s"", ntime);
 	pool->swork.clean = clean;
 	alloc_len = pool->coinbase_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;
 	pool->nonce2_offset = cb1_len + pool->n1_len;
 
 	for (i = 0; i < pool->merkles; i++)
 		free(pool->swork.merkle_bin[i]);
 	if (merkles) {
 		pool->swork.merkle_bin = realloc(pool->swork.merkle_bin,
 						 sizeof(char *) * merkles + 1);
 		for (i = 0; i < merkles; i++) {
 			char *merkle = json_array_string(arr, i);
 
 			pool->swork.merkle_bin[i] = malloc(32);
 			if (unlikely(!pool->swork.merkle_bin[i]))
 				quit(1, ""Failed to malloc pool swork merkle_bin"");
 			if (opt_protocol)
 				applog(LOG_DEBUG, ""merkle %d: %s"", i, merkle);
 			ret = hex2bin(pool->swork.merkle_bin[i], merkle, 32);
 			free(merkle);
 			if (unlikely(!ret)) {
 				applog(LOG_ERR, ""Failed to convert merkle to merkle_bin in parse_notify"");
 				goto out_unlock;
 			}
 		}
 	}
 	pool->merkles = merkles;
 	if (clean)
 		pool->nonce2 = 0;
 #if 0
 	header_len = 		 strlen(pool->bbversion) +
 				 strlen(pool->prev_hash);
 	 	 32 +
 				 strlen(pool->ntime) +
 				 strlen(pool->nbit) +
 	 		 8 +
 	 	 96;
 #endif
 	snprintf(header, 225,
 		""%s%s%s%s%s%s%s"",
 		pool->bbversion,
 		pool->prev_hash,
 		blank_merkle,
 		pool->ntime,
 		pool->nbit,
 		""00000000"",  
 		workpadding);
 	ret = hex2bin(pool->header_bin, header, 112);
 	if (unlikely(!ret)) {
 		applog(LOG_ERR, ""Failed to convert header to header_bin in parse_notify"");
 		goto out_unlock;
 	}
 
 	cb1 = alloca(cb1_len);
 	ret = hex2bin(cb1, coinbase1, cb1_len);
 	if (unlikely(!ret)) {
 		applog(LOG_ERR, ""Failed to convert cb1 to cb1_bin in parse_notify"");
 		goto out_unlock;
 	}
 	cb2 = alloca(cb2_len);
 	ret = hex2bin(cb2, coinbase2, cb2_len);
 	if (unlikely(!ret)) {
 		applog(LOG_ERR, ""Failed to convert cb2 to cb2_bin in parse_notify"");
 		goto out_unlock;
 	}
 	free(pool->coinbase);
 	align_len(&alloc_len);
 	pool->coinbase = calloc(alloc_len, 1);
 	if (unlikely(!pool->coinbase))
 		quit(1, ""Failed to calloc pool coinbase in parse_notify"");
 	memcpy(pool->coinbase, cb1, cb1_len);
 	memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);
 	memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);
 	if (opt_debug) {
 		char *cb = bin2hex(pool->coinbase, pool->coinbase_len);
 
 		applog(LOG_DEBUG, ""Pool %d coinbase %s"", pool->pool_no, cb);
 		free(cb);
 	}
 out_unlock:
 	cg_wunlock(&pool->data_lock);
 
 	if (opt_protocol) {
 		applog(LOG_DEBUG, ""job_id: %s"", job_id);
 		applog(LOG_DEBUG, ""prev_hash: %s"", prev_hash);
 		applog(LOG_DEBUG, ""coinbase1: %s"", coinbase1);
 		applog(LOG_DEBUG, ""coinbase2: %s"", coinbase2);
 		applog(LOG_DEBUG, ""bbversion: %s"", bbversion);
 		applog(LOG_DEBUG, ""nbit: %s"", nbit);
 		applog(LOG_DEBUG, ""ntime: %s"", ntime);
 		applog(LOG_DEBUG, ""clean: %s"", clean ? ""yes"" : ""no"");
 	}
 	free(coinbase1);
 	free(coinbase2);
 
 	 
 	pool->getwork_requested++;
 	total_getworks++;
 	if (pool == current_pool())
 		opt_work_update = true;
 out:
 	return ret;
 }","[27, 28, 29, 37, 38, 39, 26, 31, 32, 33, 34, 35, 36]","Multiple heap-based buffer overflows in the parse_notify function in sgminer before 4.2.2, cgminer before 4.3.5, and BFGMiner before 4.1.0 allow remote pool servers to have unspecified impact via a (1) large or (2) negative value in the Extranonc2_size parameter in a mining.subscribe response and a crafted mining.notify request."
206288," RenderFrameHostManager::DetermineSiteInstanceForURL(
     const GURL& dest_url,
     SiteInstance* source_instance,
     SiteInstance* current_instance,
     SiteInstance* dest_instance,
     ui::PageTransition transition,
     bool dest_is_restore,
     bool dest_is_view_source_mode,
     bool force_browsing_instance_swap,
     bool was_server_redirect) {
   SiteInstanceImpl* current_instance_impl =
       static_cast<SiteInstanceImpl*>(current_instance);
   NavigationControllerImpl& controller =
       delegate_->GetControllerForRenderManager();
   BrowserContext* browser_context = controller.GetBrowserContext();
 
   if (dest_instance) {
     if (force_browsing_instance_swap) {
       CHECK(!dest_instance->IsRelatedSiteInstance(
                 render_frame_host_->GetSiteInstance()));
     }
     return SiteInstanceDescriptor(dest_instance);
   }
 
   if (force_browsing_instance_swap)
     return SiteInstanceDescriptor(browser_context, dest_url,
                                   SiteInstanceRelation::UNRELATED);
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           switches::kProcessPerSite) &&
       ui::PageTransitionCoreTypeIs(transition, ui::PAGE_TRANSITION_GENERATED)) {
     return SiteInstanceDescriptor(current_instance_impl);
   }
 
   if (SiteIsolationPolicy::AreCrossProcessFramesPossible() &&
       !frame_tree_node_->IsMainFrame()) {
     SiteInstance* parent_site_instance =
         frame_tree_node_->parent()->current_frame_host()->GetSiteInstance();
     if (parent_site_instance->GetSiteURL().SchemeIs(kChromeUIScheme) &&
         dest_url.SchemeIs(kChromeUIScheme)) {
       return SiteInstanceDescriptor(parent_site_instance);
     }
   }
 
   if (!current_instance_impl->HasSite()) {
     bool use_process_per_site =
         RenderProcessHost::ShouldUseProcessPerSite(browser_context, dest_url) &&
         RenderProcessHostImpl::GetProcessHostForSite(browser_context, dest_url);
     if (current_instance_impl->HasRelatedSiteInstance(dest_url) ||
         use_process_per_site) {
       return SiteInstanceDescriptor(browser_context, dest_url,
                                     SiteInstanceRelation::RELATED);
     }
 
     if (current_instance_impl->HasWrongProcessForURL(dest_url))
       return SiteInstanceDescriptor(browser_context, dest_url,
                                     SiteInstanceRelation::RELATED);
 
     if (dest_is_view_source_mode)
       return SiteInstanceDescriptor(browser_context, dest_url,
                                     SiteInstanceRelation::UNRELATED);
 
     if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(
             browser_context, dest_url)) {
       return SiteInstanceDescriptor(browser_context, dest_url,
                                     SiteInstanceRelation::UNRELATED);
     }
 
     if (dest_is_restore &&
         GetContentClient()->browser()->ShouldAssignSiteForURL(dest_url)) {
       current_instance_impl->SetSite(dest_url);
     }
 
     return SiteInstanceDescriptor(current_instance_impl);
   }
 
 
    NavigationEntry* current_entry = controller.GetLastCommittedEntry();
  if (interstitial_page_) {
   if (delegate_->GetInterstitialForRenderManager()) {
      current_entry = controller.GetEntryAtOffset(-1);
   }
 
   if (current_entry &&
       current_entry->IsViewSourceMode() != dest_is_view_source_mode &&
       !IsRendererDebugURL(dest_url)) {
     return SiteInstanceDescriptor(browser_context, dest_url,
                                   SiteInstanceRelation::UNRELATED);
   }
 
   GURL about_blank(url::kAboutBlankURL);
   GURL about_srcdoc(content::kAboutSrcDocURL);
   bool dest_is_data_or_about = dest_url == about_srcdoc ||
                                dest_url == about_blank ||
                                dest_url.scheme() == url::kDataScheme;
   if (source_instance && dest_is_data_or_about && !was_server_redirect)
     return SiteInstanceDescriptor(source_instance);
 
   if (IsCurrentlySameSite(render_frame_host_.get(), dest_url))
     return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());
 
   if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled()) {
     if (!frame_tree_node_->IsMainFrame()) {
       RenderFrameHostImpl* main_frame =
           frame_tree_node_->frame_tree()->root()->current_frame_host();
       if (IsCurrentlySameSite(main_frame, dest_url))
         return SiteInstanceDescriptor(main_frame->GetSiteInstance());
     }
 
     if (frame_tree_node_->opener()) {
       RenderFrameHostImpl* opener_frame =
           frame_tree_node_->opener()->current_frame_host();
       if (IsCurrentlySameSite(opener_frame, dest_url))
         return SiteInstanceDescriptor(opener_frame->GetSiteInstance());
     }
   }
 
   if (!frame_tree_node_->IsMainFrame() &&
       SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
       !SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,
                                                          dest_url)) {
     if (GetContentClient()
             ->browser()
             ->ShouldFrameShareParentSiteInstanceDespiteTopDocumentIsolation(
                 dest_url, current_instance)) {
       return SiteInstanceDescriptor(render_frame_host_->GetSiteInstance());
     }
 
     return SiteInstanceDescriptor(
         browser_context, dest_url,
         SiteInstanceRelation::RELATED_DEFAULT_SUBFRAME);
   }
 
   if (!frame_tree_node_->IsMainFrame()) {
     RenderFrameHostImpl* parent =
         frame_tree_node_->parent()->current_frame_host();
     bool dest_url_requires_dedicated_process =
         SiteInstanceImpl::DoesSiteRequireDedicatedProcess(browser_context,
                                                           dest_url);
     if (!parent->GetSiteInstance()->RequiresDedicatedProcess() &&
         !dest_url_requires_dedicated_process) {
       return SiteInstanceDescriptor(parent->GetSiteInstance());
     }
   }
 
   return SiteInstanceDescriptor(browser_context, dest_url,
                                 SiteInstanceRelation::RELATED);
 }","[80, 79]",Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.
197944," hb_buffer_clear (hb_buffer_t *buffer)
  {
    buffer->have_output = FALSE;
    buffer->have_positions = FALSE;
   buffer->in_error = FALSE;
    buffer->len = 0;
    buffer->out_len = 0;
    buffer->i = 0;
   buffer->max_lig_id = 0;
    buffer->max_lig_id = 0;
  }",[5],"The hb_buffer_ensure function in hb-buffer.c in HarfBuzz, as used in Pango 1.28.3, Firefox, and other products, does not verify that memory reallocations succeed, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly execute arbitrary code via crafted OpenType font data that triggers use of an incorrect index."
206585," bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session,
                                                  TargetRegistry* registry) {
   if (!ShouldAllowSession(session))
     return false;
 
   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
   session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
   session->AddHandler(base::WrapUnique(new protocol::IOHandler(
       GetIOContext())));
   session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
   session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(
       GetId(),
       frame_tree_node_ ? frame_tree_node_->devtools_frame_token()
                        : base::UnguessableToken(),
       GetIOContext())));
   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
   session->AddHandler(base::WrapUnique(new protocol::TargetHandler(
       session->client()->MayDiscoverTargets()
            ? protocol::TargetHandler::AccessMode::kRegular
            : protocol::TargetHandler::AccessMode::kAutoAttachOnly,
        GetId(), registry)));
  session->AddHandler(
      base::WrapUnique(new protocol::PageHandler(emulation_handler)));
   session->AddHandler(base::WrapUnique(new protocol::PageHandler(
       emulation_handler, session->client()->MayAffectLocalFiles())));
    session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
    if (!frame_tree_node_ || !frame_tree_node_->parent()) {
      session->AddHandler(base::WrapUnique(
         new protocol::TracingHandler(frame_tree_node_, GetIOContext())));
   }
 
   if (sessions().empty()) {
     bool use_video_capture_api = true;
 #ifdef OS_ANDROID
     if (!CompositorImpl::IsInitialized())
       use_video_capture_api = false;
 #endif
     if (!use_video_capture_api)
       frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
     GrantPolicy();
 #if defined(OS_ANDROID)
     GetWakeLock()->RequestWakeLock();
 #endif
   }
   return true;
 }","[31, 32, 29, 30]",Inappropriate allowance of the setDownloadBehavior devtools protocol feature in Extensions in Google Chrome prior to 71.0.3578.80 allowed a remote attacker with control of an installed extension to access files on the local file system via a crafted Chrome Extension.
207448," static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
  size_t bytes)
 {
  struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
  int read;
 
     DEBUG(""read %zu bytes, state: %d"", bytes, in->common.state);
 
  if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)
  {
         DEBUG(""stream suspended"");
  return -1;
  }
 
   
  if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||
  (in->common.state == AUDIO_A2DP_STATE_STANDBY))
  {
         pthread_mutex_lock(&in->common.lock);
 
  if (start_audio_datapath(&in->common) < 0)
  {
   
 
  int us_delay = calc_audiotime(in->common.cfg, bytes);
 
  
              DEBUG(""emulate a2dp read delay (%d us)"", us_delay);
  
            usleep(us_delay);
             TEMP_FAILURE_RETRY(usleep(us_delay));
              pthread_mutex_unlock(&in->common.lock);
              return -1;
          }
 
         pthread_mutex_unlock(&in->common.lock);
  }
  else if (in->common.state != AUDIO_A2DP_STATE_STARTED)
  {
         ERROR(""stream not in stopped or standby"");
  return -1;
  }
 
     read = skt_read(in->common.audio_fd, buffer, bytes);
 
  if (read == -1)
  {
         skt_disconnect(in->common.audio_fd);
         in->common.audio_fd = AUDIO_SKT_DISCONNECTED;
         in->common.state = AUDIO_A2DP_STATE_STOPPED;
  } else if (read == 0) {
         DEBUG(""read time out - return zeros"");
         memset(buffer, 0, bytes);
         read = bytes;
  }
 
     DEBUG(""read %d bytes out of %zu bytes"", read, bytes);
  return read;
 }","[31, 30]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
205037," void ProfileDependencyManager::AssertFactoriesBuilt() {
   if (built_factories_)
     return;
 
 #if defined(ENABLE_BACKGROUND)
   BackgroundContentsServiceFactory::GetInstance();
 #endif
   BookmarkModelFactory::GetInstance();
 #if defined(ENABLE_CAPTIVE_PORTAL_DETECTION)
   captive_portal::CaptivePortalServiceFactory::GetInstance();
 #endif
   ChromeURLDataManagerFactory::GetInstance();
 #if defined(ENABLE_PRINTING)
   CloudPrintProxyServiceFactory::GetInstance();
 #endif
   CookieSettings::Factory::GetInstance();
 #if defined(ENABLE_NOTIFICATIONS)
   DesktopNotificationServiceFactory::GetInstance();
 #endif
   DownloadServiceFactory::GetInstance();
 #if defined(ENABLE_EXTENSIONS)
   extensions::AppRestoreServiceFactory::GetInstance();
    extensions::BluetoothAPIFactory::GetInstance();
    extensions::CommandServiceFactory::GetInstance();
    extensions::CookiesAPIFactory::GetInstance();
   extensions::DialAPIFactory::GetInstance();
    extensions::ExtensionSystemFactory::GetInstance();
    extensions::FontSettingsAPIFactory::GetInstance();
    extensions::IdleManagerFactory::GetInstance();
   extensions::ManagedModeAPIFactory::GetInstance();
   extensions::ProcessesAPIFactory::GetInstance();
   extensions::SuggestedLinksRegistryFactory::GetInstance();
   extensions::TabCaptureRegistryFactory::GetInstance();
   extensions::WebNavigationAPIFactory::GetInstance();
   ExtensionManagementAPIFactory::GetInstance();
 #endif
   FaviconServiceFactory::GetInstance();
   FindBarStateFactory::GetInstance();
 #if defined(USE_AURA)
   GesturePrefsObserverFactoryAura::GetInstance();
 #endif
   GlobalErrorServiceFactory::GetInstance();
   GoogleURLTrackerFactory::GetInstance();
   HistoryServiceFactory::GetInstance();
   MediaGalleriesPreferencesFactory::GetInstance();
   NTPResourceCacheFactory::GetInstance();
   PasswordStoreFactory::GetInstance();
   PersonalDataManagerFactory::GetInstance();
 #if !defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
 #endif
   PluginPrefsFactory::GetInstance();
 #if defined(ENABLE_CONFIGURATION_POLICY) && !defined(OS_CHROMEOS)
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
   predictors::AutocompleteActionPredictorFactory::GetInstance();
   predictors::PredictorDatabaseFactory::GetInstance();
   predictors::ResourcePrefetchPredictorFactory::GetInstance();
   prerender::PrerenderManagerFactory::GetInstance();
   prerender::PrerenderLinkManagerFactory::GetInstance();
   ProfileSyncServiceFactory::GetInstance();
   ProtocolHandlerRegistryFactory::GetInstance();
 #if defined(ENABLE_PROTECTOR_SERVICE)
   protector::ProtectorServiceFactory::GetInstance();
 #endif
 #if defined(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
   ShortcutsBackendFactory::GetInstance();
   ThumbnailServiceFactory::GetInstance();
   SigninManagerFactory::GetInstance();
 #if defined(ENABLE_INPUT_SPEECH)
   SpeechInputExtensionManager::InitializeFactory();
   ChromeSpeechRecognitionPreferences::InitializeFactory();
 #endif
   SpellcheckServiceFactory::GetInstance();
   TabRestoreServiceFactory::GetInstance();
   TemplateURLFetcherFactory::GetInstance();
   TemplateURLServiceFactory::GetInstance();
 #if defined(ENABLE_THEMES)
   ThemeServiceFactory::GetInstance();
 #endif
   TokenServiceFactory::GetInstance();
   UserStyleSheetWatcherFactory::GetInstance();
   VisitedLinkMasterFactory::GetInstance();
   WebDataServiceFactory::GetInstance();
 #if defined(ENABLE_WEB_INTENTS)
   WebIntentsRegistryFactory::GetInstance();
 #endif
 
   built_factories_ = true;
 }",[26],"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly implement web audio nodes, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
206645," void WebGLRenderingContextBase::TexImageImpl(
     TexImageFunctionID function_id,
     GLenum target,
     GLint level,
     GLint internalformat,
     GLint xoffset,
     GLint yoffset,
     GLint zoffset,
     GLenum format,
     GLenum type,
     Image* image,
     WebGLImageConversion::ImageHtmlDomSource dom_source,
     bool flip_y,
     bool premultiply_alpha,
     const IntRect& source_image_rect,
     GLsizei depth,
     GLint unpack_image_height) {
   const char* func_name = GetTexImageFunctionName(function_id);
   if (type == GL_UNSIGNED_INT_10F_11F_11F_REV) {
     type = GL_FLOAT;
   }
    Vector<uint8_t> data;
  
    IntRect sub_rect = source_image_rect;
  if (sub_rect == SentinelEmptyRect()) {
   if (sub_rect.IsValid() && sub_rect == SentinelEmptyRect()) {
      sub_rect = SafeGetImageSize(image);
    }
 
   bool selecting_sub_rectangle = false;
   if (!ValidateTexImageSubRectangle(func_name, function_id, image, sub_rect,
                                     depth, unpack_image_height,
                                     &selecting_sub_rectangle)) {
     return;
   }
 
   IntRect adjusted_source_image_rect = sub_rect;
   if (flip_y) {
     adjusted_source_image_rect.SetY(image->height() -
                                     adjusted_source_image_rect.MaxY());
   }
 
   WebGLImageConversion::ImageExtractor image_extractor(
       image, dom_source, premultiply_alpha,
       unpack_colorspace_conversion_ == GL_NONE);
   if (!image_extractor.ImagePixelData()) {
     SynthesizeGLError(GL_INVALID_VALUE, func_name, ""bad image data"");
     return;
   }
 
   WebGLImageConversion::DataFormat source_data_format =
       image_extractor.ImageSourceFormat();
   WebGLImageConversion::AlphaOp alpha_op = image_extractor.ImageAlphaOp();
   const void* image_pixel_data = image_extractor.ImagePixelData();
 
   bool need_conversion = true;
   if (type == GL_UNSIGNED_BYTE &&
       source_data_format == WebGLImageConversion::kDataFormatRGBA8 &&
       format == GL_RGBA && alpha_op == WebGLImageConversion::kAlphaDoNothing &&
       !flip_y && !selecting_sub_rectangle && depth == 1) {
     need_conversion = false;
   } else {
     if (!WebGLImageConversion::PackImageData(
             image, image_pixel_data, format, type, flip_y, alpha_op,
             source_data_format, image_extractor.ImageWidth(),
             image_extractor.ImageHeight(), adjusted_source_image_rect, depth,
             image_extractor.ImageSourceUnpackAlignment(), unpack_image_height,
             data)) {
       SynthesizeGLError(GL_INVALID_VALUE, func_name, ""packImage error"");
       return;
     }
   }
 
   ScopedUnpackParametersResetRestore temporary_reset_unpack(this);
   if (function_id == kTexImage2D) {
     TexImage2DBase(target, level, internalformat,
                    adjusted_source_image_rect.Width(),
                    adjusted_source_image_rect.Height(), 0, format, type,
                    need_conversion ? data.data() : image_pixel_data);
   } else if (function_id == kTexSubImage2D) {
     ContextGL()->TexSubImage2D(
         target, level, xoffset, yoffset, adjusted_source_image_rect.Width(),
         adjusted_source_image_rect.Height(), format, type,
         need_conversion ? data.data() : image_pixel_data);
   } else {
     if (function_id == kTexImage3D) {
       ContextGL()->TexImage3D(
           target, level, internalformat, adjusted_source_image_rect.Width(),
           adjusted_source_image_rect.Height(), depth, 0, format, type,
           need_conversion ? data.data() : image_pixel_data);
     } else {
       DCHECK_EQ(function_id, kTexSubImage3D);
       ContextGL()->TexSubImage3D(
           target, level, xoffset, yoffset, zoffset,
           adjusted_source_image_rect.Width(),
           adjusted_source_image_rect.Height(), depth, format, type,
           need_conversion ? data.data() : image_pixel_data);
     }
   }
 }","[26, 25]",Insufficient data validation in WebGL in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page.
7009,"search_impl(i_ctx_t *i_ctx_p, bool forward)
{
os_ptr op = osp;
os_ptr op1 = op - 1;
uint size = r_size(op);
uint count;
byte *pat;
byte *ptr;
byte ch;
int incr = forward ? 1 : -1;

check_read_type(*op1, t_string);
check_read_type(*op, t_string);
if (size > r_size(op1)) {
make_false(op);
return 0;
}
count = r_size(op1) - size;
ptr = op1->value.bytes;
if (size == 0)
goto found;
if (!forward)
ptr += count;
pat = op->value.bytes;
ch = pat[0];
do {
if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))
goto found;
ptr += incr;
}
while (count--);

make_false(op);
return 0;
found:
op->tas.type_attrs = op1->tas.type_attrs;
op->value.bytes = ptr;
r_set_size(op, size);
push(2);
op[-1] = *op1;
r_set_size(op - 1, ptr - op[-1].value.bytes);
op1->value.bytes = ptr + size;
r_set_size(op1, count + (!forward ? (size - 1) : 0));
make_true(op);
return 0;
}","[37, 38, 40, 41, 42, 43]","A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b."
203282," static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)
 {
 	git_pkt *pkt;
 	const char *line, *line_end;
 	size_t line_len;
 	int error;
 	int reading_from_buf = data_pkt_buf->size > 0;
 
 	if (reading_from_buf) {
 		 
 		git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);
 		line = data_pkt_buf->ptr;
 		line_len = data_pkt_buf->size;
 	}
 	else {
 		line = data_pkt->data;
 		line_len = data_pkt->len;
 	}
 
 	while (line_len > 0) {
 		error = git_pkt_parse_line(&pkt, line, &line_end, line_len);
 
 		if (error == GIT_EBUFS) {
 			 
 			if (!reading_from_buf)
 				git_buf_put(data_pkt_buf, line, line_len);
 			error = 0;
 			goto done;
 		}
 		else if (error < 0)
 			goto done;
 
 		 
  		line_len -= (line_end - line);
  		line = line_end;
  
		 
		if (pkt == NULL)
			continue;
  		error = add_push_report_pkt(push, pkt);
  
  		git_pkt_free(pkt);
 
 		if (error < 0 && error != GIT_ITEROVER)
 			goto done;
 	}
 
 	error = 0;
 
 done:
 	if (reading_from_buf)
 		git_buf_consume(data_pkt_buf, line_end);
 	return error;
 }","[37, 38, 39]",The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.
8504,"static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {
json_t * j_error = json_array(), * j_return;
cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;
int i, ret;
char * message = NULL;
gnutls_pubkey_t pubkey = NULL;
gnutls_x509_crt_t cert = NULL;
gnutls_datum_t cert_dat, data, signature, cert_issued_by;
unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];
size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;

if (j_error != NULL) {
do {
if (gnutls_x509_crt_init(&cert)) {
json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_x509_crt_init""));
break;
}
if (gnutls_pubkey_init(&pubkey)) {
json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_pubkey_init""));
break;
}


if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) {
json_array_append_new(j_error, json_string(""CBOR map value 'attStmt' invalid format""));
break;
}
for (i=0; i<2; i++) {
key = cbor_map_handle(att_stmt)[i].key;
if (cbor_isa_string(key)) {
if (0 == o_strncmp((const char *)cbor_string_handle(key), ""x5c"", MIN(o_strlen(""x5c""), cbor_string_length(key)))) {
x5c = cbor_map_handle(att_stmt)[i].value;
} else if (0 == o_strncmp((const char *)cbor_string_handle(key), ""sig"", MIN(o_strlen(""sig""), cbor_string_length(key)))) {
sig = cbor_map_handle(att_stmt)[i].value;
} else {
message = msprintf(""attStmt map element %d key is not valid: '%.*s'"", i, cbor_string_length(key), cbor_string_handle(key));
json_array_append_new(j_error, json_string(message));
o_free(message);
break;
}
} else {
message = msprintf(""attStmt map element %d key is not a string"", i);
json_array_append_new(j_error, json_string(message));
o_free(message);
break;
}
}
if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) {
json_array_append_new(j_error, json_string(""CBOR map value 'x5c' invalid format""));
break;
}
att_cert = cbor_array_get(x5c, 0);
cert_dat.data = cbor_bytestring_handle(att_cert);
cert_dat.size = cbor_bytestring_length(att_cert);
if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) {
json_array_append_new(j_error, json_string(""Error importing x509 certificate""));
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d"", ret);
break;
}
if (json_object_get(j_params, ""root-ca-list"") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) {
json_array_append_new(j_error, json_string(""Unrecognized certificate authority""));
if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) {
message = msprintf(""Unrecognized certificate autohority: %.*s"", cert_issued_by.size, cert_issued_by.data);
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - %s"", message);
o_free(message);
gnutls_free(cert_issued_by.data);
} else {
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)"");
}
break;
}
if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) {
json_array_append_new(j_error, json_string(""Error importing x509 certificate""));
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d"", ret);
break;
}
if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) {
json_array_append_new(j_error, json_string(""Error exporting x509 certificate""));
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d"", ret);
break;
}
if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) {
json_array_append_new(j_error, json_string(""Internal error""));
y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error o_base64_encode cert_export"");
break;
}
if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {
json_array_append_new(j_error, json_string(""Internal error""));
y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error generate_digest_raw client_data"");
break;
}

if (sig == NULL || !cbor_isa_bytestring(sig)) {
json_array_append_new(j_error, json_string(""Error sig is not a bytestring""));
break;
}


data_signed[0] = 0x0;
data_signed_offset = 1;

memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);
data_signed_offset += rpid_hash_len;

memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);
data_signed_offset+=client_data_hash_len;

memcpy(data_signed+data_signed_offset, credential_id, credential_id_len);
data_signed_offset+=credential_id_len;

data_signed[data_signed_offset] = 0x04;
data_signed_offset++;

memcpy(data_signed+data_signed_offset, cert_x, cert_x_len);
data_signed_offset+=cert_x_len;

memcpy(data_signed+data_signed_offset, cert_y, cert_y_len);
data_signed_offset+=cert_y_len;


data.data = data_signed;
data.size = data_signed_offset;

signature.data = cbor_bytestring_handle(sig);
signature.size = cbor_bytestring_length(sig);

if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {
json_array_append_new(j_error, json_string(""Invalid signature""));
}

} while (0);

if (json_array_size(j_error)) {
j_return = json_pack(""{sisO}"", ""result"", G_ERROR_PARAM, ""error"", j_error);
} else {
j_return = json_pack(""{sis{ss%}}"", ""result"", G_OK, ""data"", ""certificate"", cert_export_b64, cert_export_b64_len);
}
json_decref(j_error);
gnutls_pubkey_deinit(pubkey);
gnutls_x509_crt_deinit(cert);
if (att_cert != NULL) {
cbor_decref(&att_cert);
}

} else {
y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error allocating resources for j_error"");
j_return = json_pack(""{si}"", ""result"", G_ERROR);
}
return j_return;
}","[9, 99, 133]",scheme/webauthn.c in Glewlwyd SSO server through 2.5.3 has a buffer overflow during FIDO2 signature validation in webauthn registration.
205773,"  void RenderParamsFromPrintSettings(const PrintSettings& settings,
                                     PrintMsg_Print_Params* params) {
    params->page_size = settings.page_setup_device_units().physical_size();
   params->content_size.SetSize(
       settings.page_setup_device_units().content_area().width(),
       settings.page_setup_device_units().content_area().height());
   params->printable_area.SetRect(
       settings.page_setup_device_units().printable_area().x(),
       settings.page_setup_device_units().printable_area().y(),
       settings.page_setup_device_units().printable_area().width(),
       settings.page_setup_device_units().printable_area().height());
   params->margin_top = settings.page_setup_device_units().content_area().y();
   params->margin_left = settings.page_setup_device_units().content_area().x();
   params->dpi = settings.dpi();
   params->scale_factor = settings.scale_factor();
   params->rasterize_pdf = settings.rasterize_pdf();
   params->document_cookie = 0;
   params->selection_only = settings.selection_only();
   params->supports_alpha_blend = settings.supports_alpha_blend();
   params->should_print_backgrounds = settings.should_print_backgrounds();
    params->display_header_footer = settings.display_header_footer();
    params->title = settings.title();
    params->url = settings.url();
  params->printed_doc_type = SkiaDocumentType::PDF;
   params->printed_doc_type =
       IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;
  }","[25, 26, 24]","The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call."
205804,"  bool AXObject::isHiddenForTextAlternativeCalculation() const {
  if (equalIgnoringCase(getAttribute(aria_hiddenAttr), ""false""))
   if (equalIgnoringASCIICase(getAttribute(aria_hiddenAttr), ""false""))
      return false;
  
    if (getLayoutObject())
     return getLayoutObject()->style()->visibility() != EVisibility::kVisible;
 
   Document* document = getDocument();
   if (!document || !document->frame())
     return false;
   if (Node* node = getNode()) {
     if (node->isConnected() && node->isElementNode()) {
       RefPtr<ComputedStyle> style =
           document->ensureStyleResolver().styleForElement(toElement(node));
       return style->display() == EDisplay::kNone ||
              style->visibility() != EVisibility::kVisible;
     }
   }
   return false;
 }","[3, 2]","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
206935,"  void ExtensionBrowserTest::OpenWindow(content::WebContents* contents,
                                        const GURL& url,
                                        bool newtab_process_should_equal_opener,
                                       bool should_succeed,
                                        content::WebContents** newtab_result) {
    content::WebContentsAddedObserver tab_added_observer;
    ASSERT_TRUE(content::ExecuteScript(contents,
                                       ""window.open('"" + url.spec() + ""');""));
    content::WebContents* newtab = tab_added_observer.GetWebContents();
    ASSERT_TRUE(newtab);
    WaitForLoadStop(newtab);
  EXPECT_EQ(url, newtab->GetLastCommittedURL());
 
   if (should_succeed) {
     EXPECT_EQ(url, newtab->GetLastCommittedURL());
     EXPECT_EQ(content::PAGE_TYPE_NORMAL,
               newtab->GetController().GetLastCommittedEntry()->GetPageType());
   } else {
      
      
     EXPECT_TRUE(
         newtab->GetLastCommittedURL() == GURL(url::kAboutBlankURL) ||
         newtab->GetController().GetLastCommittedEntry()->GetPageType() ==
             content::PAGE_TYPE_ERROR);
   }
 
    if (newtab_process_should_equal_opener) {
      EXPECT_EQ(contents->GetMainFrame()->GetSiteInstance(),
                newtab->GetMainFrame()->GetSiteInstance());
   } else {
     EXPECT_NE(contents->GetMainFrame()->GetSiteInstance(),
               newtab->GetMainFrame()->GetSiteInstance());
   }
 
   if (newtab_result)
     *newtab_result = newtab;
 }","[4, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 12]",Insufficient Policy Enforcement in Extensions in Google Chrome prior to 62.0.3202.62 allowed a remote attacker to access Extension pages without authorisation via a crafted HTML page.
208027," void SkippedMBMotionComp(
  VideoDecData *video
 )
 {
  Vop *prev = video->prevVop;
  Vop *comp;
  int ypos, xpos;
     PIXEL *c_comp, *c_prev;
     PIXEL *cu_comp, *cu_prev;
     PIXEL *cv_comp, *cv_prev;
  int width, width_uv;
  int32 offset;
 #ifdef PV_POSTPROC_ON  
  int imv;
  int32 size = (int32) video->nTotalMB << 8;
  uint8 *pp_dec_y, *pp_dec_u;
  uint8 *pp_prev1;
  int mvwidth = video->nMBPerRow << 1;
 #endif
 
     width = video->width;
     width_uv  = width >> 1;
     ypos = video->mbnum_row << 4 ;
     xpos = video->mbnum_col << 4 ;
     offset = (int32)ypos * width + xpos;
 
 
  
       
       
    c_prev  = prev->yChan + offset;
     c_prev  = prev->yChan;
     if (!c_prev) {
         ALOGE(""b/35269635"");
         android_errorWriteLog(0x534e4554, ""35269635"");
         return;
     }
     c_prev += offset;
 
       
      cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
       
     cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);
 
     comp = video->currVop;
 
     c_comp  = comp->yChan + offset;
     cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);
     cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);
 
 
   
  PutSKIPPED_MB(c_comp,  c_prev, width);
  PutSKIPPED_B(cu_comp, cu_prev, width_uv);
  PutSKIPPED_B(cv_comp, cv_prev, width_uv);
 
   
 #ifdef PV_POSTPROC_ON  
  if (video->postFilterType != PV_NO_POST_PROC)
  {
         imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
   
         pp_prev1 = video->pstprcTypPrv + imv;
         pp_dec_y = video->pstprcTypCur + imv;
  *pp_dec_y = *pp_prev1;
  *(pp_dec_y + 1) = *(pp_prev1 + 1);
  *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);
  *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);
 
   
   
         pp_prev1 = video->pstprcTypPrv + (size >> 6) +
  ((imv + (xpos >> 3)) >> 2);
         pp_dec_u = video->pstprcTypCur + (size >> 6) +
  ((imv + (xpos >> 3)) >> 2);
  *pp_dec_u = *pp_prev1;
         pp_dec_u[size>>8] = pp_prev1[size>>8];
  }
 #endif
   
 
  return;
 }","[32, 33, 34, 35, 36, 37, 38, 39, 31]","A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635."
8907,"R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {
ut64 offset = 6;
RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
if (!attr || sz < 10) {
free (attr);
return NULL;
}
attr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;
attr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);
offset += 2;
attr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);
offset += 2;
attr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);
if (attr->info.enclosing_method_attr.class_name == NULL) {
eprintf (""Could not resolve enclosing class name for the enclosed method.\n"");
}
attr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);
if (attr->info.enclosing_method_attr.class_name == NULL) {
eprintf (""Could not resolve method descriptor for the enclosed method.\n"");
}
attr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);
if (attr->info.enclosing_method_attr.method_name == NULL) {
eprintf (""Could not resolve method name for the enclosed method.\n"");
}
attr->size = offset;
return attr;
}",[3],Buffer Access with Incorrect Length Value in GitHub repository radareorg/radare2 prior to 5.6.2.
200847," int usb_get_bos_descriptor(struct usb_device *dev)
 {
 	struct device *ddev = &dev->dev;
 	struct usb_bos_descriptor *bos;
 	struct usb_dev_cap_header *cap;
 	unsigned char *buffer;
 	int length, total_len, num, i;
 	int ret;
 
 	bos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);
 	if (!bos)
 		return -ENOMEM;
 
 	 
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
 	if (ret < USB_DT_BOS_SIZE) {
 		dev_err(ddev, ""unable to get BOS descriptor\n"");
 		if (ret >= 0)
 			ret = -ENOMSG;
 		kfree(bos);
 		return ret;
 	}
 
 	length = bos->bLength;
 	total_len = le16_to_cpu(bos->wTotalLength);
 	num = bos->bNumDeviceCaps;
 	kfree(bos);
 	if (total_len < length)
 		return -EINVAL;
 
 	dev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);
 	if (!dev->bos)
 		return -ENOMEM;
 
 	 
 	buffer = kzalloc(total_len, GFP_KERNEL);
 	if (!buffer) {
 		ret = -ENOMEM;
 		goto err;
 	}
 	dev->bos->desc = (struct usb_bos_descriptor *)buffer;
 
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);
 	if (ret < total_len) {
 		dev_err(ddev, ""unable to get BOS descriptor set\n"");
 		if (ret >= 0)
 			ret = -ENOMSG;
 		goto err;
 	}
 	total_len -= length;
 
  	for (i = 0; i < num; i++) {
  		buffer += length;
  		cap = (struct usb_dev_cap_header *)buffer;
		length = cap->bLength;
  
		if (total_len < length)
 		if (total_len < sizeof(*cap) || total_len < cap->bLength) {
 			dev->bos->desc->bNumDeviceCaps = i;
  			break;
 		}
 		length = cap->bLength;
  		total_len -= length;
  
  		if (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
 			dev_warn(ddev, ""descriptor type invalid, skip\n"");
 			continue;
 		}
 
 		switch (cap->bDevCapabilityType) {
 		case USB_CAP_TYPE_WIRELESS_USB:
 			 
 			break;
 		case USB_CAP_TYPE_EXT:
 			dev->bos->ext_cap =
 				(struct usb_ext_cap_descriptor *)buffer;
 			break;
 		case USB_SS_CAP_TYPE:
 			dev->bos->ss_cap =
 				(struct usb_ss_cap_descriptor *)buffer;
 			break;
 		case USB_SSP_CAP_TYPE:
 			dev->bos->ssp_cap =
 				(struct usb_ssp_cap_descriptor *)buffer;
 			break;
 		case CONTAINER_ID_TYPE:
 			dev->bos->ss_id =
 				(struct usb_ss_container_id_descriptor *)buffer;
 			break;
 		case USB_PTM_CAP_TYPE:
 			dev->bos->ptm_cap =
 				(struct usb_ptm_cap_descriptor *)buffer;
 		default:
 			break;
 		}
 	}
 
 	return 0;
 
 err:
 	usb_release_bos_descriptor(dev);
 	return ret;
 }","[58, 59, 61, 62, 55, 57]",The usb_get_bos_descriptor function in drivers/usb/core/config.c in the Linux kernel before 4.13.10 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
205768,"  void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(
     const PrintHostMsg_DidPreviewDocument_Params& params) {
   StopWorker(params.document_cookie);
 
   if (params.expected_pages_count <= 0) {
     NOTREACHED();
     return;
   }
 
   PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
    if (!print_preview_ui)
      return;
  
  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  if (!data_bytes || !data_bytes->size())
    return;
  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,
                                                std::move(data_bytes));
  print_preview_ui->OnPreviewDataIsAvailable(
      params.expected_pages_count, params.preview_request_id);
   if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
     auto* client = PrintCompositeClient::FromWebContents(web_contents());
     DCHECK(client);
 
     client->DoComposite(
         params.metafile_data_handle, params.data_size,
         base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,
                        weak_ptr_factory_.GetWeakPtr(),
                        params.expected_pages_count, params.preview_request_id));
   } else {
     NotifyUIPreviewDocumentReady(
         params.expected_pages_count, params.preview_request_id,
         GetDataFromHandle(params.metafile_data_handle, params.data_size));
   }
  }","[22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 14, 15, 16, 17, 18, 19, 20, 21]","The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call."
203786," bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,
                                            size_t glyph_count,
                                            IntegerSet* glyph_id_processed) {
   if (glyph_ids == NULL || glyph_count == 0 || glyph_id_processed == NULL) {
     return false;
   }
 
   GlyphTablePtr glyph_table =
       down_cast<GlyphTable*>(font_->GetTable(Tag::glyf));
   LocaTablePtr loca_table = down_cast<LocaTable*>(font_->GetTable(Tag::loca));
   if (glyph_table == NULL || loca_table == NULL) {
     return false;
   }
 
   IntegerSet glyph_id_remaining;
   glyph_id_remaining.insert(0);   
   for (size_t i = 0; i < glyph_count; ++i) {
     glyph_id_remaining.insert(glyph_ids[i]);
   }
 
   while (!glyph_id_remaining.empty()) {
     IntegerSet comp_glyph_id;
     for (IntegerSet::iterator i = glyph_id_remaining.begin(),
                               e = glyph_id_remaining.end(); i != e; ++i) {
       if (*i < 0 || *i >= loca_table->NumGlyphs()) {
         continue;
       }
 
       int32_t length = loca_table->GlyphLength(*i);
       if (length == 0) {
         continue;
       }
       int32_t offset = loca_table->GlyphOffset(*i);
 
       GlyphPtr glyph;
       glyph.Attach(glyph_table->GetGlyph(offset, length));
       if (glyph == NULL) {
         continue;
       }
 
       if (glyph->GlyphType() == GlyphType::kComposite) {
         Ptr<GlyphTable::CompositeGlyph> comp_glyph =
             down_cast<GlyphTable::CompositeGlyph*>(glyph.p_);
         for (int32_t j = 0; j < comp_glyph->NumGlyphs(); ++j) {
           int32_t glyph_id = comp_glyph->GlyphIndex(j);
           if (glyph_id_processed->find(glyph_id) == glyph_id_processed->end() &&
               glyph_id_remaining.find(glyph_id) == glyph_id_remaining.end()) {
             comp_glyph_id.insert(comp_glyph->GlyphIndex(j));
           }
         }
       }
 
       glyph_id_processed->insert(*i);
     }
 
      glyph_id_remaining.clear();
      glyph_id_remaining = comp_glyph_id;
    }
 
   return true;
  }","[59, 60]","Google Chrome before 14.0.835.163 does not properly handle Tibetan characters, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
2822,"static void *zend_mm_realloc_heap(zend_mm_heap *heap, void *ptr, size_t size, size_t copy_size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)
{
size_t page_offset;
size_t old_size;
size_t new_size;
void *ret;
#if ZEND_DEBUG
size_t real_size;
zend_mm_debug_info *dbg;
#endif

page_offset = ZEND_MM_ALIGNED_OFFSET(ptr, ZEND_MM_CHUNK_SIZE);
if (UNEXPECTED(page_offset == 0)) {
if (UNEXPECTED(ptr == NULL)) {
return zend_mm_alloc_heap(heap, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
}
old_size = zend_mm_get_huge_block_size(heap, ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#if ZEND_DEBUG
real_size = size;
size = ZEND_MM_ALIGNED_SIZE(size) + ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info));
#endif
if (size > ZEND_MM_MAX_LARGE_SIZE) {
#if ZEND_DEBUG
size = real_size;
#endif
#ifdef ZEND_WIN32




new_size = ZEND_MM_ALIGNED_SIZE_EX(size, MAX(REAL_PAGE_SIZE, ZEND_MM_CHUNK_SIZE));
#else
new_size = ZEND_MM_ALIGNED_SIZE_EX(size, REAL_PAGE_SIZE);
#endif
if (new_size == old_size) {
#if ZEND_DEBUG
zend_mm_change_huge_block_size(heap, ptr, new_size, real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#else
zend_mm_change_huge_block_size(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#endif
return ptr;
} else if (new_size < old_size) {

if (zend_mm_chunk_truncate(heap, ptr, old_size, new_size)) {
#if ZEND_MM_STAT || ZEND_MM_LIMIT
heap->real_size -= old_size - new_size;
#endif
#if ZEND_MM_STAT
heap->size -= old_size - new_size;
#endif
#if ZEND_DEBUG
zend_mm_change_huge_block_size(heap, ptr, new_size, real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#else
zend_mm_change_huge_block_size(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#endif
return ptr;
}
} else                                {
#if ZEND_MM_LIMIT
if (UNEXPECTED(heap->real_size + (new_size - old_size) > heap->limit)) {
if (zend_mm_gc(heap) && heap->real_size + (new_size - old_size) <= heap->limit) {

} else if (heap->overflow == 0) {
#if ZEND_DEBUG
zend_mm_safe_error(heap, ""Allowed memory size of %zu bytes exhausted at %s:%d (tried to allocate %zu bytes)"", heap->limit, __zend_filename, __zend_lineno, size);
#else
zend_mm_safe_error(heap, ""Allowed memory size of %zu bytes exhausted (tried to allocate %zu bytes)"", heap->limit, size);
#endif
return NULL;
}
}
#endif

if (zend_mm_chunk_extend(heap, ptr, old_size, new_size)) {
#if ZEND_MM_STAT || ZEND_MM_LIMIT
heap->real_size += new_size - old_size;
#endif
#if ZEND_MM_STAT
heap->real_peak = MAX(heap->real_peak, heap->real_size);
heap->size += new_size - old_size;
heap->peak = MAX(heap->peak, heap->size);
#endif
#if ZEND_DEBUG
zend_mm_change_huge_block_size(heap, ptr, new_size, real_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#else
zend_mm_change_huge_block_size(heap, ptr, new_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#endif
return ptr;
}
}
}
} else {
zend_mm_chunk *chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(ptr, ZEND_MM_CHUNK_SIZE);
int page_num = (int)(page_offset / ZEND_MM_PAGE_SIZE);
zend_mm_page_info info = chunk->map[page_num];
#if ZEND_DEBUG
size_t real_size = size;

size = ZEND_MM_ALIGNED_SIZE(size) + ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info));
#endif

ZEND_MM_CHECK(chunk->heap == heap, ""zend_mm_heap corrupted"");
if (info & ZEND_MM_IS_SRUN) {
int old_bin_num, bin_num;

old_bin_num = ZEND_MM_SRUN_BIN_NUM(info);
old_size = bin_data_size[old_bin_num];
bin_num = ZEND_MM_SMALL_SIZE_TO_BIN(size);
if (old_bin_num == bin_num) {
#if ZEND_DEBUG
dbg = zend_mm_get_debug_info(heap, ptr);
dbg->size = real_size;
dbg->filename = __zend_filename;
dbg->orig_filename = __zend_orig_filename;
dbg->lineno = __zend_lineno;
dbg->orig_lineno = __zend_orig_lineno;
#endif
return ptr;
}
} else                                        {
ZEND_MM_CHECK(ZEND_MM_ALIGNED_OFFSET(page_offset, ZEND_MM_PAGE_SIZE) == 0, ""zend_mm_heap corrupted"");
old_size = ZEND_MM_LRUN_PAGES(info) * ZEND_MM_PAGE_SIZE;
if (size > ZEND_MM_MAX_SMALL_SIZE && size <= ZEND_MM_MAX_LARGE_SIZE) {
new_size = ZEND_MM_ALIGNED_SIZE_EX(size, ZEND_MM_PAGE_SIZE);
if (new_size == old_size) {
#if ZEND_DEBUG
dbg = zend_mm_get_debug_info(heap, ptr);
dbg->size = real_size;
dbg->filename = __zend_filename;
dbg->orig_filename = __zend_orig_filename;
dbg->lineno = __zend_lineno;
dbg->orig_lineno = __zend_orig_lineno;
#endif
return ptr;
} else if (new_size < old_size) {

int new_pages_count = (int)(new_size / ZEND_MM_PAGE_SIZE);
int rest_pages_count = (int)((old_size - new_size) / ZEND_MM_PAGE_SIZE);

#if ZEND_MM_STAT
heap->size -= rest_pages_count * ZEND_MM_PAGE_SIZE;
#endif
chunk->map[page_num] = ZEND_MM_LRUN(new_pages_count);
chunk->free_pages += rest_pages_count;
zend_mm_bitset_reset_range(chunk->free_map, page_num + new_pages_count, rest_pages_count);
#if ZEND_DEBUG
dbg = zend_mm_get_debug_info(heap, ptr);
dbg->size = real_size;
dbg->filename = __zend_filename;
dbg->orig_filename = __zend_orig_filename;
dbg->lineno = __zend_lineno;
dbg->orig_lineno = __zend_orig_lineno;
#endif
return ptr;
} else                                {
int new_pages_count = (int)(new_size / ZEND_MM_PAGE_SIZE);
int old_pages_count = (int)(old_size / ZEND_MM_PAGE_SIZE);


if (page_num + new_pages_count <= ZEND_MM_PAGES &&
zend_mm_bitset_is_free_range(chunk->free_map, page_num + old_pages_count, new_pages_count - old_pages_count)) {
#if ZEND_MM_STAT
do {
size_t size = heap->size + (new_size - old_size);
size_t peak = MAX(heap->peak, size);
heap->size = size;
heap->peak = peak;
} while (0);
#endif
chunk->free_pages -= new_pages_count - old_pages_count;
zend_mm_bitset_set_range(chunk->free_map, page_num + old_pages_count, new_pages_count - old_pages_count);
chunk->map[page_num] = ZEND_MM_LRUN(new_pages_count);
#if ZEND_DEBUG
dbg = zend_mm_get_debug_info(heap, ptr);
dbg->size = real_size;
dbg->filename = __zend_filename;
dbg->orig_filename = __zend_orig_filename;
dbg->lineno = __zend_lineno;
dbg->orig_lineno = __zend_orig_lineno;
#endif
return ptr;
}
}
}
}
#if ZEND_DEBUG
size = real_size;
#endif
}


#if ZEND_MM_STAT
do {
size_t orig_peak = heap->peak;
size_t orig_real_peak = heap->real_peak;
#endif
ret = zend_mm_alloc_heap(heap, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
memcpy(ret, ptr, MIN(old_size, copy_size));
zend_mm_free_heap(heap, ptr ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
#if ZEND_MM_STAT
heap->peak = MAX(orig_peak, heap->size);
heap->real_peak = MAX(orig_real_peak, heap->real_size);
} while (0);
#endif
return ret;
}","[104, 106, 108, 109, 111, 112, 113, 114, 115, 116, 118]","Zend/zend_alloc.c in PHP 7.x before 7.0.10, when open_basedir is enabled, mishandles huge realloc operations, which allows remote attackers to cause a denial of service (integer overflow) or possibly have unspecified other impact via a long pathname."
202324," static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
 {
 	struct uvesafb_pal_entry *entries;
 	int shift = 16 - dac_width;
 	int i, err = 0;
 
 	if (info->var.bits_per_pixel == 8) {
 		if (cmap->start + cmap->len > info->cmap.start +
  		    info->cmap.len || cmap->start < info->cmap.start)
  			return -EINVAL;
  
		entries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);
 		entries = kmalloc_array(cmap->len, sizeof(*entries),
 					GFP_KERNEL);
  		if (!entries)
  			return -ENOMEM;
  
 		for (i = 0; i < cmap->len; i++) {
 			entries[i].red   = cmap->red[i]   >> shift;
 			entries[i].green = cmap->green[i] >> shift;
 			entries[i].blue  = cmap->blue[i]  >> shift;
 			entries[i].pad   = 0;
 		}
 		err = uvesafb_setpalette(entries, cmap->len, cmap->start, info);
 		kfree(entries);
 	} else {
 		 
 		for (i = 0; i < cmap->len; i++) {
 			err |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],
 						cmap->green[i], cmap->blue[i],
 						0, info);
 		}
 	}
 	return err;
 }","[13, 14, 12]",An integer overflow in the uvesafb_setcmap function in drivers/video/fbdev/uvesafb.c in the Linux kernel before 4.17.4 could result in local attackers being able to crash the kernel or potentially elevate privileges because kmalloc_array is not used.
206393,"  void WarmupURLFetcher::FetchWarmupURLNow(
      const DataReductionProxyServer& proxy_server) {
    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(!params::IsIncludedInHoldbackFieldTrial());
  
    UMA_HISTOGRAM_EXACT_LINEAR(""DataReductionProxy.WarmupURL.FetchInitiated"", 1,
                               2);
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation(""data_reduction_proxy_warmup"", R""(
           semantics {
             sender: ""Data Reduction Proxy""
             description:
               ""Sends a request to the Data Reduction Proxy server to warm up ""
               ""the connection to the proxy.""
             trigger:
               ""A network change while the data reduction proxy is enabled will ""
               ""trigger this request.""
             data: ""A specific URL, not related to user data.""
             destination: GOOGLE_OWNED_SERVICE
           }
           policy {
             cookies_allowed: NO
             setting:
               ""Users can control Data Saver on Android via the 'Data Saver' ""
               ""setting. Data Saver is not available on iOS, and on desktop it ""
               ""is enabled by installing the Data Saver extension.""
             policy_exception_justification: ""Not implemented.""
           })"");
 
   GURL warmup_url_with_query_params;
   GetWarmupURLWithQueryParam(&warmup_url_with_query_params);
 
   url_loader_.reset();
   fetch_timeout_timer_.Stop();
   is_fetch_in_flight_ = true;
 
   auto resource_request = std::make_unique<network::ResourceRequest>();
   resource_request->url = warmup_url_with_query_params;
   resource_request->load_flags = net::LOAD_BYPASS_CACHE;
 
   resource_request->render_frame_id = MSG_ROUTING_CONTROL;
 
   url_loader_ = network::SimpleURLLoader::Create(std::move(resource_request),
                                                  traffic_annotation);
   static const int kMaxRetries = 5;
   url_loader_->SetRetryOptions(
       kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);
   url_loader_->SetAllowHttpErrorResults(true);
 
   fetch_timeout_timer_.Start(FROM_HERE, GetFetchTimeout(), this,
                              &WarmupURLFetcher::OnFetchTimeout);
 
   url_loader_->SetOnResponseStartedCallback(base::BindOnce(
       &WarmupURLFetcher::OnURLLoadResponseStarted, base::Unretained(this)));
   url_loader_->SetOnRedirectCallback(base::BindRepeating(
       &WarmupURLFetcher::OnURLLoaderRedirect, base::Unretained(this)));
 
   url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
       GetNetworkServiceURLLoaderFactory(proxy_server),
       base::BindOnce(&WarmupURLFetcher::OnURLLoadComplete,
                      base::Unretained(this)));
 }",[4],"A use after free in PDFium in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
205636," void FrameSelection::SelectAll(SetSelectionBy set_selection_by) {
   if (isHTMLSelectElement(GetDocument().FocusedElement())) {
     HTMLSelectElement* select_element =
         toHTMLSelectElement(GetDocument().FocusedElement());
     if (select_element->CanSelectAll()) {
       select_element->SelectAll();
       return;
     }
   }
 
   Node* root = nullptr;
   Node* select_start_target = nullptr;
   if (set_selection_by == SetSelectionBy::kUser && IsHidden()) {
     root = GetDocument().documentElement();
     select_start_target = GetDocument().body();
   } else if (ComputeVisibleSelectionInDOMTree().IsContentEditable()) {
     root = HighestEditableRoot(ComputeVisibleSelectionInDOMTree().Start());
     if (Node* shadow_root = NonBoundaryShadowTreeRootNode(
             ComputeVisibleSelectionInDOMTree().Start()))
       select_start_target = shadow_root->OwnerShadowHost();
     else
       select_start_target = root;
   } else {
     root = NonBoundaryShadowTreeRootNode(
         ComputeVisibleSelectionInDOMTree().Start());
     if (root) {
       select_start_target = root->OwnerShadowHost();
     } else {
       root = GetDocument().documentElement();
       select_start_target = GetDocument().body();
     }
   }
   if (!root || EditingIgnoresContent(*root))
     return;
 
   if (select_start_target) {
     const Document& expected_document = GetDocument();
     if (select_start_target->DispatchEvent(Event::CreateCancelableBubble(
             EventTypeNames::selectstart)) != DispatchEventResult::kNotCanceled)
       return;
     if (!IsAvailable()) {
       return;
     }
     if (!root->isConnected() || expected_document != root->GetDocument())
       return;
    }
  
  SetSelection(SelectionInDOMTree::Builder()
                   .SelectAllChildren(*root)
                   .SetIsHandleVisible(IsHandleVisible())
   SetSelection(SelectionInDOMTree::Builder().SelectAllChildren(*root).Build(),
                SetSelectionData::Builder()
                    .SetShouldCloseTyping(true)
                    .SetShouldClearTypingStyle(true)
                    .SetShouldShowHandle(IsHandleVisible())
                     .Build());
    SelectFrameElementInParentIfFullySelected();
   NotifyTextControlOfSelectionChange(SetSelectionBy::kUser);
   if (IsHandleVisible()) {
     ContextMenuAllowedScope scope;
     frame_->GetEventHandler().ShowNonLocatedContextMenu(nullptr,
                                                         kMenuSourceTouch);
   }
 }","[51, 52, 53, 54, 55, 48, 49, 50]","The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data."
198425," static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)
 {
     const unsigned char *p, *pm;
     int pklen, pmlen;
     int ptype;
     void *pval;
     ASN1_STRING *pstr;
     X509_ALGOR *palg;
     ASN1_INTEGER *privkey = NULL;
     BN_CTX *ctx = NULL;
 
      STACK_OF(ASN1_TYPE) *ndsa = NULL;
      DSA *dsa = NULL;
  
     int ret = 0;
 
      if (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))
          return 0;
      X509_ALGOR_get0(NULL, &ptype, &pval, palg);
     if (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {
         ASN1_TYPE *t1, *t2;
         if (!(ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)))
             goto decerr;
         if (sk_ASN1_TYPE_num(ndsa) != 2)
             goto decerr;
          
 
         t1 = sk_ASN1_TYPE_value(ndsa, 0);
         t2 = sk_ASN1_TYPE_value(ndsa, 1);
         if (t1->type == V_ASN1_SEQUENCE) {
             p8->broken = PKCS8_EMBEDDED_PARAM;
             pval = t1->value.ptr;
         } else if (ptype == V_ASN1_SEQUENCE)
             p8->broken = PKCS8_NS_DB;
         else
             goto decerr;
 
         if (t2->type != V_ASN1_INTEGER)
             goto decerr;
 
         privkey = t2->value.integer;
     } else {
         const unsigned char *q = p;
         if (!(privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)))
             goto decerr;
         if (privkey->type == V_ASN1_NEG_INTEGER) {
             p8->broken = PKCS8_NEG_PRIVKEY;
             ASN1_STRING_clear_free(privkey);
             if (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))
                 goto decerr;
         }
         if (ptype != V_ASN1_SEQUENCE)
             goto decerr;
     }
 
     pstr = pval;
     pm = pstr->data;
     pmlen = pstr->length;
     if (!(dsa = d2i_DSAparams(NULL, &pm, pmlen)))
         goto decerr;
      
     if (!(dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL))) {
         DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);
         goto dsaerr;
     }
      
     if (!(dsa->pub_key = BN_new())) {
         DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);
         goto dsaerr;
     }
     if (!(ctx = BN_CTX_new())) {
         DSAerr(DSA_F_DSA_PRIV_DECODE, ERR_R_MALLOC_FAILURE);
         goto dsaerr;
     }
 
     if (!BN_mod_exp(dsa->pub_key, dsa->g, dsa->priv_key, dsa->p, ctx)) {
         DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);
         goto dsaerr;
     }
 
      }","[15, 16]",Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key.
7218,"static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)
{
struct parser_buf pbuf = {
.f_indx = 0,
.tmp_indx = 0,
.f_read_size = 0
};

int write_count = 0;
int src_fd;
int p_state = P_STATE_CODE;

src_fd = open(src, O_RDONLY);
if (src_fd == -1) {
fprintf(stderr, ""**Error: Could not open source file: %s.\n"", src);
return -1;
}

while (p_buf_refill(&pbuf, src_fd) > 0) {

while (PBUF_F_REMD(pbuf)) {

switch (p_state) {
case P_STATE_COMMENT_C:

switch (PBUF_F_CHAR(pbuf)) {
case '*':
p_buf_push_tmp_char(&pbuf, '*');
continue;

case '/':
if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {
pbuf.tmp_indx--;
p_state = P_STATE_CODE;
}
break;

default:
if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))
pbuf.tmp_indx--;
break;
}

pbuf.f_indx++;

case P_STATE_CODE:
default:



switch (PBUF_F_CHAR(pbuf)) {
case ' ':
case '\t':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
PBUF_TMP_PREV_CHAR(pbuf) == '\n'))
pbuf.f_indx++;
else
p_buf_push_tmp_char(&pbuf, ' ');

continue;

case '\r':
case '\n':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
PBUF_TMP_PREV_CHAR(pbuf) == '\n')) {
pbuf.f_indx++;
} else if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == '\\')) {
pbuf.tmp_indx--;
pbuf.f_indx++;
} else {
p_buf_push_tmp_char(&pbuf, '\n');
}

continue;

case '\\':
p_buf_push_tmp_char(&pbuf, '\\');
continue;

case '/':
p_buf_push_tmp_char(&pbuf, '/');
continue;

case '*':
if (pbuf.tmp_indx &&
(PBUF_TMP_PREV_CHAR(pbuf) == '/')) {
pbuf.tmp_indx--;
pbuf.f_indx++;
p_state = P_STATE_COMMENT_C;
continue;
}

default:
break;
}


p_buf_write_tmp(&pbuf, tmp_fd);
p_buf_write_f_char(&pbuf, tmp_fd);
}
}
}

p_buf_write_tmp(&pbuf, tmp_fd);
return 0;
}","[69, 80, 84]","Buffer overflow vulnerability in function src_parser_trans_stage_1_2_3 trgil gilcc before commit 803969389ca9c06237075a7f8eeb1a19e6651759, allows attackers to cause a denial of service."
202988,"  bgp_attr_print(netdissect_options *ndo,
               u_int atype, const u_char *pptr, u_int len)
                u_int atype, const u_char *pptr, u_int len, const unsigned attr_set_level)
  {
  	int i;
  	uint16_t af;
 	uint8_t safi, snpa, nhlen;
         union {  
             float f;
             uint32_t i;
         } bw;
 	int advance;
 	u_int tlen;
 	const u_char *tptr;
 	char buf[MAXHOSTNAMELEN + 100];
         int  as_size;
 
         tptr = pptr;
         tlen=len;
 
 	switch (atype) {
 	case BGPTYPE_ORIGIN:
 		if (len != 1)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK(*tptr);
 			ND_PRINT((ndo, ""%s"", tok2str(bgp_origin_values,
 						""Unknown Origin Typecode"",
 						tptr[0])));
 		}
 		break;
 
          
 	case BGPTYPE_AS4_PATH:
 	case BGPTYPE_AS_PATH:
 		if (len % 2) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 if (!len) {
 			ND_PRINT((ndo, ""empty""));
 			break;
                 }
 
                  
                 as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);
 
 		while (tptr < pptr + len) {
 			ND_TCHECK(tptr[0]);
                         ND_PRINT((ndo, ""%s"", tok2str(bgp_as_path_segment_open_values,
 						""?"", tptr[0])));
 			ND_TCHECK(tptr[1]);
                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
                             ND_TCHECK2(tptr[2 + i], as_size);
 			    ND_PRINT((ndo, ""%s "",
 				as_printf(ndo, astostr, sizeof(astostr),
 				as_size == 2 ?
 				EXTRACT_16BITS(&tptr[2 + i]) :
 				EXTRACT_32BITS(&tptr[2 + i]))));
                         }
 			ND_TCHECK(tptr[0]);
                         ND_PRINT((ndo, ""%s"", tok2str(bgp_as_path_segment_close_values,
 						""?"", tptr[0])));
                         ND_TCHECK(tptr[1]);
                         tptr += 2 + tptr[1] * as_size;
 		}
 		break;
 	case BGPTYPE_NEXT_HOP:
 		if (len != 4)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK2(tptr[0], 4);
 			ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr)));
 		}
 		break;
 	case BGPTYPE_MULTI_EXIT_DISC:
 	case BGPTYPE_LOCAL_PREF:
 		if (len != 4)
 			ND_PRINT((ndo, ""invalid len""));
 		else {
 			ND_TCHECK2(tptr[0], 4);
 			ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(tptr)));
 		}
 		break;
 	case BGPTYPE_ATOMIC_AGGREGATE:
 		if (len != 0)
 			ND_PRINT((ndo, ""invalid len""));
 		break;
         case BGPTYPE_AGGREGATOR:
 
                  
                 if (len != 6 && len != 8) {
                     ND_PRINT((ndo, ""invalid len""));
                     break;
                 }
                 ND_TCHECK2(tptr[0], len);
                 if (len == 6) {
 		    ND_PRINT((ndo, "" AS #%s, origin %s"",
 			as_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),
 			ipaddr_string(ndo, tptr + 2)));
                 } else {
 		    ND_PRINT((ndo, "" AS #%s, origin %s"",
 			as_printf(ndo, astostr, sizeof(astostr),
 			EXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));
                 }
                 break;
 	case BGPTYPE_AGGREGATOR4:
 		if (len != 8) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_TCHECK2(tptr[0], 8);
 		ND_PRINT((ndo, "" AS #%s, origin %s"",
 		    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),
 		    ipaddr_string(ndo, tptr + 4)));
 		break;
 	case BGPTYPE_COMMUNITIES:
 		if (len % 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		while (tlen>0) {
 			uint32_t comm;
 			ND_TCHECK2(tptr[0], 4);
 			comm = EXTRACT_32BITS(tptr);
 			switch (comm) {
 			case BGP_COMMUNITY_NO_EXPORT:
 				ND_PRINT((ndo, "" NO_EXPORT""));
 				break;
 			case BGP_COMMUNITY_NO_ADVERT:
 				ND_PRINT((ndo, "" NO_ADVERTISE""));
 				break;
 			case BGP_COMMUNITY_NO_EXPORT_SUBCONFED:
 				ND_PRINT((ndo, "" NO_EXPORT_SUBCONFED""));
 				break;
 			default:
 				ND_PRINT((ndo, ""%u:%u%s"",
                                        (comm >> 16) & 0xffff,
                                        comm & 0xffff,
                                        (tlen>4) ? "", "" : """"));
 				break;
 			}
                         tlen -=4;
                         tptr +=4;
 		}
 		break;
         case BGPTYPE_ORIGINATOR_ID:
 		if (len != 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_TCHECK2(tptr[0], 4);
                 ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, tptr)));
                 break;
         case BGPTYPE_CLUSTER_LIST:
 		if (len % 4) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 while (tlen>0) {
 			ND_TCHECK2(tptr[0], 4);
                         ND_PRINT((ndo, ""%s%s"",
                                ipaddr_string(ndo, tptr),
                                 (tlen>4) ? "", "" : """"));
                         tlen -=4;
                         tptr +=4;
                 }
                 break;
 	case BGPTYPE_MP_REACH_NLRI:
 		ND_TCHECK2(tptr[0], 3);
 		af = EXTRACT_16BITS(tptr);
 		safi = tptr[2];
 
                 ND_PRINT((ndo, ""\n\t    AFI: %s (%u), %sSAFI: %s (%u)"",
                        tok2str(af_values, ""Unknown AFI"", af),
                        af,
                        (safi>128) ? ""vendor specific "" : """",  
                        tok2str(bgp_safi_values, ""Unknown SAFI"", safi),
                        safi));
 
                 switch(af<<8 | safi) {
                 case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                 case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):
 		case (AFNUM_INET<<8 | SAFNUM_MDT):
                 case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                 case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                 case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     break;
                 default:
                     ND_TCHECK2(tptr[0], tlen);
                     ND_PRINT((ndo, ""\n\t    no AFI %u / SAFI %u decoder"", af, safi));
                     if (ndo->ndo_vflag <= 1)
                         print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                     goto done;
                     break;
                 }
 
                 tptr +=3;
 
 		ND_TCHECK(tptr[0]);
 		nhlen = tptr[0];
                 tlen = nhlen;
                 tptr++;
 
 		if (tlen) {
                     int nnh = 0;
                     ND_PRINT((ndo, ""\n\t    nexthop: ""));
                     while (tlen > 0) {
                         if ( nnh++ > 0 ) {
                             ND_PRINT((ndo,  "", "" ));
                         }
                         switch(af<<8 | safi) {
                         case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                         case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):
                         case (AFNUM_INET<<8 | SAFNUM_MDT):
 			    if (tlen < (int)sizeof(struct in_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr));
                                 ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, tptr)));
                                 tlen -= sizeof(struct in_addr);
                                 tptr += sizeof(struct in_addr);
                             }
                             break;
                         case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));
                                 tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                                 tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);
                             }
                             break;
                         case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                             if (tlen < (int)sizeof(struct in6_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in6_addr));
                                 ND_PRINT((ndo, ""%s"", ip6addr_string(ndo, tptr)));
                                 tlen -= sizeof(struct in6_addr);
                                 tptr += sizeof(struct in6_addr);
                             }
                             break;
                         case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));
                                 tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                                 tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);
                             }
                             break;
                         case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < (int)sizeof(struct in_addr)) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], sizeof(struct in_addr));
                                 ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr)));
                                 tlen -= (sizeof(struct in_addr));
                                 tptr += (sizeof(struct in_addr));
                             }
                             break;
                         case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                             ND_TCHECK2(tptr[0], tlen);
                             ND_PRINT((ndo, ""%s"", isonsap_string(ndo, tptr, tlen)));
                             tptr += tlen;
                             tlen = 0;
                             break;
 
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                         case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                             if (tlen < BGP_VPN_RD_LEN+1) {
                                 ND_PRINT((ndo, ""invalid len""));
                                 tlen = 0;
                             } else {
                                 ND_TCHECK2(tptr[0], tlen);
                                 ND_PRINT((ndo, ""RD: %s, %s"",
                                        bgp_vpn_rd_print(ndo, tptr),
                                        isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));
                                  
                                 if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
                                     && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
                                     ND_PRINT((ndo, "" = %s"", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));
                                  
                                 else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)
                                          && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
                                     ND_PRINT((ndo, "" = %s"", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));
                                 tptr += tlen;
                                 tlen = 0;
                             }
                             break;
                         default:
                             ND_TCHECK2(tptr[0], tlen);
                             ND_PRINT((ndo, ""no AFI %u/SAFI %u decoder"", af, safi));
                             if (ndo->ndo_vflag <= 1)
                                 print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                             tptr += tlen;
                             tlen = 0;
                             goto done;
                             break;
                         }
                     }
 		}
 		ND_PRINT((ndo, "", nh-length: %u"", nhlen));
 		tptr += tlen;
 
 		ND_TCHECK(tptr[0]);
 		snpa = tptr[0];
 		tptr++;
 
 		if (snpa) {
 			ND_PRINT((ndo, ""\n\t    %u SNPA"", snpa));
 			for ( ; snpa > 0; snpa--) {
 				ND_TCHECK(tptr[0]);
 				ND_PRINT((ndo, ""\n\t      %d bytes"", tptr[0]));
 				tptr += tptr[0] + 1;
 			}
 		} else {
 			ND_PRINT((ndo, "", no SNPA""));
                 }
 
 		while (tptr < pptr + len) {
                     switch (af<<8 | safi) {
                     case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):
                         advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):  
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):
                         advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
 
 		    case (AFNUM_INET<<8 | SAFNUM_MDT):
 		      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));
 		      if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
 		       break;
                     case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     default:
                         ND_TCHECK2(*tptr,tlen);
                         ND_PRINT((ndo, ""\n\t    no AFI %u / SAFI %u decoder"", af, safi));
                         if (ndo->ndo_vflag <= 1)
                             print_unknown_data(ndo, tptr, ""\n\t    "", tlen);
                         advance = 0;
                         tptr = pptr + len;
                         break;
                     }
                     if (advance < 0)
                         break;
                     tptr += advance;
 		}
         done:
 		break;
 
 	case BGPTYPE_MP_UNREACH_NLRI:
 		ND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);
 		af = EXTRACT_16BITS(tptr);
 		safi = tptr[2];
 
                 ND_PRINT((ndo, ""\n\t    AFI: %s (%u), %sSAFI: %s (%u)"",
                        tok2str(af_values, ""Unknown AFI"", af),
                        af,
                        (safi>128) ? ""vendor specific "" : """",  
                        tok2str(bgp_safi_values, ""Unknown SAFI"", safi),
                        safi));
 
                 if (len == BGP_MP_NLRI_MINSIZE)
                     ND_PRINT((ndo, ""\n\t      End-of-Rib Marker (empty NLRI)""));
 
 		tptr += 3;
 
 		while (tptr < pptr + len) {
                     switch (af<<8 | safi) {
                     case (AFNUM_INET<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_UNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):
                         advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else if (advance == -3)
                             break;  
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_VPLS<<8 | SAFNUM_VPLS):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):
                         advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):
                     case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):
                         advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
 		    case (AFNUM_INET<<8 | SAFNUM_MDT):
 		      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));
 		      if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
 		       break;
                     case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):  
                     case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):
                         advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));
                         if (advance == -1)
                             ND_PRINT((ndo, ""\n\t    (illegal prefix length)""));
                         else if (advance == -2)
                             goto trunc;
                         else
                             ND_PRINT((ndo, ""\n\t      %s"", buf));
                         break;
                     default:
                         ND_TCHECK2(*(tptr-3),tlen);
                         ND_PRINT((ndo, ""no AFI %u / SAFI %u decoder"", af, safi));
                         if (ndo->ndo_vflag <= 1)
                             print_unknown_data(ndo, tptr-3, ""\n\t    "", tlen);
                         advance = 0;
                         tptr = pptr + len;
                         break;
                     }
                     if (advance < 0)
                         break;
                     tptr += advance;
 		}
 		break;
         case BGPTYPE_EXTD_COMMUNITIES:
 		if (len % 8) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
                 while (tlen>0) {
                     uint16_t extd_comm;
 
                     ND_TCHECK2(tptr[0], 2);
                     extd_comm=EXTRACT_16BITS(tptr);
 
 		    ND_PRINT((ndo, ""\n\t    %s (0x%04x), Flags [%s]"",
 			   tok2str(bgp_extd_comm_subtype_values,
 				      ""unknown extd community typecode"",
 				      extd_comm),
 			   extd_comm,
 			   bittok2str(bgp_extd_comm_flag_values, ""none"", extd_comm)));
 
                     ND_TCHECK2(*(tptr+2), 6);
                     switch(extd_comm) {
                     case BGP_EXT_COM_RT_0:
                     case BGP_EXT_COM_RO_0:
                     case BGP_EXT_COM_L2VPN_RT_0:
                         ND_PRINT((ndo, "": %u:%u (= %s)"",
                                EXTRACT_16BITS(tptr+2),
                                EXTRACT_32BITS(tptr+4),
                                ipaddr_string(ndo, tptr+4)));
                         break;
                     case BGP_EXT_COM_RT_1:
                     case BGP_EXT_COM_RO_1:
                     case BGP_EXT_COM_L2VPN_RT_1:
                     case BGP_EXT_COM_VRF_RT_IMP:
                         ND_PRINT((ndo, "": %s:%u"",
                                ipaddr_string(ndo, tptr+2),
                                EXTRACT_16BITS(tptr+6)));
                         break;
                     case BGP_EXT_COM_RT_2:
                     case BGP_EXT_COM_RO_2:
 			ND_PRINT((ndo, "": %s:%u"",
 			    as_printf(ndo, astostr, sizeof(astostr),
 			    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));
 			break;
                     case BGP_EXT_COM_LINKBAND:
 		        bw.i = EXTRACT_32BITS(tptr+2);
                         ND_PRINT((ndo, "": bandwidth: %.3f Mbps"",
                                bw.f*8/1000000));
                         break;
                     case BGP_EXT_COM_VPN_ORIGIN:
                     case BGP_EXT_COM_VPN_ORIGIN2:
                     case BGP_EXT_COM_VPN_ORIGIN3:
                     case BGP_EXT_COM_VPN_ORIGIN4:
                     case BGP_EXT_COM_OSPF_RID:
                     case BGP_EXT_COM_OSPF_RID2:
                         ND_PRINT((ndo, ""%s"", ipaddr_string(ndo, tptr+2)));
                         break;
                     case BGP_EXT_COM_OSPF_RTYPE:
                     case BGP_EXT_COM_OSPF_RTYPE2:
                         ND_PRINT((ndo, "": area:%s, router-type:%s, metric-type:%s%s"",
                                ipaddr_string(ndo, tptr+2),
                                tok2str(bgp_extd_comm_ospf_rtype_values,
 					  ""unknown (0x%02x)"",
 					  *(tptr+6)),
                                (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? ""E2"" : """",
                                ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? ""E1"" : """"));
                         break;
                     case BGP_EXT_COM_L2INFO:
                         ND_PRINT((ndo, "": %s Control Flags [0x%02x]:MTU %u"",
                                tok2str(l2vpn_encaps_values,
 					  ""unknown encaps"",
 					  *(tptr+2)),
                                        *(tptr+3),
                                EXTRACT_16BITS(tptr+4)));
                         break;
                     case BGP_EXT_COM_SOURCE_AS:
                         ND_PRINT((ndo, "": AS %u"", EXTRACT_16BITS(tptr+2)));
                         break;
                     default:
                         ND_TCHECK2(*tptr,8);
                         print_unknown_data(ndo, tptr, ""\n\t      "", 8);
                         break;
                     }
                     tlen -=8;
                     tptr +=8;
                 }
                 break;
 
         case BGPTYPE_PMSI_TUNNEL:
         {
                 uint8_t tunnel_type, flags;
 
                 ND_TCHECK2(tptr[0], 5);
                 tunnel_type = *(tptr+1);
                 flags = *tptr;
                 tlen = len;
 
                 ND_PRINT((ndo, ""\n\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u"",
                        tok2str(bgp_pmsi_tunnel_values, ""Unknown"", tunnel_type),
                        tunnel_type,
                        bittok2str(bgp_pmsi_flag_values, ""none"", flags),
                        EXTRACT_24BITS(tptr+2)>>4));
 
                 tptr +=5;
                 tlen -= 5;
 
                 switch (tunnel_type) {
                 case BGP_PMSI_TUNNEL_PIM_SM:  
                 case BGP_PMSI_TUNNEL_PIM_BIDIR:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Sender %s, P-Group %s"",
                            ipaddr_string(ndo, tptr),
                            ipaddr_string(ndo, tptr+4)));
                     break;
 
                 case BGP_PMSI_TUNNEL_PIM_SSM:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Root-Node %s, P-Group %s"",
                            ipaddr_string(ndo, tptr),
                            ipaddr_string(ndo, tptr+4)));
                     break;
                 case BGP_PMSI_TUNNEL_INGRESS:
                     ND_TCHECK2(tptr[0], 4);
                     ND_PRINT((ndo, ""\n\t      Tunnel-Endpoint %s"",
                            ipaddr_string(ndo, tptr)));
                     break;
                 case BGP_PMSI_TUNNEL_LDP_P2MP:  
                 case BGP_PMSI_TUNNEL_LDP_MP2MP:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Root-Node %s, LSP-ID 0x%08x"",
                            ipaddr_string(ndo, tptr),
                            EXTRACT_32BITS(tptr+4)));
                     break;
                 case BGP_PMSI_TUNNEL_RSVP_P2MP:
                     ND_TCHECK2(tptr[0], 8);
                     ND_PRINT((ndo, ""\n\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x"",
                            ipaddr_string(ndo, tptr),
                            EXTRACT_32BITS(tptr+4)));
                     break;
                 default:
                     if (ndo->ndo_vflag <= 1) {
                         print_unknown_data(ndo, tptr, ""\n\t      "", tlen);
                     }
                 }
                 break;
         }
 	case BGPTYPE_AIGP:
 	{
 		uint8_t type;
 		uint16_t length;
 
 		tlen = len;
 
 		while (tlen >= 3) {
 
 		    ND_TCHECK2(tptr[0], 3);
 
 		    type = *tptr;
 		    length = EXTRACT_16BITS(tptr+1);
 		    tptr += 3;
 		    tlen -= 3;
 
 		    ND_PRINT((ndo, ""\n\t    %s TLV (%u), length %u"",
 			      tok2str(bgp_aigp_values, ""Unknown"", type),
 			      type, length));
 
 		    if (length < 3)
 			goto trunc;
 		    length -= 3;
 
 		     
 		    ND_TCHECK2(tptr[3], length);
 
 		    switch (type) {
 
 		    case BGP_AIGP_TLV:
 		        if (length < 8)
 		            goto trunc;
 			ND_PRINT((ndo, "", metric %"" PRIu64,
 				  EXTRACT_64BITS(tptr)));
 			break;
 
 		    default:
 			if (ndo->ndo_vflag <= 1) {
 			    print_unknown_data(ndo, tptr,""\n\t      "", length);
 			}
 		    }
 
 		    tptr += length;
 		    tlen -= length;
 		}
 		break;
 	}
         case BGPTYPE_ATTR_SET:
                 ND_TCHECK2(tptr[0], 4);
                 if (len < 4)
                 	goto trunc;
 		ND_PRINT((ndo, ""\n\t    Origin AS: %s"",
 		    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));
 		tptr+=4;
                 len -=4;
 
                 while (len) {
                     u_int aflags, alenlen, alen;
 
                     ND_TCHECK2(tptr[0], 2);
                     if (len < 2)
                         goto trunc;
                     aflags = *tptr;
                     atype = *(tptr + 1);
                     tptr += 2;
                     len -= 2;
                     alenlen = bgp_attr_lenlen(aflags, tptr);
                     ND_TCHECK2(tptr[0], alenlen);
                     if (len < alenlen)
                         goto trunc;
                     alen = bgp_attr_len(aflags, tptr);
                     tptr += alenlen;
                     len -= alenlen;
 
                     ND_PRINT((ndo, ""\n\t      %s (%u), length: %u"",
                            tok2str(bgp_attr_values,
                                       ""Unknown Attribute"", atype),
                            atype,
                            alen));
 
                     if (aflags) {
                         ND_PRINT((ndo, "", Flags [%s%s%s%s"",
                                aflags & 0x80 ? ""O"" : """",
                                aflags & 0x40 ? ""T"" : """",
                                aflags & 0x20 ? ""P"" : """",
                                aflags & 0x10 ? ""E"" : """"));
                         if (aflags & 0xf)
                              ND_PRINT((ndo, ""+%x"", aflags & 0xf));
                          ND_PRINT((ndo, ""]: ""));
                      }
                      
                    if (!bgp_attr_print(ndo, atype, tptr, alen))
                     if (attr_set_level == 10)
                         ND_PRINT((ndo, ""(too many nested levels, not recursing)""));
                     else if (!bgp_attr_print(ndo, atype, tptr, alen, attr_set_level + 1))
                          return 0;
                      tptr += alen;
                      len -= alen;
 		}
                 break;
 
 	case BGPTYPE_LARGE_COMMUNITY:
 		if (len == 0 || len % 12) {
 			ND_PRINT((ndo, ""invalid len""));
 			break;
 		}
 		ND_PRINT((ndo, ""\n\t    ""));
 		while (len > 0) {
 			ND_TCHECK2(*tptr, 12);
 			ND_PRINT((ndo, ""%u:%u:%u%s"",
 				 EXTRACT_32BITS(tptr),
 				 EXTRACT_32BITS(tptr + 4),
 				 EXTRACT_32BITS(tptr + 8),
 				 (len > 12) ? "", "" : """"));
                         tptr += 12;
                         len -= 12;
 		}
 		break;
 	default:
 	    ND_TCHECK2(*pptr,len);
             ND_PRINT((ndo, ""\n\t    no Attribute %u decoder"", atype));  
             if (ndo->ndo_vflag <= 1)
                 print_unknown_data(ndo, pptr, ""\n\t    "", len);
             break;
 	}
         if (ndo->ndo_vflag > 1 && len) {  
             ND_TCHECK2(*pptr,len);
             print_unknown_data(ndo, pptr, ""\n\t    "", len);
         }
         return 1;
 
 trunc:
         return 0;
 }","[3, 914, 915, 916, 2, 913]",The BGP parser in tcpdump before 4.9.3 allows stack consumption in print-bgp.c:bgp_attr_print() because of unlimited recursion.
201579," static Image *ReadTIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   const char
     *option;
 
   float
     *chromaticity,
     x_position,
     y_position,
     x_resolution,
     y_resolution;
 
   Image
     *image;
 
   int
     tiff_status;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register ssize_t
     i;
 
   size_t
     pad;
 
   ssize_t
     y;
 
   TIFF
     *tiff;
 
   TIFFMethodType
     method;
 
   uint16
     compress_tag,
     bits_per_sample,
     endian,
     extra_samples,
     interlace,
     max_sample_value,
     min_sample_value,
     orientation,
     pages,
     photometric,
     *sample_info,
     sample_format,
     samples_per_pixel,
     units,
     value;
 
   uint32
     height,
     rows_per_strip,
     width;
 
   unsigned char
     *tiff_pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   (void) SetMagickThreadValue(tiff_exception,exception);
   tiff=TIFFClientOpen(image->filename,""rb"",(thandle_t) image,TIFFReadBlob,
     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,
     TIFFUnmapBlob);
   if (tiff == (TIFF *) NULL)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   if (image_info->number_scenes != 0)
     {
        
       if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))
         {
           for (i=0; i < (ssize_t) image_info->scene; i++)
           {
             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
             if (status == MagickFalse)
               {
                 TIFFClose(tiff);
                 image=DestroyImageList(image);
                 return((Image *) NULL);
               }
             AcquireNextImage(image_info,image);
             if (GetNextImageInList(image) == (Image *) NULL)
               {
                 TIFFClose(tiff);
                 image=DestroyImageList(image);
                 return((Image *) NULL);
               }
             image=SyncNextImageInList(image);
           }
         }
     }
   do
   {
 DisableMSCWarning(4127)
     if (0 && (image_info->verbose != MagickFalse))
       TIFFPrintDirectory(tiff,stdout,MagickFalse);
 RestoreMSCWarning
     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||
         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))
       {
         TIFFClose(tiff);
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       }
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       (void) SetImageProperty(image,""quantum:format"",""floating-point"");
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""min-is-black"");
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""min-is-white"");
         break;
       }
       case PHOTOMETRIC_PALETTE:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""palette"");
         break;
       }
       case PHOTOMETRIC_RGB:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""RGB"");
         break;
       }
       case PHOTOMETRIC_CIELAB:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""CIELAB"");
         break;
       }
       case PHOTOMETRIC_LOGL:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""CIE Log2(L)"");
         break;
       }
       case PHOTOMETRIC_LOGLUV:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""LOGLUV"");
         break;
       }
 #if defined(PHOTOMETRIC_MASK)
       case PHOTOMETRIC_MASK:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""MASK"");
         break;
       }
 #endif
       case PHOTOMETRIC_SEPARATED:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""separated"");
         break;
       }
       case PHOTOMETRIC_YCBCR:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""YCBCR"");
         break;
       }
       default:
       {
         (void) SetImageProperty(image,""tiff:photometric"",""unknown"");
         break;
       }
     }
     if (image->debug != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %ux%u"",
           (unsigned int) width,(unsigned int) height);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Interlace: %u"",
           interlace);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Bits per sample: %u"",bits_per_sample);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Min sample value: %u"",min_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""Max sample value: %u"",max_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Photometric ""
           ""interpretation: %s"",GetImageProperty(image,""tiff:photometric""));
       }
     image->columns=(size_t) width;
     image->rows=(size_t) height;
     image->depth=(size_t) bits_per_sample;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),""Image depth: %.20g"",
         (double) image->depth);
     image->endian=MSBEndian;
     if (endian == FILLORDER_LSB2MSB)
       image->endian=LSBEndian;
 #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
     if (TIFFIsBigEndian(tiff) == 0)
       {
         (void) SetImageProperty(image,""tiff:endian"",""lsb"");
         image->endian=LSBEndian;
       }
     else
       {
         (void) SetImageProperty(image,""tiff:endian"",""msb"");
         image->endian=MSBEndian;
       }
 #endif
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       SetImageColorspace(image,GRAYColorspace);
     if (photometric == PHOTOMETRIC_SEPARATED)
       SetImageColorspace(image,CMYKColorspace);
     if (photometric == PHOTOMETRIC_CIELAB)
       SetImageColorspace(image,LabColorspace);
     TIFFGetProfiles(tiff,image,image_info->ping);
     TIFFGetProperties(tiff,image);
     option=GetImageOption(image_info,""tiff:exif-properties"");
     if ((option == (const char *) NULL) ||
         (IsMagickTrue(option) != MagickFalse))
       TIFFGetEXIFProperties(tiff,image);
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))
       {
         image->x_resolution=x_resolution;
         image->y_resolution=y_resolution;
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)
       {
         if (units == RESUNIT_INCH)
           image->units=PixelsPerInchResolution;
         if (units == RESUNIT_CENTIMETER)
           image->units=PixelsPerCentimeterResolution;
       }
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))
       {
         image->page.x=(ssize_t) ceil(x_position*image->x_resolution-0.5);
         image->page.y=(ssize_t) ceil(y_position*image->y_resolution-0.5);
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)
       image->orientation=(OrientationType) orientation;
     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.white_point.x=chromaticity[0];
             image->chromaticity.white_point.y=chromaticity[1];
           }
       }
     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.red_primary.x=chromaticity[0];
             image->chromaticity.red_primary.y=chromaticity[1];
             image->chromaticity.green_primary.x=chromaticity[2];
             image->chromaticity.green_primary.y=chromaticity[3];
             image->chromaticity.blue_primary.x=chromaticity[4];
             image->chromaticity.blue_primary.y=chromaticity[5];
           }
       }
 #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
     if ((compress_tag != COMPRESSION_NONE) &&
         (TIFFIsCODECConfigured(compress_tag) == 0))
       {
         TIFFClose(tiff);
         ThrowReaderException(CoderError,""CompressNotSupported"");
       }
 #endif
     switch (compress_tag)
     {
       case COMPRESSION_NONE: image->compression=NoCompression; break;
       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;
       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;
       case COMPRESSION_JPEG:
       {
          image->compression=JPEGCompression;
 #if defined(JPEG_SUPPORT)
          {
            char
              sampling_factor[MaxTextExtent];
 
            int
              tiff_status;
 
            uint16
              horizontal,
              vertical;
 
            tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,
              &vertical);
            if (tiff_status == 1)
              {
                (void) FormatLocaleString(sampling_factor,MaxTextExtent,""%dx%d"",
                  horizontal,vertical);
                (void) SetImageProperty(image,""jpeg:sampling-factor"",
                  sampling_factor);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""Sampling Factors: %s"",sampling_factor);
              }
          }
 #endif
         break;
       }
       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;
 #if defined(COMPRESSION_LZMA)
       case COMPRESSION_LZMA: image->compression=LZMACompression; break;
 #endif
       case COMPRESSION_LZW: image->compression=LZWCompression; break;
       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;
       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
       default: image->compression=RLECompression; break;
     }
     quantum_info=(QuantumInfo *) NULL;
     if ((photometric == PHOTOMETRIC_PALETTE) &&
         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
       {
         size_t
           colors;
 
         colors=(size_t) GetQuantumRange(bits_per_sample)+1;
         if (AcquireImageColormap(image,colors) == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)
       image->scene=value;
     if (image->storage_class == PseudoClass)
       {
         int
           tiff_status;
 
         size_t
           range;
 
         uint16
           *blue_colormap,
           *green_colormap,
           *red_colormap;
 
          
         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,
           &green_colormap,&blue_colormap);
         if (tiff_status == 1)
           {
             if ((red_colormap != (uint16 *) NULL) &&
                 (green_colormap != (uint16 *) NULL) &&
                 (blue_colormap != (uint16 *) NULL))
               {
                 range=255;   
                 for (i=0; i < (ssize_t) image->colors; i++)
                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||
                       (blue_colormap[i] >= 256))
                     {
                       range=65535;
                       break;
                     }
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   image->colormap[i].red=ClampToQuantum(((double)
                     QuantumRange*red_colormap[i])/range);
                   image->colormap[i].green=ClampToQuantum(((double)
                     QuantumRange*green_colormap[i])/range);
                   image->colormap[i].blue=ClampToQuantum(((double)
                     QuantumRange*blue_colormap[i])/range);
                 }
               }
           }
       }
     if (image_info->ping != MagickFalse)
       {
         if (image_info->number_scenes != 0)
           if (image->scene >= (image_info->scene+image_info->number_scenes-1))
             break;
         goto next_tiff_frame;
       }
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
      
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       {
         TIFFClose(tiff);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     if (sample_format == SAMPLEFORMAT_UINT)
       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_INT)
       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
     if (status == MagickFalse)
       {
         TIFFClose(tiff);
         quantum_info=DestroyQuantumInfo(quantum_info);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     status=MagickTrue;
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         quantum_info->min_is_white=MagickFalse;
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         quantum_info->min_is_white=MagickTrue;
         break;
       }
       default:
         break;
     }
     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
       &sample_info);
     if (tiff_status == 1)
       {
         (void) SetImageProperty(image,""tiff:alpha"",""unspecified"");
         if (extra_samples == 0)
           {
             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
               image->matte=MagickTrue;
           }
         else
           for (i=0; i < extra_samples; i++)
           {
             image->matte=MagickTrue;
             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
               {
                 SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                 (void) SetImageProperty(image,""tiff:alpha"",""associated"");
               }
             else
               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
                (void) SetImageProperty(image,""tiff:alpha"",""unassociated"");
           }
       }
     method=ReadGenericMethod;
     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
       {
         char
           value[MaxTextExtent];
 
         method=ReadStripMethod;
         (void) FormatLocaleString(value,MaxTextExtent,""%u"",(unsigned int)
           rows_per_strip);
         (void) SetImageProperty(image,""tiff:rows-per-strip"",value);
       }
     if ((samples_per_pixel >= 3) && (interlace == PLANARCONFIG_CONTIG))
       method=ReadRGBAMethod;
     if ((samples_per_pixel >= 4) && (interlace == PLANARCONFIG_SEPARATE))
       method=ReadCMYKAMethod;
     if ((photometric != PHOTOMETRIC_RGB) &&
         (photometric != PHOTOMETRIC_CIELAB) &&
         (photometric != PHOTOMETRIC_SEPARATED))
       method=ReadGenericMethod;
     if (image->storage_class == PseudoClass)
       method=ReadSingleSampleMethod;
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       method=ReadSingleSampleMethod;
     if ((photometric != PHOTOMETRIC_SEPARATED) &&
         (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))
       method=ReadGenericMethod;
     if (image->compression == JPEGCompression)
       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
         samples_per_pixel);
     if (compress_tag == COMPRESSION_JBIG)
       method=ReadStripMethod;
     if (TIFFIsTiled(tiff) != MagickFalse)
        method=ReadTileMethod;
      quantum_info->endian=LSBEndian;
      quantum_type=RGBQuantum;
    tiff_pixels=(unsigned char *) AcquireMagickMemory(TIFFScanlineSize(tiff)+
      sizeof(uint32));
     tiff_pixels=(unsigned char *) AcquireMagickMemory(MagickMax(
       TIFFScanlineSize(tiff),(size_t) (image->columns*samples_per_pixel*
       pow(2.0,ceil(log(bits_per_sample)/log(2.0))))));
      if (tiff_pixels == (unsigned char *) NULL)
        {
          TIFFClose(tiff);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     switch (method)
     {
       case ReadSingleSampleMethod:
       {
          
         quantum_type=IndexQuantum;
         pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);
         if (image->matte != MagickFalse)
           {
             if (image->storage_class != PseudoClass)
               {
                 quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
                   GrayAlphaQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);
               }
             else
               {
                 quantum_type=IndexAlphaQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);
               }
           }
         else
           if (image->storage_class != PseudoClass)
             {
               quantum_type=GrayQuantum;
               pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);
             }
         status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(
           bits_per_sample)/log(2))));
         if (status == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register PixelPacket
             *magick_restrict q;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,tiff_pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadRGBAMethod:
       {
          
         pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
         quantum_type=RGBQuantum;
         if (image->matte != MagickFalse)
           {
             quantum_type=RGBAQuantum;
             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
           }
         if (image->colorspace == CMYKColorspace)
           {
             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
             quantum_type=CMYKQuantum;
             if (image->matte != MagickFalse)
               {
                 quantum_type=CMYKAQuantum;
                 pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
               }
           }
         status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
         if (status == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register PixelPacket
             *magick_restrict q;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,tiff_pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadCMYKAMethod:
       {
          
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register PixelPacket
               *magick_restrict q;
 
             int
               status;
 
             status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)
               tiff_pixels);
             if (status == -1)
               break;
             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (PixelPacket *) NULL)
               break;
             if (image->colorspace != CMYKColorspace)
               switch (i)
               {
                 case 0: quantum_type=RedQuantum; break;
                 case 1: quantum_type=GreenQuantum; break;
                 case 2: quantum_type=BlueQuantum; break;
                 case 3: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             else
               switch (i)
               {
                 case 0: quantum_type=CyanQuantum; break;
                 case 1: quantum_type=MagentaQuantum; break;
                 case 2: quantum_type=YellowQuantum; break;
                 case 3: quantum_type=BlackQuantum; break;
                 case 4: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
               quantum_type,tiff_pixels,exception);
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
           }
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadYCCKMethod:
       {
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           int
             status;
 
           register IndexPacket
             *indexes;
 
           register PixelPacket
             *magick_restrict q;
 
           register ssize_t
             x;
 
           unsigned char
             *p;
 
           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) tiff_pixels);
           if (status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           indexes=GetAuthenticIndexQueue(image);
           p=tiff_pixels;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.402*(double) *(p+2))-179.456)));
             SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-
               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
               135.45984)));
             SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.772*(double) *(p+1))-226.816)));
             SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));
             q++;
             p+=4;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadStripMethod:
       {
         register uint32
           *p;
 
          
         i=0;
         p=(uint32 *) NULL;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register ssize_t
             x;
 
           register PixelPacket
             *magick_restrict q;
 
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           if (i == 0)
             {
               if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) tiff_pixels) == 0)
                 break;
               i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)
                 image->rows-y);
             }
           i--;
           p=((uint32 *) tiff_pixels)+image->columns*i;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(q,ScaleCharToQuantum((unsigned char)
               (TIFFGetR(*p))));
             SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
               (TIFFGetG(*p))));
             SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
               (TIFFGetB(*p))));
             if (image->matte != MagickFalse)
               SetPixelOpacity(q,ScaleCharToQuantum((unsigned char)
                 (TIFFGetA(*p))));
             p++;
             q++;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadTileMethod:
       {
         register uint32
           *p;
 
         uint32
           *tile_pixels,
           columns,
           rows;
 
          
         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
           {
             TIFFClose(tiff);
             ThrowReaderException(CoderError,""ImageIsNotTiled"");
           }
         (void) SetImageStorageClass(image,DirectClass);
         number_pixels=(MagickSizeType) columns*rows;
         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
            sizeof(*tile_pixels));
         if (tile_pixels == (uint32 *) NULL)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         for (y=0; y < (ssize_t) image->rows; y+=rows)
         {
           PixelPacket
             *tile;
 
           register ssize_t
             x;
 
           register PixelPacket
             *magick_restrict q;
 
           size_t
             columns_remaining,
             rows_remaining;
 
           rows_remaining=image->rows-y;
           if ((ssize_t) (y+rows) < (ssize_t) image->rows)
             rows_remaining=rows;
           tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,
             exception);
           if (tile == (PixelPacket *) NULL)
             break;
           for (x=0; x < (ssize_t) image->columns; x+=columns)
           {
             size_t
               column,
               row;
 
             if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)
               break;
             columns_remaining=image->columns-x;
             if ((ssize_t) (x+columns) < (ssize_t) image->columns)
               columns_remaining=columns;
             p=tile_pixels+(rows-rows_remaining)*columns;
             q=tile+(image->columns*(rows_remaining-1)+x);
             for (row=rows_remaining; row > 0; row--)
             {
               if (image->matte != MagickFalse)
                 for (column=columns_remaining; column > 0; column--)
                 {
                   SetPixelRed(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetR(*p)));
                   SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetG(*p)));
                   SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetB(*p)));
                   SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetA(*p)));
                   q++;
                   p++;
                 }
               else
                 for (column=columns_remaining; column > 0; column--)
                 {
                   SetPixelRed(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetR(*p)));
                   SetPixelGreen(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetG(*p)));
                   SetPixelBlue(q,ScaleCharToQuantum((unsigned char)
                     TIFFGetB(*p)));
                   q++;
                   p++;
                 }
               p+=columns-columns_remaining;
               q-=(image->columns+columns_remaining);
             }
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
         break;
       }
       case ReadGenericMethod:
       default:
       {
         MemoryInfo
           *pixel_info;
 
         register uint32
           *p;
 
         uint32
           *pixels;
 
          
         number_pixels=(MagickSizeType) image->columns*image->rows;
         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixel_info=AcquireVirtualMemory(image->columns,image->rows*
           sizeof(*pixels));
         if (pixel_info == (MemoryInfo *) NULL)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);
         (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
           image->rows,(uint32 *) pixels,0);
          
         p=pixels+number_pixels-1;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register ssize_t
             x;
 
           register PixelPacket
             *magick_restrict q;
 
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (PixelPacket *) NULL)
             break;
           q+=image->columns-1;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));
             SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));
             SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));
             if (image->matte != MagickFalse)
               SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));
             p--;
             q--;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         pixel_info=RelinquishVirtualMemory(pixel_info);
         break;
       }
     }
     tiff_pixels=(unsigned char *) RelinquishMagickMemory(tiff_pixels);
     SetQuantumImageType(image,quantum_type);
   next_tiff_frame:
     if (quantum_info != (QuantumInfo *) NULL)
       quantum_info=DestroyQuantumInfo(quantum_info);
     if (photometric == PHOTOMETRIC_CIELAB)
       DecodeLabImage(image,exception);
     if ((photometric == PHOTOMETRIC_LOGL) ||
         (photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       {
         image->type=GrayscaleType;
         if (bits_per_sample == 1)
           image->type=BilevelType;
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
     if (status != MagickFalse)
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,image->scene-1,
           image->scene);
         if (status == MagickFalse)
           break;
       }
   } while (status != MagickFalse);
   TIFFClose(tiff);
   TIFFReadPhotoshopLayers(image,image_info,exception);
   if (image_info->number_scenes != 0)
   {
     if (image_info->scene >= GetImageListLength(image))
     {
        
       image = DestroyImageList(image);
       return((Image *)NULL);
     }
   }
   return(GetFirstImageInList(image));
 }","[514, 515, 516, 512, 513]",Heap-based buffer overflow in the PushQuantumPixel function in ImageMagick before 6.9.7-3 and 7.x before 7.0.4-3 allows remote attackers to cause a denial of service (application crash) via a crafted TIFF file.
208233," OMX_ERRORTYPE SoftMP3::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamAudioPcm:
  {
 
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
 
             pcmParams->eNumData = OMX_NumericalDataSigned;
             pcmParams->eEndian = OMX_EndianBig;
             pcmParams->bInterleaved = OMX_TRUE;
             pcmParams->nBitPerSample = 16;
             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
             pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
 
             pcmParams->nChannels = mNumChannels;
             pcmParams->nSamplingRate = mSamplingRate;
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioMp3:
  {
 
              OMX_AUDIO_PARAM_MP3TYPE *mp3Params =
                  (OMX_AUDIO_PARAM_MP3TYPE *)params;
  
             if (!isValidOMXParam(mp3Params)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (mp3Params->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
 
             mp3Params->nChannels = mNumChannels;
             mp3Params->nBitRate = 0  ;
             mp3Params->nSampleRate = mSamplingRate;
 
  return OMX_ErrorNone;
  }
 
  default:
  return SimpleSoftOMXComponent::internalGetParameter(index, params);
  }
 }","[10, 11, 12, 13, 38, 39, 40, 41]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
7480,"static bool anal_fcn_data (RCore *core, const char *input) {
RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);
ut32 fcn_size = r_anal_function_size_from_entry (fcn);
if (fcn) {
int i;
bool gap = false;
ut64 gap_addr = UT64_MAX;
char *bitmap = calloc (1, fcn_size);
if (bitmap) {
RAnalBlock *b;
RListIter *iter;
r_list_foreach (fcn->bbs, iter, b) {
int f = b->addr - fcn->addr;
int t = R_MIN (f + b->size, fcn_size);
if (f >= 0) {
while (f < t) {
bitmap[f++] = 1;
}
}
}
}
for (i = 0; i < fcn_size; i++) {
ut64 here = fcn->addr + i;
if (bitmap && bitmap[i]) {
if (gap) {
r_cons_printf (""Cd %d @ 0x%08""PFMT64x""\n"", here - gap_addr, gap_addr);
gap = false;
}
gap_addr = UT64_MAX;
} else {
if (!gap) {
gap = true;
gap_addr = here;
}
}
}
if (gap) {
r_cons_printf (""Cd %d @ 0x%08""PFMT64x""\n"", fcn->addr + fcn_size - gap_addr, gap_addr);
}
free (bitmap);
return true;
}
return false;
}","[2, 3, 8]","A segmentation fault was discovered in radare2 with adf command. In libr/core/cmd_anal.c, when command ""adf"" has no or wrong argument, anal_fcn_data (core, input + 1) --> RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1); returns null pointer for fcn causing segmentation fault later in ensure_fcn_range (fcn)."
200725," 				__releases(kernel_lock)
 				__acquires(kernel_lock)
 {
 	struct buffer_head *bh;
 	struct ext4_super_block *es = NULL;
 	struct ext4_sb_info *sbi;
 	ext4_fsblk_t block;
 	ext4_fsblk_t sb_block = get_sb_block(&data);
 	ext4_fsblk_t logical_sb_block;
 	unsigned long offset = 0;
 	unsigned long journal_devnum = 0;
 	unsigned long def_mount_opts;
 	struct inode *root;
 	char *cp;
 	const char *descr;
 	int ret = -EINVAL;
 	int blocksize;
 	unsigned int db_count;
 	unsigned int i;
 	int needs_recovery, has_huge_files;
 	__u64 blocks_count;
 	int err;
 	unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;
 
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi)
 		return -ENOMEM;
 
 	sbi->s_blockgroup_lock =
 		kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);
 	if (!sbi->s_blockgroup_lock) {
 		kfree(sbi);
 		return -ENOMEM;
 	}
 	sb->s_fs_info = sbi;
 	sbi->s_mount_opt = 0;
 	sbi->s_resuid = EXT4_DEF_RESUID;
 	sbi->s_resgid = EXT4_DEF_RESGID;
 	sbi->s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS;
 	sbi->s_sb_block = sb_block;
 	sbi->s_sectors_written_start = part_stat_read(sb->s_bdev->bd_part,
 						      sectors[1]);
 
 	unlock_kernel();
 
 	 
 	for (cp = sb->s_id; (cp = strchr(cp, '/'));)
 		*cp = '!';
 
 	blocksize = sb_min_blocksize(sb, EXT4_MIN_BLOCK_SIZE);
 	if (!blocksize) {
 		ext4_msg(sb, KERN_ERR, ""unable to set blocksize"");
 		goto out_fail;
 	}
 
 	 
 	if (blocksize != EXT4_MIN_BLOCK_SIZE) {
 		logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;
 		offset = do_div(logical_sb_block, blocksize);
 	} else {
 		logical_sb_block = sb_block;
 	}
 
 	if (!(bh = sb_bread(sb, logical_sb_block))) {
 		ext4_msg(sb, KERN_ERR, ""unable to read superblock"");
 		goto out_fail;
 	}
 	 
 	es = (struct ext4_super_block *) (((char *)bh->b_data) + offset);
 	sbi->s_es = es;
 	sb->s_magic = le16_to_cpu(es->s_magic);
 	if (sb->s_magic != EXT4_SUPER_MAGIC)
 		goto cantfind_ext4;
 	sbi->s_kbytes_written = le64_to_cpu(es->s_kbytes_written);
 
 	 
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	if (def_mount_opts & EXT4_DEFM_DEBUG)
 		set_opt(sbi->s_mount_opt, DEBUG);
 	if (def_mount_opts & EXT4_DEFM_BSDGROUPS) {
 		ext4_msg(sb, KERN_WARNING, deprecated_msg, ""bsdgroups"",
 			""2.6.38"");
 		set_opt(sbi->s_mount_opt, GRPID);
 	}
 	if (def_mount_opts & EXT4_DEFM_UID16)
 		set_opt(sbi->s_mount_opt, NO_UID32);
 #ifdef CONFIG_EXT4_FS_XATTR
 	if (def_mount_opts & EXT4_DEFM_XATTR_USER)
 		set_opt(sbi->s_mount_opt, XATTR_USER);
 #endif
 #ifdef CONFIG_EXT4_FS_POSIX_ACL
 	if (def_mount_opts & EXT4_DEFM_ACL)
 		set_opt(sbi->s_mount_opt, POSIX_ACL);
 #endif
 	if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_DATA)
 		set_opt(sbi->s_mount_opt, JOURNAL_DATA);
 	else if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_ORDERED)
 		set_opt(sbi->s_mount_opt, ORDERED_DATA);
 	else if ((def_mount_opts & EXT4_DEFM_JMODE) == EXT4_DEFM_JMODE_WBACK)
 		set_opt(sbi->s_mount_opt, WRITEBACK_DATA);
 
 	if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_PANIC)
 		set_opt(sbi->s_mount_opt, ERRORS_PANIC);
 	else if (le16_to_cpu(sbi->s_es->s_errors) == EXT4_ERRORS_CONTINUE)
 		set_opt(sbi->s_mount_opt, ERRORS_CONT);
 	else
 		set_opt(sbi->s_mount_opt, ERRORS_RO);
 
 	sbi->s_resuid = le16_to_cpu(es->s_def_resuid);
 	sbi->s_resgid = le16_to_cpu(es->s_def_resgid);
 	sbi->s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;
 	sbi->s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;
 	sbi->s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;
 
 	set_opt(sbi->s_mount_opt, BARRIER);
 
 	 
 	set_opt(sbi->s_mount_opt, DELALLOC);
 
 	if (!parse_options((char *) data, sb, &journal_devnum,
 			   &journal_ioprio, NULL, 0))
 		goto failed_mount;
 
 	sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |
 		(test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);
 
 	if (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV &&
 	    (EXT4_HAS_COMPAT_FEATURE(sb, ~0U) ||
 	     EXT4_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||
 	     EXT4_HAS_INCOMPAT_FEATURE(sb, ~0U)))
 		ext4_msg(sb, KERN_WARNING,
 		       ""feature flags set on rev 0 fs, ""
 		       ""running e2fsck is recommended"");
 
 	 
 	if (!ext4_feature_set_ok(sb, (sb->s_flags & MS_RDONLY)))
 		goto failed_mount;
 
 	blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);
 
 	if (blocksize < EXT4_MIN_BLOCK_SIZE ||
 	    blocksize > EXT4_MAX_BLOCK_SIZE) {
 		ext4_msg(sb, KERN_ERR,
 		       ""Unsupported filesystem blocksize %d"", blocksize);
 		goto failed_mount;
 	}
 
 	if (sb->s_blocksize != blocksize) {
 		 
 		if (!sb_set_blocksize(sb, blocksize)) {
 			ext4_msg(sb, KERN_ERR, ""bad block size %d"",
 					blocksize);
 			goto failed_mount;
 		}
 
 		brelse(bh);
 		logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE;
 		offset = do_div(logical_sb_block, blocksize);
 		bh = sb_bread(sb, logical_sb_block);
 		if (!bh) {
 			ext4_msg(sb, KERN_ERR,
 			       ""Can't read superblock on 2nd try"");
 			goto failed_mount;
 		}
 		es = (struct ext4_super_block *)(((char *)bh->b_data) + offset);
 		sbi->s_es = es;
 		if (es->s_magic != cpu_to_le16(EXT4_SUPER_MAGIC)) {
 			ext4_msg(sb, KERN_ERR,
 			       ""Magic mismatch, very weird!"");
 			goto failed_mount;
 		}
 	}
 
 	has_huge_files = EXT4_HAS_RO_COMPAT_FEATURE(sb,
 				EXT4_FEATURE_RO_COMPAT_HUGE_FILE);
 	sbi->s_bitmap_maxbytes = ext4_max_bitmap_size(sb->s_blocksize_bits,
 						      has_huge_files);
 	sb->s_maxbytes = ext4_max_size(sb->s_blocksize_bits, has_huge_files);
 
 	if (le32_to_cpu(es->s_rev_level) == EXT4_GOOD_OLD_REV) {
 		sbi->s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;
 		sbi->s_first_ino = EXT4_GOOD_OLD_FIRST_INO;
 	} else {
 		sbi->s_inode_size = le16_to_cpu(es->s_inode_size);
 		sbi->s_first_ino = le32_to_cpu(es->s_first_ino);
 		if ((sbi->s_inode_size < EXT4_GOOD_OLD_INODE_SIZE) ||
 		    (!is_power_of_2(sbi->s_inode_size)) ||
 		    (sbi->s_inode_size > blocksize)) {
 			ext4_msg(sb, KERN_ERR,
 			       ""unsupported inode size: %d"",
 			       sbi->s_inode_size);
 			goto failed_mount;
 		}
 		if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE)
 			sb->s_time_gran = 1 << (EXT4_EPOCH_BITS - 2);
 	}
 
 	sbi->s_desc_size = le16_to_cpu(es->s_desc_size);
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_64BIT)) {
 		if (sbi->s_desc_size < EXT4_MIN_DESC_SIZE_64BIT ||
 		    sbi->s_desc_size > EXT4_MAX_DESC_SIZE ||
 		    !is_power_of_2(sbi->s_desc_size)) {
 			ext4_msg(sb, KERN_ERR,
 			       ""unsupported descriptor size %lu"",
 			       sbi->s_desc_size);
 			goto failed_mount;
 		}
 	} else
 		sbi->s_desc_size = EXT4_MIN_DESC_SIZE;
 
 	sbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);
 	sbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);
 	if (EXT4_INODE_SIZE(sb) == 0 || EXT4_INODES_PER_GROUP(sb) == 0)
 		goto cantfind_ext4;
 
 	sbi->s_inodes_per_block = blocksize / EXT4_INODE_SIZE(sb);
 	if (sbi->s_inodes_per_block == 0)
 		goto cantfind_ext4;
 	sbi->s_itb_per_group = sbi->s_inodes_per_group /
 					sbi->s_inodes_per_block;
 	sbi->s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);
 	sbi->s_sbh = bh;
 	sbi->s_mount_state = le16_to_cpu(es->s_state);
 	sbi->s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));
 	sbi->s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));
 
 	for (i = 0; i < 4; i++)
 		sbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);
 	sbi->s_def_hash_version = es->s_def_hash_version;
 	i = le32_to_cpu(es->s_flags);
 	if (i & EXT2_FLAGS_UNSIGNED_HASH)
 		sbi->s_hash_unsigned = 3;
 	else if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {
 #ifdef __CHAR_UNSIGNED__
 		es->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);
 		sbi->s_hash_unsigned = 3;
 #else
 		es->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);
 #endif
 		sb->s_dirt = 1;
 	}
 
 	if (sbi->s_blocks_per_group > blocksize * 8) {
 		ext4_msg(sb, KERN_ERR,
 		       ""#blocks per group too big: %lu"",
 		       sbi->s_blocks_per_group);
 		goto failed_mount;
 	}
 	if (sbi->s_inodes_per_group > blocksize * 8) {
 		ext4_msg(sb, KERN_ERR,
 		       ""#inodes per group too big: %lu"",
 		       sbi->s_inodes_per_group);
 		goto failed_mount;
 	}
 
 	 
 	if ((ext4_blocks_count(es) >
 	     (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) ||
 	    (ext4_blocks_count(es) >
 	     (pgoff_t)(~0ULL) >> (PAGE_CACHE_SHIFT - sb->s_blocksize_bits))) {
 		ext4_msg(sb, KERN_ERR, ""filesystem""
 			 "" too large to mount safely on this system"");
 		if (sizeof(sector_t) < 8)
 			ext4_msg(sb, KERN_WARNING, ""CONFIG_LBDAF not enabled"");
 		ret = -EFBIG;
 		goto failed_mount;
 	}
 
 	if (EXT4_BLOCKS_PER_GROUP(sb) == 0)
 		goto cantfind_ext4;
 
 	 
 	blocks_count = sb->s_bdev->bd_inode->i_size >> sb->s_blocksize_bits;
 	if (blocks_count && ext4_blocks_count(es) > blocks_count) {
 		ext4_msg(sb, KERN_WARNING, ""bad geometry: block count %llu ""
 		       ""exceeds size of device (%llu blocks)"",
 		       ext4_blocks_count(es), blocks_count);
 		goto failed_mount;
 	}
 
 	 
 	if (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {
                 ext4_msg(sb, KERN_WARNING, ""bad geometry: first data""
 			 ""block %u is beyond end of filesystem (%llu)"",
 			 le32_to_cpu(es->s_first_data_block),
 			 ext4_blocks_count(es));
 		goto failed_mount;
 	}
 	blocks_count = (ext4_blocks_count(es) -
 			le32_to_cpu(es->s_first_data_block) +
 			EXT4_BLOCKS_PER_GROUP(sb) - 1);
 	do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
 	if (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {
 		ext4_msg(sb, KERN_WARNING, ""groups count too large: %u ""
 		       ""(block count %llu, first data block %u, ""
 		       ""blocks per group %lu)"", sbi->s_groups_count,
 		       ext4_blocks_count(es),
 		       le32_to_cpu(es->s_first_data_block),
 		       EXT4_BLOCKS_PER_GROUP(sb));
 		goto failed_mount;
 	}
 	sbi->s_groups_count = blocks_count;
 	sbi->s_blockfile_groups = min_t(ext4_group_t, sbi->s_groups_count,
 			(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));
 	db_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /
 		   EXT4_DESC_PER_BLOCK(sb);
 	sbi->s_group_desc = kmalloc(db_count * sizeof(struct buffer_head *),
 				    GFP_KERNEL);
 	if (sbi->s_group_desc == NULL) {
 		ext4_msg(sb, KERN_ERR, ""not enough memory"");
 		goto failed_mount;
 	}
 
 #ifdef CONFIG_PROC_FS
 	if (ext4_proc_root)
 		sbi->s_proc = proc_mkdir(sb->s_id, ext4_proc_root);
 #endif
 
 	bgl_lock_init(sbi->s_blockgroup_lock);
 
 	for (i = 0; i < db_count; i++) {
 		block = descriptor_loc(sb, logical_sb_block, i);
 		sbi->s_group_desc[i] = sb_bread(sb, block);
 		if (!sbi->s_group_desc[i]) {
 			ext4_msg(sb, KERN_ERR,
 			       ""can't read group descriptor %d"", i);
 			db_count = i;
 			goto failed_mount2;
 		}
 	}
 	if (!ext4_check_descriptors(sb)) {
 		ext4_msg(sb, KERN_ERR, ""group descriptors corrupted!"");
 		goto failed_mount2;
 	}
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_FLEX_BG))
 		if (!ext4_fill_flex_info(sb)) {
 			ext4_msg(sb, KERN_ERR,
 			       ""unable to initialize ""
 			       ""flex_bg meta info!"");
 			goto failed_mount2;
 		}
 
 	sbi->s_gdb_count = db_count;
 	get_random_bytes(&sbi->s_next_generation, sizeof(u32));
 	spin_lock_init(&sbi->s_next_gen_lock);
 
 	err = percpu_counter_init(&sbi->s_freeblocks_counter,
 			ext4_count_free_blocks(sb));
 	if (!err) {
 		err = percpu_counter_init(&sbi->s_freeinodes_counter,
 				ext4_count_free_inodes(sb));
 	}
 	if (!err) {
 		err = percpu_counter_init(&sbi->s_dirs_counter,
 				ext4_count_dirs(sb));
 	}
 	if (!err) {
 		err = percpu_counter_init(&sbi->s_dirtyblocks_counter, 0);
 	}
 	if (err) {
 		ext4_msg(sb, KERN_ERR, ""insufficient memory"");
 		goto failed_mount3;
 	}
 
 	sbi->s_stripe = ext4_get_stripe_size(sbi);
 	sbi->s_max_writeback_mb_bump = 128;
 
 	 
 	if (!test_opt(sb, NOLOAD) &&
 	    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL))
 		sb->s_op = &ext4_sops;
 	else
 		sb->s_op = &ext4_nojournal_sops;
 	sb->s_export_op = &ext4_export_ops;
 	sb->s_xattr = ext4_xattr_handlers;
 #ifdef CONFIG_QUOTA
 	sb->s_qcop = &ext4_qctl_operations;
 	sb->dq_op = &ext4_quota_operations;
 #endif
 	INIT_LIST_HEAD(&sbi->s_orphan);  
 	mutex_init(&sbi->s_orphan_lock);
 	mutex_init(&sbi->s_resize_lock);
 
 	sb->s_root = NULL;
 
 	needs_recovery = (es->s_last_orphan != 0 ||
 			  EXT4_HAS_INCOMPAT_FEATURE(sb,
 				    EXT4_FEATURE_INCOMPAT_RECOVER));
 
 	 
 	if (!test_opt(sb, NOLOAD) &&
 	    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL)) {
 		if (ext4_load_journal(sb, es, journal_devnum))
 			goto failed_mount3;
 	} else if (test_opt(sb, NOLOAD) && !(sb->s_flags & MS_RDONLY) &&
  	      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {
  		ext4_msg(sb, KERN_ERR, ""required journal recovery ""
  		       ""suppressed and not mounted read-only"");
		goto failed_mount4;
 		goto failed_mount_wq;
  	} else {
  		clear_opt(sbi->s_mount_opt, DATA_FLAGS);
  		set_opt(sbi->s_mount_opt, WRITEBACK_DATA);
 		sbi->s_journal = NULL;
 		needs_recovery = 0;
 		goto no_journal;
 	}
 
 	if (ext4_blocks_count(es) > 0xffffffffULL &&
  	    !jbd2_journal_set_features(EXT4_SB(sb)->s_journal, 0, 0,
  				       JBD2_FEATURE_INCOMPAT_64BIT)) {
  		ext4_msg(sb, KERN_ERR, ""Failed to set 64-bit journal feature"");
		goto failed_mount4;
 		goto failed_mount_wq;
  	}
  
  	if (test_opt(sb, JOURNAL_ASYNC_COMMIT)) {
 		jbd2_journal_set_features(sbi->s_journal,
 				JBD2_FEATURE_COMPAT_CHECKSUM, 0,
 				JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);
 	} else if (test_opt(sb, JOURNAL_CHECKSUM)) {
 		jbd2_journal_set_features(sbi->s_journal,
 				JBD2_FEATURE_COMPAT_CHECKSUM, 0, 0);
 		jbd2_journal_clear_features(sbi->s_journal, 0, 0,
 				JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);
 	} else {
 		jbd2_journal_clear_features(sbi->s_journal,
 				JBD2_FEATURE_COMPAT_CHECKSUM, 0,
 				JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT);
 	}
 
 	 
 	switch (test_opt(sb, DATA_FLAGS)) {
 	case 0:
 		 
 		if (jbd2_journal_check_available_features
 		    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE))
 			set_opt(sbi->s_mount_opt, ORDERED_DATA);
 		else
 			set_opt(sbi->s_mount_opt, JOURNAL_DATA);
 		break;
 
 	case EXT4_MOUNT_ORDERED_DATA:
 	case EXT4_MOUNT_WRITEBACK_DATA:
 		if (!jbd2_journal_check_available_features
  		    (sbi->s_journal, 0, 0, JBD2_FEATURE_INCOMPAT_REVOKE)) {
  			ext4_msg(sb, KERN_ERR, ""Journal does not support ""
  			       ""requested data journaling mode"");
			goto failed_mount4;
 			goto failed_mount_wq;
  		}
  	default:
  		break;
  	}
  	set_task_ioprio(sbi->s_journal->j_task, journal_ioprio);
  
  no_journal:
  	if (test_opt(sb, NOBH)) {
  		if (!(test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)) {
  			ext4_msg(sb, KERN_WARNING, ""Ignoring nobh option - ""
  				""its supported only with writeback mode"");
  			clear_opt(sbi->s_mount_opt, NOBH);
  		}
 		if (test_opt(sb, DIOREAD_NOLOCK)) {
 			ext4_msg(sb, KERN_WARNING, ""dioread_nolock option is ""
 				""not supported with nobh mode"");
 			goto failed_mount_wq;
 		}
  	}
  	EXT4_SB(sb)->dio_unwritten_wq = create_workqueue(""ext4-dio-unwritten"");
  	if (!EXT4_SB(sb)->dio_unwritten_wq) {
 		printk(KERN_ERR ""EXT4-fs: failed to create DIO workqueue\n"");
 		goto failed_mount_wq;
 	}
 
 	 
 
 	root = ext4_iget(sb, EXT4_ROOT_INO);
 	if (IS_ERR(root)) {
 		ext4_msg(sb, KERN_ERR, ""get root inode failed"");
 		ret = PTR_ERR(root);
 		goto failed_mount4;
 	}
 	if (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {
 		iput(root);
 		ext4_msg(sb, KERN_ERR, ""corrupt root inode, run e2fsck"");
 		goto failed_mount4;
 	}
 	sb->s_root = d_alloc_root(root);
 	if (!sb->s_root) {
 		ext4_msg(sb, KERN_ERR, ""get root dentry failed"");
 		iput(root);
 		ret = -ENOMEM;
 		goto failed_mount4;
 	}
 
 	ext4_setup_super(sb, es, sb->s_flags & MS_RDONLY);
 
 	 
 	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE) {
 		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
 						     EXT4_GOOD_OLD_INODE_SIZE;
 		if (EXT4_HAS_RO_COMPAT_FEATURE(sb,
 				       EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE)) {
 			if (sbi->s_want_extra_isize <
 			    le16_to_cpu(es->s_want_extra_isize))
 				sbi->s_want_extra_isize =
 					le16_to_cpu(es->s_want_extra_isize);
 			if (sbi->s_want_extra_isize <
 			    le16_to_cpu(es->s_min_extra_isize))
 				sbi->s_want_extra_isize =
 					le16_to_cpu(es->s_min_extra_isize);
 		}
 	}
 	 
 	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
 							sbi->s_inode_size) {
 		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
 						       EXT4_GOOD_OLD_INODE_SIZE;
 		ext4_msg(sb, KERN_INFO, ""required extra inode space not""
 			 ""available"");
 	}
 
 	if (test_opt(sb, DELALLOC) &&
 	    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {
 		ext4_msg(sb, KERN_WARNING, ""Ignoring delalloc option - ""
  			 ""requested data journaling mode"");
  		clear_opt(sbi->s_mount_opt, DELALLOC);
  	}
 	if (test_opt(sb, DIOREAD_NOLOCK)) {
 		if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {
 			ext4_msg(sb, KERN_WARNING, ""Ignoring dioread_nolock ""
 				""option - requested data journaling mode"");
 			clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);
 		}
 		if (sb->s_blocksize < PAGE_SIZE) {
 			ext4_msg(sb, KERN_WARNING, ""Ignoring dioread_nolock ""
 				""option - block size is too small"");
 			clear_opt(sbi->s_mount_opt, DIOREAD_NOLOCK);
 		}
 	}
  
  	err = ext4_setup_system_zone(sb);
  	if (err) {
 		ext4_msg(sb, KERN_ERR, ""failed to initialize system ""
 			 ""zone (%d)\n"", err);
 		goto failed_mount4;
 	}
 
 	ext4_ext_init(sb);
 	err = ext4_mb_init(sb, needs_recovery);
 	if (err) {
 		ext4_msg(sb, KERN_ERR, ""failed to initalize mballoc (%d)"",
 			 err);
 		goto failed_mount4;
 	}
 
 	sbi->s_kobj.kset = ext4_kset;
 	init_completion(&sbi->s_kobj_unregister);
 	err = kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL,
 				   ""%s"", sb->s_id);
 	if (err) {
 		ext4_mb_release(sb);
 		ext4_ext_release(sb);
 		goto failed_mount4;
 	};
 
 	EXT4_SB(sb)->s_mount_state |= EXT4_ORPHAN_FS;
 	ext4_orphan_cleanup(sb, es);
 	EXT4_SB(sb)->s_mount_state &= ~EXT4_ORPHAN_FS;
 	if (needs_recovery) {
 		ext4_msg(sb, KERN_INFO, ""recovery complete"");
 		ext4_mark_recovery_complete(sb, es);
 	}
 	if (EXT4_SB(sb)->s_journal) {
 		if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)
 			descr = "" journalled data mode"";
 		else if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_ORDERED_DATA)
 			descr = "" ordered data mode"";
 		else
 			descr = "" writeback data mode"";
 	} else
 		descr = ""out journal"";
 
 	ext4_msg(sb, KERN_INFO, ""mounted filesystem with%s"", descr);
 
 	lock_kernel();
 	return 0;
 
 cantfind_ext4:
 	if (!silent)
 		ext4_msg(sb, KERN_ERR, ""VFS: Can't find ext4 filesystem"");
 	goto failed_mount;
 
 failed_mount4:
 	ext4_msg(sb, KERN_ERR, ""mount failed"");
 	destroy_workqueue(EXT4_SB(sb)->dio_unwritten_wq);
 failed_mount_wq:
 	ext4_release_system_zone(sb);
 	if (sbi->s_journal) {
 		jbd2_journal_destroy(sbi->s_journal);
 		sbi->s_journal = NULL;
 	}
 failed_mount3:
 	if (sbi->s_flex_groups) {
 		if (is_vmalloc_addr(sbi->s_flex_groups))
 			vfree(sbi->s_flex_groups);
 		else
 			kfree(sbi->s_flex_groups);
 	}
 	percpu_counter_destroy(&sbi->s_freeblocks_counter);
 	percpu_counter_destroy(&sbi->s_freeinodes_counter);
 	percpu_counter_destroy(&sbi->s_dirs_counter);
 	percpu_counter_destroy(&sbi->s_dirtyblocks_counter);
 failed_mount2:
 	for (i = 0; i < db_count; i++)
 		brelse(sbi->s_group_desc[i]);
 	kfree(sbi->s_group_desc);
 failed_mount:
 	if (sbi->s_proc) {
 		remove_proc_entry(sb->s_id, ext4_proc_root);
 	}
 #ifdef CONFIG_QUOTA
 	for (i = 0; i < MAXQUOTAS; i++)
 		kfree(sbi->s_qf_names[i]);
 #endif
 	ext4_blkdev_remove(sbi);
 	brelse(bh);
 out_fail:
 	sb->s_fs_info = NULL;
 	kfree(sbi->s_blockgroup_lock);
 	kfree(sbi);
 	lock_kernel();
 	return ret;
 }","[400, 414, 450, 464, 465, 466, 467, 468, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 399, 413, 449]","The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function."
199041," SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,
 		struct rusage32 __user *, ur)
  {
  	struct rusage r;
  	long ret, err;
 	unsigned int status = 0;
  	mm_segment_t old_fs;
  
  	if (!ur)
 		return sys_wait4(pid, ustatus, options, NULL);
 
  	old_fs = get_fs();
  		
  	set_fs (KERNEL_DS);
	ret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);
 	ret = sys_wait4(pid, (unsigned int __user *) &status, options,
 			(struct rusage __user *) &r);
  	set_fs (old_fs);
  
  	if (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))
  		return -EFAULT;
  
  	err = 0;
 	err |= put_user(status, ustatus);
  	err |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);
  	err |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);
  	err |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);
 	err |= __put_user(r.ru_stime.tv_usec, &ur->ru_stime.tv_usec);
 	err |= __put_user(r.ru_maxrss, &ur->ru_maxrss);
 	err |= __put_user(r.ru_ixrss, &ur->ru_ixrss);
 	err |= __put_user(r.ru_idrss, &ur->ru_idrss);
 	err |= __put_user(r.ru_isrss, &ur->ru_isrss);
 	err |= __put_user(r.ru_minflt, &ur->ru_minflt);
 	err |= __put_user(r.ru_majflt, &ur->ru_majflt);
 	err |= __put_user(r.ru_nswap, &ur->ru_nswap);
 	err |= __put_user(r.ru_inblock, &ur->ru_inblock);
 	err |= __put_user(r.ru_oublock, &ur->ru_oublock);
 	err |= __put_user(r.ru_msgsnd, &ur->ru_msgsnd);
 	err |= __put_user(r.ru_msgrcv, &ur->ru_msgrcv);
 	err |= __put_user(r.ru_nsignals, &ur->ru_nsignals);
 	err |= __put_user(r.ru_nvcsw, &ur->ru_nvcsw);
 	err |= __put_user(r.ru_nivcsw, &ur->ru_nivcsw);
 
 	return err ? err : ret;
 }","[6, 16, 17, 24, 15]","The osf_wait4 function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform uses an incorrect pointer, which allows local users to gain privileges by writing a certain integer value to kernel memory."
6122,"ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)
{
ngx_int_t                  overwrite;
ngx_str_t                  uri, args;
ngx_table_elt_t           *location;
ngx_http_core_loc_conf_t  *clcf;

overwrite = err_page->overwrite;

if (overwrite && overwrite != NGX_HTTP_OK) {
r->expect_tested = 1;
}

if (overwrite >= 0) {
r->err_status = overwrite;
}

if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {
return NGX_ERROR;
}

if (uri.len && uri.data[0] == '/') {

if (err_page->value.lengths) {
ngx_http_split_args(r, &uri, &args);

} else {
args = err_page->args;
}

if (r->method != NGX_HTTP_HEAD) {
r->method = NGX_HTTP_GET;
r->method_name = ngx_http_core_get_method;
}

return ngx_http_internal_redirect(r, &uri, &args);
}

if (uri.len && uri.data[0] == '@') {
return ngx_http_named_location(r, &uri);
}

location = ngx_list_push(&r->headers_out.headers);

if (location == NULL) {
return NGX_ERROR;
}

if (overwrite != NGX_HTTP_MOVED_PERMANENTLY
&& overwrite != NGX_HTTP_MOVED_TEMPORARILY
&& overwrite != NGX_HTTP_SEE_OTHER
&& overwrite != NGX_HTTP_TEMPORARY_REDIRECT
&& overwrite != NGX_HTTP_PERMANENT_REDIRECT)
{
r->err_status = NGX_HTTP_MOVED_TEMPORARILY;
}

location->hash = 1;
ngx_str_set(&location->key, ""Location"");
location->value = uri;

ngx_http_clear_location(r);

r->headers_out.location = location;

clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

if (clcf->msie_refresh && r->headers_in.msie) {
return ngx_http_send_refresh(r);
}

return ngx_http_send_special_response(r, clcf, r->err_status
- NGX_HTTP_MOVED_PERMANENTLY
+ NGX_HTTP_OFF_3XX);
}",[43],"NGINX before 1.17.7, with certain error_page configurations, allows HTTP request smuggling, as demonstrated by the ability of an attacker to read unauthorized web pages in environments where NGINX is being fronted by a load balancer."
207925," static int sysMapBlockFile(FILE* mapf, MemMapping* pMap)
 {
 
      char block_dev[PATH_MAX+1];
      size_t size;
      unsigned int blksize;
    unsigned int blocks;
     size_t blocks;
      unsigned int range_count;
      unsigned int i;
  
  if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) {
         LOGW(""failed to read block device from header\n"");
  return -1;
  }
  for (i = 0; i < sizeof(block_dev); ++i) {
  if (block_dev[i] == '\n') {
             block_dev[i] = 0;
  break;
  }
  }
 
  if (fscanf(mapf, ""%zu %u\n%u\n"", &size, &blksize, &range_count) != 3) {
 
          LOGW(""failed to parse block map header\n"");
          return -1;
      }
    blocks = ((size-1) / blksize) + 1;
     if (blksize != 0) {
         blocks = ((size-1) / blksize) + 1;
     }
     if (size == 0 || blksize == 0 || blocks > SIZE_MAX / blksize || range_count == 0) {
         LOGE(""invalid data in block map file: size %zu, blksize %u, range_count %u\n"",
              size, blksize, range_count);
         return -1;
     }
  
      pMap->range_count = range_count;
    pMap->ranges = malloc(range_count * sizeof(MappedRange));
    memset(pMap->ranges, 0, range_count * sizeof(MappedRange));
     pMap->ranges = calloc(range_count, sizeof(MappedRange));
     if (pMap->ranges == NULL) {
         LOGE(""calloc(%u, %zu) failed: %s\n"", range_count, sizeof(MappedRange), strerror(errno));
         return -1;
     }
  
      unsigned char* reserve;
      reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
      if (reserve == MAP_FAILED) {
          LOGW(""failed to reserve address space: %s\n"", strerror(errno));
         free(pMap->ranges);
          return -1;
      }
  
    pMap->ranges[range_count-1].addr = reserve;
    pMap->ranges[range_count-1].length = blocks * blksize;
      int fd = open(block_dev, O_RDONLY);
      if (fd < 0) {
          LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno));
         munmap(reserve, blocks * blksize);
         free(pMap->ranges);
          return -1;
      }
  
      unsigned char* next = reserve;
     size_t remaining_size = blocks * blksize;
     bool success = true;
      for (i = 0; i < range_count; ++i) {
        int start, end;
        if (fscanf(mapf, ""%d %d\n"", &start, &end) != 2) {
         size_t start, end;
         if (fscanf(mapf, ""%zu %zu\n"", &start, &end) != 2) {
              LOGW(""failed to parse range %d in block map\n"", i);
            return -1;
             success = false;
             break;
         }
         size_t length = (end - start) * blksize;
         if (end <= start || (end - start) > SIZE_MAX / blksize || length > remaining_size) {
           LOGE(""unexpected range in block map: %zu %zu\n"", start, end);
           success = false;
           break;
          }
  
        void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
         void* addr = mmap64(next, length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize);
          if (addr == MAP_FAILED) {
              LOGW(""failed to map block %d: %s\n"", i, strerror(errno));
            return -1;
             success = false;
             break;
          }
          pMap->ranges[i].addr = addr;
        pMap->ranges[i].length = (end-start)*blksize;
         pMap->ranges[i].length = length;
  
        next += pMap->ranges[i].length;
         next += length;
         remaining_size -= length;
     }
     if (success && remaining_size != 0) {
       LOGE(""ranges in block map are invalid: remaining_size = %zu\n"", remaining_size);
       success = false;
     }
     if (!success) {
       close(fd);
       munmap(reserve, blocks * blksize);
       free(pMap->ranges);
       return -1;
      }
  
     close(fd);
      pMap->addr = reserve;
      pMap->length = size;
  
     LOGI(""mmapped %d ranges\n"", range_count);
 
  return 0;
 }","[8, 29, 30, 31, 32, 33, 34, 35, 36, 41, 42, 43, 44, 45, 51, 60, 61, 66, 67, 71, 72, 75, 76, 77, 78, 79, 80, 81, 82, 86, 90, 91, 95, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 112, 7, 28, 39, 40, 55, 56, 69, 70, 74, 85, 89, 94, 97]","Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931."
206878," std::unique_ptr<base::DictionaryValue> ParsePrintSettings(
     int command_id,
     const base::DictionaryValue* params,
     HeadlessPrintSettings* settings) {
   if (const base::Value* landscape_value = params->FindKey(""landscape""))
     settings->landscape = landscape_value->GetBool();
 
   if (const base::Value* display_header_footer_value =
           params->FindKey(""displayHeaderFooter"")) {
     settings->display_header_footer = display_header_footer_value->GetBool();
   }
 
   if (const base::Value* should_print_backgrounds_value =
           params->FindKey(""printBackground"")) {
     settings->should_print_backgrounds =
         should_print_backgrounds_value->GetBool();
   }
   if (const base::Value* scale_value = params->FindKey(""scale""))
     settings->scale = scale_value->GetDouble();
   if (settings->scale > kScaleMaxVal / 100 ||
       settings->scale < kScaleMinVal / 100)
     return CreateInvalidParamResponse(command_id, ""scale"");
   if (const base::Value* page_ranges_value = params->FindKey(""pageRanges""))
     settings->page_ranges = page_ranges_value->GetString();
 
   if (const base::Value* ignore_invalid_page_ranges_value =
           params->FindKey(""ignoreInvalidPageRanges"")) {
     settings->ignore_invalid_page_ranges =
         ignore_invalid_page_ranges_value->GetBool();
   }
 
   double paper_width_in_inch = printing::kLetterWidthInch;
 
   if (const base::Value* paper_width_value = params->FindKey(""paperWidth""))
     paper_width_in_inch = paper_width_value->GetDouble();
 
   double paper_height_in_inch = printing::kLetterHeightInch;
 
   if (const base::Value* paper_height_value = params->FindKey(""paperHeight""))
     paper_height_in_inch = paper_height_value->GetDouble();
   if (paper_width_in_inch <= 0)
     return CreateInvalidParamResponse(command_id, ""paperWidth"");
   if (paper_height_in_inch <= 0)
     return CreateInvalidParamResponse(command_id, ""paperHeight"");
   settings->paper_size_in_points =
       gfx::Size(paper_width_in_inch * printing::kPointsPerInch,
                 paper_height_in_inch * printing::kPointsPerInch);
 
   double default_margin_in_inch = 1000.0 / printing::kHundrethsMMPerInch;
   double margin_top_in_inch = default_margin_in_inch;
   double margin_bottom_in_inch = default_margin_in_inch;
   double margin_left_in_inch = default_margin_in_inch;
   double margin_right_in_inch = default_margin_in_inch;
 
   if (const base::Value* margin_top_value = params->FindKey(""marginTop""))
     margin_top_in_inch = margin_top_value->GetDouble();
 
   if (const base::Value* margin_bottom_value = params->FindKey(""marginBottom""))
     margin_bottom_in_inch = margin_bottom_value->GetDouble();
 
   if (const base::Value* margin_left_value = params->FindKey(""marginLeft""))
     margin_left_in_inch = margin_left_value->GetDouble();
 
    if (const base::Value* margin_right_value = params->FindKey(""marginRight""))
      margin_right_in_inch = margin_right_value->GetDouble();
  
   if (const base::Value* header_template_value =
           params->FindKey(""headerTemplate"")) {
     settings->header_template = header_template_value->GetString();
   }
   if (const base::Value* footer_template_value =
           params->FindKey(""footerTemplate"")) {
     settings->footer_template = footer_template_value->GetString();
   }
 
    if (margin_top_in_inch < 0)
      return CreateInvalidParamResponse(command_id, ""marginTop"");
    if (margin_bottom_in_inch < 0)
     return CreateInvalidParamResponse(command_id, ""marginBottom"");
   if (margin_left_in_inch < 0)
     return CreateInvalidParamResponse(command_id, ""marginLeft"");
   if (margin_right_in_inch < 0)
     return CreateInvalidParamResponse(command_id, ""marginRight"");
   settings->margins_in_points.top =
       margin_top_in_inch * printing::kPointsPerInch;
   settings->margins_in_points.bottom =
       margin_bottom_in_inch * printing::kPointsPerInch;
   settings->margins_in_points.left =
       margin_left_in_inch * printing::kPointsPerInch;
   settings->margins_in_points.right =
       margin_right_in_inch * printing::kPointsPerInch;
 
   return nullptr;
 }","[67, 68, 69, 70, 71, 72, 73, 74, 75]",Failure to apply Mark-of-the-Web in Downloads in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to bypass OS level controls via a crafted HTML page.
201261," find_file (const char *currpath, grub_fshelp_node_t currroot,
  	   grub_fshelp_node_t *currfound,
  	   struct grub_fshelp_find_file_closure *c)
  {
#ifndef _MSC_VER
	char fpath[grub_strlen (currpath) + 1];
#else
  	char *fpath = grub_malloc (grub_strlen (currpath) + 1);
#endif
    char *name = fpath;
    char *next;
    enum grub_fshelp_filetype type = GRUB_FSHELP_DIR;
   grub_fshelp_node_t currnode = currroot;
   grub_fshelp_node_t oldnode = currroot;
 
   c->currroot = currroot;
 
   grub_strncpy (fpath, currpath, grub_strlen (currpath) + 1);
 
    
   while (*name == '/')
     name++;
 
    if (! *name)
      {
        *currfound = currnode;
 free (fpath);
        return 0;
      }
  
   for (;;)
     {
       int found;
       struct find_file_closure cc;
 
        
       next = grub_strchr (name, '/');
       if (next)
 	{
 	   
 	  while (*next == '/')
 	    *(next++) = '\0';
 	}
 
        
        if (type != GRUB_FSHELP_DIR)
  	{
  	  free_node (currnode, c);
 free (fpath);
  	  return grub_error (GRUB_ERR_BAD_FILE_TYPE, ""not a directory"");
  	}
  
       cc.name = name;
       cc.type = &type;
       cc.oldnode = &oldnode;
       cc.currnode = &currnode;
        
        found = c->iterate_dir (currnode, iterate, &cc);
        if (! found)
  	{
	  if (grub_errno)
 	  if (grub_errno) {
 free (fpath);
  	    return grub_errno;
 }
  
  	  break;
  	}
 
        
       if (type == GRUB_FSHELP_SYMLINK)
 	{
 	  char *symlink;
 
 	   
 	  if (++(c->symlinknest) == 8)
  	    {
  	      free_node (currnode, c);
  	      free_node (oldnode, c);
 free (fpath);
  	      return grub_error (GRUB_ERR_SYMLINK_LOOP,
  				 ""too deep nesting of symlinks"");
  	    }
 
 	  symlink = c->read_symlink (currnode);
 	  free_node (currnode, c);
 
  	  if (!symlink)
  	    {
  	      free_node (oldnode, c);
 free (fpath);
  	      return grub_errno;
  	    }
  
 	   
 	  if (symlink[0] == '/')
 	    {
 	      free_node (oldnode, c);
 	      oldnode = c->rootnode;
 	    }
 
 	   
 	  find_file (symlink, oldnode, &currnode, c);
 	  type = c->foundtype;
 	  grub_free (symlink);
 
  	  if (grub_errno)
  	    {
  	      free_node (oldnode, c);
 free (fpath);
  	      return grub_errno;
  	    }
  	}
 
       free_node (oldnode, c);
 
        
       if (! next || *next == '\0')
  	{
  	  *currfound = currnode;
  	  c->foundtype = type;
 free (fpath);
  	  return 0;
  	}
  
        name = next;
      }
  
 free (fpath);
    return grub_error (GRUB_ERR_FILE_NOT_FOUND, ""file not found"");
  }","[27, 49, 62, 63, 65, 80, 91, 110, 122, 129, 5, 6, 7, 9, 61]","The grub_ext2_read_block function in fs/ext2.c in GNU GRUB before 2013-11-12, as used in shlr/grub/fs/ext2.c in radare2 1.5.0, allows remote attackers to cause a denial of service (excessive stack use and application crash) via a crafted binary file, related to use of a variable-size stack array."
202417," int git_delta_apply(
 	void **out,
 	size_t *out_len,
 	const unsigned char *base,
 	size_t base_len,
 	const unsigned char *delta,
 	size_t delta_len)
 {
 	const unsigned char *delta_end = delta + delta_len;
 	size_t base_sz, res_sz, alloc_sz;
 	unsigned char *res_dp;
 
 	*out = NULL;
 	*out_len = 0;
 
 	 
 	if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {
 		giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
 		return -1;
 	}
 
 	if (hdr_sz(&res_sz, &delta, delta_end) < 0) {
 		giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
 		return -1;
 	}
 
 	GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);
 	res_dp = git__malloc(alloc_sz);
 	GITERR_CHECK_ALLOC(res_dp);
 
 	res_dp[res_sz] = '\0';
 	*out = res_dp;
 	*out_len = res_sz;
 
 	while (delta < delta_end) {
  		unsigned char cmd = *delta++;
  		if (cmd & 0x80) {
  			 
			size_t off = 0, len = 0;
 			size_t off = 0, len = 0, end;
  
  #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }
  			if (cmd & 0x01) ADD_DELTA(off, 0UL);
 			if (cmd & 0x02) ADD_DELTA(off, 8UL);
 			if (cmd & 0x04) ADD_DELTA(off, 16UL);
 			if (cmd & 0x08) ADD_DELTA(off, 24UL);
 
 			if (cmd & 0x10) ADD_DELTA(len, 0UL);
 			if (cmd & 0x20) ADD_DELTA(len, 8UL);
 			if (cmd & 0x40) ADD_DELTA(len, 16UL);
  			if (!len)       len = 0x10000;
  #undef ADD_DELTA
  
			if (base_len < off + len || res_sz < len)
 			if (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||
 			    base_len < end || res_sz < len)
  				goto fail;
 
  			memcpy(res_dp, base + off, len);
  			res_dp += len;
  			res_sz -= len;
 
 		} else if (cmd) {
 			 
 			if (delta_end - delta < cmd || res_sz < cmd)
 				goto fail;
 			memcpy(res_dp, delta, cmd);
 			delta += cmd;
 			res_dp += cmd;
 			res_sz -= cmd;
 
 		} else {
 			 
 			goto fail;
 		}
 	}
 
 	if (delta != delta_end || res_sz)
 		goto fail;
 	return 0;
 
 fail:
 	git__free(*out);
 
 	*out = NULL;
 	*out_len = 0;
 
 	giterr_set(GITERR_INVALID, ""failed to apply delta"");
 	return -1;
 }","[40, 55, 56, 58, 39, 54]","A flaw was found in libgit2 before version 0.27.3. It has been discovered that an unexpected sign extension in git_delta_apply function in delta.c file may lead to an integer overflow which in turn leads to an out of bound read, allowing to read before the base object. An attacker may use this flaw to leak memory addresses or cause a Denial of Service."
206357," IDNSpoofChecker::IDNSpoofChecker() {
   UErrorCode status = U_ZERO_ERROR;
   checker_ = uspoof_open(&status);
   if (U_FAILURE(status)) {
     checker_ = nullptr;
     return;
   }
 
 
   uspoof_setRestrictionLevel(checker_, USPOOF_MODERATELY_RESTRICTIVE);
 
   SetAllowedUnicodeSet(&status);
 
   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;
   uspoof_setChecks(checker_, checks, &status);
 
   deviation_characters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[\\u00df\\u03c2\\u200c\\u200d]""),
                       status);
   deviation_characters_.freeze();
 
   non_ascii_latin_letters_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[[:Latin:] - [a-zA-Z]]""), status);
   non_ascii_latin_letters_.freeze();
 
   kana_letters_exceptions_ = icu::UnicodeSet(UNICODE_STRING_SIMPLE(
        ""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb\\u30fc]""), status);
    kana_letters_exceptions_.freeze();
  
    
    
   cyrillic_letters_latin_alike_ =
       icu::UnicodeSet(icu::UnicodeString(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);
   cyrillic_letters_latin_alike_.freeze();
 
   cyrillic_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
   cyrillic_letters_.freeze();
 
    DCHECK(U_SUCCESS(status));
  }","[30, 31, 32, 33, 34, 35, 36, 37, 38, 39]","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 58.0.3029.81 for Mac, Windows, and Linux, and 58.0.3029.83 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
199295," kvp_respond_to_host(char *key, char *value, int error)
 {
 	struct hv_kvp_msg  *kvp_msg;
 	struct hv_kvp_msg_enumerate  *kvp_data;
 	char	*key_name;
 	struct icmsg_hdr *icmsghdrp;
 	int	keylen, valuelen;
 	u32	buf_len;
 	struct vmbus_channel *channel;
 	u64	req_id;
 
 	 
 
 	if (!kvp_transaction.active) {
 		 
 		pr_warn(""KVP: Transaction not active\n"");
 		return;
 	}
 	 
 
 	buf_len = kvp_transaction.recv_len;
 	channel = kvp_transaction.recv_channel;
 	req_id = kvp_transaction.recv_req_id;
 
 	kvp_transaction.active = false;
 
 	if (channel->onchannel_callback == NULL)
 		 
 		return;
 
 	icmsghdrp = (struct icmsg_hdr *)
 			&recv_buffer[sizeof(struct vmbuspipe_hdr)];
 	kvp_msg = (struct hv_kvp_msg *)
 			&recv_buffer[sizeof(struct vmbuspipe_hdr) +
 			sizeof(struct icmsg_hdr)];
 	kvp_data = &kvp_msg->kvp_data;
 	key_name = key;
 
 	 
 	if (error) {
 		 
 		icmsghdrp->status = HV_E_FAIL;
 		goto response_done;
 	}
 
 	 
	keylen = utf8s_to_utf16s(key_name, strlen(key_name),
				(wchar_t *)kvp_data->data.key);
 	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->data.key,
 				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
  	kvp_data->data.key_size = 2*(keylen + 1);  
	valuelen = utf8s_to_utf16s(value, strlen(value),
				(wchar_t *)kvp_data->data.value);
 	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
 				(wchar_t *) kvp_data->data.value,
 				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);
  	kvp_data->data.value_size = 2*(valuelen + 1);  
  
  	kvp_data->data.value_type = REG_SZ;  
 	icmsghdrp->status = HV_S_OK;
 
 response_done:
 	icmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;
 
 	vmbus_sendpacket(channel, recv_buffer, buf_len, req_id,
 				VM_PKT_DATA_INBAND, 0);
 
 }","[49, 50, 51, 55, 56, 57, 47, 48, 53, 54]","Buffer overflow in the VFAT filesystem implementation in the Linux kernel before 3.3 allows local users to gain privileges or cause a denial of service (system crash) via a VFAT write operation on a filesystem with the utf8 mount option, which is not properly handled during UTF-8 to UTF-16 conversion."
198996," static void ptrace_triggered(struct perf_event *bp, int nmi,
 static void ptrace_triggered(struct perf_event *bp,
  			     struct perf_sample_data *data,
  			     struct pt_regs *regs)
  {
 	int i;
 	struct thread_struct *thread = &(current->thread);
 
 	 
 	for (i = 0; i < HBP_NUM; i++) {
 		if (thread->ptrace_bps[i] == bp)
 			break;
 	}
 
 	thread->debugreg6 |= (DR_TRAP0 << i);
 }",[2],"The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
199296," xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,
 	     int *longlen, int *outlen, int escape, int utf8,
 	     struct nls_table *nls)
 {
 	const unsigned char *ip;
 	unsigned char nc;
 	unsigned char *op;
 	unsigned int ec;
 	int i, k, fill;
  	int charlen;
  
  	if (utf8) {
		*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);
 		*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,
 				(wchar_t *) outname, FAT_LFN_LEN + 2);
  		if (*outlen < 0)
  			return *outlen;
  		else if (*outlen > FAT_LFN_LEN)
 			return -ENAMETOOLONG;
 
 		op = &outname[*outlen * sizeof(wchar_t)];
 	} else {
 		if (nls) {
 			for (i = 0, ip = name, op = outname, *outlen = 0;
 			     i < len && *outlen <= FAT_LFN_LEN;
 			     *outlen += 1)
 			{
 				if (escape && (*ip == ':')) {
 					if (i > len - 5)
 						return -EINVAL;
 					ec = 0;
 					for (k = 1; k < 5; k++) {
 						nc = ip[k];
 						ec <<= 4;
 						if (nc >= '0' && nc <= '9') {
 							ec |= nc - '0';
 							continue;
 						}
 						if (nc >= 'a' && nc <= 'f') {
 							ec |= nc - ('a' - 10);
 							continue;
 						}
 						if (nc >= 'A' && nc <= 'F') {
 							ec |= nc - ('A' - 10);
 							continue;
 						}
 						return -EINVAL;
 					}
 					*op++ = ec & 0xFF;
 					*op++ = ec >> 8;
 					ip += 5;
 					i += 5;
 				} else {
 					if ((charlen = nls->char2uni(ip, len - i, (wchar_t *)op)) < 0)
 						return -EINVAL;
 					ip += charlen;
 					i += charlen;
 					op += 2;
 				}
 			}
 			if (i < len)
 				return -ENAMETOOLONG;
 		} else {
 			for (i = 0, ip = name, op = outname, *outlen = 0;
 			     i < len && *outlen <= FAT_LFN_LEN;
 			     i++, *outlen += 1)
 			{
 				*op++ = *ip++;
 				*op++ = 0;
 			}
 			if (i < len)
 				return -ENAMETOOLONG;
 		}
 	}
 
 	*longlen = *outlen;
 	if (*outlen % 13) {
 		*op++ = 0;
 		*op++ = 0;
 		*outlen += 1;
 		if (*outlen % 13) {
 			fill = 13 - (*outlen % 13);
 			for (i = 0; i < fill; i++) {
 				*op++ = 0xff;
 				*op++ = 0xff;
 			}
 			*outlen += fill;
 		}
 	}
 
 	return 0;
 }","[14, 15, 13]","Buffer overflow in the VFAT filesystem implementation in the Linux kernel before 3.3 allows local users to gain privileges or cause a denial of service (system crash) via a VFAT write operation on a filesystem with the utf8 mount option, which is not properly handled during UTF-8 to UTF-16 conversion."
7019,"int bus_test_polkit(
sd_bus_message *call,
int capability,
const char *action,
const char **details,
uid_t good_user,
bool *_challenge,
sd_bus_error *e) {

int r;

assert(call);
assert(action);



r = check_good_user(call, good_user);
if (r != 0)
return r;

r = sd_bus_query_sender_privilege(call, capability);
if (r < 0)
return r;
else if (r > 0)
return 1;
#if ENABLE_POLKIT
else {
_cleanup_(sd_bus_message_unrefp) sd_bus_message *request = NULL;
_cleanup_(sd_bus_message_unrefp) sd_bus_message *reply = NULL;
int authorized = false, challenge = false;
const char *sender, **k, **v;

sender = sd_bus_message_get_sender(call);
if (!sender)
return -EBADMSG;

r = sd_bus_message_new_method_call(
call->bus,
&request,
""org.freedesktop.PolicyKit1"",
""/org/freedesktop/PolicyKit1/Authority"",
""org.freedesktop.PolicyKit1.Authority"",
""CheckAuthorization"");
if (r < 0)
return r;

r = sd_bus_message_append(
request,
""(sa{sv})s"",
""system-bus-name"", 1, ""name"", ""s"", sender,
action);
if (r < 0)
return r;

r = sd_bus_message_open_container(request, 'a', ""{ss}"");
if (r < 0)
return r;

STRV_FOREACH_PAIR(k, v, details) {
r = sd_bus_message_append(request, ""{ss}"", *k, *v);
if (r < 0)
return r;
}

r = sd_bus_message_close_container(request);
if (r < 0)
return r;

r = sd_bus_message_append(request, ""us"", 0, NULL);
if (r < 0)
return r;

r = sd_bus_call(call->bus, request, 0, e, &reply);
if (r < 0) {

if (sd_bus_error_has_name(e, SD_BUS_ERROR_SERVICE_UNKNOWN)) {
sd_bus_error_free(e);
return -EACCES;
}

return r;
}

r = sd_bus_message_enter_container(reply, 'r', ""bba{ss}"");
if (r < 0)
return r;

r = sd_bus_message_read(reply, ""bb"", &authorized, &challenge);
if (r < 0)
return r;

if (authorized)
return 1;

if (_challenge) {
*_challenge = challenge;
return 0;
}
}
#endif

return -EACCES;
}","[8, 31, 55, 56, 57, 59, 60, 61, 62, 65, 73, 76, 77]","A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages."
199693," static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,
 			       struct msghdr *msg, size_t size,
 			       int flags)
 {
 	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
 	struct scm_cookie tmp_scm;
 	struct sock *sk = sock->sk;
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr = msg->msg_name;
 	int copied = 0;
 	int check_creds = 0;
 	int target;
 	int err = 0;
 	long timeo;
 	int skip;
 
 	err = -EINVAL;
 	if (sk->sk_state != TCP_ESTABLISHED)
 		goto out;
 
 	err = -EOPNOTSUPP;
 	if (flags&MSG_OOB)
 		goto out;
 
  	target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);
  	timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);
  
	msg->msg_namelen = 0;
  	 
 
 	if (!siocb->scm) {
 		siocb->scm = &tmp_scm;
 		memset(&tmp_scm, 0, sizeof(tmp_scm));
 	}
 
 	err = mutex_lock_interruptible(&u->readlock);
 	if (err) {
 		err = sock_intr_errno(timeo);
 		goto out;
 	}
 
 	do {
 		int chunk;
 		struct sk_buff *skb, *last;
 
 		unix_state_lock(sk);
 		last = skb = skb_peek(&sk->sk_receive_queue);
 again:
 		if (skb == NULL) {
 			unix_sk(sk)->recursion_level = 0;
 			if (copied >= target)
 				goto unlock;
 
 			 
 
 			err = sock_error(sk);
 			if (err)
 				goto unlock;
 			if (sk->sk_shutdown & RCV_SHUTDOWN)
 				goto unlock;
 
 			unix_state_unlock(sk);
 			err = -EAGAIN;
 			if (!timeo)
 				break;
 			mutex_unlock(&u->readlock);
 
 			timeo = unix_stream_data_wait(sk, timeo, last);
 
 			if (signal_pending(current)
 			    ||  mutex_lock_interruptible(&u->readlock)) {
 				err = sock_intr_errno(timeo);
 				goto out;
 			}
 
 			continue;
  unlock:
 			unix_state_unlock(sk);
 			break;
 		}
 
 		skip = sk_peek_offset(sk, flags);
 		while (skip >= unix_skb_len(skb)) {
 			skip -= unix_skb_len(skb);
 			last = skb;
 			skb = skb_peek_next(skb, &sk->sk_receive_queue);
 			if (!skb)
 				goto again;
 		}
 
 		unix_state_unlock(sk);
 
 		if (check_creds) {
 			 
 			if ((UNIXCB(skb).pid  != siocb->scm->pid) ||
 			    !uid_eq(UNIXCB(skb).uid, siocb->scm->creds.uid) ||
 			    !gid_eq(UNIXCB(skb).gid, siocb->scm->creds.gid))
 				break;
 		} else if (test_bit(SOCK_PASSCRED, &sock->flags)) {
 			 
 			scm_set_cred(siocb->scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid);
 			check_creds = 1;
 		}
 
 		 
 		if (sunaddr) {
 			unix_copy_addr(msg, skb->sk);
 			sunaddr = NULL;
 		}
 
 		chunk = min_t(unsigned int, unix_skb_len(skb) - skip, size);
 		if (skb_copy_datagram_iovec(skb, UNIXCB(skb).consumed + skip,
 					    msg->msg_iov, chunk)) {
 			if (copied == 0)
 				copied = -EFAULT;
 			break;
 		}
 		copied += chunk;
 		size -= chunk;
 
 		 
 		if (!(flags & MSG_PEEK)) {
 			UNIXCB(skb).consumed += chunk;
 
 			sk_peek_offset_bwd(sk, chunk);
 
 			if (UNIXCB(skb).fp)
 				unix_detach_fds(siocb->scm, skb);
 
 			if (unix_skb_len(skb))
 				break;
 
 			skb_unlink(skb, &sk->sk_receive_queue);
 			consume_skb(skb);
 
 			if (siocb->scm->fp)
 				break;
 		} else {
 			 
 			if (UNIXCB(skb).fp)
 				siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);
 
 			sk_peek_offset_fwd(sk, chunk);
 
 			break;
 		}
 	} while (size);
 
 	mutex_unlock(&u->readlock);
 	scm_recv(sock, msg, siocb->scm, flags);
 out:
 	return copied ? : err;
 }",[28],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
201489," jp2_box_t *jp2_box_create(int type)
 jp2_box_t *jp2_box_create0()
  {
  	jp2_box_t *box;
	jp2_boxinfo_t *boxinfo;
  	if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
  		return 0;
  	}
  	memset(box, 0, sizeof(jp2_box_t));
 	box->type = 0;
 	box->len = 0;
 	 
 	 
 	box->ops = &jp2_boxinfo_unk.ops;
 	return box;
 }
 
 jp2_box_t *jp2_box_create(int type)
 {
 	jp2_box_t *box;
 	jp2_boxinfo_t *boxinfo;
 	if (!(box = jp2_box_create0())) {
 		return 0;
 	}
  	box->type = type;
  	box->len = 0;
  	if (!(boxinfo = jp2_boxinfolookup(type))) {
 		return 0;
 	}
 	box->info = boxinfo;
 	box->ops = &boxinfo->ops;
 	return box;
 }","[2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 5]",The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.
205944," void MostVisitedSitesBridge::JavaObserver::OnMostVisitedURLsAvailable(
     const NTPTilesVector& tiles) {
   JNIEnv* env = AttachCurrentThread();
   std::vector<base::string16> titles;
   std::vector<std::string> urls;
   std::vector<std::string> whitelist_icon_paths;
   std::vector<int> sources;
 
   titles.reserve(tiles.size());
   urls.reserve(tiles.size());
   whitelist_icon_paths.reserve(tiles.size());
   sources.reserve(tiles.size());
   for (const auto& tile : tiles) {
     titles.emplace_back(tile.title);
     urls.emplace_back(tile.url.spec());
      whitelist_icon_paths.emplace_back(tile.whitelist_icon_path.value());
      sources.emplace_back(static_cast<int>(tile.source));
    }
  Java_MostVisitedURLsObserver_onMostVisitedURLsAvailable(
   Java_Observer_onMostVisitedURLsAvailable(
        env, observer_, ToJavaArrayOfStrings(env, titles),
        ToJavaArrayOfStrings(env, urls),
        ToJavaArrayOfStrings(env, whitelist_icon_paths),
       ToJavaIntArray(env, sources));
 }","[20, 19]","The VpxVideoDecoder::VpxDecode function in media/filters/vpx_video_decoder.cc in the vpxdecoder implementation in Google Chrome before 41.0.2272.76 does not ensure that alpha-plane dimensions are identical to image dimensions, which allows remote attackers to cause a denial of service (out-of-bounds read) via crafted VPx video data."
7215,"im_vips2dz( IMAGE *in, const char *filename )
{
char *p, *q;
char name[FILENAME_MAX];
char mode[FILENAME_MAX];
char buf[FILENAME_MAX];

int i;
VipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ;
char *suffix = "".jpeg"";
int overlap = 0;
int tile_size = 256;
VipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
gboolean centre = FALSE;
VipsAngle angle = VIPS_ANGLE_D0;







im_strncpy( name, filename, FILENAME_MAX );
if( (p = strchr( name, ':' )) ) {
*p = '\0';
im_strncpy( mode, p + 1, FILENAME_MAX );
}

strcpy( buf, mode );
p = &buf[0];

if( (q = im_getnextoption( &p )) ) {
if( (i = vips_enum_from_nick( ""im_vips2dz"",
VIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 )
return( -1 );
layout = i;
}

if( (q = im_getnextoption( &p )) )
suffix = g_strdup( q );
if( (q = im_getnextoption( &p )) )
overlap = atoi( q );
if( (q = im_getnextoption( &p )) )
tile_size = atoi( q );

if( (q = im_getnextoption( &p )) ) {
if( (i = vips_enum_from_nick( ""im_vips2dz"",
VIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )
return( -1 );
depth = i;
}

if( (q = im_getnextoption( &p )) ) {
if( im_isprefix( ""cen"", q ) )
centre = TRUE;
}

if( (q = im_getnextoption( &p )) ) {
if( (i = vips_enum_from_nick( ""im_vips2dz"",
VIPS_TYPE_ANGLE, q )) < 0 )
return( -1 );
angle = i;
}

if( vips_dzsave( in, name,
""layout"", layout,
""suffix"", suffix,
""overlap"", overlap,
""tile_size"", tile_size,
""depth"", depth,
""centre"", centre,
""angle"", angle,
NULL ) )
return( -1 );

return( 0 );
}",[29],im_vips2dz in /libvips/libvips/deprecated/im_vips2dz.c in libvips before 8.8.2 has an uninitialized variable which may cause the leakage of remote server path or stack address.
203310,"  static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)
  {
    FILE *fp = fopen(dest_filename, ""w"");
     FILE *fp = fopen(dest_filename, ""wx"");
      if (!fp)
          return false;
  
     unsigned fd = 0;
     while (fd <= 99999)  
     {
         sprintf(source_filename + source_base_ofs, ""fd/%u"", fd);
         char *name = malloc_readlink(source_filename);
         if (!name)
             break;
         fprintf(fp, ""%u:%s\n"", fd, name);
         free(name);
 
         sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd);
         fd++;
         FILE *in = fopen(source_filename, ""r"");
         if (!in)
             continue;
         char buf[128];
         while (fgets(buf, sizeof(buf)-1, in))
         {
              
             char *eol = strchrnul(buf, '\n');
             eol[0] = '\n';
             eol[1] = '\0';
             fputs(buf, fp);
         }
         fclose(in);
     }
 
     const int dest_fd = fileno(fp);
     if (fchown(dest_fd, uid, gid) < 0)
     {
         perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid);
         fclose(fp);
         unlink(dest_filename);
         return false;
     }
 
     fclose(fp);
     return true;
 }","[4, 3]","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
9317,"TEST_F(ListenerManagerImplQuicOnlyTest, QuicListenerFactoryAndSslContext) {
const std::string yaml = TestEnvironment::substitute(R""EOF(
address:
  socket_address:
    address: 127.0.0.1
    protocol: UDP
    port_value: 1234
filter_chains:
- filter_chain_match:
    transport_protocol: ""quic""
  filters:
  - name: envoy.filters.network.http_connection_manager
    typed_config:
      ""@type"": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
      codec_type: HTTP3
      stat_prefix: hcm
      route_config:
        name: local_route
      http_filters:
        - name: envoy.filters.http.router
  transport_socket:
    name: envoy.transport_sockets.quic
    typed_config:
      ""@type"": type.googleapis.com/envoy.extensions.transport_sockets.quic.v3.QuicDownstreamTransport
      downstream_tls_context:
        common_tls_context:
          tls_certificates:
          - certificate_chain:
              filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem""
            private_key:
              filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem""
          validation_context:
            trusted_ca:
              filename: ""{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem""
            match_subject_alt_names:
            - exact: localhost
            - exact: 127.0.0.1
udp_listener_config:
  quic_options: {}
  )EOF"",
Network::Address::IpVersion::v4);

envoy::config::listener::v3::Listener listener_proto = parseListenerFromV3Yaml(yaml);
ON_CALL(udp_gso_syscall_, supportsUdpGso())
.WillByDefault(Return(os_sys_calls_actual_.supportsUdpGso()));
EXPECT_CALL(server_.api_.random_, uuid());
expectCreateListenSocket(envoy::config::core::v3::SocketOption::STATE_PREBIND,
#ifdef SO_RXQ_OVFL  SO_REUSEPORT is on as configured

Api::OsSysCallsSingleton::get().supportsUdpGro() ? 4 : 3,
#else

Api::OsSysCallsSingleton::get().supportsUdpGro() ? 3 : 2,
#endif
ListenerComponentFactory::BindType::ReusePort);

expectSetsockopt(                             IPPROTO_IP,
ENVOY_IP_PKTINFO,
1,
1);
#ifdef SO_RXQ_OVFL
expectSetsockopt(                             SOL_SOCKET,
SO_RXQ_OVFL,
1,
1);
#endif
expectSetsockopt(                             SOL_SOCKET,
SO_REUSEPORT,
1,
1);
#ifdef UDP_GRO
if (Api::OsSysCallsSingleton::get().supportsUdpGro()) {
expectSetsockopt(                             SOL_UDP,
UDP_GRO,
1,
1);
}
#endif

manager_->addOrUpdateListener(listener_proto, """", true);
EXPECT_EQ(1u, manager_->listeners().size());
EXPECT_FALSE(manager_->listeners()[0]
.get()
.udpListenerConfig()
->listenerFactory()
.isTransportConnectionless());
Network::SocketSharedPtr listen_socket =
manager_->listeners().front().get().listenSocketFactory().getListenSocket(0);

Network::UdpPacketWriterPtr udp_packet_writer =
manager_->listeners()
.front()
.get()
.udpListenerConfig()
->packetWriterFactory()
.createUdpPacketWriter(listen_socket->ioHandle(),
manager_->listeners()[0].get().listenerScope());
EXPECT_EQ(udp_packet_writer->isBatchMode(), Api::OsSysCallsSingleton::get().supportsUdpGso());


EXPECT_EQ(nullptr, findFilterChain(1234, ""127.0.0.1"", """", ""tls"", {}, ""8.8.8.8"", 111));

auto filter_chain = findFilterChain(1234, ""127.0.0.1"", """", ""quic"", {}, ""8.8.8.8"", 111);
ASSERT_NE(nullptr, filter_chain);
auto& quic_socket_factory = dynamic_cast<const Quic::QuicServerTransportSocketFactory&>(
filter_chain->transportSocketFactory());
EXPECT_TRUE(quic_socket_factory.implementsSecureTransport());
EXPECT_FALSE(quic_socket_factory.getTlsCertificates().empty());
}","[35, 36, 37]","Envoy is an open source edge and service proxy, designed for cloud-native applications. The default_validator.cc implementation used to implement the default certificate validation routines has a ""type confusion"" bug when processing subjectAltNames. This processing allows, for example, an rfc822Name or uniformResourceIndicator to be authenticated as a domain name. This confusion allows for the bypassing of nameConstraints, as processed by the underlying OpenSSL/BoringSSL implementation, exposing the possibility of impersonation of arbitrary servers. As a result Envoy will trust upstream certificates that should not be trusted."
200657," static long ext4_zero_range(struct file *file, loff_t offset,
 			    loff_t len, int mode)
 {
 	struct inode *inode = file_inode(file);
 	handle_t *handle = NULL;
 	unsigned int max_blocks;
 	loff_t new_size = 0;
 	int ret = 0;
 	int flags;
 	int credits;
  	int partial_begin, partial_end;
  	loff_t start, end;
  	ext4_lblk_t lblk;
	struct address_space *mapping = inode->i_mapping;
  	unsigned int blkbits = inode->i_blkbits;
  
  	trace_ext4_zero_range(inode, offset, len, mode);
 
 	if (!S_ISREG(inode->i_mode))
 		return -EINVAL;
 
 	 
 	if (ext4_should_journal_data(inode)) {
 		ret = ext4_force_commit(inode->i_sb);
 		if (ret)
  			return ret;
  	}
  
	 
	if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
		ret = filemap_write_and_wait_range(mapping, offset,
						   offset + len - 1);
		if (ret)
			return ret;
	}
  	 
 	start = round_up(offset, 1 << blkbits);
 	end = round_down((offset + len), 1 << blkbits);
 
 	if (start < offset || end > offset + len)
 		return -EINVAL;
 	partial_begin = offset & ((1 << blkbits) - 1);
 	partial_end = (offset + len) & ((1 << blkbits) - 1);
 
 	lblk = start >> blkbits;
 	max_blocks = (end >> blkbits);
 	if (max_blocks < lblk)
 		max_blocks = 0;
 	else
 		max_blocks -= lblk;
 
 	mutex_lock(&inode->i_mutex);
 
 	 
 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 		ret = -EOPNOTSUPP;
 		goto out_mutex;
 	}
 
 	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
 	     offset + len > i_size_read(inode)) {
 		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
 	}
 
 	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
 	if (mode & FALLOC_FL_KEEP_SIZE)
 		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
 
 	 
 	if (partial_begin || partial_end) {
 		ret = ext4_alloc_file_blocks(file,
 				round_down(offset, 1 << blkbits) >> blkbits,
 				(round_up((offset + len), 1 << blkbits) -
 				 round_down(offset, 1 << blkbits)) >> blkbits,
 				new_size, flags, mode);
 		if (ret)
 			goto out_mutex;
 
 	}
 
 	 
 	if (max_blocks > 0) {
  		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
  			  EXT4_EX_NOCACHE);
  
		 
		truncate_pagecache_range(inode, start, end - 1);
		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
  		 
  		ext4_inode_block_unlocked_dio(inode);
  		inode_dio_wait(inode);
  
 		 
 		down_write(&EXT4_I(inode)->i_mmap_sem);
 		 
 		truncate_pagecache_range(inode, start, end - 1);
 		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
 
  		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
  					     flags, mode);
 		up_write(&EXT4_I(inode)->i_mmap_sem);
  		if (ret)
  			goto out_dio;
  	}
 	if (!partial_begin && !partial_end)
 		goto out_dio;
 
 	 
 	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
 	if (ext4_should_journal_data(inode))
 		credits += 2;
 	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
 		ext4_std_error(inode->i_sb, ret);
 		goto out_dio;
 	}
 
 	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
 	if (new_size) {
 		ext4_update_inode_size(inode, new_size);
 	} else {
 		 
 		if ((offset + len) > i_size_read(inode))
 			ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
 	}
 	ext4_mark_inode_dirty(handle, inode);
 
 	 
 	ret = ext4_zero_partial_blocks(handle, inode, offset, len);
 
 	if (file->f_flags & O_SYNC)
 		ext4_handle_sync(handle);
 
 	ext4_journal_stop(handle);
 out_dio:
 	ext4_inode_resume_unlocked_dio(inode);
 out_mutex:
 	mutex_unlock(&inode->i_mutex);
 	return ret;
 }","[96, 97, 98, 99, 100, 101, 104, 14, 29, 30, 31, 32, 33, 34, 35, 89, 90, 91]",Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.
201839," static void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)
 {
 	st_entry ent;
 	wddx_stack *stack = (wddx_stack *)user_data;
 
 	if (!strcmp(name, EL_PACKET)) {
 		int i;
 
 		if (atts) for (i=0; atts[i]; i++) {
 			if (!strcmp(atts[i], EL_VERSION)) {
 				 
 			}
 		}
 	} else if (!strcmp(name, EL_STRING)) {
 		ent.type = ST_STRING;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		INIT_PZVAL(ent.data);
 		Z_TYPE_P(ent.data) = IS_STRING;
 		Z_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();
 		Z_STRLEN_P(ent.data) = 0;
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_BINARY)) {
 		ent.type = ST_BINARY;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		INIT_PZVAL(ent.data);
 		Z_TYPE_P(ent.data) = IS_STRING;
 		Z_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();
 		Z_STRLEN_P(ent.data) = 0;
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_CHAR)) {
 		int i;
 
 		if (atts) for (i = 0; atts[i]; i++) {
 			if (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {
 				char tmp_buf[2];
 
 				snprintf(tmp_buf, sizeof(tmp_buf), ""%c"", (char)strtol(atts[i+1], NULL, 16));
 				php_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));
 				break;
 			}
 		}
 	} else if (!strcmp(name, EL_NUMBER)) {
 		ent.type = ST_NUMBER;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		INIT_PZVAL(ent.data);
 		Z_TYPE_P(ent.data) = IS_LONG;
 		Z_LVAL_P(ent.data) = 0;
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_BOOLEAN)) {
 		int i;
 
 		if (atts) for (i = 0; atts[i]; i++) {
 			if (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {
 				ent.type = ST_BOOLEAN;
 				SET_STACK_VARNAME;
 
 				ALLOC_ZVAL(ent.data);
 				INIT_PZVAL(ent.data);
 				Z_TYPE_P(ent.data) = IS_BOOL;
 				wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
  				php_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));
  				break;
  			}
 		} else {
 			ent.type = ST_BOOLEAN;
 			SET_STACK_VARNAME;
 			ZVAL_FALSE(&ent.data);
 			wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
  		}
  	} else if (!strcmp(name, EL_NULL)) {
  		ent.type = ST_NULL;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		INIT_PZVAL(ent.data);
 		ZVAL_NULL(ent.data);
 
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_ARRAY)) {
 		ent.type = ST_ARRAY;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		array_init(ent.data);
 		INIT_PZVAL(ent.data);
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_STRUCT)) {
 		ent.type = ST_STRUCT;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		array_init(ent.data);
 		INIT_PZVAL(ent.data);
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_VAR)) {
 		int i;
 
 		if (atts) for (i = 0; atts[i]; i++) {
 			if (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {
 				if (stack->varname) efree(stack->varname);
 				stack->varname = estrdup(atts[i+1]);
 				break;
 			}
 		}
 	} else if (!strcmp(name, EL_RECORDSET)) {
 		int i;
 
 		ent.type = ST_RECORDSET;
 		SET_STACK_VARNAME;
 		MAKE_STD_ZVAL(ent.data);
 		array_init(ent.data);
 
 		if (atts) for (i = 0; atts[i]; i++) {
 			if (!strcmp(atts[i], ""fieldNames"") && atts[i+1] && atts[i+1][0]) {
 				zval *tmp;
 				char *key;
 				char *p1, *p2, *endp;
 
 				i++;
 				endp = (char *)atts[i] + strlen(atts[i]);
 				p1 = (char *)atts[i];
 				while ((p2 = php_memnstr(p1, "","", sizeof("","")-1, endp)) != NULL) {
 					key = estrndup(p1, p2 - p1);
 					MAKE_STD_ZVAL(tmp);
 					array_init(tmp);
 					add_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);
 					p1 = p2 + sizeof("","")-1;
 					efree(key);
 				}
 
 				if (p1 <= endp) {
 					MAKE_STD_ZVAL(tmp);
 					array_init(tmp);
 					add_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);
 				}
 
 				break;
 			}
 		}
 
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_FIELD)) {
 		int i;
 		st_entry ent;
 
 		ent.type = ST_FIELD;
 		ent.varname = NULL;
 		ent.data = NULL;
 
 		if (atts) for (i = 0; atts[i]; i++) {
 			if (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {
 				st_entry *recordset;
 				zval **field;
 
 				if (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&
 					recordset->type == ST_RECORDSET &&
 					zend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {
 					ent.data = *field;
 				}
 
 				break;
 			}
 		}
 
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	} else if (!strcmp(name, EL_DATETIME)) {
 		ent.type = ST_DATETIME;
 		SET_STACK_VARNAME;
 
 		ALLOC_ZVAL(ent.data);
 		INIT_PZVAL(ent.data);
 		Z_TYPE_P(ent.data) = IS_LONG;
 		wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));
 	}
 }","[70, 71, 72, 73, 74]",The php_wddx_push_element function in ext/wddx/wddx.c in PHP before 5.6.29 and 7.x before 7.0.14 allows remote attackers to cause a denial of service (out-of-bounds read and memory corruption) or possibly have unspecified other impact via an empty boolean element in a wddxPacket XML document.
8275,"void Compute(OpKernelContext *ctx) override {
const Tensor *indices_t, *values_t, *shape_t, *reduction_axes_t;
OP_REQUIRES_OK(ctx, ctx->input(""input_indices"", &indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""input_values"", &values_t));
OP_REQUIRES_OK(ctx, ctx->input(""input_shape"", &shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""reduction_axes"", &reduction_axes_t));

OP_REQUIRES_OK(ctx, ValidateInputs(shape_t, reduction_axes_t));






const auto shape_vec = shape_t->vec<int64>();
SparseTensor sp;
OP_REQUIRES_OK(ctx, SparseTensor::Create(
tensor::DeepCopy(*indices_t), tensor::DeepCopy(*values_t),
TensorShape(shape_vec), &sp));
ReduceDetails reduction = SparseTensorReduceHelper(
sp, reduction_axes_t->flat<int32>(), keep_dims_);

Tensor *out_values;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, reduction.reduced_shape, &out_values));
auto out_flat = out_values->flat<T>();
out_flat.setZero();

Tensor tmp_reduced_val;
OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::value,
TensorShape({}), &tmp_reduced_val));
auto reduced_val = tmp_reduced_val.scalar<T>();



gtl::InlinedVector<int64, 8> output_strides(reduction.group_by_dims.size());
if (!output_strides.empty()) {
output_strides.back() = 1;
for (int d = output_strides.size() - 2; d >= 0; --d) {
output_strides[d] =
output_strides[d + 1] * shape_vec(reduction.group_by_dims[d + 1]);
}
}

auto CoordinatesToFlatIndex = [](ArraySlice<int64> coords,
ArraySlice<int64> strides) -> int64 {
if (strides.empty()) {
return 0;
}
CHECK_EQ(coords.size(), strides.size());
int64_t idx = 0;
for (int i = 0; i < coords.size(); ++i) {
idx += coords[i] * strides[i];
}
return idx;
};



sp.Reorder<T>(reduction.reorder_dims);
for (const auto &g : sp.group(reduction.group_by_dims)) {
Op::template Run<T>(ctx, reduced_val, g.template values<T>());
const int64_t idx = CoordinatesToFlatIndex(g.group(), output_strides);
out_flat(idx) = reduced_val();
VLOG(2) << ""coords: "" << absl::StrJoin(g.group(), "","")
<< ""; idx: "" << idx << ""; group "" << Op::Name() << "": ""
<< reduced_val();
}
}","[63, 64]","TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of sparse reduction operations in TensorFlow can trigger accesses outside of bounds of heap allocated data. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_reduce_op.cc#L217-L228) fails to validate that each reduction group does not overflow and that each corresponding index does not point to outside the bounds of the input tensor. We have patched the issue in GitHub commit 87158f43f05f2720a374f3e6d22a7aaa3a33f750. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
199680," static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
 		      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;
 	size_t copied;
 	struct sk_buff *skb;
 	int er;
 
 	 
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_ESTABLISHED) {
 		release_sock(sk);
 		return -ENOTCONN;
 	}
 
 	 
 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
 		release_sock(sk);
 		return er;
 	}
 
 	skb_reset_transport_header(skb);
 	copied     = skb->len;
 
 	if (copied > size) {
 		copied = size;
 		msg->msg_flags |= MSG_TRUNC;
 	}
 
 	er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (er < 0) {
 		skb_free_datagram(sk, skb);
 		release_sock(sk);
 		return er;
 	}
 
 	if (sax != NULL) {
 		memset(sax, 0, sizeof(*sax));
  		sax->sax25_family = AF_NETROM;
  		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,
  			      AX25_ADDR_LEN);
 		msg->msg_namelen = sizeof(*sax);
  	}
  
	msg->msg_namelen = sizeof(*sax);
  	skb_free_datagram(sk, skb);
  
  	release_sock(sk);
 	return copied;
 }","[44, 47]","The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
202172," xfs_attr_shortform_addname(xfs_da_args_t *args)
 {
 	int newsize, forkoff, retval;
 
 	trace_xfs_attr_sf_addname(args);
 
 	retval = xfs_attr_shortform_lookup(args);
 	if ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {
 		return retval;
 	} else if (retval == -EEXIST) {
  		if (args->flags & ATTR_CREATE)
  			return retval;
  		retval = xfs_attr_shortform_remove(args);
		ASSERT(retval == 0);
 		if (retval)
 			return retval;
 		 
 		args->flags &= ~ATTR_REPLACE;
  	}
  
  	if (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||
 	    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)
 		return -ENOSPC;
 
 	newsize = XFS_ATTR_SF_TOTSIZE(args->dp);
 	newsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);
 
 	forkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);
 	if (!forkoff)
 		return -ENOSPC;
 
 	xfs_attr_shortform_add(args, forkoff);
 	return 0;
 }","[15, 16, 17, 18, 14]","In the Linux kernel before 4.17, a local attacker able to set attributes on an xfs filesystem could make this filesystem non-operational until the next mount by triggering an unchecked error condition during an xfs attribute change, because xfs_attr_shortform_addname in fs/xfs/libxfs/xfs_attr.c mishandles ATTR_REPLACE operations with conversion of an attr from short to long form."
201680," int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)
 {
     register struct entropy_data *c = wps->w.c + chan;
     uint32_t ones_count, low, mid, high;
     int32_t value;
     int sign;
 
     if (!wps->wvbits.ptr)
         return WORD_EOF;
 
     if (correction)
         *correction = 0;
 
     if (!(wps->w.c [0].median [0] & ~1) && !wps->w.holding_zero && !wps->w.holding_one && !(wps->w.c [1].median [0] & ~1)) {
         uint32_t mask;
         int cbits;
 
         if (wps->w.zeros_acc) {
             if (--wps->w.zeros_acc) {
                 c->slow_level -= (c->slow_level + SLO) >> SLS;
                 return 0;
             }
         }
         else {
             for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);
 
             if (cbits == 33)
                 return WORD_EOF;
 
             if (cbits < 2)
                 wps->w.zeros_acc = cbits;
             else {
                 for (mask = 1, wps->w.zeros_acc = 0; --cbits; mask <<= 1)
                     if (getbit (&wps->wvbits))
                         wps->w.zeros_acc |= mask;
 
                 wps->w.zeros_acc |= mask;
             }
 
             if (wps->w.zeros_acc) {
                 c->slow_level -= (c->slow_level + SLO) >> SLS;
                 CLEAR (wps->w.c [0].median);
                 CLEAR (wps->w.c [1].median);
                 return 0;
             }
         }
     }
 
     if (wps->w.holding_zero)
         ones_count = wps->w.holding_zero = 0;
     else {
 #ifdef USE_CTZ_OPTIMIZATION
         while (wps->wvbits.bc < LIMIT_ONES) {
             if (++(wps->wvbits.ptr) == wps->wvbits.end)
                 wps->wvbits.wrap (&wps->wvbits);
 
             wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc;
             wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;
         }
 
 #ifdef _WIN32
         _BitScanForward (&ones_count, ~wps->wvbits.sr);
 #else
         ones_count = __builtin_ctz (~wps->wvbits.sr);
 #endif
 
         if (ones_count >= LIMIT_ONES) {
             wps->wvbits.bc -= ones_count;
             wps->wvbits.sr >>= ones_count;
 
             for (; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);
 
             if (ones_count == (LIMIT_ONES + 1))
                 return WORD_EOF;
 
             if (ones_count == LIMIT_ONES) {
                 uint32_t mask;
                 int cbits;
 
                 for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);
 
                 if (cbits == 33)
                     return WORD_EOF;
 
                 if (cbits < 2)
                     ones_count = cbits;
                 else {
                     for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                         if (getbit (&wps->wvbits))
                             ones_count |= mask;
 
                     ones_count |= mask;
                 }
 
                 ones_count += LIMIT_ONES;
             }
         }
         else {
             wps->wvbits.bc -= ones_count + 1;
             wps->wvbits.sr >>= ones_count + 1;
         }
 #elif defined (USE_NEXT8_OPTIMIZATION)
         int next8;
 
         if (wps->wvbits.bc < 8) {
             if (++(wps->wvbits.ptr) == wps->wvbits.end)
                 wps->wvbits.wrap (&wps->wvbits);
 
             next8 = (wps->wvbits.sr |= *(wps->wvbits.ptr) << wps->wvbits.bc) & 0xff;
             wps->wvbits.bc += sizeof (*(wps->wvbits.ptr)) * 8;
         }
         else
             next8 = wps->wvbits.sr & 0xff;
 
         if (next8 == 0xff) {
             wps->wvbits.bc -= 8;
             wps->wvbits.sr >>= 8;
 
             for (ones_count = 8; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);
 
             if (ones_count == (LIMIT_ONES + 1))
                 return WORD_EOF;
 
             if (ones_count == LIMIT_ONES) {
                 uint32_t mask;
                 int cbits;
 
                 for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);
 
                 if (cbits == 33)
                     return WORD_EOF;
 
                 if (cbits < 2)
                     ones_count = cbits;
                 else {
                     for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                         if (getbit (&wps->wvbits))
                             ones_count |= mask;
 
                     ones_count |= mask;
                 }
 
                 ones_count += LIMIT_ONES;
             }
         }
         else {
             wps->wvbits.bc -= (ones_count = ones_count_table [next8]) + 1;
             wps->wvbits.sr >>= ones_count + 1;
         }
 #else
         for (ones_count = 0; ones_count < (LIMIT_ONES + 1) && getbit (&wps->wvbits); ++ones_count);
 
         if (ones_count >= LIMIT_ONES) {
             uint32_t mask;
             int cbits;
 
             if (ones_count == (LIMIT_ONES + 1))
                 return WORD_EOF;
 
             for (cbits = 0; cbits < 33 && getbit (&wps->wvbits); ++cbits);
 
             if (cbits == 33)
                 return WORD_EOF;
 
             if (cbits < 2)
                 ones_count = cbits;
             else {
                 for (mask = 1, ones_count = 0; --cbits; mask <<= 1)
                     if (getbit (&wps->wvbits))
                         ones_count |= mask;
 
                 ones_count |= mask;
             }
 
             ones_count += LIMIT_ONES;
         }
 #endif
 
         if (wps->w.holding_one) {
             wps->w.holding_one = ones_count & 1;
             ones_count = (ones_count >> 1) + 1;
         }
         else {
             wps->w.holding_one = ones_count & 1;
             ones_count >>= 1;
         }
 
         wps->w.holding_zero = ~wps->w.holding_one & 1;
     }
 
     if ((wps->wphdr.flags & HYBRID_FLAG) && !chan)
         update_error_limit (wps);
 
     if (ones_count == 0) {
         low = 0;
         high = GET_MED (0) - 1;
         DEC_MED0 ();
     }
     else {
         low = GET_MED (0);
         INC_MED0 ();
 
         if (ones_count == 1) {
             high = low + GET_MED (1) - 1;
             DEC_MED1 ();
         }
         else {
             low += GET_MED (1);
             INC_MED1 ();
 
             if (ones_count == 2) {
                 high = low + GET_MED (2) - 1;
                 DEC_MED2 ();
             }
             else {
                 low += (ones_count - 2) * GET_MED (2);
                 high = low + GET_MED (2) - 1;
                 INC_MED2 ();
             }
         }
     }
  
      low &= 0x7fffffff;
      high &= 0x7fffffff;
 
     if (low > high)          
         high = low;
 
      mid = (high + low + 1) >> 1;
  
      if (!c->error_limit)
         mid = read_code (&wps->wvbits, high - low) + low;
     else while (high - low > c->error_limit) {
         if (getbit (&wps->wvbits))
             mid = (high + (low = mid) + 1) >> 1;
         else
             mid = ((high = mid - 1) + low + 1) >> 1;
     }
 
     sign = getbit (&wps->wvbits);
 
     if (bs_is_open (&wps->wvcbits) && c->error_limit) {
         value = read_code (&wps->wvcbits, high - low) + low;
 
         if (correction)
             *correction = sign ? (mid - value) : (value - mid);
     }
 
     if (wps->wphdr.flags & HYBRID_BITRATE) {
         c->slow_level -= (c->slow_level + SLO) >> SLS;
         c->slow_level += wp_log2 (mid);
     }
 
     return sign ? ~mid : mid;
 }","[225, 226, 227, 228]",The read_new_config_info function in open_utils.c in Wavpack before 5.1.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted WV file.
206409,"  PageInfoUI::IdentityInfo::IdentityInfo()
      : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
        connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
        show_ssl_decision_revoke_button(false),
        show_change_password_buttons(false) {}",[3],"Cast in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android sent cookies to sites discovered via SSDP, which allowed an attacker on the local network segment to initiate connections to arbitrary URLs and observe any plaintext cookies sent."
197951," static void gx_ttfReader__Read(ttfReader *self, void *p, int n)
 {
     gx_ttfReader *r = (gx_ttfReader *)self;
     const byte *q;
 
      if (!r->error) {
          if (r->extra_glyph_index != -1) {
              q = r->glyph_data.bits.data + r->pos;
            r->error = (r->glyph_data.bits.size - r->pos < n ?
             r->error = ((r->pos >= r->glyph_data.bits.size ||
                         r->glyph_data.bits.size - r->pos < n) ?
                              gs_note_error(gs_error_invalidfont) : 0);
              if (r->error == 0)
                  memcpy(p, q, n);
             unsigned int cnt;
 
             for (cnt = 0; cnt < (uint)n; cnt += r->error) {
                 r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);
                 if (r->error < 0)
                     break;
                 else if ( r->error == 0) {
                     memcpy((char *)p + cnt, q, n - cnt);
                     break;
                 } else {
                     memcpy((char *)p + cnt, q, r->error);
                 }
             }
         }
     }
     if (r->error) {
         memset(p, 0, n);
         return;
     }
     r->pos += n;
 }","[10, 11, 9]",The gx_ttfReader__Read function in base/gxttfb.c in Artifex Ghostscript GhostXPS 9.21 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) or possibly have unspecified other impact via a crafted document.
9179,"int virtualbox_get_guest_property(char *name, void **value, size_t *size) {

errno = 0;


int _cleanup_close_ fd = open(""/dev/vboxguest"", O_RDWR | O_CLOEXEC);
if (fd == -1) {
return VERR_GENERAL_FAILURE;
}


int ret = version_info(fd);
if (ret != VINF_SUCCESS) {
return ret;
}


uint32_t client_id;
ret = connect(fd, &client_id);
if (ret != VINF_SUCCESS) {
return ret;
}


ret = get_prop(fd, client_id, name, value, size);
if (ret != VINF_SUCCESS) {
disconnect(fd, client_id);
return ret;
}


ret = disconnect(fd, client_id);
if (ret != VINF_SUCCESS) {


free(*value);
*value = NULL;
return ret;
}


errno = 0;
return 0;
}","[18, 19, 25]",A vulnerability was found in Ignition where ignition configs are accessible from unprivileged containers in VMs running on VMware products. This issue is only relevant in user environments where the Ignition config contains secrets. The highest threat from this vulnerability is to data confidentiality. Possible workaround is to not put secrets in the Ignition config.
207572," sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)
 {
     ALOGV(""getFrameAtTime: time(%lld us) option(%d)"", timeUs, option);
  Mutex::Autolock lock(mLock);
  Mutex::Autolock glock(sLock);
     mThumbnail.clear();
  if (mRetriever == NULL) {
         ALOGE(""retriever is not initialized"");
  return NULL;
  }
  VideoFrame *frame = mRetriever->getFrameAtTime(timeUs, option);
  if (frame == NULL) {
         ALOGE(""failed to capture a video frame"");
  return NULL;
  }
  size_t size = sizeof(VideoFrame) + frame->mSize;
     sp<MemoryHeapBase> heap = new MemoryHeapBase(size, 0, ""MetadataRetrieverClient"");
  if (heap == NULL) {
         ALOGE(""failed to create MemoryDealer"");
  delete frame;
  return NULL;
  }
     mThumbnail = new MemoryBase(heap, 0, size);
  if (mThumbnail == NULL) {
         ALOGE(""not enough memory for VideoFrame size=%u"", size);
  delete frame;
  return NULL;
  }
  VideoFrame *frameCopy = static_cast<VideoFrame *>(mThumbnail->pointer());
     frameCopy->mWidth = frame->mWidth;
     frameCopy->mHeight = frame->mHeight;
     frameCopy->mDisplayWidth = frame->mDisplayWidth;
     frameCopy->mDisplayHeight = frame->mDisplayHeight;
     frameCopy->mSize = frame->mSize;
     frameCopy->mRotationAngle = frame->mRotationAngle;
 
      ALOGV(""rotation: %d"", frameCopy->mRotationAngle);
      frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);
      memcpy(frameCopy->mData, frame->mData, frame->mSize);
     frameCopy->mData = 0;
      delete frame;   
      return mThumbnail;
  }",[40],"media/libmediaplayerservice/MetadataRetrieverClient.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to obtain sensitive pointer information via a crafted application, aka internal bug 28377502."
207075," void MediaStreamDispatcherHost::BindRequest(
 void MediaStreamDispatcherHost::Create(
     int render_process_id,
     int render_frame_id,
     MediaStreamManager* media_stream_manager,
      mojom::MediaStreamDispatcherHostRequest request) {
    DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bindings_.AddBinding(this, std::move(request));
   mojo::MakeStrongBinding(
       std::make_unique<MediaStreamDispatcherHost>(
           render_process_id, render_frame_id, media_stream_manager),
       std::move(request));
  }","[2, 3, 4, 5, 9, 10, 11, 12, 8]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
5543,"MG_INTERNAL int parse_mqtt(struct mbuf *io, struct mg_mqtt_message *mm) {
uint8_t header;
size_t len = 0, len_len = 0;
const char *p, *end;
unsigned char lc = 0;
int cmd;

if (io->len < 2) return MG_MQTT_ERROR_INCOMPLETE_MSG;
header = io->buf[0];
cmd = header >> 4;


len = len_len = 0;
p = io->buf + 1;
while ((size_t)(p - io->buf) < io->len) {
lc = *((const unsigned char *) p++);
len += (lc & 0x7f) << 7 * len_len;
len_len++;
if (!(lc & 0x80)) break;
if (len_len > 4) return MG_MQTT_ERROR_MALFORMED_MSG;
}

end = p + len;
if (lc & 0x80 || len > (io->len - (p - io->buf))) {
return MG_MQTT_ERROR_INCOMPLETE_MSG;
}

mm->cmd = cmd;
mm->qos = MG_MQTT_GET_QOS(header);

switch (cmd) {
case MG_MQTT_CMD_CONNECT: {
p = scanto(p, &mm->protocol_name);
if (p > end - 4) return MG_MQTT_ERROR_MALFORMED_MSG;
mm->protocol_version = *(uint8_t *) p++;
mm->connect_flags = *(uint8_t *) p++;
mm->keep_alive_timer = getu16(p);
p += 2;
if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;
p = scanto(p, &mm->client_id);
if (p > end) return MG_MQTT_ERROR_MALFORMED_MSG;
if (mm->connect_flags & MG_MQTT_HAS_WILL) {
if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;
p = scanto(p, &mm->will_topic);
}
if (mm->connect_flags & MG_MQTT_HAS_WILL) {
if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;
p = scanto(p, &mm->will_message);
}
if (mm->connect_flags & MG_MQTT_HAS_USER_NAME) {
if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;
p = scanto(p, &mm->user_name);
}
if (mm->connect_flags & MG_MQTT_HAS_PASSWORD) {
if (p >= end) return MG_MQTT_ERROR_MALFORMED_MSG;
p = scanto(p, &mm->password);
}
if (p != end) return MG_MQTT_ERROR_MALFORMED_MSG;

LOG(LL_DEBUG,
(""%d %2x %d proto [%.*s] client_id [%.*s] will_topic [%.*s] ""
""will_msg [%.*s] user_name [%.*s] password [%.*s]"",
(int) len, (int) mm->connect_flags, (int) mm->keep_alive_timer,
(int) mm->protocol_name.len, mm->protocol_name.p,
(int) mm->client_id.len, mm->client_id.p, (int) mm->will_topic.len,
mm->will_topic.p, (int) mm->will_message.len, mm->will_message.p,
(int) mm->user_name.len, mm->user_name.p, (int) mm->password.len,
mm->password.p));
break;
}
case MG_MQTT_CMD_CONNACK:
if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;
mm->connack_ret_code = p[1];
break;
case MG_MQTT_CMD_PUBACK:
case MG_MQTT_CMD_PUBREC:
case MG_MQTT_CMD_PUBREL:
case MG_MQTT_CMD_PUBCOMP:
case MG_MQTT_CMD_SUBACK:
mm->message_id = getu16(p);
break;
case MG_MQTT_CMD_PUBLISH: {
p = scanto(p, &mm->topic);
if (p > end) return MG_MQTT_ERROR_MALFORMED_MSG;
if (mm->qos > 0) {
if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;
mm->message_id = getu16(p);
p += 2;
}
mm->payload.p = p;
mm->payload.len = end - p;
break;
}
case MG_MQTT_CMD_SUBSCRIBE:
if (end - p < 2) return MG_MQTT_ERROR_MALFORMED_MSG;
mm->message_id = getu16(p);
p += 2;




mm->payload.p = p;
mm->payload.len = end - p;
break;
default:

break;
}

mm->len = end - io->buf;
return mm->len;
}","[4, 15, 24, 25, 80, 81]",An issue was discovered in Mongoose before 6.15. The parse_mqtt() function in mg_mqtt.c has a critical heap-based buffer overflow.
199398,"  int hugepage_madvise(struct vm_area_struct *vma,
  		     unsigned long *vm_flags, int advice)
  {
 	switch (advice) {
 	case MADV_HUGEPAGE:
  		 
		if (*vm_flags & (VM_HUGEPAGE |
				 VM_SHARED   | VM_MAYSHARE   |
				 VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |
				 VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |
				 VM_MIXEDMAP | VM_SAO))
 		if (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))
  			return -EINVAL;
  		*vm_flags &= ~VM_NOHUGEPAGE;
  		*vm_flags |= VM_HUGEPAGE;
 		 
 		if (unlikely(khugepaged_enter_vma_merge(vma)))
 			return -ENOMEM;
 		break;
 	case MADV_NOHUGEPAGE:
  		 
		if (*vm_flags & (VM_NOHUGEPAGE |
				 VM_SHARED   | VM_MAYSHARE   |
				 VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |
				 VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |
				 VM_MIXEDMAP | VM_SAO))
 		if (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))
  			return -EINVAL;
  		*vm_flags &= ~VM_HUGEPAGE;
  		*vm_flags |= VM_NOHUGEPAGE;
 		 
 		break;
 	}
 
 	return 0;
 }","[12, 27, 7, 8, 9, 10, 11, 22, 23, 24, 25, 26]","The Linux kernel before 2.6.39 does not properly create transparent huge pages in response to a MAP_PRIVATE mmap system call on /dev/zero, which allows local users to cause a denial of service (system crash) via a crafted application."
204668," xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
 		      int what, xmlChar end, xmlChar  end2, xmlChar end3) {
     xmlChar *buffer = NULL;
     int buffer_size = 0;
 
     xmlChar *current = NULL;
     xmlChar *rep = NULL;
     const xmlChar *last;
     xmlEntityPtr ent;
     int c,l;
     int nbchars = 0;
 
     if ((ctxt == NULL) || (str == NULL) || (len < 0))
 	return(NULL);
     last = str + len;
 
     if (((ctxt->depth > 40) &&
          ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
 	(ctxt->depth > 1024)) {
 	xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
 	return(NULL);
     }
 
      
     buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
     buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));
     if (buffer == NULL) goto mem_error;
 
      
     if (str < last)
 	c = CUR_SCHAR(str, l);
     else
         c = 0;
     while ((c != 0) && (c != end) &&  
 	   (c != end2) && (c != end3)) {
 
 	if (c == 0) break;
         if ((c == '&') && (str[1] == '#')) {
 	    int val = xmlParseStringCharRef(ctxt, &str);
 	    if (val != 0) {
 		COPY_BUF(0,buffer,nbchars,val);
 	    }
 	    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
 	        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 	    }
 	} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {
 	    if (xmlParserDebugEntities)
 		xmlGenericError(xmlGenericErrorContext,
 			""String decoding Entity Reference: %.30s\n"",
 			str);
 	    ent = xmlParseStringEntityRef(ctxt, &str);
 	    if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
 	        (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
 	        goto int_error;
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked;
 	    if ((ent != NULL) &&
 		(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 		if (ent->content != NULL) {
 		    COPY_BUF(0,buffer,nbchars,ent->content[0]);
 		    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
 			growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 		    }
 		} else {
 		    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
 			    ""predefined entity has no content\n"");
 		}
 	    } else if ((ent != NULL) && (ent->content != NULL)) {
 		ctxt->depth++;
 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,
 			                      0, 0, 0);
 		ctxt->depth--;
 
 		if (rep != NULL) {
 		    current = rep;
 		    while (*current != 0) {  
 			buffer[nbchars++] = *current++;
 			if (nbchars >
 		            buffer_size - XML_PARSER_BUFFER_SIZE) {
 			    if (xmlParserEntityCheck(ctxt, nbchars, ent))
 				goto int_error;
 			    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 			}
 		    }
 		    xmlFree(rep);
 		    rep = NULL;
 		}
 	    } else if (ent != NULL) {
 		int i = xmlStrlen(ent->name);
 		const xmlChar *cur = ent->name;
  
  		buffer[nbchars++] = '&';
  		if (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {
		    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 		    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);
  		}
  		for (;i > 0;i--)
  		    buffer[nbchars++] = *cur++;
 		buffer[nbchars++] = ';';
 	    }
 	} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {
 	    if (xmlParserDebugEntities)
 		xmlGenericError(xmlGenericErrorContext,
 			""String decoding PE Reference: %.30s\n"", str);
 	    ent = xmlParseStringPEReference(ctxt, &str);
 	    if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
 	        goto int_error;
 	    if (ent != NULL)
 	        ctxt->nbentities += ent->checked;
 	    if (ent != NULL) {
                 if (ent->content == NULL) {
 		    xmlLoadEntityContent(ctxt, ent);
 		}
 		ctxt->depth++;
 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,
 			                      0, 0, 0);
 		ctxt->depth--;
 		if (rep != NULL) {
 		    current = rep;
 		    while (*current != 0) {  
 			buffer[nbchars++] = *current++;
 			if (nbchars >
 		            buffer_size - XML_PARSER_BUFFER_SIZE) {
 			    if (xmlParserEntityCheck(ctxt, nbchars, ent))
 			        goto int_error;
 			    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 			}
 		    }
 		    xmlFree(rep);
 		    rep = NULL;
 		}
 	    }
 	} else {
 	    COPY_BUF(l,buffer,nbchars,c);
 	    str += l;
 	    if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
 	      growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
 	    }
 	}
 	if (str < last)
 	    c = CUR_SCHAR(str, l);
 	else
 	    c = 0;
     }
     buffer[nbchars] = 0;
     return(buffer);
 
 mem_error:
     xmlErrMemory(ctxt, NULL);
 int_error:
     if (rep != NULL)
         xmlFree(rep);
     if (buffer != NULL)
         xmlFree(buffer);
     return(NULL);
 }","[95, 94]","Heap-based buffer overflow in libxml2, as used in Google Chrome before 16.0.912.75, allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
199654," static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 			   size_t len, int noblock, int flags, int *addr_len)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	size_t copied = 0;
 	int err = -EOPNOTSUPP;
 	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 	struct sk_buff *skb;
 
  	if (flags & MSG_OOB)
  		goto out;
  
	if (addr_len)
		*addr_len = sizeof(*sin);
  	skb = skb_recv_datagram(sk, flags, noblock, &err);
  	if (!skb)
  		goto out;
 
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
 		copied = len;
 	}
 
 	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (err)
 		goto done;
 
 	sock_recv_timestamp(msg, sk, skb);
 
 	 
 	if (sin) {
 		sin->sin_family = AF_INET;
  		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
  		sin->sin_port = 0;
  		memset(&sin->sin_zero, 0, sizeof(sin->sin_zero));
 		*addr_len = sizeof(*sin);
  	}
  	if (inet->cmsg_flags)
  		ip_cmsg_recv(msg, skb);
 	if (flags & MSG_TRUNC)
 		copied = skb->len;
 done:
 	skb_free_datagram(sk, skb);
 out:
 	return err ? err : copied;
 }","[37, 13, 14]","The dgram_recvmsg function in net/ieee802154/dgram.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel stack memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
206388,"  void DataReductionProxyConfigServiceClient::RetrieveRemoteConfig() {
    DCHECK(thread_checker_.CalledOnValidThread());
   DCHECK(!params::IsIncludedInHoldbackFieldTrial());
 
    CreateClientConfigRequest request;
    std::string serialized_request;
  #if defined(OS_ANDROID)
   request.set_telephony_network_operator(
       net::android::GetTelephonyNetworkOperator());
 #endif
 
   data_reduction_proxy::ConfigDeviceInfo* device_info =
       request.mutable_device_info();
   device_info->set_total_device_memory_kb(
       base::SysInfo::AmountOfPhysicalMemory() / 1024);
   const std::string& session_key = request_options_->GetSecureSession();
   if (!session_key.empty())
     request.set_session_key(request_options_->GetSecureSession());
   request.set_dogfood_group(
       base::FeatureList::IsEnabled(features::kDogfood)
           ? CreateClientConfigRequest_DogfoodGroup_DOGFOOD
           : CreateClientConfigRequest_DogfoodGroup_NONDOGFOOD);
   data_reduction_proxy::VersionInfo* version_info =
       request.mutable_version_info();
   uint32_t build;
   uint32_t patch;
   util::GetChromiumBuildAndPatchAsInts(util::ChromiumVersion(), &build, &patch);
   version_info->set_client(util::GetStringForClient(io_data_->client()));
   version_info->set_build(build);
   version_info->set_patch(patch);
   version_info->set_channel(io_data_->channel());
   request.SerializeToString(&serialized_request);
 
   net::NetworkTrafficAnnotationTag traffic_annotation =
       net::DefineNetworkTrafficAnnotation(""data_reduction_proxy_config"", R""(
         semantics {
           sender: ""Data Reduction Proxy""
           description:
             ""Requests a configuration that specifies how to connect to the ""
             ""data reduction proxy.""
           trigger:
             ""Requested when Data Saver is enabled and the browser does not ""
             ""have a configuration that is not older than a threshold set by ""
             ""the server.""
           data: ""None.""
           destination: GOOGLE_OWNED_SERVICE
         }
         policy {
           cookies_allowed: NO
           setting:
             ""Users can control Data Saver on Android via 'Data Saver' setting. ""
             ""Data Saver is not available on iOS, and on desktop it is enabled ""
             ""by insalling the Data Saver extension.""
           policy_exception_justification: ""Not implemented.""
         })"");
   fetch_in_progress_ = true;
 
   auto resource_request = std::make_unique<network::ResourceRequest>();
   resource_request->url = config_service_url_;
   resource_request->method = ""POST"";
   resource_request->load_flags = net::LOAD_BYPASS_PROXY;
   resource_request->allow_credentials = false;
   url_loader_ = variations::CreateSimpleURLLoaderWithVariationsHeader(
       std::move(resource_request), variations::InIncognito::kNo,
       variations::SignedIn::kNo, traffic_annotation);
 
   url_loader_->AttachStringForUpload(serialized_request,
                                      ""application/x-protobuf"");
   static const int kMaxRetries = 5;
   url_loader_->SetRetryOptions(
       kMaxRetries, network::SimpleURLLoader::RETRY_ON_NETWORK_CHANGE);
   url_loader_->DownloadToStringOfUnboundedSizeUntilCrashAndDie(
       url_loader_factory_.get(),
       base::BindOnce(&DataReductionProxyConfigServiceClient::OnURLLoadComplete,
                      base::Unretained(this)));
 }","[3, 4]","A use after free in PDFium in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
206414," BluetoothDeviceChooserController::~BluetoothDeviceChooserController() {
   if (scanning_start_time_) {
     RecordScanningDuration(base::TimeTicks::Now() -
                            scanning_start_time_.value());
   }
  
    if (chooser_) {
      DCHECK(!error_callback_.is_null());
    error_callback_.Run(blink::mojom::WebBluetoothResult::CHOOSER_CANCELLED);
     error_callback_.Run(WebBluetoothResult::CHOOSER_CANCELLED);
    }
  }","[10, 9]","Heap buffer overflow in filter processing in Skia in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
201170," int MSG_ReadBits( msg_t *msg, int bits ) {
 	int			value;
 	int			get;
 	qboolean	sgn;
  	int			i, nbits;
  
 	if ( msg->readcount > msg->cursize ) {
 		return 0;
 	}
 
  	value = 0;
  
  	if ( bits < 0 ) {
 		bits = -bits;
 		sgn = qtrue;
 	} else {
 		sgn = qfalse;
  	}
  
  	if (msg->oob) {
 		if (msg->readcount + (bits>>3) > msg->cursize) {
 			msg->readcount = msg->cursize + 1;
 			return 0;
 		}
 
  		if(bits==8)
  		{
  			value = msg->data[msg->readcount];
 			msg->readcount += 1;
 			msg->bit += 8;
 		}
 		else if(bits==16)
 		{
 			short temp;
 			
 			CopyLittleShort(&temp, &msg->data[msg->readcount]);
 			value = temp;
 			msg->readcount += 2;
 			msg->bit += 16;
 		}
 		else if(bits==32)
 		{
 			CopyLittleLong(&value, &msg->data[msg->readcount]);
 			msg->readcount += 4;
 			msg->bit += 32;
 		}
 		else
 			Com_Error(ERR_DROP, ""can't read %d bits"", bits);
 	} else {
  		nbits = 0;
  		if (bits&7) {
  			nbits = bits&7;
 			if (msg->bit + nbits > msg->cursize << 3) {
 				msg->readcount = msg->cursize + 1;
 				return 0;
 			}
  			for(i=0;i<nbits;i++) {
  				value |= (Huff_getBit(msg->data, &msg->bit)<<i);
  			}
 			bits = bits - nbits;
 		}
  		if (bits) {
  			for(i=0;i<bits;i+=8) {
				Huff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);
 				Huff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit, msg->cursize<<3);
  				value |= (get<<(i+nbits));
 
 				if (msg->bit > msg->cursize<<3) {
 					msg->readcount = msg->cursize + 1;
 					return 0;
 				}
  			}
  		}
 		msg->readcount = (msg->bit>>3)+1;
 	}
 	if ( sgn && bits > 0 && bits < 32 ) {
 		if ( value & ( 1 << ( bits - 1 ) ) ) {
 			value |= -1 ^ ( ( 1 << bits ) - 1 );
 		}
 	}
 
 	return value;
 }","[7, 8, 9, 10, 21, 22, 23, 24, 25, 53, 54, 55, 56, 65, 67, 68, 69, 70, 71, 64]",Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
203967,"   static void UpdatePropertyHandler(
      void* object, const ImePropertyList& prop_list) {
    
   virtual void OnUpdateImeProperty(
       const input_method::ImePropertyList& prop_list) {
      if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
        LOG(ERROR) << ""Not on UI thread"";
        return;
      }
  
    InputMethodLibraryImpl* input_method_library =
        static_cast<InputMethodLibraryImpl*>(object);
    input_method_library->UpdateProperty(prop_list);
     UpdateProperty(prop_list);
    }","[3, 4, 5, 14, 2, 11, 12, 13]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
207551," status_t OMXNodeInstance::freeBuffer(
         OMX_U32 portIndex, OMX::buffer_id buffer) {
  Mutex::Autolock autoLock(mLock);
     CLOG_BUFFER(freeBuffer, ""%s:%u %#x"", portString(portIndex), portIndex, buffer);
 
  
      removeActiveBuffer(portIndex, buffer);
  
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
     if (header == NULL) {
         return BAD_VALUE;
     }
      BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
  
      OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
     CLOG_IF_ERROR(freeBuffer, err, ""%s:%u %#x"", portString(portIndex), portIndex, buffer);
 
  delete buffer_meta;
     buffer_meta = NULL;
     invalidateBufferID(buffer);
 
  return StatusFromOMXError(err);
 }","[10, 11, 12, 13, 9]","omx/OMXNodeInstance.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the buffer port, which allows attackers to gain privileges via a crafted application, aka internal bug 28816827."
200001,"  void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)
  	{
	BN_ULONG t1,t2;
  	BN_ULONG c1,c2,c3;
  
  	c1=0;
 	c2=0;
 	c3=0;
 	mul_add_c(a[0],b[0],c1,c2,c3);
 	r[0]=c1;
 	c1=0;
 	mul_add_c(a[0],b[1],c2,c3,c1);
 	mul_add_c(a[1],b[0],c2,c3,c1);
 	r[1]=c2;
 	c2=0;
 	mul_add_c(a[2],b[0],c3,c1,c2);
 	mul_add_c(a[1],b[1],c3,c1,c2);
 	mul_add_c(a[0],b[2],c3,c1,c2);
 	r[2]=c3;
 	c3=0;
 	mul_add_c(a[0],b[3],c1,c2,c3);
 	mul_add_c(a[1],b[2],c1,c2,c3);
 	mul_add_c(a[2],b[1],c1,c2,c3);
 	mul_add_c(a[3],b[0],c1,c2,c3);
 	r[3]=c1;
 	c1=0;
 	mul_add_c(a[4],b[0],c2,c3,c1);
 	mul_add_c(a[3],b[1],c2,c3,c1);
 	mul_add_c(a[2],b[2],c2,c3,c1);
 	mul_add_c(a[1],b[3],c2,c3,c1);
 	mul_add_c(a[0],b[4],c2,c3,c1);
 	r[4]=c2;
 	c2=0;
 	mul_add_c(a[0],b[5],c3,c1,c2);
 	mul_add_c(a[1],b[4],c3,c1,c2);
 	mul_add_c(a[2],b[3],c3,c1,c2);
 	mul_add_c(a[3],b[2],c3,c1,c2);
 	mul_add_c(a[4],b[1],c3,c1,c2);
 	mul_add_c(a[5],b[0],c3,c1,c2);
 	r[5]=c3;
 	c3=0;
 	mul_add_c(a[6],b[0],c1,c2,c3);
 	mul_add_c(a[5],b[1],c1,c2,c3);
 	mul_add_c(a[4],b[2],c1,c2,c3);
 	mul_add_c(a[3],b[3],c1,c2,c3);
 	mul_add_c(a[2],b[4],c1,c2,c3);
 	mul_add_c(a[1],b[5],c1,c2,c3);
 	mul_add_c(a[0],b[6],c1,c2,c3);
 	r[6]=c1;
 	c1=0;
 	mul_add_c(a[0],b[7],c2,c3,c1);
 	mul_add_c(a[1],b[6],c2,c3,c1);
 	mul_add_c(a[2],b[5],c2,c3,c1);
 	mul_add_c(a[3],b[4],c2,c3,c1);
 	mul_add_c(a[4],b[3],c2,c3,c1);
 	mul_add_c(a[5],b[2],c2,c3,c1);
 	mul_add_c(a[6],b[1],c2,c3,c1);
 	mul_add_c(a[7],b[0],c2,c3,c1);
 	r[7]=c2;
 	c2=0;
 	mul_add_c(a[7],b[1],c3,c1,c2);
 	mul_add_c(a[6],b[2],c3,c1,c2);
 	mul_add_c(a[5],b[3],c3,c1,c2);
 	mul_add_c(a[4],b[4],c3,c1,c2);
 	mul_add_c(a[3],b[5],c3,c1,c2);
 	mul_add_c(a[2],b[6],c3,c1,c2);
 	mul_add_c(a[1],b[7],c3,c1,c2);
 	r[8]=c3;
 	c3=0;
 	mul_add_c(a[2],b[7],c1,c2,c3);
 	mul_add_c(a[3],b[6],c1,c2,c3);
 	mul_add_c(a[4],b[5],c1,c2,c3);
 	mul_add_c(a[5],b[4],c1,c2,c3);
 	mul_add_c(a[6],b[3],c1,c2,c3);
 	mul_add_c(a[7],b[2],c1,c2,c3);
 	r[9]=c1;
 	c1=0;
 	mul_add_c(a[7],b[3],c2,c3,c1);
 	mul_add_c(a[6],b[4],c2,c3,c1);
 	mul_add_c(a[5],b[5],c2,c3,c1);
 	mul_add_c(a[4],b[6],c2,c3,c1);
 	mul_add_c(a[3],b[7],c2,c3,c1);
 	r[10]=c2;
 	c2=0;
 	mul_add_c(a[4],b[7],c3,c1,c2);
 	mul_add_c(a[5],b[6],c3,c1,c2);
 	mul_add_c(a[6],b[5],c3,c1,c2);
 	mul_add_c(a[7],b[4],c3,c1,c2);
 	r[11]=c3;
 	c3=0;
 	mul_add_c(a[7],b[5],c1,c2,c3);
 	mul_add_c(a[6],b[6],c1,c2,c3);
 	mul_add_c(a[5],b[7],c1,c2,c3);
 	r[12]=c1;
 	c1=0;
 	mul_add_c(a[6],b[7],c2,c3,c1);
 	mul_add_c(a[7],b[6],c2,c3,c1);
 	r[13]=c2;
 	c2=0;
 	mul_add_c(a[7],b[7],c3,c1,c2);
 	r[14]=c3;
 	r[15]=c1;
 	}",[3],"The BN_sqr implementation in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k does not properly calculate the square of a BIGNUM value, which might make it easier for remote attackers to defeat cryptographic protection mechanisms via unspecified vectors, related to crypto/bn/asm/mips.pl, crypto/bn/asm/x86_64-gcc.c, and crypto/bn/bn_asm.c."
8826,"static int ScaKwdTab(GmfMshSct *msh)
{
int      KwdCod, c;
int64_t  NexPos, EndPos, LstPos;
char     str[ GmfStrSiz ];

if(msh->typ & Asc)
{

while(fscanf(msh->hdl, ""%s"", str) != EOF)
{

if(isalpha(str[0]))
{


for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)
if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))
{
ScaKwdHdr(msh, KwdCod);
break;
}
}
else if(str[0] == '#')
while((c = fgetc(msh->hdl)) != '\n' && c != EOF);
}
}
else
{

EndPos = GetFilSiz(msh);
LstPos = -1;


do
{

ScaWrd(msh, ( char *)&KwdCod);
NexPos = GetPos(msh);


if(NexPos > EndPos)
longjmp(msh->err, -24);


if(NexPos && (NexPos <= LstPos))
longjmp(msh->err, -30);

LstPos = NexPos;


if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )
ScaKwdHdr(msh, KwdCod);


if(NexPos && !(SetFilPos(msh, NexPos)))
longjmp(msh->err, -25);

}while(NexPos && (KwdCod != GmfEnd));
}

return(1);
}",[10],A buffer overflow in the GmfOpenMesh() function of libMeshb v7.61 allows attackers to cause a Denial of Service (DoS) via a crafted MESH file.
205670," void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(
     bool spv1_compositing_specific_pass) {
   bool is_spv1_composited =
       object_.HasLayer() &&
       ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();
   if (is_spv1_composited != spv1_compositing_specific_pass)
     return;
 
   if (NeedsPaintPropertyUpdate()) {
     if (!NeedsClipPathClip(object_)) {
       OnClearClip(properties_->ClearClipPathClip());
     } else {
       ClipPaintPropertyNode::State state;
       state.local_transform_space = context_.current.transform;
        state.clip_rect =
            FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));
        state.clip_path = fragment_data_.ClipPathPath();
      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,
       OnUpdateClip(properties_->UpdateClipPathClip(*context_.current.clip,
                                                     std::move(state)));
      }
    }
 
   if (properties_->ClipPathClip() && !spv1_compositing_specific_pass) {
     context_.current.clip = context_.absolute_position.clip =
         context_.fixed_position.clip = properties_->ClipPathClip();
   }
 }","[19, 18]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
207338," xsltElementComp(xsltStylesheetPtr style, xmlNodePtr inst) {
 #ifdef XSLT_REFACTORED
     xsltStyleItemElementPtr comp;
 #else
     xsltStylePreCompPtr comp;
 #endif
 
      
     if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))
 	return;
 
 #ifdef XSLT_REFACTORED
     comp = (xsltStyleItemElementPtr) xsltNewStylePreComp(style, XSLT_FUNC_ELEMENT);
 #else
     comp = xsltNewStylePreComp(style, XSLT_FUNC_ELEMENT);
 #endif
 
     if (comp == NULL)
 	return;
     inst->psvi = comp;
     comp->inst = inst;
 
      
      
     comp->name = xsltEvalStaticAttrValueTemplate(style, inst,
 	(const xmlChar *)""name"", NULL, &comp->has_name);
     if (! comp->has_name) {
 	xsltTransformError(NULL, style, inst,
 	    ""xsl:element: The attribute 'name' is missing.\n"");
 	style->errors++;
 	goto error;
     }
      
      
     comp->ns = xsltEvalStaticAttrValueTemplate(style, inst,
 	(const xmlChar *)""namespace"", NULL, &comp->has_ns);
 
     if (comp->name != NULL) {
 	if (xmlValidateQName(comp->name, 0)) {
 	    xsltTransformError(NULL, style, inst,
 		""xsl:element: The value '%s' of the attribute 'name' is ""
 		""not a valid QName.\n"", comp->name);
 	    style->errors++;
 	} else {
 	    const xmlChar *prefix = NULL, *name;
 
 	    name = xsltSplitQName(style->dict, comp->name, &prefix);
 	    if (comp->has_ns == 0) {
 		xmlNsPtr ns;
 
 		 
 		ns = xmlSearchNs(inst->doc, inst, prefix);
 		if (ns != NULL) {
 		    comp->ns = xmlDictLookup(style->dict, ns->href, -1);
 		    comp->has_ns = 1;
  #ifdef XSLT_REFACTORED
  		    comp->nsPrefix = prefix;
  		    comp->name = name;
 #else
                     (void)name;  
  #endif
  		} else if (prefix != NULL) {
  		    xsltTransformError(NULL, style, inst,
 			""xsl:element: The prefixed QName '%s' ""
 			""has no namespace binding in scope in the ""
 			""stylesheet; this is an error, since the namespace was ""
 			""not specified by the instruction itself.\n"", comp->name);
 		    style->errors++;
 		}
 	    }
 	    if ((prefix != NULL) &&
 		(!xmlStrncasecmp(prefix, (xmlChar *)""xml"", 3)))
 	    {
 		 
 		comp->has_name = 0;
 	    }
 	}
     }
      
     comp->use = xsltEvalStaticAttrValueTemplate(style, inst,
 		       (const xmlChar *)""use-attribute-sets"",
 		       NULL, &comp->has_use);
 
 error:
     return;
 }","[59, 60]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
202821,"  static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                     OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
  {
    OPJ_UINT32 x, y;
     OPJ_UINT32 x, y, written;
      OPJ_UINT8 *pix;
      const OPJ_UINT8 *beyond;
  
      beyond = pData + stride * height;
      pix = pData;
  
    x = y = 0U;
     x = y = written = 0U;
      while (y < height) {
          int c = getc(IN);
          if (c == EOF) {
             return OPJ_FALSE;
         }
 
         if (c) {
             int j, c1_int;
             OPJ_UINT8 c1;
 
             c1_int = getc(IN);
             if (c1_int == EOF) {
                 return OPJ_FALSE;
             }
             c1 = (OPJ_UINT8)c1_int;
 
              for (j = 0; (j < c) && (x < width) &&
                      ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                  *pix = c1;
                 written++;
              }
          } else {
              c = getc(IN);
             if (c == EOF) {
                 return OPJ_FALSE;
             }
 
             if (c == 0x00) {  
                 x = 0;
                 ++y;
                 pix = pData + y * stride + x;
             } else if (c == 0x01) {  
                 break;
             } else if (c == 0x02) {  
                 c = getc(IN);
                 if (c == EOF) {
                     return OPJ_FALSE;
                 }
                 x += (OPJ_UINT32)c;
                 c = getc(IN);
                 if (c == EOF) {
                     return OPJ_FALSE;
                 }
                 y += (OPJ_UINT32)c;
                 pix = pData + y * stride + x;
             } else {  
                 int j;
                 for (j = 0; (j < c) && (x < width) &&
                         ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                     int c1_int;
                     OPJ_UINT8 c1;
                     c1_int = getc(IN);
                     if (c1_int == EOF) {
                         return OPJ_FALSE;
                      }
                      c1 = (OPJ_UINT8)c1_int;
                      *pix = c1;
                     written++;
                  }
                  if ((OPJ_UINT32)c & 1U) {  
                      c = getc(IN);
                     if (c == EOF) {
                         return OPJ_FALSE;
                     }
                 }
              }
          }
      } 
 
     if (written != width * height) {
         fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
         return OPJ_FALSE;
     }
 
      return OPJ_TRUE;
  }","[5, 13, 33, 71, 82, 83, 84, 85, 86, 87, 4, 12]","In OpenJPEG 2.3.1, there is excessive iteration in the opj_t1_encode_cblks function of openjp2/t1.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted bmp file. This issue is similar to CVE-2018-6616."
3815,"void CLASS foveon_dp_load_raw()
{
unsigned c, roff[4], row, col, diff;
ushort huff[512], vpred[2][2], hpred[2];

fseek (ifp, 8, SEEK_CUR);
foveon_huff (huff);
roff[0] = 48;
FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);
FORC3 {
fseek (ifp, data_offset+roff[c], SEEK_SET);
getbits(-1);
vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;
for (row=0; row < height; row++) {
#ifdef LIBRAW_LIBRARY_BUILD
checkCancel();
#endif
for (col=0; col < width; col++) {
diff = ljpeg_diff(huff);
if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
else hpred[col & 1] += diff;
image[row*width+col][c] = hpred[col & 1];
}
}
}
}",[4],"An integer overflow error within the ""foveon_load_camf()"" function (dcraw_foveon.c) in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a heap-based buffer overflow."
198229," PHP_METHOD(Phar, createDefaultStub)
 {
 	char *index = NULL, *webindex = NULL, *error;
         zend_string *stub;
         size_t index_len = 0, webindex_len = 0;
  
       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""|ss"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
        if (zend_parse_parameters(ZEND_NUM_ARGS(), ""|pp"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
                 return;
         }
  
 	stub = phar_create_default_stub(index, webindex, &error);
 
 	if (error) {
 		zend_throw_exception_ex(phar_ce_PharException, 0, ""%s"", error);
 		efree(error);
 		return;
 	}
 	RETURN_NEW_STR(stub);
 }","[8, 7]","The Phar extension in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allows remote attackers to execute arbitrary code via a crafted filename, as demonstrated by mishandling of \0 characters by the phar_analyze_path function in ext/phar/phar.c."
7833,"void Compute(OpKernelContext* context) override {
const Tensor& filter = context->input(1);
const TensorShape& filter_shape = filter.shape();

const Tensor& out_backprop = context->input(2);
const TensorShape& out_backprop_shape = out_backprop.shape();

TensorShape input_shape;
if (takes_shape_) {
const Tensor& input_sizes = context->input(0);


OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));
} else {
input_shape = context->input(0).shape();
}

ConvBackpropDimensions dims;
OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(
""Conv3DBackpropInputOp"",                      3,
input_shape, filter_shape, out_backprop_shape,
stride_, padding_, data_format_, &dims));

Tensor* in_backprop;
OP_REQUIRES_OK(context,
context->allocate_output(0, input_shape, &in_backprop));

functor::CuboidConvolutionBackwardInput<Device, T>()(
context->eigen_device<Device>(),
in_backprop->tensor<T, 5>(),
filter.tensor<T, 5>(),
out_backprop.tensor<T, 5>(),
static_cast<int>(dims.spatial_dims[0].stride),
static_cast<int>(dims.spatial_dims[1].stride),
static_cast<int>(dims.spatial_dims[2].stride));
}",[18],"TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
198405," nsPluginInstance::setupCookies(const std::string& pageurl)
 {
     std::string::size_type pos;
     pos = pageurl.find(""/"", pageurl.find("""", 0) + 2) + 1;
     std::string url = pageurl.substr(0, pos);
 
     std::string ncookie;
  
     char *cookie = 0;
     uint32_t length = 0;
 
     NPError rv = NPERR_GENERIC_ERROR;
 #if NPAPI_VERSION != 190
     if (NPNFuncs.getvalueforurl) {
         rv = NPN_GetValueForURL(_instance, NPNURLVCookie, url.c_str(),
                                 &cookie, &length);
     } else {
         LOG_ONCE( gnash::log_debug(""Browser doesn't support getvalueforurl"") );
     }
 #endif
 
     if (rv == NPERR_GENERIC_ERROR) {
         log_debug(""Trying window.document.cookie for cookies"");
         ncookie = getDocumentProp(""cookie"");
     }
 
     if (cookie) {
         ncookie.assign(cookie, length);
         NPN_MemFree(cookie);
     }
 
     if (ncookie.empty()) {
         gnash::log_debug(""No stored Cookie for %s"", url);
         return;
     }
 
     gnash::log_debug(""The Cookie for %s is %s"", url, ncookie);
     std::ofstream cookiefile;
     std::stringstream ss;
      ss << ""/tmp/gnash-cookies."" << getpid();
  
      cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);
     chmod (ss.str().c_str(), 0600);
  
   
     typedef boost::char_separator<char> char_sep;
     typedef boost::tokenizer<char_sep> tokenizer;
     tokenizer tok(ncookie, char_sep("";""));
 
     for (tokenizer::iterator it=tok.begin(); it != tok.end(); ++it) {
         cookiefile << ""Set-Cookie: "" << *it << std::endl;
     }
  
     cookiefile.close();
   
     if (setenv(""GNASH_COOKIES_IN"", ss.str().c_str(), 1) < 0) {
         gnash::log_error(
             ""Couldn't set environment variable GNASH_COOKIES_IN to %s"",
             ncookie);
     }
 }",[43],"plugin/npapi/plugin.cpp in Gnash before 0.8.10 uses weak permissions (world readable) for cookie files with predictable names in /tmp, which allows local users to obtain sensitive information."
198037,"   tt_face_load_kern( TT_Face    face,
                      FT_Stream  stream )
   {
     FT_Error   error;
     FT_ULong   table_size;
     FT_Byte*   p;
     FT_Byte*   p_limit;
     FT_UInt    nn, num_tables;
     FT_UInt32  avail = 0, ordered = 0;
 
 
      
     error = face->goto_table( face, TTAG_kern, stream, &table_size );
     if ( error )
       goto Exit;
 
     if ( table_size < 4 )   
     {
       FT_ERROR(( ""tt_face_load_kern:""
                  "" kerning table is too small - ignored\n"" ));
       error = FT_THROW( Table_Missing );
       goto Exit;
     }
 
     if ( FT_FRAME_EXTRACT( table_size, face->kern_table ) )
     {
       FT_ERROR(( ""tt_face_load_kern:""
                  "" could not extract kerning table\n"" ));
       goto Exit;
     }
 
     face->kern_table_size = table_size;
 
     p       = face->kern_table;
     p_limit = p + table_size;
 
     p         += 2;  
     num_tables = FT_NEXT_USHORT( p );
 
     if ( num_tables > 32 )  
       num_tables = 32;
 
     for ( nn = 0; nn < num_tables; nn++ )
     {
       FT_UInt    num_pairs, length, coverage;
       FT_Byte*   p_next;
       FT_UInt32  mask = (FT_UInt32)1UL << nn;
 
 
       if ( p + 6 > p_limit )
         break;
 
       p_next = p;
 
       p += 2;  
        length   = FT_NEXT_USHORT( p );
        coverage = FT_NEXT_USHORT( p );
  
      if ( length <= 6 )
       if ( length <= 6 + 8 )
          break;
  
        p_next += length;
 
       if ( p_next > p_limit )   
         p_next = p_limit;
 
        
       if ( ( coverage & ~8 ) != 0x0001 ||
            p + 8 > p_limit             )
         goto NextTable;
 
       num_pairs = FT_NEXT_USHORT( p );
       p        += 6;
 
       if ( ( p_next - p ) < 6 * (int)num_pairs )  
         num_pairs = (FT_UInt)( ( p_next - p ) / 6 );
 
       avail |= mask;
 
        
       if ( num_pairs > 0 )
       {
         FT_ULong  count;
         FT_ULong  old_pair;
 
 
         old_pair = FT_NEXT_ULONG( p );
         p       += 2;
 
         for ( count = num_pairs - 1; count > 0; count-- )
         {
           FT_UInt32  cur_pair;
 
 
           cur_pair = FT_NEXT_ULONG( p );
           if ( cur_pair <= old_pair )
             break;
 
           p += 2;
           old_pair = cur_pair;
         }
 
         if ( count == 0 )
           ordered |= mask;
       }
 
     NextTable:
       p = p_next;
     }
 
     face->num_kern_tables = nn;
     face->kern_avail_bits = avail;
     face->kern_order_bits = ordered;
 
   Exit:
     return error;
   }","[60, 59]","The tt_face_load_kern function in sfnt/ttkern.c in FreeType before 2.5.4 enforces an incorrect minimum table length, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted TrueType font."
207908," bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,
 
                                 uint8_t pin_len, bt_pin_code_t *pin_code)
  {
      BTIF_TRACE_EVENT(""%s: accept=%d"", __FUNCTION__, accept);
    if (pin_code == NULL)
     if (pin_code == NULL || pin_len > PIN_CODE_LEN)
          return BT_STATUS_FAIL;
  #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
  
  if (pairing_cb.is_le_only)
  {
  int i;
         UINT32 passkey = 0;
  int multi[] = {100000, 10000, 1000, 100, 10,1};
         BD_ADDR remote_bd_addr;
         bdcpy(remote_bd_addr, bd_addr->address);
  for (i = 0; i < 6; i++)
  {
             passkey += (multi[i] * (pin_code->pin[i] - '0'));
  }
         BTIF_TRACE_DEBUG(""btif_dm_pin_reply: passkey: %d"", passkey);
         BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);
 
  }
  else
  {
         BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);
  if (accept)
             pairing_cb.pin_code_len = pin_len;
  }
 #else
     BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);
 
  if (accept)
         pairing_cb.pin_code_len = pin_len;
 #endif
  return BT_STATUS_SUCCESS;
 }","[7, 6]","Buffer overflow in btif/src/btif_dm.c in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 allows remote attackers to execute arbitrary code via a long PIN value, aka internal bug 27411268."
205262,"  void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {
    DCHECK(main_task_runner_->BelongsToCurrentThread());
  
    channel_.reset();
   pipe_.Close();
  
    if (launch_elevated_) {
      if (job_.IsValid()) {
       TerminateJobObject(job_, exit_code);
     }
   } else {
     if (worker_process_.IsValid()) {
       TerminateProcess(worker_process_, exit_code);
     }
   }
 }",[5],Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving PDF fields.
199902," xfs_attr_calc_size(
 	struct xfs_inode 	*ip,
 	int			namelen,
 	int			valuelen,
 	int			*local)
 {
 	struct xfs_mount 	*mp = ip->i_mount;
 	int			size;
 	int			nblks;
 
 	 
 	size = xfs_attr_leaf_newentsize(namelen, valuelen,
 					mp->m_sb.sb_blocksize, local);
 
 	nblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);
 	if (*local) {
 		if (size > (mp->m_sb.sb_blocksize >> 1)) {
 			 
 			nblks *= 2;
 		}
 	} else {
 		 
		uint	dblocks = XFS_B_TO_FSB(mp, valuelen);
 		uint	dblocks = xfs_attr3_rmt_blocks(mp, valuelen);
  		nblks += dblocks;
  		nblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);
  	}
 
 	return nblks;
 }","[24, 23]","The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access."
206753,"  Response StorageHandler::TrackCacheStorageForOrigin(const std::string& origin) {
  if (!process_)
   if (!storage_partition_)
      return Response::InternalError();
  
    GURL origin_url(origin);
   if (!origin_url.is_valid())
     return Response::InvalidParams(origin + "" is not a valid URL"");
 
   BrowserThread::PostTask(
       BrowserThread::IO, FROM_HERE,
       base::BindOnce(&CacheStorageObserver::TrackOriginOnIOThread,
                      base::Unretained(GetCacheStorageObserver()),
                      url::Origin::Create(origin_url)));
   return Response::OK();
 }","[3, 2]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
203207," isakmp_rfc3948_print(netdissect_options *ndo,
  		     const u_char *bp, u_int length,
  		     const u_char *bp2)
  {
 	ND_TCHECK(bp[0]);
  	if(length == 1 && bp[0]==0xff) {
  		ND_PRINT((ndo, ""isakmp-nat-keep-alive""));
  		return;
 	}
 
  	if(length < 4) {
  		goto trunc;
  	}
 	ND_TCHECK(bp[3]);
  
  	 
 	if(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {
 		ND_PRINT((ndo, ""NONESP-encap: ""));
 		isakmp_print(ndo, bp+4, length-4, bp2);
 		return;
 	}
 
 	 
 	{
 		int nh, enh, padlen;
 		int advance;
 
 		ND_PRINT((ndo, ""UDP-encap: ""));
 
 		advance = esp_print(ndo, bp, length, bp2, &enh, &padlen);
 		if(advance <= 0)
 			return;
 
 		bp += advance;
 		length -= advance + padlen;
 		nh = enh & 0xff;
 
 		ip_print_inner(ndo, bp, length, nh, bp2);
 		return;
 	}
 
 trunc:
 	ND_PRINT((ndo,""[|isakmp]""));
 	return;
 }","[5, 14]",The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:isakmp_rfc3948_print().
199866," int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
 {
     BIGNUM *b, *c = NULL, *u = NULL, *v = NULL, *tmp;
     int ret = 0;
 
     bn_check_top(a);
     bn_check_top(p);
 
     BN_CTX_start(ctx);
 
     if ((b = BN_CTX_get(ctx)) == NULL)
         goto err;
     if ((c = BN_CTX_get(ctx)) == NULL)
         goto err;
     if ((u = BN_CTX_get(ctx)) == NULL)
         goto err;
     if ((v = BN_CTX_get(ctx)) == NULL)
         goto err;
 
     if (!BN_GF2m_mod(u, a, p))
         goto err;
     if (BN_is_zero(u))
         goto err;
 
     if (!BN_copy(v, p))
         goto err;
 # if 0
     if (!BN_one(b))
         goto err;
 
     while (1) {
         while (!BN_is_odd(u)) {
             if (BN_is_zero(u))
                 goto err;
             if (!BN_rshift1(u, u))
                 goto err;
             if (BN_is_odd(b)) {
                 if (!BN_GF2m_add(b, b, p))
                     goto err;
             }
             if (!BN_rshift1(b, b))
                 goto err;
         }
 
         if (BN_abs_is_word(u, 1))
             break;
 
         if (BN_num_bits(u) < BN_num_bits(v)) {
             tmp = u;
             u = v;
             v = tmp;
             tmp = b;
             b = c;
             c = tmp;
         }
 
         if (!BN_GF2m_add(u, u, v))
             goto err;
         if (!BN_GF2m_add(b, b, c))
             goto err;
      }
  # else
      {
        int i, ubits = BN_num_bits(u), vbits = BN_num_bits(v),  
            top = p->top;
         int i;
         int ubits = BN_num_bits(u);
         int vbits = BN_num_bits(v);  
         int top = p->top;
          BN_ULONG *udp, *bdp, *vdp, *cdp;
  
          bn_wexpand(u, top);
         udp = u->d;
         for (i = u->top; i < top; i++)
             udp[i] = 0;
         u->top = top;
         bn_wexpand(b, top);
         bdp = b->d;
         bdp[0] = 1;
         for (i = 1; i < top; i++)
             bdp[i] = 0;
         b->top = top;
         bn_wexpand(c, top);
         cdp = c->d;
         for (i = 0; i < top; i++)
             cdp[i] = 0;
         c->top = top;
         vdp = v->d;              
         while (1) {
             while (ubits && !(udp[0] & 1)) {
                 BN_ULONG u0, u1, b0, b1, mask;
 
                 u0 = udp[0];
                 b0 = bdp[0];
                 mask = (BN_ULONG)0 - (b0 & 1);
                 b0 ^= p->d[0] & mask;
                 for (i = 0; i < top - 1; i++) {
                     u1 = udp[i + 1];
                     udp[i] = ((u0 >> 1) | (u1 << (BN_BITS2 - 1))) & BN_MASK2;
                     u0 = u1;
                     b1 = bdp[i + 1] ^ (p->d[i + 1] & mask);
                     bdp[i] = ((b0 >> 1) | (b1 << (BN_BITS2 - 1))) & BN_MASK2;
                     b0 = b1;
                 }
                 udp[i] = u0 >> 1;
                 bdp[i] = b0 >> 1;
                  ubits--;
              }
  
            if (ubits <= BN_BITS2 && udp[0] == 1)
                break;
             if (ubits <= BN_BITS2) {
                 if (udp[0] == 0)  
                     goto err;
                 if (udp[0] == 1)
                     break;
             }
  
              if (ubits < vbits) {
                  i = ubits;
                 ubits = vbits;
                 vbits = i;
                 tmp = u;
                 u = v;
                 v = tmp;
                 tmp = b;
                 b = c;
                 c = tmp;
                 udp = vdp;
                 vdp = v->d;
                 bdp = cdp;
                 cdp = c->d;
             }
             for (i = 0; i < top; i++) {
                 udp[i] ^= vdp[i];
                 bdp[i] ^= cdp[i];
             }
             if (ubits == vbits) {
                 BN_ULONG ul;
                 int utop = (ubits - 1) / BN_BITS2;
 
                 while ((ul = udp[utop]) == 0 && utop)
                     utop--;
                 ubits = utop * BN_BITS2 + BN_num_bits_word(ul);
             }
         }
         bn_correct_top(b);
     }
 # endif
 
     if (!BN_copy(r, b))
         goto err;
     bn_check_top(r);
     ret = 1;
 
  err:
 # ifdef BN_DEBUG                 
     bn_correct_top(c);
     bn_correct_top(u);
     bn_correct_top(v);
 # endif
     BN_CTX_end(ctx);
     return ret;
 }","[66, 67, 68, 69, 112, 113, 114, 115, 116, 117, 64, 65, 110, 111]","The BN_GF2m_mod_inv function in crypto/bn/bn_gf2m.c in OpenSSL before 0.9.8s, 1.0.0 before 1.0.0e, 1.0.1 before 1.0.1n, and 1.0.2 before 1.0.2b does not properly handle ECParameters structures in which the curve is over a malformed binary polynomial field, which allows remote attackers to cause a denial of service (infinite loop) via a session that uses an Elliptic Curve algorithm, as demonstrated by an attack against a server that supports client authentication."
199794,"  int CLASS ljpeg_start (struct jhead *jh, int info_only)
  {
  int c, tag, len;
   int c, tag;
   ushort len;
    uchar data[0x10000];
    const uchar *dp;
  
   memset (jh, 0, sizeof *jh);
   jh->restart = INT_MAX;
   fread (data, 2, 1, ifp);
   if (data[1] != 0xd8) return 0;
   do {
     fread (data, 2, 2, ifp);
     tag =  data[0] << 8 | data[1];
     len = (data[2] << 8 | data[3]) - 2;
     if (tag <= 0xff00) return 0;
     fread (data, 1, len, ifp);
     switch (tag) {
       case 0xffc3:
 	jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;
       case 0xffc0:
 	jh->bits = data[0];
 	jh->high = data[1] << 8 | data[2];
 	jh->wide = data[3] << 8 | data[4];
 	jh->clrs = data[5] + jh->sraw;
 	if (len == 9 && !dng_version) getc(ifp);
 	break;
       case 0xffc4:
 	if (info_only) break;
 	for (dp = data; dp < data+len && (c = *dp++) < 4; )
 	  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);
 	break;
       case 0xffda:
 	jh->psv = data[1+data[0]*2];
 	jh->bits -= data[3+data[0]*2] & 15;
 	break;
       case 0xffdd:
 	jh->restart = data[0] << 8 | data[1];
     }
   } while (tag != 0xffda);
   if (info_only) return 1;
   FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];
   if (jh->sraw) {
     FORC(4)        jh->huff[2+c] = jh->huff[1];
     FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];
   }
   jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);
   merror (jh->row, ""ljpeg_start()"");
   return zero_after_ff = 1;
 }","[4, 5, 3]","Integer overflow in the ljpeg_start function in dcraw 7.00 and earlier allows remote attackers to cause a denial of service (crash) via a crafted image, which triggers a buffer overflow, related to the len variable."
205071,"  void RenderWidgetHostViewAura::AcceleratedSurfaceNew(
        int32 width_in_pixel,
        int32 height_in_pixel,
      uint64 surface_handle) {
       uint64 surface_handle,
       const std::string& mailbox_name) {
    ImageTransportFactory* factory = ImageTransportFactory::GetInstance();
    scoped_refptr<ui::Texture> surface(factory->CreateTransportClient(
        gfx::Size(width_in_pixel, height_in_pixel), device_scale_factor_,
      surface_handle));
       mailbox_name));
    if (!surface) {
      LOG(ERROR) << ""Failed to create ImageTransport texture"";
      return;
    }
    image_transport_clients_[surface_handle] = surface;
  }","[5, 6, 11, 4, 10]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
8303,"void Compute(OpKernelContext* context) override {
const Tensor& diagonal = context->input(0);




int32_t lower_diag_index = 0;
int32_t upper_diag_index = 0;
int32_t num_rows = -1;
int32_t num_cols = -1;
T padding_value(0);


if (context->num_inputs() > kNumV1Inputs) {
auto& diag_index = context->input(1);
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(diag_index.shape()) ||
TensorShapeUtils::IsVector(diag_index.shape()),
errors::InvalidArgument(
""diag_index must be a scalar or vector, received shape: "",
diag_index.shape().DebugString()));
lower_diag_index = diag_index.flat<int32>()(0);
upper_diag_index = lower_diag_index;
if (TensorShapeUtils::IsVector(diag_index.shape())) {
auto diag_index_size = diag_index.dim_size(0);
OP_REQUIRES(
context, 0 < diag_index_size && diag_index_size <= 2,
errors::InvalidArgument(
""diag_index must have only one or two elements, received "",
diag_index_size, "" elements.""));
if (diag_index_size > 1) {
upper_diag_index = diag_index.flat<int32>()(1);
}
}

auto& num_rows_tensor = context->input(2);
OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_rows_tensor.shape()),
errors::InvalidArgument(""num_rows must be a scalar""));
num_rows = num_rows_tensor.flat<int32>()(0);

auto& num_cols_tensor = context->input(3);
OP_REQUIRES(context, TensorShapeUtils::IsScalar(num_cols_tensor.shape()),
errors::InvalidArgument(""num_cols must be a scalar""));
num_cols = num_cols_tensor.flat<int32>()(0);

auto& padding_value_tensor = context->input(4);
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(padding_value_tensor.shape()),
errors::InvalidArgument(""padding_value must be a scalar""));
padding_value = padding_value_tensor.flat<T>()(0);
}


const TensorShape& diagonal_shape = diagonal.shape();
const int diag_rank = diagonal_shape.dims();
const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;
OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diagonal_shape),
errors::InvalidArgument(
""diagonal must be at least 1-dim, received shape: "",
diagonal.shape().DebugString()));
OP_REQUIRES(
context, lower_diag_index <= upper_diag_index,
errors::InvalidArgument(
""lower_diag_index must not be larger than upper_diag_index: "",
lower_diag_index, "" > "", upper_diag_index));
OP_REQUIRES(context,
lower_diag_index == upper_diag_index ||
diagonal_shape.dim_size(diag_rank - 2) == num_diags,
errors::InvalidArgument(
""The number of diagonals provided in the input does not ""
""match the lower_diag_index and upper_diag_index range.""));

const Eigen::Index max_diag_len = diagonal_shape.dim_size(diag_rank - 1);
const int32_t min_num_rows = max_diag_len - std::min(upper_diag_index, 0);
const int32_t min_num_cols = max_diag_len + std::max(lower_diag_index, 0);
OP_REQUIRES(context, num_rows == -1 || num_rows >= min_num_rows,
errors::InvalidArgument(""The number of rows is too small.""));
OP_REQUIRES(context, num_cols == -1 || num_cols >= min_num_cols,
errors::InvalidArgument(""The number of columns is too small.""));



if (num_rows == -1 && num_cols == -1) {
num_rows = std::max(min_num_rows, min_num_cols);
num_cols = num_rows;
} else if (num_rows == -1) {
num_rows = min_num_rows;
} else if (num_cols == -1) {
num_cols = min_num_cols;
}
OP_REQUIRES(context, num_rows == min_num_rows || num_cols == min_num_cols,
errors::InvalidArgument(
""The number of rows or columns is not consistent with ""
""the specified d_lower, d_upper, and diagonal.""));

TensorShape output_shape = diagonal_shape;
if (num_diags == 1) {
output_shape.set_dim(diag_rank - 1, num_rows);
output_shape.AddDim(num_cols);
} else {
output_shape.set_dim(diag_rank - 2, num_rows);
output_shape.set_dim(diag_rank - 1, num_cols);
}

Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));
auto output_reshaped = output->flat_inner_dims<T, 3>();
auto diag_reshaped = diagonal.flat<T>();
functor::MatrixDiag<Device, T>::Compute(
context, context->eigen_device<Device>(), diag_reshaped,
output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,
padding_value, left_align_superdiagonal_, left_align_subdiagonal_);
}",[22],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit f2a673bd34f0d64b8e40a551ac78989d16daad09. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
207010," OperationID FileSystemOperationRunner::BeginOperation(
      std::unique_ptr<FileSystemOperation> operation) {
    OperationID id = next_operation_id_++;
  
  operations_.emplace(id, std::move(operation));
   operations_[id] = std::move(operation);
    return id;
  }","[6, 5]",An integer overflow that leads to a use-after-free in Blink Storage in Google Chrome on Linux prior to 73.0.3683.75 allowed a remote attacker who had compromised the renderer process to execute arbitrary code via a crafted HTML page.
206256," static BROTLI_INLINE BrotliResult ProcessCommandsInternal(int safe,
     BrotliState* s) {
   int pos = s->pos;
   int i = s->loop_counter;
   BrotliResult result = BROTLI_RESULT_SUCCESS;
   BrotliBitReader* br = &s->br;
 
   if (!CheckInputAmount(safe, br, 28) || !WarmupBitReader(safe, br)) {
     result = BROTLI_RESULT_NEEDS_MORE_INPUT;
     goto saveStateAndReturn;
   }
 
    
   if (s->state == BROTLI_STATE_COMMAND_BEGIN) {
     goto CommandBegin;
   } else if (s->state == BROTLI_STATE_COMMAND_INNER) {
     goto CommandInner;
   } else if (s->state == BROTLI_STATE_COMMAND_POST_DECODE_LITERALS) {
     goto CommandPostDecodeLiterals;
   } else if (s->state == BROTLI_STATE_COMMAND_POST_WRAP_COPY) {
     goto CommandPostWrapCopy;
   } else {
     return BROTLI_FAILURE();
   }
 
 CommandBegin:
   if (safe) {
     s->state = BROTLI_STATE_COMMAND_BEGIN;
   }
   if (!CheckInputAmount(safe, br, 28)) {  
     s->state = BROTLI_STATE_COMMAND_BEGIN;
     result = BROTLI_RESULT_NEEDS_MORE_INPUT;
     goto saveStateAndReturn;
   }
   if (PREDICT_FALSE(s->block_length[1] == 0)) {
     BROTLI_SAFE(DecodeCommandBlockSwitch(s));
     goto CommandBegin;
   }
    
   BROTLI_SAFE(ReadCommand(s, br, &i));
   BROTLI_LOG_UINT(i);
   BROTLI_LOG_UINT(s->copy_length);
   BROTLI_LOG_UINT(s->distance_code);
   if (i == 0) {
     goto CommandPostDecodeLiterals;
   }
   s->meta_block_remaining_len -= i;
 
 CommandInner:
   if (safe) {
     s->state = BROTLI_STATE_COMMAND_INNER;
   }
    
   if (s->trivial_literal_context) {
     uint32_t bits;
     uint32_t value;
     PreloadSymbol(safe, s->literal_htree, br, &bits, &value);
     do {
       if (!CheckInputAmount(safe, br, 28)) {  
         s->state = BROTLI_STATE_COMMAND_INNER;
         result = BROTLI_RESULT_NEEDS_MORE_INPUT;
         goto saveStateAndReturn;
       }
       if (PREDICT_FALSE(s->block_length[0] == 0)) {
         BROTLI_SAFE(DecodeLiteralBlockSwitch(s));
         PreloadSymbol(safe, s->literal_htree, br, &bits, &value);
       }
       if (!safe) {
         s->ringbuffer[pos] = (uint8_t)ReadPreloadedSymbol(
             s->literal_htree, br, &bits, &value);
       } else {
         uint32_t literal;
         if (!SafeReadSymbol(s->literal_htree, br, &literal)) {
           result = BROTLI_RESULT_NEEDS_MORE_INPUT;
           goto saveStateAndReturn;
         }
         s->ringbuffer[pos] = (uint8_t)literal;
       }
       --s->block_length[0];
       BROTLI_LOG_UINT(s->literal_htree_index);
       BROTLI_LOG_ARRAY_INDEX(s->ringbuffer, pos);
       ++pos;
       if (PREDICT_FALSE(pos == s->ringbuffer_size)) {
         s->state = BROTLI_STATE_COMMAND_INNER_WRITE;
         --i;
         goto saveStateAndReturn;
       }
     } while (--i != 0);
   } else {
     uint8_t p1 = s->ringbuffer[(pos - 1) & s->ringbuffer_mask];
     uint8_t p2 = s->ringbuffer[(pos - 2) & s->ringbuffer_mask];
     do {
       const HuffmanCode* hc;
       uint8_t context;
       if (!CheckInputAmount(safe, br, 28)) {  
         s->state = BROTLI_STATE_COMMAND_INNER;
         result = BROTLI_RESULT_NEEDS_MORE_INPUT;
         goto saveStateAndReturn;
       }
       if (PREDICT_FALSE(s->block_length[0] == 0)) {
         BROTLI_SAFE(DecodeLiteralBlockSwitch(s));
       }
       context = s->context_lookup1[p1] | s->context_lookup2[p2];
       BROTLI_LOG_UINT(context);
       hc = s->literal_hgroup.htrees[s->context_map_slice[context]];
       p2 = p1;
       if (!safe) {
         p1 = (uint8_t)ReadSymbol(hc, br);
       } else {
         uint32_t literal;
         if (!SafeReadSymbol(hc, br, &literal)) {
           result = BROTLI_RESULT_NEEDS_MORE_INPUT;
           goto saveStateAndReturn;
         }
         p1 = (uint8_t)literal;
       }
       s->ringbuffer[pos] = p1;
       --s->block_length[0];
       BROTLI_LOG_UINT(s->context_map_slice[context]);
       BROTLI_LOG_ARRAY_INDEX(s->ringbuffer, pos & s->ringbuffer_mask);
       ++pos;
       if (PREDICT_FALSE(pos == s->ringbuffer_size)) {
         s->state = BROTLI_STATE_COMMAND_INNER_WRITE;
         --i;
         goto saveStateAndReturn;
       }
     } while (--i != 0);
   }
   if (s->meta_block_remaining_len <= 0) {
     s->state = BROTLI_STATE_METABLOCK_DONE;
     goto saveStateAndReturn;
   }
 
 CommandPostDecodeLiterals:
   if (safe) {
     s->state = BROTLI_STATE_COMMAND_POST_DECODE_LITERALS;
   }
   if (s->distance_code >= 0) {
     --s->dist_rb_idx;
     s->distance_code = s->dist_rb[s->dist_rb_idx & 3];
     goto postReadDistance;   
   }
    
   if (PREDICT_FALSE(s->block_length[2] == 0)) {
     BROTLI_SAFE(DecodeDistanceBlockSwitch(s));
   }
   BROTLI_SAFE(ReadDistance(s, br));
 postReadDistance:
   BROTLI_LOG_UINT(s->distance_code);
   if (s->max_distance != s->max_backward_distance) {
     if (pos < s->max_backward_distance_minus_custom_dict_size) {
       s->max_distance = pos + s->custom_dict_size;
     } else {
       s->max_distance = s->max_backward_distance;
     }
   }
   i = s->copy_length;
    
   if (s->distance_code > s->max_distance) {
     if (i >= kBrotliMinDictionaryWordLength &&
         i <= kBrotliMaxDictionaryWordLength) {
       int offset = kBrotliDictionaryOffsetsByLength[i];
       int word_id = s->distance_code - s->max_distance - 1;
       uint32_t shift = kBrotliDictionarySizeBitsByLength[i];
       int mask = (int)BitMask(shift);
       int word_idx = word_id & mask;
       int transform_idx = word_id >> shift;
       offset += word_idx * i;
       if (transform_idx < kNumTransforms) {
         const uint8_t* word = &kBrotliDictionary[offset];
         int len = i;
         if (transform_idx == 0) {
           memcpy(&s->ringbuffer[pos], word, (size_t)len);
         } else {
           len = TransformDictionaryWord(
               &s->ringbuffer[pos], word, len, transform_idx);
         }
         pos += len;
         s->meta_block_remaining_len -= len;
         if (pos >= s->ringbuffer_size) {
            
           s->state = BROTLI_STATE_COMMAND_POST_WRITE_1;
           goto saveStateAndReturn;
         }
       } else {
         BROTLI_LOG((""Invalid backward reference. pos: %d distance: %d ""
                ""len: %d bytes left: %d\n"",
             pos, s->distance_code, i,
             s->meta_block_remaining_len));
         return BROTLI_FAILURE();
       }
     } else {
       BROTLI_LOG((""Invalid backward reference. pos: %d distance: %d ""
              ""len: %d bytes left: %d\n"", pos, s->distance_code, i,
              s->meta_block_remaining_len));
       return BROTLI_FAILURE();
     }
   } else {
     const uint8_t *ringbuffer_end_minus_copy_length =
         s->ringbuffer_end - i;
      uint8_t* copy_src = &s->ringbuffer[
          (pos - s->distance_code) & s->ringbuffer_mask];
      uint8_t* copy_dst = &s->ringbuffer[pos];
      
     if (PREDICT_FALSE(s->ringbuffer_end < (const uint8_t*)0 + i)) {
       ringbuffer_end_minus_copy_length = 0;
     }
       
      s->dist_rb[s->dist_rb_idx & 3] = s->distance_code;
      ++s->dist_rb_idx;
     s->meta_block_remaining_len -= i;
     if (PREDICT_FALSE(s->meta_block_remaining_len < 0)) {
       BROTLI_LOG((""Invalid backward reference. pos: %d distance: %d ""
              ""len: %d bytes left: %d\n"", pos, s->distance_code, i,
              s->meta_block_remaining_len));
       return BROTLI_FAILURE();
     }
      
     memmove16(copy_dst, copy_src);
      
     if (copy_src < copy_dst) {
       if (copy_dst >= ringbuffer_end_minus_copy_length) {
         goto CommandPostWrapCopy;
       }
       if (copy_src + i > copy_dst) {
         goto postSelfintersecting;
       }
     } else {
       if (copy_src >= ringbuffer_end_minus_copy_length) {
         goto CommandPostWrapCopy;
       }
       if (copy_dst + i > copy_src) {
         goto postSelfintersecting;
       }
     }
     pos += i;
     if (i > 16) {
       if (i > 32) {
         memcpy(copy_dst + 16, copy_src + 16, (size_t)(i - 16));
       } else {
          
         memmove16(copy_dst + 16, copy_src + 16);
       }
     }
   }
   if (s->meta_block_remaining_len <= 0) {
      
     s->state = BROTLI_STATE_METABLOCK_DONE;
     goto saveStateAndReturn;
   } else {
     goto CommandBegin;
   }
 postSelfintersecting:
   while (--i >= 0) {
     s->ringbuffer[pos] =
         s->ringbuffer[(pos - s->distance_code) & s->ringbuffer_mask];
     ++pos;
   }
   if (s->meta_block_remaining_len <= 0) {
      
     s->state = BROTLI_STATE_METABLOCK_DONE;
     goto saveStateAndReturn;
   } else {
     goto CommandBegin;
   }
 
 CommandPostWrapCopy:
   s->state = BROTLI_STATE_COMMAND_POST_WRAP_COPY;
   while (--i >= 0) {
     s->ringbuffer[pos] =
         s->ringbuffer[(pos - s->distance_code) & s->ringbuffer_mask];
     ++pos;
     if (pos == s->ringbuffer_size) {
        
       s->state = BROTLI_STATE_COMMAND_POST_WRITE_2;
       goto saveStateAndReturn;
     }
   }
   if (s->meta_block_remaining_len <= 0) {
      
     s->state = BROTLI_STATE_METABLOCK_DONE;
     goto saveStateAndReturn;
   } else {
     goto CommandBegin;
   }
 
 saveStateAndReturn:
   s->pos = pos;
   s->loop_counter = i;
   return result;
 }","[204, 205, 206, 207]","Integer underflow in the ProcessCommandsInternal function in dec/decode.c in Brotli, as used in Google Chrome before 48.0.2564.109, allows remote attackers to cause a denial of service (buffer overflow) or possibly have unspecified other impact via crafted data with brotli compression."
4188,"void LibRaw::parse_x3f()
{
x3f_t *x3f = x3f_new_from_file(libraw_internal_data.internal_data.input);
if (!x3f)
return;
_x3f_data = x3f;

x3f_header_t *H = NULL;
x3f_directory_section_t *DS = NULL;

H = &x3f->header;

x3f_directory_entry_t *DE = x3f_get_raw(x3f);
if (!DE)
return;
imgdata.sizes.flip = H->rotation;
x3f_directory_entry_header_t *DEH = &DE->header;
x3f_image_data_t *ID = &DEH->data_subsection.image_data;
imgdata.sizes.raw_width = ID->columns;
imgdata.sizes.raw_height = ID->rows;

DE = x3f_get_prop(x3f);
if ((x3f_load_data(x3f, DE) == X3F_OK))
{

DEH = &DE->header;
x3f_property_list_t *PL = &DEH->data_subsection.property_list;
if (PL->property_table.size != 0)
{
int i;
x3f_property_t *P = PL->property_table.element;
for (i = 0; i < PL->num_properties; i++)
{
char name[100], value[100];
utf2char(P[i].name, name,sizeof(name));
utf2char(P[i].value, value,sizeof(value));
if (!strcmp(name, ""ISO""))
imgdata.other.iso_speed = atoi(value);
if (!strcmp(name, ""CAMMANUF""))
strcpy(imgdata.idata.make, value);
if (!strcmp(name, ""CAMMODEL""))
strcpy(imgdata.idata.model, value);
if (!strcmp(name, ""CAMSERIAL""))
strcpy(imgdata.shootinginfo.BodySerial, value);
if (!strcmp(name, ""WB_DESC""))
strcpy(imgdata.color.model2, value);
if (!strcmp(name, ""TIME""))
imgdata.other.timestamp = atoi(value);
if (!strcmp(name, ""SHUTTER""))
imgdata.other.shutter = atof(value);
if (!strcmp(name, ""APERTURE""))
imgdata.other.aperture = atof(value);
if (!strcmp(name, ""FLENGTH""))
imgdata.other.focal_len = atof(value);
if (!strcmp(name, ""FLEQ35MM""))
imgdata.lens.makernotes.FocalLengthIn35mmFormat = atof(value);
if (!strcmp(name, ""IMAGERTEMP""))
imgdata.other.SensorTemperature = atof(value);
if (!strcmp(name, ""LENSARANGE""))
{
char *sp;
imgdata.lens.makernotes.MaxAp4CurFocal = imgdata.lens.makernotes.MinAp4CurFocal = atof(value);
sp = strrchr(value, ' ');
if (sp)
{
imgdata.lens.makernotes.MinAp4CurFocal = atof(sp);
if (imgdata.lens.makernotes.MaxAp4CurFocal > imgdata.lens.makernotes.MinAp4CurFocal)
my_swap(float, imgdata.lens.makernotes.MaxAp4CurFocal, imgdata.lens.makernotes.MinAp4CurFocal);
}
}
if (!strcmp(name, ""LENSFRANGE""))
{
char *sp;
imgdata.lens.makernotes.MinFocal = imgdata.lens.makernotes.MaxFocal = atof(value);
sp = strrchr(value, ' ');
if (sp)
{
imgdata.lens.makernotes.MaxFocal = atof(sp);
if ((imgdata.lens.makernotes.MaxFocal + 0.17f) < imgdata.lens.makernotes.MinFocal)
my_swap(float, imgdata.lens.makernotes.MaxFocal, imgdata.lens.makernotes.MinFocal);
}
}
if (!strcmp(name, ""LENSMODEL""))
{
char *sp;
imgdata.lens.makernotes.LensID = strtol(value, &sp, 16);
if (imgdata.lens.makernotes.LensID)
imgdata.lens.makernotes.LensMount = Sigma_X3F;
}
}
imgdata.idata.raw_count = 1;
load_raw = &LibRaw::x3f_load_raw;
imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;
imgdata.idata.is_foveon = 1;
libraw_internal_data.internal_output_params.raw_color = 1;
imgdata.color.maximum = 0x3fff;
libraw_internal_data.unpacker_data.order = 0x4949;
}
}
else
{

if (imgdata.sizes.raw_width == 5888 || imgdata.sizes.raw_width == 2944 || imgdata.sizes.raw_width == 6656 ||
imgdata.sizes.raw_width == 3328 || imgdata.sizes.raw_width == 5504 ||
imgdata.sizes.raw_width == 2752)
{
imgdata.idata.raw_count = 1;
load_raw = &LibRaw::x3f_load_raw;
imgdata.sizes.raw_pitch = imgdata.sizes.raw_width * 6;
imgdata.idata.is_foveon = 1;
libraw_internal_data.internal_output_params.raw_color = 1;
libraw_internal_data.unpacker_data.order = 0x4949;
strcpy(imgdata.idata.make, ""SIGMA"");
#if 1

int pos = libraw_internal_data.internal_data.input->tell();
libraw_internal_data.internal_data.input->seek(0, SEEK_SET);
unsigned char buf[2048];
libraw_internal_data.internal_data.input->read(buf, 2048, 1);
libraw_internal_data.internal_data.input->seek(pos, SEEK_SET);
unsigned char *fnd = (unsigned char *)lr_memmem(buf, 2048, ""SIGMA dp"", 8);
unsigned char *fndsd = (unsigned char *)lr_memmem(buf, 2048, ""sd Quatt"", 8);
if (fnd)
{
unsigned char *nm = fnd + 8;
snprintf(imgdata.idata.model, 64, ""dp%c Quattro"", *nm <= '9' && *nm >= '0' ? *nm : '2');
}
else if (fndsd)
{
snprintf(imgdata.idata.model, 64, ""%s"", fndsd);
}
else
#endif
if (imgdata.sizes.raw_width == 6656 || imgdata.sizes.raw_width == 3328)
strcpy(imgdata.idata.model, ""sd Quattro H"");
else
strcpy(imgdata.idata.model, ""dp2 Quattro"");
}

}

LibRaw_thumbnail_formats format = LIBRAW_THUMBNAIL_UNKNOWN;
if ((DE = x3f_get_thumb_jpeg(x3f)))
{
format = LIBRAW_THUMBNAIL_JPEG;
}
else if ((DE = x3f_get_thumb_plain(x3f)))
{
format = LIBRAW_THUMBNAIL_BITMAP;
}
if (DE)
{
x3f_directory_entry_header_t *DEH = &DE->header;
x3f_image_data_t *ID = &DEH->data_subsection.image_data;
imgdata.thumbnail.twidth = ID->columns;
imgdata.thumbnail.theight = ID->rows;
imgdata.thumbnail.tcolors = 3;
imgdata.thumbnail.tformat = format;
libraw_internal_data.internal_data.toffset = DE->input.offset;
write_thumb = &LibRaw::x3f_thumb_loader;
}
}","[22, 28, 35, 36]",An issue was discovered in LibRaw 0.18.9. There is an out-of-bounds read affecting the X3F property table list implementation in libraw_x3f.cpp and libraw_cxx.cpp.
7021,"static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {
_cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;
AsyncPolkitQuery *q = userdata;
int r;

assert(reply);
assert(q);

q->slot = sd_bus_slot_unref(q->slot);
q->reply = sd_bus_message_ref(reply);

r = sd_bus_message_rewind(q->request, true);
if (r < 0) {
r = sd_bus_reply_method_errno(q->request, r, NULL);
goto finish;
}

r = q->callback(q->request, q->userdata, &error_buffer);
r = bus_maybe_reply_error(q->request, r, &error_buffer);

finish:
async_polkit_query_free(q);

return r;
}","[9, 10, 12, 13, 14, 15, 18, 19, 21, 22, 24]","A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages."
205555," AppResult::AppResult(Profile* profile,
                      const std::string& app_id,
                      AppListControllerDelegate* controller,
                      bool is_recommendation)
     : profile_(profile),
       app_id_(app_id),
       controller_(controller),
       extension_registry_(NULL) {
   set_id(extensions::Extension::GetBaseURLFromExtensionId(app_id_).spec());
   if (app_list::switches::IsExperimentalAppListEnabled())
      set_display_type(is_recommendation ? DISPLAY_RECOMMENDATION : DISPLAY_TILE);
  
    const extensions::Extension* extension =
      extensions::ExtensionSystem::Get(profile_)->extension_service()
          ->GetInstalledExtension(app_id_);
       extensions::ExtensionRegistry::Get(profile_)->GetInstalledExtension(
           app_id_);
    DCHECK(extension);
  
    is_platform_app_ = extension->is_platform_app();
 
   icon_.reset(
       new extensions::IconImage(profile_,
                                 extension,
                                 extensions::IconsInfo::GetIcons(extension),
                                 GetPreferredIconDimension(),
                                 extensions::util::GetDefaultAppIcon(),
                                 this));
   UpdateIcon();
 
   StartObservingExtensionRegistry();
 }","[16, 17, 14, 15]",Multiple unspecified vulnerabilities in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
8513,"mrb_proc_init_copy(mrb_state *mrb, mrb_value self)
{
mrb_value proc = mrb_get_arg1(mrb);

if (!mrb_proc_p(proc)) {
mrb_raise(mrb, E_ARGUMENT_ERROR, ""not a proc"");
}
mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));
return self;
}",[8],mruby is vulnerable to NULL Pointer Dereference
8821,"readSampleCountForLineBlock(InputStreamMutex* streamData,
DeepScanLineInputFile::Data* data,
int lineBlockId)
{
streamData->is->seekg(data->lineOffsets[lineBlockId]);

if (isMultiPart(data->version))
{
int partNumber;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, partNumber);

if (partNumber != data->partNumber)
throw IEX_NAMESPACE::ArgExc(""Unexpected part number."");
}

int minY;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, minY);





if (minY != data->minY + lineBlockId * data->linesInBuffer)
throw IEX_NAMESPACE::ArgExc(""Unexpected data block y coordinate."");

int maxY;
maxY = min(minY + data->linesInBuffer - 1, data->maxY);

uint64_t sampleCountTableDataSize;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, sampleCountTableDataSize);



if(sampleCountTableDataSize>static_cast<uint64_t>(data->maxSampleCountTableSize))
{
THROW (IEX_NAMESPACE::ArgExc, ""Bad sampleCountTableDataSize read from chunk ""<< lineBlockId << "": expected "" << data->maxSampleCountTableSize << "" or less, got ""<< sampleCountTableDataSize);
}

uint64_t packedDataSize;
uint64_t unpackedDataSize;
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, packedDataSize);
OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, unpackedDataSize);













int compressorMaxDataSize = std::numeric_limits<int>::max();
if (sampleCountTableDataSize > uint64_t(compressorMaxDataSize))
{
THROW (IEX_NAMESPACE::ArgExc, ""This version of the library does not ""
<< ""support the allocation of data with size  > ""
<< compressorMaxDataSize
<< "" file table size    :"" << sampleCountTableDataSize << "".\n"");
}
streamData->is->read(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize));

const char* readPtr;






if (sampleCountTableDataSize < static_cast<uint64_t>(data->maxSampleCountTableSize))
{
if(!data->sampleCountTableComp)
{
THROW(IEX_NAMESPACE::ArgExc,""Deep scanline data corrupt at chunk "" << lineBlockId << "" (sampleCountTableDataSize error)"");
}
data->sampleCountTableComp->uncompress(data->sampleCountTableBuffer,
static_cast<int>(sampleCountTableDataSize),
minY,
readPtr);
}
else readPtr = data->sampleCountTableBuffer;

char* base = data->sampleCountSliceBase;
int xStride = data->sampleCountXStride;
int yStride = data->sampleCountYStride;




size_t cumulative_total_samples=0;

for (int y = minY; y <= maxY; y++)
{
int yInDataWindow = y - data->minY;
data->lineSampleCount[yInDataWindow] = 0;

int lastAccumulatedCount = 0;
for (int x = data->minX; x <= data->maxX; x++)
{
int accumulatedCount, count;





Xdr::read <CharPtrIO> (readPtr, accumulatedCount);



if (accumulatedCount < lastAccumulatedCount)
{
THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "" (negative sample count detected)"");
}

count = accumulatedCount - lastAccumulatedCount;
lastAccumulatedCount = accumulatedCount;





data->sampleCount[yInDataWindow][x - data->minX] = count;
data->lineSampleCount[yInDataWindow] += count;
sampleCount(base, xStride, yStride, x, y) = count;
}
cumulative_total_samples+=data->lineSampleCount[yInDataWindow];
if(cumulative_total_samples*data->combinedSampleSize > unpackedDataSize)
{
THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "": pixel data only contains "" << unpackedDataSize
<< "" bytes of data but table references at least "" << cumulative_total_samples*data->combinedSampleSize << "" bytes of sample data"" );
}
data->gotSampleCount[y - data->minY] = true;
}
}","[56, 57, 59, 60, 61, 62, 64]",OpenEXR 3.1.x before 3.1.4 has a heap-based buffer overflow in Imf_3_1::LineCompositeTask::execute (called from IlmThread_3_1::NullThreadPoolProvider::addTask and IlmThread_3_1::ThreadPool::addGlobalTask). NOTE: db217f2 may be inapplicable.
204224,"    bool HasPermissionsForFile(const FilePath& file, int permissions) {
      FilePath current_path = file.StripTrailingSeparators();
      FilePath last_path;
     int skip = 0;
      while (current_path != last_path) {
      if (file_permissions_.find(current_path) != file_permissions_.end())
        return (file_permissions_[current_path] & permissions) == permissions;
       FilePath base_name =  current_path.BaseName();
       if (base_name.value() == FilePath::kParentDirectory) {
         ++skip;
       } else if (skip > 0) {
         if (base_name.value() != FilePath::kCurrentDirectory)
           --skip;
       } else {
         if (file_permissions_.find(current_path) != file_permissions_.end())
           return (file_permissions_[current_path] & permissions) == permissions;
       }
        last_path = current_path;
        current_path = current_path.DirName();
      }
 
     return false;
   }","[4, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 6, 7]","Google Chrome before 23.0.1271.95 does not properly handle file paths, which has unspecified impact and attack vectors."
198990," static int x86_pmu_handle_irq(struct pt_regs *regs)
 {
 	struct perf_sample_data data;
 	struct cpu_hw_events *cpuc;
 	struct perf_event *event;
 	int idx, handled = 0;
 	u64 val;
 
 	perf_sample_data_init(&data, 0);
 
 	cpuc = &__get_cpu_var(cpu_hw_events);
 
 	 
 	apic_write(APIC_LVTPC, APIC_DM_NMI);
 
 	for (idx = 0; idx < x86_pmu.num_counters; idx++) {
 		if (!test_bit(idx, cpuc->active_mask)) {
 			 
 			if (__test_and_clear_bit(idx, cpuc->running))
 				handled++;
 			continue;
 		}
 
 		event = cpuc->events[idx];
 
 		val = x86_perf_event_update(event);
 		if (val & (1ULL << (x86_pmu.cntval_bits - 1)))
 			continue;
 
 		 
 		handled++;
 		data.period	= event->hw.last_period;
 
  		if (!x86_perf_event_set_period(event))
  			continue;
  
		if (perf_event_overflow(event, 1, &data, regs))
 		if (perf_event_overflow(event, &data, regs))
  			x86_pmu_stop(event, 0);
  	}
  
 	if (handled)
 		inc_irq_stat(apic_perf_irqs);
 
 	return handled;
 }","[38, 37]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
48,"finalizer_thread (gpointer unused)
{
while (!finished) {




g_assert (mono_domain_get () == mono_get_root_domain ());

#ifdef MONO_HAS_SEMAPHORES
MONO_SEM_WAIT (&finalizer_sem);
#else

WaitForSingleObjectEx (finalizer_event, INFINITE, FALSE);
#endif

mono_console_handle_async_ops ();

#ifndef DISABLE_ATTACH
mono_attach_maybe_start ();
#endif

if (domains_to_finalize) {
mono_finalizer_lock ();
if (domains_to_finalize) {
DomainFinalizationReq *req = domains_to_finalize->data;
domains_to_finalize = g_slist_remove (domains_to_finalize, req);
mono_finalizer_unlock ();

finalize_domain_objects (req);
} else {
mono_finalizer_unlock ();
}
}




mono_gc_invoke_finalizers ();

SetEvent (pending_done_event);
}

SetEvent (shutdown_event);
return 0;
}","[23, 41]","Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to finalizing and then resurrecting a DynamicMethod instance."
8022,"static int sanitize_ptr_alu(struct bpf_verifier_env *env,
struct bpf_insn *insn,
const struct bpf_reg_state *ptr_reg,
const struct bpf_reg_state *off_reg,
struct bpf_reg_state *dst_reg,
struct bpf_insn_aux_data *tmp_aux,
const bool commit_window)
{
struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;
struct bpf_verifier_state *vstate = env->cur_state;
bool off_is_neg = off_reg->smin_value < 0;
bool ptr_is_dst_reg = ptr_reg == dst_reg;
u8 opcode = BPF_OP(insn->code);
u32 alu_state, alu_limit;
struct bpf_reg_state tmp;
bool ret;
int err;

if (can_skip_alu_sanitation(env, insn))
return 0;





if (vstate->speculative)
goto do_sim;

err = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode);
if (err < 0)
return err;

if (commit_window) {



alu_state = tmp_aux->alu_state;
alu_limit = abs(tmp_aux->alu_limit - alu_limit);
} else {
alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;
alu_state |= ptr_is_dst_reg ?
BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;
}

err = update_alu_sanitation_state(aux, alu_state, alu_limit);
if (err < 0)
return err;
do_sim:




if (commit_window)
return 0;










if (!ptr_is_dst_reg) {
tmp = *dst_reg;
*dst_reg = *ptr_reg;
}
ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);
if (!ptr_is_dst_reg && ret)
*dst_reg = tmp;
return !ret ? REASON_STACK : 0;
}","[11, 41]","kernel/bpf/verifier.c in the Linux kernel through 5.12.1 performs undesirable speculative loads, leading to disclosure of stack content via side-channel attacks, aka CID-801c6058d14a. The specific concern is not protecting the BPF stack area against speculative loads. Also, the BPF stack can contain uninitialized data that might represent sensitive information previously operated on by the kernel."
202244," decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)
 {
 	size_t cipher_len;
 	size_t i;
 	unsigned char iv[16] = { 0 };
 	unsigned char plaintext[4096] = { 0 };
 	epass2003_exdata *exdata = NULL;
 
 	if (!card->drv_data) 
 		return SC_ERROR_INVALID_ARGUMENTS;
 
 	exdata = (epass2003_exdata *)card->drv_data;
 
 	 
 	if (in[0] == 0x99)
 		return 0;
 
 	 
 	if (0x01 == in[2] && 0x82 != in[1]) {
 		cipher_len = in[1];
 		i = 3;
 	}
 	else if (0x01 == in[3] && 0x81 == in[1]) {
 		cipher_len = in[2];
 		i = 4;
 	}
 	else if (0x01 == in[4] && 0x82 == in[1]) {
 		cipher_len = in[2] * 0x100;
 		cipher_len += in[3];
 		i = 5;
 	}
 	else {
 		return -1;
 	}
 
 	if (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)
 		return -1;
 
 	 
 	if (KEY_TYPE_AES == exdata->smtype)
 		aes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
 	else
 		des3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);
 
 	 
  	while (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))
  		cipher_len--;
  
	if (2 == cipher_len)
 	if (2 == cipher_len || *out_len < cipher_len - 2)
  		return -1;
  
  	memcpy(out, plaintext, cipher_len - 2);
 	*out_len = cipher_len - 2;
 	return 0;
 }","[50, 49]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
201172," static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,
                                const uint8_t *buf, int buf_size,
                                int first_field)
 {
     int i, cid, ret;
     int old_bit_depth = ctx->bit_depth, bitdepth;
     uint64_t header_prefix;
     if (buf_size < 0x280) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""buffer too small (%d < 640).\n"", buf_size);
         return AVERROR_INVALIDDATA;
     }
 
     header_prefix = ff_dnxhd_parse_header_prefix(buf);
     if (header_prefix == 0) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"",
                buf[0], buf[1], buf[2], buf[3], buf[4]);
         return AVERROR_INVALIDDATA;
     }
     if (buf[5] & 2) {  
         ctx->cur_field = buf[5] & 1;
         frame->interlaced_frame = 1;
         frame->top_field_first  = first_field ^ ctx->cur_field;
         av_log(ctx->avctx, AV_LOG_DEBUG,
                ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field);
     } else {
         ctx->cur_field = 0;
     }
     ctx->mbaff = (buf[0x6] >> 5) & 1;
 
     ctx->height = AV_RB16(buf + 0x18);
     ctx->width  = AV_RB16(buf + 0x1a);
 
     switch(buf[0x21] >> 5) {
     case 1: bitdepth = 8; break;
     case 2: bitdepth = 10; break;
     case 3: bitdepth = 12; break;
     default:
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5);
         return AVERROR_INVALIDDATA;
     }
 
     cid = AV_RB32(buf + 0x28);
 
     ctx->avctx->profile = dnxhd_get_profile(cid);
 
     if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)
         return ret;
     if (ctx->mbaff && ctx->cid_table->cid != 1260)
         av_log(ctx->avctx, AV_LOG_WARNING,
                ""Adaptive MB interlace flag in an unsupported profile.\n"");
 
     ctx->act = buf[0x2C] & 7;
     if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)
         av_log(ctx->avctx, AV_LOG_WARNING,
                ""Adaptive color transform in an unsupported profile.\n"");
 
     ctx->is_444 = (buf[0x2C] >> 6) & 1;
     if (ctx->is_444) {
         if (bitdepth == 8) {
             avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits"");
             return AVERROR_INVALIDDATA;
         } else if (bitdepth == 10) {
             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10
                                     : AV_PIX_FMT_GBRP10;
         } else {
             ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;
             ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12
                                     : AV_PIX_FMT_GBRP12;
         }
     } else if (bitdepth == 12) {
         ctx->decode_dct_block = dnxhd_decode_dct_block_12;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P12;
     } else if (bitdepth == 10) {
         if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX)
             ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;
         else
             ctx->decode_dct_block = dnxhd_decode_dct_block_10;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P10;
     } else {
         ctx->decode_dct_block = dnxhd_decode_dct_block_8;
         ctx->pix_fmt = AV_PIX_FMT_YUV422P;
     }
 
     ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;
     if (ctx->bit_depth != old_bit_depth) {
         ff_blockdsp_init(&ctx->bdsp, ctx->avctx);
         ff_idctdsp_init(&ctx->idsp, ctx->avctx);
         ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,
                           ff_zigzag_direct);
     }
 
     if (ctx->width != ctx->cid_table->width &&
         ctx->cid_table->width != DNXHD_VARIABLE) {
         av_reduce(&ctx->avctx->sample_aspect_ratio.num,
                   &ctx->avctx->sample_aspect_ratio.den,
                   ctx->width, ctx->cid_table->width, 255);
         ctx->width = ctx->cid_table->width;
     }
 
     if (buf_size < ctx->cid_table->coding_unit_size) {
         av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %u).\n"",
                buf_size, ctx->cid_table->coding_unit_size);
         return AVERROR_INVALIDDATA;
     }
 
     ctx->mb_width  = (ctx->width + 15)>> 4;
     ctx->mb_height = AV_RB16(buf + 0x16c);
 
     if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)
         ctx->height <<= 1;
 
     av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"",
            ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"",
            ctx->bit_depth, ctx->mbaff, ctx->act);
 
      if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
          ctx->data_offset = 0x170 + (ctx->mb_height << 2);
      } else {
        if (ctx->mb_height > 68 ||
            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
         if (ctx->mb_height > 68) {
              av_log(ctx->avctx, AV_LOG_ERROR,
                     ""mb height too big: %d\n"", ctx->mb_height);
              return AVERROR_INVALIDDATA;
          }
          ctx->data_offset = 0x280;
      }
     if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                 ""mb height too big: %d\n"", ctx->mb_height);
         return AVERROR_INVALIDDATA;
     }
  
      if (buf_size < ctx->data_offset) {
          av_log(ctx->avctx, AV_LOG_ERROR,
                ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset);
         return AVERROR_INVALIDDATA;
     }
 
     if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                ""mb_height too big (%d > %""SIZE_SPECIFIER"").\n"", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index));
         return AVERROR_INVALIDDATA;
     }
 
     for (i = 0; i < ctx->mb_height; i++) {
         ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
         ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %""PRIu32""\n"",
                 i, 0x170 + (i << 2), ctx->mb_scan_index[i]);
         if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""invalid mb scan index (%""PRIu32"" vs %u).\n"",
                    ctx->mb_scan_index[i], buf_size - ctx->data_offset);
             return AVERROR_INVALIDDATA;
         }
     }
 
     return 0;
 }","[125, 132, 133, 134, 135, 136, 123, 124]",The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.
208623," void WT_Interpolate (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
 {
     EAS_PCM *pOutputBuffer;
     EAS_I32 phaseInc;
     EAS_I32 phaseFrac;
     EAS_I32 acc0;
  const EAS_SAMPLE *pSamples;
  const EAS_SAMPLE *loopEnd;
     EAS_I32 samp1;
     EAS_I32 samp2;
     EAS_I32 numSamples;
 
   
 
      numSamples = pWTIntFrame->numSamples;
      if (numSamples <= 0) {
          ALOGE(""b/26366256"");
         android_errorWriteLog(0x534e4554, ""26366256"");
          return;
      }
      pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     loopEnd = (const EAS_SAMPLE*) pWTVoice->loopEnd + 1;
     pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
   
     phaseFrac = pWTVoice->phaseFrac;
     phaseInc = pWTIntFrame->frame.phaseIncrement;
 
   
 #if defined(_8_BIT_SAMPLES)
   
     samp1 = pSamples[0] << 8;
   
     samp2 = pSamples[1] << 8;
 #else
     samp1 = pSamples[0];
     samp2 = pSamples[1];
 #endif
 
  while (numSamples--) {
 
   
         acc0 = samp2 - samp1;
         acc0 = acc0 * phaseFrac;
   
         acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);
 
   
   
  *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);
 
   
         phaseFrac += phaseInc;
   
         acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;
 
   
  if (acc0 > 0) {
 
   
             pSamples += acc0;
             phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);
 
   
             acc0 = (EAS_I32) (pSamples - loopEnd);
  if (acc0 >= 0)
                 pSamples = (const EAS_SAMPLE*) pWTVoice->loopStart + acc0;
 
   
 #if defined(_8_BIT_SAMPLES)
   
             samp1 = pSamples[0] << 8;
   
             samp2 = pSamples[1] << 8;
 #else
             samp1 = pSamples[0];
             samp2 = pSamples[1];
 #endif
  }
  }
 
   
     pWTVoice->phaseAccum = (EAS_U32) pSamples;
     pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
 }",[18],"Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
199972,"  void __init files_init(unsigned long mempages)
  { 
  	unsigned long n;
 
 	filp_cachep = kmem_cache_create(""filp"", sizeof(struct file), 0,
 			SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);
 
 	  
 
  	n = (mempages * (PAGE_SIZE / 1024)) / 10;
  	files_stat.max_files = max_t(unsigned long, n, NR_FILE);
  	files_defer_init();
	lg_lock_init(&files_lglock, ""files_lglock"");
  	percpu_counter_init(&nr_files, 0);
  } ",[13],"The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations."
208023,"  status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) {
     if (size < 1) {
         ALOGE(""empty NAL b/35467107"");
         return ERROR_MALFORMED;
     }
      uint8_t nalUnitType = (data[0] >> 1) & 0x3f;
      status_t err = OK;
      switch (nalUnitType) {
          case 32:   
             if (size < 2) {
                 ALOGE(""invalid NAL/VPS size b/35467107"");
                 return ERROR_MALFORMED;
             }
              err = parseVps(data + 2, size - 2);
              break;
          case 33:   
             if (size < 2) {
                 ALOGE(""invalid NAL/SPS size b/35467107"");
                 return ERROR_MALFORMED;
             }
              err = parseSps(data + 2, size - 2);
              break;
          case 34:   
             if (size < 2) {
                 ALOGE(""invalid NAL/PPS size b/35467107"");
                 return ERROR_MALFORMED;
             }
              err = parsePps(data + 2, size - 2);
              break;
          case 39:   
  case 40:  
  break;
  default:
             ALOGE(""Unrecognized NAL unit type."");
  return ERROR_MALFORMED;
  }
 
  if (err != OK) {
  return err;
  }
 
     sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size);
     buffer->setInt32Data(nalUnitType);
     mNalUnits.push(buffer);
  return OK;
 }","[2, 3, 4, 5, 10, 11, 12, 13, 17, 18, 19, 20, 24, 25, 26, 27]","A remote denial of service vulnerability in HevcUtils.cpp in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as Low due to details specific to the vulnerability. Product: Android. Versions: 7.0, 7.1.1, 7.1.2. Android ID: A-35467107."
8413,"static void control_work_handler(struct work_struct *work)
{
struct ports_device *portdev;
struct virtqueue *vq;
struct port_buffer *buf;
unsigned int len;

portdev = container_of(work, struct ports_device, control_work);
vq = portdev->c_ivq;

spin_lock(&portdev->c_ivq_lock);
while ((buf = virtqueue_get_buf(vq, &len))) {
spin_unlock(&portdev->c_ivq_lock);

buf->len = len;
buf->offset = 0;

handle_control_message(vq->vdev, portdev, buf);

spin_lock(&portdev->c_ivq_lock);
if (add_inbuf(portdev->c_ivq, buf) < 0) {
dev_warn(&portdev->vdev->dev,
""Error adding buffer to queue\n"");
free_buf(buf, false);
}
}
spin_unlock(&portdev->c_ivq_lock);
}",[15],"** DISPUTED ** In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior."
9917,"int read_password(unsigned char* buffer, encryptmode_t mode)
{
#ifndef WIN32
#define PASS_EOF EOF
struct termios t;
int echo_enabled;
int tty;
FILE* ftty;
unsigned char pwd[MAX_PASSWD_BUF];
unsigned char pwd_confirm[MAX_PASSWD_BUF];
unsigned char* p;
#else
#define PASS_EOF L'\x003'
FILE* ftty = stderr;
wchar_t* pwd = (wchar_t *)buffer;
wchar_t pwd_confirm[MAX_PASSWD_LEN+1];
wchar_t* p;
#endif

int c;
int chars_read;
int i;
int match;

#ifndef WIN32

ftty = fopen(""/dev/tty"", ""r+"");
if (ftty == NULL)
{
return AESCRYPT_READPWD_FOPEN;
}
tty = fileno(ftty);
if (tty < 0)
{
return AESCRYPT_READPWD_FILENO;
}


if (tcgetattr(tty, &t) < 0)
{
fclose(ftty);
return AESCRYPT_READPWD_TCGETATTR;
}
#endif





for (i = 0; (i == 0) || (i == 1 && mode == ENC); i++)
{

if (!i)
{
p = pwd;
}
else
{
p = pwd_confirm;
}


if (i)
{
fprintf(ftty, ""Re-"");
}
fprintf(ftty, ""Enter password: "");
fflush(ftty);

#ifndef WIN32

if (t.c_lflag & ECHO)
{
t.c_lflag &= ~ECHO;
if (tcsetattr(tty, TCSANOW, &t) < 0)
{

memset_secure(pwd, 0, MAX_PASSWD_BUF);
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);
fclose(ftty);
return AESCRYPT_READPWD_TCSETATTR;
}
echo_enabled = 1;
}
else
{
echo_enabled = 0;
}
#endif


chars_read = 0;
#ifdef WIN32
while (((c = _getwch()) != L'\r') && (c != PASS_EOF))
#else
while (((c = fgetc(ftty)) != '\n') && (c != PASS_EOF))
#endif
{

if (chars_read <= MAX_PASSWD_LEN)
{
#ifdef WIN32
p[chars_read] = (wchar_t) c;
#else
p[chars_read] = (char) c;
#endif
}
chars_read++;
}

if (chars_read <= MAX_PASSWD_LEN)
{
p[chars_read] = '\0';
}

fprintf(ftty, ""\n"");

#ifndef WIN32

if (echo_enabled)
{
t.c_lflag |= ECHO;
if (tcsetattr(tty, TCSANOW, &t) < 0)
{

memset_secure(pwd, 0, MAX_PASSWD_BUF);
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);
fclose(ftty);
return AESCRYPT_READPWD_TCSETATTR;
}
}
#endif


if (c == PASS_EOF)
{

memset_secure(pwd, 0, MAX_PASSWD_BUF);
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);
if (ftty != stderr)
fclose(ftty);
return AESCRYPT_READPWD_FGETC;
}





if (chars_read > MAX_PASSWD_LEN)
{

memset_secure(pwd, 0, MAX_PASSWD_BUF);
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);
if (ftty != stderr)
fclose(ftty);
return AESCRYPT_READPWD_TOOLONG;
}
}


if (ftty != stderr)
fclose(ftty);


if (mode == ENC)
{

match = strcmp((char*)pwd, (char*)pwd_confirm);
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);

if (match != 0)
{

memset_secure(pwd, 0, MAX_PASSWD_BUF);
return AESCRYPT_READPWD_NOMATCH;
}
}

#ifdef WIN32
chars_read *= 2;
#else
chars_read = passwd_to_utf16(
pwd,
chars_read,
MAX_PASSWD_LEN,
buffer);

if (chars_read < 0) {
memset_secure(pwd_confirm, 0, MAX_PASSWD_BUF);
memset_secure(pwd, 0, MAX_PASSWD_BUF);
return AESCRYPT_READPWD_ICONV;
}
#endif

return chars_read;
}","[28, 30, 33, 35, 140, 141, 154, 155, 161, 162, 168, 171, 174, 175, 182, 183, 184, 185, 186]","AES Crypt is a file encryption software for multiple platforms. AES Crypt for Linux built using the source on GitHub and having the version number 3.11 has a vulnerability with respect to reading user-provided passwords and confirmations via command-line prompts. Passwords lengths were not checked before being read. This vulnerability may lead to buffer overruns. This does _not_ affect source code found on aescrypt.com, nor is the vulnerability present when providing a password or a key via the `-p` or `-k` command-line options. The problem was fixed via in commit 68761851b and will be included in release 3.16. Users are advised to upgrade. Users unable to upgrade should us the `-p` or `-k` options to provide a password or key."
202888,"  void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)
  {
	static u32 ip_idents_hashrnd __read_mostly;
  	u32 hash, id;
  
	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 	 
 	if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))
 		get_random_bytes(&net->ipv4.ip_id_key,
 				 sizeof(net->ipv4.ip_id_key));
  
	hash = jhash_3words((__force u32)iph->daddr,
 	hash = siphash_3u32((__force u32)iph->daddr,
  			    (__force u32)iph->saddr,
			    iph->protocol ^ net_hash_mix(net),
			    ip_idents_hashrnd);
 			    iph->protocol,
 			    &net->ipv4.ip_id_key);
  	id = ip_idents_reserve(hash, segs);
  	iph->id = htons(id);
  }","[7, 8, 9, 10, 13, 17, 18, 3, 6, 12, 15, 16]","In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses."
199908," xfs_attr3_leaf_getvalue(
 	struct xfs_buf		*bp,
 	struct xfs_da_args	*args)
 {
 	struct xfs_attr_leafblock *leaf;
 	struct xfs_attr3_icleaf_hdr ichdr;
 	struct xfs_attr_leaf_entry *entry;
 	struct xfs_attr_leaf_name_local *name_loc;
 	struct xfs_attr_leaf_name_remote *name_rmt;
 	int			valuelen;
 
 	leaf = bp->b_addr;
 	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
 	ASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);
 	ASSERT(args->index < ichdr.count);
 
 	entry = &xfs_attr3_leaf_entryp(leaf)[args->index];
 	if (entry->flags & XFS_ATTR_LOCAL) {
 		name_loc = xfs_attr3_leaf_name_local(leaf, args->index);
 		ASSERT(name_loc->namelen == args->namelen);
 		ASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);
 		valuelen = be16_to_cpu(name_loc->valuelen);
 		if (args->flags & ATTR_KERNOVAL) {
 			args->valuelen = valuelen;
 			return 0;
 		}
 		if (args->valuelen < valuelen) {
 			args->valuelen = valuelen;
 			return XFS_ERROR(ERANGE);
 		}
 		args->valuelen = valuelen;
 		memcpy(args->value, &name_loc->nameval[args->namelen], valuelen);
 	} else {
  		name_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);
  		ASSERT(name_rmt->namelen == args->namelen);
  		ASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);
		valuelen = be32_to_cpu(name_rmt->valuelen);
 		args->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);
  		args->rmtblkno = be32_to_cpu(name_rmt->valueblk);
  		args->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,
						       valuelen);
 						       args->rmtvaluelen);
  		if (args->flags & ATTR_KERNOVAL) {
			args->valuelen = valuelen;
 			args->valuelen = args->rmtvaluelen;
  			return 0;
  		}
		if (args->valuelen < valuelen) {
			args->valuelen = valuelen;
 		if (args->valuelen < args->rmtvaluelen) {
 			args->valuelen = args->rmtvaluelen;
  			return XFS_ERROR(ERANGE);
  		}
		args->valuelen = valuelen;
 		args->valuelen = args->rmtvaluelen;
  	}
  	return 0;
  }","[38, 42, 45, 50, 51, 55, 37, 41, 44, 48, 49, 54]","The XFS implementation in the Linux kernel before 3.15 improperly uses an old size value during remote attribute replacement, which allows local users to cause a denial of service (transaction overrun and data corruption) or possibly gain privileges by leveraging XFS filesystem access."
199876," static int cg_getattr(const char *path, struct stat *sb)
 {
 	struct timespec now;
 	struct fuse_context *fc = fuse_get_context();
 	char * cgdir = NULL;
 	char *fpath = NULL, *path1, *path2;
 	struct cgfs_files *k = NULL;
 	const char *cgroup;
 	const char *controller = NULL;
 	int ret = -ENOENT;
 
 
 	if (!fc)
 		return -EIO;
 
 	memset(sb, 0, sizeof(struct stat));
 
 	if (clock_gettime(CLOCK_REALTIME, &now) < 0)
 		return -EINVAL;
 
 	sb->st_uid = sb->st_gid = 0;
 	sb->st_atim = sb->st_mtim = sb->st_ctim = now;
 	sb->st_size = 0;
 
 	if (strcmp(path, ""/cgroup"") == 0) {
 		sb->st_mode = S_IFDIR | 00755;
 		sb->st_nlink = 2;
 		return 0;
 	}
 
 	controller = pick_controller_from_path(fc, path);
 	if (!controller)
 		return -EIO;
 	cgroup = find_cgroup_in_path(path);
 	if (!cgroup) {
 		 
 		sb->st_mode = S_IFDIR | 00755;
 		sb->st_nlink = 2;
 		return 0;
 	}
 
 	get_cgdir_and_path(cgroup, &cgdir, &fpath);
 
 	if (!fpath) {
 		path1 = ""/"";
 		path2 = cgdir;
 	} else {
 		path1 = cgdir;
 		path2 = fpath;
 	}
 
 	 
  
  	if (is_child_cgroup(controller, path1, path2)) {
 		if (!caller_may_see_dir(fc->pid, controller, cgroup)) {
 			ret = -ENOENT;
 			goto out;
 		}
  		if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
  			 
  			sb->st_mode = S_IFDIR | 00555;
 			sb->st_nlink = 2;
 			ret = 0;
 			goto out;
 		}
 		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
 			ret = -EACCES;
 			goto out;
 		}
 
 		sb->st_mode = S_IFDIR | 00755;
 		k = cgfs_get_key(controller, cgroup, ""tasks"");
 		if (!k) {
 			sb->st_uid = sb->st_gid = 0;
 		} else {
 			sb->st_uid = k->uid;
 			sb->st_gid = k->gid;
 		}
 		free_key(k);
 		sb->st_nlink = 2;
 		ret = 0;
 		goto out;
 	}
 
 	if ((k = cgfs_get_key(controller, path1, path2)) != NULL) {
 		sb->st_mode = S_IFREG | k->mode;
 		sb->st_nlink = 1;
 		sb->st_uid = k->uid;
 		sb->st_gid = k->gid;
 		sb->st_size = 0;
 		free_key(k);
 		if (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {
 			ret = -ENOENT;
 			goto out;
 		}
 		if (!fc_may_access(fc, controller, path1, path2, O_RDONLY)) {
 			ret = -EACCES;
 			goto out;
 		}
 
 		ret = 0;
 	}
 
 out:
 	free(cgdir);
 	return ret;
 }","[55, 56, 57, 58]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup."
206283," void WebContentsImpl::RunBeforeUnloadConfirm(
      RenderFrameHost* render_frame_host,
      bool is_reload,
      IPC::Message* reply_msg) {
    
    
   if (IsFullscreenForCurrentTab())
     ExitFullscreen(true);
 
    RenderFrameHostImpl* rfhi =
        static_cast<RenderFrameHostImpl*>(render_frame_host);
    if (delegate_)
     delegate_->WillRunBeforeUnloadConfirm();
 
   bool suppress_this_message =
       !rfhi->is_active() ||
       ShowingInterstitialPage() || !delegate_ ||
       delegate_->ShouldSuppressDialogs(this) ||
       !delegate_->GetJavaScriptDialogManager(this);
   if (suppress_this_message) {
     rfhi->JavaScriptDialogClosed(reply_msg, true, base::string16());
     return;
   }
 
   is_showing_before_unload_dialog_ = true;
   dialog_manager_ = delegate_->GetJavaScriptDialogManager(this);
   dialog_manager_->RunBeforeUnloadDialog(
       this, is_reload,
       base::Bind(&WebContentsImpl::OnDialogClosed, base::Unretained(this),
                  render_frame_host->GetProcess()->GetID(),
                  render_frame_host->GetRoutingID(), reply_msg,
                  false));
 }","[5, 6, 7, 8, 9]","Inappropriate implementation in modal dialog handling in Blink in Google Chrome prior to 60.0.3112.78 for Mac, Windows, Linux, and Android allowed a remote attacker to prevent a full screen warning from being displayed via a crafted HTML page."
207244," IDNSpoofChecker::IDNSpoofChecker() {
   UErrorCode status = U_ZERO_ERROR;
   checker_ = uspoof_open(&status);
   if (U_FAILURE(status)) {
     checker_ = nullptr;
     return;
   }
 
 
   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);
 
   SetAllowedUnicodeSet(&status);
 
   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;
   uspoof_setChecks(checker_, checks, &status);
 
   deviation_characters_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u00df\\u03c2\\u200c\\u200d]""), status);
   deviation_characters_.freeze();
 
   non_ascii_latin_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Latin:] - [a-zA-Z]]""), status);
   non_ascii_latin_letters_.freeze();
 
   kana_letters_exceptions_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[\\u3078-\\u307a\\u30d8-\\u30da\\u30fb-\\u30fe]""),
       status);
   kana_letters_exceptions_.freeze();
   combining_diacritics_exceptions_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[\\u0300-\\u0339]""), status);
   combining_diacritics_exceptions_.freeze();
 
   cyrillic_letters_latin_alike_ = icu::UnicodeSet(
       icu::UnicodeString::fromUTF8(""[асԁеһіјӏорԛѕԝхуъЬҽпгѵѡ]""), status);
   cyrillic_letters_latin_alike_.freeze();
 
   cyrillic_letters_ =
       icu::UnicodeSet(UNICODE_STRING_SIMPLE(""[[:Cyrl:]]""), status);
   cyrillic_letters_.freeze();
 
   DCHECK(U_SUCCESS(status));
   lgc_letters_n_ascii_ = icu::UnicodeSet(
       UNICODE_STRING_SIMPLE(""[[:Latin:][:Greek:][:Cyrillic:][0-9\\u002e_""
                             ""\\u002d][\\u0300-\\u0339]]""),
       status);
   lgc_letters_n_ascii_.freeze();
 
   UParseError parse_error;
   diacritic_remover_.reset(icu::Transliterator::createFromRules(
       UNICODE_STRING_SIMPLE(""DropAcc""),
       icu::UnicodeString::fromUTF8(""::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;""
                                    "" ł > l; ø > o; đ > d;""),
       UTRANS_FORWARD, parse_error, status));
 
       UNICODE_STRING_SIMPLE(""ExtraConf""),
       icu::UnicodeString::fromUTF8(""[þϼҏ] > p; [ħнћңҥӈӊԋԧԩ] > h;""
                                    ""[ĸκкқҝҟҡӄԟ] > k; [ŋп] > n; [ŧтҭԏ] > t;""
                                     ""[ƅьҍв] > b;  [ωшщฟ] > w; [мӎ] > m;""
                                     ""[єҽҿၔ] > e; ґ > r; [ғӻ] > f; [ҫင] > c;""
                                     ""ұ > y; [χҳӽӿ] > x;""
#if defined(OS_WIN)
                                   ""ӏ > i;""
#else
                                   ""ӏ > l;""
#endif
                                     ""ԃ  > d; [ԍဌ] > g; [ടร] > s; ၂ > j;""
                                     ""[зӡ] > 3""),
        UTRANS_FORWARD, parse_error, status));
   DCHECK(U_SUCCESS(status))
       << ""Spoofchecker initalization failed due to an error: ""
       << u_errorName(status);
 }","[61, 62, 63, 64, 65]",Incorrect handling of confusable characters in URL Formatter in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to perform domain spoofing via IDN homographs via a crafted domain name.
198714," static struct sock *dccp_v6_request_recv_sock(struct sock *sk,
 					      struct sk_buff *skb,
 					      struct request_sock *req,
 					      struct dst_entry *dst)
 {
 	struct inet6_request_sock *ireq6 = inet6_rsk(req);
 	struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
 	struct inet_sock *newinet;
 	struct dccp6_sock *newdp6;
 	struct sock *newsk;
 	struct ipv6_txoptions *opt;
 
 	if (skb->protocol == htons(ETH_P_IP)) {
 		 
 		newsk = dccp_v4_request_recv_sock(sk, skb, req, dst);
 		if (newsk == NULL)
 			return NULL;
 
 		newdp6 = (struct dccp6_sock *)newsk;
 		newinet = inet_sk(newsk);
 		newinet->pinet6 = &newdp6->inet6;
 		newnp = inet6_sk(newsk);
 
 		memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
 		ipv6_addr_set_v4mapped(newinet->inet_daddr, &newnp->daddr);
 
 		ipv6_addr_set_v4mapped(newinet->inet_saddr, &newnp->saddr);
 
 		ipv6_addr_copy(&newnp->rcv_saddr, &newnp->saddr);
 
 		inet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;
 		newsk->sk_backlog_rcv = dccp_v4_do_rcv;
 		newnp->pktoptions  = NULL;
 		newnp->opt	   = NULL;
 		newnp->mcast_oif   = inet6_iif(skb);
 		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
 
 		 
 
 		 
 		dccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);
 
 		return newsk;
 	}
 
 	opt = np->opt;
 
 	if (sk_acceptq_is_full(sk))
 		goto out_overflow;
 
 	if (dst == NULL) {
 		struct in6_addr *final_p, final;
 		struct flowi6 fl6;
 
 		memset(&fl6, 0, sizeof(fl6));
 		fl6.flowi6_proto = IPPROTO_DCCP;
 		ipv6_addr_copy(&fl6.daddr, &ireq6->rmt_addr);
 		final_p = fl6_update_dst(&fl6, opt, &final);
 		ipv6_addr_copy(&fl6.saddr, &ireq6->loc_addr);
 		fl6.flowi6_oif = sk->sk_bound_dev_if;
 		fl6.fl6_dport = inet_rsk(req)->rmt_port;
 		fl6.fl6_sport = inet_rsk(req)->loc_port;
 		security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
 
 		dst = ip6_dst_lookup_flow(sk, &fl6, final_p, false);
 		if (IS_ERR(dst))
 			goto out;
 	}
 
 	newsk = dccp_create_openreq_child(sk, req, skb);
 	if (newsk == NULL)
 		goto out_nonewsk;
 
 	 
 
 	__ip6_dst_store(newsk, dst, NULL, NULL);
 	newsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |
 						      NETIF_F_TSO);
 	newdp6 = (struct dccp6_sock *)newsk;
 	newinet = inet_sk(newsk);
 	newinet->pinet6 = &newdp6->inet6;
 	newnp = inet6_sk(newsk);
 
 	memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
 	ipv6_addr_copy(&newnp->daddr, &ireq6->rmt_addr);
 	ipv6_addr_copy(&newnp->saddr, &ireq6->loc_addr);
 	ipv6_addr_copy(&newnp->rcv_saddr, &ireq6->loc_addr);
 	newsk->sk_bound_dev_if = ireq6->iif;
 
 	 
	newinet->opt = NULL;
 	newinet->inet_opt = NULL;
  
  	 
  	newnp->rxopt.all = np->rxopt.all;
 
 	 
 	newnp->pktoptions = NULL;
 	if (ireq6->pktopts != NULL) {
 		newnp->pktoptions = skb_clone(ireq6->pktopts, GFP_ATOMIC);
 		kfree_skb(ireq6->pktopts);
 		ireq6->pktopts = NULL;
 		if (newnp->pktoptions)
 			skb_set_owner_r(newnp->pktoptions, newsk);
 	}
 	newnp->opt	  = NULL;
 	newnp->mcast_oif  = inet6_iif(skb);
 	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
 
 	 
 	if (opt != NULL) {
 		newnp->opt = ipv6_dup_options(newsk, opt);
 		if (opt != np->opt)
 			sock_kfree_s(sk, opt, opt->tot_len);
 	}
 
 	inet_csk(newsk)->icsk_ext_hdr_len = 0;
 	if (newnp->opt != NULL)
 		inet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +
 						     newnp->opt->opt_flen);
 
 	dccp_sync_mss(newsk, dst_mtu(dst));
 
 	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
 	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
 
 	if (__inet_inherit_port(sk, newsk) < 0) {
 		sock_put(newsk);
 		goto out;
 	}
 	__inet6_hash(newsk, NULL);
 
 	return newsk;
 
 out_overflow:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
 out_nonewsk:
 	dst_release(dst);
 out:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);
 	if (opt != NULL && opt != np->opt)
 		sock_kfree_s(sk, opt, opt->tot_len);
 	return NULL;
 }","[94, 93]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
7815,"String UTF16BEDecoder::to_utf8(const StringView& input)
{
StringBuilder builder(input.length() / 2);
for (size_t i = 0; i < input.length(); i += 2) {
u16 code_point = (input[i] << 8) | input[i + 1];
builder.append_code_point(code_point);
}
return builder.to_string();
}",[4],SerenityOS fixed as of c9f25bca048443e317f1994ba9b106f2386688c3 contains a buffer overflow vulnerability in LibTextCode through opening a crafted file.
6148,"otError Commissioner::GeneratePskc(const char *              aPassPhrase,
const char *              aNetworkName,
const Mac::ExtendedPanId &aExtPanId,
Pskc &                    aPskc)
{
otError     error      = OT_ERROR_NONE;
const char *saltPrefix = ""Thread"";
uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];
uint16_t    saltLen = 0;

VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&
(strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&
(strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),
error = OT_ERROR_INVALID_ARGS);

memset(salt, 0, sizeof(salt));
memcpy(salt, saltPrefix, strlen(saltPrefix));
saltLen += static_cast<uint16_t>(strlen(saltPrefix));

memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));
saltLen += OT_EXT_PAN_ID_SIZE;

memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));
saltLen += static_cast<uint16_t>(strlen(aNetworkName));

otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),
reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);

exit:
return error;
}","[6, 7, 8, 9, 11, 12, 13, 17, 18, 23, 24, 26, 27]",OpenThread before 2019-12-13 has a stack-based buffer overflow in MeshCoP::Commissioner::GeneratePskc.
199593," static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
 		     unsigned int dataoff, unsigned int *timeouts)
 {
 	struct net *net = nf_ct_net(ct);
 	struct dccp_net *dn;
 	struct dccp_hdr _dh, *dh;
  	const char *msg;
  	u_int8_t state;
  
	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
 	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
  	BUG_ON(dh == NULL);
  
  	state = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];
 	switch (state) {
 	default:
 		dn = dccp_pernet(net);
 		if (dn->dccp_loose == 0) {
 			msg = ""nf_ct_dccp: not picking up existing connection "";
 			goto out_invalid;
 		}
 	case CT_DCCP_REQUEST:
 		break;
 	case CT_DCCP_INVALID:
 		msg = ""nf_ct_dccp: invalid state transition "";
 		goto out_invalid;
 	}
 
 	ct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;
 	ct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;
 	ct->proto.dccp.state = CT_DCCP_NONE;
 	ct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;
 	ct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;
 	ct->proto.dccp.handshake_seq = 0;
 	return true;
 
 out_invalid:
 	if (LOG_INVALID(net, IPPROTO_DCCP))
 		nf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,
 			      NULL, ""%s"", msg);
 	return false;
 }","[11, 10]","net/netfilter/nf_conntrack_proto_dccp.c in the Linux kernel through 3.13.6 uses a DCCP header pointer incorrectly, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a DCCP packet that triggers a call to the (1) dccp_new, (2) dccp_packet, or (3) dccp_error function."
199046," static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
 			const char *dev_name, void *raw_data)
 {
 	struct super_block *s;
 	struct ecryptfs_sb_info *sbi;
 	struct ecryptfs_dentry_info *root_info;
  	const char *err = ""Getting sb failed"";
  	struct inode *inode;
  	struct path path;
 	uid_t check_ruid;
  	int rc;
  
  	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
 	if (!sbi) {
 		rc = -ENOMEM;
  		goto out;
  	}
  
	rc = ecryptfs_parse_options(sbi, raw_data);
 	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
  	if (rc) {
  		err = ""Error parsing options"";
  		goto out;
 	}
 
 	s = sget(fs_type, NULL, set_anon_super, NULL);
 	if (IS_ERR(s)) {
 		rc = PTR_ERR(s);
 		goto out;
 	}
 
 	s->s_flags = flags;
 	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
 	if (rc)
 		goto out1;
 
 	ecryptfs_set_superblock_private(s, sbi);
 	s->s_bdi = &sbi->bdi;
 
 	 
 	sbi = NULL;
 	s->s_op = &ecryptfs_sops;
 	s->s_d_op = &ecryptfs_dops;
 
 	err = ""Reading sb failed"";
 	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
 	if (rc) {
 		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
 		goto out1;
 	}
 	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
 		rc = -EINVAL;
 		printk(KERN_ERR ""Mount on filesystem of type ""
 			""eCryptfs explicitly disallowed due to ""
  			""known incompatibilities\n"");
  		goto out_free;
  	}
 
 	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
 		rc = -EPERM;
 		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
 		       ""requested user (uid: %d)\n"",
 		       path.dentry->d_inode->i_uid, current_uid());
 		goto out_free;
 	}
 
  	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
  	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
  	s->s_blocksize = path.dentry->d_sb->s_blocksize;
 	s->s_magic = ECRYPTFS_SUPER_MAGIC;
 
 	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
 	rc = PTR_ERR(inode);
 	if (IS_ERR(inode))
 		goto out_free;
 
 	s->s_root = d_alloc_root(inode);
 	if (!s->s_root) {
 		iput(inode);
 		rc = -ENOMEM;
 		goto out_free;
 	}
 
 	rc = -ENOMEM;
 	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
 	if (!root_info)
 		goto out_free;
 
 	 
 	ecryptfs_set_dentry_private(s->s_root, root_info);
 	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
 	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);
 
 	s->s_flags |= MS_ACTIVE;
 	return dget(s->s_root);
 
 out_free:
 	path_put(&path);
 out1:
 	deactivate_locked_super(s);
 out:
 	if (sbi) {
 		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
 		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
 	}
 	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
 	return ERR_PTR(rc);
 }","[10, 20, 58, 59, 60, 61, 62, 63, 64, 65, 66, 19]",Race condition in the ecryptfs_mount function in fs/ecryptfs/main.c in the eCryptfs subsystem in the Linux kernel before 3.1 allows local users to bypass intended file permissions via a mount.ecryptfs_private mount with a mismatched uid.
207310,"  exsltCryptoRc4EncryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {
  
    int key_len = 0, key_size = 0;
     int key_len = 0;
      int str_len = 0, bin_len = 0, hex_len = 0;
      xmlChar *key = NULL, *str = NULL, *padkey = NULL;
      xmlChar *bin = NULL, *hex = NULL;
     xsltTransformContextPtr tctxt = NULL;
 
     if (nargs != 2) {
 	xmlXPathSetArityError (ctxt);
 	return;
     }
      tctxt = xsltXPathGetTransformContext(ctxt);
  
      str = xmlXPathPopString (ctxt);
    str_len = xmlUTF8Strlen (str);
     str_len = xmlStrlen (str);
  
      if (str_len == 0) {
  	xmlXPathReturnEmptyString (ctxt);
 	xmlFree (str);
 	return;
      }
  
      key = xmlXPathPopString (ctxt);
    key_len = xmlUTF8Strlen (key);
     key_len = xmlStrlen (key);
  
      if (key_len == 0) {
  	xmlXPathReturnEmptyString (ctxt);
 	xmlFree (key);
 	xmlFree (str);
 	return;
     }
 
     padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);
     if (padkey == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    ""exsltCryptoRc4EncryptFunction: Failed to allocate padkey\n"");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
      }
      memset(padkey, 0, RC4_KEY_LENGTH + 1);
  
    key_size = xmlUTF8Strsize (key, key_len);
    if ((key_size > RC4_KEY_LENGTH) || (key_size < 0)) {
     if ((key_len > RC4_KEY_LENGTH) || (key_len < 0)) {
  	xsltTransformError(tctxt, NULL, tctxt->inst,
  	    ""exsltCryptoRc4EncryptFunction: key size too long or key broken\n"");
  	tctxt->state = XSLT_STATE_STOPPED;
  	xmlXPathReturnEmptyString (ctxt);
  	goto done;
      }
    memcpy (padkey, key, key_size);
     memcpy (padkey, key, key_len);
  
   
      bin_len = str_len;
     bin = xmlStrdup (str);
     if (bin == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    ""exsltCryptoRc4EncryptFunction: Failed to allocate string\n"");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
     PLATFORM_RC4_ENCRYPT (ctxt, padkey, str, str_len, bin, bin_len);
 
  
     hex_len = str_len * 2 + 1;
     hex = xmlMallocAtomic (hex_len);
     if (hex == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    ""exsltCryptoRc4EncryptFunction: Failed to allocate result\n"");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
 
     exsltCryptoBin2Hex (bin, str_len, hex, hex_len);
     xmlXPathReturnString (ctxt, hex);
 
 done:
     if (key != NULL)
 	xmlFree (key);
     if (str != NULL)
 	xmlFree (str);
     if (padkey != NULL)
 	xmlFree (padkey);
     if (bin != NULL)
 	xmlFree (bin);
 }","[4, 18, 28, 49, 57, 3, 17, 27, 47, 48, 56]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
205152," DictionaryValue* ExtensionTabUtil::CreateTabValue(
     const WebContents* contents,
      TabStripModel* tab_strip,
      int tab_index,
      const Extension* extension) {
  bool has_permission = extension && extension->HasAPIPermissionForTab(
      GetTabId(contents), APIPermission::kTab);
  return CreateTabValue(contents, tab_strip, tab_index,
                        has_permission ? INCLUDE_PRIVACY_SENSITIVE_FIELDS :
                            OMIT_PRIVACY_SENSITIVE_FIELDS);
   DictionaryValue *result = CreateTabValue(contents, tab_strip, tab_index);
   ScrubTabValueForExtension(contents, extension, result);
   return result;
  }","[11, 12, 13, 6, 7, 8, 9, 10]","Google Chrome before 26.0.1410.43 does not ensure that an extension has the tabs (aka APIPermission::kTab) permission before providing a URL to this extension, which has unspecified impact and remote attack vectors."
10021,"void Compute(OpKernelContext* ctx) override {
const auto splits = ctx->input(0).flat<int64_t>();
const auto values = ctx->input(1).flat<Tidx>();
const Tensor& size_t = ctx->input(2);
const auto weights = ctx->input(3).flat<T>();
const int64_t weights_size = weights.size();

OP_REQUIRES(ctx, size_t.dims() == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
size_t.dims()));
Tidx size = size_t.scalar<Tidx>()();
OP_REQUIRES(
ctx, size >= 0,
errors::InvalidArgument(""size ("", size, "") must be non-negative""));

int num_rows = splits.size() - 1;
int num_values = values.size();
int batch_idx = 0;

OP_REQUIRES(ctx, splits(0) == 0,
errors::InvalidArgument(""Splits must start with 0, not with "",
splits(0)));

OP_REQUIRES(ctx, splits(num_rows) == num_values,
errors::InvalidArgument(
""Splits must end with the number of values, got "",
splits(num_rows), "" instead of "", num_values));

Tensor* out_t;
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
functor::SetZeroFunctor<Device, T> fill;
fill(ctx->eigen_device<Device>(), out_t->flat<T>());
const auto out = out_t->matrix<T>();

for (int idx = 0; idx < num_values; ++idx) {
while (idx >= splits(batch_idx)) {
batch_idx++;
}
Tidx bin = values(idx);
OP_REQUIRES(ctx, bin >= 0,
errors::InvalidArgument(""Input must be non-negative""));
if (bin < size) {
if (binary_output_) {
out(batch_idx - 1, bin) = T(1);
} else {
T value = (weights_size > 0) ? weights(idx) : T(1);
out(batch_idx - 1, bin) += value;
}
}
}
}",[20],"TensorFlow is an open source platform for machine learning. If `RaggedBincount` is given an empty input tensor `splits`, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 7a4591fd4f065f4fa903593bc39b2f79530a74b8. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
198523," client_x11_display_valid(const char *display)
  {
  	size_t i, dlen;
  
 	if (display == NULL)
 		return 0;
 
  	dlen = strlen(display);
  	for (i = 0; i < dlen; i++) {
  		if (!isalnum((u_char)display[i]) &&
 		}
 	}","[5, 6, 7]","The client in OpenSSH before 7.2 mishandles failed cookie generation for untrusted X11 forwarding and relies on the local X11 server for access-control decisions, which allows remote X11 clients to trigger a fallback and obtain trusted X11 forwarding privileges by leveraging configuration issues on this X11 server, as demonstrated by lack of the SECURITY extension on this X11 server."
206162," png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
 {
    png_bytep best_row;
 #ifdef PNG_WRITE_FILTER_SUPPORTED
    png_bytep prev_row, row_buf;
     png_uint_32 mins, bpp;
     png_byte filter_to_do = png_ptr->do_filter;
     png_uint_32 row_bytes = row_info->rowbytes;
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   int num_p_filters = (int)png_ptr->num_prev_filters;
#endif 
  
     png_debug(1, ""in png_write_find_filter"");
  
#ifndef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
  if (png_ptr->row_number == 0 && filter_to_do == PNG_ALL_FILTERS)
  {
       
      filter_to_do &= ~(PNG_FILTER_UP | PNG_FILTER_PAETH);
  }
#endif 
      
     bpp = (row_info->pixel_depth + 7) >> 3;
  
    prev_row = png_ptr->prev_row;
 #endif
    best_row = png_ptr->row_buf;
 #ifdef PNG_WRITE_FILTER_SUPPORTED
    row_buf = best_row;
    mins = PNG_MAXSUM;
 
     
 
 
     
    if ((filter_to_do & PNG_FILTER_NONE) &&
        filter_to_do != PNG_FILTER_NONE)
    {
       png_bytep rp;
       png_uint_32 sum = 0;
       png_uint_32 i;
       int v;
 
       for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
       {
          v = *rp;
           sum += (v < 128) ? v : 256 - v;
        }
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         png_uint_32 sumhi, sumlo;
         int j;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;  
          
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
          
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;
         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
        mins = sum;
     }
  
     
    if (filter_to_do == PNG_FILTER_SUB)
     
    {
       png_bytep rp, lp, dp;
       png_uint_32 i;
       for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
            i++, rp++, dp++)
       {
          *dp = *rp;
       }
       for (lp = row_buf + 1; i < row_bytes;
          i++, rp++, lp++, dp++)
       {
          *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
       }
       best_row = png_ptr->sub_row;
    }
 
    else if (filter_to_do & PNG_FILTER_SUB)
    {
       png_bytep rp, dp, lp;
       png_uint_32 sum = 0, lmins = mins;
        png_uint_32 i;
        int v;
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
       
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif
        for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
             i++, rp++, dp++)
        {
          v = *dp = *rp;
 
          sum += (v < 128) ? v : 256 - v;
       }
       for (lp = row_buf + 1; i < row_bytes;
          i++, rp++, lp++, dp++)
       {
          v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
 
          if (sum > lmins)   
              break;
        }
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
        if (sum < mins)
        {
           mins = sum;
          best_row = png_ptr->sub_row;
       }
    }
 
     
    if (filter_to_do == PNG_FILTER_UP)
    {
       png_bytep rp, dp, pp;
       png_uint_32 i;
 
       for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
            pp = prev_row + 1; i < row_bytes;
            i++, rp++, pp++, dp++)
       {
          *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
       }
       best_row = png_ptr->up_row;
    }
 
    else if (filter_to_do & PNG_FILTER_UP)
    {
       png_bytep rp, dp, pp;
       png_uint_32 sum = 0, lmins = mins;
        png_uint_32 i;
        int v;
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif
        for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
             pp = prev_row + 1; i < row_bytes; i++)
        {
          v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
 
          if (sum > lmins)   
              break;
        }
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
        if (sum < mins)
        {
           mins = sum;
          best_row = png_ptr->up_row;
       }
    }
 
     
    if (filter_to_do == PNG_FILTER_AVG)
    {
       png_bytep rp, dp, pp, lp;
       png_uint_32 i;
       for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
          *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
       }
       for (lp = row_buf + 1; i < row_bytes; i++)
       {
          *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
                  & 0xff);
       }
       best_row = png_ptr->avg_row;
    }
 
    else if (filter_to_do & PNG_FILTER_AVG)
    {
       png_bytep rp, dp, pp, lp;
       png_uint_32 sum = 0, lmins = mins;
        png_uint_32 i;
        int v;
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif
        for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
             pp = prev_row + 1; i < bpp; i++)
        {
          v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
       }
       for (lp = row_buf + 1; i < row_bytes; i++)
       {
          v = *dp++ =
           (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
 
          if (sum > lmins)   
              break;
        }
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
        if (sum < mins)
        {
           mins = sum;
          best_row = png_ptr->avg_row;
       }
    }
 
     
    if (filter_to_do == PNG_FILTER_PAETH)
    {
       png_bytep rp, dp, pp, cp, lp;
       png_uint_32 i;
       for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
            pp = prev_row + 1; i < bpp; i++)
       {
          *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
       }
 
       for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
       {
          int a, b, c, pa, pb, pc, p;
 
          b = *pp++;
          c = *cp++;
          a = *lp++;
 
          p = b - c;
          pc = a - c;
 
 #ifdef PNG_USE_ABS
          pa = abs(p);
          pb = abs(pc);
          pc = abs(p + pc);
 #else
          pa = p < 0 ? -p : p;
          pb = pc < 0 ? -pc : pc;
          pc = (p + pc) < 0 ? -(p + pc) : p + pc;
 #endif
 
          p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
 
          *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
       }
       best_row = png_ptr->paeth_row;
    }
 
    else if (filter_to_do & PNG_FILTER_PAETH)
    {
       png_bytep rp, dp, pp, cp, lp;
       png_uint_32 sum = 0, lmins = mins;
        png_uint_32 i;
        int v;
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif
        for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
             pp = prev_row + 1; i < bpp; i++)
        {
          v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
       }
 
       for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
       {
          int a, b, c, pa, pb, pc, p;
 
          b = *pp++;
          c = *cp++;
          a = *lp++;
 
 #ifndef PNG_SLOW_PAETH
          p = b - c;
          pc = a - c;
 #ifdef PNG_USE_ABS
          pa = abs(p);
          pb = abs(pc);
          pc = abs(p + pc);
 #else
          pa = p < 0 ? -p : p;
          pb = pc < 0 ? -pc : pc;
          pc = (p + pc) < 0 ? -(p + pc) : p + pc;
 #endif
          p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
 #else  
          p = a + b - c;
          pa = abs(p - a);
          pb = abs(p - b);
          pc = abs(p - c);
          if (pa <= pb && pa <= pc)
             p = a;
          else if (pb <= pc)
             p = b;
          else
             p = c;
 #endif  
 
          v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
 
          sum += (v < 128) ? v : 256 - v;
 
          if (sum > lmins)   
              break;
        }
  
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
        if (sum < mins)
        {
           best_row = png_ptr->paeth_row;
       }
    }
 #endif  
      
  
     png_write_filtered_row(png_ptr, best_row);
#ifdef PNG_WRITE_FILTER_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
    
   if (png_ptr->num_prev_filters > 0)
   {
      int j;
      for (j = 1; j < num_p_filters; j++)
      {
         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
      }
      png_ptr->prev_filters[j] = best_row[0];
   }
#endif
#endif  
  }","[9, 10, 11, 15, 16, 17, 18, 19, 20, 21, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
203344," static int amd_gpio_probe(struct platform_device *pdev)
 {
 	int ret = 0;
 	int irq_base;
 	struct resource *res;
 	struct amd_gpio *gpio_dev;
 
 	gpio_dev = devm_kzalloc(&pdev->dev,
 				sizeof(struct amd_gpio), GFP_KERNEL);
 	if (!gpio_dev)
 		return -ENOMEM;
 
 	spin_lock_init(&gpio_dev->lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, ""Failed to get gpio io resource.\n"");
 		return -EINVAL;
 	}
 
 	gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,
 						resource_size(res));
 	if (!gpio_dev->base)
 		return -ENOMEM;
 
 	irq_base = platform_get_irq(pdev, 0);
 	if (irq_base < 0) {
 		dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n"");
 		return -EINVAL;
 	}
 
 	gpio_dev->pdev = pdev;
 	gpio_dev->gc.direction_input	= amd_gpio_direction_input;
 	gpio_dev->gc.direction_output	= amd_gpio_direction_output;
 	gpio_dev->gc.get			= amd_gpio_get_value;
 	gpio_dev->gc.set			= amd_gpio_set_value;
 	gpio_dev->gc.set_debounce	= amd_gpio_set_debounce;
 	gpio_dev->gc.dbg_show		= amd_gpio_dbg_show;
 
 	gpio_dev->gc.base			= 0;
 	gpio_dev->gc.label			= pdev->name;
 	gpio_dev->gc.owner			= THIS_MODULE;
 	gpio_dev->gc.parent			= &pdev->dev;
 	gpio_dev->gc.ngpio			= TOTAL_NUMBER_OF_PINS;
 #if defined(CONFIG_OF_GPIO)
 	gpio_dev->gc.of_node			= pdev->dev.of_node;
 #endif
 
 	gpio_dev->groups = kerncz_groups;
  	gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);
  
  	amd_pinctrl_desc.name = dev_name(&pdev->dev);
	gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
					&pdev->dev, gpio_dev);
 	gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
 						gpio_dev);
  	if (IS_ERR(gpio_dev->pctrl)) {
  		dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n"");
  		return PTR_ERR(gpio_dev->pctrl);
  	}
  
  	ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);
  	if (ret)
		goto out1;
 		return ret;
  
  	ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),
  				0, 0, TOTAL_NUMBER_OF_PINS);
 	if (ret) {
 		dev_err(&pdev->dev, ""Failed to add pin range\n"");
 		goto out2;
 	}
 
 	ret = gpiochip_irqchip_add(&gpio_dev->gc,
 				&amd_gpio_irqchip,
 				0,
 				handle_simple_irq,
 				IRQ_TYPE_NONE);
 	if (ret) {
 		dev_err(&pdev->dev, ""could not add irqchip\n"");
 		ret = -ENODEV;
 		goto out2;
 	}
 
 	gpiochip_set_chained_irqchip(&gpio_dev->gc,
 				 &amd_gpio_irqchip,
 				 irq_base,
 				 amd_gpio_irq_handler);
 
 	platform_set_drvdata(pdev, gpio_dev);
 
 	dev_dbg(&pdev->dev, ""amd gpio driver loaded\n"");
 	return ret;
 
  out2:
  	gpiochip_remove(&gpio_dev->gc);
  
out1:
	pinctrl_unregister(gpio_dev->pctrl);
  	return ret;
  }","[55, 56, 65, 53, 54, 64, 98, 99]","In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free."
200866," static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 {
 	struct encrypted_key_payload *epayload = key->payload.data[0];
 	struct encrypted_key_payload *new_epayload;
 	char *buf;
 	char *new_master_desc = NULL;
 	const char *format = NULL;
  	size_t datalen = prep->datalen;
  	int ret = 0;
  
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
 	if (key_is_negative(key))
  		return -ENOKEY;
  	if (datalen <= 0 || datalen > 32767 || !prep->data)
  		return -EINVAL;
 
 	buf = kmalloc(datalen + 1, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
 	buf[datalen] = 0;
 	memcpy(buf, prep->data, datalen);
 	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
 	if (ret < 0)
 		goto out;
 
 	ret = valid_master_desc(new_master_desc, epayload->master_desc);
 	if (ret < 0)
 		goto out;
 
 	new_epayload = encrypted_key_alloc(key, epayload->format,
 					   new_master_desc, epayload->datalen);
 	if (IS_ERR(new_epayload)) {
 		ret = PTR_ERR(new_epayload);
 		goto out;
 	}
 
 	__ekey_init(new_epayload, epayload->format, new_master_desc,
 		    epayload->datalen);
 
 	memcpy(new_epayload->iv, epayload->iv, ivsize);
 	memcpy(new_epayload->payload_data, epayload->payload_data,
 	       epayload->payload_datalen);
 
 	rcu_assign_keypointer(key, new_epayload);
 	call_rcu(&epayload->rcu, encrypted_rcu_free);
 out:
 	kzfree(buf);
 	return ret;
 }","[12, 11]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
204949,"  void SocketStream::set_context(URLRequestContext* context) {
  const URLRequestContext* prev_context = context_.get();
   const URLRequestContext* prev_context = context_;
  
  if (context) {
    context_ = context->AsWeakPtr();
  } else {
    context_.reset();
  }
   context_ = context;
  
    if (prev_context != context) {
      if (prev_context && pac_request_) {
       prev_context->proxy_service()->CancelPacRequest(pac_request_);
       pac_request_ = NULL;
     }
 
     net_log_.EndEvent(NetLog::TYPE_REQUEST_ALIVE);
     net_log_ = BoundNetLog();
 
     if (context) {
       net_log_ = BoundNetLog::Make(
           context->net_log(),
           NetLog::SOURCE_SOCKET_STREAM);
 
       net_log_.BeginEvent(NetLog::TYPE_REQUEST_ALIVE);
     }
   }
  }","[3, 10, 2, 5, 6, 7, 8, 9]",Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote servers to execute arbitrary code via crafted response traffic after a URL request.
200948," static av_cold int rl2_read_header(AVFormatContext *s)
 {
     AVIOContext *pb = s->pb;
     AVStream *st;
     unsigned int frame_count;
     unsigned int audio_frame_counter = 0;
     unsigned int video_frame_counter = 0;
     unsigned int back_size;
     unsigned short sound_rate;
     unsigned short rate;
     unsigned short channels;
     unsigned short def_sound_size;
     unsigned int signature;
     unsigned int pts_den = 11025;  
     unsigned int pts_num = 1103;
     unsigned int* chunk_offset = NULL;
     int* chunk_size = NULL;
     int* audio_size = NULL;
     int i;
     int ret = 0;
 
     avio_skip(pb,4);           
     back_size = avio_rl32(pb);  
     signature = avio_rb32(pb);
     avio_skip(pb, 4);          
     frame_count = avio_rl32(pb);
 
      
     if(back_size > INT_MAX/2  || frame_count > INT_MAX / sizeof(uint32_t))
         return AVERROR_INVALIDDATA;
 
     avio_skip(pb, 2);          
     sound_rate = avio_rl16(pb);
     rate = avio_rl16(pb);
     channels = avio_rl16(pb);
     def_sound_size = avio_rl16(pb);
 
      
     st = avformat_new_stream(s, NULL);
     if(!st)
          return AVERROR(ENOMEM);
 
     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
     st->codecpar->codec_id = AV_CODEC_ID_RL2;
     st->codecpar->codec_tag = 0;   
     st->codecpar->width = 320;
     st->codecpar->height = 200;
 
      
     st->codecpar->extradata_size = EXTRADATA1_SIZE;
 
     if(signature == RLV3_TAG && back_size > 0)
         st->codecpar->extradata_size += back_size;
 
     if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0)
         return AVERROR(ENOMEM);
 
      
     if(sound_rate){
         if (!channels || channels > 42) {
             av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels);
             return AVERROR_INVALIDDATA;
         }
 
         pts_num = def_sound_size;
         pts_den = rate;
 
         st = avformat_new_stream(s, NULL);
         if (!st)
             return AVERROR(ENOMEM);
         st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
         st->codecpar->codec_id = AV_CODEC_ID_PCM_U8;
         st->codecpar->codec_tag = 1;
         st->codecpar->channels = channels;
         st->codecpar->bits_per_coded_sample = 8;
         st->codecpar->sample_rate = rate;
         st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *
             st->codecpar->bits_per_coded_sample;
         st->codecpar->block_align = st->codecpar->channels *
             st->codecpar->bits_per_coded_sample / 8;
         avpriv_set_pts_info(st,32,1,rate);
     }
 
     avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den);
 
     chunk_size =   av_malloc(frame_count * sizeof(uint32_t));
     audio_size =   av_malloc(frame_count * sizeof(uint32_t));
     chunk_offset = av_malloc(frame_count * sizeof(uint32_t));
 
     if(!chunk_size || !audio_size || !chunk_offset){
         av_free(chunk_size);
         av_free(audio_size);
         av_free(chunk_offset);
         return AVERROR(ENOMEM);
      }
  
       
    for(i=0; i < frame_count;i++)
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          chunk_size[i] = avio_rl32(pb);
    for(i=0; i < frame_count;i++)
     }
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          chunk_offset[i] = avio_rl32(pb);
    for(i=0; i < frame_count;i++)
     }
     for(i=0; i < frame_count;i++) {
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
          audio_size[i] = avio_rl32(pb) & 0xFFFF;
     }
  
       
      for(i=0;i<frame_count;i++){
         if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){
             ret = AVERROR_INVALIDDATA;
             break;
         }
 
         if(sound_rate && audio_size[i]){
             av_add_index_entry(s->streams[1], chunk_offset[i],
                 audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME);
             audio_frame_counter += audio_size[i] / channels;
         }
         av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i],
             video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME);
         ++video_frame_counter;
     }
 
 
     av_free(chunk_size);
     av_free(audio_size);
     av_free(chunk_offset);
 
     return ret;
 }","[99, 100, 101, 104, 105, 106, 107, 110, 111, 112, 113, 115, 98, 103, 109]","In libavformat/rl2.c in FFmpeg 3.3.3, a DoS in rl2_read_header() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted RL2 file, which claims a large *frame_count* field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops."
201040," mobility_opt_print(netdissect_options *ndo,
                    const u_char *bp, const unsigned len)
 {
 	unsigned i, optlen;
 
 	for (i = 0; i < len; i += optlen) {
 		ND_TCHECK(bp[i]);
 		if (bp[i] == IP6MOPT_PAD1)
 			optlen = 1;
 		else {
 			if (i + 1 < len) {
 				ND_TCHECK(bp[i + 1]);
 				optlen = bp[i + 1] + 2;
 			}
 			else
 				goto trunc;
 		}
 		if (i + optlen > len)
 			goto trunc;
 		ND_TCHECK(bp[i + optlen]);
 
 		switch (bp[i]) {
 		case IP6MOPT_PAD1:
 			ND_PRINT((ndo, ""(pad1)""));
 			break;
 		case IP6MOPT_PADN:
 			if (len - i < IP6MOPT_MINLEN) {
 				ND_PRINT((ndo, ""(padn: trunc)""));
 				goto trunc;
 			}
 			ND_PRINT((ndo, ""(padn)""));
 			break;
 		case IP6MOPT_REFRESH:
 			if (len - i < IP6MOPT_REFRESH_MINLEN) {
 				ND_PRINT((ndo, ""(refresh: trunc)""));
  				goto trunc;
  			}
  			 
 			ND_TCHECK_16BITS(&bp[i+2]);
  			ND_PRINT((ndo, ""(refresh: %u)"",
  				EXTRACT_16BITS(&bp[i+2]) << 2));
  			break;
 		case IP6MOPT_ALTCOA:
 			if (len - i < IP6MOPT_ALTCOA_MINLEN) {
 				ND_PRINT((ndo, ""(altcoa: trunc)""));
 				goto trunc;
 			}
 			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));
 			break;
 		case IP6MOPT_NONCEID:
 			if (len - i < IP6MOPT_NONCEID_MINLEN) {
 				ND_PRINT((ndo, ""(ni: trunc)""));
 				goto trunc;
 			}
 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));
 			break;
 		case IP6MOPT_AUTH:
 			if (len - i < IP6MOPT_AUTH_MINLEN) {
 				ND_PRINT((ndo, ""(auth: trunc)""));
 				goto trunc;
 			}
 			ND_PRINT((ndo, ""(auth)""));
 			break;
 		default:
 			if (len - i < IP6MOPT_MINLEN) {
 				ND_PRINT((ndo, ""(sopt_type %u: trunc)"", bp[i]));
 				goto trunc;
 			}
 			ND_PRINT((ndo, ""(type-0x%02x: len=%u)"", bp[i], bp[i + 1]));
 			break;
 		}
 	}
 	return 0;
 
 trunc:
 	return 1;
 }",[39],The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().
8298,"void Compute(OpKernelContext* c) override {
core::RefCountPtr<Var> v;
OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));
OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get()));





tf_shared_lock ml(*v->mu());
const Tensor& params = *v->tensor();
const Tensor& indices = c->input(1);
OP_REQUIRES(
c, TensorShapeUtils::IsVectorOrHigher(params.shape()),
errors::InvalidArgument(""params must be at least 1 dimensional""));


const int64_t N = indices.NumElements();
OP_REQUIRES(
c, params.dim_size(0) <= std::numeric_limits<Index>::max(),
errors::InvalidArgument(""params.shape[0] too large for "",
DataTypeString(DataTypeToEnum<Index>::v()),
"" indexing: "", params.dim_size(0), "" > "",
std::numeric_limits<Index>::max()));



TensorShape result_shape;
for (int i = 0; i < batch_dims_; ++i) {
result_shape.AddDim(params.dim_size(i));
}
for (int i = batch_dims_; i < indices.dims(); ++i) {
result_shape.AddDim(indices.dim_size(i));
}
for (int i = batch_dims_ + 1; i < params.dims(); ++i) {
result_shape.AddDim(params.dim_size(i));
}

Tensor* out = nullptr;
Tensor tmp;
if (params.dtype() == DT_VARIANT) {
tmp = Tensor(DT_VARIANT, result_shape);
c->set_output(0, tmp);
out = &tmp;
} else {
OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out));
}

if (N > 0) {
Tensor tmp_indices;


const Tensor* op_indices = &indices;
if (batch_dims_ > 0) {
OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),
&tmp_indices));
functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;
copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),
indices.flat<Index>());

AddBatchOffsets(&tmp_indices, params);
op_indices = &tmp_indices;
}

int64_t gather_dim_size = 1;
for (int idx = 0; idx <= batch_dims_; ++idx) {
gather_dim_size *= params.dim_size(idx);
}
int64_t inner_size = 1;
for (int i = batch_dims_ + 1; i < params.dims(); ++i) {
inner_size *= params.dim_size(i);
}
auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size});
const auto indices_flat = op_indices->flat<Index>();
auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N});

functor::GatherFunctor<Device, T, Index> functor;
int64_t bad_i = functor(c, params_flat, indices_flat, out_flat);

OP_REQUIRES(
c, bad_i < 0,
errors::InvalidArgument(
""indices"", SliceDebugString(indices.shape(), bad_i), "" = "",
indices_flat(bad_i), "" is not in [0, "", params.dim_size(0), "")""));
}
}",[18],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can trigger a crash via a `CHECK`-fail in debug builds of TensorFlow using `tf.raw_ops.ResourceGather` or a read from outside the bounds of heap allocated data in the same API in a release build. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/resource_variable_ops.cc#L660-L668) does not check that the `batch_dims` value that the user supplies is less than the rank of the input tensor. Since the implementation uses several for loops over the dimensions of `tensor`, this results in reading data from outside the bounds of heap allocated buffer backing the tensor. We have patched the issue in GitHub commit bc9c546ce7015c57c2f15c168b3d9201de679a1d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
199442," int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)
 int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,
 			   int relocated)
  {
	int result = parse_rock_ridge_inode_internal(de, inode, 0);
 	int flags = relocated ? RR_RELOC_DE : 0;
 	int result = parse_rock_ridge_inode_internal(de, inode, flags);
  
  	 
  	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
  	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
		result = parse_rock_ridge_inode_internal(de, inode, 14);
 		result = parse_rock_ridge_inode_internal(de, inode,
 							 flags | RR_REGARD_XA);
  	}
  	return result;
  }","[2, 3, 6, 7, 13, 14, 5, 12]",The parse_rock_ridge_inode_internal function in fs/isofs/rock.c in the Linux kernel through 3.16.1 allows local users to cause a denial of service (unkillable mount process) via a crafted iso9660 image with a self-referential CL entry.
198621," static void nbd_recv_coroutines_enter_all(NBDClientSession *s)
 static void nbd_recv_coroutines_enter_all(BlockDriverState *bs)
  {
     NBDClientSession *s = nbd_get_client_session(bs);
      int i;
  
      for (i = 0; i < MAX_NBD_REQUESTS; i++) {
             qemu_coroutine_enter(s->recv_coroutine[i]);
              qemu_coroutine_enter(s->recv_coroutine[i]);
          }
      }","[2, 4]","An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service."
203803,"  RTCPeerConnectionHandlerDummy::RTCPeerConnectionHandlerDummy(RTCPeerConnectionHandlerClient* client)
      : m_client(client)
  {
    ASSERT_UNUSED(m_client, m_client);
     ASSERT(m_client);
  }","[5, 4]","Google V8, as used in Google Chrome before 14.0.835.163, does not properly perform object sealing, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that leverage *type confusion.*"
5870,"void handle_usb_rx(const void *msg, size_t len)
{
if (msg_tiny_flag) {
uint8_t buf[64];
memcpy(buf, msg, sizeof(buf));

uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
uint32_t msgSize = buf[8]        |
((uint32_t)buf[7]) <<  8 |
((uint32_t)buf[6]) << 16 |
((uint32_t)buf[5]) << 24;

if (msgSize > 64 - 9) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
return;
}


const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);
if (!entry) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
return;
}

tiny_dispatch(entry, buf + 9, msgSize);
} else {
usb_rx_helper(msg, len, NORMAL_MSG);
}
}","[19, 20, 21, 22, 25, 25]",Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.
203275," static ssize_t WritePSDChannels(const PSDInfo *psd_info,
   const ImageInfo *image_info,Image *image,Image *next_image,
   MagickOffsetType size_offset,const MagickBooleanType separate)
 {
   Image
     *mask;
 
   MagickOffsetType
     rows_offset;
 
   size_t
     channels,
     count,
     length,
     offset_length;
 
   unsigned char
     *compact_pixels;
 
   count=0;
   offset_length=0;
   rows_offset=0;
    compact_pixels=(unsigned char *) NULL;
    if (next_image->compression == RLECompression)
      {
      compact_pixels=AcquireCompactPixels(image);
       compact_pixels=AcquireCompactPixels(next_image);
        if (compact_pixels == (unsigned char *) NULL)
          return(0);
      }
   channels=1;
   if (separate == MagickFalse)
     {
       if (next_image->storage_class != PseudoClass)
         {
           if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)
             channels=next_image->colorspace == CMYKColorspace ? 4 : 3;
           if (next_image->matte != MagickFalse)
             channels++;
         }
       rows_offset=TellBlob(image)+2;
       count+=WriteCompressionStart(psd_info,image,next_image,channels);
       offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));
     }
   size_offset+=2;
   if (next_image->storage_class == PseudoClass)
     {
       length=WritePSDChannel(psd_info,image_info,image,next_image,
         IndexQuantum,compact_pixels,rows_offset,separate);
       if (separate != MagickFalse)
         size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
       else
         rows_offset+=offset_length;
       count+=length;
     }
   else
     {
       if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)
         {
           length=WritePSDChannel(psd_info,image_info,image,next_image,
             GrayQuantum,compact_pixels,rows_offset,separate);
           if (separate != MagickFalse)
             size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
           else
             rows_offset+=offset_length;
           count+=length;
         }
       else
         {
           if (next_image->colorspace == CMYKColorspace)
             (void) NegateImage(next_image,MagickFalse);
 
           length=WritePSDChannel(psd_info,image_info,image,next_image,
             RedQuantum,compact_pixels,rows_offset,separate);
           if (separate != MagickFalse)
             size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
           else
             rows_offset+=offset_length;
           count+=length;
 
           length=WritePSDChannel(psd_info,image_info,image,next_image,
             GreenQuantum,compact_pixels,rows_offset,separate);
           if (separate != MagickFalse)
             size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
           else
             rows_offset+=offset_length;
           count+=length;
 
           length=WritePSDChannel(psd_info,image_info,image,next_image,
             BlueQuantum,compact_pixels,rows_offset,separate);
           if (separate != MagickFalse)
             size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
           else
             rows_offset+=offset_length;
           count+=length;
 
           if (next_image->colorspace == CMYKColorspace)
             {
               length=WritePSDChannel(psd_info,image_info,image,next_image,
                 BlackQuantum,compact_pixels,rows_offset,separate);
               if (separate != MagickFalse)
                 size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
               else
                 rows_offset+=offset_length;
               count+=length;
             }
         }
       if (next_image->matte != MagickFalse)
         {
           length=WritePSDChannel(psd_info,image_info,image,next_image,
             AlphaQuantum,compact_pixels,rows_offset,separate);
           if (separate != MagickFalse)
             size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
           else
             rows_offset+=offset_length;
           count+=length;
         }
     }
   compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
   if (next_image->colorspace == CMYKColorspace)
     (void) NegateImage(next_image,MagickFalse);
   if (separate != MagickFalse)
     {
       const char
         *property;
 
       property=GetImageArtifact(next_image,""psd:opacity-mask"");
       if (property != (const char *) NULL)
         {
           mask=(Image *) GetImageRegistry(ImageRegistryType,property,
             &image->exception);
           if (mask != (Image *) NULL)
             {
               if (mask->compression == RLECompression)
                 {
                   compact_pixels=AcquireCompactPixels(mask);
                   if (compact_pixels == (unsigned char *) NULL)
                     return(0);
                 }
               length=WritePSDChannel(psd_info,image_info,image,mask,
                 RedQuantum,compact_pixels,rows_offset,MagickTrue);
               (void) WritePSDSize(psd_info,image,length,size_offset);
               count+=length;
               compact_pixels=(unsigned char *) RelinquishMagickMemory(
                 compact_pixels);
             }
         }
     }
   return(count);
 }","[27, 26]","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
203280," static void setup_test_dir(char *tmp_dir, const char *files, ...) {
         va_list ap;
 
         assert_se(mkdtemp(tmp_dir) != NULL);
 
          va_start(ap, files);
          while (files != NULL) {
                  _cleanup_free_ char *path = strappend(tmp_dir, files);
                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);
                 assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID) == 0);
                  files = va_arg(ap, const char *);
          }
          va_end(ap);
 }","[10, 9]","A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229."
208174,"  void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
     std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);
  
      s->id = local_socket_next_id++;
  
      if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
         fatal(""local socket id overflow"");
      }
  
      insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
  }","[3, 9, 2, 8, 13]","The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842."
201313," nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,
 					struct nfsd3_readdirargs *args)
 {
 	p = decode_fh(p, &args->fh);
 	if (!p)
 		return 0;
 	p = xdr_decode_hyper(p, &args->cookie);
  	args->verf   = p; p += 2;
  	args->dircount = ~0;
  	args->count  = ntohl(*p++);
 
 	if (!xdr_argsize_check(rqstp, p))
 		return 0;
 
  	args->count  = min_t(u32, args->count, PAGE_SIZE);
  	args->buffer = page_address(*(rqstp->rq_next_page++));
  
	return xdr_argsize_check(rqstp, p);
 	return 1;
  }","[11, 12, 13, 14, 19, 18]","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
200161,"  int perf_event_task_disable(void)
  {
 	struct perf_event_context *ctx;
  	struct perf_event *event;
  
  	mutex_lock(&current->perf_event_mutex);
	list_for_each_entry(event, &current->perf_event_list, owner_entry)
		perf_event_for_each_child(event, perf_event_disable);
 	list_for_each_entry(event, &current->perf_event_list, owner_entry) {
 		ctx = perf_event_ctx_lock(event);
 		perf_event_for_each_child(event, _perf_event_disable);
 		perf_event_ctx_unlock(event, ctx);
 	}
  	mutex_unlock(&current->perf_event_mutex);
  
  	return 0;
 }","[3, 9, 10, 11, 12, 13, 7, 8]","kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224."
208164,"  status_t OMXNodeInstance::updateNativeHandleInMeta(
         OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {
  Mutex::Autolock autoLock(mLock);
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
  if (header == NULL) {
         ALOGE(""b/25884056"");
  return BAD_VALUE;
  }
 
  if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
  return BAD_VALUE;
  }
 
 
      BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);
      sp<ABuffer> data = bufferMeta->getBuffer(
            header, portIndex == kPortIndexInput  , false  );
             header, false  , false  );
      bufferMeta->setNativeHandle(nativeHandle);
      if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource
              && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {
  VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());
         metadata.eType = mMetadataType[portIndex];
         metadata.pHandle =
             nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());
  } else {
         CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, ""%s:%u, %#x bad type (%d) or size (%zu)"",
             portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());
  return BAD_VALUE;
  }
 
     CLOG_BUFFER(updateNativeHandleInMeta, ""%s:%u, %#x := %p"",
             portString(portIndex), portIndex, buffer,
             nativeHandle == NULL ? NULL : nativeHandle->handle());
  return OK;
 }","[18, 17]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
8249,"static void mbochs_remove(struct mdev_device *mdev)
{
struct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);

mbochs_used_mbytes -= mdev_state->type->mbytes;
vfio_unregister_group_dev(&mdev_state->vdev);
kfree(mdev_state->pages);
kfree(mdev_state->vconfig);
kfree(mdev_state);
}","[5, 7]",A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.
201096,"  ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,
  	      const struct isakmp_gen *ext, u_int item_len,
	      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,
	      uint32_t proto0 _U_, int depth)
 	      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,
 	      uint32_t proto0 _U_, int depth _U_)
  {
  	const struct ikev1_pl_n *p;
  	struct ikev1_pl_n n;
 	const u_char *cp;
 	const u_char *ep2;
 	uint32_t doi;
 	uint32_t proto;
 	static const char *notify_error_str[] = {
 		NULL,				""INVALID-PAYLOAD-TYPE"",
 		""DOI-NOT-SUPPORTED"",		""SITUATION-NOT-SUPPORTED"",
 		""INVALID-COOKIE"",		""INVALID-MAJOR-VERSION"",
 		""INVALID-MINOR-VERSION"",	""INVALID-EXCHANGE-TYPE"",
 		""INVALID-FLAGS"",		""INVALID-MESSAGE-ID"",
 		""INVALID-PROTOCOL-ID"",		""INVALID-SPI"",
 		""INVALID-TRANSFORM-ID"",		""ATTRIBUTES-NOT-SUPPORTED"",
 		""NO-PROPOSAL-CHOSEN"",		""BAD-PROPOSAL-SYNTAX"",
 		""PAYLOAD-MALFORMED"",		""INVALID-KEY-INFORMATION"",
 		""INVALID-ID-INFORMATION"",	""INVALID-CERT-ENCODING"",
 		""INVALID-CERTIFICATE"",		""CERT-TYPE-UNSUPPORTED"",
 		""INVALID-CERT-AUTHORITY"",	""INVALID-HASH-INFORMATION"",
 		""AUTHENTICATION-FAILED"",	""INVALID-SIGNATURE"",
 		""ADDRESS-NOTIFICATION"",		""NOTIFY-SA-LIFETIME"",
 		""CERTIFICATE-UNAVAILABLE"",	""UNSUPPORTED-EXCHANGE-TYPE"",
 		""UNEQUAL-PAYLOAD-LENGTHS"",
 	};
 	static const char *ipsec_notify_error_str[] = {
 		""RESERVED"",
 	};
 	static const char *notify_status_str[] = {
 		""CONNECTED"",
 	};
 	static const char *ipsec_notify_status_str[] = {
 		""RESPONDER-LIFETIME"",		""REPLAY-STATUS"",
 		""INITIAL-CONTACT"",
 	};
  
 
  
 #define NOTIFY_ERROR_STR(x) \
 	STR_OR_ID((x), notify_error_str)
 
  
 #define IPSEC_NOTIFY_ERROR_STR(x) \
 	STR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)
 
  
 #define NOTIFY_STATUS_STR(x) \
 	STR_OR_ID((u_int)((x) - 16384), notify_status_str)
 
  
 #define IPSEC_NOTIFY_STATUS_STR(x) \
 	STR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)
 
 	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_N)));
 
 	p = (const struct ikev1_pl_n *)ext;
 	ND_TCHECK(*p);
 	UNALIGNED_MEMCPY(&n, ext, sizeof(n));
 	doi = ntohl(n.doi);
 	proto = n.prot_id;
 	if (doi != 1) {
 		ND_PRINT((ndo,"" doi=%d"", doi));
 		ND_PRINT((ndo,"" proto=%d"", proto));
 		if (ntohs(n.type) < 8192)
 			ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
 		else if (ntohs(n.type) < 16384)
 			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 		else if (ntohs(n.type) < 24576)
 			ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
 		else
 			ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 		if (n.spi_size) {
 			ND_PRINT((ndo,"" spi=""));
 			if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
 				goto trunc;
 		}
 		return (const u_char *)(p + 1) + n.spi_size;
 	}
 
 	ND_PRINT((ndo,"" doi=ipsec""));
 	ND_PRINT((ndo,"" proto=%s"", PROTOIDSTR(proto)));
 	if (ntohs(n.type) < 8192)
 		ND_PRINT((ndo,"" type=%s"", NOTIFY_ERROR_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 16384)
 		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 24576)
 		ND_PRINT((ndo,"" type=%s"", NOTIFY_STATUS_STR(ntohs(n.type))));
 	else if (ntohs(n.type) < 32768)
 		ND_PRINT((ndo,"" type=%s"", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));
 	else
 		ND_PRINT((ndo,"" type=%s"", numstr(ntohs(n.type))));
 	if (n.spi_size) {
 		ND_PRINT((ndo,"" spi=""));
 		if (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))
 			goto trunc;
 	}
 
 	cp = (const u_char *)(p + 1) + n.spi_size;
  	ep2 = (const u_char *)p + item_len;
  
  	if (cp < ep) {
		ND_PRINT((ndo,"" orig=(""));
  		switch (ntohs(n.type)) {
  		case IPSECDOI_NTYPE_RESPONDER_LIFETIME:
  		    {
  			const struct attrmap *map = oakley_t_map;
  			size_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);
 			ND_PRINT((ndo,"" attrs=(""));
  			while (cp < ep && cp < ep2) {
  				cp = ikev1_attrmap_print(ndo, cp,
  					(ep < ep2) ? ep : ep2, map, nmap);
  			}
 			ND_PRINT((ndo,"")""));
  			break;
  		    }
  		case IPSECDOI_NTYPE_REPLAY_STATUS:
 			ND_PRINT((ndo,"" status=(""));
  			ND_PRINT((ndo,""replay detection %sabled"",
  				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));
			break;
		case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:
			if (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,
					    (const struct isakmp_gen *)cp, ep, phase, doi, proto,
					    depth) == NULL)
				return NULL;
 			ND_PRINT((ndo,"")""));
  			break;
  		default:
 			 
			isakmp_print(ndo, cp,
				     item_len - sizeof(*p) - n.spi_size,
				     NULL);
 			if (ndo->ndo_vflag > 3) {
 				ND_PRINT((ndo,"" data=(""));
 				if (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))
 					goto trunc;
 				ND_PRINT((ndo,"")""));
 			} else {
 				if (!ike_show_somedata(ndo, cp, ep))
 					goto trunc;
 			}
 			break;
  		}
		ND_PRINT((ndo,"")""));
  	}
  	return (const u_char *)ext + item_len;
  trunc:
 	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_N)));
 	return NULL;
 }","[5, 6, 114, 119, 123, 132, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 3, 4, 108, 126, 127, 128, 129, 130, 131, 136, 137, 138, 150]","The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions."
204121,"  AutoFillQueryXmlParser::AutoFillQueryXmlParser(
      std::vector<AutoFillFieldType>* field_types,
    UploadRequired* upload_required)
     UploadRequired* upload_required,
     std::string* experiment_id)
      : field_types_(field_types),
      upload_required_(upload_required) {
       upload_required_(upload_required),
       experiment_id_(experiment_id) {
    DCHECK(upload_required_);
   DCHECK(experiment_id_);
  }","[4, 5, 8, 9, 11, 3, 7]",Use-after-free vulnerability in the frame-loader implementation in Google Chrome before 10.0.648.204 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
201610," dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 static int dns_resolver_cmp(const struct key *key,
 			    const struct key_match_data *match_data)
  {
  	int slen, dlen, ret = 0;
  	const char *src = key->description, *dsp = match_data->raw_data;
 
 	kenter(""%s,%s"", src, dsp);
 
 	if (!src || !dsp)
 		goto no_match;
 
 	if (strcasecmp(src, dsp) == 0)
 		goto matched;
 
 	slen = strlen(src);
 	dlen = strlen(dsp);
 	if (slen <= 0 || dlen <= 0)
 		goto no_match;
 	if (src[slen - 1] == '.')
 		slen--;
 	if (dsp[dlen - 1] == '.')
 		dlen--;
 	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
 		goto no_match;
 
 matched:
 	ret = 1;
 no_match:
 	kleave("" = %d"", ret);
  	return ret;
  }","[3, 4, 2]","The KEYS subsystem in the Linux kernel before 3.18 allows local users to gain privileges or cause a denial of service (NULL pointer dereference and system crash) via vectors involving a NULL value for a certain match field, related to the keyring_search_iterator function in keyring.c."
208133," WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,
 
                             void *pv_api_ip,
                             void *pv_api_op)
  {
     ihevcd_cxa_create_ip_t *ps_create_ip;
      ihevcd_cxa_create_op_t *ps_create_op;
  
      WORD32 ret;
      codec_t *ps_codec;
     ps_create_ip = (ihevcd_cxa_create_ip_t *)pv_api_ip;
      ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;
  
      ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
     ps_codec_obj = NULL;
      ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);
  
       
    if((IV_FAIL == ret) && (NULL != ps_codec_obj))
     if(IV_FAIL == ret)
      {
        ihevcd_free_static_bufs(ps_codec_obj);
         if(NULL != ps_codec_obj)
         {
             if(ps_codec_obj->pv_codec_handle)
             {
                 ihevcd_free_static_bufs(ps_codec_obj);
             }
             else
             {
                 void (*pf_aligned_free)(void *pv_mem_ctxt, void *pv_buf);
                 void *pv_mem_ctxt;
 
                 pf_aligned_free = ps_create_ip->s_ivd_create_ip_t.pf_aligned_free;
                 pv_mem_ctxt  = ps_create_ip->s_ivd_create_ip_t.pv_mem_ctxt;
                 pf_aligned_free(pv_mem_ctxt, ps_codec_obj);
             }
         }
          ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
          ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
  
  return IV_FAIL;
  }
     ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;
     ret = ihevcd_init(ps_codec);
 
     TRACE_INIT(NULL);
     STATS_INIT();
 
  return ret;
 }","[6, 11, 15, 20, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 19, 22]","A vulnerability in the Android media framework (libhevc) related to handling ps_codec_obj memory allocation failures. Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-68299873."
206186," bool TabLifecycleUnitSource::TabLifecycleUnit::CanDiscard(
     DiscardReason reason,
     DecisionDetails* decision_details) const {
   DCHECK(decision_details->reasons().empty());
 
 
   if (!tab_strip_model_)
     return false;
 
   const LifecycleUnitState target_state =
       reason == DiscardReason::kProactive &&
               GetState() != LifecycleUnitState::FROZEN
           ? LifecycleUnitState::PENDING_DISCARD
           : LifecycleUnitState::DISCARDED;
   if (!IsValidStateChange(GetState(), target_state,
                           DiscardReasonToStateChangeReason(reason))) {
     return false;
   }
 
   if (GetWebContents()->IsCrashed())
     return false;
 
   if (!GetWebContents()->GetLastCommittedURL().is_valid() ||
       GetWebContents()->GetLastCommittedURL().is_empty()) {
     return false;
   }
 
   if (discard_count_ > 0) {
 #if defined(OS_CHROMEOS)
     if (reason != DiscardReason::kUrgent)
       return false;
 #else
     return false;
  #endif   
    }
  
 
 #if defined(OS_CHROMEOS)
   if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)
     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);
 #else
   if (tab_strip_model_->GetActiveWebContents() == GetWebContents())
     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);
 #endif   
 
   if (GetWebContents()->GetPageImportanceSignals().had_form_interaction)
     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_FORM_ENTRY);
 
   IsMediaTabImpl(decision_details);
 
   if (GetWebContents()->GetContentsMimeType() == ""application/pdf"")
     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_IS_PDF);
 
   if (!IsAutoDiscardable()) {
     decision_details->AddReason(
          DecisionFailureReason::LIVE_STATE_EXTENSION_DISALLOWED);
    }
  
    
    
    
   if (reason != DiscardReason::kUrgent) {
     CheckIfTabCanCommunicateWithUserWhileInBackground(GetWebContents(),
                                                       decision_details);
   }
 
    if (decision_details->reasons().empty()) {
      decision_details->AddReason(
          DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE);
     DCHECK(decision_details->IsPositive());
   }
   return decision_details->IsPositive();
 }","[59, 60, 61, 62, 63, 64, 65, 66]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
200536," static bool check_underflow(const struct arpt_entry *e)
 {
  	const struct xt_entry_target *t;
  	unsigned int verdict;
  
	if (!unconditional(&e->arp))
 	if (!unconditional(e))
  		return false;
  	t = arpt_get_target_c(e);
  	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
 		return false;
 	verdict = ((struct xt_standard_target *)t)->verdict;
 	verdict = -verdict - 1;
 	return verdict == NF_DROP || verdict == NF_ACCEPT;
 }","[7, 6]","The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call."
202234," static int piv_match_card_continued(sc_card_t *card)
 {
 	int i;
 	int type  = -1;
 	piv_private_data_t *priv = NULL;
 	int saved_type = card->type;
 
 	 
 	card->ops->logout = NULL;
 
 	 
 	 
 	switch (card->type) {
 		case -1:
 		case SC_CARD_TYPE_PIV_II_GENERIC:
 		case SC_CARD_TYPE_PIV_II_HIST:
 		case SC_CARD_TYPE_PIV_II_NEO:
 		case SC_CARD_TYPE_PIV_II_YUBIKEY4:
 		case SC_CARD_TYPE_PIV_II_GI_DE:
 			type = card->type;
 			break;
 		default:
 			return 0;  
 	}
 	if (type == -1) {
 
 		 
 
 		if (card->reader->atr_info.hist_bytes != NULL) {
 			if (card->reader->atr_info.hist_bytes_len == 8 &&
 					!(memcmp(card->reader->atr_info.hist_bytes, ""Yubikey4"", 8))) {
 				type = SC_CARD_TYPE_PIV_II_YUBIKEY4;
 			}
 			else if (card->reader->atr_info.hist_bytes_len >= 7 &&
 					!(memcmp(card->reader->atr_info.hist_bytes, ""Yubikey"", 7))) {
 				type = SC_CARD_TYPE_PIV_II_NEO;
 			}
 			 
			else if (card->reader->atr_info.hist_bytes_len >= 4 &&
					!(memcmp(card->reader->atr_info.hist_bytes, ""sfte"", 4))) {
 			else if (card->reader->atr_info.hist_bytes_len >= 4
 					&& !(memcmp(card->reader->atr_info.hist_bytes, ""sfte"", 4))) {
  				type = SC_CARD_TYPE_PIV_II_GI_DE;
  			}
  
			else if (card->reader->atr_info.hist_bytes[0] == 0x80u) {  
 			else if (card->reader->atr_info.hist_bytes_len > 0
 					&& card->reader->atr_info.hist_bytes[0] == 0x80u) {  
  				size_t datalen;
  				const u8 *data = sc_compacttlv_find_tag(card->reader->atr_info.hist_bytes + 1,
  									card->reader->atr_info.hist_bytes_len - 1,
 									0xF0, &datalen);
 
 				if (data != NULL) {
 					int k;
 
 					for (k = 0; piv_aids[k].len_long != 0; k++) {
 						if (datalen == piv_aids[k].len_long
 							&& !memcmp(data, piv_aids[k].value, datalen)) {
 							type = SC_CARD_TYPE_PIV_II_HIST;
 							break;
 						}
 					}
 				}
 			}
 		}
 		if (type == -1)
 			type = SC_CARD_TYPE_PIV_II_GENERIC;
 	}
 
 	 
 
 	priv = calloc(1, sizeof(piv_private_data_t));
 
 	if (!priv)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 
 	if (card->type == -1)
 		card->type = type;
 
 	card->drv_data = priv;  
 	priv->aid_file = sc_file_new();
 	priv->selected_obj = -1;
 	priv->pin_preference = 0x80;  
 	priv->logged_in = SC_PIN_STATE_UNKNOWN;
 	priv->tries_left = 10;  
 	priv->pstate = PIV_STATE_MATCH;
 
 	 
 	for (i=0; i < PIV_OBJ_LAST_ENUM -1; i++)
 		if(piv_objects[i].flags & PIV_OBJECT_NOT_PRESENT)
 			priv->obj_cache[i].flags |= PIV_OBJ_CACHE_NOT_PRESENT;
 
 	sc_lock(card);
 
 	 
 	i = piv_find_discovery(card);
 
 	if (i < 0) {
 		 
 		sc_file_t aidfile;
 
 		i = piv_find_aid(card, &aidfile);
 	}
 
 	if (i >= 0) {
 		 
 		int i7e = piv_find_discovery(card);
 
 		if (i7e != 0 && i7e !=  SC_ERROR_FILE_NOT_FOUND) {
 			priv->card_issues |= CI_DISCOVERY_USELESS;
 			priv->obj_cache[PIV_OBJ_DISCOVERY].flags |= PIV_OBJ_CACHE_NOT_PRESENT;
 		}
 	}
 
 
 	if (i < 0) {
 		 
 		sc_unlock(card);
 		piv_finish(card);
 		card->type = saved_type;
 		return 0;
 	}
 
 	 
 	priv->pstate=PIV_STATE_INIT;
 	return 1;  
 }","[41, 42, 47, 48, 39, 40, 46]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
6286,"BOOL license_read_new_or_upgrade_license_packet(rdpLicense* license, wStream* s)
{
UINT32 os_major;
UINT32 os_minor;
UINT32 cbScope, cbCompanyName, cbProductId, cbLicenseInfo;
wStream* licenseStream = NULL;
BOOL ret = FALSE;
BYTE computedMac[16];
LICENSE_BLOB* calBlob;

DEBUG_LICENSE(""Receiving Server New/Upgrade License Packet"");

calBlob = license_new_binary_blob(BB_DATA_BLOB);
if (!calBlob)
return FALSE;


if (!license_read_encrypted_blob(license, s, calBlob))
goto out_free_blob;


if (Stream_GetRemainingLength(s) < 16)
goto out_free_blob;

if (!security_mac_data(license->MacSaltKey, calBlob->data, calBlob->length, computedMac))
goto out_free_blob;

if (memcmp(computedMac, Stream_Pointer(s), sizeof(computedMac)) != 0)
{
WLog_ERR(TAG, ""new or upgrade license MAC mismatch"");
goto out_free_blob;
}

if (!Stream_SafeSeek(s, 16))
goto out_free_blob;

licenseStream = Stream_New(calBlob->data, calBlob->length);
if (!licenseStream)
goto out_free_blob;

Stream_Read_UINT16(licenseStream, os_minor);
Stream_Read_UINT16(licenseStream, os_major);


Stream_Read_UINT32(licenseStream, cbScope);
if (Stream_GetRemainingLength(licenseStream) < cbScope)
goto out_free_stream;
#ifdef WITH_DEBUG_LICENSE
WLog_DBG(TAG, ""Scope:"");
winpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbScope);
#endif
Stream_Seek(licenseStream, cbScope);


Stream_Read_UINT32(licenseStream, cbCompanyName);
if (Stream_GetRemainingLength(licenseStream) < cbCompanyName)
goto out_free_stream;
#ifdef WITH_DEBUG_LICENSE
WLog_DBG(TAG, ""Company name:"");
winpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbCompanyName);
#endif
Stream_Seek(licenseStream, cbCompanyName);


Stream_Read_UINT32(licenseStream, cbProductId);
if (Stream_GetRemainingLength(licenseStream) < cbProductId)
goto out_free_stream;
#ifdef WITH_DEBUG_LICENSE
WLog_DBG(TAG, ""Product id:"");
winpr_HexDump(TAG, WLOG_DEBUG, Stream_Pointer(licenseStream), cbProductId);
#endif
Stream_Seek(licenseStream, cbProductId);


Stream_Read_UINT32(licenseStream, cbLicenseInfo);
if (Stream_GetRemainingLength(licenseStream) < cbLicenseInfo)
goto out_free_stream;

license->state = LICENSE_STATE_COMPLETED;

ret = TRUE;
if (!license->rdp->settings->OldLicenseBehaviour)
ret = saveCal(license->rdp->settings, Stream_Pointer(licenseStream), cbLicenseInfo,
license->rdp->settings->ClientHostname);

out_free_stream:
Stream_Free(licenseStream, FALSE);
out_free_blob:
license_free_binary_blob(calBlob);
return ret;
}","[41, 55, 65, 75]","In FreeRDP before version 2.1.2, there is an out of bounds read in license_read_new_or_upgrade_license_packet. A manipulated license packet can lead to out of bound reads to an internal buffer. This is fixed in version 2.1.2."
9790,"static void dhcps_send_ack(struct pbuf *packet_buffer)
{
dhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;
dhcps_initialize_message(dhcp_message_repository);
add_offer_options(add_msg_type(&dhcp_message_repository->options[4],
DHCP_MESSAGE_TYPE_ACK));
udp_sendto_if(dhcps_pcb, packet_buffer,
&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);
}","[3, 5, 6, 7, 8]",component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.
200916," static int sdp_parse_fmtp_config_h264(AVFormatContext *s,
                                       AVStream *stream,
                                       PayloadContext *h264_data,
                                       const char *attr, const char *value)
 {
     AVCodecParameters *par = stream->codecpar;
 
     if (!strcmp(attr, ""packetization-mode"")) {
         av_log(s, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value));
         h264_data->packetization_mode = atoi(value);
          
         if (h264_data->packetization_mode > 1)
             av_log(s, AV_LOG_ERROR,
                    ""Interleaved RTP mode is not supported yet.\n"");
     } else if (!strcmp(attr, ""profile-level-id"")) {
         if (strlen(value) == 6)
              parse_profile_level_id(s, h264_data, value);
      } else if (!strcmp(attr, ""sprop-parameter-sets"")) {
          int ret;
        if (value[strlen(value) - 1] == ',') {
         if (*value == 0 || value[strlen(value) - 1] == ',') {
              av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
              return 0;
          }
         par->extradata_size = 0;
         av_freep(&par->extradata);
         ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,
                                                  &par->extradata_size, value);
         av_log(s, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)\n"",
                par->extradata, par->extradata_size);
         return ret;
     }
     return 0;
 }","[21, 20]","The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file."
6266,"static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,
size_t offset)
{
size_t position;
WINPR_UNUSED(context);
position = Stream_GetPosition(s);
Stream_SetPosition(s, offset);
Stream_Write_UINT8(s, orderInfo->controlFlags);

if (orderInfo->controlFlags & ORDER_TYPE_CHANGE)
Stream_Write_UINT8(s, orderInfo->orderType);

update_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,
PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);
update_write_bounds(s, orderInfo);
Stream_SetPosition(s, position);
return 0;
}",[14],"In FreeRDP before version 2.1.2, an out of bound reads occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2."
205168," bool ChromePluginServiceFilter::IsPluginEnabled(
 bool ChromePluginServiceFilter::IsPluginAvailable(
      int render_process_id,
      int render_view_id,
      const void* context,
     const GURL& url,
     const GURL& policy_url,
     webkit::WebPluginInfo* plugin) {
   base::AutoLock auto_lock(lock_);
   const ProcessDetails* details = GetProcess(render_process_id);
 
   if (details) {
     for (size_t i = 0; i < details->overridden_plugins.size(); ++i) {
       if (details->overridden_plugins[i].render_view_id == render_view_id &&
           (details->overridden_plugins[i].url == url ||
             details->overridden_plugins[i].url.is_empty())) {
  
          bool use = details->overridden_plugins[i].plugin.path == plugin->path;
        if (!use)
          return false;
        *plugin = details->overridden_plugins[i].plugin;
        break;
         if (use)
           *plugin = details->overridden_plugins[i].plugin;
         return use;
        }
      }
    }
 
   ResourceContextMap::iterator prefs_it =
       resource_context_map_.find(context);
   if (prefs_it == resource_context_map_.end())
     return false;
 
   PluginPrefs* plugin_prefs = prefs_it->second.get();
   if (!plugin_prefs->IsPluginEnabled(*plugin))
     return false;
 
   RestrictedPluginMap::const_iterator it =
       restricted_plugins_.find(plugin->path);
   if (it != restricted_plugins_.end()) {
     if (it->second.first != plugin_prefs)
       return false;
     const GURL& origin = it->second.second;
     if (!origin.is_empty() &&
         (policy_url.scheme() != origin.scheme() ||
          policy_url.host() != origin.host() ||
          policy_url.port() != origin.port())) {
       return false;
     }
   }
 
   return true;
 }","[2, 23, 24, 25, 19, 20, 21, 22]","Google Chrome before 25.0.1364.152 does not properly manage the interaction between the browser process and renderer processes during authorization of the loading of a plug-in, which makes it easier for remote attackers to bypass intended access restrictions via vectors involving a blocked plug-in."
198115," static char **fill_envp(struct dhcp_packet *packet)
 {
 	int envc;
 	int i;
 	char **envp, **curr;
 	const char *opt_name;
 	uint8_t *temp;
 	uint8_t overload = 0;
 
 #define BITMAP unsigned
 #define BBITS (sizeof(BITMAP) * 8)
 #define BMASK(i) (1 << (i & (sizeof(BITMAP) * 8 - 1)))
 #define FOUND_OPTS(i) (found_opts[(unsigned)i / BBITS])
 	BITMAP found_opts[256 / BBITS];
 
 	memset(found_opts, 0, sizeof(found_opts));
 
 	 
 	envc = 6;
 	 
 	if (packet) {
 		 
 		for (i = 1; i < 255; i++) {
 			temp = udhcp_get_option(packet, i);
 			if (temp) {
 				if (i == DHCP_OPTION_OVERLOAD)
 					overload |= *temp;
 				else if (i == DHCP_SUBNET)
 					envc++;  
 				envc++;
 				 
 				FOUND_OPTS(i) |= BMASK(i);
 			}
 		}
 	}
 	curr = envp = xzalloc(sizeof(envp[0]) * envc);
 
 	*curr = xasprintf(""interface=%s"", client_config.interface);
 	putenv(*curr++);
 
 	if (!packet)
 		return envp;
 
 	 
 	 
 	*curr = xmalloc(sizeof(""ip=255.255.255.255""));
 	sprint_nip(*curr, ""ip="", (uint8_t *) &packet->yiaddr);
 	putenv(*curr++);
 	if (packet->siaddr_nip) {
 		 
 		*curr = xmalloc(sizeof(""siaddr=255.255.255.255""));
 		sprint_nip(*curr, ""siaddr="", (uint8_t *) &packet->siaddr_nip);
 		putenv(*curr++);
 	}
 	if (!(overload & FILE_FIELD) && packet->file[0]) {
 		 
 		*curr = xasprintf(""boot_file=%.""DHCP_PKT_FILE_LEN_STR""s"", packet->file);
 		putenv(*curr++);
 	}
 	if (!(overload & SNAME_FIELD) && packet->sname[0]) {
 		 
 		*curr = xasprintf(""sname=%.""DHCP_PKT_SNAME_LEN_STR""s"", packet->sname);
 		putenv(*curr++);
 	}
 
 	 
 	opt_name = dhcp_option_strings;
 	i = 0;
 	while (*opt_name) {
 		uint8_t code = dhcp_optflags[i].code;
 		BITMAP *found_ptr = &FOUND_OPTS(code);
 		BITMAP found_mask = BMASK(code);
 		if (!(*found_ptr & found_mask))
 			goto next;
 		*found_ptr &= ~found_mask;  
  		temp = udhcp_get_option(packet, code);
  		*curr = xmalloc_optname_optval(temp, &dhcp_optflags[i], opt_name);
  		putenv(*curr++);
		if (code == DHCP_SUBNET) {
 		if (code == DHCP_SUBNET && temp[-OPT_DATA + OPT_LEN] == 4) {
  			 
  			uint32_t subnet;
  			move_from_unaligned32(subnet, temp);
 			*curr = xasprintf(""mask=%u"", mton(subnet));
 			putenv(*curr++);
 		}
  next:
 		opt_name += strlen(opt_name) + 1;
 		i++;
 	}
 	 
 	for (i = 0; i < 256;) {
 		BITMAP bitmap = FOUND_OPTS(i);
 		if (!bitmap) {
 			i += BBITS;
 			continue;
 		}
 		if (bitmap & BMASK(i)) {
 			unsigned len, ofs;
 
 			temp = udhcp_get_option(packet, i);
 			 
 			len = temp[-OPT_DATA + OPT_LEN];
 			*curr = xmalloc(sizeof(""optNNN="") + 1 + len*2);
 			ofs = sprintf(*curr, ""opt%u="", i);
 			*bin2hex(*curr + ofs, (void*) temp, len) = '\0';
 			putenv(*curr++);
 		}
 		i++;
 	}
 
 	return envp;
 }","[80, 79]","An issue was discovered in BusyBox through 1.30.0. An out of bounds read in udhcp components (consumed by the DHCP server, client, and/or relay) might allow a remote attacker to leak sensitive information from the stack by sending a crafted DHCP message. This is related to assurance of a 4-byte length when decoding DHCP_SUBNET. NOTE: this issue exists because of an incomplete fix for CVE-2018-20679."
207084,"  void MediaStreamManager::CancelAllRequests(int render_process_id,
                                           int render_frame_id) {
                                            int render_frame_id,
                                            int requester_id) {
    DCHECK_CURRENTLY_ON(BrowserThread::IO);
    auto request_it = requests_.begin();
    while (request_it != requests_.end()) {
      if (request_it->second->requesting_process_id != render_process_id ||
        request_it->second->requesting_frame_id != render_frame_id) {
         request_it->second->requesting_frame_id != render_frame_id ||
         request_it->second->requester_id != requester_id) {
        ++request_it;
        continue;
      }
     const std::string label = request_it->first;
     ++request_it;
     CancelRequest(label);
   }
 }","[3, 4, 10, 11, 2, 9]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
204428," void ChromeMockRenderThread::OnUpdatePrintSettings(
     int document_cookie,
     const base::DictionaryValue& job_settings,
     PrintMsg_PrintPages_Params* params) {
   std::string dummy_string;
   int margins_type = 0;
   if (!job_settings.GetBoolean(printing::kSettingLandscape, NULL) ||
       !job_settings.GetBoolean(printing::kSettingCollate, NULL) ||
       !job_settings.GetInteger(printing::kSettingColor, NULL) ||
       !job_settings.GetBoolean(printing::kSettingPrintToPDF, NULL) ||
       !job_settings.GetBoolean(printing::kIsFirstRequest, NULL) ||
        !job_settings.GetString(printing::kSettingDeviceName, &dummy_string) ||
        !job_settings.GetInteger(printing::kSettingDuplexMode, NULL) ||
        !job_settings.GetInteger(printing::kSettingCopies, NULL) ||
      !job_settings.GetString(printing::kPreviewUIAddr, &dummy_string) ||
       !job_settings.GetInteger(printing::kPreviewUIID, NULL) ||
        !job_settings.GetInteger(printing::kPreviewRequestID, NULL) ||
        !job_settings.GetInteger(printing::kSettingMarginsType, &margins_type)) {
      return;
    }
  
  if (printer_.get()) {
    const ListValue* page_range_array;
    printing::PageRanges new_ranges;
    if (job_settings.GetList(printing::kSettingPageRange, &page_range_array)) {
      for (size_t index = 0; index < page_range_array->GetSize(); ++index) {
        const base::DictionaryValue* dict;
        if (!page_range_array->GetDictionary(index, &dict))
          continue;
        printing::PageRange range;
        if (!dict->GetInteger(printing::kSettingPageRangeFrom, &range.from) ||
            !dict->GetInteger(printing::kSettingPageRangeTo, &range.to)) {
          continue;
        }
        range.from--;
        range.to--;
        new_ranges.push_back(range);
   const ListValue* page_range_array;
   printing::PageRanges new_ranges;
   if (job_settings.GetList(printing::kSettingPageRange, &page_range_array)) {
     for (size_t index = 0; index < page_range_array->GetSize(); ++index) {
       const base::DictionaryValue* dict;
       if (!page_range_array->GetDictionary(index, &dict))
         continue;
       printing::PageRange range;
       if (!dict->GetInteger(printing::kSettingPageRangeFrom, &range.from) ||
           !dict->GetInteger(printing::kSettingPageRangeTo, &range.to)) {
         continue;
        }
        
        
       range.from--;
       range.to--;
       new_ranges.push_back(range);
      }
    std::vector<int> pages(printing::PageRange::GetPages(new_ranges));
    printer_->UpdateSettings(document_cookie, params, pages, margins_type);
    }
   std::vector<int> pages(printing::PageRange::GetPages(new_ranges));
   printer_->UpdateSettings(document_cookie, params, pages, margins_type);
 }
 
 MockPrinter* ChromeMockRenderThread::printer() {
   return printer_.get();
  }","[16, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 59, 60, 61, 62, 63, 64, 15, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 56, 57]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
7580,"int64 CSteamNetworkConnectionBase::SNP_SendMessage( CSteamNetworkingMessage *pSendMessage, SteamNetworkingMicroseconds usecNow, bool *pbThinkImmediately )
{
int cbData = (int)pSendMessage->m_cbSize;


if ( pbThinkImmediately )
*pbThinkImmediately = false;


if ( m_senderState.PendingBytesTotal() + cbData > m_connectionConfig.m_SendBufferSize.Get() )
{
SpewWarningRateLimited( usecNow, ""Connection already has %u bytes pending, cannot queue any more messages\n"", m_senderState.PendingBytesTotal() );
pSendMessage->Release();
return -k_EResultLimitExceeded;
}


if ( cbData > k_cbMaxUnreliableMsgSize && !( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )  )
{
SpewWarningRateLimited( usecNow, ""Trying to send a very large (%d bytes) unreliable message.  Sending as reliable instead.\n"", cbData );
pSendMessage->m_nFlags |= k_nSteamNetworkingSend_Reliable;
}

if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoDelay )
{



}



SNP_ClampSendRate();
SNP_TokenBucket_Accumulate( usecNow );


pSendMessage->m_nMessageNumber = ++m_senderState.m_nLastSentMsgNum;


if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_Reliable )
{
pSendMessage->SNPSend_SetReliableStreamPos( m_senderState.m_nReliableStreamPos );


byte *hdr = pSendMessage->SNPSend_ReliableHeader();
hdr[0] = 0;
byte *hdrEnd = hdr+1;
int64 nMsgNumGap = pSendMessage->m_nMessageNumber - m_senderState.m_nLastSendMsgNumReliable;
Assert( nMsgNumGap >= 1 );
if ( nMsgNumGap > 1 )
{
hdrEnd = SerializeVarInt( hdrEnd, (uint64)nMsgNumGap );
hdr[0] |= 0x40;
}
if ( cbData < 0x20 )
{
hdr[0] |= (byte)cbData;
}
else
{
hdr[0] |= (byte)( 0x20 | ( cbData & 0x1f ) );
hdrEnd = SerializeVarInt( hdrEnd, cbData>>5U );
}
pSendMessage->m_cbSNPSendReliableHeader = hdrEnd - hdr;


pSendMessage->m_cbSize += pSendMessage->m_cbSNPSendReliableHeader;


m_senderState.m_nReliableStreamPos += pSendMessage->m_cbSize;


++m_senderState.m_nMessagesSentReliable;
m_senderState.m_cbPendingReliable += pSendMessage->m_cbSize;



m_senderState.m_nLastSendMsgNumReliable = pSendMessage->m_nMessageNumber;

Assert( pSendMessage->SNPSend_IsReliable() );
}
else
{
pSendMessage->SNPSend_SetReliableStreamPos( 0 );
pSendMessage->m_cbSNPSendReliableHeader = 0;

++m_senderState.m_nMessagesSentUnreliable;
m_senderState.m_cbPendingUnreliable += pSendMessage->m_cbSize;

Assert( !pSendMessage->SNPSend_IsReliable() );
}


m_senderState.m_messagesQueued.push_back( pSendMessage );
SpewVerboseGroup( m_connectionConfig.m_LogLevel_Message.Get(), ""[%s] SendMessage %s: MsgNum=%lld sz=%d\n"",
GetDescription(),
pSendMessage->SNPSend_IsReliable() ? ""RELIABLE"" : ""UNRELIABLE"",
(long long)pSendMessage->m_nMessageNumber,
pSendMessage->m_cbSize );








pSendMessage->SNPSend_SetUsecNagle( usecNow + m_connectionConfig.m_NagleTime.Get() );
if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_NoNagle )
m_senderState.ClearNagleTimers();


int64 result = pSendMessage->m_nMessageNumber;








if ( GetState() == k_ESteamNetworkingConnectionState_Connected )
{
SteamNetworkingMicroseconds usecNextThink = SNP_GetNextThinkTime( usecNow );


if ( usecNextThink > usecNow )
{


if ( m_senderState.m_messagesQueued.m_pFirst->SNPSend_UsecNagle() == 0 )
{
SpewVerbose( ""[%s] RATELIM QueueTime is %.1fms, SendRate=%.1fk, BytesQueued=%d\n"",
GetDescription(),
m_senderState.CalcTimeUntilNextSend() * 1e-3,
m_senderState.m_n_x * ( 1.0/1024.0),
m_senderState.PendingBytesTotal()
);
}


EnsureMinThinkTime( usecNextThink );
}
else
{


if ( pSendMessage->m_nFlags & k_nSteamNetworkingSend_UseCurrentThread )
{



if ( pbThinkImmediately )
{

*pbThinkImmediately = true;
}
else
{

CheckConnectionStateAndSetNextThinkTime( usecNow );
}
}
else
{

SetNextThinkTimeASAP();
}
}
}

return result;
}",[18],"Valve's Game Networking Sockets prior to version v1.2.0 improperly handles unreliable segments with negative offsets in function SNP_ReceiveUnreliableSegment(), leading to a Heap-Based Buffer Underflow and a free() of memory not from the heap, resulting in a memory corruption and probably even a remote code execution."
198508," int virtio_load(VirtIODevice *vdev, QEMUFile *f)
 {
     int i, ret;
     uint32_t num;
     uint32_t features;
     uint32_t supported_features;
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
 
     if (k->load_config) {
         ret = k->load_config(qbus->parent, f);
         if (ret)
             return ret;
     }
 
      qemu_get_8s(f, &vdev->status);
      qemu_get_8s(f, &vdev->isr);
      qemu_get_be16s(f, &vdev->queue_sel);
     if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {
         return -1;
     }
      qemu_get_be32s(f, &features);
  
      if (virtio_set_features(vdev, features) < 0) {
         return -1;
     }
     vdev->config_len = qemu_get_be32(f);
     qemu_get_buffer(f, vdev->config, vdev->config_len);
 
     num = qemu_get_be32(f);
 
     if (num > VIRTIO_PCI_QUEUE_MAX) {
         error_report(""Invalid number of PCI queues: 0x%x"", num);
         return -1;
     }
 
     for (i = 0; i < num; i++) {
         vdev->vq[i].vring.num = qemu_get_be32(f);
         if (k->has_variable_vring_alignment) {
             vdev->vq[i].vring.align = qemu_get_be32(f);
         }
         vdev->vq[i].pa = qemu_get_be64(f);
         qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);
         vdev->vq[i].signalled_used_valid = false;
         vdev->vq[i].notification = true;
 
         if (vdev->vq[i].pa) {
             uint16_t nheads;
             virtqueue_init(&vdev->vq[i]);
             nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;
              
             if (nheads > vdev->vq[i].vring.num) {
                 error_report(""VQ %d size 0x%x Guest index 0x%x ""
                              ""inconsistent with Host index 0x%x: delta 0x%x"",
                              i, vdev->vq[i].vring.num,
                              vring_avail_idx(&vdev->vq[i]),
                              vdev->vq[i].last_avail_idx, nheads);
                 return -1;
             }
         } else if (vdev->vq[i].last_avail_idx) {
             error_report(""VQ %d address 0x0 ""
                          ""inconsistent with Host index 0x%x"",
                          i, vdev->vq[i].last_avail_idx);
                 return -1;
 	}
         if (k->load_queue) {
             ret = k->load_queue(qbus->parent, i, f);
             if (ret)
                 return ret;
         }
     }
 
     virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
     return 0;
 }","[19, 20, 21]",Array index error in the virtio_load function in hw/virtio/virtio.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image.
205709," ClipPaintPropertyNode* ClipPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(
 const ClipPaintPropertyNode& ClipPaintPropertyNode::Root() {
   DEFINE_STATIC_LOCAL(
        ClipPaintPropertyNode, root,
      (ClipPaintPropertyNode::Create(
          nullptr, State{TransformPaintPropertyNode::Root(),
                         FloatRoundedRect(LayoutRect::InfiniteIntRect())})));
       (nullptr, State{&TransformPaintPropertyNode::Root(),
                       FloatRoundedRect(LayoutRect::InfiniteIntRect())}));
    return root;
  }","[3, 4, 9, 10, 2, 6, 7, 8]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
200377," static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale)
 {
 	char*		tag_value	= NULL;
 	int32_t     	tag_value_len   = 512;
 
 	int		singletonPos   	= 0;
 	char*       	mod_loc_name	= NULL;
 	int 		grOffset	= 0;
 
 	int32_t     	buflen          = 512;
 	UErrorCode  	status          = U_ZERO_ERROR;
 
 
 	if( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){
 		 
 		grOffset =  findOffset( LOC_GRANDFATHERED , loc_name );
 		if( grOffset >= 0 ){
 			if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
 				return estrdup(loc_name);
 			} else {
 				 
 				return NULL;
 			}
 		}
 
 	if( fromParseLocale==1 ){
 		 
 		if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
 			if( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){
 				return estrdup(loc_name);
  			}
  		}
  
		singletonPos = getSingletonPos( loc_name );	
 		singletonPos = getSingletonPos( loc_name );
  		if( singletonPos == 0){
  			 
 			return NULL;
 		} else if( singletonPos > 0 ){
 			 
 			mod_loc_name = estrndup ( loc_name , singletonPos-1);
 		}
 	}  
 
  	}  
  
  	if( mod_loc_name == NULL){
		mod_loc_name = estrdup(loc_name );	
 		mod_loc_name = estrdup(loc_name );
  	}
  
  	 
     do{
 		tag_value = erealloc( tag_value , buflen  );
 		tag_value_len = buflen;
 
 		if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
 			buflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status);
 		}
 		if( strcmp(tag_name , LOC_LANG_TAG )==0 ){
 			buflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status);
 		}
 		if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
 			buflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status);
 		}
 		if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
 			buflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status);
 		}
 		if( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){
 			buflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status);
 		}
 
  		if( U_FAILURE( status ) ) {
  			if( status == U_BUFFER_OVERFLOW_ERROR ) {
  				status = U_ZERO_ERROR;
 				buflen++;  
  				continue;
  			}
  
 			 
 			*result = 0;
 			if( tag_value ){
 				efree( tag_value );
 			}
 			if( mod_loc_name ){
 				efree( mod_loc_name);
 			}
 			return NULL;
 		}
 	} while( buflen > tag_value_len );
 
 	if(  buflen ==0 ){
 		 
 		*result = -1;
 		if( tag_value ){
 			efree( tag_value );
 		}
 		if( mod_loc_name ){
 			efree( mod_loc_name);
 		}
 		return NULL;
 	} else {
 		*result = 1;
 	}
 
 	if( mod_loc_name ){
 		efree( mod_loc_name);
 	}
 	return tag_value;
 }","[35, 49, 76, 34, 48]","The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
202950," static void setup_remaining_vcs(int src_fd, unsigned src_idx, bool utf8) {
         struct console_font_op cfo = {
                 .op = KD_FONT_OP_GET,
                 .width = UINT_MAX, .height = UINT_MAX,
                 .charcount = UINT_MAX,
         };
         struct unimapinit adv = {};
         struct unimapdesc unimapd;
         _cleanup_free_ struct unipair* unipairs = NULL;
         _cleanup_free_ void *fontbuf = NULL;
         unsigned i;
         int r;
 
         unipairs = new(struct unipair, USHRT_MAX);
         if (!unipairs) {
                 log_oom();
                 return;
         }
 
          
         r = ioctl(src_fd, KDFONTOP, &cfo);
         if (r < 0)
                 log_warning_errno(errno, ""KD_FONT_OP_GET failed while trying to get the font metadata: %m"");
         else {
                  
                 if (cfo.width > 32 || cfo.height > 32 || cfo.charcount > 512)
                         log_warning(""Invalid font metadata - width: %u (max 32), height: %u (max 32), count: %u (max 512)"",
                                     cfo.width, cfo.height, cfo.charcount);
                 else {
                          
                         fontbuf = malloc_multiply((cfo.width + 7) / 8 * 32, cfo.charcount);
                         if (!fontbuf) {
                                 log_oom();
                                 return;
                         }
                          
                         cfo.data = fontbuf;
                         r = ioctl(src_fd, KDFONTOP, &cfo);
                         if (r < 0)
                                 log_warning_errno(errno, ""KD_FONT_OP_GET failed while trying to read the font data: %m"");
                         else {
                                 unimapd.entries  = unipairs;
                                 unimapd.entry_ct = USHRT_MAX;
                                 r = ioctl(src_fd, GIO_UNIMAP, &unimapd);
                                 if (r < 0)
                                         log_warning_errno(errno, ""GIO_UNIMAP failed while trying to read unicode mappings: %m"");
                                 else
                                         cfo.op = KD_FONT_OP_SET;
                         }
                 }
         }
 
         if (cfo.op != KD_FONT_OP_SET)
                 log_warning(""Fonts will not be copied to remaining consoles"");
 
         for (i = 1; i <= 63; i++) {
                 char ttyname[sizeof(""/dev/tty63"")];
                 _cleanup_close_ int fd_d = -1;
 
                 if (i == src_idx || verify_vc_allocation(i) < 0)
                         continue;
 
                  
                 xsprintf(ttyname, ""/dev/tty%u"", i);
                 fd_d = open_terminal(ttyname, O_RDWR|O_CLOEXEC|O_NOCTTY);
                 if (fd_d < 0) {
                         log_warning_errno(fd_d, ""Unable to open tty%u, fonts will not be copied: %m"", i);
                          continue;
                  }
  
                if (verify_vc_kbmode(fd_d) < 0)
                 if (vt_verify_kbmode(fd_d) < 0)
                          continue;
  
                  toggle_utf8(ttyname, fd_d, utf8);
 
                 if (cfo.op != KD_FONT_OP_SET)
                         continue;
 
                 r = ioctl(fd_d, KDFONTOP, &cfo);
                 if (r < 0) {
                         int last_errno, mode;
 
                          
 
                         last_errno = errno;
                         if (ioctl(fd_d, KDGETMODE, &mode) >= 0 && mode != KD_TEXT)
                                 log_debug(""KD_FONT_OP_SET skipped: tty%u is not in text mode"", i);
                         else
                                 log_warning_errno(last_errno, ""KD_FONT_OP_SET failed, fonts will not be copied to tty%u: %m"", i);
 
                         continue;
                 }
 
                  
                 r = ioctl(fd_d, PIO_UNIMAPCLR, &adv);
                 if (r < 0) {
                         log_warning_errno(errno, ""PIO_UNIMAPCLR failed, unimaps might be incorrect for tty%u: %m"", i);
                         continue;
                 }
 
                 r = ioctl(fd_d, PIO_UNIMAP, &unimapd);
                 if (r < 0) {
                         log_warning_errno(errno, ""PIO_UNIMAP failed, unimaps might be incorrect for tty%u: %m"", i);
                         continue;
                 }
 
                 log_debug(""Font and unimap successfully copied to %s"", ttyname);
         }
 }","[72, 71]","systemd 242 changes the VT1 mode upon a logout, which allows attackers to read cleartext passwords in certain circumstances, such as watching a shutdown, or using Ctrl-Alt-F1 and Ctrl-Alt-F2. This occurs because the KDGKBMODE (aka current keyboard mode) check is mishandled."
204766," static v8::Handle<v8::Value> methodCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestMediaQueryListListener.method"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestMediaQueryListListener* imp = V8TestMediaQueryListListener::toNative(args.Holder());
      EXCEPTION_BLOCK(RefPtr<MediaQueryListListener>, listener, MediaQueryListListener::create(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
      imp->method(listener);
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
207569," status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
     ALOGV(""entering parseChunk %lld/%d"", (long long)*offset, depth);
  uint32_t hdr[2];
  if (mDataSource->readAt(*offset, hdr, 8) < 8) {
  return ERROR_IO;
  }
  uint64_t chunk_size = ntohl(hdr[0]);
  int32_t chunk_type = ntohl(hdr[1]);
  off64_t data_offset = *offset + 8;
 
  if (chunk_size == 1) {
  if (mDataSource->readAt(*offset + 8, &chunk_size, 8) < 8) {
  return ERROR_IO;
  }
         chunk_size = ntoh64(chunk_size);
         data_offset += 8;
 
  if (chunk_size < 16) {
  return ERROR_MALFORMED;
  }
  } else if (chunk_size == 0) {
  if (depth == 0) {
  off64_t sourceSize;
  if (mDataSource->getSize(&sourceSize) == OK) {
                 chunk_size = (sourceSize - *offset);
  } else {
                 ALOGE(""atom size is 0, and data source has no size"");
  return ERROR_MALFORMED;
  }
  } else {
  *offset += 4;
  return OK;
  }
  } else if (chunk_size < 8) {
         ALOGE(""invalid chunk size: %"" PRIu64, chunk_size);
  return ERROR_MALFORMED;
  }
 
  char chunk[5];
  MakeFourCCString(chunk_type, chunk);
     ALOGV(""chunk: %s @ %lld, %d"", chunk, (long long)*offset, depth);
 
  if (kUseHexDump) {
  static const char kWhitespace[] = ""                                        "";
  const char *indent = &kWhitespace[sizeof(kWhitespace) - 1 - 2 * depth];
         printf(""%sfound chunk '%s' of size %"" PRIu64 ""\n"", indent, chunk, chunk_size);
 
  char buffer[256];
  size_t n = chunk_size;
  if (n > sizeof(buffer)) {
             n = sizeof(buffer);
  }
  if (mDataSource->readAt(*offset, buffer, n)
  < (ssize_t)n) {
  return ERROR_IO;
  }
 
         hexdump(buffer, n);
  }
 
  PathAdder autoAdder(&mPath, chunk_type);
 
  off64_t chunk_data_size = *offset + chunk_size - data_offset;
 
  if (chunk_type != FOURCC('c', 'p', 'r', 't')
  && chunk_type != FOURCC('c', 'o', 'v', 'r')
  && mPath.size() == 5 && underMetaDataPath(mPath)) {
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset;
  while (*offset < stop_offset) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
 
  return OK;
  }
 
  switch(chunk_type) {
  case FOURCC('m', 'o', 'o', 'v'):
  case FOURCC('t', 'r', 'a', 'k'):
  case FOURCC('m', 'd', 'i', 'a'):
  case FOURCC('m', 'i', 'n', 'f'):
  case FOURCC('d', 'i', 'n', 'f'):
  case FOURCC('s', 't', 'b', 'l'):
  case FOURCC('m', 'v', 'e', 'x'):
  case FOURCC('m', 'o', 'o', 'f'):
  case FOURCC('t', 'r', 'a', 'f'):
  case FOURCC('m', 'f', 'r', 'a'):
  case FOURCC('u', 'd', 't', 'a'):
  case FOURCC('i', 'l', 's', 't'):
  case FOURCC('s', 'i', 'n', 'f'):
  case FOURCC('s', 'c', 'h', 'i'):
  case FOURCC('e', 'd', 't', 's'):
  {
  if (chunk_type == FOURCC('m', 'o', 'o', 'f') && !mMoofFound) {
                 mMoofFound = true;
                 mMoofOffset = *offset;
  }
 
  if (chunk_type == FOURCC('s', 't', 'b', 'l')) {
                 ALOGV(""sampleTable chunk is %"" PRIu64 "" bytes long."", chunk_size);
 
  if (mDataSource->flags()
  & (DataSource::kWantsPrefetching
  | DataSource::kIsCachingDataSource)) {
                     sp<MPEG4DataSource> cachedSource =
  new MPEG4DataSource(mDataSource);
 
  if (cachedSource->setCachedRange(*offset, chunk_size) == OK) {
                         mDataSource = cachedSource;
  }
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
                 mLastTrack->sampleTable = new SampleTable(mDataSource);
  }
 
  bool isTrack = false;
  if (chunk_type == FOURCC('t', 'r', 'a', 'k')) {
                 isTrack = true;
 
  Track *track = new Track;
                 track->next = NULL;
  if (mLastTrack) {
                     mLastTrack->next = track;
  } else {
                     mFirstTrack = track;
  }
                 mLastTrack = track;
 
                 track->meta = new MetaData;
                 track->includes_expensive_metadata = false;
                 track->skipTrack = false;
                 track->timescale = 0;
                 track->meta->setCString(kKeyMIMEType, ""application/octet-stream"");
  }
 
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset;
  while (*offset < stop_offset) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
 
  if (isTrack) {
  if (mLastTrack->skipTrack) {
  Track *cur = mFirstTrack;
 
  if (cur == mLastTrack) {
  delete cur;
                         mFirstTrack = mLastTrack = NULL;
  } else {
  while (cur && cur->next != mLastTrack) {
                             cur = cur->next;
  }
                         cur->next = NULL;
  delete mLastTrack;
                         mLastTrack = cur;
  }
 
  return OK;
  }
 
  status_t err = verifyTrack(mLastTrack);
 
  if (err != OK) {
  return err;
  }
  } else if (chunk_type == FOURCC('m', 'o', 'o', 'v')) {
                 mInitCheck = OK;
 
  if (!mIsDrm) {
  return UNKNOWN_ERROR;  
  } else {
  return OK;
  }
  }
  break;
  }
 
  case FOURCC('e', 'l', 's', 't'):
  {
  *offset += chunk_size;
 
  uint8_t version;
  if (mDataSource->readAt(data_offset, &version, 1) < 1) {
  return ERROR_IO;
  }
 
  uint32_t entry_count;
  if (!mDataSource->getUInt32(data_offset + 4, &entry_count)) {
  return ERROR_IO;
  }
 
  if (entry_count != 1) {
                 ALOGW(""ignoring edit list with %d entries"", entry_count);
  } else if (mHeaderTimescale == 0) {
                 ALOGW(""ignoring edit list because timescale is 0"");
  } else {
  off64_t entriesoffset = data_offset + 8;
  uint64_t segment_duration;
  int64_t media_time;
 
  if (version == 1) {
  if (!mDataSource->getUInt64(entriesoffset, &segment_duration) ||
  !mDataSource->getUInt64(entriesoffset + 8, (uint64_t*)&media_time)) {
  return ERROR_IO;
  }
  } else if (version == 0) {
  uint32_t sd;
  int32_t mt;
  if (!mDataSource->getUInt32(entriesoffset, &sd) ||
  !mDataSource->getUInt32(entriesoffset + 4, (uint32_t*)&mt)) {
  return ERROR_IO;
  }
                     segment_duration = sd;
                     media_time = mt;
  } else {
  return ERROR_IO;
  }
 
  uint64_t halfscale = mHeaderTimescale / 2;
                 segment_duration = (segment_duration * 1000000 + halfscale)/ mHeaderTimescale;
                 media_time = (media_time * 1000000 + halfscale) / mHeaderTimescale;
 
  int64_t duration;
  int32_t samplerate;
  if (!mLastTrack) {
  return ERROR_MALFORMED;
  }
  if (mLastTrack->meta->findInt64(kKeyDuration, &duration) &&
                         mLastTrack->meta->findInt32(kKeySampleRate, &samplerate)) {
 
  int64_t delay = (media_time  * samplerate + 500000) / 1000000;
                     mLastTrack->meta->setInt32(kKeyEncoderDelay, delay);
 
  int64_t paddingus = duration - (segment_duration + media_time);
  if (paddingus < 0) {
                         paddingus = 0;
  }
  int64_t paddingsamples = (paddingus * samplerate + 500000) / 1000000;
                     mLastTrack->meta->setInt32(kKeyEncoderPadding, paddingsamples);
  }
  }
  break;
  }
 
  case FOURCC('f', 'r', 'm', 'a'):
  {
  *offset += chunk_size;
 
  uint32_t original_fourcc;
  if (mDataSource->readAt(data_offset, &original_fourcc, 4) < 4) {
  return ERROR_IO;
  }
             original_fourcc = ntohl(original_fourcc);
             ALOGV(""read original format: %d"", original_fourcc);
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(original_fourcc));
  uint32_t num_channels = 0;
  uint32_t sample_rate = 0;
  if (AdjustChannelsAndRate(original_fourcc, &num_channels, &sample_rate)) {
                 mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
                 mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
  }
  break;
  }
 
  case FOURCC('t', 'e', 'n', 'c'):
  {
  *offset += chunk_size;
 
  if (chunk_size < 32) {
  return ERROR_MALFORMED;
  }
 
  char buf[4];
             memset(buf, 0, 4);
  if (mDataSource->readAt(data_offset + 4, buf + 1, 3) < 3) {
  return ERROR_IO;
  }
  uint32_t defaultAlgorithmId = ntohl(*((int32_t*)buf));
  if (defaultAlgorithmId > 1) {
  return ERROR_MALFORMED;
  }
 
             memset(buf, 0, 4);
  if (mDataSource->readAt(data_offset + 7, buf + 3, 1) < 1) {
  return ERROR_IO;
  }
  uint32_t defaultIVSize = ntohl(*((int32_t*)buf));
 
  if ((defaultAlgorithmId == 0 && defaultIVSize != 0) ||
  (defaultAlgorithmId != 0 && defaultIVSize == 0)) {
  return ERROR_MALFORMED;
  } else if (defaultIVSize != 0 &&
                     defaultIVSize != 8 &&
                     defaultIVSize != 16) {
  return ERROR_MALFORMED;
  }
 
  uint8_t defaultKeyId[16];
 
  if (mDataSource->readAt(data_offset + 8, &defaultKeyId, 16) < 16) {
  return ERROR_IO;
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setInt32(kKeyCryptoMode, defaultAlgorithmId);
             mLastTrack->meta->setInt32(kKeyCryptoDefaultIVSize, defaultIVSize);
             mLastTrack->meta->setData(kKeyCryptoKey, 'tenc', defaultKeyId, 16);
  break;
  }
 
  case FOURCC('t', 'k', 'h', 'd'):
  {
  *offset += chunk_size;
 
  status_t err;
  if ((err = parseTrackHeader(data_offset, chunk_data_size)) != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('p', 's', 's', 'h'):
  {
  *offset += chunk_size;
 
  PsshInfo pssh;
 
  if (mDataSource->readAt(data_offset + 4, &pssh.uuid, 16) < 16) {
  return ERROR_IO;
  }
 
  uint32_t psshdatalen = 0;
  if (mDataSource->readAt(data_offset + 20, &psshdatalen, 4) < 4) {
  return ERROR_IO;
  }
             pssh.datalen = ntohl(psshdatalen);
             ALOGV(""pssh data size: %d"", pssh.datalen);
  if (chunk_size < 20 || pssh.datalen > chunk_size - 20) {
  return ERROR_MALFORMED;
  }
 
             pssh.data = new (std::nothrow) uint8_t[pssh.datalen];
  if (pssh.data == NULL) {
  return ERROR_MALFORMED;
  }
             ALOGV(""allocated pssh @ %p"", pssh.data);
  ssize_t requested = (ssize_t) pssh.datalen;
  if (mDataSource->readAt(data_offset + 24, pssh.data, requested) < requested) {
  return ERROR_IO;
  }
             mPssh.push_back(pssh);
 
  break;
  }
 
  case FOURCC('m', 'd', 'h', 'd'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 4 || mLastTrack == NULL) {
  return ERROR_MALFORMED;
  }
 
  uint8_t version;
  if (mDataSource->readAt(
                         data_offset, &version, sizeof(version))
  < (ssize_t)sizeof(version)) {
  return ERROR_IO;
  }
 
  off64_t timescale_offset;
 
  if (version == 1) {
                 timescale_offset = data_offset + 4 + 16;
  } else if (version == 0) {
                 timescale_offset = data_offset + 4 + 8;
  } else {
  return ERROR_IO;
  }
 
  uint32_t timescale;
  if (mDataSource->readAt(
                         timescale_offset, &timescale, sizeof(timescale))
  < (ssize_t)sizeof(timescale)) {
  return ERROR_IO;
  }
 
  if (!timescale) {
                 ALOGE(""timescale should not be ZERO."");
  return ERROR_MALFORMED;
  }
 
             mLastTrack->timescale = ntohl(timescale);
 
  int64_t duration = 0;
  if (version == 1) {
  if (mDataSource->readAt(
                             timescale_offset + 4, &duration, sizeof(duration))
  < (ssize_t)sizeof(duration)) {
  return ERROR_IO;
  }
  if (duration != -1) {
                     duration = ntoh64(duration);
  }
  } else {
  uint32_t duration32;
  if (mDataSource->readAt(
                             timescale_offset + 4, &duration32, sizeof(duration32))
  < (ssize_t)sizeof(duration32)) {
  return ERROR_IO;
  }
  if (duration32 != 0xffffffff) {
                     duration = ntohl(duration32);
  }
  }
  if (duration != 0 && mLastTrack->timescale != 0) {
                 mLastTrack->meta->setInt64(
                         kKeyDuration, (duration * 1000000) / mLastTrack->timescale);
  }
 
  uint8_t lang[2];
  off64_t lang_offset;
  if (version == 1) {
                 lang_offset = timescale_offset + 4 + 8;
  } else if (version == 0) {
                 lang_offset = timescale_offset + 4 + 4;
  } else {
  return ERROR_IO;
  }
 
  if (mDataSource->readAt(lang_offset, &lang, sizeof(lang))
  < (ssize_t)sizeof(lang)) {
  return ERROR_IO;
  }
 
  char lang_code[4];
             lang_code[0] = ((lang[0] >> 2) & 0x1f) + 0x60;
             lang_code[1] = ((lang[0] & 0x3) << 3 | (lang[1] >> 5)) + 0x60;
             lang_code[2] = (lang[1] & 0x1f) + 0x60;
             lang_code[3] = '\0';
 
             mLastTrack->meta->setCString(
                     kKeyMediaLanguage, lang_code);
 
  break;
  }
 
  case FOURCC('s', 't', 's', 'd'):
  {
  if (chunk_data_size < 8) {
  return ERROR_MALFORMED;
  }
 
  uint8_t buffer[8];
  if (chunk_data_size < (off64_t)sizeof(buffer)) {
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                         data_offset, buffer, 8) < 8) {
  return ERROR_IO;
  }
 
  if (U32_AT(buffer) != 0) {
  return ERROR_MALFORMED;
  }
 
  uint32_t entry_count = U32_AT(&buffer[4]);
 
  if (entry_count > 1) {
  const char *mime;
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
                 CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
  if (strcasecmp(mime, MEDIA_MIMETYPE_TEXT_3GPP) &&
                         strcasecmp(mime, ""application/octet-stream"")) {
                     mLastTrack->skipTrack = true;
  *offset += chunk_size;
  break;
  }
  }
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset + 8;
  for (uint32_t i = 0; i < entry_count; ++i) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
  break;
  }
 
  case FOURCC('m', 'p', '4', 'a'):
  case FOURCC('e', 'n', 'c', 'a'):
  case FOURCC('s', 'a', 'm', 'r'):
  case FOURCC('s', 'a', 'w', 'b'):
  {
  uint8_t buffer[8 + 20];
  if (chunk_data_size < (ssize_t)sizeof(buffer)) {
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                         data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {
  return ERROR_IO;
  }
 
  uint16_t data_ref_index __unused = U16_AT(&buffer[6]);
  uint32_t num_channels = U16_AT(&buffer[16]);
 
  uint16_t sample_size = U16_AT(&buffer[18]);
  uint32_t sample_rate = U32_AT(&buffer[24]) >> 16;
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
  if (chunk_type != FOURCC('e', 'n', 'c', 'a')) {
                 mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
  AdjustChannelsAndRate(chunk_type, &num_channels, &sample_rate);
  }
             ALOGV(""*** coding='%s' %d channels, size %d, rate %d\n"",
                    chunk, num_channels, sample_size, sample_rate);
             mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
             mLastTrack->meta->setInt32(kKeySampleRate, sample_rate);
 
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset + sizeof(buffer);
  while (*offset < stop_offset) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
  break;
  }
 
  case FOURCC('m', 'p', '4', 'v'):
  case FOURCC('e', 'n', 'c', 'v'):
  case FOURCC('s', '2', '6', '3'):
  case FOURCC('H', '2', '6', '3'):
  case FOURCC('h', '2', '6', '3'):
  case FOURCC('a', 'v', 'c', '1'):
  case FOURCC('h', 'v', 'c', '1'):
  case FOURCC('h', 'e', 'v', '1'):
  {
             mHasVideo = true;
 
  uint8_t buffer[78];
  if (chunk_data_size < (ssize_t)sizeof(buffer)) {
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                         data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {
  return ERROR_IO;
  }
 
  uint16_t data_ref_index __unused = U16_AT(&buffer[6]);
  uint16_t width = U16_AT(&buffer[6 + 18]);
  uint16_t height = U16_AT(&buffer[6 + 20]);
 
  if (width == 0)  width  = 352;
  if (height == 0) height = 288;
 
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
  if (chunk_type != FOURCC('e', 'n', 'c', 'v')) {
                 mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
  }
             mLastTrack->meta->setInt32(kKeyWidth, width);
             mLastTrack->meta->setInt32(kKeyHeight, height);
 
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset + sizeof(buffer);
  while (*offset < stop_offset) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
  break;
  }
 
  case FOURCC('s', 't', 'c', 'o'):
  case FOURCC('c', 'o', '6', '4'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  status_t err =
                 mLastTrack->sampleTable->setChunkOffsetParams(
                         chunk_type, data_offset, chunk_data_size);
 
  *offset += chunk_size;
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('s', 't', 's', 'c'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  status_t err =
                 mLastTrack->sampleTable->setSampleToChunkParams(
                         data_offset, chunk_data_size);
 
  *offset += chunk_size;
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('s', 't', 's', 'z'):
  case FOURCC('s', 't', 'z', '2'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  status_t err =
                 mLastTrack->sampleTable->setSampleSizeParams(
                         chunk_type, data_offset, chunk_data_size);
 
  *offset += chunk_size;
 
  if (err != OK) {
  return err;
  }
 
  size_t max_size;
             err = mLastTrack->sampleTable->getMaxSampleSize(&max_size);
 
  if (err != OK) {
  return err;
  }
 
  if (max_size != 0) {
  if (max_size > SIZE_MAX - 10 * 2) {
                     ALOGE(""max sample size too big: %zu"", max_size);
  return ERROR_MALFORMED;
  }
                 mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);
  } else {
  uint32_t width, height;
  if (!mLastTrack->meta->findInt32(kKeyWidth, (int32_t*)&width) ||
  !mLastTrack->meta->findInt32(kKeyHeight,(int32_t*) &height)) {
                     ALOGE(""No width or height, assuming worst case 1080p"");
                     width = 1920;
                     height = 1080;
  } else {
  if (width > 32768 || height > 32768) {
                         ALOGE(""can't support %u x %u video"", width, height);
  return ERROR_MALFORMED;
  }
  }
 
  const char *mime;
                 CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
  if (!strcmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) {
                     max_size = ((width + 15) / 16) * ((height + 15) / 16) * 192;
  } else {
                     max_size = width * height * 3 / 2;
  }
                 mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size);
  }
 
  const char *mime;
             CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
  if (!strncasecmp(""video/"", mime, 6)) {
  size_t nSamples = mLastTrack->sampleTable->countSamples();
  int64_t durationUs;
  if (mLastTrack->meta->findInt64(kKeyDuration, &durationUs)) {
  if (durationUs > 0) {
  int32_t frameRate = (nSamples * 1000000LL +
  (durationUs >> 1)) / durationUs;
                         mLastTrack->meta->setInt32(kKeyFrameRate, frameRate);
  }
  }
  }
 
  break;
  }
 
  case FOURCC('s', 't', 't', 's'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  *offset += chunk_size;
 
  status_t err =
                 mLastTrack->sampleTable->setTimeToSampleParams(
                         data_offset, chunk_data_size);
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('c', 't', 't', 's'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  *offset += chunk_size;
 
  status_t err =
                 mLastTrack->sampleTable->setCompositionTimeToSampleParams(
                         data_offset, chunk_data_size);
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('s', 't', 's', 's'):
  {
  if ((mLastTrack == NULL) || (mLastTrack->sampleTable == NULL))
  return ERROR_MALFORMED;
 
  *offset += chunk_size;
 
  status_t err =
                 mLastTrack->sampleTable->setSyncSampleParams(
                         data_offset, chunk_data_size);
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC(0xA9, 'x', 'y', 'z'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 8) {
  return ERROR_MALFORMED;
  }
 
  char buffer[18];
 
  off64_t location_length = chunk_data_size - 5;
  if (location_length >= (off64_t) sizeof(buffer)) {
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                         data_offset + 4, buffer, location_length) < location_length) {
  return ERROR_IO;
  }
 
             buffer[location_length] = '\0';
             mFileMetaData->setCString(kKeyLocation, buffer);
  break;
  }
 
  case FOURCC('e', 's', 'd', 's'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 4) {
  return ERROR_MALFORMED;
  }
 
  uint8_t buffer[256];
  if (chunk_data_size > (off64_t)sizeof(buffer)) {
  return ERROR_BUFFER_TOO_SMALL;
  }
 
  if (mDataSource->readAt(
                         data_offset, buffer, chunk_data_size) < chunk_data_size) {
  return ERROR_IO;
  }
 
  if (U32_AT(buffer) != 0) {
  return ERROR_MALFORMED;
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setData(
                     kKeyESDS, kTypeESDS, &buffer[4], chunk_data_size - 4);
 
  if (mPath.size() >= 2
  && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'a')) {
 
  status_t err = updateAudioTrackInfoFromESDS_MPEG4Audio(
  &buffer[4], chunk_data_size - 4);
 
  if (err != OK) {
  return err;
  }
  }
  if (mPath.size() >= 2
  && mPath[mPath.size() - 2] == FOURCC('m', 'p', '4', 'v')) {
                 ESDS esds(&buffer[4], chunk_data_size - 4);
 
  uint8_t objectTypeIndication;
  if (esds.getObjectTypeIndication(&objectTypeIndication) == OK) {
  if (objectTypeIndication >= 0x60 && objectTypeIndication <= 0x65) {
                         mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_MPEG2);
  }
  }
  }
  break;
  }
 
  case FOURCC('a', 'v', 'c', 'C'):
  {
  *offset += chunk_size;
 
  
              sp<ABuffer> buffer = new ABuffer(chunk_data_size);
  
             if (buffer->data() == NULL) {
                 ALOGE(""b/28471206"");
                 return NO_MEMORY;
             }
 
              if (mDataSource->readAt(
                          data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                  return ERROR_IO;
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setData(
                     kKeyAVCC, kTypeAVCC, buffer->data(), chunk_data_size);
 
  break;
  }
  case FOURCC('h', 'v', 'c', 'C'):
 
          {
              sp<ABuffer> buffer = new ABuffer(chunk_data_size);
  
             if (buffer->data() == NULL) {
                 ALOGE(""b/28471206"");
                 return NO_MEMORY;
             }
 
              if (mDataSource->readAt(
                          data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                  return ERROR_IO;
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setData(
                     kKeyHVCC, kTypeHVCC, buffer->data(), chunk_data_size);
 
  *offset += chunk_size;
  break;
  }
 
  case FOURCC('d', '2', '6', '3'):
  {
  *offset += chunk_size;
   
  char buffer[23];
  if (chunk_data_size != 7 &&
                 chunk_data_size != 23) {
                 ALOGE(""Incorrect D263 box size %lld"", (long long)chunk_data_size);
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                     data_offset, buffer, chunk_data_size) < chunk_data_size) {
  return ERROR_IO;
  }
 
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
             mLastTrack->meta->setData(kKeyD263, kTypeD263, buffer, chunk_data_size);
 
  break;
  }
 
  case FOURCC('m', 'e', 't', 'a'):
  {
  off64_t stop_offset = *offset + chunk_size;
  *offset = data_offset;
  bool isParsingMetaKeys = underQTMetaPath(mPath, 2);
  if (!isParsingMetaKeys) {
  uint8_t buffer[4];
  if (chunk_data_size < (off64_t)sizeof(buffer)) {
  *offset = stop_offset;
  return ERROR_MALFORMED;
  }
 
  if (mDataSource->readAt(
                             data_offset, buffer, 4) < 4) {
  *offset = stop_offset;
  return ERROR_IO;
  }
 
  if (U32_AT(buffer) != 0) {
 
  *offset = stop_offset;
  return OK;
  }
  *offset += sizeof(buffer);
  }
 
  while (*offset < stop_offset) {
  status_t err = parseChunk(offset, depth + 1);
  if (err != OK) {
  return err;
  }
  }
 
  if (*offset != stop_offset) {
  return ERROR_MALFORMED;
  }
  break;
  }
 
  case FOURCC('m', 'e', 'a', 'n'):
  case FOURCC('n', 'a', 'm', 'e'):
  case FOURCC('d', 'a', 't', 'a'):
  {
  *offset += chunk_size;
 
  if (mPath.size() == 6 && underMetaDataPath(mPath)) {
  status_t err = parseITunesMetaData(data_offset, chunk_data_size);
 
  if (err != OK) {
  return err;
  }
  }
 
  break;
  }
 
  case FOURCC('m', 'v', 'h', 'd'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 32) {
  return ERROR_MALFORMED;
  }
 
  uint8_t header[32];
  if (mDataSource->readAt(
                         data_offset, header, sizeof(header))
  < (ssize_t)sizeof(header)) {
  return ERROR_IO;
  }
 
  uint64_t creationTime;
  uint64_t duration = 0;
  if (header[0] == 1) {
                 creationTime = U64_AT(&header[4]);
                 mHeaderTimescale = U32_AT(&header[20]);
                 duration = U64_AT(&header[24]);
  if (duration == 0xffffffffffffffff) {
                     duration = 0;
  }
  } else if (header[0] != 0) {
  return ERROR_MALFORMED;
  } else {
                 creationTime = U32_AT(&header[4]);
                 mHeaderTimescale = U32_AT(&header[12]);
  uint32_t d32 = U32_AT(&header[16]);
  if (d32 == 0xffffffff) {
                     d32 = 0;
  }
                 duration = d32;
  }
  if (duration != 0 && mHeaderTimescale != 0) {
                 mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);
  }
 
  String8 s;
             convertTimeToDate(creationTime, &s);
 
             mFileMetaData->setCString(kKeyDate, s.string());
 
  break;
  }
 
  case FOURCC('m', 'e', 'h', 'd'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 8) {
  return ERROR_MALFORMED;
  }
 
  uint8_t flags[4];
  if (mDataSource->readAt(
                         data_offset, flags, sizeof(flags))
  < (ssize_t)sizeof(flags)) {
  return ERROR_IO;
  }
 
  uint64_t duration = 0;
  if (flags[0] == 1) {
  if (chunk_data_size < 12) {
  return ERROR_MALFORMED;
  }
                 mDataSource->getUInt64(data_offset + 4, &duration);
  if (duration == 0xffffffffffffffff) {
                     duration = 0;
  }
  } else if (flags[0] == 0) {
  uint32_t d32;
                 mDataSource->getUInt32(data_offset + 4, &d32);
  if (d32 == 0xffffffff) {
                     d32 = 0;
  }
                 duration = d32;
  } else {
  return ERROR_MALFORMED;
  }
 
  if (duration != 0 && mHeaderTimescale != 0) {
                 mFileMetaData->setInt64(kKeyDuration, duration * 1000000 / mHeaderTimescale);
  }
 
  break;
  }
 
  case FOURCC('m', 'd', 'a', 't'):
  {
             ALOGV(""mdat chunk, drm: %d"", mIsDrm);
 
             mMdatFound = true;
 
  if (!mIsDrm) {
  *offset += chunk_size;
  break;
  }
 
  if (chunk_size < 8) {
  return ERROR_MALFORMED;
  }
 
  return parseDrmSINF(offset, data_offset);
  }
 
  case FOURCC('h', 'd', 'l', 'r'):
  {
  *offset += chunk_size;
 
  if (underQTMetaPath(mPath, 3)) {
  break;
  }
 
  uint32_t buffer;
  if (mDataSource->readAt(
                         data_offset + 8, &buffer, 4) < 4) {
  return ERROR_IO;
  }
 
  uint32_t type = ntohl(buffer);
  if (type == FOURCC('t', 'e', 'x', 't') || type == FOURCC('s', 'b', 't', 'l')) {
  if (mLastTrack != NULL) {
                     mLastTrack->meta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_TEXT_3GPP);
  }
  }
 
  break;
  }
 
  case FOURCC('k', 'e', 'y', 's'):
  {
  *offset += chunk_size;
 
  if (underQTMetaPath(mPath, 3)) {
                 parseQTMetaKey(data_offset, chunk_data_size);
  }
  break;
  }
 
  case FOURCC('t', 'r', 'e', 'x'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 24) {
  return ERROR_IO;
  }
  Trex trex;
  if (!mDataSource->getUInt32(data_offset + 4, &trex.track_ID) ||
  !mDataSource->getUInt32(data_offset + 8, &trex.default_sample_description_index) ||
  !mDataSource->getUInt32(data_offset + 12, &trex.default_sample_duration) ||
  !mDataSource->getUInt32(data_offset + 16, &trex.default_sample_size) ||
  !mDataSource->getUInt32(data_offset + 20, &trex.default_sample_flags)) {
  return ERROR_IO;
  }
             mTrex.add(trex);
  break;
  }
 
  case FOURCC('t', 'x', '3', 'g'):
  {
  if (mLastTrack == NULL)
  return ERROR_MALFORMED;
 
  uint32_t type;
  const void *data;
  size_t size = 0;
  if (!mLastTrack->meta->findData(
                     kKeyTextFormatData, &type, &data, &size)) {
                 size = 0;
  }
 
  if ((chunk_size > SIZE_MAX) || (SIZE_MAX - chunk_size <= size)) {
  return ERROR_MALFORMED;
  }
 
  uint8_t *buffer = new (std::nothrow) uint8_t[size + chunk_size];
  if (buffer == NULL) {
  return ERROR_MALFORMED;
  }
 
  if (size > 0) {
                 memcpy(buffer, data, size);
  }
 
  if ((size_t)(mDataSource->readAt(*offset, buffer + size, chunk_size))
  < chunk_size) {
  delete[] buffer;
                 buffer = NULL;
 
  *offset += chunk_size;
  return ERROR_IO;
  }
 
             mLastTrack->meta->setData(
                     kKeyTextFormatData, 0, buffer, size + chunk_size);
 
  delete[] buffer;
 
  *offset += chunk_size;
  break;
  }
 
  case FOURCC('c', 'o', 'v', 'r'):
  {
  *offset += chunk_size;
 
  if (mFileMetaData != NULL) {
                 ALOGV(""chunk_data_size = %"" PRId64 "" and data_offset = %"" PRId64,
                       chunk_data_size, data_offset);
 
  if (chunk_data_size < 0 || static_cast<uint64_t>(chunk_data_size) >= SIZE_MAX - 1) {
 
                      return ERROR_MALFORMED;
                  }
                  sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
                 if (buffer->data() == NULL) {
                     ALOGE(""b/28471206"");
                     return NO_MEMORY;
                 }
                  if (mDataSource->readAt(
                      data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
                      return ERROR_IO;
  }
  const int kSkipBytesOfDataBox = 16;
  if (chunk_data_size <= kSkipBytesOfDataBox) {
  return ERROR_MALFORMED;
  }
 
                 mFileMetaData->setData(
                     kKeyAlbumArt, MetaData::TYPE_NONE,
                     buffer->data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);
  }
 
  break;
  }
 
  case FOURCC('t', 'i', 't', 'l'):
  case FOURCC('p', 'e', 'r', 'f'):
  case FOURCC('a', 'u', 't', 'h'):
  case FOURCC('g', 'n', 'r', 'e'):
  case FOURCC('a', 'l', 'b', 'm'):
  case FOURCC('y', 'r', 'r', 'c'):
  {
  *offset += chunk_size;
 
  status_t err = parse3GPPMetaData(data_offset, chunk_data_size, depth);
 
  if (err != OK) {
  return err;
  }
 
  break;
  }
 
  case FOURCC('I', 'D', '3', '2'):
  {
  *offset += chunk_size;
 
  if (chunk_data_size < 6) {
  return ERROR_MALFORMED;
  }
 
             parseID3v2MetaData(data_offset + 6);
 
  break;
  }
 
  case FOURCC('-', '-', '-', '-'):
  {
             mLastCommentMean.clear();
             mLastCommentName.clear();
             mLastCommentData.clear();
  *offset += chunk_size;
  break;
  }
 
  case FOURCC('s', 'i', 'd', 'x'):
  {
             parseSegmentIndex(data_offset, chunk_data_size);
  *offset += chunk_size;
  return UNKNOWN_ERROR;  
  }
 
  default:
  {
  if (underQTMetaPath(mPath, 3)) {
                 parseQTMetaVal(chunk_type, data_offset, chunk_data_size);
  }
 
  *offset += chunk_size;
  break;
  }
  }
 
  return OK;
 }","[869, 870, 871, 872, 873, 892, 893, 894, 895, 896, 1209, 1210, 1211, 1212]","MPEG4Extractor.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not check whether memory allocation succeeds, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted file, aka internal bug 28471206."
2054,"void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,
std::unique_ptr<folly::IOBuf> value_chain) {
Cursor keyCur(key_chain.get());
auto key = keyCur.readFixedString(key_chain->computeChainDataLength());

Cursor valCur(value_chain.get());
auto value = valCur.readFixedString(value_chain->computeChainDataLength());

m_requestParams[key] = value;
}",[6],"HHVM does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an ""httpoxy"" issue. This issue affects HHVM versions prior to 3.9.6, all versions between 3.10.0 and 3.12.4 (inclusive), and all versions between 3.13.0 and 3.14.2 (inclusive)."
208110," VOID ixheaacd_esbr_radix4bfly(const WORD32 *w, WORD32 *x, WORD32 index1,
 
                                WORD32 index) {
    int i;
    WORD32 l1, l2, h2, fft_jmp;
  WORD32 xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
  WORD32 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
   WORD64 xt0_0, yt0_0, xt1_0, yt1_0, xt2_0, yt2_0;
   WORD64 xh0_0, xh1_0, xh20_0, xh21_0, xl0_0, xl1_0, xl20_0, xl21_0;
    WORD32 x_0, x_1, x_l1_0, x_l1_1, x_l2_0, x_l2_1;
    WORD32 x_h2_0, x_h2_1;
    WORD32 si10, si20, si30, co10, co20, co30;
 
   WORD64 mul_1, mul_2, mul_3, mul_4, mul_5, mul_6;
   WORD64 mul_7, mul_8, mul_9, mul_10, mul_11, mul_12;
   WORD32 *x_l1;
   WORD32 *x_l2;
   WORD32 *x_h2;
  const WORD32 *w_ptr = w;
   WORD32 i1;
 
   h2 = index << 1;
   l1 = index << 2;
   l2 = (index << 2) + (index << 1);
 
   x_l1 = &(x[l1]);
   x_l2 = &(x[l2]);
   x_h2 = &(x[h2]);
 
   fft_jmp = 6 * (index);
 
  for (i1 = 0; i1 < index1; i1++) {
  for (i = 0; i < index; i++) {
       si10 = (*w_ptr++);
       co10 = (*w_ptr++);
       si20 = (*w_ptr++);
       co20 = (*w_ptr++);
       si30 = (*w_ptr++);
       co30 = (*w_ptr++);
 
       x_0 = x[0];
       x_h2_0 = x[h2];
 
        x_l1_0 = x[l1];
        x_l2_0 = x[l2];
  
      xh0_0 = x_0 + x_l1_0;
      xl0_0 = x_0 - x_l1_0;
       xh0_0 = (WORD64)x_0 + (WORD64)x_l1_0;
       xl0_0 = (WORD64)x_0 - (WORD64)x_l1_0;
  
      xh20_0 = x_h2_0 + x_l2_0;
      xl20_0 = x_h2_0 - x_l2_0;
       xh20_0 = (WORD64)x_h2_0 + (WORD64)x_l2_0;
       xl20_0 = (WORD64)x_h2_0 - (WORD64)x_l2_0;
  
      x[0] = xh0_0 + xh20_0;
      xt0_0 = xh0_0 - xh20_0;
       x[0] = (WORD32)ixheaacd_add64_sat(xh0_0, xh20_0);
       xt0_0 = (WORD64)xh0_0 - (WORD64)xh20_0;
  
        x_1 = x[1];
        x_h2_1 = x[h2 + 1];
        x_l1_1 = x[l1 + 1];
        x_l2_1 = x[l2 + 1];
  
      xh1_0 = x_1 + x_l1_1;
      xl1_0 = x_1 - x_l1_1;
       xh1_0 = (WORD64)x_1 + (WORD64)x_l1_1;
       xl1_0 = (WORD64)x_1 - (WORD64)x_l1_1;
  
      xh21_0 = x_h2_1 + x_l2_1;
      xl21_0 = x_h2_1 - x_l2_1;
       xh21_0 = (WORD64)x_h2_1 + (WORD64)x_l2_1;
       xl21_0 = (WORD64)x_h2_1 - (WORD64)x_l2_1;
  
      x[1] = xh1_0 + xh21_0;
      yt0_0 = xh1_0 - xh21_0;
       x[1] = (WORD32)ixheaacd_add64_sat(xh1_0, xh21_0);
       yt0_0 = (WORD64)xh1_0 - (WORD64)xh21_0;
  
      xt1_0 = xl0_0 + xl21_0;
      xt2_0 = xl0_0 - xl21_0;
       xt1_0 = (WORD64)xl0_0 + (WORD64)xl21_0;
       xt2_0 = (WORD64)xl0_0 - (WORD64)xl21_0;
  
      yt2_0 = xl1_0 + xl20_0;
      yt1_0 = xl1_0 - xl20_0;
       yt2_0 = (WORD64)xl1_0 + (WORD64)xl20_0;
       yt1_0 = (WORD64)xl1_0 - (WORD64)xl20_0;
  
        mul_11 = ixheaacd_mult64(xt2_0, co30);
        mul_3 = ixheaacd_mult64(yt2_0, si30);
       x[l2] = (WORD32)((mul_3 + mul_11) >> 32) << RADIXSHIFT;
 
       mul_5 = ixheaacd_mult64(xt2_0, si30);
       mul_9 = ixheaacd_mult64(yt2_0, co30);
       x[l2 + 1] = (WORD32)((mul_9 - mul_5) >> 32) << RADIXSHIFT;
 
       mul_12 = ixheaacd_mult64(xt0_0, co20);
       mul_2 = ixheaacd_mult64(yt0_0, si20);
       x[l1] = (WORD32)((mul_2 + mul_12) >> 32) << RADIXSHIFT;
 
       mul_6 = ixheaacd_mult64(xt0_0, si20);
       mul_8 = ixheaacd_mult64(yt0_0, co20);
       x[l1 + 1] = (WORD32)((mul_8 - mul_6) >> 32) << RADIXSHIFT;
 
       mul_4 = ixheaacd_mult64(xt1_0, co10);
       mul_1 = ixheaacd_mult64(yt1_0, si10);
       x[h2] = (WORD32)((mul_1 + mul_4) >> 32) << RADIXSHIFT;
 
       mul_10 = ixheaacd_mult64(xt1_0, si10);
       mul_7 = ixheaacd_mult64(yt1_0, co10);
       x[h2 + 1] = (WORD32)((mul_7 - mul_10) >> 32) << RADIXSHIFT;
 
       x += 2;
  }
     x += fft_jmp;
     w_ptr = w_ptr - fft_jmp;
  }
 }","[8, 9, 49, 50, 54, 55, 59, 60, 69, 70, 74, 75, 79, 80, 84, 85, 89, 90, 6, 7, 47, 48, 52, 53, 57, 58, 67, 68, 72, 73, 77, 78, 82, 83, 87, 88]",In ixheaacd_real_synth_fft_p3 of ixheaacd_esbr_fft.c there is a possible out of bounds write due to a missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-9.0 Android ID: A-110769924
7596,"static int ssl_verify_cert(struct tunnel *tunnel)
{
int ret = -1;
int cert_valid = 0;
unsigned char digest[SHA256LEN];
unsigned int len;
struct x509_digest *elem;
char digest_str[SHA256STRLEN], *subject, *issuer;
char *line;
int i;
X509_NAME *subj;

SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);

X509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);
if (cert == NULL) {
log_error(""Unable to get gateway certificate.\n"");
return 1;
}

subj = X509_get_subject_name(cert);

#ifdef HAVE_X509_CHECK_HOST



if (X509_check_host(cert, tunnel->config->gateway_host,
0, 0, NULL) == 1)
cert_valid = 1;
#else
char common_name[FIELD_SIZE + 1];


if (subj
&& X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,
FIELD_SIZE) > 0
&& strncasecmp(common_name, tunnel->config->gateway_host,
FIELD_SIZE) == 0)
cert_valid = 1;
#endif


if (cert_valid
&& SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {
log_debug(""Gateway certificate validation succeeded.\n"");
ret = 0;
goto free_cert;
}
log_debug(""Gateway certificate validation failed.\n"");


if (X509_digest(cert, EVP_sha256(), digest, &len) <= 0
|| len != SHA256LEN) {
log_error(""Could not compute certificate sha256 digest.\n"");
goto free_cert;
}

for (i = 0; i < SHA256LEN; i++)
sprintf(&digest_str[2 * i], ""%02x"", digest[i]);
digest_str[SHA256STRLEN - 1] = '\0';

for (elem = tunnel->config->cert_whitelist; elem != NULL;
elem = elem->next)
if (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)
break;
if (elem != NULL) {
log_debug(""Gateway certificate digest found in white list.\n"");
ret = 0;
goto free_cert;
}

subject = X509_NAME_oneline(subj, NULL, 0);
issuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);

log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n"");
log_error(""    --trusted-cert %s\n"", digest_str);
log_error(""or add this line to your config file:\n"");
log_error(""    trusted-cert = %s\n"", digest_str);
log_error(""Gateway certificate:\n"");
log_error(""    subject:\n"");
for (line = strtok(subject, ""/""); line != NULL;
line = strtok(NULL, ""/""))
log_error(""        %s\n"", line);
log_error(""    issuer:\n"");
for (line = strtok(issuer, ""/""); line != NULL;
line = strtok(NULL, ""/""))
log_error(""        %s\n"", line);
log_error(""    sha256 digest:\n"");
log_error(""        %s\n"", digest_str);

free_cert:
X509_free(cert);
return ret;
}","[31, 34, 35, 36, 37, 38, 39]","An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL before 1.0.2. tunnel.c mishandles certificate validation because hostname comparisons do not consider '\0' characters, as demonstrated by a good.example.com\x00evil.example.com attack."
208161," status_t OMXNodeInstance::setParameter(
         OMX_INDEXTYPE index, const void *params, size_t size) {
  Mutex::Autolock autoLock(mLock);
 
      OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
      CLOG_CONFIG(setParameter, ""%s(%#x), %zu@%p)"", asString(extIndex), index, size, params);
  
     if (isProhibitedIndex_l(index)) {
         android_errorWriteLog(0x534e4554, ""29422020"");
         return BAD_INDEX;
     }
 
      OMX_ERRORTYPE err = OMX_SetParameter(
              mHandle, index, const_cast<void *>(params));
      CLOG_IF_ERROR(setParameter, err, ""%s(%#x)"", asString(extIndex), index);
  return StatusFromOMXError(err);
 }","[8, 9, 10, 11, 12]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
205231," bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest) {
 bool AudioRendererAlgorithm::OutputFasterPlayback(uint8* dest,
                                                   int input_step,
                                                   int output_step) {
    
   CHECK_GT(input_step, output_step);
    DCHECK_LT(index_into_window_, window_size_);
    DCHECK_GT(playback_rate_, 1.0);
  
   if (audio_buffer_.forward_bytes() < bytes_per_frame_)
     return false;
 
  int input_step = window_size_;
  int output_step = ceil(window_size_ / playback_rate_);
  AlignToFrameBoundary(&output_step);
  DCHECK_GT(input_step, output_step);
    int bytes_to_crossfade = bytes_in_crossfade_;
    if (muted_ || bytes_to_crossfade > output_step)
      bytes_to_crossfade = 0;
 
   int outtro_crossfade_begin = output_step - bytes_to_crossfade;
 
   int outtro_crossfade_end = output_step;
 
   int intro_crossfade_begin = input_step - bytes_to_crossfade;
 
   if (index_into_window_ < outtro_crossfade_begin) {
     CopyWithAdvance(dest);
     index_into_window_ += bytes_per_frame_;
     return true;
   }
 
   while (index_into_window_ < outtro_crossfade_end) {
     if (audio_buffer_.forward_bytes() < bytes_per_frame_)
       return false;
 
     DCHECK_GT(bytes_to_crossfade, 0);
     uint8* place_to_copy = crossfade_buffer_.get() +
         (index_into_window_ - outtro_crossfade_begin);
     CopyWithAdvance(place_to_copy);
     index_into_window_ += bytes_per_frame_;
   }
 
   while (index_into_window_ < intro_crossfade_begin) {
     if (audio_buffer_.forward_bytes() < bytes_per_frame_)
       return false;
 
     DropFrame();
     index_into_window_ += bytes_per_frame_;
   }
 
   if (audio_buffer_.forward_bytes() < bytes_per_frame_)
     return false;
 
   if (bytes_to_crossfade == 0) {
     DCHECK_EQ(index_into_window_, window_size_);
     return false;
   }
 
   DCHECK_LT(index_into_window_, window_size_);
   int offset_into_buffer = index_into_window_ - intro_crossfade_begin;
   memcpy(dest, crossfade_buffer_.get() + offset_into_buffer,
          bytes_per_frame_);
   scoped_array<uint8> intro_frame_ptr(new uint8[bytes_per_frame_]);
   audio_buffer_.Read(intro_frame_ptr.get(), bytes_per_frame_);
   OutputCrossfadedFrame(dest, intro_frame_ptr.get());
   index_into_window_ += bytes_per_frame_;
    return true;
  }","[2, 3, 4, 5, 6, 13, 14, 15, 16]",Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service (out-of-bounds read) via vectors involving seek operations on video data.
9229,"MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {
if (!result) {
debug_print(""Result structure is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
result->start = result->end = NULL;
*(result->value) = '\0';
if (!data_start || !data_end) {
debug_print(""Data is null%s"", ""\n"");
return MOBI_PARAM_ERR;
}
size_t needle_length = strlen(needle);
if (needle_length > MOBI_ATTRNAME_MAXSIZE) {
debug_print(""Attribute too long: %zu\n"", needle_length);
return MOBI_PARAM_ERR;
}
if (data_start + needle_length > data_end) {
return MOBI_SUCCESS;
}
unsigned char *data = (unsigned char *) data_start;
unsigned char tag_open;
unsigned char tag_close;
if (type == T_CSS) {
tag_open = '{';
tag_close = '}';
} else {
tag_open = '<';
tag_close = '>';
}
unsigned char last_border = tag_close;
while (data <= data_end) {
if (*data == tag_open || *data == tag_close) {
last_border = *data;
}
if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {

if (last_border != tag_open) {

data += needle_length;
continue;
}

while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {
data--;
}
result->is_url = (*data == '(');
result->start = ++data;

int i = 0;
while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {
result->value[i++] = (char) *data++;
}

if (*(data - 1) == '/' && *data == '>') {
--data; --i;
}
result->end = data;
result->value[i] = '\0';
return MOBI_SUCCESS;
}
data++;
}
return MOBI_SUCCESS;
}",[54],Buffer Over-read in GitHub repository bfabiszewski/libmobi prior to 0.11.
204339," bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)
 {
      NPEvent npEvent;
      NPMouseEvent mouse;
  
    switch (point.m_state) {
     switch (point.state()) {
      case Platform::TouchPoint::TouchPressed:
          mouse.type = MOUSE_BUTTON_DOWN;
          break;
     case Platform::TouchPoint::TouchReleased:
         mouse.type = MOUSE_BUTTON_UP;
         break;
     case Platform::TouchPoint::TouchMoved:
         mouse.type = MOUSE_MOTION;
         break;
     case Platform::TouchPoint::TouchStationary:
          return true;
      }
  
    mouse.x = point.m_screenPos.x();
    mouse.y = point.m_screenPos.y();
     mouse.x = point.screenPosition().x();
     mouse.y = point.screenPosition().y();
      mouse.button = mouse.type != MOUSE_BUTTON_UP;
      mouse.flags = 0;
      npEvent.type = NP_MouseEvent;
     npEvent.data = &mouse;
 
     pluginView->dispatchFullScreenNPEvent(npEvent);
     return true;
 }","[7, 23, 24, 6, 21, 22]",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
198617," SProcXIBarrierReleasePointer(ClientPtr client)
 {
     xXIBarrierReleasePointerInfo *info;
     REQUEST(xXIBarrierReleasePointerReq);
     int i;
 
     swaps(&stuff->length);
      REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);
  
      swapl(&stuff->num_barriers);
     if (stuff->num_barriers > UINT32_MAX / sizeof(xXIBarrierReleasePointerInfo))
         return BadLength;
      REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));
  
      info = (xXIBarrierReleasePointerInfo*) &stuff[1];
         swapl(&info->barrier);
         swapl(&info->eventid);
     }","[11, 12]",xorg-x11-server before 1.19.5 was vulnerable to integer overflow in (S)ProcXIBarrierReleasePointer functions allowing malicious X client to cause X server to crash or possibly execute arbitrary code.
207517," static int accept_server_socket(int sfd)
 {
  struct sockaddr_un remote;
  struct pollfd pfd;
  int fd;
  socklen_t len = sizeof(struct sockaddr_un);
 
     BTIF_TRACE_EVENT(""accept fd %d"", sfd);
 
   
 
      pfd.fd = sfd;
      pfd.events = POLLIN;
  
    if (poll(&pfd, 1, 0) == 0)
     if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)
      {
          BTIF_TRACE_EVENT(""accept poll timeout"");
          return -1;
  }
 
  
  
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)
      {
           BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
           return -1;
  }
 
 
  return fd;
 }","[16, 25, 15, 24]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
2496,"MagickExport MagickBooleanType DrawPrimitive(Image *image,
const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,
ExceptionInfo *exception)
{
CacheView
*image_view;

MagickStatusType
status;

register ssize_t
i,
x;

ssize_t
y;

if (image->debug != MagickFalse)
{
(void) LogMagickEvent(DrawEvent,GetMagickModule(),
""  begin draw-primitive"");
(void) LogMagickEvent(DrawEvent,GetMagickModule(),
""    affine: %g %g %g %g %g %g"",draw_info->affine.sx,
draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,
draw_info->affine.tx,draw_info->affine.ty);
}
if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&
((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||
(IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))
(void) SetImageColorspace(image,sRGBColorspace,exception);
status=MagickTrue;
x=(ssize_t) ceil(primitive_info->point.x-0.5);
y=(ssize_t) ceil(primitive_info->point.y-0.5);
image_view=AcquireAuthenticCacheView(image,exception);
switch (primitive_info->primitive)
{
case AlphaPrimitive:
{
if (image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
switch (primitive_info->method)
{
case PointMethod:
default:
{
PixelInfo
pixel;

register Quantum
*q;

q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
(void) SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case ReplaceMethod:
{
MagickBooleanType
sync;

PixelInfo
pixel,
target;

(void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
exception);
GetPixelInfo(image,&pixel);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;

q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetPixelInfoPixel(image,q,&pixel);
if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
{
q+=GetPixelChannels(image);
continue;
}
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
q+=GetPixelChannels(image);
}
sync=SyncCacheViewAuthenticPixels(image_view,exception);
if (sync == MagickFalse)
break;
}
break;
}
case FloodfillMethod:
case FillToBorderMethod:
{
ChannelType
channel_mask;

PixelInfo
target;

(void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
&target,exception);
if (primitive_info->method == FillToBorderMethod)
{
target.red=(double) draw_info->border_color.red;
target.green=(double) draw_info->border_color.green;
target.blue=(double) draw_info->border_color.blue;
}
channel_mask=SetImageChannelMask(image,AlphaChannel);
status&=FloodfillPaintImage(image,draw_info,&target,x,y,
primitive_info->method == FloodfillMethod ? MagickFalse :
MagickTrue,exception);
(void) SetImageChannelMask(image,channel_mask);
break;
}
case ResetMethod:
{
MagickBooleanType
sync;

PixelInfo
pixel;

for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;

q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
q+=GetPixelChannels(image);
}
sync=SyncCacheViewAuthenticPixels(image_view,exception);
if (sync == MagickFalse)
break;
}
break;
}
}
break;
}
case ColorPrimitive:
{
switch (primitive_info->method)
{
case PointMethod:
default:
{
PixelInfo
pixel;

register Quantum
*q;

q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetPixelInfo(image,&pixel);
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
(void) SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case ReplaceMethod:
{
MagickBooleanType
sync;

PixelInfo
pixel,
target;

(void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,
exception);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;

q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetPixelInfoPixel(image,q,&pixel);
if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
{
q+=GetPixelChannels(image);
continue;
}
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
q+=GetPixelChannels(image);
}
sync=SyncCacheViewAuthenticPixels(image_view,exception);
if (sync == MagickFalse)
break;
}
break;
}
case FloodfillMethod:
case FillToBorderMethod:
{
PixelInfo
target;

(void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,
&target,exception);
if (primitive_info->method == FillToBorderMethod)
{
target.red=(double) draw_info->border_color.red;
target.green=(double) draw_info->border_color.green;
target.blue=(double) draw_info->border_color.blue;
}
status&=FloodfillPaintImage(image,draw_info,&target,x,y,
primitive_info->method == FloodfillMethod ? MagickFalse :
MagickTrue,exception);
break;
}
case ResetMethod:
{
MagickBooleanType
sync;

PixelInfo
pixel;

GetPixelInfo(image,&pixel);
for (y=0; y < (ssize_t) image->rows; y++)
{
register Quantum
*magick_restrict q;

q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
exception);
if (q == (Quantum *) NULL)
break;
for (x=0; x < (ssize_t) image->columns; x++)
{
GetFillColor(draw_info,x,y,&pixel,exception);
SetPixelViaPixelInfo(image,&pixel,q);
q+=GetPixelChannels(image);
}
sync=SyncCacheViewAuthenticPixels(image_view,exception);
if (sync == MagickFalse)
break;
}
break;
}
}
break;
}
case ImagePrimitive:
{
AffineMatrix
affine;

char
composite_geometry[MagickPathExtent];

Image
*composite_image;

ImageInfo
*clone_info;

RectangleInfo
geometry;

ssize_t
x1,
y1;

if (primitive_info->text == (char *) NULL)
break;
clone_info=AcquireImageInfo();
if (LocaleNCompare(primitive_info->text,""data:"",5) == 0)
composite_image=ReadInlineImage(clone_info,primitive_info->text,
exception);
else
{
(void) CopyMagickString(clone_info->filename,primitive_info->text,
MagickPathExtent);
composite_image=ReadImage(clone_info,exception);
}
clone_info=DestroyImageInfo(clone_info);
if (composite_image == (Image *) NULL)
break;
(void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)
NULL,(void *) NULL);
x1=(ssize_t) ceil(primitive_info[1].point.x-0.5);
y1=(ssize_t) ceil(primitive_info[1].point.y-0.5);
if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||
((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))
{



(void) FormatLocaleString(composite_geometry,MagickPathExtent,
""%gx%g!"",primitive_info[1].point.x,primitive_info[1].point.y);
composite_image->filter=image->filter;
(void) TransformImage(&composite_image,(char *) NULL,
composite_geometry,exception);
}
if (composite_image->alpha_trait == UndefinedPixelTrait)
(void) SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,
exception);
if (draw_info->alpha != OpaqueAlpha)
(void) SetImageAlpha(composite_image,draw_info->alpha,exception);
SetGeometry(image,&geometry);
image->gravity=draw_info->gravity;
geometry.x=x;
geometry.y=y;
(void) FormatLocaleString(composite_geometry,MagickPathExtent,
""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,(double)
composite_image->rows,(double) geometry.x,(double) geometry.y);
(void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);
affine=draw_info->affine;
affine.tx=(double) geometry.x;
affine.ty=(double) geometry.y;
composite_image->interpolate=image->interpolate;
if (draw_info->compose == OverCompositeOp)
(void) DrawAffineImage(image,composite_image,&affine,exception);
else
(void) CompositeImage(image,composite_image,draw_info->compose,
MagickTrue,geometry.x,geometry.y,exception);
composite_image=DestroyImage(composite_image);
break;
}
case PointPrimitive:
{
PixelInfo
fill_color;

register Quantum
*q;

if ((y < 0) || (y >= (ssize_t) image->rows))
break;
if ((x < 0) || (x >= (ssize_t) image->columns))
break;
q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);
if (q == (Quantum *) NULL)
break;
GetFillColor(draw_info,x,y,&fill_color,exception);
CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,
(double) GetPixelAlpha(image,q),q);
(void) SyncCacheViewAuthenticPixels(image_view,exception);
break;
}
case TextPrimitive:
{
char
geometry[MagickPathExtent];

DrawInfo
*clone_info;

if (primitive_info->text == (char *) NULL)
break;
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
(void) CloneString(&clone_info->text,primitive_info->text);
(void) FormatLocaleString(geometry,MagickPathExtent,""%+f%+f"",
primitive_info->point.x,primitive_info->point.y);
(void) CloneString(&clone_info->geometry,geometry);
status&=AnnotateImage(image,clone_info,exception);
clone_info=DestroyDrawInfo(clone_info);
break;
}
default:
{
double
mid,
scale;

DrawInfo
*clone_info;

if (IsEventLogging() != MagickFalse)
LogPrimitiveInfo(primitive_info);
scale=ExpandAffine(&draw_info->affine);
if ((draw_info->dash_pattern != (double *) NULL) &&
(draw_info->dash_pattern[0] != 0.0) &&
((scale*draw_info->stroke_width) >= MagickEpsilon) &&
(draw_info->stroke.alpha != (Quantum) TransparentAlpha))
{



clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
clone_info->stroke_width=0.0;
clone_info->stroke.alpha=(Quantum) TransparentAlpha;
status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
exception);
clone_info=DestroyDrawInfo(clone_info);
(void) DrawDashPolygon(draw_info,primitive_info,image,exception);
break;
}
mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
if ((mid > 1.0) &&
((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||
(draw_info->stroke_pattern != (Image *) NULL)))
{
MagickBooleanType
closed_path;




for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
closed_path=
(primitive_info[i-1].point.x == primitive_info[0].point.x) &&
(primitive_info[i-1].point.y == primitive_info[0].point.y) ?
MagickTrue : MagickFalse;
i=(ssize_t) primitive_info[0].coordinates;
if ((((draw_info->linecap == RoundCap) ||
(closed_path != MagickFalse)) &&
(draw_info->linejoin == RoundJoin)) ||
(primitive_info[i].primitive != UndefinedPrimitive))
{
(void) DrawPolygonPrimitive(image,draw_info,primitive_info,
exception);
break;
}
clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
clone_info->stroke_width=0.0;
clone_info->stroke.alpha=(Quantum) TransparentAlpha;
status&=DrawPolygonPrimitive(image,clone_info,primitive_info,
exception);
clone_info=DestroyDrawInfo(clone_info);
status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);
break;
}
status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);
break;
}
}
image_view=DestroyCacheView(image_view);
if (image->debug != MagickFalse)
(void) LogMagickEvent(DrawEvent,GetMagickModule(),""  end draw-primitive"");
return(status != 0 ? MagickTrue : MagickFalse);
}","[406, 441]","The DrawDashPolygon function in MagickCore/draw.c in ImageMagick before 6.9.4-0 and 7.x before 7.0.1-2 mishandles calculations of certain vertices integer data, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
199534," static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)
 {
 	struct user *dummy = NULL;
 	addr_t offset;
 
 	if (addr < (addr_t) &dummy->regs.acrs) {
 		 
 		if (addr == (addr_t) &dummy->regs.psw.mask) {
  			unsigned long mask = PSW_MASK_USER;
  
  			mask |= is_ri_task(child) ? PSW_MASK_RI : 0;
			if ((data & ~mask) != PSW_USER_BITS)
 			if ((data ^ PSW_USER_BITS) & ~mask)
 				 
 				return -EINVAL;
 			if ((data & PSW_MASK_ASC) == PSW_ASC_HOME)
 				 
  				return -EINVAL;
  			if ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))
 				 
  				return -EINVAL;
  		}
  		*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;
 
 	} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {
 		 
 		offset = addr - (addr_t) &dummy->regs.acrs;
 #ifdef CONFIG_64BIT
 		 
 		if (addr == (addr_t) &dummy->regs.acrs[15])
 			child->thread.acrs[15] = (unsigned int) (data >> 32);
 		else
 #endif
 		*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;
 
 	} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {
 		 
 		task_pt_regs(child)->orig_gpr2 = data;
 
 	} else if (addr < (addr_t) &dummy->regs.fp_regs) {
 		 
 		return 0;
 
 	} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {
 		 
 		if (addr == (addr_t) &dummy->regs.fp_regs.fpc)
 			if ((unsigned int) data != 0 ||
 			    test_fp_ctl(data >> (BITS_PER_LONG - 32)))
 				return -EINVAL;
 		offset = addr - (addr_t) &dummy->regs.fp_regs;
 		*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;
 
 	} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {
 		 
 		addr -= (addr_t) &dummy->regs.per_info;
 		__poke_user_per(child, addr, data);
 
 	}
 
 	return 0;
 }","[13, 14, 15, 16, 17, 20, 12]","arch/s390/kernel/ptrace.c in the Linux kernel before 3.15.8 on the s390 platform does not properly restrict address-space control operations in PTRACE_POKEUSR_AREA requests, which allows local users to obtain read and write access to kernel memory locations, and consequently gain privileges, via a crafted application that makes a ptrace system call."
202589," valid_host(cupsd_client_t *con)		 
 {
   cupsd_alias_t	*a;			 
   cupsd_netif_t	*netif;			 
   const char	*end;			 
   char		*ptr;			 
 
 
   
 
   strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),
           sizeof(con->clientname));
   if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))
   {
     *ptr++ = '\0';
     con->clientport = atoi(ptr);
   }
   else
     con->clientport = con->serverport;
 
   
 
   if (httpAddrLocalhost(httpGetAddress(con->http)))
   {
     
  
      return (!_cups_strcasecmp(con->clientname, ""localhost"") ||
  	    !_cups_strcasecmp(con->clientname, ""localhost."") ||
#ifdef __linux
	    !_cups_strcasecmp(con->clientname, ""localhost.localdomain"") ||
#endif  
              !strcmp(con->clientname, ""127.0.0.1"") ||
  	    !strcmp(con->clientname, ""[::1]""));
    }
 
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   
 
   if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&
       !end[1])
   {
     
 
     for (end --; end > con->clientname && *end != '.'; end --);
   }
 
   if (end && (!_cups_strcasecmp(end, "".local"") ||
 	      !_cups_strcasecmp(end, "".local."")))
     return (1);
 #endif  
 
   
 
   if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')
   {
     
 
     http_addrlist_t *addrlist;		 
 
 
     if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)
     {
       
 
       httpAddrFreeList(addrlist);
       return (1);
     }
   }
 
   
 
   for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);
        a;
        a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))
   {
     
 
     if (!strcmp(a->name, ""*""))
       return (1);
 
     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))
     {
       
 
       end = con->clientname + a->namelen;
 
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
 
 #if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
   for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);
        a;
        a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))
   {
     
 
     if (!strcmp(a->name, ""*""))
       return (1);
 
     if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))
     {
       
 
       end = con->clientname + a->namelen;
 
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
 #endif  
 
   
 
   for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);
        netif;
        netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))
   {
     if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))
     {
       
 
       end = con->clientname + netif->hostlen;
 
       if (!*end || (*end == '.' && !end[1]))
         return (1);
     }
   }
 
   return (0);
 }","[29, 30, 31]",A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1).
199421," doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,
     size_t size, off_t fsize, int *flags, int mach, int strtab)
 {
  	Elf32_Shdr sh32;
  	Elf64_Shdr sh64;
  	int stripped = 1;
 	size_t nbadcap = 0;
  	void *nbuf;
  	off_t noff, coff, name_off;
  	uint64_t cap_hw1 = 0;	 
 	uint64_t cap_sf1 = 0;	 
 	char name[50];
 
 	if (size != xsh_sizeof) {
 		if (file_printf(ms, "", corrupted section header size"") == -1)
 			return -1;
 		return 0;
 	}
 
 	 
 	if (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) == -1) {
 		file_badread(ms);
 		return -1;
 	}
 	name_off = xsh_offset;
 
 	for ( ; num; num--) {
 		 
 		if (pread(fd, name, sizeof(name), name_off + xsh_name) == -1) {
 			file_badread(ms);
 			return -1;
 		}
 		name[sizeof(name) - 1] = '\0';
 		if (strcmp(name, "".debug_info"") == 0)
 			stripped = 0;
 
 		if (pread(fd, xsh_addr, xsh_sizeof, off) == -1) {
 			file_badread(ms);
 			return -1;
 		}
 		off += size;
 
 		 
 		switch (xsh_type) {
 		case SHT_SYMTAB:
 #if 0
 		case SHT_DYNSYM:
 #endif
 			stripped = 0;
 			break;
 		default:
 			if (xsh_offset > fsize) {
 				 
 				continue;
 			}
 			break;
 		}
 
 		 
 		switch (xsh_type) {
 		case SHT_NOTE:
 			if ((nbuf = malloc(xsh_size)) == NULL) {
 				file_error(ms, errno, ""Cannot allocate memory""
 				    "" for note"");
 				return -1;
 			}
 			if (pread(fd, nbuf, xsh_size, xsh_offset) == -1) {
 				file_badread(ms);
 				free(nbuf);
 				return -1;
 			}
 
 			noff = 0;
 			for (;;) {
 				if (noff >= (off_t)xsh_size)
 					break;
 				noff = donote(ms, nbuf, (size_t)noff,
 				    xsh_size, clazz, swap, 4, flags);
 				if (noff == 0)
 					break;
 			}
 			free(nbuf);
 			break;
 		case SHT_SUNW_cap:
 			switch (mach) {
 			case EM_SPARC:
 			case EM_SPARCV9:
 			case EM_IA_64:
 			case EM_386:
 			case EM_AMD64:
 				break;
 			default:
  				goto skip;
  			}
  
 			if (nbadcap > 5)
 				break;
  			if (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {
  				file_badseek(ms);
  				return -1;
 			}
 			coff = 0;
 			for (;;) {
 				Elf32_Cap cap32;
 				Elf64_Cap cap64;
 				char cbuf[ 
 				    MAX(sizeof cap32, sizeof cap64)];
 				if ((coff += xcap_sizeof) > (off_t)xsh_size)
 					break;
 				if (read(fd, cbuf, (size_t)xcap_sizeof) !=
 				    (ssize_t)xcap_sizeof) {
 					file_badread(ms);
 					return -1;
 				}
 				if (cbuf[0] == 'A') {
 #ifdef notyet
 					char *p = cbuf + 1;
 					uint32_t len, tag;
 					memcpy(&len, p, sizeof(len));
 					p += 4;
 					len = getu32(swap, len);
 					if (memcmp(""gnu"", p, 3) != 0) {
 					    if (file_printf(ms,
 						"", unknown capability %.3s"", p)
 						== -1)
 						return -1;
 					    break;
 					}
 					p += strlen(p) + 1;
 					tag = *p++;
 					memcpy(&len, p, sizeof(len));
 					p += 4;
 					len = getu32(swap, len);
 					if (tag != 1) {
 					    if (file_printf(ms, "", unknown gnu""
 						"" capability tag %d"", tag)
 						== -1)
 						return -1;
 					    break;
 					}
 #endif
 					break;
 				}
 				(void)memcpy(xcap_addr, cbuf, xcap_sizeof);
 				switch (xcap_tag) {
 				case CA_SUNW_NULL:
 					break;
 				case CA_SUNW_HW_1:
 					cap_hw1 |= xcap_val;
 					break;
 				case CA_SUNW_SF_1:
 					cap_sf1 |= xcap_val;
 					break;
 				default:
 					if (file_printf(ms,
 					    "", with unknown capability ""
 					    ""0x%"" INT64_T_FORMAT ""x = 0x%""
 					    INT64_T_FORMAT ""x"",
  					    (unsigned long long)xcap_tag,
  					    (unsigned long long)xcap_val) == -1)
  						return -1;
 					if (nbadcap++ > 2)
 						coff = xsh_size;
  					break;
  				}
  			}
 			 
 		skip:
 		default:
 			break;
 		}
 	}
 
 	if (file_printf(ms, "", %sstripped"", stripped ? """" : ""not "") == -1)
 		return -1;
 	if (cap_hw1) {
 		const cap_desc_t *cdp;
 		switch (mach) {
 		case EM_SPARC:
 		case EM_SPARC32PLUS:
 		case EM_SPARCV9:
 			cdp = cap_desc_sparc;
 			break;
 		case EM_386:
 		case EM_IA_64:
 		case EM_AMD64:
 			cdp = cap_desc_386;
 			break;
 		default:
 			cdp = NULL;
 			break;
 		}
 		if (file_printf(ms, "", uses"") == -1)
 			return -1;
 		if (cdp) {
 			while (cdp->cd_name) {
 				if (cap_hw1 & cdp->cd_mask) {
 					if (file_printf(ms,
 					    "" %s"", cdp->cd_name) == -1)
 						return -1;
 					cap_hw1 &= ~cdp->cd_mask;
 				}
 				++cdp;
 			}
 			if (cap_hw1)
 				if (file_printf(ms,
 				    "" unknown hardware capability 0x%""
 				    INT64_T_FORMAT ""x"",
 				    (unsigned long long)cap_hw1) == -1)
 					return -1;
 		} else {
 			if (file_printf(ms,
 			    "" hardware capability 0x%"" INT64_T_FORMAT ""x"",
 			    (unsigned long long)cap_hw1) == -1)
 				return -1;
 		}
 	}
 	if (cap_sf1) {
 		if (cap_sf1 & SF1_SUNW_FPUSED) {
 			if (file_printf(ms,
 			    (cap_sf1 & SF1_SUNW_FPKNWN)
 			    ? "", uses frame pointer""
 			    : "", not known to use frame pointer"") == -1)
 				return -1;
 		}
 		cap_sf1 &= ~SF1_SUNW_MASK;
 		if (cap_sf1)
 			if (file_printf(ms,
 			    "", with unknown software capability 0x%""
 			    INT64_T_FORMAT ""x"",
 			    (unsigned long long)cap_sf1) == -1)
 				return -1;
 	}
 	return 0;
 }","[7, 96, 97, 162, 163]",The ELF parser (readelf.c) in file before 5.21 allows remote attackers to cause a denial of service (CPU consumption or crash) via a large number of (1) program or (2) section headers or (3) invalid capabilities.
8493,"static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)
{
u32 i, j, len, line;
GF_TextSample *samp;
Double ts_scale;
char szLine[2048], szTime[20], szText[2048];


if (!ctx->is_setup) {
ctx->is_setup = GF_TRUE;
return txtin_setup_srt(filter, ctx);
}
if (!ctx->opid) return GF_NOT_SUPPORTED;
if (!ctx->playstate) return GF_OK;
else if (ctx->playstate==2) return GF_EOS;

if (ctx->seek_state==1) {
ctx->seek_state = 2;
gf_fseek(ctx->src, 0, SEEK_SET);
}

if (ctx->fps.den && ctx->fps.num) {
ts_scale = ((Double) ctx->fps.num) / ctx->fps.den;
} else {
ts_scale = 25;
}

line = 0;

while (1) {
char *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);
if (!sOK) break;

REM_TRAIL_MARKS(szLine, ""\r\n\t "")

line++;
len = (u32) strlen(szLine);
if (!len) continue;

i=0;
if (szLine[i] != '{') {
GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[TXTIn] Bad SUB file (line %d): expecting \""{\"" got \""%c\""\n"", line, szLine[i]));
continue;
}
while (szLine[i+1] && szLine[i+1]!='}') {
szTime[i] = szLine[i+1];
i++;
}
szTime[i] = 0;
ctx->start = atoi(szTime);
if (ctx->start < ctx->end) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\n"", line, ctx->start, ctx->end));
ctx->start = ctx->end;
}
j=i+2;
i=0;
if (szLine[i+j] != '{') {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] Bad SUB file - expecting \""{\"" got \""%c\""\n"", szLine[i]));
continue;
}
while (szLine[i+1+j] && szLine[i+1+j]!='}') {
szTime[i] = szLine[i+1+j];
i++;
}
szTime[i] = 0;
ctx->end = atoi(szTime);
j+=i+2;

if (ctx->start > ctx->end) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\n"", line, ctx->end, ctx->start));
continue;
}

if (ctx->start && ctx->first_samp) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);
ctx->first_samp = GF_FALSE;
gf_isom_delete_text_sample(samp);
}

for (i=j; i<len; i++) {
if (szLine[i]=='|') {
szText[i-j] = '\n';
} else {
szText[i-j] = szLine[i];
}
}
szText[i-j] = 0;

if (ctx->prev_end) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);
gf_isom_delete_text_sample(samp);
}

samp = gf_isom_new_text_sample();
gf_isom_text_add_text(samp, szText, (u32) strlen(szText) );
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);
gf_isom_delete_text_sample(samp);

ctx->prev_end = ctx->end;

gf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );

if (gf_filter_pid_would_block(ctx->opid))
return GF_OK;
}

if (ctx->end && !ctx->noflush) {
samp = gf_isom_new_text_sample();
txtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);
gf_isom_delete_text_sample(samp);
}

gf_filter_pid_set_info_str( ctx->opid, ""ttxt:last_dur"", &PROP_UINT(0) );

return GF_EOS;
}",[49],"The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges."
200717,"  static int ext4_get_block_write(struct inode *inode, sector_t iblock,
  		   struct buffer_head *bh_result, int create)
  {
	handle_t *handle = NULL;
 	handle_t *handle = ext4_journal_current_handle();
  	int ret = 0;
  	unsigned max_blocks = bh_result->b_size >> inode->i_blkbits;
  	int dio_credits;
 	int started = 0;
  
  	ext4_debug(""ext4_get_block_write: inode %lu, create flag %d\n"",
  		   inode->i_ino, create);
 	 
  	create = EXT4_GET_BLOCKS_IO_CREATE_EXT;
  
	if (max_blocks > DIO_MAX_BLOCKS)
		max_blocks = DIO_MAX_BLOCKS;
	dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);
	handle = ext4_journal_start(inode, dio_credits);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		goto out;
 	if (!handle) {
 		if (max_blocks > DIO_MAX_BLOCKS)
 			max_blocks = DIO_MAX_BLOCKS;
 		dio_credits = ext4_chunk_trans_blocks(inode, max_blocks);
 		handle = ext4_journal_start(inode, dio_credits);
 		if (IS_ERR(handle)) {
 			ret = PTR_ERR(handle);
 			goto out;
 		}
 		started = 1;
  	}
 
  	ret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,
  			      create);
  	if (ret > 0) {
  		bh_result->b_size = (ret << inode->i_blkbits);
  		ret = 0;
  	}
	ext4_journal_stop(handle);
 	if (started)
 		ext4_journal_stop(handle);
  out:
  	return ret;
  }","[5, 9, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 34, 42, 43, 4, 16, 17, 18, 19, 20, 21, 22, 41]","The ext4 implementation in the Linux kernel before 2.6.34 does not properly track the initialization of certain data structures, which allows physically proximate attackers to cause a denial of service (NULL pointer dereference and panic) via a crafted USB device, related to the ext4_fill_super function."
201056,"  beep_print(netdissect_options *ndo, const u_char *bp, u_int length)
  {
  
	if (l_strnstart(""MSG"", 4, (const char *)bp, length))  
 	if (l_strnstart(ndo, ""MSG"", 4, (const char *)bp, length))  
  		ND_PRINT((ndo, "" BEEP MSG""));
	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP RPY""));
	else if (l_strnstart(""ERR "", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP ERR""));
	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP ANS""));
	else if (l_strnstart(""NUL "", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""NUL "", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP NUL""));
	else if (l_strnstart(""SEQ "", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP SEQ""));
	else if (l_strnstart(""END"", 4, (const char *)bp, length))
 	else if (l_strnstart(ndo, ""END"", 4, (const char *)bp, length))
  		ND_PRINT((ndo, "" BEEP END""));
  	else
  		ND_PRINT((ndo, "" BEEP (payload or undecoded)""));
 }","[5, 8, 11, 14, 17, 20, 23, 4, 7, 10, 13, 16, 19, 22]",The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().
6253,"Perl_re_op_compile(pTHX_ SV ** const patternp, int pat_count,
OP *expr, const regexp_engine* eng, REGEXP *old_re,
bool *is_bare_re, const U32 orig_rx_flags, const U32 pm_flags)
{
dVAR;
REGEXP *Rx;
STRLEN plen;
char *exp;
regnode *scan;
I32 flags;
SSize_t minlen = 0;
U32 rx_flags;
SV *pat;
SV** new_patternp = patternp;



I32 sawlookahead = 0;
I32 sawplus = 0;
I32 sawopen = 0;
I32 sawminmod = 0;

regex_charset initial_charset = get_regex_charset(orig_rx_flags);
bool recompile = 0;
bool runtime_code = 0;
scan_data_t data;
RExC_state_t RExC_state;
RExC_state_t * const pRExC_state = &RExC_state;
#ifdef TRIE_STUDY_OPT
int restudied = 0;
RExC_state_t copyRExC_state;
#endif
GET_RE_DEBUG_FLAGS_DECL;

PERL_ARGS_ASSERT_RE_OP_COMPILE;

DEBUG_r(if (!PL_colorset) reginitcolors());



if (! PL_InBitmap) {
#ifdef DEBUGGING
char * dump_len_string;
#endif




PL_InBitmap = _new_invlist(2);
PL_InBitmap = _add_range_to_invlist(PL_InBitmap, 0,
NUM_ANYOF_CODE_POINTS - 1);
#ifdef DEBUGGING
dump_len_string = PerlEnv_getenv(""PERL_DUMP_RE_MAX_LEN"");
if (   ! dump_len_string
|| ! grok_atoUV(dump_len_string, (UV *)&PL_dump_re_max_len, NULL))
{
PL_dump_re_max_len = 60;
}
#endif
}

pRExC_state->warn_text = NULL;
pRExC_state->unlexed_names = NULL;
pRExC_state->code_blocks = NULL;

if (is_bare_re)
*is_bare_re = FALSE;

if (expr && (expr->op_type == OP_LIST ||
(expr->op_type == OP_NULL && expr->op_targ == OP_LIST))) {

OP *o;
int ncode = 0;

for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o))
if (o->op_type == OP_NULL && (o->op_flags & OPf_SPECIAL))
ncode++;

if (ncode)
pRExC_state->code_blocks = S_alloc_code_blocks(aTHX_ ncode);
}

if (!pat_count) {


int n;
OP *o;


assert(expr);
n = 0;
if (expr->op_type == OP_CONST)
n = 1;
else
for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
if (o->op_type == OP_CONST)
n++;
}



assert(!new_patternp);
Newx(new_patternp, n, SV*);
SAVEFREEPV(new_patternp);
pat_count = n;

n = 0;
if (expr->op_type == OP_CONST)
new_patternp[n] = cSVOPx_sv(expr);
else
for (o = cLISTOPx(expr)->op_first; o; o = OpSIBLING(o)) {
if (o->op_type == OP_CONST)
new_patternp[n++] = cSVOPo_sv;
}

}

DEBUG_PARSE_r(Perl_re_printf( aTHX_
""Assembling pattern from %d elements%s\n"", pat_count,
orig_rx_flags & RXf_SPLIT ? "" for split"" : """"));



if (pRExC_state->code_blocks && pRExC_state->code_blocks->count
&& expr->op_type != OP_CONST)
{
expr = cLISTOPx(expr)->op_first;
assert(   expr->op_type == OP_PUSHMARK
|| (expr->op_type == OP_NULL && expr->op_targ == OP_PUSHMARK)
|| expr->op_type == OP_PADRANGE);
expr = OpSIBLING(expr);
}

pat = S_concat_pat(aTHX_ pRExC_state, NULL, new_patternp, pat_count,
expr, &recompile, NULL);


{
SV *re = pat;
if (SvROK(re))
re = SvRV(re);
if (SvTYPE(re) == SVt_REGEXP) {
if (is_bare_re)
*is_bare_re = TRUE;
SvREFCNT_inc(re);
DEBUG_PARSE_r(Perl_re_printf( aTHX_
""Precompiled pattern%s\n"",
orig_rx_flags & RXf_SPLIT ? "" for split"" : """"));

return (REGEXP*)re;
}
}

exp = SvPV_nomg(pat, plen);

if (!eng->op_comp) {
if ((SvUTF8(pat) && IN_BYTES)
|| SvGMAGICAL(pat) || SvAMAGIC(pat))
{


pat = newSVpvn_flags(exp, plen, SVs_TEMP |
(IN_BYTES ? 0 : SvUTF8(pat)));
}
return CALLREGCOMP_ENG(eng, pat, orig_rx_flags);
}


RExC_utf8 = RExC_orig_utf8 = (plen == 0 || IN_BYTES) ? 0 : SvUTF8(pat);
RExC_uni_semantics = 0;
RExC_contains_locale = 0;
RExC_strict = cBOOL(pm_flags & RXf_PMf_STRICT);
RExC_in_script_run = 0;
RExC_study_started = 0;
pRExC_state->runtime_code_qr = NULL;
RExC_frame_head= NULL;
RExC_frame_last= NULL;
RExC_frame_count= 0;
RExC_latest_warn_offset = 0;
RExC_use_BRANCHJ = 0;
RExC_total_parens = 0;
RExC_open_parens = NULL;
RExC_close_parens = NULL;
RExC_paren_names = NULL;
RExC_size = 0;
RExC_seen_d_op = FALSE;
#ifdef DEBUGGING
RExC_paren_name_list = NULL;
#endif

DEBUG_r({
RExC_mysv1= sv_newmortal();
RExC_mysv2= sv_newmortal();
});

DEBUG_COMPILE_r({
SV *dsv= sv_newmortal();
RE_PV_QUOTED_DECL(s, RExC_utf8, dsv, exp, plen, PL_dump_re_max_len);
Perl_re_printf( aTHX_  ""%sCompiling REx%s %s\n"",
PL_colors[4], PL_colors[5], s);
});




if ((pm_flags & PMf_USE_RE_EVAL)


|| (IN_PERL_COMPILETIME && (PL_hints & HINT_RE_EVAL))
)
runtime_code = S_has_runtime_code(aTHX_ pRExC_state, exp, plen);

redo_parse:







if (   old_re
&& !recompile
&& !!RX_UTF8(old_re) == !!RExC_utf8
&& ( RX_COMPFLAGS(old_re) == ( orig_rx_flags & RXf_PMf_FLAGCOPYMASK ) )
&& RX_PRECOMP(old_re)
&& RX_PRELEN(old_re) == plen
&& memEQ(RX_PRECOMP(old_re), exp, plen)
&& !runtime_code                                           )
{
return old_re;
}


RExC_rx_sv = Rx = (REGEXP*) newSV_type(SVt_REGEXP);
RExC_rx = ReANY(Rx);
if ( RExC_rx == NULL )
FAIL(""Regexp out of space"");

rx_flags = orig_rx_flags;

if (   (UTF || RExC_uni_semantics)
&& initial_charset == REGEX_DEPENDS_CHARSET)
{



set_regex_charset(&rx_flags, REGEX_UNICODE_CHARSET);
RExC_uni_semantics = 1;
}

RExC_pm_flags = pm_flags;

if (runtime_code) {
assert(TAINTING_get || !TAINT_get);
if (TAINT_get)
Perl_croak(aTHX_ ""Eval-group in insecure regular expression"");

if (!S_compile_runtime_code(aTHX_ pRExC_state, exp, plen)) {


S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);
goto redo_parse;
}
}
assert(!pRExC_state->runtime_code_qr);

RExC_sawback = 0;

RExC_seen = 0;
RExC_maxlen = 0;
RExC_in_lookbehind = 0;
RExC_seen_zerolen = *exp == '^' ? -1 : 0;
#ifdef EBCDIC
RExC_recode_x_to_native = 0;
#endif
RExC_in_multi_char_class = 0;

RExC_start = RExC_copy_start_in_constructed = RExC_copy_start_in_input = RExC_precomp = exp;
RExC_precomp_end = RExC_end = exp + plen;
RExC_nestroot = 0;
RExC_whilem_seen = 0;
RExC_end_op = NULL;
RExC_recurse = NULL;
RExC_study_chunk_recursed = NULL;
RExC_study_chunk_recursed_bytes= 0;
RExC_recurse_count = 0;
pRExC_state->code_index = 0;



set_regex_pv(pRExC_state, Rx);

DEBUG_PARSE_r({
Perl_re_printf( aTHX_
""Starting parse and generation\n"");
RExC_lastnum=0;
RExC_lastparse=NULL;
});




if (!  RExC_size) {














RExC_size = STR_SZ(RExC_end - RExC_start);
}

Newxc(RExC_rxi, sizeof(regexp_internal) + RExC_size, char, regexp_internal);
if ( RExC_rxi == NULL )
FAIL(""Regexp out of space"");

Zero(RExC_rxi, sizeof(regexp_internal) + RExC_size, char);
RXi_SET( RExC_rx, RExC_rxi );




RExC_size = 0;


RExC_rx->engine= eng;
RExC_rx->extflags = rx_flags;
RXp_COMPFLAGS(RExC_rx) = orig_rx_flags & RXf_PMf_FLAGCOPYMASK;

if (pm_flags & PMf_IS_QR) {
RExC_rxi->code_blocks = pRExC_state->code_blocks;
if (RExC_rxi->code_blocks) {
RExC_rxi->code_blocks->refcnt++;
}
}

RExC_rx->intflags = 0;

RExC_flags = rx_flags;
RExC_parse = exp;








assert(*RExC_end == '\0');

RExC_naughty = 0;
RExC_npar = 1;
RExC_parens_buf_size = 0;
RExC_emit_start = RExC_rxi->program;
pRExC_state->code_index = 0;

*((char*) RExC_emit_start) = (char) REG_MAGIC;
RExC_emit = 1;


if (reg(pRExC_state, 0, &flags, 1)) {



if (IN_PARENS_PASS) {
flags |= RESTART_PARSE;
}


RExC_total_parens = RExC_npar;
}
else if (! MUST_RESTART(flags)) {
ReREFCNT_dec(Rx);
Perl_croak(aTHX_ ""panic: reg returned failure to re_op_compile, flags=%#"" UVxf, (UV) flags);
}


if (MUST_RESTART(flags)) {









if (flags & NEED_UTF8) {





if (UNLIKELY(RExC_latest_warn_offset > 0)) {
RExC_latest_warn_offset +=
variant_under_utf8_count((U8 *) exp, (U8 *) exp
+ RExC_latest_warn_offset);
}
S_pat_upgrade_to_utf8(aTHX_ pRExC_state, &exp, &plen,
pRExC_state->code_blocks ? pRExC_state->code_blocks->count : 0);
DEBUG_PARSE_r(Perl_re_printf( aTHX_ ""Need to redo parse after upgrade\n""));
}
else {
DEBUG_PARSE_r(Perl_re_printf( aTHX_ ""Need to redo parse\n""));
}

if (ALL_PARENS_COUNTED) {

Renew(RExC_open_parens, RExC_total_parens, regnode_offset);
Zero(RExC_open_parens, RExC_total_parens, regnode_offset);
RExC_open_parens[0] = 1;

Renew(RExC_close_parens, RExC_total_parens, regnode_offset);
Zero(RExC_close_parens, RExC_total_parens, regnode_offset);
}
else {

RExC_total_parens = 0;
if (RExC_open_parens) {
Safefree(RExC_open_parens);
RExC_open_parens = NULL;
}
if (RExC_close_parens) {
Safefree(RExC_close_parens);
RExC_close_parens = NULL;
}
}


SvREFCNT_dec_NN(RExC_rx_sv);

goto redo_parse;
}






set_regex_pv(pRExC_state, Rx);

RExC_rx->nparens = RExC_total_parens - 1;


if (RExC_whilem_seen > 15)
RExC_whilem_seen = 15;

DEBUG_PARSE_r({
Perl_re_printf( aTHX_
""Required size %"" IVdf "" nodes\n"", (IV)RExC_size);
RExC_lastnum=0;
RExC_lastparse=NULL;
});

#ifdef RE_TRACK_PATTERN_OFFSETS
DEBUG_OFFSETS_r(Perl_re_printf( aTHX_
""%s %"" UVuf "" bytes for offset annotations.\n"",
RExC_offsets ? ""Got"" : ""Couldn't get"",
(UV)((RExC_offsets[0] * 2 + 1))));
DEBUG_OFFSETS_r(if (RExC_offsets) {
const STRLEN len = RExC_offsets[0];
STRLEN i;
GET_RE_DEBUG_FLAGS_DECL;
Perl_re_printf( aTHX_
""Offsets: [%"" UVuf ""]\n\t"", (UV)RExC_offsets[0]);
for (i = 1; i <= len; i++) {
if (RExC_offsets[i*2-1] || RExC_offsets[i*2])
Perl_re_printf( aTHX_  ""%"" UVuf "":%"" UVuf ""[%"" UVuf ""] "",
(UV)i, (UV)RExC_offsets[i*2-1], (UV)RExC_offsets[i*2]);
}
Perl_re_printf( aTHX_  ""\n"");
});

#else
SetProgLen(RExC_rxi,RExC_size);
#endif

DEBUG_OPTIMISE_r(
Perl_re_printf( aTHX_  ""Starting post parse optimization\n"");
);



Newx(RExC_rx->substrs, 1, struct reg_substr_data);
if (RExC_recurse_count) {
Newx(RExC_recurse, RExC_recurse_count, regnode *);
SAVEFREEPV(RExC_recurse);
}

if (RExC_seen & REG_RECURSE_SEEN) {


RExC_study_chunk_recursed_bytes= (RExC_total_parens >> 3) +
((RExC_total_parens & 0x07) != 0);
Newx(RExC_study_chunk_recursed,
RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);
SAVEFREEPV(RExC_study_chunk_recursed);
}

reStudy:
RExC_rx->minlen = minlen = sawlookahead = sawplus = sawopen = sawminmod = 0;
DEBUG_r(
RExC_study_chunk_recursed_count= 0;
);
Zero(RExC_rx->substrs, 1, struct reg_substr_data);
if (RExC_study_chunk_recursed) {
Zero(RExC_study_chunk_recursed,
RExC_study_chunk_recursed_bytes * RExC_total_parens, U8);
}


#ifdef TRIE_STUDY_OPT
if (!restudied) {
StructCopy(&zero_scan_data, &data, scan_data_t);
copyRExC_state = RExC_state;
} else {
U32 seen=RExC_seen;
DEBUG_OPTIMISE_r(Perl_re_printf( aTHX_ ""Restudying\n""));

RExC_state = copyRExC_state;
if (seen & REG_TOP_LEVEL_BRANCHES_SEEN)
RExC_seen |= REG_TOP_LEVEL_BRANCHES_SEEN;
else
RExC_seen &= ~REG_TOP_LEVEL_BRANCHES_SEEN;
StructCopy(&zero_scan_data, &data, scan_data_t);
}
#else
StructCopy(&zero_scan_data, &data, scan_data_t);
#endif


RExC_rx->extflags = RExC_flags;


if (UTF)
SvUTF8_on(Rx);
RExC_rxi->regstclass = NULL;
if (RExC_naughty >= TOO_NAUGHTY)
RExC_rx->intflags |= PREGf_NAUGHTY;
scan = RExC_rxi->program + 1;



if (!(RExC_seen & REG_TOP_LEVEL_BRANCHES_SEEN)) {

SSize_t fake;
STRLEN longest_length[2];
regnode_ssc ch_class;
int stclass_flag;
SSize_t last_close = 0;
regnode *first= scan;
regnode *first_next= regnext(first);
int i;












while ((OP(first) == OPEN && (sawopen = 1)) ||

(OP(first) == BRANCH && OP(first_next) != BRANCH) ||

(OP(first) == IFMATCH && !first->flags && (sawlookahead = 1)) ||
(OP(first) == PLUS) ||
(OP(first) == MINMOD) ||

(PL_regkind[OP(first)] == CURLY && ARG1(first) > 0) ||
(OP(first) == NOTHING && PL_regkind[OP(first_next)] != END ))
{






if (OP(first) == PLUS)
sawplus = 1;
else {
if (OP(first) == MINMOD)
sawminmod = 1;
first += regarglen[OP(first)];
}
first = NEXTOPER(first);
first_next= regnext(first);
}


again:
DEBUG_PEEP(""first:"", first, 0, 0);

if (PL_regkind[OP(first)] == EXACT) {
if (   OP(first) == EXACT
|| OP(first) == EXACT_ONLY8
|| OP(first) == EXACTL)
{
NOOP;
}
else
RExC_rxi->regstclass = first;
}
#ifdef TRIE_STCLASS
else if (PL_regkind[OP(first)] == TRIE &&
((reg_trie_data *)RExC_rxi->data->data[ ARG(first) ])->minlen>0)
{

RExC_rxi->regstclass = construct_ahocorasick_from_trie(pRExC_state, (regnode *)first, 0);
}
#endif
else if (REGNODE_SIMPLE(OP(first)))
RExC_rxi->regstclass = first;
else if (PL_regkind[OP(first)] == BOUND ||
PL_regkind[OP(first)] == NBOUND)
RExC_rxi->regstclass = first;
else if (PL_regkind[OP(first)] == BOL) {
RExC_rx->intflags |= (OP(first) == MBOL
? PREGf_ANCH_MBOL
: PREGf_ANCH_SBOL);
first = NEXTOPER(first);
goto again;
}
else if (OP(first) == GPOS) {
RExC_rx->intflags |= PREGf_ANCH_GPOS;
first = NEXTOPER(first);
goto again;
}
else if ((!sawopen || !RExC_sawback) &&
!sawlookahead &&
(OP(first) == STAR &&
PL_regkind[OP(NEXTOPER(first))] == REG_ANY) &&
!(RExC_rx->intflags & PREGf_ANCH) && !pRExC_state->code_blocks)
{

const int type =
(OP(NEXTOPER(first)) == REG_ANY)
? PREGf_ANCH_MBOL
: PREGf_ANCH_SBOL;
RExC_rx->intflags |= (type | PREGf_IMPLICIT);
first = NEXTOPER(first);
goto again;
}
if (sawplus && !sawminmod && !sawlookahead
&& (!sawopen || !RExC_sawback)
&& !pRExC_state->code_blocks)

RExC_rx->intflags |= PREGf_SKIP;


#ifdef TRIE_STUDY_OPT
DEBUG_PARSE_r(
if (!restudied)
Perl_re_printf( aTHX_  ""first at %"" IVdf ""\n"",
(IV)(first - scan + 1))
);
#else
DEBUG_PARSE_r(
Perl_re_printf( aTHX_  ""first at %"" IVdf ""\n"",
(IV)(first - scan + 1))
);
#endif














data.substrs[0].str = newSVpvs("""");
data.substrs[1].str = newSVpvs("""");
data.last_found = newSVpvs("""");
data.cur_is_floating = 0;
ENTER_with_name(""study_chunk"");
SAVEFREESV(data.substrs[0].str);
SAVEFREESV(data.substrs[1].str);
SAVEFREESV(data.last_found);
first = scan;
if (!RExC_rxi->regstclass) {
ssc_init(pRExC_state, &ch_class);
data.start_class = &ch_class;
stclass_flag = SCF_DO_STCLASS_AND;
} else
stclass_flag = 0;
data.last_closep = &last_close;

DEBUG_RExC_seen();




minlen = study_chunk(pRExC_state, &first, &minlen, &fake,
scan + RExC_size,
&data, -1, 0, NULL,
SCF_DO_SUBSTR | SCF_WHILEM_VISITED_POS | stclass_flag
| (restudied ? SCF_TRIE_DOING_RESTUDY : 0),
0);


CHECK_RESTUDY_GOTO_butfirst(LEAVE_with_name(""study_chunk""));


if ( RExC_total_parens == 1 && !data.cur_is_floating
&& data.last_start_min == 0 && data.last_end > 0
&& !RExC_seen_zerolen
&& !(RExC_seen & REG_VERBARG_SEEN)
&& !(RExC_seen & REG_GPOS_SEEN)
){
RExC_rx->extflags |= RXf_CHECK_ALL;
}
scan_commit(pRExC_state, &data,&minlen, 0);





for (i = 1; i >= 0; i--) {
longest_length[i] = CHR_SVLEN(data.substrs[i].str);

if (   !(   i
&& SvCUR(data.substrs[0].str)
&&    data.substrs[0].min_offset
== data.substrs[1].min_offset
&&    SvCUR(data.substrs[0].str)
== SvCUR(data.substrs[1].str)
)
&& S_setup_longest (aTHX_ pRExC_state,
&(RExC_rx->substrs->data[i]),
&(data.substrs[i]),
longest_length[i]))
{
RExC_rx->substrs->data[i].min_offset =
data.substrs[i].min_offset - data.substrs[i].lookbehind;

RExC_rx->substrs->data[i].max_offset = data.substrs[i].max_offset;

if (data.substrs[i].max_offset < SSize_t_MAX)
RExC_rx->substrs->data[i].max_offset -= data.substrs[i].lookbehind;
SvREFCNT_inc_simple_void_NN(data.substrs[i].str);
}
else {
RExC_rx->substrs->data[i].substr      = NULL;
RExC_rx->substrs->data[i].utf8_substr = NULL;
longest_length[i] = 0;
}
}

LEAVE_with_name(""study_chunk"");

if (RExC_rxi->regstclass
&& (OP(RExC_rxi->regstclass) == REG_ANY || OP(RExC_rxi->regstclass) == SANY))
RExC_rxi->regstclass = NULL;

if ((!(RExC_rx->substrs->data[0].substr || RExC_rx->substrs->data[0].utf8_substr)
|| RExC_rx->substrs->data[0].min_offset)
&& stclass_flag
&& ! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
&& is_ssc_worth_it(pRExC_state, data.start_class))
{
const U32 n = add_data(pRExC_state, STR_WITH_LEN(""f""));

ssc_finalize(pRExC_state, data.start_class);

Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
StructCopy(data.start_class,
(regnode_ssc*)RExC_rxi->data->data[n],
regnode_ssc);
RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];
RExC_rx->intflags &= ~PREGf_SKIP;
DEBUG_COMPILE_r({ SV *sv = sv_newmortal();
regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);
Perl_re_printf( aTHX_
""synthetic stclass \""%s\"".\n"",
SvPVX_const(sv));});
data.start_class = NULL;
}



i = (longest_length[0] <= longest_length[1]);
RExC_rx->substrs->check_ix = i;
RExC_rx->check_end_shift  = RExC_rx->substrs->data[i].end_shift;
RExC_rx->check_substr     = RExC_rx->substrs->data[i].substr;
RExC_rx->check_utf8       = RExC_rx->substrs->data[i].utf8_substr;
RExC_rx->check_offset_min = RExC_rx->substrs->data[i].min_offset;
RExC_rx->check_offset_max = RExC_rx->substrs->data[i].max_offset;
if (!i && (RExC_rx->intflags & (PREGf_ANCH_SBOL|PREGf_ANCH_GPOS)))
RExC_rx->intflags |= PREGf_NOSCAN;

if ((RExC_rx->check_substr || RExC_rx->check_utf8) ) {
RExC_rx->extflags |= RXf_USE_INTUIT;
if (SvTAIL(RExC_rx->check_substr ? RExC_rx->check_substr : RExC_rx->check_utf8))
RExC_rx->extflags |= RXf_INTUIT_TAIL;
}







}
else {

SSize_t fake;
regnode_ssc ch_class;
SSize_t last_close = 0;

DEBUG_PARSE_r(Perl_re_printf( aTHX_  ""\nMulti Top Level\n""));

scan = RExC_rxi->program + 1;
ssc_init(pRExC_state, &ch_class);
data.start_class = &ch_class;
data.last_closep = &last_close;

DEBUG_RExC_seen();




minlen = study_chunk(pRExC_state,
&scan, &minlen, &fake, scan + RExC_size, &data, -1, 0, NULL,
SCF_DO_STCLASS_AND|SCF_WHILEM_VISITED_POS|(restudied
? SCF_TRIE_DOING_RESTUDY
: 0),
0);

CHECK_RESTUDY_GOTO_butfirst(NOOP);

RExC_rx->check_substr = NULL;
RExC_rx->check_utf8 = NULL;
RExC_rx->substrs->data[0].substr      = NULL;
RExC_rx->substrs->data[0].utf8_substr = NULL;
RExC_rx->substrs->data[1].substr      = NULL;
RExC_rx->substrs->data[1].utf8_substr = NULL;

if (! (ANYOF_FLAGS(data.start_class) & SSC_MATCHES_EMPTY_STRING)
&& is_ssc_worth_it(pRExC_state, data.start_class))
{
const U32 n = add_data(pRExC_state, STR_WITH_LEN(""f""));

ssc_finalize(pRExC_state, data.start_class);

Newx(RExC_rxi->data->data[n], 1, regnode_ssc);
StructCopy(data.start_class,
(regnode_ssc*)RExC_rxi->data->data[n],
regnode_ssc);
RExC_rxi->regstclass = (regnode*)RExC_rxi->data->data[n];
RExC_rx->intflags &= ~PREGf_SKIP;
DEBUG_COMPILE_r({ SV* sv = sv_newmortal();
regprop(RExC_rx, sv, (regnode*)data.start_class, NULL, pRExC_state);
Perl_re_printf( aTHX_
""synthetic stclass \""%s\"".\n"",
SvPVX_const(sv));});
data.start_class = NULL;
}
}

if (RExC_seen & REG_UNBOUNDED_QUANTIFIER_SEEN) {
RExC_rx->extflags |= RXf_UNBOUNDED_QUANTIFIER_SEEN;
RExC_rx->maxlen = REG_INFTY;
}
else {
RExC_rx->maxlen = RExC_maxlen;
}



DEBUG_OPTIMISE_r({
Perl_re_printf( aTHX_ ""minlen: %"" IVdf "" RExC_rx->minlen:%"" IVdf "" maxlen:%"" IVdf ""\n"",
(IV)minlen, (IV)RExC_rx->minlen, (IV)RExC_maxlen);
});
RExC_rx->minlenret = minlen;
if (RExC_rx->minlen < minlen)
RExC_rx->minlen = minlen;

if (RExC_seen & REG_RECURSE_SEEN ) {
RExC_rx->intflags |= PREGf_RECURSE_SEEN;
Newx(RExC_rx->recurse_locinput, RExC_rx->nparens + 1, char *);
}
if (RExC_seen & REG_GPOS_SEEN)
RExC_rx->intflags |= PREGf_GPOS_SEEN;
if (RExC_seen & REG_LOOKBEHIND_SEEN)
RExC_rx->extflags |= RXf_NO_INPLACE_SUBST;

if (pRExC_state->code_blocks)
RExC_rx->extflags |= RXf_EVAL_SEEN;
if (RExC_seen & REG_VERBARG_SEEN)
{
RExC_rx->intflags |= PREGf_VERBARG_SEEN;
RExC_rx->extflags |= RXf_NO_INPLACE_SUBST;
}
if (RExC_seen & REG_CUTGROUP_SEEN)
RExC_rx->intflags |= PREGf_CUTGROUP_SEEN;
if (pm_flags & PMf_USE_RE_EVAL)
RExC_rx->intflags |= PREGf_USE_RE_EVAL;
if (RExC_paren_names)
RXp_PAREN_NAMES(RExC_rx) = MUTABLE_HV(SvREFCNT_inc(RExC_paren_names));
else
RXp_PAREN_NAMES(RExC_rx) = NULL;



if (RExC_rx->intflags & PREGf_ANCH)
RExC_rx->extflags |= RXf_IS_ANCHORED;


{







regnode *first = RExC_rxi->program + 1;
U8 fop = OP(first);
regnode *next = regnext(first);
U8 nop = OP(next);

if (PL_regkind[fop] == NOTHING && nop == END)
RExC_rx->extflags |= RXf_NULL;
else if ((fop == MBOL || (fop == SBOL && !first->flags)) && nop == END)





RExC_rx->extflags |= RXf_START_ONLY;
else if (fop == PLUS
&& PL_regkind[nop] == POSIXD && FLAGS(next) == _CC_SPACE
&& nop == END)
RExC_rx->extflags |= RXf_WHITE;
else if ( RExC_rx->extflags & RXf_SPLIT
&& (fop == EXACT || fop == EXACT_ONLY8 || fop == EXACTL)
&& STR_LEN(first) == 1
&& *(STRING(first)) == ' '
&& nop == END )
RExC_rx->extflags |= (RXf_SKIPWHITE|RXf_WHITE);

}

if (RExC_contains_locale) {
RXp_EXTFLAGS(RExC_rx) |= RXf_TAINTED;
}

#ifdef DEBUGGING
if (RExC_paren_names) {
RExC_rxi->name_list_idx = add_data( pRExC_state, STR_WITH_LEN(""a""));
RExC_rxi->data->data[RExC_rxi->name_list_idx]
= (void*)SvREFCNT_inc(RExC_paren_name_list);
} else
#endif
RExC_rxi->name_list_idx = 0;

while ( RExC_recurse_count > 0 ) {
const regnode *scan = RExC_recurse[ --RExC_recurse_count ];











assert(scan && OP(scan) == GOSUB);
ARG2L_SET( scan, RExC_open_parens[ARG(scan)] - REGNODE_OFFSET(scan));
}

Newxz(RExC_rx->offs, RExC_total_parens, regexp_paren_pair);

DEBUG_TEST_r({
Perl_re_printf( aTHX_ ""study_chunk_recursed_count: %lu\n"",
(unsigned long)RExC_study_chunk_recursed_count);
});
DEBUG_DUMP_r({
DEBUG_RExC_seen();
Perl_re_printf( aTHX_ ""Final program:\n"");
regdump(RExC_rx);
});

if (RExC_open_parens) {
Safefree(RExC_open_parens);
RExC_open_parens = NULL;
}
if (RExC_close_parens) {
Safefree(RExC_close_parens);
RExC_close_parens = NULL;
}

#ifdef USE_ITHREADS



if (old_re && SvREADONLY(old_re))
SvREADONLY_on(Rx);
#endif
return Rx;
}",[381],"Perl before 5.30.3 has an integer overflow related to mishandling of a ""PL_regkind[OP(n)] == NOTHING"" situation. A crafted regular expression could lead to malformed bytecode with a possibility of instruction injection."
201734," static Image *ReadEMFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   BITMAPINFO
     DIBinfo;
 
   HBITMAP
     hBitmap,
     hOldBitmap;
 
   HDC
     hDC;
 
   HENHMETAFILE
     hemf;
 
   Image
     *image;
 
   RECT
     rect;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   RGBQUAD
     *pBits,
     *ppBits;
 
   ssize_t
     height,
     width,
     y;
 
   image=AcquireImage(image_info);
   hemf=ReadEnhMetaFile(image_info->filename,&width,&height);
   if (hemf == (HENHMETAFILE) NULL)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if ((image->columns == 0) || (image->rows == 0))
     {
       double
         y_resolution,
         x_resolution;
 
       y_resolution=DefaultResolution;
       x_resolution=DefaultResolution;
       if (image->y_resolution > 0)
         {
           y_resolution=image->y_resolution;
           if (image->units == PixelsPerCentimeterResolution)
             y_resolution*=CENTIMETERS_INCH;
         }
       if (image->x_resolution > 0)
         {
           x_resolution=image->x_resolution;
           if (image->units == PixelsPerCentimeterResolution)
             x_resolution*=CENTIMETERS_INCH;
         }
       image->rows=(size_t) ((height/1000.0/CENTIMETERS_INCH)*y_resolution+0.5);
       image->columns=(size_t) ((width/1000.0/CENTIMETERS_INCH)*
         x_resolution+0.5);
     }
   if (image_info->size != (char *) NULL)
     {
       ssize_t
         x;
 
       image->columns=width;
       image->rows=height;
       x=0;
        y=0;
        (void) GetGeometry(image_info->size,&x,&y,&image->columns,&image->rows);
      }
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
    if (image_info->page != (char *) NULL)
      {
        char
         *geometry;
 
       register char
         *p;
 
       MagickStatusType
         flags;
 
       ssize_t
         sans;
 
       geometry=GetPageGeometry(image_info->page);
       p=strchr(geometry,'>');
       if (p == (char *) NULL)
         {
           flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,
             &image->rows);
           if (image->x_resolution != 0.0)
             image->columns=(size_t) floor((image->columns*image->x_resolution)+
               0.5);
           if (image->y_resolution != 0.0)
             image->rows=(size_t) floor((image->rows*image->y_resolution)+0.5);
         }
       else
         {
           *p='\0';
           flags=ParseMetaGeometry(geometry,&sans,&sans,&image->columns,
             &image->rows);
           if (image->x_resolution != 0.0)
             image->columns=(size_t) floor(((image->columns*image->x_resolution)/
               DefaultResolution)+0.5);
           if (image->y_resolution != 0.0)
             image->rows=(size_t) floor(((image->rows*image->y_resolution)/
               DefaultResolution)+0.5);
         }
       (void) flags;
       geometry=DestroyString(geometry);
     }
   hDC=GetDC(NULL);
   if (hDC == (HDC) NULL)
     {
       DeleteEnhMetaFile(hemf);
       ThrowReaderException(ResourceLimitError,""UnableToCreateADC"");
     }
    
   (void) ResetMagickMemory(&DIBinfo,0,sizeof(BITMAPINFO));
   DIBinfo.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
   DIBinfo.bmiHeader.biWidth=(LONG) image->columns;
   DIBinfo.bmiHeader.biHeight=(-1)*(LONG) image->rows;
   DIBinfo.bmiHeader.biPlanes=1;
   DIBinfo.bmiHeader.biBitCount=32;
   DIBinfo.bmiHeader.biCompression=BI_RGB;
   hBitmap=CreateDIBSection(hDC,&DIBinfo,DIB_RGB_COLORS,(void **) &ppBits,NULL,
     0);
   ReleaseDC(NULL,hDC);
   if (hBitmap == (HBITMAP) NULL)
     {
       DeleteEnhMetaFile(hemf);
       ThrowReaderException(ResourceLimitError,""UnableToCreateBitmap"");
     }
   hDC=CreateCompatibleDC(NULL);
   if (hDC == (HDC) NULL)
     {
       DeleteEnhMetaFile(hemf);
       DeleteObject(hBitmap);
       ThrowReaderException(ResourceLimitError,""UnableToCreateADC"");
     }
   hOldBitmap=(HBITMAP) SelectObject(hDC,hBitmap);
   if (hOldBitmap == (HBITMAP) NULL)
     {
       DeleteEnhMetaFile(hemf);
       DeleteDC(hDC);
       DeleteObject(hBitmap);
       ThrowReaderException(ResourceLimitError,""UnableToCreateBitmap"");
     }
    
   pBits=ppBits;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       pBits->rgbRed=ScaleQuantumToChar(image->background_color.red);
       pBits->rgbGreen=ScaleQuantumToChar(image->background_color.green);
       pBits->rgbBlue=ScaleQuantumToChar(image->background_color.blue);
       pBits++;
     }
   }
   rect.top=0;
   rect.left=0;
   rect.right=(LONG) image->columns;
   rect.bottom=(LONG) image->rows;
    
   PlayEnhMetaFile(hDC,hemf,&rect);
   pBits=ppBits;
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       SetPixelRed(q,ScaleCharToQuantum(pBits->rgbRed));
       SetPixelGreen(q,ScaleCharToQuantum(pBits->rgbGreen));
       SetPixelBlue(q,ScaleCharToQuantum(pBits->rgbBlue));
       SetPixelOpacity(q,OpaqueOpacity);
       pBits++;
       q++;
     }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
   }
   DeleteEnhMetaFile(hemf);
   SelectObject(hDC,hOldBitmap);
   DeleteDC(hDC);
   DeleteObject(hBitmap);
   return(GetFirstImageInList(image));
 }","[77, 78, 79, 80, 81, 82]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
199045," static void ip_expire(unsigned long arg)
 {
 	struct ipq *qp;
 	struct net *net;
 
 	qp = container_of((struct inet_frag_queue *) arg, struct ipq, q);
 	net = container_of(qp->q.net, struct net, ipv4.frags);
 
 	spin_lock(&qp->q.lock);
 
 	if (qp->q.last_in & INET_FRAG_COMPLETE)
 		goto out;
 
 	ipq_kill(qp);
 
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);
  
  	if ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {
  		struct sk_buff *head = qp->q.fragments;
 		const struct iphdr *iph;
 		int err;
  
  		rcu_read_lock();
  		head->dev = dev_get_by_index_rcu(net, qp->iif);
  		if (!head->dev)
  			goto out_rcu_unlock;
  
 		 
 		skb_dst_drop(head);
 		iph = ip_hdr(head);
 		err = ip_route_input_noref(head, iph->daddr, iph->saddr,
 					   iph->tos, head->dev);
 		if (err)
 			goto out_rcu_unlock;
 
  		 
		if (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {
			const struct iphdr *iph = ip_hdr(head);
			int err = ip_route_input(head, iph->daddr, iph->saddr,
						 iph->tos, head->dev);
			if (unlikely(err))
				goto out_rcu_unlock;
			 
			if (skb_rtable(head)->rt_type != RTN_LOCAL)
				goto out_rcu_unlock;
 		if (qp->user == IP_DEFRAG_CONNTRACK_IN &&
 		    skb_rtable(head)->rt_type != RTN_LOCAL)
 			goto out_rcu_unlock;
  
		}
  
  		 
  		icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);
 out_rcu_unlock:
 		rcu_read_unlock();
 	}
 out:
 	spin_unlock(&qp->q.lock);
 	ipq_put(qp);
 }","[21, 22, 29, 30, 31, 32, 33, 34, 35, 36, 47, 48, 49, 38, 39, 40, 41, 42, 43, 44, 45, 46, 51]","The ip_expire function in net/ipv4/ip_fragment.c in the Linux kernel before 2.6.39 does not properly construct ICMP_TIME_EXCEEDED packets after a timeout, which allows remote attackers to cause a denial of service (invalid pointer dereference) via crafted fragmented packets."
205844,"  void WallpaperManager::DoSetDefaultWallpaper(
      const AccountId& account_id,
     bool update_wallpaper,
      MovableOnDestroyCallbackHolder on_finish) {
    if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())
     return;
   wallpaper_cache_.erase(account_id);
 
   WallpaperResolution resolution = GetAppropriateResolution();
   const bool use_small = (resolution == WALLPAPER_RESOLUTION_SMALL);
 
   const base::FilePath* file = NULL;
 
   const user_manager::User* user =
       user_manager::UserManager::Get()->FindUser(account_id);
 
   if (user_manager::UserManager::Get()->IsLoggedInAsGuest()) {
     file =
         use_small ? &guest_small_wallpaper_file_ : &guest_large_wallpaper_file_;
   } else if (user && user->GetType() == user_manager::USER_TYPE_CHILD) {
     file =
         use_small ? &child_small_wallpaper_file_ : &child_large_wallpaper_file_;
   } else {
     file = use_small ? &default_small_wallpaper_file_
                      : &default_large_wallpaper_file_;
   }
   wallpaper::WallpaperLayout layout =
       use_small ? wallpaper::WALLPAPER_LAYOUT_CENTER
                 : wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED;
   DCHECK(file);
   if (!default_wallpaper_image_.get() ||
       default_wallpaper_image_->file_path() != *file) {
      default_wallpaper_image_.reset();
      if (!file->empty()) {
        loaded_wallpapers_for_test_++;
      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),
       StartLoadAndSetDefaultWallpaper(*file, layout, update_wallpaper,
                                       std::move(on_finish),
                                        &default_wallpaper_image_);
        return;
      }
  
      CreateSolidDefaultWallpaper();
    }
  if (default_wallpaper_image_->image().width() == 1 &&
      default_wallpaper_image_->image().height() == 1)
    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
  SetWallpaper(default_wallpaper_image_->image(), info);
 
   if (update_wallpaper) {
      
     if (default_wallpaper_image_->image().width() == 1 &&
         default_wallpaper_image_->image().height() == 1) {
       layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
     }
 
     WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
                        wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
     SetWallpaper(default_wallpaper_image_->image(), info);
   }
  }","[3, 37, 38, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 36, 45, 46, 47, 48, 49, 50]","The XSSAuditor::canonicalize function in core/html/parser/XSSAuditor.cpp in the XSS auditor in Blink, as used in Google Chrome before 44.0.2403.89, does not properly choose a truncation point, which makes it easier for remote attackers to obtain sensitive information via an unspecified linear-time attack."
198721,"  void cipso_v4_sock_delattr(struct sock *sk)
  {
  	int hdr_delta;
	struct ip_options *opt;
 	struct ip_options_rcu *opt;
  	struct inet_sock *sk_inet;
  
  	sk_inet = inet_sk(sk);
	opt = sk_inet->opt;
	if (opt == NULL || opt->cipso == 0)
 	opt = rcu_dereference_protected(sk_inet->inet_opt, 1);
 	if (opt == NULL || opt->opt.cipso == 0)
  		return;
  
	hdr_delta = cipso_v4_delopt(&sk_inet->opt);
 	hdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);
  	if (sk_inet->is_icsk && hdr_delta > 0) {
  		struct inet_connection_sock *sk_conn = inet_csk(sk);
  		sk_conn->icsk_ext_hdr_len -= hdr_delta;
 		sk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);
 	}
 }","[5, 11, 12, 16, 4, 9, 10, 15]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
207344," xsltCopyOf(xsltTransformContextPtr ctxt, xmlNodePtr node,
 	           xmlNodePtr inst, xsltStylePreCompPtr castedComp) {
 #ifdef XSLT_REFACTORED
     xsltStyleItemCopyOfPtr comp = (xsltStyleItemCopyOfPtr) castedComp;
 #else
     xsltStylePreCompPtr comp = castedComp;
 #endif
      xmlXPathObjectPtr res = NULL;
      xmlNodeSetPtr list = NULL;
      int i;
    xmlDocPtr oldXPContextDoc;
    xmlNsPtr *oldXPNamespaces;
    xmlNodePtr oldXPContextNode;
    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;
    xmlXPathContextPtr xpctxt;
  
      if ((ctxt == NULL) || (node == NULL) || (inst == NULL))
  	return;
     if ((comp == NULL) || (comp->select == NULL) || (comp->comp == NULL)) {
 	xsltTransformError(ctxt, NULL, inst,
 	     ""xsl:copy-of : compilation failed\n"");
 	return;
     }
 
       
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
     XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
 	 ""xsltCopyOf: select %s\n"", comp->select));
 #endif
 
       
    xpctxt = ctxt->xpathCtxt;
    oldXPContextDoc = xpctxt->doc;
    oldXPContextNode = xpctxt->node;
    oldXPProximityPosition = xpctxt->proximityPosition;
    oldXPContextSize = xpctxt->contextSize;
    oldXPNsNr = xpctxt->nsNr;
    oldXPNamespaces = xpctxt->namespaces;
    xpctxt->node = node;
    if (comp != NULL) {
#ifdef XSLT_REFACTORED
	if (comp->inScopeNs != NULL) {
	    xpctxt->namespaces = comp->inScopeNs->list;
	    xpctxt->nsNr = comp->inScopeNs->xpathNumber;
	} else {
	    xpctxt->namespaces = NULL;
	    xpctxt->nsNr = 0;
	}
#else
	xpctxt->namespaces = comp->nsList;
	xpctxt->nsNr = comp->nsNr;
#endif
    } else {
	xpctxt->namespaces = NULL;
	xpctxt->nsNr = 0;
    }
    res = xmlXPathCompiledEval(comp->comp, xpctxt);
    xpctxt->doc = oldXPContextDoc;
    xpctxt->node = oldXPContextNode;
    xpctxt->contextSize = oldXPContextSize;
    xpctxt->proximityPosition = oldXPProximityPosition;
    xpctxt->nsNr = oldXPNsNr;
    xpctxt->namespaces = oldXPNamespaces;
     res = xsltPreCompEval(ctxt, node, comp);
  
      if (res != NULL) {
  	if (res->type == XPATH_NODESET) {
 	     
 #ifdef WITH_XSLT_DEBUG_PROCESS
 	    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
 		 ""xsltCopyOf: result is a node set\n""));
 #endif
 	    list = res->nodesetval;
 	    if (list != NULL) {
 		xmlNodePtr cur;
 		 
 		for (i = 0;i < list->nodeNr;i++) {
 		    cur = list->nodeTab[i];
 		    if (cur == NULL)
 			continue;
 		    if ((cur->type == XML_DOCUMENT_NODE) ||
 			(cur->type == XML_HTML_DOCUMENT_NODE))
 		    {
 			xsltCopyTreeList(ctxt, inst,
 			    cur->children, ctxt->insert, 0, 0);
 		    } else if (cur->type == XML_ATTRIBUTE_NODE) {
 			xsltShallowCopyAttr(ctxt, inst,
 			    ctxt->insert, (xmlAttrPtr) cur);
 		    } else {
 			xsltCopyTreeInternal(ctxt, inst,
 			    cur, ctxt->insert, 0, 0);
 		    }
 		}
 	    }
 	} else if (res->type == XPATH_XSLT_TREE) {
 	     
 #ifdef WITH_XSLT_DEBUG_PROCESS
 	    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
 		 ""xsltCopyOf: result is a result tree fragment\n""));
 #endif
 	    list = res->nodesetval;
 	    if ((list != NULL) && (list->nodeTab != NULL) &&
 		(list->nodeTab[0] != NULL) &&
 		(IS_XSLT_REAL_NODE(list->nodeTab[0])))
 	    {
 		xsltCopyTreeList(ctxt, inst,
 		    list->nodeTab[0]->children, ctxt->insert, 0, 0);
 	    }
 	} else {
 	    xmlChar *value = NULL;
 	     
 	    value = xmlXPathCastToString(res);
 	    if (value == NULL) {
 		xsltTransformError(ctxt, NULL, inst,
 		    ""Internal error in xsltCopyOf(): ""
 		    ""failed to cast an XPath object to string.\n"");
 		ctxt->state = XSLT_STATE_STOPPED;
 	    } else {
 		if (value[0] != 0) {
 		     
 		    xsltCopyTextString(ctxt, ctxt->insert, value, 0);
 		}
 		xmlFree(value);
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
 		XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,
 		    ""xsltCopyOf: result %s\n"", res->stringval));
 #endif
 	    }
 	}
     } else {
 	ctxt->state = XSLT_STATE_STOPPED;
     }
 
     if (res != NULL)
 	xmlXPathFreeObject(res);
 }","[65, 11, 12, 13, 14, 15, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
200027," static inline bool is_exception(u32 intr_info)
 static inline bool is_nmi(u32 intr_info)
  {
  	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))
		== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);
 		== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);
  }","[2, 6, 5]","arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest."
198767,"  static void hugetlb_vm_op_close(struct vm_area_struct *vma)
  {
  	struct hstate *h = hstate_vma(vma);
 	struct resv_map *reservations = vma_resv_map(vma);
 	struct hugepage_subpool *spool = subpool_vma(vma);
 	unsigned long reserve;
 	unsigned long start;
 	unsigned long end;
 
 	if (reservations) {
 		start = vma_hugecache_offset(h, vma, vma->vm_start);
 		end = vma_hugecache_offset(h, vma, vma->vm_end);
 
  		reserve = (end - start) -
  			region_count(&reservations->regions, start, end);
  
		kref_put(&reservations->refs, resv_map_release);
 		resv_map_put(vma);
  
  		if (reserve) {
  			hugetlb_acct_memory(h, -reserve);
 			hugepage_subpool_put_pages(spool, reserve);
 		}
 	}
 }","[18, 17]",Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.
206962,"   void SetupMockGroup() {
     std::unique_ptr<net::HttpResponseInfo> info(MakeMockResponseInfo());
     const int kMockInfoSize = GetResponseInfoSize(info.get());
 
     scoped_refptr<AppCacheGroup> group(
         new AppCacheGroup(service_->storage(), kManifestUrl, kMockGroupId));
     scoped_refptr<AppCache> cache(
         new AppCache(service_->storage(), kMockCacheId));
      cache->AddEntry(
          kManifestUrl,
          AppCacheEntry(AppCacheEntry::MANIFEST, kMockResponseId,
                      kMockInfoSize + kMockBodySize));
                       kMockInfoSize + kMockBodySize,  0));
      cache->set_complete(true);
      group->AddCache(cache.get());
      mock_storage()->AddStoredGroup(group.get());
     mock_storage()->AddStoredCache(cache.get());
   }","[13, 12]",Resource size information leakage in Blink in Google Chrome prior to 75.0.3770.80 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
202523,"  krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,
                          char **db_args)
 {
     int                         l=0, kerberos_principal_object_type=0;
     unsigned int                ntrees=0, tre=0;
     krb5_error_code             st=0, tempst=0;
     LDAP                        *ld=NULL;
      LDAPMessage                 *result=NULL, *ent=NULL;
      char                        **subtreelist = NULL;
      char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;
    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];
     char                        *strval[10]={NULL}, errbuf[1024];
      char                        *filtuser=NULL;
      struct berval               **bersecretkey=NULL;
      LDAPMod                     **mods=NULL;
      krb5_boolean                create_standalone=FALSE;
    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;
     krb5_boolean                establish_links=FALSE;
      char                        *standalone_principal_dn=NULL;
      krb5_tl_data                *tl_data=NULL;
      krb5_key_data               **keys=NULL;
     kdb5_dal_handle             *dal_handle=NULL;
     krb5_ldap_context           *ldap_context=NULL;
     krb5_ldap_server_handle     *ldap_server_handle=NULL;
     osa_princ_ent_rec           princ_ent = {0};
     xargs_t                     xargs = {0};
     char                        *polname = NULL;
     OPERATION optype;
     krb5_boolean                found_entry = FALSE;
 
      
     krb5_clear_error_message(context);
 
     SETUP_CONTEXT();
     if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)
         return EINVAL;
 
      
     GET_HANDLE();
 
     if (!is_principal_in_realm(ldap_context, entry->princ)) {
         st = EINVAL;
         k5_setmsg(context, st,
                   _(""Principal does not belong to the default realm""));
         goto cleanup;
     }
 
      
     if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||
         ((st=krb5_ldap_unparse_principal_name(user)) != 0))
         goto cleanup;
     filtuser = ldap_filter_correct(user);
     if (filtuser == NULL) {
         st = ENOMEM;
         goto cleanup;
     }
 
      
     if (entry->mask & KADM5_PRINCIPAL)
         optype = ADD_PRINCIPAL;
     else
         optype = MODIFY_PRINCIPAL;
 
     if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||
         ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))
         goto cleanup;
 
     if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)
         goto cleanup;
 
     if (entry->mask & KADM5_LOAD) {
         unsigned int     tree = 0;
         int              numlentries = 0;
         char             *filter = NULL;
 
          
         if (asprintf(&filter, FILTER""%s))"", filtuser) < 0) {
             filter = NULL;
             st = ENOMEM;
             goto cleanup;
         }
 
          
         if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)
             goto cleanup;
 
         found_entry = FALSE;
          
         for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {
             if (principal_dn == NULL) {
                 LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);
             } else {
                  
                 LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);
             }
             if (st == LDAP_SUCCESS) {
                 numlentries = ldap_count_entries(ld, result);
                 if (numlentries > 1) {
                     free(filter);
                     st = EINVAL;
                     k5_setmsg(context, st,
                               _(""operation can not continue, more than one ""
                                 ""entry with principal name \""%s\"" found""),
                               user);
                     goto cleanup;
                 } else if (numlentries == 1) {
                     found_entry = TRUE;
                     if (principal_dn == NULL) {
                         ent = ldap_first_entry(ld, result);
                         if (ent != NULL) {
                              
                             if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {
                                 ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);
                                 st = set_ldap_error (context, st, 0);
                                 free(filter);
                                 goto cleanup;
                             }
                         }
                     }
                 }
             } else if (st != LDAP_NO_SUCH_OBJECT) {
                  
                 st = set_ldap_error (context, st, 0);
                 free(filter);
                 goto cleanup;
             }
             ldap_msgfree(result);
             result = NULL;
              
         }  
 
         free(filter);
 
         if (found_entry == FALSE && principal_dn != NULL) {
              
             create_standalone = TRUE;
             standalone_principal_dn = strdup(principal_dn);
             CHECK_NULL(standalone_principal_dn);
         }
     }  
 
      
     if (principal_dn == NULL && xargs.dn == NULL) {  
          
         if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(""krbtgt"") &&
             strncmp(entry->princ->data[0].data, ""krbtgt"", entry->princ->data[0].length) == 0) {
              
             subtree = strdup(ldap_context->lrparams->realmdn);
         } else if (xargs.containerdn) {
             if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {
                 if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {
                     int ost = st;
                     st = EINVAL;
                     k5_wrapmsg(context, ost, st, _(""'%s' not found""),
                                xargs.containerdn);
                 }
                 goto cleanup;
             }
             subtree = strdup(xargs.containerdn);
         } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {
              
             subtree = strdup(ldap_context->lrparams->containerref);
         } else {
             subtree = strdup(ldap_context->lrparams->realmdn);
         }
         CHECK_NULL(subtree);
 
         if (asprintf(&standalone_principal_dn, ""krbprincipalname=%s,%s"",
                      filtuser, subtree) < 0)
             standalone_principal_dn = NULL;
         CHECK_NULL(standalone_principal_dn);
          
         create_standalone = TRUE;
         free(subtree);
         subtree = NULL;
     }
 
      
      if (xargs.dn_from_kbd == TRUE) {
         
        int              dnlen=0, subtreelen=0;
        char             *dn=NULL;
        krb5_boolean     outofsubtree=TRUE;
        if (xargs.dn != NULL) {
            dn = xargs.dn;
        } else if (xargs.linkdn != NULL) {
            dn = xargs.linkdn;
        } else if (standalone_principal_dn != NULL) {
             
            dn = standalone_principal_dn;
        }
           
          if (subtreelist == NULL) {
              st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);
              if (st)
                  goto cleanup;
          }
  
        for (tre=0; tre<ntrees; ++tre) {
            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {
                outofsubtree = FALSE;
                break;
            } else {
                dnlen = strlen (dn);
                subtreelen = strlen(subtreelist[tre]);
                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {
                    outofsubtree = FALSE;
                    break;
                }
            }
        }
        if (outofsubtree == TRUE) {
            st = EINVAL;
            k5_setmsg(context, st, _(""DN is out of the realm subtree""));
         st = validate_xargs(context, ldap_server_handle, &xargs,
                             standalone_principal_dn, subtreelist, ntrees);
         if (st)
              goto cleanup;
        }
         
        if (standalone_principal_dn == NULL) {
             
             
            char  *attributes[]={""krbticketpolicyreference"", ""krbprincipalname"", NULL};
            ldap_msgfree(result);
            result = NULL;
            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);
            if (st == LDAP_SUCCESS) {
                ent = ldap_first_entry(ld, result);
                if (ent != NULL) {
                    if ((values=ldap_get_values(ld, ent, ""krbticketpolicyreference"")) != NULL) {
                        ldap_value_free(values);
                    }
                    if ((values=ldap_get_values(ld, ent, ""krbprincipalname"")) != NULL) {
                        krb_identity_exists = TRUE;
                        ldap_value_free(values);
                    }
                }
            } else {
                st = set_ldap_error(context, st, OP_SEARCH);
                goto cleanup;
            }
        }
    }
     
    if (xargs.dn != NULL && krb_identity_exists == TRUE) {
        st = EINVAL;
        snprintf(errbuf, sizeof(errbuf),
                 _(""ldap object is already kerberized""));
        k5_setmsg(context, st, ""%s"", errbuf);
        goto cleanup;
      }
  
      if (xargs.linkdn != NULL) {
          
         if (optype == MODIFY_PRINCIPAL &&
             kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {
             st = EINVAL;
             snprintf(errbuf, sizeof(errbuf),
                      _(""link information can not be set/updated as the ""
                        ""kerberos principal belongs to an ldap object""));
             k5_setmsg(context, st, ""%s"", errbuf);
             goto cleanup;
         }
          
         {
             char **linkdns=NULL;
             int  j=0;
 
             if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {
                 snprintf(errbuf, sizeof(errbuf),
                          _(""Failed getting object references""));
                 k5_setmsg(context, st, ""%s"", errbuf);
                 goto cleanup;
             }
             if (linkdns != NULL) {
                 st = EINVAL;
                 snprintf(errbuf, sizeof(errbuf),
                          _(""kerberos principal is already linked to a ldap ""
                            ""object""));
                 k5_setmsg(context, st, ""%s"", errbuf);
                 for (j=0; linkdns[j] != NULL; ++j)
                     free (linkdns[j]);
                 free (linkdns);
                 goto cleanup;
             }
         }
 
         establish_links = TRUE;
     }
 
     if (entry->mask & KADM5_LAST_SUCCESS) {
         memset(strval, 0, sizeof(strval));
         if ((strval[0]=getstringtime(entry->last_success)) == NULL)
             goto cleanup;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastSuccessfulAuth"", LDAP_MOD_REPLACE, strval)) != 0) {
             free (strval[0]);
             goto cleanup;
         }
         free (strval[0]);
     }
 
     if (entry->mask & KADM5_LAST_FAILED) {
         memset(strval, 0, sizeof(strval));
         if ((strval[0]=getstringtime(entry->last_failed)) == NULL)
             goto cleanup;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastFailedAuth"", LDAP_MOD_REPLACE, strval)) != 0) {
             free (strval[0]);
             goto cleanup;
         }
         free(strval[0]);
     }
 
     if (entry->mask & KADM5_FAIL_AUTH_COUNT) {
         krb5_kvno fail_auth_count;
 
         fail_auth_count = entry->fail_auth_count;
         if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
             fail_auth_count++;
 
         st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                        LDAP_MOD_REPLACE,
                                        fail_auth_count);
         if (st != 0)
             goto cleanup;
     } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {
         int attr_mask = 0;
         krb5_boolean has_fail_count;
 
          
         st = krb5_get_attributes_mask(context, entry, &attr_mask);
         if (st != 0)
             goto cleanup;
         has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);
 
          
 #ifdef LDAP_MOD_INCREMENT
         if (ldap_server_handle->server_info->modify_increment &&
             has_fail_count) {
             st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                            LDAP_MOD_INCREMENT, 1);
             if (st != 0)
                 goto cleanup;
         } else {
 #endif  
             if (has_fail_count) {
                 st = krb5_add_int_mem_ldap_mod(&mods,
                                                ""krbLoginFailedCount"",
                                                LDAP_MOD_DELETE,
                                                entry->fail_auth_count);
                 if (st != 0)
                     goto cleanup;
             }
             st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                            LDAP_MOD_ADD,
                                            entry->fail_auth_count + 1);
             if (st != 0)
                 goto cleanup;
 #ifdef LDAP_MOD_INCREMENT
         }
 #endif
     } else if (optype == ADD_PRINCIPAL) {
          
         st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                        LDAP_MOD_ADD, 0);
     }
 
     if (entry->mask & KADM5_MAX_LIFE) {
         if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxticketlife"", LDAP_MOD_REPLACE, entry->max_life)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_MAX_RLIFE) {
         if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxrenewableage"", LDAP_MOD_REPLACE,
                                           entry->max_renewable_life)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_ATTRIBUTES) {
         if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbticketflags"", LDAP_MOD_REPLACE,
                                           entry->attributes)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_PRINCIPAL) {
         memset(strval, 0, sizeof(strval));
         strval[0] = user;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbprincipalname"", LDAP_MOD_REPLACE, strval)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {
         memset(strval, 0, sizeof(strval));
         if ((strval[0]=getstringtime(entry->expiration)) == NULL)
             goto cleanup;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbprincipalexpiration"", LDAP_MOD_REPLACE, strval)) != 0) {
             free (strval[0]);
             goto cleanup;
         }
         free (strval[0]);
     }
 
     if (entry->mask & KADM5_PW_EXPIRATION) {
         memset(strval, 0, sizeof(strval));
         if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
             goto cleanup;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpasswordexpiration"",
                                           LDAP_MOD_REPLACE,
                                           strval)) != 0) {
             free (strval[0]);
             goto cleanup;
         }
         free (strval[0]);
     }
 
     if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {
         memset(&princ_ent, 0, sizeof(princ_ent));
         for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {
             if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {
                 if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {
                     goto cleanup;
                 }
                 break;
             }
         }
     }
 
     if (entry->mask & KADM5_POLICY) {
         if (princ_ent.aux_attributes & KADM5_POLICY) {
             memset(strval, 0, sizeof(strval));
             if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)
                 goto cleanup;
             strval[0] = polname;
             if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_REPLACE, strval)) != 0)
                 goto cleanup;
         } else {
             st = EINVAL;
             k5_setmsg(context, st, ""Password policy value null"");
             goto cleanup;
         }
     } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {
          
 
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_REPLACE, NULL)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_POLICY_CLR) {
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_DELETE, NULL)) != 0)
             goto cleanup;
     }
 
     if (entry->mask & KADM5_KEY_HIST) {
         bersecretkey = krb5_encode_histkey(&princ_ent);
         if (bersecretkey == NULL) {
             st = ENOMEM;
             goto cleanup;
         }
 
         st = krb5_add_ber_mem_ldap_mod(&mods, ""krbpwdhistory"",
                                        LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                        bersecretkey);
         if (st != 0)
             goto cleanup;
         free_berdata(bersecretkey);
         bersecretkey = NULL;
     }
 
     if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {
         krb5_kvno mkvno;
 
         if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)
             goto cleanup;
         bersecretkey = krb5_encode_krbsecretkey (entry->key_data,
                                                  entry->n_key_data, mkvno);
 
         if (bersecretkey == NULL) {
             st = ENOMEM;
             goto cleanup;
         }
          
         if (bersecretkey[0] != NULL || !create_standalone) {
             st = krb5_add_ber_mem_ldap_mod(&mods, ""krbprincipalkey"",
                                            LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                            bersecretkey);
             if (st != 0)
                 goto cleanup;
         }
 
         if (!(entry->mask & KADM5_PRINCIPAL)) {
             memset(strval, 0, sizeof(strval));
             if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
                 goto cleanup;
             if ((st=krb5_add_str_mem_ldap_mod(&mods,
                                               ""krbpasswordexpiration"",
                                               LDAP_MOD_REPLACE, strval)) != 0) {
                 free (strval[0]);
                 goto cleanup;
             }
             free (strval[0]);
         }
 
          
         {
             krb5_timestamp last_pw_changed;
             if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,
                                                     &last_pw_changed)) != 0)
                 goto cleanup;
 
             memset(strval, 0, sizeof(strval));
             if ((strval[0] = getstringtime(last_pw_changed)) == NULL)
                 goto cleanup;
 
             if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastPwdChange"",
                                               LDAP_MOD_REPLACE, strval)) != 0) {
                 free (strval[0]);
                 goto cleanup;
             }
             free (strval[0]);
         }
 
     }  
 
      
     st = update_ldap_mod_auth_ind(context, entry, &mods);
     if (st != 0)
         goto cleanup;
 
      
     if (entry->tl_data != NULL) {
         int count = 0;
         struct berval **ber_tl_data = NULL;
         krb5_tl_data *ptr;
         krb5_timestamp unlock_time;
         for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
             if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
 #ifdef SECURID
                 || ptr->tl_data_type == KRB5_TL_DB_ARGS
 #endif
                 || ptr->tl_data_type == KRB5_TL_KADM_DATA
                 || ptr->tl_data_type == KDB_TL_USER_INFO
                 || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                 || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                 continue;
             count++;
         }
         if (count != 0) {
             int j;
             ber_tl_data = (struct berval **) calloc (count + 1,
                                                      sizeof (struct berval*));
             if (ber_tl_data == NULL) {
                 st = ENOMEM;
                 goto cleanup;
             }
             for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
                  
                 if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
 #ifdef SECURID
                     || ptr->tl_data_type == KRB5_TL_DB_ARGS
 #endif
                     || ptr->tl_data_type == KRB5_TL_KADM_DATA
                     || ptr->tl_data_type == KDB_TL_USER_INFO
                     || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                     || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                     continue;
                 if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)
                     break;
                 j++;
             }
             if (st == 0) {
                 ber_tl_data[count] = NULL;
                 st=krb5_add_ber_mem_ldap_mod(&mods, ""krbExtraData"",
                                              LDAP_MOD_REPLACE |
                                              LDAP_MOD_BVALUES, ber_tl_data);
             }
             free_berdata(ber_tl_data);
             if (st != 0)
                 goto cleanup;
         }
         if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,
                                                   &unlock_time)) != 0)
             goto cleanup;
         if (unlock_time != 0) {
              
             memset(strval, 0, sizeof(strval));
             if ((strval[0] = getstringtime(unlock_time)) == NULL)
                 goto cleanup;
 
             if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastAdminUnlock"",
                                               LDAP_MOD_REPLACE, strval)) != 0) {
                 free (strval[0]);
                 goto cleanup;
             }
             free (strval[0]);
         }
     }
 
      
     if (xargs.tktpolicydn != NULL) {
         int tmask=0;
 
         if (strlen(xargs.tktpolicydn) != 0) {
             st = checkattributevalue(ld, xargs.tktpolicydn, ""objectclass"", policyclass, &tmask);
             CHECK_CLASS_VALIDITY(st, tmask, _(""ticket policy object value: ""));
 
             strval[0] = xargs.tktpolicydn;
             strval[1] = NULL;
             if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbticketpolicyreference"", LDAP_MOD_REPLACE, strval)) != 0)
                 goto cleanup;
 
         } else {
              
             if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbticketpolicyreference"", LDAP_MOD_DELETE, NULL)) != 0)
                 goto cleanup;
         }
 
     }
 
     if (establish_links == TRUE) {
         memset(strval, 0, sizeof(strval));
         strval[0] = xargs.linkdn;
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbObjectReferences"", LDAP_MOD_REPLACE, strval)) != 0)
             goto cleanup;
     }
 
      
     if (mods == NULL)
         goto cleanup;
 
     if (create_standalone == TRUE) {
         memset(strval, 0, sizeof(strval));
         strval[0] = ""krbprincipal"";
         strval[1] = ""krbprincipalaux"";
         strval[2] = ""krbTicketPolicyAux"";
 
         if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)
             goto cleanup;
 
         st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
         if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {
              
             st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);
             if (st != LDAP_SUCCESS) {
                 snprintf(errbuf, sizeof(errbuf),
                          _(""Principal delete failed (trying to replace ""
                            ""entry): %s""), ldap_err2string(st));
                 st = translate_ldap_error (st, OP_ADD);
                 k5_setmsg(context, st, ""%s"", errbuf);
                 goto cleanup;
             } else {
                 st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
             }
         }
         if (st != LDAP_SUCCESS) {
             snprintf(errbuf, sizeof(errbuf), _(""Principal add failed: %s""),
                      ldap_err2string(st));
             st = translate_ldap_error (st, OP_ADD);
             k5_setmsg(context, st, ""%s"", errbuf);
             goto cleanup;
         }
     } else {
          
         {
             char *attrvalues[] = {""krbprincipalaux"", ""krbTicketPolicyAux"", NULL};
             int p, q, r=0, amask=0;
 
             if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,
                                         ""objectclass"", attrvalues, &amask)) != 0)
                 goto cleanup;
 
             memset(strval, 0, sizeof(strval));
             for (p=1, q=0; p<=2; p<<=1, ++q) {
                 if ((p & amask) == 0)
                     strval[r++] = attrvalues[q];
             }
             if (r != 0) {
                 if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)
                     goto cleanup;
             }
         }
         if (xargs.dn != NULL)
             st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);
         else
             st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);
 
         if (st != LDAP_SUCCESS) {
             snprintf(errbuf, sizeof(errbuf), _(""User modification failed: %s""),
                      ldap_err2string(st));
             st = translate_ldap_error (st, OP_MOD);
             k5_setmsg(context, st, ""%s"", errbuf);
             goto cleanup;
         }
 
         if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
             entry->fail_auth_count++;
     }
 
 cleanup:
     if (user)
         free(user);
 
     if (filtuser)
         free(filtuser);
 
     free_xargs(xargs);
 
     if (standalone_principal_dn)
         free(standalone_principal_dn);
 
     if (principal_dn)
         free (principal_dn);
 
     if (polname != NULL)
         free(polname);
 
     for (tre = 0; tre < ntrees; tre++)
         free(subtreelist[tre]);
     free(subtreelist);
 
     if (subtree)
         free (subtree);
 
     if (bersecretkey) {
         for (l=0; bersecretkey[l]; ++l) {
             if (bersecretkey[l]->bv_val)
                 free (bersecretkey[l]->bv_val);
             free (bersecretkey[l]);
         }
         free (bersecretkey);
     }
 
     if (keys)
         free (keys);
 
     ldap_mods_free(mods, 1);
     ldap_osa_free_princ_ent(&princ_ent);
     ldap_msgfree(result);
     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);
     return(st);
 }","[12, 18, 215, 216, 217, 11, 17, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251]","MIT krb5 1.6 or later allows an authenticated kadmin with permission to add principals to an LDAP Kerberos database to circumvent a DN containership check by supplying both a *linkdn* and *containerdn* database argument, or by supplying a DN string which is a left extension of a container DN string but is not hierarchically within the container DN."
9941,"void Compute(OpKernelContext* context) override {
const Tensor& x = context->input(0);
const Tensor& y = context->input(1);
const float min_x = context->input(2).flat<float>()(0);
const float max_x = context->input(3).flat<float>()(0);
const float min_y = context->input(4).flat<float>()(0);
const float max_y = context->input(5).flat<float>()(0);

BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape()));
if (!bcast.IsValid()) {
context->SetStatus(errors::InvalidArgument(
""Incompatible shapes: "", x.shape().DebugString(), "" vs. "",
y.shape().DebugString()));
return;
}
Tensor* z;
OP_REQUIRES_OK(context, context->allocate_output(
0, BCast::ToShape(bcast.output_shape()), &z));




OP_REQUIRES(context, (max_x > min_x),
errors::InvalidArgument(""max_x must be larger than min_x.""));
OP_REQUIRES(context, (max_y > min_y),
errors::InvalidArgument(""max_y must be larger than min_y.""));
const T* x_data = x.flat<T>().data();
const T* y_data = y.flat<T>().data();
Toutput* z_data = z->flat<Toutput>().data();




const float smallest_min = std::min(min_x, min_y);
const float largest_max = std::max(max_x, max_y);
const float biggest_range =
std::max(std::abs(smallest_min), std::abs(largest_max));
const float output_range = (biggest_range * (1 << 14));
const float min_z_value = -output_range;
const float max_z_value = output_range;

const int ndims = bcast.x_reshape().size();
if (ndims <= 1) {
if (x.NumElements() == 1) {
ScalarAddition<T, Toutput>(context, y_data, min_y, max_y,
y.NumElements(), x_data[0], min_x, max_x,
min_z_value, max_z_value, z_data);
} else if (y.NumElements() == 1) {
ScalarAddition<T, Toutput>(context, x_data, min_x, max_x,
x.NumElements(), y_data[0], min_y, max_y,
min_z_value, max_z_value, z_data);
} else {
VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y,
max_y, x.NumElements(), min_z_value,
max_z_value, z_data);
}
} else if (ndims == 2) {
const T* vector_data;
int64_t vector_num_elements;
float vector_min;
float vector_max;
const T* tensor_data;
int64_t tensor_num_elements;
float tensor_min;
float tensor_max;
if (x.NumElements() < y.NumElements()) {
vector_data = x_data;
vector_num_elements = x.NumElements();
vector_min = min_x;
vector_max = max_x;
tensor_data = y_data;
tensor_num_elements = y.NumElements();
tensor_min = min_y;
tensor_max = max_y;
} else {
vector_data = y_data;
vector_num_elements = y.NumElements();
vector_min = min_y;
vector_max = max_y;
tensor_data = x_data;
tensor_num_elements = x.NumElements();
tensor_min = min_x;
tensor_max = max_x;
}
OP_REQUIRES(context, vector_num_elements > 0,
errors::InvalidArgument(""Must have some elements to add""));
VectorTensorAddition<T, Toutput>(
vector_data, vector_min, vector_max, vector_num_elements, tensor_data,
tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value,
z_data);
} else {
LOG(INFO) << ""ndims="" << ndims;
LOG(INFO) << ""bcast.x_reshape()=""
<< TensorShape(bcast.x_reshape()).DebugString();
LOG(INFO) << ""bcast.y_reshape()=""
<< TensorShape(bcast.y_reshape()).DebugString();
LOG(INFO) << ""bcast.x_bcast()=""
<< TensorShape(bcast.x_bcast()).DebugString();
LOG(INFO) << ""bcast.y_bcast()=""
<< TensorShape(bcast.y_bcast()).DebugString();

context->SetStatus(errors::Unimplemented(
""Broadcast between "", context->input(0).shape().DebugString(),
"" and "", context->input(1).shape().DebugString(),
"" is not supported yet.""));
return;
}

Tensor* z_min = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min));
z_min->flat<float>()(0) = min_z_value;

Tensor* z_max = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max));
z_max->flat<float>()(0) = max_z_value;
}","[4, 5, 6, 7]","TensorFlow is an open source platform for machine learning. If `QuantizedAdd` is given `min_input` or `max_input` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 49b3824d83af706df0ad07e4e677d88659756d89. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
206669," bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,
                                              bool is_tld_ascii) {
   UErrorCode status = U_ZERO_ERROR;
   int32_t result =
       uspoof_check(checker_, label.data(),
                    base::checked_cast<int32_t>(label.size()), nullptr, &status);
   if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))
     return false;
 
   icu::UnicodeString label_string(FALSE, label.data(),
                                   base::checked_cast<int32_t>(label.size()));
 
   if (deviation_characters_.containsSome(label_string))
     return false;
 
   result &= USPOOF_RESTRICTION_LEVEL_MASK;
   if (result == USPOOF_ASCII)
     return true;
   if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&
       kana_letters_exceptions_.containsNone(label_string) &&
       combining_diacritics_exceptions_.containsNone(label_string)) {
     return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);
   }
 
   if (non_ascii_latin_letters_.containsSome(label_string) &&
       !lgc_letters_n_ascii_.containsAll(label_string))
     return false;
 
   if (!tls_index.initialized())
     tls_index.Initialize(&OnThreadTermination);
   icu::RegexMatcher* dangerous_pattern =
       reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());
   if (!dangerous_pattern) {
      
      dangerous_pattern = new icu::RegexMatcher(
         icu::UnicodeString(
             R""([^\p{scx=kana}\p{scx=hira}\p{scx=hani}])""
             R""([\u30ce\u30f3\u30bd\u30be])""
             R""([^\p{scx=kana}\p{scx=hira}\p{scx=hani}]|)""
             R""([^\p{scx=kana}\p{scx=hira}]\u30fc|^\u30fc|)""
             R""([^\p{scx=kana}][\u30fd\u30fe]|^[\u30fd\u30fe]|)""
             R""(^[\p{scx=kana}]+[\u3078-\u307a][\p{scx=kana}]+$|)""
              R""(^[\p{scx=hira}]+[\u30d8-\u30da][\p{scx=hira}]+$|)""
              R""([a-z]\u30fb|\u30fb[a-z]|)""
              R""([^\p{scx=latn}\p{scx=grek}\p{scx=cyrl}][\u0300-\u0339]|)""
            R""([ijl\u0131]\u0307)"",
             R""(\u0131[\u0300-\u0339]|)""
             R""([ijl]\u0307)"",
              -1, US_INV),
          0, status);
      tls_index.Set(dangerous_pattern);
   }
   dangerous_pattern->reset(label_string);
   return !dangerous_pattern->find();
 }","[34, 47, 48, 46]",Incorrect security UI in Omnibox in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page.
205082," void RenderWidgetHostViewAura::RunCompositingDidCommitCallbacks(
    ui::Compositor* compositor) {
  for (std::vector< base::Callback<void(ui::Compositor*)> >::const_iterator
 void RenderWidgetHostViewAura::RunCompositingDidCommitCallbacks() {
   for (std::vector<base::Closure>::const_iterator
        it = on_compositing_did_commit_callbacks_.begin();
        it != on_compositing_did_commit_callbacks_.end(); ++it) {
    it->Run(compositor);
     it->Run();
    }
    on_compositing_did_commit_callbacks_.clear();
  }","[4, 5, 9, 2, 3, 8]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
197780," GfxImageColorMap::GfxImageColorMap(int bitsA, Object *decode,
 				   GfxColorSpace *colorSpaceA) {
   GfxIndexedColorSpace *indexedCS;
   GfxSeparationColorSpace *sepCS;
   int maxPixel, indexHigh;
   Guchar *lookup2;
   Function *sepFunc;
   Object obj;
   double x[gfxColorMaxComps];
   double y[gfxColorMaxComps];
   int i, j, k, byte;
   double mapped;
 
   ok = gTrue;
 
   bits = bitsA;
   maxPixel = (1 << bits) - 1;
   colorSpace = colorSpaceA;
 
   if (maxPixel > 255) maxPixel = 255;
 
   for (k = 0; k < gfxColorMaxComps; ++k) {
     lookup[k] = NULL;
   }
 
   if (decode->isNull()) {
     nComps = colorSpace->getNComps();
     colorSpace->getDefaultRanges(decodeLow, decodeRange, maxPixel);
   } else if (decode->isArray()) {
     nComps = decode->arrayGetLength() / 2;
     if (nComps != colorSpace->getNComps()) {
       goto err1;
     }
     for (i = 0; i < nComps; ++i) {
       decode->arrayGet(2*i, &obj);
       if (!obj.isNum()) {
 	goto err2;
       }
       decodeLow[i] = obj.getNum();
       obj.free();
       decode->arrayGet(2*i+1, &obj);
       if (!obj.isNum()) {
 	goto err2;
       }
       decodeRange[i] = obj.getNum() - decodeLow[i];
       obj.free();
     }
   } else {
     goto err1;
   }
 
   colorSpace2 = NULL;
   nComps2 = 0;
   if (colorSpace->getMode() == csIndexed) {
     indexedCS = (GfxIndexedColorSpace *)colorSpace;
     colorSpace2 = indexedCS->getBase();
     indexHigh = indexedCS->getIndexHigh();
      nComps2 = colorSpace2->getNComps();
      lookup2 = indexedCS->getLookup();
      colorSpace2->getDefaultRanges(x, y, indexHigh);
    byte_lookup = (Guchar *)gmalloc ((maxPixel + 1) * nComps2);
     byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);
      for (k = 0; k < nComps2; ++k) {
        lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
  					   sizeof(GfxColorComp));
       for (i = 0; i <= maxPixel; ++i) {
 	j = (int)(decodeLow[0] + (i * decodeRange[0]) / maxPixel + 0.5);
 	if (j < 0) {
 	  j = 0;
 	} else if (j > indexHigh) {
 	  j = indexHigh;
 	}
 
 	mapped = x[k] + (lookup2[j*nComps2 + k] / 255.0) * y[k];
 	lookup[k][i] = dblToCol(mapped);
 	byte_lookup[i * nComps2 + k] = (Guchar) (mapped * 255);
       }
     }
   } else if (colorSpace->getMode() == csSeparation) {
     sepCS = (GfxSeparationColorSpace *)colorSpace;
     colorSpace2 = sepCS->getAlt();
     nComps2 = colorSpace2->getNComps();
     sepFunc = sepCS->getFunc();
     byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps2);
     for (k = 0; k < nComps2; ++k) {
       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
 					   sizeof(GfxColorComp));
       for (i = 0; i <= maxPixel; ++i) {
 	x[0] = decodeLow[0] + (i * decodeRange[0]) / maxPixel;
 	sepFunc->transform(x, y);
 	lookup[k][i] = dblToCol(y[k]);
 	byte_lookup[i*nComps2 + k] = (Guchar) (y[k] * 255);
       }
     }
   } else {
     byte_lookup = (Guchar *)gmallocn ((maxPixel + 1), nComps);
     for (k = 0; k < nComps; ++k) {
       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
 					   sizeof(GfxColorComp));
       for (i = 0; i <= maxPixel; ++i) {
 	mapped = decodeLow[k] + (i * decodeRange[k]) / maxPixel;
 	lookup[k][i] = dblToCol(mapped);
 	byte = (int) (mapped * 255.0 + 0.5);
 	if (byte < 0)  
 	  byte = 0;  
 	else if (byte > 255)  
 	  byte = 255;  
 	byte_lookup[i * nComps + k] = byte;	
       }
     }
   }
 
   return;
 
  err2:
   obj.free();
  err1:
   ok = gFalse;
   byte_lookup = NULL;
 }","[62, 61]","Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791."
9526,"PJ_DEF(pj_status_t) pjsip_ua_register_dlg( pjsip_user_agent *ua,
pjsip_dialog *dlg )
{

PJ_ASSERT_RETURN(ua && dlg, PJ_EINVAL);


PJ_ASSERT_RETURN(dlg->local.info && dlg->local.info->tag.slen &&
dlg->local.tag_hval != 0, PJ_EBUG);







pj_mutex_lock(mod_ua.mutex);


if (dlg->role == PJSIP_ROLE_UAC) {
struct dlg_set *dlg_set;

dlg_set = (struct dlg_set*)
pj_hash_get_lower( mod_ua.dlg_table,
dlg->local.info->tag.ptr,
(unsigned)dlg->local.info->tag.slen,
&dlg->local.tag_hval);

if (dlg_set) {



pj_assert(dlg_set->dlg_list.next != (void*)&dlg_set->dlg_list);
pj_list_push_back(&dlg_set->dlg_list, dlg);

dlg->dlg_set = dlg_set;

} else {



dlg_set = alloc_dlgset_node();
pj_list_init(&dlg_set->dlg_list);
pj_list_push_back(&dlg_set->dlg_list, dlg);

dlg->dlg_set = dlg_set;


pj_hash_set_np_lower(mod_ua.dlg_table,
dlg->local.info->tag.ptr,
(unsigned)dlg->local.info->tag.slen,
dlg->local.tag_hval, dlg_set->ht_entry,
dlg_set);
}

} else {

struct dlg_set *dlg_set;

dlg_set = alloc_dlgset_node();
pj_list_init(&dlg_set->dlg_list);
pj_list_push_back(&dlg_set->dlg_list, dlg);

dlg->dlg_set = dlg_set;

pj_hash_set_np_lower(mod_ua.dlg_table,
dlg->local.info->tag.ptr,
(unsigned)dlg->local.info->tag.slen,
dlg->local.tag_hval, dlg_set->ht_entry, dlg_set);
}


pj_mutex_unlock(mod_ua.mutex);


return PJ_SUCCESS;
}","[43, 50, 51, 61, 67, 68]","PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In versions up to and including 2.11.1 when in a dialog set (or forking) scenario, a hash key shared by multiple UAC dialogs can potentially be prematurely freed when one of the dialogs is destroyed . The issue may cause a dialog set to be registered in the hash table multiple times (with different hash keys) leading to undefined behavior such as dialog list collision which eventually leading to endless loop. A patch is available in commit db3235953baa56d2fb0e276ca510fefca751643f which will be included in the next release. There are no known workarounds for this issue."
7346,"zfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,
cred_t *cr, zfs_fuid_type_t type)
{
#ifdef HAVE_KSID
uint32_t index = FUID_INDEX(fuid);
const char *domain;
uid_t id;

if (index == 0)
return (fuid);

domain = zfs_fuid_find_by_idx(zfsvfs, index);
ASSERT(domain != NULL);

if (type == ZFS_OWNER || type == ZFS_ACE_USER) {
(void) kidmap_getuidbysid(crgetzone(cr), domain,
FUID_RID(fuid), &id);
} else {
(void) kidmap_getgidbysid(crgetzone(cr), domain,
FUID_RID(fuid), &id);
}
return (id);
#else



return (fuid);
#endif /* HAVE_KSID */
}","[4, 23, 27, 28]","OpenZFS before 2.0.0-rc1, when used on FreeBSD, allows execute permissions for all directories."
200642," static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
 {
 	unsigned long val;
 	void *ptr = NULL;
 
 	if (!atomic_pool) {
 		WARN(1, ""coherent pool not initialised!\n"");
 		return NULL;
 	}
 
 	val = gen_pool_alloc(atomic_pool, size);
 	if (val) {
 		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
  
  		*ret_page = phys_to_page(phys);
  		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 		memset(ptr, 0, size);
  	}
  
  	return ptr;
 }","[19, 17, 18]","arch/arm64/mm/dma-mapping.c in the Linux kernel before 4.0.3, as used in the ION subsystem in Android and other products, does not initialize certain data structures, which allows local users to obtain sensitive information from kernel memory by triggering a dma_mmap call."
201302," static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,
 	netdev_features_t features)
 {
 	struct sk_buff *segs = ERR_PTR(-EINVAL);
 	struct ipv6hdr *ipv6h;
 	const struct net_offload *ops;
 	int proto;
 	struct frag_hdr *fptr;
 	unsigned int unfrag_ip6hlen;
 	unsigned int payload_len;
 	u8 *prevhdr;
 	int offset = 0;
 	bool encap, udpfrag;
 	int nhoff;
 	bool gso_partial;
 
 	skb_reset_network_header(skb);
 	nhoff = skb_network_header(skb) - skb_mac_header(skb);
 	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
 		goto out;
 
 	encap = SKB_GSO_CB(skb)->encap_level > 0;
 	if (encap)
 		features &= skb->dev->hw_enc_features;
 	SKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);
 
 	ipv6h = ipv6_hdr(skb);
 	__skb_pull(skb, sizeof(*ipv6h));
 	segs = ERR_PTR(-EPROTONOSUPPORT);
 
 	proto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);
 
 	if (skb->encapsulation &&
 	    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))
 		udpfrag = proto == IPPROTO_UDP && encap;
 	else
 		udpfrag = proto == IPPROTO_UDP && !skb->encapsulation;
 
 	ops = rcu_dereference(inet6_offloads[proto]);
 	if (likely(ops && ops->callbacks.gso_segment)) {
 		skb_reset_transport_header(skb);
 		segs = ops->callbacks.gso_segment(skb, features);
 	}
 
 	if (IS_ERR_OR_NULL(segs))
 		goto out;
 
 	gso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);
 
 	for (skb = segs; skb; skb = skb->next) {
 		ipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);
 		if (gso_partial)
 			payload_len = skb_shinfo(skb)->gso_size +
 				      SKB_GSO_CB(skb)->data_offset +
 				      skb->head - (unsigned char *)(ipv6h + 1);
 		else
 			payload_len = skb->len - nhoff - sizeof(*ipv6h);
 		ipv6h->payload_len = htons(payload_len);
 		skb->network_header = (u8 *)ipv6h - skb->head;
  
  		if (udpfrag) {
  			unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);
 			if (unfrag_ip6hlen < 0)
 				return ERR_PTR(unfrag_ip6hlen);
  			fptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);
  			fptr->frag_off = htons(offset);
  			if (skb->next)
 				fptr->frag_off |= htons(IP6_MF);
 			offset += (ntohs(ipv6h->payload_len) -
 				   sizeof(struct frag_hdr));
 		}
 		if (encap)
 			skb_reset_inner_headers(skb);
 	}
 
 out:
 	return segs;
 }","[63, 64]","The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls."
7469,"PackLinuxElf64::canPack()
{
union {
unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];

} u;
COMPILE_TIME_ASSERT(sizeof(u) <= 1024)

fi->readx(u.buf, sizeof(u.buf));
fi->seek(0, SEEK_SET);
Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;


if (checkEhdr(ehdr) != 0)
return false;


if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {
throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'"");
return false;
}
if (e_phoff != sizeof(*ehdr)) {
throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'"");
return false;
}


Elf64_Phdr const *phdr = phdri;
for (unsigned j=0; j < e_phnum; ++phdr, ++j) {
if (j >= 14) {
throwCantPack(""too many ElfXX_Phdr; try '--force-execve'"");
return false;
}
unsigned const p_type = get_te32(&phdr->p_type);
if (1!=exetype && PT_LOAD64 == p_type) {
exetype = 1;
load_va = get_te64(&phdr->p_vaddr);
upx_uint64_t const p_offset = get_te64(&phdr->p_offset);
upx_uint64_t const off = ~page_mask & load_va;
if (off && off == p_offset) {
throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'"");

return false;
}
if (0 != p_offset) {
throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'"");
return false;
}
hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));
break;
}
}














if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {

alloc_file_image(file_image, file_size);
fi->seek(0, SEEK_SET);
fi->readx(file_image, file_size);
memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));
phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);
shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);

sec_strndx = NULL;
shstrtab = NULL;
if (e_shnum) {
unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);
if (e_shstrndx) {
if (e_shnum <= e_shstrndx) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
sec_strndx = &shdri[e_shstrndx];
upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset);
if ((u64_t)file_size <= sh_offset) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset);
throwCantPack(msg);
}
shstrtab = (char const *)(sh_offset + file_image);
}
sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link);
if (e_shnum <= sh_link) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link);
}
sec_dynstr = &shdri[sh_link];
}

if (sec_strndx) {
unsigned const sh_name = get_te32(&sec_strndx->sh_name);
if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)
|| (u32_t)file_size <= sh_name
|| (sh_name
&& 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name]))
) {
throwCantPack(""bad e_shstrndx"");
}
}
}

Elf64_Phdr const *pload_x0(0);
phdr= phdri;
for (int j= e_phnum; --j>=0; ++phdr)
if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);
invert_pt_dynamic(dynseg);
}
else if (PT_LOAD64==get_te32(&phdr->p_type)) {
if (!pload_x0
&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)
) {
pload_x0 = phdr;
}
check_pt_load(phdr);
}

dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);
dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);

if (opt->o_unix.force_pie
||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)
||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),
(int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))
||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),
(int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {
is_pie = true;
goto proceed;
}













if (elf_find_dynamic(upx_dt_init)) {
if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {
throwCantPack(""DT_TEXTREL found; re-compile with -fPIC"");
goto abandon;
}
if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) {

if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  !opt->o_unix.android_shlib
) {
opt->info_mode++;
info(""note: use --android-shlib if appropriate"");
opt->info_mode--;
}
}
Elf64_Shdr const *shdr = shdri;
xct_va = ~0ull;
if (e_shnum) {
for (int j= e_shnum; --j>=0; ++shdr) {
unsigned const sh_type = get_te32(&shdr->sh_type);
if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {
xct_va = umin(xct_va, get_te64(&shdr->sh_addr));
}

if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init
&&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)
||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init
&&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {
unsigned user_init_ava = get_te32(&shdr->sh_addr);
user_init_off = get_te64(&shdr->sh_offset);
if ((u64_t)file_size <= user_init_off) {
char msg[70]; snprintf(msg, sizeof(msg),
""bad Elf64_Shdr[%d].sh_offset %#x"",
-1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}



int z_rel = dt_table[Elf64_Dyn::DT_RELA];
int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ];
if (z_rel && z_rsz) {
unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val);
Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off];
unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val);
Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp);
for (; rp < last; ++rp) {
unsigned r_va = get_te64(&rp->r_offset);
if (r_va == user_init_ava) {
unsigned r_info = get_te64(&rp->r_info);
unsigned r_type = ELF64_R_TYPE(r_info);
if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  R_AARCH64_RELATIVE == r_type) {
user_init_va = get_te64(&rp->r_addend);
}
else if (Elf64_Ehdr::EM_AARCH64 == e_machine
&&  R_AARCH64_ABS64 == r_type) {
user_init_va = get_te64(&file_image[user_init_off]);
}
else {
char msg[50]; snprintf(msg, sizeof(msg),
""bad relocation %#x DT_INIT_ARRAY[0]"",
r_info);
throwCantPack(msg);
}
break;
}
}
}
unsigned const p_filesz = get_te64(&pload_x0->p_filesz);
if (!((user_init_va - xct_va) < p_filesz)) {

if (0==user_init_va && opt->o_unix.android_shlib) {

upx_dt_init = 0;

}
else {
char msg[70]; snprintf(msg, sizeof(msg),
""bad init address %#x in Elf64_Shdr[%d].%#x\n"",
(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
}
}


if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)
&&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {
unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);
Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];
for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {
if (upx_dt_init == get_te64(&dynp->d_tag)) {
break;
}
}
if ((1+ dynp) < (n+ dynseg)) {
user_init_va = get_te64(&dynp->d_val);
set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);
user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];
}
}
}
}
else {
upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);
upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);
upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);
upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);
upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);
if ((init == (relsz + rel   ) && rel    == (strsz + strtab))
||  (init == (strsz + strtab) && strtab == (relsz + rel   ))
) {
xct_va = init;
user_init_va = init;
user_init_off = elf_get_offset_from_address(init);
}
}

upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);
upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);
unsigned y = 0;
if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))
||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))
||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))
||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))
||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))
||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))
||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))
||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))
||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {
static char const *which[] = {
""unknown"",
""DT_GNU_HASH"",
""DT_HASH"",
""DT_STRTAB"",
""DT_SYMTAB"",
""DT_REL"",
""DT_RELA"",
""DT_JMPREL"",
""DT_VERDEF"",
""DT_VERSYM"",
""DT_VERNEEDED"",
};
char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]);
throwCantPack(buf);
goto abandon;
}
if (!opt->o_unix.android_shlib) {
phdr = phdri;
for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {
upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);
if (PT_NOTE64 == get_te32(&phdr->p_type)
&& xct_va < vaddr) {
char buf[40]; snprintf(buf, sizeof(buf),
""PT_NOTE %#lx above stub"", (unsigned long)vaddr);
throwCantPack(buf);
goto abandon;
}
}
}
xct_off = elf_get_offset_from_address(xct_va);
if (opt->debug.debug_level) {
fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"",
(long)xct_va, (long)xct_off);
}
goto proceed;
}
else
throwCantPack(""need DT_INIT; try \""void _init(void){}\"""");
abandon:
return false;
proceed: ;
}


if (!super::canPack())
return false;
assert(exetype == 1);
exetype = 0;


opt->o_unix.blocksize = blocksize = file_size;
return true;
}","[108, 112]",An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service.
199791," void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,
			int length, int offset, int total_size)
 void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,
 			u8 length, u16 offset, u16 total_size)
  {
  	struct oz_port *port = hport;
  	struct urb *urb;
 	int err = 0;
 
 	oz_dbg(ON, ""oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\n"",
 	       length, offset, total_size);
 	urb = oz_find_urb_by_id(port, 0, req_id);
  	if (!urb)
  		return;
  	if (status == 0) {
		int copy_len;
		int required_size = urb->transfer_buffer_length;
 		unsigned int copy_len;
 		unsigned int required_size = urb->transfer_buffer_length;
  
  		if (required_size > total_size)
  			required_size = total_size;
 		copy_len = required_size-offset;
 		if (length <= copy_len)
 			copy_len = length;
 		memcpy(urb->transfer_buffer+offset, desc, copy_len);
 		offset += copy_len;
 		if (offset < required_size) {
 			struct usb_ctrlrequest *setup =
 				(struct usb_ctrlrequest *)urb->setup_packet;
 			unsigned wvalue = le16_to_cpu(setup->wValue);
 
 			if (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))
 				err = -ENOMEM;
 			else if (oz_usb_get_desc_req(port->hpd, req_id,
 					setup->bRequestType, (u8)(wvalue>>8),
 					(u8)wvalue, setup->wIndex, offset,
 					required_size-offset)) {
 				oz_dequeue_ep_urb(port, 0, 0, urb);
 				err = -ENOMEM;
 			}
 			if (err == 0)
 				return;
 		}
 	}
 	urb->actual_length = total_size;
 	oz_complete_urb(port->ozhcd->hcd, urb, 0);
 }","[3, 4, 18, 19, 2, 16, 17]",Integer signedness error in the oz_hcd_get_desc_cnf function in drivers/staging/ozwpan/ozhcd.c in the OZWPAN driver in the Linux kernel through 4.0.5 allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a crafted packet.
7832,"void Compute(OpKernelContext* context) override {
OpInputList indices_list_in;
OP_REQUIRES_OK(context, context->input_list(""indices"", &indices_list_in));
OpInputList values_list_in;
OP_REQUIRES_OK(context, context->input_list(""values"", &values_list_in));
OpInputList shapes_list_in;
OP_REQUIRES_OK(context, context->input_list(""shapes"", &shapes_list_in));
OpInputList dense_list_in;
OP_REQUIRES_OK(context,
context->input_list(""dense_inputs"", &dense_list_in));

OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,
shapes_list_in, dense_list_in));

const Tensor* num_buckets_t;
OP_REQUIRES_OK(context, context->input(""num_buckets"", &num_buckets_t));
const int64 num_buckets = num_buckets_t->scalar<int64>()();

const Tensor* strong_hash_t;
OP_REQUIRES_OK(context, context->input(""strong_hash"", &strong_hash_t));
const bool strong_hash = strong_hash_t->scalar<bool>()();

const Tensor* salt_t;
OP_REQUIRES_OK(context, context->input(""salt"", &salt_t));
const auto salt = salt_t->flat<int64>();
std::vector<int64> key_{salt(0), salt(1)};

std::vector<std::unique_ptr<ColumnInterface<int64>>> columns =
GenerateKeyedColumnsFromInput<int64>(indices_list_in, values_list_in,
shapes_list_in, dense_list_in,
key_);
Tensor* indices_out;
Tensor* values_out;
Tensor* shape_out;
const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);
std::vector<int64> output_start_indices(batch_size);
OP_REQUIRES_OK(
context,
CreateOutputTensors(columns, batch_size, context, &indices_out,
&values_out, &shape_out, &output_start_indices));
const tstring unused_sep;
HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);
OutputUpdater<int64> updater(output_start_indices, indices_out, values_out);
auto do_work = [&columns, crosser, updater, strong_hash](int64 begin,
int64 end) {
for (int b = begin; b < end; b++) {
ProductIterator<int64> product_iterator(columns, b);
int64 cross_count = 0;
while (product_iterator.HasNext()) {
const auto permutation = product_iterator.Next();
updater.Update(b, cross_count,
crosser.Generate(b, permutation, strong_hash));
cross_count++;
}
}
};

auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();

const int kCostPerUnit = 5000 * indices_list_in.size();
Shard(worker_threads->num_threads, worker_threads->workers, batch_size,
kCostPerUnit, do_work);
}","[12, 13]","TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
207865," long VideoTrack::Parse(Segment* pSegment, const Info& info,
  long long element_start, long long element_size,
  VideoTrack*& pResult) {
  if (pResult)
  return -1;
 
  if (info.type != Track::kVideo)
  return -1;
 
  
    long long width = 0;
    long long height = 0;
   long long display_width = 0;
   long long display_height = 0;
   long long display_unit = 0;
   long long stereo_mode = 0;
 
    double rate = 0.0;
  
    IMkvReader* const pReader = pSegment->m_pReader;
 
  const Settings& s = info.settings;
   assert(s.start >= 0);
   assert(s.size >= 0);
 
  long long pos = s.start;
   assert(pos >= 0);
 
  const long long stop = pos + s.size;
 
  while (pos < stop) {
  long long id, size;
 
  const long status = ParseElementHeader(pReader, pos, stop, id, size);
 
  if (status < 0)  
  return status;
 
  if (id == 0x30) {  
       width = UnserializeUInt(pReader, pos, size);
 
  if (width <= 0)
  return E_FILE_FORMAT_INVALID;
  } else if (id == 0x3A) {  
       height = UnserializeUInt(pReader, pos, size);
 
  
        if (height <= 0)
          return E_FILE_FORMAT_INVALID;
     } else if (id == 0x14B0) {   
       display_width = UnserializeUInt(pReader, pos, size);
 
       if (display_width <= 0)
         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x14BA) {   
       display_height = UnserializeUInt(pReader, pos, size);
 
       if (display_height <= 0)
         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x14B2) {   
       display_unit = UnserializeUInt(pReader, pos, size);
 
       if (display_unit < 0)
         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x13B8) {   
       stereo_mode = UnserializeUInt(pReader, pos, size);
 
       if (stereo_mode < 0)
         return E_FILE_FORMAT_INVALID;
      } else if (id == 0x0383E3) {   
        const long status = UnserializeFloat(pReader, pos, size, rate);
  
  if (status < 0)
  return status;
 
  if (rate <= 0)
  return E_FILE_FORMAT_INVALID;
 
      }
  
      pos += size;   
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
  assert(pos == stop);
   if (pos != stop)
     return E_FILE_FORMAT_INVALID;
  
    VideoTrack* const pTrack =
        new (std::nothrow) VideoTrack(pSegment, element_start, element_size);
 
  if (pTrack == NULL)
  return -1;  
 
  const int status = info.Copy(pTrack->m_info);
 
  if (status) {  
  delete pTrack;
  return status;
  }
 
  
    pTrack->m_width = width;
    pTrack->m_height = height;
   pTrack->m_display_width = display_width;
   pTrack->m_display_height = display_height;
   pTrack->m_display_unit = display_unit;
   pTrack->m_stereo_mode = stereo_mode;
    pTrack->m_rate = rate;
  
    pResult = pTrack;
  return 0;  
 }","[13, 14, 15, 16, 17, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 83, 84, 88, 89, 107, 108, 109, 110, 82, 87]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
198580,"  static int bdrv_check_request(BlockDriverState *bs, int64_t sector_num,
                                int nb_sectors)
  {
     if (nb_sectors > INT_MAX / BDRV_SECTOR_SIZE) {
         return -EIO;
     }
 
      return bdrv_check_byte_request(bs, sector_num * BDRV_SECTOR_SIZE,
                                     nb_sectors * BDRV_SECTOR_SIZE);
  }","[4, 5, 6, 7]","Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes."
1503,"static bool extractFileTo(zip* zip, const std::string &file, std::string& to,
char* buf, size_t len) {
auto sep = file.rfind('/');
if (sep != std::string::npos) {
auto path = to + file.substr(0, sep);
if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {
return false;
}

if (sep == file.length() - 1) {
return true;
}
}

to.append(file);
struct zip_stat zipStat;
if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {
return false;
}

auto zipFile = zip_fopen_index(zip, zipStat.index, 0);
FAIL_IF_INVALID_PTR(zipFile);

auto outFile = fopen(to.c_str(), ""wb"");
if (outFile == nullptr) {
zip_fclose(zipFile);
return false;
}

for (auto n = zip_fread(zipFile, buf, len); n != 0;
n = zip_fread(zipFile, buf, len)) {
if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {
zip_fclose(zipFile);
fclose(outFile);
remove(to.c_str());
return false;
}
}

zip_fclose(zipFile);
if (fclose(outFile) != 0) {
return false;
}

return true;
}","[3, 5, 10, 15, 15, 16, 17, 18]","Directory traversal vulnerability in the ZipArchive::extractTo function in ext/zip/php_zip.c in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 and ext/zip/ext_zip.cpp in HHVM before 3.12.1 allows remote attackers to create arbitrary empty directories via a crafted ZIP archive."
207355," void InputConnectionImpl::CommitText(const base::string16& text,
                                      int new_cursor_pos) {
   StartStateUpdateTimer();
 
   std::string error;
   if (!ime_engine_->ClearComposition(input_context_id_, &error))
     LOG(ERROR) << ""ClearComposition failed: error=\"""" << error << ""\"""";
 
   if (IsControlChar(text)) {
     SendControlKeyEvent(text);
     return;
   }
 
    if (!ime_engine_->CommitText(input_context_id_,
                                 base::UTF16ToUTF8(text).c_str(), &error))
      LOG(ERROR) << ""CommitText failed: error=\"""" << error << ""\"""";
   composing_text_.clear();
  }",[17],"The CPDF_DIBSource::CreateDecoder function in core/fpdfapi/fpdf_render/fpdf_render_loadimage.cpp in PDFium, as used in Google Chrome before 51.0.2704.63, mishandles decoder-initialization failure, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document."
204277," AudioOutputDevice::AudioOutputDevice(
     AudioOutputIPC* ipc,
     const scoped_refptr<base::MessageLoopProxy>& io_loop)
     : ScopedLoopObserver(io_loop),
       input_channels_(0),
       callback_(NULL),
        ipc_(ipc),
        stream_id_(0),
        play_on_start_(true),
      is_started_(false),
      audio_thread_(new AudioDeviceThread()) {
       is_started_(false) {
    CHECK(ipc_);
  }","[12, 10, 11]",Race condition in Google Chrome before 22.0.1229.92 allows remote attackers to execute arbitrary code via vectors related to audio devices.
198766," int hugetlb_reserve_pages(struct inode *inode,
 					long from, long to,
 					struct vm_area_struct *vma,
 					vm_flags_t vm_flags)
 {
 	long ret, chg;
 	struct hstate *h = hstate_inode(inode);
 	struct hugepage_subpool *spool = subpool_inode(inode);
 
 	 
 	if (vm_flags & VM_NORESERVE)
 		return 0;
 
 	 
 	if (!vma || vma->vm_flags & VM_MAYSHARE)
 		chg = region_chg(&inode->i_mapping->private_list, from, to);
 	else {
 		struct resv_map *resv_map = resv_map_alloc();
 		if (!resv_map)
 			return -ENOMEM;
 
 		chg = to - from;
 
 		set_vma_resv_map(vma, resv_map);
  		set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
  	}
  
	if (chg < 0)
		return chg;
 	if (chg < 0) {
 		ret = chg;
 		goto out_err;
 	}
  
  	 
	if (hugepage_subpool_get_pages(spool, chg))
		return -ENOSPC;
 	if (hugepage_subpool_get_pages(spool, chg)) {
 		ret = -ENOSPC;
 		goto out_err;
 	}
  
  	 
  	ret = hugetlb_acct_memory(h, chg);
  	if (ret < 0) {
  		hugepage_subpool_put_pages(spool, chg);
		return ret;
 		goto out_err;
  	}
  
  	 
  	if (!vma || vma->vm_flags & VM_MAYSHARE)
  		region_add(&inode->i_mapping->private_list, from, to);
  	return 0;
 out_err:
 	resv_map_put(vma);
 	return ret;
  }","[30, 31, 32, 33, 38, 39, 40, 41, 48, 55, 56, 57, 28, 29, 36, 37, 47]",Memory leak in mm/hugetlb.c in the Linux kernel before 3.4.2 allows local users to cause a denial of service (memory consumption or system crash) via invalid MAP_HUGETLB mmap operations.
206107,"    StatisticsRecorderTest() : use_persistent_histogram_allocator_(GetParam()) {
    PersistentHistogramAllocator::GetCreateHistogramResultHistogram();
      InitializeStatisticsRecorder();
 
     if (use_persistent_histogram_allocator_) {
       GlobalHistogramAllocator::CreateWithLocalMemory(kAllocatorMemorySize, 0,
                                                       ""StatisticsRecorderTest"");
     }
   }",[2],"The Extensions subsystem in Google Chrome before 49.0.2623.75 does not properly maintain own properties, which allows remote attackers to bypass intended access restrictions via crafted JavaScript code that triggers an incorrect cast, related to extensions/renderer/v8_helpers.h and gin/converter.h."
205740," ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(Navigator& navigator, ExceptionState& exceptionState)
 ServiceWorkerContainer* NavigatorServiceWorker::serviceWorker(ExecutionContext* executionContext, Navigator& navigator, ExceptionState& exceptionState)
  {
     ASSERT(!navigator.frame() || executionContext->securityOrigin()->canAccessCheckSuborigins(navigator.frame()->securityContext()->securityOrigin()));
      return NavigatorServiceWorker::from(navigator).serviceWorker(exceptionState);
  }","[2, 4]","The NavigatorServiceWorker::serviceWorker function in modules/serviceworkers/NavigatorServiceWorker.cpp in Blink, as used in Google Chrome before 45.0.2454.85, allows remote attackers to bypass the Same Origin Policy by accessing a Service Worker."
201461," static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)
 {
 	char *colon;
  	char *host = NULL;
  
  #ifdef HAVE_IPV6
	char *p;
  	if (*(str) == '[' && str_len > 1) {
  		 
		p = memchr(str + 1, ']', str_len - 2);
 		char *p = memchr(str + 1, ']', str_len - 2), *e = NULL;
  		if (!p || *(p + 1) != ':') {
  			if (get_err) {
  				*err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str);
  			}
  			return NULL;
  		}
		*portno = atoi(p + 2);
 		*portno = strtol(p + 2, &e, 10);
 		if (e && *e) {
 			if (get_err) {
 				*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
 			}
 			return NULL;
 		}
  		return estrndup(str + 1, p - str - 1);
  	}
  #endif
 
  	if (str_len) {
  		colon = memchr(str, ':', str_len - 1);
  	} else {
  		colon = NULL;
  	}
 
  	if (colon) {
		*portno = atoi(colon + 1);
		host = estrndup(str, colon - str);
	} else {
		if (get_err) {
			*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
 		char *e = NULL;
 		*portno = strtol(colon + 1, &e, 10);
 		if (!e || !*e) {
 			return estrndup(str, colon - str);
  		}
		return NULL;
  	}
  
	return host;
 	if (get_err) {
 		*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
 	}
 	return NULL;
  }","[11, 19, 20, 21, 22, 23, 24, 25, 29, 35, 42, 43, 44, 45, 51, 52, 53, 54, 7, 10, 18, 37, 38, 39, 40, 41, 47, 50]","PHP through 7.1.11 enables potential SSRF in applications that accept an fsockopen or pfsockopen hostname argument with an expectation that the port number is constrained. Because a :port syntax is recognized, fsockopen will use the port number that is specified in the hostname argument, instead of the port number in the second argument of the function."
203279," static int timer_start(Unit *u) {
         Timer *t = TIMER(u);
         TimerValue *v;
 
         assert(t);
         assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);
 
         if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)
                 return -ENOENT;
 
         t->last_trigger = DUAL_TIMESTAMP_NULL;
 
          
         LIST_FOREACH(value, v, t->values)
                 if (v->base == TIMER_ACTIVE)
                         v->disabled = false;
 
         if (t->stamp_path) {
                 struct stat st;
 
                 if (stat(t->stamp_path, &st) >= 0)
                         t->last_trigger.realtime = timespec_load(&st.st_atim);
                 else if (errno == ENOENT)
                           
                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);
                         touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);
          }
  
          t->result = TIMER_SUCCESS;
         timer_enter_waiting(t, true);
         return 1;
 }","[26, 25]","A flaw in systemd v228 in /src/basic/fs-util.c caused world writable suid files to be created when using the systemd timers features, allowing local attackers to escalate their privileges to root. This is fixed in v229."
9710,"void Compute(OpKernelContext* ctx) override {
const Tensor& handle = ctx->input(0);
const string& name = handle.scalar<tstring>()();
Tensor val;
auto session_state = ctx->session_state();
OP_REQUIRES(ctx, session_state != nullptr,
errors::FailedPrecondition(
""GetSessionTensor called on null session state""));
OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));
ctx->set_output(0, val);
}",[3],"TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.GetSessionTensor` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."
207836," const BlockEntry* Segment::GetBlock(const CuePoint& cp,
  const CuePoint::TrackPosition& tp) {
  Cluster** const ii = m_clusters;
  Cluster** i = ii;
 
  const long count = m_clusterCount + m_clusterPreloadCount;
 
  Cluster** const jj = ii + count;
  Cluster** j = jj;
 
  while (i < j) {
 
  Cluster** const k = i + (j - i) / 2;
     assert(k < jj);
 
  Cluster* const pCluster = *k;
     assert(pCluster);
 
 
  const long long pos = pCluster->GetPosition();
     assert(pos >= 0);
 
  if (pos < tp.m_pos)
       i = k + 1;
  else if (pos > tp.m_pos)
       j = k;
  else
  return pCluster->GetEntry(cp, tp);
  }
 
   assert(i == j);
 
  
    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);   
  assert(pCluster);
   if (pCluster == NULL)
     return NULL;
  
    const ptrdiff_t idx = i - m_clusters;
  
  PreloadCluster(pCluster, idx);
   if (!PreloadCluster(pCluster, idx)) {
     delete pCluster;
     return NULL;
   }
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);
 
  return pCluster->GetEntry(cp, tp);
 }","[36, 37, 42, 43, 44, 45, 35, 41]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
200167," MagickExport MagickBooleanType ContrastStretchImage(Image *image,
   const double black_point,const double white_point,ExceptionInfo *exception)
 {
 #define MaxRange(color)  ((double) ScaleQuantumToMap((Quantum) (color)))
 #define ContrastStretchImageTag  ""ContrastStretch/Image""
 
   CacheView
     *image_view;
 
   double
     *black,
     *histogram,
     *stretch_map,
     *white;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     progress;
 
   register ssize_t
     i;
 
   ssize_t
     y;
 
    
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
      (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
    if (SetImageGray(image,exception) != MagickFalse)
      (void) SetImageColorspace(image,GRAYColorspace,exception);
   if (SyncImagePixelCache(image,exception) == MagickFalse)
     return(MagickFalse);
    black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));
    white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));
    histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*
     sizeof(*histogram));
   stretch_map=(double *) AcquireQuantumMemory(MaxMap+1UL,
     GetPixelChannels(image)*sizeof(*stretch_map));
   if ((black == (double *) NULL) || (white == (double *) NULL) ||
       (histogram == (double *) NULL) || (stretch_map == (double *) NULL))
     {
       if (stretch_map != (double *) NULL)
         stretch_map=(double *) RelinquishMagickMemory(stretch_map);
       if (histogram != (double *) NULL)
         histogram=(double *) RelinquishMagickMemory(histogram);
       if (white != (double *) NULL)
         white=(double *) RelinquishMagickMemory(white);
       if (black != (double *) NULL)
         black=(double *) RelinquishMagickMemory(black);
       ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
         image->filename);
     }
    
   status=MagickTrue;
   (void) ResetMagickMemory(histogram,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*histogram));
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register const Quantum
       *magick_restrict p;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
     if (p == (const Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       double
         pixel;
 
       pixel=GetPixelIntensity(image,p);
       for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
       {
         if (image->channel_mask != DefaultChannels)
           pixel=(double) p[i];
         histogram[GetPixelChannels(image)*ScaleQuantumToMap(
           ClampToQuantum(pixel))+i]++;
       }
       p+=GetPixelChannels(image);
     }
   }
   image_view=DestroyCacheView(image_view);
    
   for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
   {
     double
       intensity;
 
     register ssize_t
       j;
 
     black[i]=0.0;
     white[i]=MaxRange(QuantumRange);
     intensity=0.0;
     for (j=0; j <= (ssize_t) MaxMap; j++)
     {
       intensity+=histogram[GetPixelChannels(image)*j+i];
       if (intensity > black_point)
         break;
     }
     black[i]=(double) j;
     intensity=0.0;
     for (j=(ssize_t) MaxMap; j != 0; j--)
     {
       intensity+=histogram[GetPixelChannels(image)*j+i];
       if (intensity > ((double) image->columns*image->rows-white_point))
         break;
     }
     white[i]=(double) j;
   }
   histogram=(double *) RelinquishMagickMemory(histogram);
    
   (void) ResetMagickMemory(stretch_map,0,(MaxMap+1)*GetPixelChannels(image)*
     sizeof(*stretch_map));
   for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
   {
     register ssize_t
       j;
 
     for (j=0; j <= (ssize_t) MaxMap; j++)
     {
       double
         gamma;
 
       gamma=PerceptibleReciprocal(white[i]-black[i]);
       if (j < (ssize_t) black[i])
         stretch_map[GetPixelChannels(image)*j+i]=0.0;
       else
         if (j > (ssize_t) white[i])
           stretch_map[GetPixelChannels(image)*j+i]=(double) QuantumRange;
         else
           stretch_map[GetPixelChannels(image)*j+i]=(double) ScaleMapToQuantum(
             (double) (MaxMap*gamma*(j-black[i])));
     }
   }
   if (image->storage_class == PseudoClass)
     {
       register ssize_t
         j;
 
        
       for (j=0; j < (ssize_t) image->colors; j++)
       {
         if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
           {
             i=GetPixelChannelOffset(image,RedPixelChannel);
             image->colormap[j].red=stretch_map[GetPixelChannels(image)*
               ScaleQuantumToMap(ClampToQuantum(image->colormap[j].red))+i];
           }
         if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
           {
             i=GetPixelChannelOffset(image,GreenPixelChannel);
             image->colormap[j].green=stretch_map[GetPixelChannels(image)*
               ScaleQuantumToMap(ClampToQuantum(image->colormap[j].green))+i];
           }
         if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
           {
             i=GetPixelChannelOffset(image,BluePixelChannel);
             image->colormap[j].blue=stretch_map[GetPixelChannels(image)*
               ScaleQuantumToMap(ClampToQuantum(image->colormap[j].blue))+i];
           }
         if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
           {
             i=GetPixelChannelOffset(image,AlphaPixelChannel);
             image->colormap[j].alpha=stretch_map[GetPixelChannels(image)*
               ScaleQuantumToMap(ClampToQuantum(image->colormap[j].alpha))+i];
           }
       }
     }
    
   status=MagickTrue;
   progress=0;
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static,4) shared(progress,status) \
     magick_threads(image,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register Quantum
       *magick_restrict q;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
     if (q == (Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       register ssize_t
         j;
 
       if (GetPixelReadMask(image,q) == 0)
         {
           q+=GetPixelChannels(image);
           continue;
         }
       for (j=0; j < (ssize_t) GetPixelChannels(image); j++)
       {
         PixelChannel channel=GetPixelChannelChannel(image,j);
         PixelTrait traits=GetPixelChannelTraits(image,channel);
         if ((traits & UpdatePixelTrait) == 0)
           continue;
         q[j]=ClampToQuantum(stretch_map[GetPixelChannels(image)*
           ScaleQuantumToMap(q[j])+j]);
       }
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
     if (image->progress_monitor != (MagickProgressMonitor) NULL)
       {
         MagickBooleanType
           proceed;
 
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
         #pragma omp critical (MagickCore_ContrastStretchImage)
 #endif
         proceed=SetImageProgress(image,ContrastStretchImageTag,progress++,
           image->rows);
         if (proceed == MagickFalse)
           status=MagickFalse;
       }
   }
   image_view=DestroyCacheView(image_view);
   stretch_map=(double *) RelinquishMagickMemory(stretch_map);
   white=(double *) RelinquishMagickMemory(white);
   black=(double *) RelinquishMagickMemory(black);
   return(status);
 }","[35, 36]",Buffer overflow in MagickCore/enhance.c in ImageMagick before 7.0.2-7 allows remote attackers to have unspecified impact via vectors related to pixel cache morphology.
197985," static void virtio_gpu_set_scanout(VirtIOGPU *g,
                                    struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_simple_resource *res;
     struct virtio_gpu_scanout *scanout;
     pixman_format_code_t format;
     uint32_t offset;
     int bpp;
     struct virtio_gpu_set_scanout ss;
 
     VIRTIO_GPU_FILL_CMD(ss);
     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);
 
     if (ss.scanout_id >= g->conf.max_outputs) {
         qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout id specified %d"",
                       __func__, ss.scanout_id);
         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
         return;
     }
 
     g->enable = 1;
     if (ss.resource_id == 0) {
         scanout = &g->scanout[ss.scanout_id];
         if (scanout->resource_id) {
             res = virtio_gpu_find_resource(g, scanout->resource_id);
             if (res) {
                 res->scanout_bitmask &= ~(1 << ss.scanout_id);
             }
         }
         if (ss.scanout_id == 0) {
             qemu_log_mask(LOG_GUEST_ERROR,
                           ""%s: illegal scanout id specified %d"",
                           __func__, ss.scanout_id);
             cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;
             return;
         }
         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, NULL);
         scanout->ds = NULL;
         scanout->width = 0;
         scanout->height = 0;
         return;
     }
 
      
     res = virtio_gpu_find_resource(g, ss.resource_id);
     if (!res) {
         qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal resource specified %d\n"",
                       __func__, ss.resource_id);
         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
         return;
     }
 
     if (ss.r.x > res->width ||
         ss.r.y > res->height ||
         ss.r.width > res->width ||
         ss.r.height > res->height ||
         ss.r.x + ss.r.width > res->width ||
         ss.r.y + ss.r.height > res->height) {
         qemu_log_mask(LOG_GUEST_ERROR, ""%s: illegal scanout %d bounds for""
                       "" resource %d, (%d,%d)+%d,%d vs %d %d\n"",
                       __func__, ss.scanout_id, ss.resource_id, ss.r.x, ss.r.y,
                       ss.r.width, ss.r.height, res->width, res->height);
         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
         return;
     }
 
     scanout = &g->scanout[ss.scanout_id];
 
     format = pixman_image_get_format(res->image);
     bpp = (PIXMAN_FORMAT_BPP(format) + 7) / 8;
     offset = (ss.r.x * bpp) + ss.r.y * pixman_image_get_stride(res->image);
     if (!scanout->ds || surface_data(scanout->ds)
         != ((uint8_t *)pixman_image_get_data(res->image) + offset) ||
         scanout->width != ss.r.width ||
         scanout->height != ss.r.height) {
         pixman_image_t *rect;
         void *ptr = (uint8_t *)pixman_image_get_data(res->image) + offset;
         rect = pixman_image_create_bits(format, ss.r.width, ss.r.height, ptr,
                                         pixman_image_get_stride(res->image));
         pixman_image_ref(res->image);
         pixman_image_set_destroy_function(rect, virtio_unref_resource,
                                           res->image);
          
         scanout->ds = qemu_create_displaysurface_pixman(rect);
         if (!scanout->ds) {
              cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
              return;
          }
         pixman_image_unref(rect);
          dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);
      }
     scanout->resource_id = ss.resource_id;
     scanout->x = ss.r.x;
     scanout->y = ss.r.y;
     scanout->width = ss.r.width;
     scanout->height = ss.r.height;
 }",[90],"Memory leak in the virtio_gpu_set_scanout function in hw/display/virtio-gpu.c in QEMU (aka Quick Emulator) allows local guest OS users to cause a denial of service (memory consumption) via a large number of ""VIRTIO_GPU_CMD_SET_SCANOUT:"" commands."
200031," int open_debug_log(void) {
 int open_debug_log(void)
 {
 	int fh;
 	struct stat st;
  
  	 
  	if(verify_config || test_scheduling == TRUE)
 		return OK;
 
 	 
  	if(debug_level == DEBUGL_NONE)
  		return OK;
  
	if((debug_file_fp = fopen(debug_file, ""a+"")) == NULL)
 	if ((fh = open(debug_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1)
 		return ERROR;
 	if((debug_file_fp = fdopen(fh, ""a+"")) == NULL)
 		return ERROR;
 
 	if ((fstat(fh, &st)) == -1) {
 		debug_file_fp = NULL;
 		close(fh);
 		return ERROR;
 	}
 	if (st.st_nlink != 1 || (st.st_mode & S_IFMT) != S_IFREG) {
 		debug_file_fp = NULL;
 		close(fh);
  		return ERROR;
 	}
  
	(void)fcntl(fileno(debug_file_fp), F_SETFD, FD_CLOEXEC);
 	(void)fcntl(fh, F_SETFD, FD_CLOEXEC);
  
  	return OK;
  	}","[2, 3, 4, 5, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 30, 33, 15, 32]",base/logging.c in Nagios Core before 4.2.4 allows local users with access to an account in the nagios group to gain root privileges via a symlink attack on the log file.  NOTE: this can be leveraged by remote attackers using CVE-2016-9565.
7223,"static int jsi_wsHttp(Jsi_Interp *interp, jsi_wsCmdObj *cmdPtr, struct lws *wsi, void *user,
struct lws_context *context, const char* inPtr, Jsi_DString *tStr, jsi_wsPss *pss)
{
const char *ext = NULL;
unsigned char buffer[JSI_BUFSIZ];
const char *mime = NULL;
time_t now = time(NULL);
char buf[JSI_BUFSIZ];
int rc = 0;
buf[0] = 0;
uchar *p = buffer, *end = &buffer[sizeof(buffer)-1];
int n;
Jsi_Value* fname = NULL;
bool isJsiWeb = 0, isSSI = 0;
cmdPtr->stats.httpLast = now;


if (lws_hdr_total_length(wsi, WSI_TOKEN_POST_URI))
return 0;
if (!pss)
pss = jsi_wsgetPss(cmdPtr, wsi, user, 1, 1);

int uplen=(cmdPtr->urlPrefix?Jsi_Strlen(cmdPtr->urlPrefix):0);

if (inPtr && cmdPtr->urlPrefix && !Jsi_Strncmp(inPtr, cmdPtr->urlPrefix, uplen))
inPtr += uplen;

if (cmdPtr->redirDisable) {
if (difftime(now, cmdPtr->stats.redirLast)>=600)
cmdPtr->redirDisable = 0;
else
cmdPtr->redirDisable--;
}

if ((cmdPtr->urlRedirect && (inPtr == 0 || *inPtr == 0 || !Jsi_Strcmp(inPtr, ""/"")) && !cmdPtr->redirDisable)
&& (inPtr = cmdPtr->urlRedirect) && inPtr[0]) {
cmdPtr->stats.redirCnt++;

if (cmdPtr->redirMax>0 && !cmdPtr->redirDisable && cmdPtr->redirMax>0 && cmdPtr->stats.redirLast
&& difftime(now, cmdPtr->stats.redirLast)<600 && ++cmdPtr->redirAllCnt>cmdPtr->redirMax)
cmdPtr->redirDisable = 100;
cmdPtr->stats.redirLast = now;
rc = lws_http_redirect(wsi, 301, (uchar*)inPtr, Jsi_Strlen(inPtr), &p, end);
return (rc == 100 ? 0 : 1);
}
if (!inPtr || !*inPtr)
inPtr = ""/"";

if (cmdPtr->useridPass || cmdPtr->onAuth) {
int ok = 0;
int alen;
const char *auth = jsi_wsHeader(pss, ""authorization"", &alen);
if (auth && !Jsi_Strncasecmp(auth, ""basic "", 6) && !cmdPtr->deleted) {
auth += 6;
Jsi_DString eStr = {}, bStr = {};
Jsi_DSAppendLen(&eStr, auth, alen - 6);
Jsi_Base64(Jsi_DSValue(&eStr), -1, &bStr, 1);
const char *bp = Jsi_DSValue(&bStr);
if (bp && bp[0]) {
if (!cmdPtr->onAuth)
ok = (!Jsi_Strcmp(cmdPtr->useridPass, bp));
else {

Jsi_Obj *oarg1;
Jsi_Value *vpargs, *vargs[10];
int n = 0;
vargs[n++] = Jsi_ValueNewObj(interp, cmdPtr->fobj);
vargs[n++] = Jsi_ValueNewNumber(interp, (Jsi_Number)(pss->wid));
vargs[n++] = Jsi_ValueNewStringDup(interp, inPtr);
vargs[n++] = Jsi_ValueNewStringDup(interp, bp);
vpargs = Jsi_ValueMakeObject(interp, NULL, oarg1 = Jsi_ObjNewArray(interp, vargs, n, 0));
Jsi_IncrRefCount(interp, vpargs);
Jsi_Value *ret = Jsi_ValueNew1(interp);
bool rb = 0;
rc = Jsi_FunctionInvoke(interp, cmdPtr->onAuth, vpargs, &ret, NULL);
if (rc == JSI_OK)
rb = !Jsi_ValueIsFalse(interp, ret);

Jsi_DecrRefCount(interp, vpargs);
Jsi_DecrRefCount(interp, ret);

if (rc != JSI_OK) {
Jsi_LogError(""websock bad rcv eval"");
return -1;
}
ok = rb;
}
}
Jsi_DSFree(&eStr);
Jsi_DSFree(&bStr);
}
if (!ok) {
const char *realm = (cmdPtr->realm?cmdPtr->realm:""jsish"");
int n = snprintf(buf, sizeof(buf), ""Basic realm=\""%s\"""", realm);
if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_WWW_AUTHENTICATE,
(unsigned char *)buf, n, &p, end))
return -1;
if (jsi_wsServeString(pss, wsi, ""Password is required to access this page"", 401, (char*)buffer, NULL)<0)
return -1;
return lws_http_transaction_completed(wsi);
}
}

if (cmdPtr->onGet || pss->onGet) {
Jsi_RC jrc;
int rrv = 1;
if (cmdPtr->getRegexp) {
rrv = 0;
jrc = Jsi_RegExpMatch(interp, cmdPtr->getRegexp, inPtr, &rrv, NULL);
if (jrc != JSI_OK)
return -1;
}
if (rrv) {
jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, pss->onGet?pss->onGet:cmdPtr->onGet, tStr);
switch (jrc) {
case JSI_ERROR: return -1;
case JSI_OK: return 0;
case JSI_SIGNAL:
return jsi_ws_http_redirect(wsi, 302, tStr, &p, end);
case JSI_CONTINUE:
inPtr = Jsi_DSValue(tStr); break;
case JSI_BREAK: break;
default: break;
}
}
}
ext = Jsi_Strrchr(inPtr, '.');

Jsi_Value *rdir = (pss->rootdir?pss->rootdir:cmdPtr->rootdir);
cmdPtr->curRoot = (rdir?Jsi_ValueString(cmdPtr->interp, rdir, NULL):""./"");
Jsi_DString sStr;
Jsi_DSInit(&sStr);
jsi_wsPathAlias(interp, cmdPtr, &inPtr, &sStr);

snprintf(buf, sizeof(buf), ""%s/%s"", cmdPtr->curRoot, inPtr);
Jsi_DSFree(&sStr);
if (cmdPtr->debug>1)
fprintf(stderr, ""FILE: %s in %s | %s\n"", buf, cmdPtr->curRoot, Jsi_ValueString(interp, cmdPtr->rootdir, NULL));
char extBuf[100], *cpde = Jsi_Strrchr(buf, '/');
isJsiWeb = (cpde && cmdPtr->jsiFnPattern && Jsi_GlobMatch(cmdPtr->jsiFnPattern, cpde+1, 0));
bool isgzip = 0;
if (!ext || !ext[1])
mime = ""text/html"";
else {
const char *eext = ext+1;
uint elen = Jsi_Strlen(ext);
if (elen>3 && elen<(sizeof(extBuf)-10) && !Jsi_Strcmp(ext+elen-3,"".gz"")) {
Jsi_Strcpy(extBuf, ext);
extBuf[elen-3] = 0;
char *ext2 = Jsi_Strrchr(extBuf, '.');
if (ext2) {
isgzip = 1;
ext = ext2;
}
}
Jsi_HashEntry *hPtr;

if (cmdPtr->mimeTypes) {

Jsi_Value *mVal = Jsi_ValueObjLookup(interp, cmdPtr->mimeTypes, ext+1, 1);
if (mVal)
mime = Jsi_ValueString(interp, mVal, NULL);
}
if (!mime) {
static const char* mtypes[] = {
""html"", ""text/html"", ""js"", ""application/x-javascript"",
""css"", ""text/css"", ""png"", ""image/png"", ""ico"", ""image/icon"",
""gif"", ""image/gif"", ""jpeg"", ""image/jpeg"",
""jpg"", ""image/jpeg"", ""svg"", ""image/svg+xml"",
""json"", ""application/json"", ""txt"", ""text/plain"",
""jsi"", ""application/x-javascript"", ""cssi"", ""text/css"",
""shtml"", ""text/html"",  ""scss"", ""text/css"",
""sjs"", ""application/x-javascript"",
0, 0
};
mime = ""text/html"";
int i;
for (i=0; mtypes[i]; i+=2)
if (tolower(*eext) == mtypes[i][0] && !Jsi_Strncasecmp(eext, mtypes[i], -1)) {
mime = mtypes[i+1];
break;
}
}

isSSI = jsi_wsIsSSIExt(interp, cmdPtr, pss, eext);

if ((hPtr = Jsi_HashEntryFind(cmdPtr->handlers, ext)) && !cmdPtr->deleted) {

Jsi_DString jStr = {};
Jsi_Value *vrc = NULL;
int hrc = 0, strLen, evrc, isalloc=0;
char *vStr, *hstr = NULL;
jsi_wsHander *hdlPtr = (jsi_wsHander*)Jsi_HashValueGet(hPtr);
Jsi_Value *hv = hdlPtr->val;

if (Jsi_Strchr(buf, '\'') || Jsi_Strchr(buf, '\""')) {
jsi_wsServeString(pss, wsi, ""Can not handle quotes in url"", 404, NULL, NULL);
return -1;
}
cmdPtr->handlersPkg=1;


if ((hdlPtr->flags&1) && cmdPtr->handlersPkg && Jsi_ValueIsString(interp, hv)
&& ((hstr = Jsi_ValueString(interp, hv, NULL)))) {
vrc = Jsi_NameLookup(interp, hstr);
if (!vrc) {
Jsi_Number pver = Jsi_PkgRequire(interp, hstr, 0);
if (pver >= 0)
vrc = Jsi_NameLookup(interp, hstr);
}
if (!vrc || !Jsi_ValueIsFunction(interp, vrc)) {
if (vrc)
Jsi_DecrRefCount(interp, vrc);
Jsi_LogError(""Failed to autoload handle: %s"", hstr);
jsi_wsServeString(pss, wsi, ""Failed to autoload handler"", 404, NULL, NULL);
return -1;
}
if (hdlPtr->val)
Jsi_DecrRefCount(interp, hdlPtr->val);
hdlPtr->val = vrc;
Jsi_IncrRefCount(interp, vrc);
hv = vrc;
}

if ((hdlPtr->flags&2) && !hdlPtr->triedLoad && !hdlPtr->objVar && Jsi_ValueIsFunction(interp, hv)) {

hdlPtr->triedLoad = 1;
Jsi_DSAppend(&jStr, ""[null]"", NULL);
Jsi_DSAppend(&jStr, ""]"", NULL);
vrc = Jsi_ValueNew1(interp);
evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);
if (Jsi_InterpGone(interp))
return -1;
if (evrc != JSI_OK || !vrc || !Jsi_ValueIsObjType(interp, vrc, JSI_OT_OBJECT)) {
Jsi_LogError(""Failed to load obj: %s"", hstr);
jsi_wsServeString(pss, wsi, ""Failed to load obj"", 404, NULL, NULL);
return -1;
}
Jsi_Value *fvrc = Jsi_ValueObjLookup(interp, vrc, ""parse"", 0);
if (!fvrc || !Jsi_ValueIsFunction(interp, fvrc)) {
Jsi_LogError(""Failed to find parse: %s"", hstr);
jsi_wsServeString(pss, wsi, ""Failed to find parse"", 404, NULL, NULL);
return -1;
}
hdlPtr->objVar = fvrc;
Jsi_IncrRefCount(interp, fvrc);
hv = vrc;

}

if (hdlPtr->objVar) {
Jsi_DSAppend(&jStr, ""[\"""", buf, ""\""]"", NULL);
vrc = Jsi_ValueNew1(interp);
evrc = Jsi_FunctionInvokeJSON(interp, hdlPtr->objVar, Jsi_DSValue(&jStr), &vrc);
isalloc = 1;
}
else if (Jsi_ValueIsFunction(interp, hv)) {

Jsi_DSAppend(&jStr, ""[\"""", buf, ""\"", {wsName:\"""", Jsi_DSValue(&cmdPtr->cName), ""\"""", ""}]"", NULL);
vrc = Jsi_ValueNew1(interp);
evrc = Jsi_FunctionInvokeJSON(interp, hv, Jsi_DSValue(&jStr), &vrc);
isalloc = 1;
} else {

hstr = Jsi_ValueString(interp, hv, NULL);
Jsi_DSAppend(&jStr, hstr, ""('"", buf, ""');"", NULL);
evrc = Jsi_EvalString(interp, Jsi_DSValue(&jStr), JSI_EVAL_RETURN);
if (evrc == JSI_OK)
vrc = Jsi_InterpResult(interp);
}

if (evrc != JSI_OK) {
Jsi_LogError(""failure in websocket handler"");
} else if ((!vrc) ||
(!(vStr = Jsi_ValueString(interp, vrc, &strLen)))) {
Jsi_LogError(""failed to get result"");
} else {
hrc = jsi_wsServeString(pss, wsi, vStr, 0, NULL, mime);
}
Jsi_DSFree(&jStr);
if (isalloc)
Jsi_DecrRefCount(interp, vrc);
if (hrc<=0)
return -1;
return 1;
}
}
if (!buf[0]) {
if (cmdPtr->debug)
fprintf(stderr, ""empty file: %s\n"", inPtr);
return -1;
}
fname = Jsi_ValueNewStringDup(interp, buf);
Jsi_IncrRefCount(interp, fname);

Jsi_DString hStr = {};
Jsi_StatBuf jsb;
bool native = Jsi_FSNative(interp, fname);
if ((native && Jsi_InterpSafe(interp) && Jsi_InterpAccess(interp, fname, JSI_INTACCESS_READ) != JSI_OK) ||
(Jsi_Stat(interp, fname, &jsb) || jsb.st_size<=0)) {
nofile:
if (cmdPtr->onUnknown || pss->onUnknown) {
Jsi_Value *uk = (pss->onUnknown?pss->onUnknown:cmdPtr->onUnknown);
Jsi_RC jrc = jsi_wsGetCmd(interp, cmdPtr, pss, wsi, inPtr, uk, NULL);
if (jrc == JSI_ERROR)
goto bail;
if (jrc == JSI_OK)
goto done;
}

if (0 && Jsi_Strstr(buf, ""favicon.ico""))
rc = jsi_wsServeString(pss, wsi, ""data:;base64,iVBORw0KGgo="", 200, NULL, ""image/icon"");
else {
const char *cp = Jsi_Strrchr(buf,'/');
if (cp && cp[1]) {
char statPath[PATH_MAX];
snprintf(statPath, sizeof(statPath), ""/zvfs/lib/web%s"", cp);
Jsi_DecrRefCount(interp, fname);
fname = Jsi_ValueNewStringDup(interp, statPath);
Jsi_IncrRefCount(interp, fname);
if (!Jsi_Stat(interp, fname, &jsb) && jsb.st_size>0) {
native = 0;
goto serve;
}
}
if (cmdPtr->noWarn==0 && !Jsi_Strstr(buf, ""favicon.ico""))
fprintf(stderr, ""failed open file for read: %s\n"", buf);
rc = jsi_wsServeString(pss, wsi, ""<b style='color:red'>ERROR: can not serve file!</b>"", 404, NULL, NULL);
}
Jsi_DecrRefCount(interp, fname);
goto done;
}
if (!ext || isSSI)
goto serve;
if (S_ISDIR(jsb.st_mode)) {
if (cmdPtr->noWarn==0)
fprintf(stderr, ""can not serve directory: %s\n"", buf);
rc = jsi_wsServeString(pss, wsi, ""<b style='color:red'>ERROR: can not serve directory!</b>"", 404, NULL, NULL);
Jsi_DecrRefCount(interp, fname);
goto done;
}

serve:
n = 0;















static const char stsStr[] = ""max-age=15768000 ; includeSubDomains"";
if (lws_is_ssl(wsi) && lws_add_http_header_by_name(wsi,
(uchar *) ""Strict-Transport-Security:"",
(uchar *) stsStr,
sizeof(stsStr)-1, &p, (uchar *)buffer + sizeof(buffer)))
goto bail;
n = p - buffer;
if (n>0)
Jsi_DSAppendLen(&hStr, (char*)buffer, n);
p = buffer;

if (isgzip) {
if (lws_add_http_header_by_token(wsi, WSI_TOKEN_HTTP_CONTENT_ENCODING,
(unsigned char *)""gzip"", n, &p, end))
goto bail;
}
if (cmdPtr->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, cmdPtr->headers, &hStr))
goto bail;

if (pss->headers && !jsi_wsAddHeader(interp, cmdPtr, wsi, pss->headers, &hStr))
goto bail;

n = Jsi_DSLength(&hStr);

if (native && !isSSI && !isJsiWeb) {

if (!jsi_wsAddStdHeader(interp, cmdPtr, wsi, &hStr)) {
Jsi_DecrRefCount(interp, fname);
goto bail;
}
int hrc = lws_serve_http_file(wsi, buf, mime, Jsi_DSValue(&hStr), Jsi_DSLength(&hStr));
if (hrc >= 0 && cmdPtr->onModify)
jsi_wsFileAdd(interp, cmdPtr, fname);
Jsi_DecrRefCount(interp, fname);
if (hrc<0) {
if (cmdPtr->noWarn==0)
fprintf(stderr, ""can not serve file (%d): %s\n"", hrc, buf);
goto bail;
} else if (hrc > 0 && lws_http_transaction_completed(wsi))
goto bail;
} else {

Jsi_DString dStr = {}, fStr = {};
if (isSSI)
rc = jsi_wsEvalSSI(interp, cmdPtr, fname, &fStr, 1, pss);
else {
rc = jsi_wsFileRead(interp, fname, &fStr, cmdPtr, pss);
if (isJsiWeb)
Jsi_DSAppend(&fStr, ""\nwindow.jsiWebSocket=true;"", NULL);
}
if (rc != JSI_OK) {
Jsi_DSFree(&fStr);
goto nofile;
}
int hrc = jsi_wsServeHeader(pss, wsi, (int)Jsi_DSLength(&fStr), 200, Jsi_DSValue(&hStr), mime, &dStr);
if (hrc>=0) {
Jsi_DSAppendLen(&dStr, Jsi_DSValue(&fStr), Jsi_DSLength(&fStr));
char *strVal = Jsi_DSValue(&dStr);
int strLen = Jsi_DSLength(&dStr);
hrc = jsi_wswrite(pss, wsi, (unsigned char*)strVal, strLen, LWS_WRITE_HTTP);
}
Jsi_DecrRefCount(interp, fname);
Jsi_DSFree(&dStr);
Jsi_DSFree(&fStr);
if (hrc<0) {
if (cmdPtr->noWarn==0)
fprintf(stderr, ""can not serve data (%d): %s\n"", hrc, buf);
goto bail;
} else if (hrc > 0 && lws_http_transaction_completed(wsi))
goto bail;

}
done:
Jsi_DSFree(&hStr);
return rc;

bail:
rc = 1;
goto done;
}",[139],"Buffer overflow vulnerability in function NumberToPrecisionCmd in jsish before 3.0.7, allows remote attackers to execute arbitrary code."
199349," isofs_export_encode_fh(struct inode *inode,
 		       __u32 *fh32,
 		       int *max_len,
 		       struct inode *parent)
 {
 	struct iso_inode_info * ei = ISOFS_I(inode);
 	int len = *max_len;
 	int type = 1;
 	__u16 *fh16 = (__u16*)fh32;
 
 	 
 	if (parent && (len < 5)) {
 		*max_len = 5;
 		return 255;
 	} else if (len < 3) {
 		*max_len = 3;
 		return 255;
 	}
 
  	len = 3;
  	fh32[0] = ei->i_iget5_block;
   	fh16[2] = (__u16)ei->i_iget5_offset;   
 	fh16[3] = 0;   
  	fh32[2] = inode->i_generation;
  	if (parent) {
  		struct iso_inode_info *eparent;
 		eparent = ISOFS_I(parent);
 		fh32[3] = eparent->i_iget5_block;
 		fh16[3] = (__u16)eparent->i_iget5_offset;   
 		fh32[4] = parent->i_generation;
 		len = 5;
 		type = 2;
 	}
 	*max_len = len;
 	return type;
 }",[23],"The isofs_export_encode_fh function in fs/isofs/export.c in the Linux kernel before 3.6 does not initialize a certain structure member, which allows local users to obtain sensitive information from kernel heap memory via a crafted application."
200813," static int check_ptr_alignment(struct bpf_verifier_env *env,
 			       const struct bpf_reg_state *reg,
 			       int off, int size)
 {
 	bool strict = env->strict_alignment;
 	const char *pointer_desc = """";
 
 	switch (reg->type) {
 	case PTR_TO_PACKET:
 	case PTR_TO_PACKET_META:
 		 
 		return check_pkt_ptr_alignment(env, reg, off, size, strict);
 	case PTR_TO_MAP_VALUE:
 		pointer_desc = ""value "";
 		break;
 	case PTR_TO_CTX:
 		pointer_desc = ""context "";
  		break;
  	case PTR_TO_STACK:
  		pointer_desc = ""stack "";
 		 
 		strict = true;
  		break;
  	default:
  		break;
 	}
 	return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,
 					   strict);
 }","[21, 22]",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging the lack of stack-pointer alignment enforcement.
201604," static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,
                                   void *ptr)
 {
     EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);
 
     switch(type) {
     case EVP_CTRL_INIT:
         if (actx == NULL)
             actx = ctx->cipher_data
                  = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());
         if (actx == NULL) {
             EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);
             return 0;
         }
         actx->len.aad = 0;
         actx->len.text = 0;
         actx->aad = 0;
         actx->mac_inited = 0;
         actx->tag_len = 0;
         actx->nonce_len = 12;
         actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;
         return 1;
 
     case EVP_CTRL_COPY:
         if (actx) {
             EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;
 
             dst->cipher_data =
                    OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());
             if (dst->cipher_data == NULL) {
                 EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);
                 return 0;
             }
         }
         return 1;
 
     case EVP_CTRL_AEAD_SET_IVLEN:
         if (arg <= 0 || arg > CHACHA_CTR_SIZE)
             return 0;
         actx->nonce_len = arg;
         return 1;
 
     case EVP_CTRL_AEAD_SET_IV_FIXED:
         if (arg != 12)
             return 0;
         actx->nonce[0] = actx->key.counter[1]
                        = CHACHA_U8TOU32((unsigned char *)ptr);
         actx->nonce[1] = actx->key.counter[2]
                        = CHACHA_U8TOU32((unsigned char *)ptr+4);
         actx->nonce[2] = actx->key.counter[3]
                        = CHACHA_U8TOU32((unsigned char *)ptr+8);
         return 1;
 
     case EVP_CTRL_AEAD_SET_TAG:
         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)
             return 0;
         if (ptr != NULL) {
             memcpy(actx->tag, ptr, arg);
             actx->tag_len = arg;
         }
         return 1;
 
     case EVP_CTRL_AEAD_GET_TAG:
         if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)
             return 0;
         memcpy(ptr, actx->tag, arg);
         return 1;
 
     case EVP_CTRL_AEAD_TLS1_AAD:
         if (arg != EVP_AEAD_TLS1_AAD_LEN)
             return 0;
         {
             unsigned int len;
             unsigned char *aad = ptr, temp[POLY1305_BLOCK_SIZE];
 
              len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |
                    aad[EVP_AEAD_TLS1_AAD_LEN - 1];
              if (!ctx->encrypt) {
                 if (len < POLY1305_BLOCK_SIZE)
                     return 0;
                  len -= POLY1305_BLOCK_SIZE;      
                  memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);
                  aad = temp;
                 temp[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);
                 temp[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;
             }
              actx->tls_payload_length = len;
  
               
              actx->key.counter[1] = actx->nonce[0];
              actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);
             actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);
             actx->mac_inited = 0;
             chacha20_poly1305_cipher(ctx, NULL, aad, EVP_AEAD_TLS1_AAD_LEN);
             return POLY1305_BLOCK_SIZE;          
         }
 
     case EVP_CTRL_AEAD_SET_MAC_KEY:
          
         return 1;
 
     default:
         return -1;
     }
 }","[79, 80]","If an SSL/TLS server or client is running on a 32-bit host, and a specific cipher is being used, then a truncated packet can cause that server or client to perform an out-of-bounds read, usually resulting in a crash. For OpenSSL 1.1.0, the crash can be triggered when using CHACHA20/POLY1305; users should upgrade to 1.1.0d. For Openssl 1.0.2, the crash can be triggered when using RC4-MD5; users who have not disabled that algorithm should update to 1.0.2k."
204859," void XMLHttpRequest::didTimeout()
 void XMLHttpRequest::handleDidTimeout()
  {
      RefPtr<XMLHttpRequest> protect(this);
      internalAbort();
  
    clearResponse();
    clearRequest();
    m_error = true;
      m_exceptionCode = TimeoutError;
  
     handleDidFailGeneric();
 
      if (!m_async) {
          m_state = DONE;
        m_exceptionCode = TimeoutError;
          return;
      }
      changeState(DONE);
  
    if (!m_uploadComplete) {
        m_uploadComplete = true;
        if (m_upload && m_uploadEventsAllowed)
            m_upload->dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));
    }
    m_progressEventThrottle.dispatchEventAndLoadEnd(XMLHttpRequestProgressEvent::create(eventNames().timeoutEvent));
     dispatchEventAndLoadEnd(eventNames().timeoutEvent);
  }","[2, 12, 13, 27, 7, 8, 9, 16, 21, 22, 23, 24, 25, 26]","Use-after-free vulnerability in core/xml/XMLHttpRequest.cpp in Blink, as used in Google Chrome before 30.0.1599.101, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger multiple conflicting uses of the same XMLHttpRequest object."
205038," void APIPermissionInfo::RegisterAllPermissions(
     PermissionsInfo* info) {
 
   struct PermissionRegistration {
     APIPermission::ID id;
     const char* name;
     int flags;
     int l10n_message_id;
     PermissionMessage::ID message_id;
     APIPermissionConstructor constructor;
   } PermissionsToRegister[] = {
     { APIPermission::kBackground, ""background"" },
     { APIPermission::kClipboardRead, ""clipboardRead"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_CLIPBOARD,
       PermissionMessage::kClipboard },
     { APIPermission::kClipboardWrite, ""clipboardWrite"" },
     { APIPermission::kDeclarativeWebRequest, ""declarativeWebRequest"" },
     { APIPermission::kDownloads, ""downloads"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_DOWNLOADS,
       PermissionMessage::kDownloads },
     { APIPermission::kExperimental, ""experimental"", kFlagCannotBeOptional },
     { APIPermission::kGeolocation, ""geolocation"", kFlagCannotBeOptional,
       IDS_EXTENSION_PROMPT_WARNING_GEOLOCATION,
       PermissionMessage::kGeolocation },
     { APIPermission::kNotification, ""notifications"" },
     { APIPermission::kUnlimitedStorage, ""unlimitedStorage"",
       kFlagCannotBeOptional },
 
     { APIPermission::kAppNotifications, ""appNotifications"" },
 
     { APIPermission::kActiveTab, ""activeTab"" },
     { APIPermission::kAlarms, ""alarms"" },
     { APIPermission::kBookmark, ""bookmarks"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_BOOKMARKS,
       PermissionMessage::kBookmarks },
     { APIPermission::kBrowsingData, ""browsingData"" },
     { APIPermission::kContentSettings, ""contentSettings"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_CONTENT_SETTINGS,
       PermissionMessage::kContentSettings },
     { APIPermission::kContextMenus, ""contextMenus"" },
     { APIPermission::kCookie, ""cookies"" },
     { APIPermission::kFileBrowserHandler, ""fileBrowserHandler"",
       kFlagCannotBeOptional },
     { APIPermission::kFontSettings, ""fontSettings"", kFlagCannotBeOptional },
     { APIPermission::kHistory, ""history"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_BROWSING_HISTORY,
       PermissionMessage::kBrowsingHistory },
     { APIPermission::kIdle, ""idle"" },
     { APIPermission::kInput, ""input"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_INPUT,
       PermissionMessage::kInput },
     { APIPermission::kManagement, ""management"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_MANAGEMENT,
       PermissionMessage::kManagement },
     { APIPermission::kPrivacy, ""privacy"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_PRIVACY,
       PermissionMessage::kPrivacy },
     { APIPermission::kStorage, ""storage"" },
     { APIPermission::kSyncFileSystem, ""syncFileSystem"" },
     { APIPermission::kTab, ""tabs"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_TABS,
       PermissionMessage::kTabs },
     { APIPermission::kTopSites, ""topSites"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_BROWSING_HISTORY,
       PermissionMessage::kBrowsingHistory },
     { APIPermission::kTts, ""tts"", 0, kFlagCannotBeOptional },
     { APIPermission::kTtsEngine, ""ttsEngine"", kFlagCannotBeOptional,
       IDS_EXTENSION_PROMPT_WARNING_TTS_ENGINE,
       PermissionMessage::kTtsEngine },
     { APIPermission::kWebNavigation, ""webNavigation"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_TABS, PermissionMessage::kTabs },
     { APIPermission::kWebRequest, ""webRequest"" },
     { APIPermission::kWebRequestBlocking, ""webRequestBlocking"" },
     { APIPermission::kWebView, ""webview"", kFlagCannotBeOptional },
 
     { APIPermission::kBookmarkManagerPrivate, ""bookmarkManagerPrivate"",
        kFlagCannotBeOptional },
      { APIPermission::kChromeosInfoPrivate, ""chromeosInfoPrivate"",
        kFlagCannotBeOptional },
     { APIPermission::kDial, ""dial"", kFlagCannotBeOptional },
      { APIPermission::kFileBrowserHandlerInternal, ""fileBrowserHandlerInternal"",
        kFlagCannotBeOptional },
      { APIPermission::kFileBrowserPrivate, ""fileBrowserPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kManagedModePrivate, ""managedModePrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kMediaPlayerPrivate, ""mediaPlayerPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kMetricsPrivate, ""metricsPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kSystemPrivate, ""systemPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kCloudPrintPrivate, ""cloudPrintPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kInputMethodPrivate, ""inputMethodPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kEchoPrivate, ""echoPrivate"", kFlagCannotBeOptional },
     { APIPermission::kRtcPrivate, ""rtcPrivate"", kFlagCannotBeOptional },
     { APIPermission::kTerminalPrivate, ""terminalPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kWallpaperPrivate, ""wallpaperPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kWebRequestInternal, ""webRequestInternal"" },
     { APIPermission::kWebSocketProxyPrivate, ""webSocketProxyPrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kWebstorePrivate, ""webstorePrivate"",
       kFlagCannotBeOptional },
     { APIPermission::kMediaGalleriesPrivate, ""mediaGalleriesPrivate"",
       kFlagCannotBeOptional },
 
     { APIPermission::kDebugger, ""debugger"",
       kFlagImpliesFullURLAccess | kFlagCannotBeOptional,
       IDS_EXTENSION_PROMPT_WARNING_DEBUGGER,
       PermissionMessage::kDebugger },
     { APIPermission::kDevtools, ""devtools"",
       kFlagImpliesFullURLAccess | kFlagCannotBeOptional },
     { APIPermission::kPageCapture, ""pageCapture"",
       kFlagImpliesFullURLAccess },
     { APIPermission::kTabCapture, ""tabCapture"",
       kFlagImpliesFullURLAccess },
     { APIPermission::kPlugin, ""plugin"",
       kFlagImpliesFullURLAccess | kFlagImpliesFullAccess |
           kFlagCannotBeOptional,
       IDS_EXTENSION_PROMPT_WARNING_FULL_ACCESS,
       PermissionMessage::kFullAccess },
     { APIPermission::kProxy, ""proxy"",
       kFlagImpliesFullURLAccess | kFlagCannotBeOptional },
 
     { APIPermission::kSerial, ""serial"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_SERIAL,
       PermissionMessage::kSerial },
     { APIPermission::kSocket, ""socket"", kFlagCannotBeOptional, 0,
       PermissionMessage::kNone, &::CreateAPIPermission<SocketPermission> },
     { APIPermission::kAppCurrentWindowInternal, ""app.currentWindowInternal"" },
     { APIPermission::kAppRuntime, ""app.runtime"" },
     { APIPermission::kAppWindow, ""app.window"" },
     { APIPermission::kAudioCapture, ""audioCapture"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_AUDIO_CAPTURE,
       PermissionMessage::kAudioCapture },
     { APIPermission::kVideoCapture, ""videoCapture"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_VIDEO_CAPTURE,
       PermissionMessage::kVideoCapture },
     { APIPermission::kFileSystem, ""fileSystem"" },
     { APIPermission::kFileSystemWrite, ""fileSystem.write"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_FILE_SYSTEM_WRITE,
       PermissionMessage::kFileSystemWrite },
     { APIPermission::kMediaGalleries, ""mediaGalleries"" },
     { APIPermission::kMediaGalleriesRead, ""mediaGalleries.read"" },
     { APIPermission::kMediaGalleriesAllAutoDetected,
       ""mediaGalleries.allAutoDetected"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_MEDIA_GALLERIES_ALL_GALLERIES,
       PermissionMessage::kMediaGalleriesAllGalleries },
     { APIPermission::kPushMessaging, ""pushMessaging"", kFlagCannotBeOptional },
     { APIPermission::kBluetooth, ""bluetooth"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_BLUETOOTH,
       PermissionMessage::kBluetooth },
     { APIPermission::kBluetoothDevice, ""bluetoothDevice"",
       kFlagNone, 0, PermissionMessage::kNone,
       &::CreateAPIPermission<BluetoothDevicePermission> },
     { APIPermission::kUsb, ""usb"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_USB,
       PermissionMessage::kUsb },
     { APIPermission::kSystemIndicator, ""systemIndicator"", kFlagNone,
       IDS_EXTENSION_PROMPT_WARNING_SYSTEM_INDICATOR,
       PermissionMessage::kSystemIndicator },
     { APIPermission::kPointerLock, ""pointerLock"" },
   };
 
   for (size_t i = 0; i < ARRAYSIZE_UNSAFE(PermissionsToRegister); ++i) {
     const PermissionRegistration& pr = PermissionsToRegister[i];
     info->RegisterPermission(
         pr.id, pr.name, pr.l10n_message_id,
         pr.message_id ? pr.message_id : PermissionMessage::kNone,
         pr.flags,
         pr.constructor);
   }
 
   info->RegisterAlias(""unlimitedStorage"", kOldUnlimitedStoragePermission);
   info->RegisterAlias(""tabs"", kWindowsPermission);
 }",[80],"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly implement web audio nodes, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via unknown vectors."
8511,"mrb_proc_copy(struct RProc *a, struct RProc *b)
{
if (a->body.irep) {

return;
}
a->flags = b->flags;
a->body = b->body;
if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {
mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);
}
a->upper = b->upper;
a->e.env = b->e.env;

}","[9, 10, 12]",mruby is vulnerable to NULL Pointer Dereference
197790," SplashError Splash::drawImage(SplashImageSource src, void *srcData,
 			      SplashColorMode srcMode, GBool srcAlpha,
 			      int w, int h, SplashCoord *mat) {
   SplashPipe pipe;
   GBool ok, rot;
   SplashCoord xScale, yScale, xShear, yShear, yShear1;
   int tx, tx2, ty, ty2, scaledWidth, scaledHeight, xSign, ySign;
   int ulx, uly, llx, lly, urx, ury, lrx, lry;
   int ulx1, uly1, llx1, lly1, urx1, ury1, lrx1, lry1;
   int xMin, xMax, yMin, yMax;
   SplashClipResult clipRes, clipRes2;
   int yp, yq, yt, yStep, lastYStep;
   int xp, xq, xt, xStep, xSrc;
   int k1, spanXMin, spanXMax, spanY;
   SplashColorPtr colorBuf, p;
   SplashColor pix;
   Guchar *alphaBuf, *q;
 #if SPLASH_CMYK
   int pixAcc0, pixAcc1, pixAcc2, pixAcc3;
 #else
   int pixAcc0, pixAcc1, pixAcc2;
 #endif
   int alphaAcc;
   SplashCoord pixMul, alphaMul, alpha;
   int x, y, x1, x2, y2;
   SplashCoord y1;
   int nComps, n, m, i, j;
 
   if (debugMode) {
     printf(""drawImage: srcMode=%d srcAlpha=%d w=%d h=%d mat=[%.2f %.2f %.2f %.2f %.2f %.2f]\n"",
 	   srcMode, srcAlpha, w, h, (double)mat[0], (double)mat[1], (double)mat[2],
 	   (double)mat[3], (double)mat[4], (double)mat[5]);
   }
 
   ok = gFalse;  
   nComps = 0;  
   switch (bitmap->mode) {
   case splashModeMono1:
   case splashModeMono8:
     ok = srcMode == splashModeMono8;
     nComps = 1;
     break;
   case splashModeRGB8:
     ok = srcMode == splashModeRGB8;
     nComps = 3;
     break;
   case splashModeXBGR8:
     ok = srcMode == splashModeXBGR8;
     nComps = 4;
     break;
   case splashModeBGR8:
     ok = srcMode == splashModeBGR8;
     nComps = 3;
     break;
 #if SPLASH_CMYK
   case splashModeCMYK8:
     ok = srcMode == splashModeCMYK8;
     nComps = 4;
     break;
 #endif
   }
   if (!ok) {
     return splashErrModeMismatch;
   }
 
   if (splashAbs(mat[0] * mat[3] - mat[1] * mat[2]) < 0.000001) {
     return splashErrSingularMatrix;
   }
 
   rot = splashAbs(mat[1]) > splashAbs(mat[0]);
   if (rot) {
     xScale = -mat[1];
     yScale = mat[2] - (mat[0] * mat[3]) / mat[1];
     xShear = -mat[3] / yScale;
     yShear = -mat[0] / mat[1];
   } else {
     xScale = mat[0];
     yScale = mat[3] - (mat[1] * mat[2]) / mat[0];
     xShear = mat[2] / yScale;
     yShear = mat[1] / mat[0];
   }
   if (xScale >= 0) {
     tx = splashFloor(mat[4] - 0.01);
     tx2 = splashFloor(mat[4] + xScale + 0.01);
   } else {
     tx = splashFloor(mat[4] + 0.01);
     tx2 = splashFloor(mat[4] + xScale - 0.01);
   }
   scaledWidth = abs(tx2 - tx) + 1;
   if (yScale >= 0) {
     ty = splashFloor(mat[5] - 0.01);
     ty2 = splashFloor(mat[5] + yScale + 0.01);
   } else {
     ty = splashFloor(mat[5] + 0.01);
     ty2 = splashFloor(mat[5] + yScale - 0.01);
   }
   scaledHeight = abs(ty2 - ty) + 1;
   xSign = (xScale < 0) ? -1 : 1;
   ySign = (yScale < 0) ? -1 : 1;
   yShear1 = (SplashCoord)xSign * yShear;
 
   ulx1 = 0;
   uly1 = 0;
   urx1 = xSign * (scaledWidth - 1);
   ury1 = (int)(yShear * urx1);
   llx1 = splashRound(xShear * ySign * (scaledHeight - 1));
   lly1 = ySign * (scaledHeight - 1) + (int)(yShear * llx1);
   lrx1 = xSign * (scaledWidth - 1) +
            splashRound(xShear * ySign * (scaledHeight - 1));
   lry1 = ySign * (scaledHeight - 1) + (int)(yShear * lrx1);
   if (rot) {
     ulx = tx + uly1;    uly = ty - ulx1;
     urx = tx + ury1;    ury = ty - urx1;
     llx = tx + lly1;    lly = ty - llx1;
     lrx = tx + lry1;    lry = ty - lrx1;
   } else {
     ulx = tx + ulx1;    uly = ty + uly1;
     urx = tx + urx1;    ury = ty + ury1;
     llx = tx + llx1;    lly = ty + lly1;
     lrx = tx + lrx1;    lry = ty + lry1;
   }
   xMin = (ulx < urx) ? (ulx < llx) ? (ulx < lrx) ? ulx : lrx
                                    : (llx < lrx) ? llx : lrx
 		     : (urx < llx) ? (urx < lrx) ? urx : lrx
                                    : (llx < lrx) ? llx : lrx;
   xMax = (ulx > urx) ? (ulx > llx) ? (ulx > lrx) ? ulx : lrx
                                    : (llx > lrx) ? llx : lrx
 		     : (urx > llx) ? (urx > lrx) ? urx : lrx
                                    : (llx > lrx) ? llx : lrx;
   yMin = (uly < ury) ? (uly < lly) ? (uly < lry) ? uly : lry
                                    : (lly < lry) ? lly : lry
 		     : (ury < lly) ? (ury < lry) ? ury : lry
                                    : (lly < lry) ? lly : lry;
   yMax = (uly > ury) ? (uly > lly) ? (uly > lry) ? uly : lry
                                    : (lly > lry) ? lly : lry
 		     : (ury > lly) ? (ury > lry) ? ury : lry
                                    : (lly > lry) ? lly : lry;
   clipRes = state->clip->testRect(xMin, yMin, xMax, yMax);
   opClipRes = clipRes;
   if (clipRes == splashClipAllOutside) {
     return splashOk;
   }
 
   yp = h / scaledHeight;
   yq = h % scaledHeight;
   xp = w / scaledWidth;
    xq = w % scaledWidth;
  
  colorBuf = (SplashColorPtr)gmalloc((yp + 1) * w * nComps);
   colorBuf = (SplashColorPtr)gmallocn3((yp + 1), w, nComps);
    if (srcAlpha) {
    alphaBuf = (Guchar *)gmalloc((yp + 1) * w);
     alphaBuf = (Guchar *)gmallocn((yp + 1), w);
    } else {
      alphaBuf = NULL;
    }
 
   pixAcc0 = pixAcc1 = pixAcc2 = 0;  
 #if SPLASH_CMYK
   pixAcc3 = 0;  
 #endif
 
   pipeInit(&pipe, 0, 0, NULL, pix, state->fillAlpha,
 	   srcAlpha || (vectorAntialias && clipRes != splashClipAllInside),
 	   gFalse);
   if (vectorAntialias) {
     drawAAPixelInit();
   }
 
   if (srcAlpha) {
 
     yt = 0;
     lastYStep = 1;
 
     for (y = 0; y < scaledHeight; ++y) {
 
       yStep = yp;
       yt += yq;
       if (yt >= scaledHeight) {
 	yt -= scaledHeight;
 	++yStep;
       }
 
       n = (yp > 0) ? yStep : lastYStep;
       if (n > 0) {
 	p = colorBuf;
 	q = alphaBuf;
 	for (i = 0; i < n; ++i) {
 	  (*src)(srcData, p, q);
 	  p += w * nComps;
 	  q += w;
 	}
       }
       lastYStep = yStep;
 
       k1 = splashRound(xShear * ySign * y);
   
       if (clipRes != splashClipAllInside &&
 	  !rot &&
 	  (int)(yShear * k1) ==
 	    (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {
 	if (xSign > 0) {
 	  spanXMin = tx + k1;
 	  spanXMax = spanXMin + (scaledWidth - 1);
 	} else {
 	  spanXMax = tx + k1;
 	  spanXMin = spanXMax - (scaledWidth - 1);
 	}
 	spanY = ty + ySign * y + (int)(yShear * k1);
 	clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);
 	if (clipRes2 == splashClipAllOutside) {
 	  continue;
 	}
       } else {
 	clipRes2 = clipRes;
       }
 
       xt = 0;
       xSrc = 0;
 
       x1 = k1;
 
       y1 = (SplashCoord)ySign * y + yShear * x1;
       if (yShear1 < 0) {
 	y1 += 0.999;
       }
 
       n = yStep > 0 ? yStep : 1;
 
       switch (srcMode) {
 
       case splashModeMono1:
       case splashModeMono8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += w - m;
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeRGB8:
       case splashModeBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 3;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 3 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeXBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 4;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 4 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	    pix[3] = 255;
 
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
 
 #if SPLASH_CMYK
       case splashModeCMYK8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  alphaAcc = 0;
 	  p = colorBuf + xSrc * 4;
 	  q = alphaBuf + xSrc;
 	  pixAcc0 = pixAcc1 = pixAcc2 = pixAcc3 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      pixAcc3 += *p++;
 	      alphaAcc += *q++;
 	    }
 	    p += 4 * (w - m);
 	    q += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 	  alphaMul = pixMul * (1.0 / 255.0);
 	  alpha = (SplashCoord)alphaAcc * alphaMul;
 
 	  if (alpha > 0) {
 	    pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	    pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	    pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	    pix[3] = (int)((SplashCoord)pixAcc3 * pixMul);
 
 	    pipe.shape = alpha;
 	    if (vectorAntialias && clipRes != splashClipAllInside) {
 	      drawAAPixel(&pipe, tx + x2, ty + y2);
 	    } else {
 	      drawPixel(&pipe, tx + x2, ty + y2,
 			clipRes2 == splashClipAllInside);
 	    }
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 #endif  
       }
     }
 
   } else {
 
     yt = 0;
     lastYStep = 1;
 
     for (y = 0; y < scaledHeight; ++y) {
 
       yStep = yp;
       yt += yq;
       if (yt >= scaledHeight) {
 	yt -= scaledHeight;
 	++yStep;
       }
 
       n = (yp > 0) ? yStep : lastYStep;
       if (n > 0) {
 	p = colorBuf;
 	for (i = 0; i < n; ++i) {
 	  (*src)(srcData, p, NULL);
 	  p += w * nComps;
 	}
       }
       lastYStep = yStep;
 
       k1 = splashRound(xShear * ySign * y);
 
       if (clipRes != splashClipAllInside &&
 	  !rot &&
 	  (int)(yShear * k1) ==
 	    (int)(yShear * (xSign * (scaledWidth - 1) + k1))) {
 	if (xSign > 0) {
 	  spanXMin = tx + k1;
 	  spanXMax = spanXMin + (scaledWidth - 1);
 	} else {
 	  spanXMax = tx + k1;
 	  spanXMin = spanXMax - (scaledWidth - 1);
 	}
 	spanY = ty + ySign * y + (int)(yShear * k1);
 	clipRes2 = state->clip->testSpan(spanXMin, spanXMax, spanY);
 	if (clipRes2 == splashClipAllOutside) {
 	  continue;
 	}
       } else {
 	clipRes2 = clipRes;
       }
 
       xt = 0;
       xSrc = 0;
 
       x1 = k1;
 
       y1 = (SplashCoord)ySign * y + yShear * x1;
       if (yShear1 < 0) {
 	y1 += 0.999;
       }
 
       n = yStep > 0 ? yStep : 1;
 
       switch (srcMode) {
 
       case splashModeMono1:
       case splashModeMono8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc;
 	  pixAcc0 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	    }
 	    p += w - m;
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeRGB8:
       case splashModeBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 3;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	    }
 	    p += 3 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
       case splashModeXBGR8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 4;
 	  pixAcc0 = pixAcc1 = pixAcc2 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      *p++;
 	    }
 	    p += 4 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	  pix[3] = 255;
 
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 
 #if SPLASH_CMYK
       case splashModeCMYK8:
 	for (x = 0; x < scaledWidth; ++x) {
 
 	  xStep = xp;
 	  xt += xq;
 	  if (xt >= scaledWidth) {
 	    xt -= scaledWidth;
 	    ++xStep;
 	  }
 
 	  if (rot) {
 	    x2 = (int)y1;
 	    y2 = -x1;
 	  } else {
 	    x2 = x1;
 	    y2 = (int)y1;
 	  }
 
 	  m = xStep > 0 ? xStep : 1;
 	  p = colorBuf + xSrc * 4;
 	  pixAcc0 = pixAcc1 = pixAcc2 = pixAcc3 = 0;
 	  for (i = 0; i < n; ++i) {
 	    for (j = 0; j < m; ++j) {
 	      pixAcc0 += *p++;
 	      pixAcc1 += *p++;
 	      pixAcc2 += *p++;
 	      pixAcc3 += *p++;
 	    }
 	    p += 4 * (w - m);
 	  }
 	  pixMul = (SplashCoord)1 / (SplashCoord)(n * m);
 
 	  pix[0] = (int)((SplashCoord)pixAcc0 * pixMul);
 	  pix[1] = (int)((SplashCoord)pixAcc1 * pixMul);
 	  pix[2] = (int)((SplashCoord)pixAcc2 * pixMul);
 	  pix[3] = (int)((SplashCoord)pixAcc3 * pixMul);
 
 	  if (vectorAntialias && clipRes != splashClipAllInside) {
 	    pipe.shape = (SplashCoord)1;
 	    drawAAPixel(&pipe, tx + x2, ty + y2);
 	  } else {
 	    drawPixel(&pipe, tx + x2, ty + y2,
 		      clipRes2 == splashClipAllInside);
 	  }
 
 	  xSrc += xStep;
 
 	  x1 += xSign;
 
 	  y1 += yShear1;
 	}
 	break;
 #endif  
       }
     }
 
   }
 
   gfree(colorBuf);
   gfree(alphaBuf);
 
   return splashOk;
 }","[150, 153, 149, 152]","Multiple integer overflows in Poppler 0.10.5 and earlier allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted PDF file, related to (1) glib/poppler-page.cc; (2) ArthurOutputDev.cc, (3) CairoOutputDev.cc, (4) GfxState.cc, (5) JBIG2Stream.cc, (6) PSOutputDev.cc, and (7) SplashOutputDev.cc in poppler/; and (8) SplashBitmap.cc, (9) Splash.cc, and (10) SplashFTFont.cc in splash/.  NOTE: this may overlap CVE-2009-0791."
200093," static void hid_input_field(struct hid_device *hid, struct hid_field *field,
 			    __u8 *data, int interrupt)
 {
 	unsigned n;
 	unsigned count = field->report_count;
 	unsigned offset = field->report_offset;
 	unsigned size = field->report_size;
 	__s32 min = field->logical_minimum;
 	__s32 max = field->logical_maximum;
 	__s32 *value;
 
 	value = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);
 	if (!value)
 		return;
 
 	for (n = 0; n < count; n++) {
 
 		value[n] = min < 0 ?
 			snto32(hid_field_extract(hid, data, offset + n * size,
 			       size), size) :
 			hid_field_extract(hid, data, offset + n * size, size);
 
  		 
  		if (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&
  		    value[n] >= min && value[n] <= max &&
 		    value[n] - min < field->maxusage &&
  		    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
  			goto exit;
  	}
 
 	for (n = 0; n < count; n++) {
 
 		if (HID_MAIN_ITEM_VARIABLE & field->flags) {
 			hid_process_event(hid, field, &field->usage[n], value[n], interrupt);
 			continue;
  		}
  
  		if (field->value[n] >= min && field->value[n] <= max
 			&& field->value[n] - min < field->maxusage
  			&& field->usage[field->value[n] - min].hid
  			&& search(value, field->value[n], count))
  				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);
  
  		if (value[n] >= min && value[n] <= max
 			&& value[n] - min < field->maxusage
  			&& field->usage[value[n] - min].hid
  			&& search(field->value, value[n], count))
  				hid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);
 	}
 
 	memcpy(field->value, value, count * sizeof(__s32));
 exit:
 	kfree(value);
 }","[26, 39, 45]","The hid_input_field function in drivers/hid/hid-core.c in the Linux kernel before 4.6 allows physically proximate attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) by connecting a device, as demonstrated by a Logitech DJ receiver."
200777," void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)
  {
  	void* pointer;
  
	if (!handle)
 	if (!handle || !SecIsValidHandle(handle))
  		return NULL;
  
  	pointer = (void*) ~((size_t) handle->dwUpper);
 
 	return pointer;
 }","[6, 5]",FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.
8418,"static unsigned int xdr_set_page_base(struct xdr_stream *xdr,
unsigned int base, unsigned int len)
{
unsigned int pgnr;
unsigned int maxlen;
unsigned int pgoff;
unsigned int pgend;
void *kaddr;

maxlen = xdr->buf->page_len;
if (base >= maxlen) {
base = maxlen;
maxlen = 0;
} else
maxlen -= base;
if (len > maxlen)
len = maxlen;

xdr_stream_page_set_pos(xdr, base);
base += xdr->buf->page_base;

pgnr = base >> PAGE_SHIFT;
xdr->page_ptr = &xdr->buf->pages[pgnr];
kaddr = page_address(*xdr->page_ptr);

pgoff = base & ~PAGE_MASK;
xdr->p = (__be32*)(kaddr + pgoff);

pgend = pgoff + len;
if (pgend > PAGE_SIZE)
pgend = PAGE_SIZE;
xdr->end = (__be32*)(kaddr + pgend);
xdr->iov = NULL;
return len;
}","[11, 12, 13, 14]",net/sunrpc/xdr.c in the Linux kernel before 5.13.4 allows remote attackers to cause a denial of service (xdr_set_page_base slab-out-of-bounds access) by performing many NFS 4.2 READ_PLUS operations.
202727," static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,
   ExceptionInfo *exception)
 {
   typedef struct {
     unsigned char Type[4];
     unsigned int nRows;
     unsigned int nCols;
     unsigned int imagf;
     unsigned int nameLen;
   } MAT4_HDR;
 
   long
     ldblk;
 
   EndianType
     endian;
 
   Image
     *rotated_image;
 
   MagickBooleanType
     status;
 
   MAT4_HDR
     HDR;
 
   QuantumInfo
     *quantum_info;
 
   QuantumFormatType
     format_type;
 
   register ssize_t
     i;
 
   ssize_t
     count,
     y;
 
   unsigned char
     *pixels;
 
   unsigned int
     depth;
 
   quantum_info=(QuantumInfo *) NULL;
   (void) SeekBlob(image,0,SEEK_SET);
   status=MagickTrue;
   while (EOFBlob(image) == MagickFalse)
   {
      
      ldblk=ReadBlobLSBLong(image);
     if(EOFBlob(image)) break;
      if ((ldblk > 9999) || (ldblk < 0))
        break;
      HDR.Type[3]=ldblk % 10; ldblk /= 10;   
     HDR.Type[2]=ldblk % 10; ldblk /= 10;   
     HDR.Type[1]=ldblk % 10; ldblk /= 10;   
     HDR.Type[0]=ldblk;         
     if (HDR.Type[3] != 0)
       break;   
     if (HDR.Type[2] != 0)
       break;   
     if (HDR.Type[0] == 0)
       {
         HDR.nRows=ReadBlobLSBLong(image);
         HDR.nCols=ReadBlobLSBLong(image);
         HDR.imagf=ReadBlobLSBLong(image);
         HDR.nameLen=ReadBlobLSBLong(image);
         endian=LSBEndian;
       }
     else
       {
         HDR.nRows=ReadBlobMSBLong(image);
         HDR.nCols=ReadBlobMSBLong(image);
         HDR.imagf=ReadBlobMSBLong(image);
         HDR.nameLen=ReadBlobMSBLong(image);
         endian=MSBEndian;
       }
     if ((HDR.imagf != 0) && (HDR.imagf != 1))
       break;
     if (HDR.nameLen > 0xFFFF)
       return(DestroyImageList(image));
     for (i=0; i < (ssize_t) HDR.nameLen; i++)
     {
       int
         byte;
 
        
       byte=ReadBlobByte(image);
       if (byte == EOF)
         {
           ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
             image->filename);
           break;
         }
     }
     image->columns=(size_t) HDR.nRows;
     image->rows=(size_t) HDR.nCols;
     if ((image->columns == 0) || (image->rows == 0))
       return(DestroyImageList(image));
     if (image_info->ping != MagickFalse)
       {
         Swap(image->columns,image->rows);
         if(HDR.imagf==1) ldblk *= 2;
         SeekBlob(image, HDR.nCols*ldblk, SEEK_CUR);
         if ((image->columns == 0) || (image->rows == 0))
           return(image->previous == (Image *) NULL ? DestroyImageList(image)
             : image);
         goto skip_reading_current;
       }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     (void) SetImageBackgroundColor(image,exception);
     (void) SetImageColorspace(image,GRAYColorspace,exception);
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       return(DestroyImageList(image));
     switch(HDR.Type[1])
     {
       case 0:
         format_type=FloatingPointQuantumFormat;
         depth=64;
         break;
       case 1:
         format_type=FloatingPointQuantumFormat;
         depth=32;
         break;
       case 2:
         format_type=UnsignedQuantumFormat;
         depth=16;
         break;
       case 3:
         format_type=SignedQuantumFormat;
         depth=16;
         break;
       case 4:
         format_type=UnsignedQuantumFormat;
         depth=8;
         break;
       default:
         format_type=UnsignedQuantumFormat;
         depth=8;
         break;
     }
     image->depth=depth;
     if (HDR.Type[0] != 0)
       SetQuantumEndian(image,quantum_info,MSBEndian);
     status=SetQuantumFormat(image,quantum_info,format_type);
     status=SetQuantumDepth(image,quantum_info,depth);
     status=SetQuantumEndian(image,quantum_info,endian);
     SetQuantumScale(quantum_info,1.0);
     pixels=(unsigned char *) GetQuantumPixels(quantum_info);
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       register Quantum
         *magick_restrict q;
 
       count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
       if (count == -1)
         break;
       q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,
         exception);
       if (q == (Quantum *) NULL)
         break;
       (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
         GrayQuantum,pixels,exception);
       if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))
         FixSignedValues(image,q,(int) image->columns);
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         break;
       if (image->previous == (Image *) NULL)
         {
           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
             image->rows);
           if (status == MagickFalse)
             break;
         }
     }
     if (HDR.imagf == 1)
       for (y=0; y < (ssize_t) image->rows; y++)
       {
          
         count=ReadBlob(image,depth/8*image->columns,(char *) pixels);
         if (count == -1)
           break;
         if (HDR.Type[1] == 0)
           InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);
         else
           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);
       }
     if (quantum_info != (QuantumInfo *) NULL)
       quantum_info=DestroyQuantumInfo(quantum_info);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
     rotated_image=RotateImage(image,90.0,exception);
     if (rotated_image != (Image *) NULL)
       {
         rotated_image->page.x=0;
         rotated_image->page.y=0;
         rotated_image->colors = image->colors;
         DestroyBlob(rotated_image);
         rotated_image->blob=ReferenceBlob(image->blob);
         AppendImageToList(&image,rotated_image);
         DeleteImageFromList(&image);
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
      
 skip_reading_current:
     AcquireNextImage(image_info,image,exception);
     if (GetNextImageInList(image) == (Image *) NULL)
       {
         status=MagickFalse;
         break;
       }
     image=SyncNextImageInList(image);
     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
       GetBlobSize(image));
     if (status == MagickFalse)
       break;
   }
   (void) CloseBlob(image);
   if (status == MagickFalse)
     return(DestroyImageList(image));
   return(GetFirstImageInList(image));
 }",[53],coders/mat.c in ImageMagick 7.0.8-43 Q16 allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact by crafting a Matlab image file that is mishandled in ReadImage in MagickCore/constitute.c.
8276,"void Compute(OpKernelContext *ctx) override {
const Tensor *indices_t, *values_t, *shape_t, *dense_t;
OP_REQUIRES_OK(ctx, ctx->input(""sp_indices"", &indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""sp_values"", &values_t));
OP_REQUIRES_OK(ctx, ctx->input(""sp_shape"", &shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""dense"", &dense_t));


OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),
errors::InvalidArgument(
""Input sp_indices should be a matrix but received shape: "",
indices_t->shape().DebugString()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(values_t->shape()) &&
TensorShapeUtils::IsVector(shape_t->shape()),
errors::InvalidArgument(
""Inputs sp_values and sp_shape should be vectors ""
""but received shapes: "",
values_t->shape().DebugString(), "" and "",
shape_t->shape().DebugString()));
OP_REQUIRES(
ctx, values_t->dim_size(0) == indices_t->dim_size(0),
errors::InvalidArgument(
""The first dimension of values and indices should match. ("",
values_t->dim_size(0), "" vs. "", indices_t->dim_size(0), "")""));

const auto indices_mat = indices_t->matrix<int64>();
const auto shape_vec = shape_t->vec<int64>();
const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));
const auto rhs_dims = BCast::FromShape(dense_t->shape());
BCast b(lhs_dims, rhs_dims, false);



auto VecGreaterEq = [](ArraySlice<int64> lhs, ArraySlice<int64> rhs) {
if (lhs.size() < rhs.size()) return false;
for (size_t i = 0; i < rhs.size(); ++i) {
if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;
}
return true;
};
OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),
errors::InvalidArgument(
""SparseDenseBinaryOpShared broadcasts dense to sparse ""
""only; got incompatible shapes: ["",
absl::StrJoin(lhs_dims, "",""), ""] vs. ["",
absl::StrJoin(rhs_dims, "",""), ""]""));

Tensor *output_values = nullptr;
Tensor dense_gathered;
const int64 nnz = indices_t->dim_size(0);
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, TensorShape({nnz}), &output_values));
OP_REQUIRES_OK(
ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),
&dense_gathered));







auto dense_gathered_flat = dense_gathered.flat<T>();
const int ndims = lhs_dims.size();
switch (ndims) {
#define CASE(NDIM)                                                             \
  case NDIM: {                                                                 \
    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \
        dense_t->shaped<T, NDIM>(b.y_reshape())                                \
            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \
    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \
    bool indices_valid = true;                                                 \
    for (int i = 0; i < nnz; ++i) {                                            \
      for (int d = 0; d < NDIM; ++d) {                                         \
        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \
        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \
          indices_valid = false;                                               \
        }                                                                      \
      }                                                                        \
      OP_REQUIRES(                                                             \
          ctx, indices_valid,                                                  \
          errors::InvalidArgument(""Provided indices are out-of-bounds w.r.t. "" \
                                  ""dense side with broadcasted shape""));       \
      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \
    }                                                                          \
    break;                                                                     \
  }

CASE(1);
CASE(2);
CASE(3);
CASE(4);
CASE(5);
default:
OP_REQUIRES(
ctx, false,
errors::InvalidArgument(""Only tensors with ranks between 1 and 5 ""
""are currently supported.  Tensor rank: "",
ndims));
#undef CASE
}

output_values->flat<T>().device(ctx->eigen_device<Device>()) =
values_t->flat<T>().binaryExpr(dense_gathered_flat,
typename Functor::func());
}",[87],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of `tf.raw_ops.SparseDenseCwiseDiv` is vulnerable to a division by 0 error. The [implementation](https://github.com/tensorflow/tensorflow/blob/a1bc56203f21a5a4995311825ffaba7a670d7747/tensorflow/core/kernels/sparse_dense_binary_op_shared.cc#L56) uses a common class for all binary operations but fails to treat the division by 0 case separately. We have patched the issue in GitHub commit d9204be9f49520cdaaeb2541d1dc5187b23f31d9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
200526," static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,
 			 int destroy, struct nlmsghdr *nlh, u32 portid)
 {
 	struct in_ifaddr *promote = NULL;
 	struct in_ifaddr *ifa, *ifa1 = *ifap;
 	struct in_ifaddr *last_prim = in_dev->ifa_list;
 	struct in_ifaddr *prev_prom = NULL;
 	int do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev);
  
  	ASSERT_RTNL();
  
 	if (in_dev->dead)
 		goto no_promotions;
 
  	 
 
 	if (!(ifa1->ifa_flags & IFA_F_SECONDARY)) {
 		struct in_ifaddr **ifap1 = &ifa1->ifa_next;
 
 		while ((ifa = *ifap1) != NULL) {
 			if (!(ifa->ifa_flags & IFA_F_SECONDARY) &&
 			    ifa1->ifa_scope <= ifa->ifa_scope)
 				last_prim = ifa;
 
 			if (!(ifa->ifa_flags & IFA_F_SECONDARY) ||
 			    ifa1->ifa_mask != ifa->ifa_mask ||
 			    !inet_ifa_match(ifa1->ifa_address, ifa)) {
 				ifap1 = &ifa->ifa_next;
 				prev_prom = ifa;
 				continue;
 			}
 
 			if (!do_promote) {
 				inet_hash_remove(ifa);
 				*ifap1 = ifa->ifa_next;
 
 				rtmsg_ifa(RTM_DELADDR, ifa, nlh, portid);
 				blocking_notifier_call_chain(&inetaddr_chain,
 						NETDEV_DOWN, ifa);
 				inet_free_ifa(ifa);
 			} else {
 				promote = ifa;
 				break;
 			}
 		}
 	}
 
 	 
 	for (ifa = promote; ifa; ifa = ifa->ifa_next) {
 		if (ifa1->ifa_mask == ifa->ifa_mask &&
 		    inet_ifa_match(ifa1->ifa_address, ifa))
  			fib_del_ifaddr(ifa, ifa1);
  	}
  
 no_promotions:
  	 
  
  	*ifap = ifa1->ifa_next;
 	inet_hash_remove(ifa1);
 
 	 
 
 	 
 	rtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid);
 	blocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1);
 
 	if (promote) {
 		struct in_ifaddr *next_sec = promote->ifa_next;
 
 		if (prev_prom) {
 			prev_prom->ifa_next = promote->ifa_next;
 			promote->ifa_next = last_prim->ifa_next;
 			last_prim->ifa_next = promote;
 		}
 
 		promote->ifa_flags &= ~IFA_F_SECONDARY;
 		rtmsg_ifa(RTM_NEWADDR, promote, nlh, portid);
 		blocking_notifier_call_chain(&inetaddr_chain,
 				NETDEV_UP, promote);
 		for (ifa = next_sec; ifa; ifa = ifa->ifa_next) {
 			if (ifa1->ifa_mask != ifa->ifa_mask ||
 			    !inet_ifa_match(ifa1->ifa_address, ifa))
 					continue;
 			fib_add_ifaddr(ifa);
 		}
 
 	}
 	if (destroy)
 		inet_free_ifa(ifa1);
 }","[12, 13, 14, 55]","The IPv4 implementation in the Linux kernel before 4.5.2 mishandles destruction of device objects, which allows guest OS users to cause a denial of service (host OS networking outage) by arranging for a large number of IP addresses."
6340,"int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
const struct host_cmd_ds_command *resp)
{
u8 *curr = (u8 *) &resp->params.get_wmm_status;
uint16_t resp_len = le16_to_cpu(resp->size), tlv_len;
int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;
bool valid = true;

struct mwifiex_ie_types_data *tlv_hdr;
struct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;
struct ieee_types_wmm_parameter *wmm_param_ie = NULL;
struct mwifiex_wmm_ac_status *ac_status;

mwifiex_dbg(priv->adapter, INFO,
""info: WMM: WMM_GET_STATUS cmdresp received: %d\n"",
resp_len);

while ((resp_len >= sizeof(tlv_hdr->header)) && valid) {
tlv_hdr = (struct mwifiex_ie_types_data *) curr;
tlv_len = le16_to_cpu(tlv_hdr->header.len);

if (resp_len < tlv_len + sizeof(tlv_hdr->header))
break;

switch (le16_to_cpu(tlv_hdr->header.type)) {
case TLV_TYPE_WMMQSTATUS:
tlv_wmm_qstatus =
(struct mwifiex_ie_types_wmm_queue_status *)
tlv_hdr;
mwifiex_dbg(priv->adapter, CMD,
""info: CMD_RESP: WMM_GET_STATUS:\t""
""QSTATUS TLV: %d, %d, %d\n"",
tlv_wmm_qstatus->queue_index,
tlv_wmm_qstatus->flow_required,
tlv_wmm_qstatus->disabled);

ac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->
queue_index];
ac_status->disabled = tlv_wmm_qstatus->disabled;
ac_status->flow_required =
tlv_wmm_qstatus->flow_required;
ac_status->flow_created = tlv_wmm_qstatus->flow_created;
break;

case WLAN_EID_VENDOR_SPECIFIC:





wmm_param_ie =
(struct ieee_types_wmm_parameter *) (curr +
2);
wmm_param_ie->vend_hdr.len = (u8) tlv_len;
wmm_param_ie->vend_hdr.element_id =
WLAN_EID_VENDOR_SPECIFIC;

mwifiex_dbg(priv->adapter, CMD,
""info: CMD_RESP: WMM_GET_STATUS:\t""
""WMM Parameter Set Count: %d\n"",
wmm_param_ie->qos_info_bitmap & mask);

memcpy((u8 *) &priv->curr_bss_params.bss_descriptor.
wmm_ie, wmm_param_ie,
wmm_param_ie->vend_hdr.len + 2);

break;

default:
valid = false;
break;
}

curr += (tlv_len + sizeof(tlv_hdr->header));
resp_len -= (tlv_len + sizeof(tlv_hdr->header));
}

mwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);
mwifiex_wmm_setup_ac_downgrade(priv);

return 0;
}",[63],"An issue was found in Linux kernel before 5.5.4. mwifiex_ret_wmm_get_status() in drivers/net/wireless/marvell/mwifiex/wmm.c allows a remote AP to trigger a heap-based buffer overflow because of an incorrect memcpy, aka CID-3a9b153c5591."
198097," static void mcf_fec_do_tx(mcf_fec_state *s)
 {
     uint32_t addr;
      uint32_t addr;
      mcf_fec_bd bd;
      int frame_size;
    int len;
     int len, descnt = 0;
      uint8_t frame[FEC_MAX_FRAME_SIZE];
      uint8_t *ptr;
  
     ptr = frame;
      ptr = frame;
      frame_size = 0;
      addr = s->tx_descriptor;
    while (1) {
     while (descnt++ < FEC_MAX_DESC) {
          mcf_fec_read_bd(&bd, addr);
          DPRINTF(""tx_bd %x flags %04x len %d data %08x\n"",
                  addr, bd.flags, bd.length, bd.data);
              
             break;
         }
         len = bd.length;
         if (frame_size + len > FEC_MAX_FRAME_SIZE) {
             len = FEC_MAX_FRAME_SIZE - frame_size;
             s->eir |= FEC_INT_BABT;
         }
         cpu_physical_memory_read(bd.data, ptr, len);
         ptr += len;
         frame_size += len;
         if (bd.flags & FEC_BD_L) {
              
             DPRINTF(""Sending packet\n"");
             qemu_send_packet(qemu_get_queue(s->nic), frame, len);
             ptr = frame;
             frame_size = 0;
             s->eir |= FEC_INT_TXF;
         }
         s->eir |= FEC_INT_TXB;
         bd.flags &= ~FEC_BD_R;
          
         mcf_fec_write_bd(&bd, addr);
          
         if ((bd.flags & FEC_BD_W) != 0) {
             addr = s->etdsr;
         } else {
             addr += 8;
         }
     }","[8, 17, 7, 16]","The mcf_fec_do_tx function in hw/net/mcf_fec.c in QEMU (aka Quick Emulator) does not properly limit the buffer descriptor count when transmitting packets, which allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via vectors involving a buffer descriptor with a length of 0 and crafted values in bd.flags."
7910,"void Compute(OpKernelContext* context) override {
const int64 axis_input = context->input(0).scalar<int64>()();
const Tensor& input_indices = context->input(1);
const Tensor& input_values = context->input(2);
const Tensor& input_shape = context->input(3);

OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices.shape()),
errors::InvalidArgument(
""Input indices should be a matrix but received shape "",
input_indices.shape().DebugString()));
OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values.shape()),
errors::InvalidArgument(
""Input values should be a vector but received shape "",
input_indices.shape().DebugString()));
OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape.shape()),
errors::InvalidArgument(
""Input shape should be a vector but received shape "",
input_shape.shape().DebugString()));

const int64 input_rank = input_shape.vec<int64>().size();
const int64 axis = (axis_input < 0) ? input_rank + axis_input : axis_input;

OP_REQUIRES(
context, axis >= 0 && axis < input_rank,
errors::InvalidArgument(""Input axis should be in range ["", -input_rank,
"", "", input_rank, ""), got "", axis_input));

OP_REQUIRES(context,
num_split_ >= 1 && num_split_ <= input_shape.vec<int64>()(axis),
errors::InvalidArgument(""Input num_split should be between 1 ""
""and the splitting dimension size ("",
input_shape.vec<int64>()(axis),
""), got "", num_split_));

sparse::SparseTensor sparse_tensor;
OP_REQUIRES_OK(context,
sparse::SparseTensor::Create(
input_indices, input_values,
TensorShape(input_shape.vec<int64>()), &sparse_tensor));

std::vector<sparse::SparseTensor> outputs;
OP_REQUIRES_OK(context, sparse::SparseTensor::Split<T>(
sparse_tensor, axis, num_split_, &outputs));

for (int slice_index = 0; slice_index < num_split_; ++slice_index) {
context->set_output(slice_index, outputs[slice_index].indices());
context->set_output(slice_index + num_split_,
outputs[slice_index].values());
Tensor* shape = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(
slice_index + 2 * num_split_,
{outputs[slice_index].dims()}, &shape));
auto output_shape = outputs[slice_index].shape();
for (int dim = 0; dim < outputs[slice_index].dims(); ++dim) {
shape->vec<int64>()(dim) = output_shape[dim];
}
}
}","[35, 37, 38, 39]","TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in caused by an integer overflow in constructing a new tensor shape. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/0908c2f2397c099338b901b067f6495a5b96760b/tensorflow/core/kernels/sparse_split_op.cc#L66-L70) builds a dense shape without checking that the dimensions would not result in overflow. The `TensorShape` constructor(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L183-L188) uses a `CHECK` operation which triggers when `InitDims`(https://github.com/tensorflow/tensorflow/blob/6f9896890c4c703ae0a0845394086e2e1e523299/tensorflow/core/framework/tensor_shape.cc#L212-L296) returns a non-OK status. This is a legacy implementation of the constructor and operations should use `BuildTensorShapeBase` or `AddDimWithStatus` to prevent `CHECK`-failures in the presence of overflows. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
202157," parse_cmdline(int argc, char **argv)
 {
 	int c;
 	bool reopen_log = false;
 	int signum;
 	struct utsname uname_buf;
 	int longindex;
 	int curind;
 	bool bad_option = false;
 	unsigned facility;
 	mode_t new_umask_val;
 
 	struct option long_options[] = {
 		{""use-file"",		required_argument,	NULL, 'f'},
 #if defined _WITH_VRRP_ && defined _WITH_LVS_
 		{""vrrp"",		no_argument,		NULL, 'P'},
 		{""check"",		no_argument,		NULL, 'C'},
 #endif
 #ifdef _WITH_BFD_
 		{""no_bfd"",		no_argument,		NULL, 'B'},
 #endif
 		{""all"",			no_argument,		NULL,  3 },
 		{""log-console"",		no_argument,		NULL, 'l'},
 		{""log-detail"",		no_argument,		NULL, 'D'},
 		{""log-facility"",	required_argument,	NULL, 'S'},
 		{""log-file"",		optional_argument,	NULL, 'g'},
 		{""flush-log-file"",	no_argument,		NULL,  2 },
 		{""no-syslog"",		no_argument,		NULL, 'G'},
 		{""umask"",		required_argument,	NULL, 'u'},
 #ifdef _WITH_VRRP_
 		{""release-vips"",	no_argument,		NULL, 'X'},
 		{""dont-release-vrrp"",	no_argument,		NULL, 'V'},
 #endif
 #ifdef _WITH_LVS_
 		{""dont-release-ipvs"",	no_argument,		NULL, 'I'},
 #endif
 		{""dont-respawn"",	no_argument,		NULL, 'R'},
 		{""dont-fork"",		no_argument,		NULL, 'n'},
 		{""dump-conf"",		no_argument,		NULL, 'd'},
 		{""pid"",			required_argument,	NULL, 'p'},
 #ifdef _WITH_VRRP_
 		{""vrrp_pid"",		required_argument,	NULL, 'r'},
 #endif
 #ifdef _WITH_LVS_
 		{""checkers_pid"",	required_argument,	NULL, 'c'},
 		{""address-monitoring"",	no_argument,		NULL, 'a'},
 #endif
 #ifdef _WITH_BFD_
 		{""bfd_pid"",		required_argument,	NULL, 'b'},
 #endif
 #ifdef _WITH_SNMP_
 		{""snmp"",		no_argument,		NULL, 'x'},
 		{""snmp-agent-socket"",	required_argument,	NULL, 'A'},
 #endif
 		{""core-dump"",		no_argument,		NULL, 'm'},
 		{""core-dump-pattern"",	optional_argument,	NULL, 'M'},
 #ifdef _MEM_CHECK_LOG_
 		{""mem-check-log"",	no_argument,		NULL, 'L'},
 #endif
 #if HAVE_DECL_CLONE_NEWNET
 		{""namespace"",		required_argument,	NULL, 's'},
 #endif
 		{""config-id"",		required_argument,	NULL, 'i'},
 		{""signum"",		required_argument,	NULL,  4 },
 		{""config-test"",		optional_argument,	NULL, 't'},
 #ifdef _WITH_PERF_
 		{""perf"",		optional_argument,	NULL,  5 },
 #endif
 #ifdef WITH_DEBUG_OPTIONS
 		{""debug"",		optional_argument,	NULL,  6 },
 #endif
 		{""version"",		no_argument,		NULL, 'v'},
 		{""help"",		no_argument,		NULL, 'h'},
 
 		{NULL,			0,			NULL,  0 }
 	};
 
 	 
 	curind = optind;
 	while (longindex = -1, (c = getopt_long(argc, argv, "":vhlndu:DRS:f:p:i:mM::g::Gt::""
 #if defined _WITH_VRRP_ && defined _WITH_LVS_
 					    ""PC""
 #endif
 #ifdef _WITH_VRRP_
 					    ""r:VX""
 #endif
 #ifdef _WITH_LVS_
 					    ""ac:I""
 #endif
 #ifdef _WITH_BFD_
 					    ""Bb:""
 #endif
 #ifdef _WITH_SNMP_
 					    ""xA:""
 #endif
 #ifdef _MEM_CHECK_LOG_
 					    ""L""
 #endif
 #if HAVE_DECL_CLONE_NEWNET
 					    ""s:""
 #endif
 				, long_options, &longindex)) != -1) {
 
 		 
 		if (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {
 			c = ':';
 			optarg = NULL;
 		}
 
 		switch (c) {
 		case 'v':
 			fprintf(stderr, ""%s"", version_string);
 #ifdef GIT_COMMIT
 			fprintf(stderr, "", git commit %s"", GIT_COMMIT);
 #endif
 			fprintf(stderr, ""\n\n%s\n\n"", COPYRIGHT_STRING);
 			fprintf(stderr, ""Built with kernel headers for Linux %d.%d.%d\n"",
 						(LINUX_VERSION_CODE >> 16) & 0xff,
 						(LINUX_VERSION_CODE >>  8) & 0xff,
 						(LINUX_VERSION_CODE      ) & 0xff);
 			uname(&uname_buf);
 			fprintf(stderr, ""Running on %s %s %s\n\n"", uname_buf.sysname, uname_buf.release, uname_buf.version);
 			fprintf(stderr, ""configure options: %s\n\n"", KEEPALIVED_CONFIGURE_OPTIONS);
 			fprintf(stderr, ""Config options: %s\n\n"", CONFIGURATION_OPTIONS);
 			fprintf(stderr, ""System options: %s\n"", SYSTEM_OPTIONS);
 			exit(0);
 			break;
 		case 'h':
 			usage(argv[0]);
 			exit(0);
 			break;
 		case 'l':
 			__set_bit(LOG_CONSOLE_BIT, &debug);
 			reopen_log = true;
 			break;
 		case 'n':
 			__set_bit(DONT_FORK_BIT, &debug);
 			break;
 		case 'd':
 			__set_bit(DUMP_CONF_BIT, &debug);
 			break;
 #ifdef _WITH_VRRP_
 		case 'V':
 			__set_bit(DONT_RELEASE_VRRP_BIT, &debug);
 			break;
 #endif
 #ifdef _WITH_LVS_
 		case 'I':
 			__set_bit(DONT_RELEASE_IPVS_BIT, &debug);
 			break;
 #endif
 		case 'D':
 			if (__test_bit(LOG_DETAIL_BIT, &debug))
 				__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);
 			else
 				__set_bit(LOG_DETAIL_BIT, &debug);
 			break;
 		case 'R':
 			__set_bit(DONT_RESPAWN_BIT, &debug);
 			break;
 #ifdef _WITH_VRRP_
 		case 'X':
 			__set_bit(RELEASE_VIPS_BIT, &debug);
 			break;
 #endif
 		case 'S':
 			if (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))
 				fprintf(stderr, ""Invalid log facility '%s'\n"", optarg);
 			else {
 				log_facility = LOG_FACILITY[facility].facility;
 				reopen_log = true;
 			}
 			break;
 		case 'g':
 			if (optarg && optarg[0])
 				log_file_name = optarg;
 			else
 				log_file_name = ""/tmp/keepalived.log"";
 			open_log_file(log_file_name, NULL, NULL, NULL);
 			break;
 		case 'G':
 			__set_bit(NO_SYSLOG_BIT, &debug);
 			reopen_log = true;
 			break;
 		case 'u':
 			new_umask_val = set_umask(optarg);
 			if (umask_cmdline)
 				umask_val = new_umask_val;
 			break;
 		case 't':
 			__set_bit(CONFIG_TEST_BIT, &debug);
 			__set_bit(DONT_RESPAWN_BIT, &debug);
  			__set_bit(DONT_FORK_BIT, &debug);
  			__set_bit(NO_SYSLOG_BIT, &debug);
  			if (optarg && optarg[0]) {
				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 				int fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
  				if (fd == -1) {
  					fprintf(stderr, ""Unable to open config-test log file %s\n"", optarg);
  					exit(EXIT_FAILURE);
 				}
 				dup2(fd, STDERR_FILENO);
 				close(fd);
 			}
 			break;
 		case 'f':
 			conf_file = optarg;
 			break;
 		case 2:		 
 			set_flush_log_file();
 			break;
 #if defined _WITH_VRRP_ && defined _WITH_LVS_
 		case 'P':
 			__clear_bit(DAEMON_CHECKERS, &daemon_mode);
 			break;
 		case 'C':
 			__clear_bit(DAEMON_VRRP, &daemon_mode);
 			break;
 #endif
 #ifdef _WITH_BFD_
 		case 'B':
 			__clear_bit(DAEMON_BFD, &daemon_mode);
 			break;
 #endif
 		case 'p':
 			main_pidfile = optarg;
 			break;
 #ifdef _WITH_LVS_
 		case 'c':
 			checkers_pidfile = optarg;
 			break;
 		case 'a':
 			__set_bit(LOG_ADDRESS_CHANGES, &debug);
 			break;
 #endif
 #ifdef _WITH_VRRP_
 		case 'r':
 			vrrp_pidfile = optarg;
 			break;
 #endif
 #ifdef _WITH_BFD_
 		case 'b':
 			bfd_pidfile = optarg;
 			break;
 #endif
 #ifdef _WITH_SNMP_
 		case 'x':
 			snmp = 1;
 			break;
 		case 'A':
 			snmp_socket = optarg;
 			break;
 #endif
 		case 'M':
 			set_core_dump_pattern = true;
 			if (optarg && optarg[0])
 				core_dump_pattern = optarg;
 			 
 		case 'm':
 			create_core_dump = true;
 			break;
 #ifdef _MEM_CHECK_LOG_
 		case 'L':
 			__set_bit(MEM_CHECK_LOG_BIT, &debug);
 			break;
 #endif
 #if HAVE_DECL_CLONE_NEWNET
 		case 's':
 			override_namespace = MALLOC(strlen(optarg) + 1);
 			strcpy(override_namespace, optarg);
 			break;
 #endif
 		case 'i':
 			FREE_PTR(config_id);
 			config_id = MALLOC(strlen(optarg) + 1);
 			strcpy(config_id, optarg);
 			break;
 		case 4:			 
 			signum = get_signum(optarg);
 			if (signum == -1) {
 				fprintf(stderr, ""Unknown sigfunc %s\n"", optarg);
 				exit(1);
 			}
 
 			printf(""%d\n"", signum);
 			exit(0);
 			break;
 		case 3:			 
 			__set_bit(RUN_ALL_CHILDREN, &daemon_mode);
 #ifdef _WITH_VRRP_
 			__set_bit(DAEMON_VRRP, &daemon_mode);
 #endif
 #ifdef _WITH_LVS_
 			__set_bit(DAEMON_CHECKERS, &daemon_mode);
 #endif
 #ifdef _WITH_BFD_
 			__set_bit(DAEMON_BFD, &daemon_mode);
 #endif
 			break;
 #ifdef _WITH_PERF_
 		case 5:
 			if (optarg && optarg[0]) {
 				if (!strcmp(optarg, ""run""))
 					perf_run = PERF_RUN;
 				else if (!strcmp(optarg, ""all""))
 					perf_run = PERF_ALL;
 				else if (!strcmp(optarg, ""end""))
 					perf_run = PERF_END;
 				else
 					log_message(LOG_INFO, ""Unknown perf start point %s"", optarg);
 			}
 			else
 				perf_run = PERF_RUN;
 
 			break;
 #endif
 #ifdef WITH_DEBUG_OPTIONS
 		case 6:
 			set_debug_options(optarg && optarg[0] ? optarg : NULL);
 			break;
 #endif
 		case '?':
 			if (optopt && argv[curind][1] != '-')
 				fprintf(stderr, ""Unknown option -%c\n"", optopt);
 			else
 				fprintf(stderr, ""Unknown option %s\n"", argv[curind]);
 			bad_option = true;
 			break;
 		case ':':
 			if (optopt && argv[curind][1] != '-')
 				fprintf(stderr, ""Missing parameter for option -%c\n"", optopt);
 			else
 				fprintf(stderr, ""Missing parameter for option --%s\n"", long_options[longindex].name);
 			bad_option = true;
 			break;
 		default:
 			exit(1);
 			break;
 		}
 		curind = optind;
 	}
 
 	if (optind < argc) {
 		printf(""Unexpected argument(s): "");
 		while (optind < argc)
 			printf(""%s "", argv[optind++]);
 		printf(""\n"");
 	}
 
 	if (bad_option)
 		exit(1);
 
 	return reopen_log;
 }","[197, 196]","keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd."
199769," int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 		  int noblock, int flags, int *addr_len)
 {
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct inet_sock *inet = inet_sk(sk);
 	struct sk_buff *skb;
 	unsigned int ulen, copied;
 	int peeked, off = 0;
 	int err;
 	int is_udplite = IS_UDPLITE(sk);
 	int is_udp4;
 	bool slow;
 
 	if (flags & MSG_ERRQUEUE)
 		return ipv6_recv_error(sk, msg, len, addr_len);
 
 	if (np->rxpmtu && np->rxopt.bits.rxpmtu)
 		return ipv6_recv_rxpmtu(sk, msg, len, addr_len);
 
 try_again:
 	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
 				  &peeked, &off, &err);
 	if (!skb)
 		goto out;
 
 	ulen = skb->len - sizeof(struct udphdr);
 	copied = len;
 	if (copied > ulen)
 		copied = ulen;
 	else if (copied < ulen)
 		msg->msg_flags |= MSG_TRUNC;
 
 	is_udp4 = (skb->protocol == htons(ETH_P_IP));
 
 	 
 
 	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
 		if (udp_lib_checksum_complete(skb))
 			goto csum_copy_err;
 	}
 
 	if (skb_csum_unnecessary(skb))
 		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
 					    msg, copied);
 	else {
 		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr), msg);
 		if (err == -EINVAL)
 			goto csum_copy_err;
 	}
 	if (unlikely(err)) {
 		trace_kfree_skb(skb, udpv6_recvmsg);
 		if (!peeked) {
 			atomic_inc(&sk->sk_drops);
 			if (is_udp4)
 				UDP_INC_STATS_USER(sock_net(sk),
 						   UDP_MIB_INERRORS,
 						   is_udplite);
 			else
 				UDP6_INC_STATS_USER(sock_net(sk),
 						    UDP_MIB_INERRORS,
 						    is_udplite);
 		}
 		goto out_free;
 	}
 	if (!peeked) {
 		if (is_udp4)
 			UDP_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_INDATAGRAMS, is_udplite);
 		else
 			UDP6_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_INDATAGRAMS, is_udplite);
 	}
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	 
 	if (msg->msg_name) {
 		DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
 		sin6->sin6_family = AF_INET6;
 		sin6->sin6_port = udp_hdr(skb)->source;
 		sin6->sin6_flowinfo = 0;
 
 		if (is_udp4) {
 			ipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,
 					       &sin6->sin6_addr);
 			sin6->sin6_scope_id = 0;
 		} else {
 			sin6->sin6_addr = ipv6_hdr(skb)->saddr;
 			sin6->sin6_scope_id =
 				ipv6_iface_scope_id(&sin6->sin6_addr,
 						    inet6_iif(skb));
 		}
 		*addr_len = sizeof(*sin6);
 	}
 
 	if (np->rxopt.all)
 		ip6_datagram_recv_common_ctl(sk, msg, skb);
 
 	if (is_udp4) {
 		if (inet->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
 	} else {
 		if (np->rxopt.all)
 			ip6_datagram_recv_specific_ctl(sk, msg, skb);
 	}
 
 	err = copied;
 	if (flags & MSG_TRUNC)
 		err = ulen;
 
 out_free:
 	skb_free_datagram_locked(sk, skb);
 out:
 	return err;
 
 csum_copy_err:
 	slow = lock_sock_fast(sk);
 	if (!skb_kill_datagram(sk, skb, flags)) {
 		if (is_udp4) {
 			UDP_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_CSUMERRORS, is_udplite);
 			UDP_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_INERRORS, is_udplite);
 		} else {
 			UDP6_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_CSUMERRORS, is_udplite);
 			UDP6_INC_STATS_USER(sock_net(sk),
 					UDP_MIB_INERRORS, is_udplite);
 		}
  	}
  	unlock_sock_fast(sk, slow);
  
	if (noblock)
		return -EAGAIN;
 	 
 	cond_resched();
  	msg->msg_flags &= ~MSG_TRUNC;
  	goto try_again;
  }","[136, 133, 134]","The (1) udp_recvmsg and (2) udpv6_recvmsg functions in the Linux kernel before 4.0.6 provide inappropriate -EAGAIN return values, which allows remote attackers to cause a denial of service (EPOLLET epoll application read outage) via an incorrect checksum in a UDP packet, a different vulnerability than CVE-2015-5364."
205726,"  TestPaintArtifact& TestPaintArtifact::ScrollHitTest(
      DisplayItemClient& client,
    scoped_refptr<const TransformPaintPropertyNode> scroll_offset) {
     const TransformPaintPropertyNode& scroll_offset) {
    display_item_list_.AllocateAndConstruct<ScrollHitTestDisplayItem>(
      client, DisplayItem::kScrollHitTest, std::move(scroll_offset));
       client, DisplayItem::kScrollHitTest, scroll_offset);
    return *this;
  }","[4, 7, 3, 6]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
199709," int use_conf(char *test_path)
 {
     int ret;
     size_t flags = 0;
     char filename[1024], errstr[1024];
     char *buffer;
     FILE *infile, *conffile;
     json_t *json;
     json_error_t error;
 
     sprintf(filename, ""%s%cinput"", test_path, dir_sep);
     if (!(infile = fopen(filename, ""rb""))) {
         fprintf(stderr, ""Could not open \""%s\""\n"", filename);
         return 2;
     }
 
     sprintf(filename, ""%s%cenv"", test_path, dir_sep);
     conffile = fopen(filename, ""rb"");
     if (conffile) {
         read_conf(conffile);
         fclose(conffile);
     }
 
     if (conf.indent < 0 || conf.indent > 255) {
         fprintf(stderr, ""invalid value for JSON_INDENT: %d\n"", conf.indent);
         return 2;
     }
 
     if (conf.indent)
         flags |= JSON_INDENT(conf.indent);
 
     if (conf.compact)
         flags |= JSON_COMPACT;
 
     if (conf.ensure_ascii)
         flags |= JSON_ENSURE_ASCII;
 
     if (conf.preserve_order)
         flags |= JSON_PRESERVE_ORDER;
 
      if (conf.sort_keys)
          flags |= JSON_SORT_KEYS;
  
     if (conf.have_hashseed)
         json_object_seed(conf.hashseed);
 
      if (conf.strip) {
           
          buffer = loadfile(infile);
         json = json_loads(strip(buffer), 0, &error);
         free(buffer);
     }
     else
         json = json_loadf(infile, 0, &error);
 
     fclose(infile);
 
     if (!json) {
         sprintf(errstr, ""%d %d %d\n%s\n"",
                 error.line, error.column, error.position,
                 error.text);
 
         ret = cmpfile(errstr, test_path, ""error"");
         return ret;
     }
 
     buffer = json_dumps(json, flags);
     ret = cmpfile(buffer, test_path, ""output"");
     free(buffer);
     json_decref(json);
 
     return ret;
 }","[44, 45, 46]","Jansson, possibly 2.4 and earlier, does not restrict the ability to trigger hash collisions predictably, which allows context-dependent attackers to cause a denial of service (CPU consumption) via a crafted JSON document."
8336,".SetShapeFn([](InferenceContext* c) {
ShapeHandle input_indices = c->input(0);
TF_RETURN_IF_ERROR(c->WithRank(input_indices, 2, &input_indices));
ShapeHandle input_values = c->input(1);
TF_RETURN_IF_ERROR(c->WithRank(input_values, 1, &input_values));
ShapeHandle input_shape = c->input(2);
TF_RETURN_IF_ERROR(c->WithRank(input_shape, 1, &input_shape));
ShapeHandle default_value = c->input(3);
TF_RETURN_IF_ERROR(c->WithRank(default_value, 0, &default_value));
DimensionHandle N = c->Dim(input_indices, 0);
TF_RETURN_IF_ERROR(c->Merge(N, c->Dim(input_values, 0), &N));
DimensionHandle unused_dim;
TF_RETURN_IF_ERROR(c->Merge(c->Dim(input_indices, 1),
c->Dim(input_shape, 0), &unused_dim));
ShapeHandle output_indices =
c->Matrix(InferenceContext::kUnknownDim, c->NumElements(input_shape));
ShapeHandle output_values = c->Vector(InferenceContext::kUnknownDim);
ShapeHandle constant_input_shape;
TF_RETURN_IF_ERROR(c->MakeShapeFromShapeTensor(2, &constant_input_shape));
ShapeHandle empty_row_indicator =
c->Vector(c->Dim(constant_input_shape, 0));
ShapeHandle reverse_index_map = c->Vector(N);
c->set_output(0, output_indices);
c->set_output(1, output_values);
c->set_output(2, empty_row_indicator);
c->set_output(3, reverse_index_map);
return Status::OK();
});",[15],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.SparseFillEmptyRows`. The shape inference [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/ops/sparse_ops.cc#L608-L634) does not validate that the input arguments are not empty tensors. We have patched the issue in GitHub commit 578e634b4f1c1c684d4b4294f9e5281b2133b3ed. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
206634," bool FrameFetchContext::UpdateTimingInfoForIFrameNavigation(
     ResourceTimingInfo* info) {
   if (IsDetached())
     return false;
 
   if (!GetFrame()->Owner())
     return false;
    if (!GetFrame()->should_send_resource_timing_info_to_parent())
      return false;
  if (MasterDocumentLoader()->LoadType() == WebFrameLoadType::kBackForward)
    
   if (MasterDocumentLoader()->LoadType() == WebFrameLoadType::kBackForward) {
      
     GetFrame()->SetShouldSendResourceTimingInfoToParent(false);
      return false;
   }
    return true;
  }","[11, 12, 13, 14, 16, 10]",Incorrect handling of timer information during navigation in Blink in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to obtain cross origin URLs via a crafted HTML page.
202392," int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)
 {
  	struct scsi_device *SDev;
  	struct scsi_sense_hdr sshdr;
  	int result, err = 0, retries = 0;
 	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE], *senseptr = NULL;
  
  	SDev = cd->device;
  
 	if (cgc->sense)
 		senseptr = sense_buffer;
 
        retry:
  	if (!scsi_block_when_processing_errors(SDev)) {
  		err = -ENODEV;
  		goto out;
  	}
  
  	result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
			      cgc->buffer, cgc->buflen,
			      (unsigned char *)cgc->sense, &sshdr,
 			      cgc->buffer, cgc->buflen, senseptr, &sshdr,
  			      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);
  
 	if (cgc->sense)
 		memcpy(cgc->sense, sense_buffer, sizeof(*cgc->sense));
 
  	 
  	if (driver_byte(result) != 0) {
  		switch (sshdr.sense_key) {
 		case UNIT_ATTENTION:
 			SDev->changed = 1;
 			if (!cgc->quiet)
 				sr_printk(KERN_INFO, cd,
 					  ""disc change detected.\n"");
 			if (retries++ < 10)
 				goto retry;
 			err = -ENOMEDIUM;
 			break;
 		case NOT_READY:	 
 			if (sshdr.asc == 0x04 &&
 			    sshdr.ascq == 0x01) {
 				 
 				if (!cgc->quiet)
 					sr_printk(KERN_INFO, cd,
 						  ""CDROM not ready yet.\n"");
 				if (retries++ < 10) {
 					 
 					ssleep(2);
 					goto retry;
 				} else {
 					 
 					err = -ENOMEDIUM;
 					break;
 				}
 			}
 			if (!cgc->quiet)
 				sr_printk(KERN_INFO, cd,
 					  ""CDROM not ready.  Make sure there ""
 					  ""is a disc in the drive.\n"");
 			err = -ENOMEDIUM;
 			break;
 		case ILLEGAL_REQUEST:
 			err = -EIO;
 			if (sshdr.asc == 0x20 &&
 			    sshdr.ascq == 0x00)
 				 
 				err = -EDRIVE_CANT_DO_THIS;
 			break;
 		default:
 			err = -EIO;
 		}
 	}
 
 	 
       out:
 	cgc->stat = err;
 	return err;
 }","[6, 10, 11, 12, 22, 25, 26, 27, 20, 21]","The sr_do_ioctl function in drivers/scsi/sr_ioctl.c in the Linux kernel through 4.16.12 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact because sense buffers have different sizes at the CDROM layer and the SCSI layer, as demonstrated by a CDROMREADMODE2 ioctl call."
202001," void test_parser(void) {
 
 void test_parser_param(uint8_t hvi_trick) {
  	int i, retval;
  	bzrtpPacket_t *zrtpPacket;
  
 	 
 	bzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);
 	bzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);
 
 
 	 
 	memcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);
 	memcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);
 	memcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);
 	memcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);
 	memcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);
 	memcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);
 	memcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);
 	memcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);
 
 	 
 	context87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
 	context12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;
 	context87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
 	context12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;
 	context87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;
 	context12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;
 
 	updateCryptoFunctionPointers(context87654321->channelContext[0]);
 	updateCryptoFunctionPointers(context12345678->channelContext[0]);
 
 	 
 	context87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
 	context12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);
 	context87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);
 	context12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);
 
 	context87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
 	context12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);
 	context87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);
 	context12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);
 
 	memcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);
 	memcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);
 	memcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
 	memcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);
 	memcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);
 	memcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);
 	memcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);
 	memcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);
 
 	 
 	context12345678->channelContext[0]->role = RESPONDER;
 
 	for (i=0; i<TEST_PACKET_NUMBER; i++) {
 		uint8_t freePacketFlag = 1;
  		 
  		zrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);
  		retval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);
		 
 		if (hvi_trick==0) {
 			CU_ASSERT_EQUAL_FATAL(retval,0);
 		} else {  
 			if (zrtpPacket->messageType==MSGTYPE_DHPART2) {
 				CU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);
 				 
 				 
 				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
 				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
 
 				bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
 				bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
 
 				return;
 
 			} else {
 				CU_ASSERT_EQUAL_FATAL(retval,0);
 			}
 		}
 			bzrtp_message(""parsing Ret val is %x index is %d\n"", retval, i);
  		 
  		if (zrtpPacket->messageType==MSGTYPE_HELLO) {
  			if (patternZRTPMetaData[i][2]==0x87654321) {
  				context12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 				context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
  			} else {
  				context87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
 				context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;
  			}
  			freePacketFlag = 0;
  		}
 		if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
 		if (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {
 			if (patternZRTPMetaData[i][2]==0x87654321) {
 				context12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
 			} else {
 				context87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;
 			}
 			freePacketFlag = 0;
 		}
 		 
 		free(zrtpPacket->packetString);
 		 
 		retval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);
 		 
 
 		 
 		if (zrtpPacket->packetString != NULL) {
 			CU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);
 		} else {
 			CU_FAIL(""Unable to build packet"");
 		}
 
  		if (freePacketFlag == 1) {
  			bzrtp_freeZrtpPacket(zrtpPacket);
  		}
 
 		 
 		if (hvi_trick == 1) {
 			if (zrtpPacket->messageType==MSGTYPE_COMMIT) {
 				if (patternZRTPMetaData[i][2]==0x87654321) {
 					bzrtpCommitMessage_t *peerCommitMessageData;
 					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;
 					peerCommitMessageData->hvi[0]=0xFF;
 				}
 			}
 		}
 
  	}
  
 	 
 	context87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
 	context12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;
 
 
  	bzrtp_destroyBzrtpContext(context87654321, 0x87654321);
  	bzrtp_destroyBzrtpContext(context12345678, 0x12345678);
  
  }","[2, 3, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 86, 89, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 139, 140, 141, 142, 143, 61]",The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.
5562,"int main(int argc, char **argv)
{
struct ifreq ifr;
#ifndef SIOCBRADDIF
unsigned long ifargs[4];
#endif
int ifindex;
int fd = -1, ctlfd = -1, unixfd = -1;
int use_vnet = 0;
int mtu;
const char *bridge = NULL;
char iface[IFNAMSIZ];
int index;
ACLRule *acl_rule;
ACLList acl_list;
int access_allowed, access_denied;
int ret = EXIT_SUCCESS;

#ifdef CONFIG_LIBCAP


if (geteuid() == 0 && getuid() != geteuid()) {
if (drop_privileges() == -1) {
fprintf(stderr, ""failed to drop privileges\n"");
return 1;
}
}
#endif


for (index = 1; index < argc; index++) {
if (strcmp(argv[index], ""--use-vnet"") == 0) {
use_vnet = 1;
} else if (strncmp(argv[index], ""--br="", 5) == 0) {
bridge = &argv[index][5];
} else if (strncmp(argv[index], ""--fd="", 5) == 0) {
unixfd = atoi(&argv[index][5]);
} else {
usage();
return EXIT_FAILURE;
}
}

if (bridge == NULL || unixfd == -1) {
usage();
return EXIT_FAILURE;
}


QSIMPLEQ_INIT(&acl_list);
if (parse_acl_file(DEFAULT_ACL_FILE, &acl_list) == -1) {
fprintf(stderr, ""failed to parse default acl file `%s'\n"",
DEFAULT_ACL_FILE);
ret = EXIT_FAILURE;
goto cleanup;
}





access_allowed = 0;
access_denied = 0;
QSIMPLEQ_FOREACH(acl_rule, &acl_list, entry) {
switch (acl_rule->type) {
case ACL_ALLOW_ALL:
access_allowed = 1;
break;
case ACL_ALLOW:
if (strcmp(bridge, acl_rule->iface) == 0) {
access_allowed = 1;
}
break;
case ACL_DENY_ALL:
access_denied = 1;
break;
case ACL_DENY:
if (strcmp(bridge, acl_rule->iface) == 0) {
access_denied = 1;
}
break;
}
}

if ((access_allowed == 0) || (access_denied == 1)) {
fprintf(stderr, ""access denied by acl file\n"");
ret = EXIT_FAILURE;
goto cleanup;
}


ctlfd = socket(AF_INET, SOCK_STREAM, 0);
if (ctlfd == -1) {
fprintf(stderr, ""failed to open control socket: %s\n"", strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


fd = open(""/dev/net/tun"", O_RDWR);
if (fd == -1) {
fprintf(stderr, ""failed to open /dev/net/tun: %s\n"", strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}



prep_ifreq(&ifr, ""tap%d"");
ifr.ifr_flags = IFF_TAP|IFF_NO_PI;
if (use_vnet && has_vnet_hdr(fd)) {
ifr.ifr_flags |= IFF_VNET_HDR;
}

if (ioctl(fd, TUNSETIFF, &ifr) == -1) {
fprintf(stderr, ""failed to create tun device: %s\n"", strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


snprintf(iface, sizeof(iface), ""%s"", ifr.ifr_name);


prep_ifreq(&ifr, bridge);
if (ioctl(ctlfd, SIOCGIFMTU, &ifr) == -1) {
fprintf(stderr, ""failed to get mtu of bridge `%s': %s\n"",
bridge, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


mtu = ifr.ifr_mtu;


prep_ifreq(&ifr, iface);
ifr.ifr_mtu = mtu;
if (ioctl(ctlfd, SIOCSIFMTU, &ifr) == -1) {
fprintf(stderr, ""failed to set mtu of device `%s' to %d: %s\n"",
iface, mtu, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}





if (ioctl(ctlfd, SIOCGIFHWADDR, &ifr) < 0) {
fprintf(stderr, ""failed to get MAC address of device `%s': %s\n"",
iface, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}
ifr.ifr_hwaddr.sa_data[0] = 0xFE;
if (ioctl(ctlfd, SIOCSIFHWADDR, &ifr) < 0) {
fprintf(stderr, ""failed to set MAC address of device `%s': %s\n"",
iface, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


prep_ifreq(&ifr, bridge);
ifindex = if_nametoindex(iface);
#ifndef SIOCBRADDIF
ifargs[0] = BRCTL_ADD_IF;
ifargs[1] = ifindex;
ifargs[2] = 0;
ifargs[3] = 0;
ifr.ifr_data = (void *)ifargs;
ret = ioctl(ctlfd, SIOCDEVPRIVATE, &ifr);
#else
ifr.ifr_ifindex = ifindex;
ret = ioctl(ctlfd, SIOCBRADDIF, &ifr);
#endif
if (ret == -1) {
fprintf(stderr, ""failed to add interface `%s' to bridge `%s': %s\n"",
iface, bridge, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


prep_ifreq(&ifr, iface);
if (ioctl(ctlfd, SIOCGIFFLAGS, &ifr) == -1) {
fprintf(stderr, ""failed to get interface flags for `%s': %s\n"",
iface, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}

ifr.ifr_flags |= IFF_UP;
if (ioctl(ctlfd, SIOCSIFFLAGS, &ifr) == -1) {
fprintf(stderr, ""failed to bring up interface `%s': %s\n"",
iface, strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}


if (send_fd(unixfd, fd) == -1) {
fprintf(stderr, ""failed to write fd to unix socket: %s\n"",
strerror(errno));
ret = EXIT_FAILURE;
goto cleanup;
}





cleanup:
if (fd >= 0) {
close(fd);
}
if (ctlfd >= 0) {
close(ctlfd);
}
while ((acl_rule = QSIMPLEQ_FIRST(&acl_list)) != NULL) {
QSIMPLEQ_REMOVE_HEAD(&acl_list, entry);
g_free(acl_rule);
}

return ret;
}",[50],"qemu-bridge-helper.c in QEMU 3.1 and 4.0.0 does not ensure that a network interface name (obtained from bridge.conf or a --br=bridge option) is limited to the IFNAMSIZ size, which can lead to an ACL bypass."
207171,"   void TestProcessOverflow() {
     int tab_count = 1;
     int host_count = 1;
     WebContents* tab1 = NULL;
     WebContents* tab2 = NULL;
     content::RenderProcessHost* rph1 = NULL;
     content::RenderProcessHost* rph2 = NULL;
     content::RenderProcessHost* rph3 = NULL;
 
      const extensions::Extension* extension =
          LoadExtension(test_data_dir_.AppendASCII(""options_page""));
  
      
      GURL omnibox(chrome::kChromeUIOmniboxURL);
      ui_test_utils::NavigateToURL(browser(), omnibox);
      EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     rph1 = tab1->GetMainFrame()->GetProcess();
      EXPECT_EQ(omnibox, tab1->GetURL());
      EXPECT_EQ(host_count, RenderProcessHostCount());
  
      
      GURL page1(""data:text/html,hello world1"");
  
      ui_test_utils::WindowedTabAddedNotificationObserver observer1(
         content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), page1);
     observer1.Wait();
 
     tab_count++;
     host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     rph2 = tab1->GetMainFrame()->GetProcess();
     EXPECT_EQ(tab1->GetURL(), page1);
      EXPECT_EQ(host_count, RenderProcessHostCount());
      EXPECT_NE(rph1, rph2);
  
      
      
      
      GURL page2(""data:text/html,hello world2"");
      ui_test_utils::WindowedTabAddedNotificationObserver observer2(
          content::NotificationService::AllSources());
      ::ShowSingletonTab(browser(), page2);
      observer2.Wait();
      tab_count++;
     if (content::AreAllSitesIsolatedForTesting())
       host_count++;
      EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
      tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
      EXPECT_EQ(tab2->GetURL(), page2);
      EXPECT_EQ(host_count, RenderProcessHostCount());
    EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
     if (content::AreAllSitesIsolatedForTesting())
       EXPECT_NE(tab2->GetMainFrame()->GetProcess(), rph2);
     else
       EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph2);
 
      
      
      
      
      GURL history(chrome::kChromeUIHistoryURL);
      ui_test_utils::WindowedTabAddedNotificationObserver observer3(
          content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), history);
     observer3.Wait();
     tab_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab2 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     EXPECT_EQ(tab2->GetURL(), GURL(history));
      EXPECT_EQ(host_count, RenderProcessHostCount());
      EXPECT_EQ(tab2->GetMainFrame()->GetProcess(), rph1);
  
      
      GURL extension_url(""chrome-extension:"" + extension->id());
      ui_test_utils::WindowedTabAddedNotificationObserver observer4(
          content::NotificationService::AllSources());
     ::ShowSingletonTab(browser(), extension_url);
 
     observer4.Wait();
     tab_count++;
     host_count++;
     EXPECT_EQ(tab_count, browser()->tab_strip_model()->count());
     tab1 = browser()->tab_strip_model()->GetWebContentsAt(tab_count - 1);
     rph3 = tab1->GetMainFrame()->GetProcess();
     EXPECT_EQ(tab1->GetURL(), extension_url);
     EXPECT_EQ(host_count, RenderProcessHostCount());
     EXPECT_NE(rph1, rph3);
     EXPECT_NE(rph2, rph3);
   }","[13, 22, 39, 40, 41, 48, 49, 55, 56, 57, 58, 59, 60, 61, 62, 63, 76, 54]",Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.
208145,"  native_handle_t* native_handle_create(int numFds, int numInts)
  {
    native_handle_t* h = malloc(
            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));
     if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {
         return NULL;
     }
  
     size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));
     native_handle_t* h = malloc(mallocSize);
      if (h) {
          h->version = sizeof(native_handle_t);
          h->numFds = numFds;
         h->numInts = numInts;
  }
  return h;
 }","[5, 6, 7, 9, 10, 3, 4]","Integer overflow in the native_handle_create function in libcutils/native_handle.c in Android before 5.1.1 LMY48M allows attackers to obtain a different application's privileges or cause a denial of service (Binder heap memory corruption) via a crafted application, aka internal bug 19334482."
206348,"  void ResourcePrefetchPredictor::LearnOrigins(
      const std::string& host,
      const GURL& main_frame_origin,
    const std::map<GURL, OriginRequestSummary>& summaries) {
     const std::map<url::Origin, OriginRequestSummary>& summaries) {
    DCHECK_CURRENTLY_ON(BrowserThread::UI);
    if (host.size() > ResourcePrefetchPredictorTables::kMaxStringLength)
      return;
 
   OriginData data;
   bool exists = origin_data_->TryGetData(host, &data);
   if (!exists) {
     data.set_host(host);
     data.set_last_visit_time(base::Time::Now().ToInternalValue());
     size_t origins_size = summaries.size();
     auto ordered_origins =
         std::vector<const OriginRequestSummary*>(origins_size);
     for (const auto& kv : summaries) {
       size_t index = kv.second.first_occurrence;
       DCHECK_LT(index, origins_size);
       ordered_origins[index] = &kv.second;
     }
 
     for (const OriginRequestSummary* summary : ordered_origins) {
       auto* origin_to_add = data.add_origins();
       InitializeOriginStatFromOriginRequestSummary(origin_to_add, *summary);
     }
    } else {
      data.set_last_visit_time(base::Time::Now().ToInternalValue());
  
    std::map<GURL, int> old_index;
     std::map<url::Origin, int> old_index;
      int old_size = static_cast<int>(data.origins_size());
      for (int i = 0; i < old_size; ++i) {
        bool is_new =
          old_index.insert({GURL(data.origins(i).origin()), i}).second;
           old_index
               .insert({url::Origin::Create(GURL(data.origins(i).origin())), i})
               .second;
        DCHECK(is_new);
      }
  
      for (int i = 0; i < old_size; ++i) {
        auto* old_origin = data.mutable_origins(i);
      GURL origin(old_origin->origin());
       url::Origin origin = url::Origin::Create(GURL(old_origin->origin()));
        auto it = summaries.find(origin);
        if (it == summaries.end()) {
         old_origin->set_number_of_misses(old_origin->number_of_misses() + 1);
         old_origin->set_consecutive_misses(old_origin->consecutive_misses() +
                                            1);
       } else {
         const auto& new_origin = it->second;
         old_origin->set_always_access_network(new_origin.always_access_network);
         old_origin->set_accessed_network(new_origin.accessed_network);
 
         int position = new_origin.first_occurrence + 1;
         int total =
             old_origin->number_of_hits() + old_origin->number_of_misses();
         old_origin->set_average_position(
             ((old_origin->average_position() * total) + position) /
             (total + 1));
         old_origin->set_number_of_hits(old_origin->number_of_hits() + 1);
         old_origin->set_consecutive_misses(0);
       }
     }
 
     for (const auto& kv : summaries) {
       if (old_index.find(kv.first) != old_index.end())
         continue;
 
       auto* origin_to_add = data.add_origins();
       InitializeOriginStatFromOriginRequestSummary(origin_to_add, kv.second);
     }
   }
 
   ResourcePrefetchPredictorTables::TrimOrigins(&data,
                                                config_.max_consecutive_misses);
   ResourcePrefetchPredictorTables::SortOrigins(&data, main_frame_origin.spec());
   if (data.origins_size() > static_cast<int>(config_.max_origins_per_entry)) {
     data.mutable_origins()->DeleteSubrange(
         config_.max_origins_per_entry,
         data.origins_size() - config_.max_origins_per_entry);
   }
 
   if (data.origins_size() == 0)
     origin_data_->DeleteData({host});
   else
     origin_data_->UpdateData(host, data);
 }","[5, 32, 37, 38, 39, 46, 4, 31, 36, 45]","Insufficient validation of untrusted input in Skia in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac, and 59.0.3071.92 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
199995," krb5_gss_process_context_token(minor_status, context_handle,
                                token_buffer)
     OM_uint32 *minor_status;
     gss_ctx_id_t context_handle;
     gss_buffer_t token_buffer;
 {
     krb5_gss_ctx_id_rec *ctx;
     OM_uint32 majerr;
  
      ctx = (krb5_gss_ctx_id_t) context_handle;
  
    if (! ctx->established) {
     if (ctx->terminated || !ctx->established) {
          *minor_status = KG_CTX_INCOMPLETE;
          return(GSS_S_NO_CONTEXT);
      }
  
      
     if (ctx->proto) {
         *minor_status = 0;
         return(GSS_S_DEFECTIVE_TOKEN);
     }
 
       
  
      if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,
                                      token_buffer,
                                      GSS_C_NO_BUFFER, NULL, NULL,
                                       KG_TOK_DEL_CTX)))
          return(majerr);
  
      
    return(krb5_gss_delete_sec_context(minor_status, &context_handle,
                                       GSS_C_NO_BUFFER));
     ctx->terminated = 1;
     return(GSS_S_COMPLETE);
  }","[13, 18, 19, 20, 21, 22, 23, 35, 36, 12, 33, 34]","The krb5_gss_process_context_token function in lib/gssapi/krb5/process_context_token.c in the libgssapi_krb5 library in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 does not properly maintain security-context handles, which allows remote authenticated users to cause a denial of service (use-after-free and double free, and daemon crash) or possibly execute arbitrary code via crafted GSSAPI traffic, as demonstrated by traffic to kadmind."
199056," static int __init ipgre_init(void)
 {
 	int err;
  
  	printk(KERN_INFO ""GRE over IPv4 tunneling driver\n"");
  
	if (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {
		printk(KERN_INFO ""ipgre init: can't add protocol\n"");
		return -EAGAIN;
	}
  	err = register_pernet_device(&ipgre_net_ops);
  	if (err < 0)
		goto gen_device_failed;
 		return err;
 
 	err = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);
 	if (err < 0) {
 		printk(KERN_INFO ""ipgre init: can't add protocol\n"");
 		goto add_proto_failed;
 	}
  
  	err = rtnl_link_register(&ipgre_link_ops);
  	if (err < 0)
 		goto rtnl_link_failed;
 
 	err = rtnl_link_register(&ipgre_tap_ops);
 	if (err < 0)
 		goto tap_ops_failed;
 
 out:
 	return err;
 
  tap_ops_failed:
  	rtnl_link_unregister(&ipgre_link_ops);
  rtnl_link_failed:
	unregister_pernet_device(&ipgre_net_ops);
gen_device_failed:
  	inet_del_protocol(&ipgre_protocol, IPPROTO_GRE);
 add_proto_failed:
 	unregister_pernet_device(&ipgre_net_ops);
  	goto out;
  }","[14, 15, 16, 17, 18, 19, 20, 39, 40, 7, 8, 9, 10, 13, 36, 37]","net/ipv4/ip_gre.c in the Linux kernel before 2.6.34, when ip_gre is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."
202942," static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi)
 {
     opj_pi_comp_t *comp = NULL;
     opj_pi_resolution_t *res = NULL;
     long index = 0;
 
     if (!pi->first) {
         comp = &pi->comps[pi->compno];
         res = &comp->resolutions[pi->resno];
         goto LABEL_SKIP;
     } else {
         pi->first = 0;
     }
 
     for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
         for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
             for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
                 comp = &pi->comps[pi->compno];
                 if (pi->resno >= comp->numresolutions) {
                     continue;
                 }
                 res = &comp->resolutions[pi->resno];
                 if (!pi->tp_on) {
                     pi->poc.precno1 = res->pw * res->ph;
                 }
                  for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
                      index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                              pi->step_c + pi->precno * pi->step_p;
                      
                     if (index >= pi->include_size) {
                         opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                         return OPJ_FALSE;
                     }
                      if (!pi->include[index]) {
                          pi->include[index] = 1;
                          return OPJ_TRUE;
                     }
 LABEL_SKIP:
                     ;
                 }
             }
         }
     }
 
     return OPJ_FALSE;
 }","[29, 30, 31, 32, 33]","Out-of-bounds accesses in the functions pi_next_lrcp, pi_next_rlcp, pi_next_rpcl, pi_next_pcrl, pi_next_rpcl, and pi_next_cprl in openmj2/pi.c in OpenJPEG through 2.3.0 allow remote attackers to cause a denial of service (application crash)."
198366," int dtls1_process_buffered_records(SSL *s)
  {
      pitem *item;
      SSL3_BUFFER *rb;
     SSL3_RECORD *rr;
     DTLS1_BITMAP *bitmap;
     unsigned int is_next_epoch;
     int replayok = 1;
  
      item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);
      if (item) {
           
          if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)
            return (1);          
             return 1;          
 
         rr = RECORD_LAYER_get_rrec(&s->rlayer);
  
          rb = RECORD_LAYER_get_rbuf(&s->rlayer);
  
              */
             return 1;
         }
 
          
         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {
             dtls1_get_unprocessed_record(s);
             if (!dtls1_process_record(s))
                 return (0);
             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),
           
          while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {
              dtls1_get_unprocessed_record(s);
            if (!dtls1_process_record(s))
                return (0);
             bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
             if (bitmap == NULL) {
                  
                  SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,
                         ERR_R_INTERNAL_ERROR);
                  return 0;
             }
 #ifndef OPENSSL_NO_SCTP
              
             if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
 #endif
             {
                  
                 replayok = dtls1_record_replay_check(s, bitmap);
             }
 
             if (!replayok || !dtls1_process_record(s, bitmap)) {
                  
                 rr->length = 0;
                 RECORD_LAYER_reset_packet_length(&s->rlayer);
                 continue;
             }
 
              if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),
                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <
                0)
                return -1;
                     SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)
                 return 0;
          }
      }
  
  *             here, anything else is handled by higher layers
  *     Application data protocol
  *             none of our business
  */
      s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;
      s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;
  
    return (1);
     return 1;
  }","[5, 6, 7, 8, 15, 16, 17, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 63, 64, 76, 14, 34, 35, 60, 61, 62, 75]","The Anti-Replay feature in the DTLS implementation in OpenSSL before 1.1.0 mishandles early use of a new epoch number in conjunction with a large sequence number, which allows remote attackers to cause a denial of service (false-positive packet drops) via spoofed DTLS records, related to rec_layer_d1.c and ssl3_record.c."
197960," check_acl(pam_handle_t *pamh,
 	  const char *sense, const char *this_user, const char *other_user,
 	  int noent_code, int debug)
 {
 	char path[PATH_MAX];
 	struct passwd *pwd;
  {
         char path[PATH_MAX];
         struct passwd *pwd;
       FILE *fp;
       int i, save_errno;
        FILE *fp = NULL;
        int i, fd = -1, save_errno;
         uid_t fsuid;
        struct stat st;
          
         pwd = pam_modutil_getpwnam(pamh, this_user);
         if (pwd == NULL) {
 	}
 	 
 	i = snprintf(path, sizeof(path), ""%s/.xauth/%s"", pwd->pw_dir, sense);
 	if ((i >= (int)sizeof(path)) || (i < 0)) {
 		pam_syslog(pamh, LOG_ERR,
 			   ""name of user's home directory is too long"");
 		return PAM_SESSION_ERR;
 	}
 	fsuid = setfsuid(pwd->pw_uid);
 	fp = fopen(path, ""r"");
                 return PAM_SESSION_ERR;
         }
         fsuid = setfsuid(pwd->pw_uid);
       fp = fopen(path, ""r"");
        if (!stat(path, &st)) {
                if (!S_ISREG(st.st_mode))
                        errno = EINVAL;
                else
                        fd = open(path, O_RDONLY | O_NOCTTY);
        }
         save_errno = errno;
         setfsuid(fsuid);
       if (fp != NULL) {
        if (fd >= 0) {
                if (!fstat(fd, &st)) {
                        if (!S_ISREG(st.st_mode))
                                errno = EINVAL;
                        else
                                fp = fdopen(fd, ""r"");
                }
                if (!fp) {
                        save_errno = errno;
                        close(fd);
                }
        }
        if (fp) {
                 char buf[LINE_MAX], *tmp;
                  
                 while (fgets(buf, sizeof(buf), fp) != NULL) {
 				   other_user, path);
 		}
 		fclose(fp);
 		return PAM_PERM_DENIED;
 	} else {
 		 
 	        errno = save_errno;
 		switch (errno) {
 		case ENOENT:
 			if (noent_code == PAM_SUCCESS) {
 				if (debug) {
 					pam_syslog(pamh, LOG_DEBUG,
 						   ""%s does not exist, ignoring"",
 						   path);
 				}
 			} else {
 				if (debug) {
 					pam_syslog(pamh, LOG_DEBUG,
 						   ""%s does not exist, failing"",
 						   path);
 				}
 			}
 			return noent_code;
 		default:
 			if (debug) {
 				pam_syslog(pamh, LOG_DEBUG,
 					   ""error opening %s: %m"", path);
 			}
 			return PAM_PERM_DENIED;
 		}
 	}
 }","[12, 13, 15, 33, 34, 35, 36, 37, 38, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 10, 11, 32, 41]","The check_acl function in pam_xauth.c in the pam_xauth module in Linux-PAM (aka pam) 1.1.2 and earlier does not verify that a certain ACL file is a regular file, which might allow local users to cause a denial of service (resource consumption) via a special file."
198930," static int list_locations(struct kmem_cache *s, char *buf,
 					enum track_item alloc)
 {
 	int len = 0;
 	unsigned long i;
 	struct loc_track t = { 0, 0, NULL };
 	int node;
 
 	if (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location),
 			GFP_TEMPORARY))
 		return sprintf(buf, ""Out of memory\n"");
 
 	 
 	flush_all(s);
 
 	for_each_node_state(node, N_NORMAL_MEMORY) {
 		struct kmem_cache_node *n = get_node(s, node);
 		unsigned long flags;
 		struct page *page;
 
 		if (!atomic_long_read(&n->nr_slabs))
 			continue;
 
 		spin_lock_irqsave(&n->list_lock, flags);
 		list_for_each_entry(page, &n->partial, lru)
 			process_slab(&t, s, page, alloc);
 		list_for_each_entry(page, &n->full, lru)
 			process_slab(&t, s, page, alloc);
 		spin_unlock_irqrestore(&n->list_lock, flags);
 	}
 
 	for (i = 0; i < t.count; i++) {
 		struct location *l = &t.loc[i];
 
 		if (len > PAGE_SIZE - 100)
 			break;
 		len += sprintf(buf + len, ""%7ld "", l->count);
 
 		if (l->addr)
 			len += sprint_symbol(buf + len, (unsigned long)l->addr);
 		else
  			len += sprintf(buf + len, ""<not-available>"");
  
  		if (l->sum_time != l->min_time) {
			unsigned long remainder;
  			len += sprintf(buf + len, "" age=%ld/%ld/%ld"",
			l->min_time,
			div_long_long_rem(l->sum_time, l->count, &remainder),
			l->max_time);
 				l->min_time,
 				(long)div_u64(l->sum_time, l->count),
 				l->max_time);
  		} else
  			len += sprintf(buf + len, "" age=%ld"",
  				l->min_time);
 
 		if (l->min_pid != l->max_pid)
 			len += sprintf(buf + len, "" pid=%ld-%ld"",
 				l->min_pid, l->max_pid);
 		else
 			len += sprintf(buf + len, "" pid=%ld"",
 				l->min_pid);
 
 		if (num_online_cpus() > 1 && !cpus_empty(l->cpus) &&
 				len < PAGE_SIZE - 60) {
 			len += sprintf(buf + len, "" cpus="");
 			len += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50,
 					l->cpus);
 		}
 
 		if (num_online_nodes() > 1 && !nodes_empty(l->nodes) &&
 				len < PAGE_SIZE - 60) {
 			len += sprintf(buf + len, "" nodes="");
 			len += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50,
 					l->nodes);
 		}
 
 		len += sprintf(buf + len, ""\n"");
 	}
 
 	free_loc_track(&t);
 	if (!t.count)
 		len += sprintf(buf, ""No data\n"");
 	return len;
 }","[50, 51, 52, 45, 47, 48, 49]",The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.
198026,"   Load_SBit_Png( FT_GlyphSlot     slot,
                  FT_Int           x_offset,
                  FT_Int           y_offset,
                  FT_Int           pix_bits,
                  TT_SBit_Metrics  metrics,
                  FT_Memory        memory,
                  FT_Byte*         data,
                  FT_UInt          png_len,
                  FT_Bool          populate_map_and_metrics )
   {
     FT_Bitmap    *map   = &slot->bitmap;
     FT_Error      error = FT_Err_Ok;
     FT_StreamRec  stream;
 
     png_structp  png;
     png_infop    info;
     png_uint_32  imgWidth, imgHeight;
 
     int         bitdepth, color_type, interlace;
     FT_Int      i;
     png_byte*  *rows = NULL;  
 
 
     if ( x_offset < 0 ||
          y_offset < 0 )
     {
       error = FT_THROW( Invalid_Argument );
        goto Exit;
      }
  
    if ( !populate_map_and_metrics                   &&
         ( x_offset + metrics->width  > map->width ||
           y_offset + metrics->height > map->rows  ||
           pix_bits != 32                          ||
           map->pixel_mode != FT_PIXEL_MODE_BGRA   ) )
     if ( !populate_map_and_metrics                            &&
          ( (FT_UInt)x_offset + metrics->width  > map->width ||
            (FT_UInt)y_offset + metrics->height > map->rows  ||
            pix_bits != 32                                   ||
            map->pixel_mode != FT_PIXEL_MODE_BGRA            ) )
      {
        error = FT_THROW( Invalid_Argument );
        goto Exit;
     }
 
     FT_Stream_OpenMemory( &stream, data, png_len );
 
     png = png_create_read_struct( PNG_LIBPNG_VER_STRING,
                                   &error,
                                   error_callback,
                                   warning_callback );
     if ( !png )
     {
       error = FT_THROW( Out_Of_Memory );
       goto Exit;
     }
 
     info = png_create_info_struct( png );
     if ( !info )
     {
       error = FT_THROW( Out_Of_Memory );
       png_destroy_read_struct( &png, NULL, NULL );
       goto Exit;
     }
 
     if ( ft_setjmp( png_jmpbuf( png ) ) )
     {
       error = FT_THROW( Invalid_File_Format );
       goto DestroyExit;
     }
 
     png_set_read_fn( png, &stream, read_data_from_FT_Stream );
 
     png_read_info( png, info );
     png_get_IHDR( png, info,
                   &imgWidth, &imgHeight,
                   &bitdepth, &color_type, &interlace,
                   NULL, NULL );
 
     if ( error                                        ||
          ( !populate_map_and_metrics                &&
            ( (FT_Int)imgWidth  != metrics->width  ||
              (FT_Int)imgHeight != metrics->height ) ) )
       goto DestroyExit;
 
     if ( populate_map_and_metrics )
     {
       FT_Long  size;
 
 
       metrics->width  = (FT_Int)imgWidth;
       metrics->height = (FT_Int)imgHeight;
 
       map->width      = metrics->width;
       map->rows       = metrics->height;
       map->pixel_mode = FT_PIXEL_MODE_BGRA;
       map->pitch      = map->width * 4;
       map->num_grays  = 256;
 
        
       if ( map->rows > 0x7FFF || map->width > 0x7FFF )
       {
         error = FT_THROW( Array_Too_Large );
         goto DestroyExit;
       }
 
       size = map->rows * map->pitch;
 
       error = ft_glyphslot_alloc_bitmap( slot, size );
       if ( error )
         goto DestroyExit;
     }
 
      
     if ( color_type == PNG_COLOR_TYPE_PALETTE )
       png_set_palette_to_rgb( png );
 
      
     if ( color_type == PNG_COLOR_TYPE_GRAY )
     {
 #if PNG_LIBPNG_VER >= 10209
       png_set_expand_gray_1_2_4_to_8( png );
 #else
       png_set_gray_1_2_4_to_8( png );
 #endif
     }
 
      
     if ( png_get_valid(png, info, PNG_INFO_tRNS ) )
       png_set_tRNS_to_alpha( png );
 
     if ( bitdepth == 16 )
       png_set_strip_16( png );
 
     if ( bitdepth < 8 )
       png_set_packing( png );
 
      
     if ( color_type == PNG_COLOR_TYPE_GRAY       ||
          color_type == PNG_COLOR_TYPE_GRAY_ALPHA )
       png_set_gray_to_rgb( png );
 
     if ( interlace != PNG_INTERLACE_NONE )
       png_set_interlace_handling( png );
 
     png_set_filler( png, 0xFF, PNG_FILLER_AFTER );
 
      
     png_read_update_info(png, info );
     png_get_IHDR( png, info,
                   &imgWidth, &imgHeight,
                   &bitdepth, &color_type, &interlace,
                   NULL, NULL );
 
     if ( bitdepth != 8                              ||
         !( color_type == PNG_COLOR_TYPE_RGB       ||
            color_type == PNG_COLOR_TYPE_RGB_ALPHA ) )
     {
       error = FT_THROW( Invalid_File_Format );
       goto DestroyExit;
     }
 
     switch ( color_type )
     {
     default:
        
 
     case PNG_COLOR_TYPE_RGB_ALPHA:
       png_set_read_user_transform_fn( png, premultiply_data );
       break;
 
     case PNG_COLOR_TYPE_RGB:
        
       png_set_read_user_transform_fn( png, convert_bytes_to_data );
       break;
     }
 
     if ( FT_NEW_ARRAY( rows, imgHeight ) )
     {
       error = FT_THROW( Out_Of_Memory );
       goto DestroyExit;
     }
 
     for ( i = 0; i < (FT_Int)imgHeight; i++ )
       rows[i] = map->buffer + ( y_offset + i ) * map->pitch + x_offset * 4;
 
     png_read_image( png, rows );
 
     FT_FREE( rows );
 
     png_read_end( png, info );
 
   DestroyExit:
     png_destroy_read_struct( &png, &info, NULL );
     FT_Stream_Close( &stream );
 
   Exit:
     return error;
   }","[36, 37, 38, 39, 40, 31, 32, 33, 34, 35]","The Load_SBit_Png function in sfnt/pngshim.c in FreeType before 2.5.4 does not restrict the rows and pitch values of PNG data, which allows remote attackers to cause a denial of service (integer overflow and heap-based buffer overflow) or possibly have unspecified other impact by embedding a PNG file in a .ttf font file."
208165," status_t OMXNodeInstance::useBuffer(
         OMX_U32 portIndex, const sp<IMemory> &params,
         OMX::buffer_id *buffer, OMX_U32 allottedSize) {
  if (params == NULL || buffer == NULL) {
         ALOGE(""b/25884056"");
  return BAD_VALUE;
 
      }
  
      Mutex::Autolock autoLock(mLock);
    if (allottedSize > params->size()) {
     if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
          return BAD_VALUE;
      }
  
    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);
      
      
     BufferMeta *buffer_meta;
     bool useBackup = mMetadataType[portIndex] != kMetadataBufferTypeInvalid;
     OMX_U8 *data = static_cast<OMX_U8 *>(params->pointer());
      
     if (useBackup) {
         data = new (std::nothrow) OMX_U8[allottedSize];
         if (data == NULL) {
             return NO_MEMORY;
         }
         memset(data, 0, allottedSize);
 
          
         if (allottedSize != params->size()) {
             CLOG_ERROR(useBuffer, BAD_VALUE, SIMPLE_BUFFER(portIndex, (size_t)allottedSize, data));
             delete[] data;
             return BAD_VALUE;
         }
 
         buffer_meta = new BufferMeta(
                 params, portIndex, false  , false  , data);
     } else {
         buffer_meta = new BufferMeta(
                 params, portIndex, false  , false  , NULL);
     }
  
      OMX_BUFFERHEADERTYPE *header;
  
      OMX_ERRORTYPE err = OMX_UseBuffer(
              mHandle, &header, portIndex, buffer_meta,
            allottedSize, static_cast<OMX_U8 *>(params->pointer()));
             allottedSize, data);
  
      if (err != OMX_ErrorNone) {
          CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
                portIndex, (size_t)allottedSize, params->pointer()));
                 portIndex, (size_t)allottedSize, data));
  
          delete buffer_meta;
          buffer_meta = NULL;
 
  *buffer = 0;
 
  return StatusFromOMXError(err);
  }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
  *buffer = makeBufferID(header);
 
     addActiveBuffer(portIndex, *buffer);
 
     sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
  if (bufferSource != NULL && portIndex == kPortIndexInput) {
         bufferSource->addCodecBuffer(header);
  }
 
     CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
  *buffer, portIndex, ""%u(%zu)@%p"", allottedSize, params->size(), params->pointer()));
  return OK;
 }","[12, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 49, 54, 11, 16, 48, 53]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
199588," txid_snapshot_recv(PG_FUNCTION_ARGS)
 {
 	StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
 	TxidSnapshot *snap;
  	txid		last = 0;
  	int			nxip;
  	int			i;
	int			avail;
	int			expect;
  	txid		xmin,
  				xmax;
  
 	 
  	nxip = pq_getmsgint(buf, 4);
	avail = buf->len - buf->cursor;
	expect = 8 + 8 + nxip * 8;
	if (nxip < 0 || nxip > avail || expect > avail)
 	if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)
  		goto bad_format;
  
  	xmin = pq_getmsgint64(buf);
 	xmax = pq_getmsgint64(buf);
 	if (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)
 		goto bad_format;
 
 	snap = palloc(TXID_SNAPSHOT_SIZE(nxip));
 	snap->xmin = xmin;
 	snap->xmax = xmax;
 	snap->nxip = nxip;
 	SET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));
 
 	for (i = 0; i < nxip; i++)
 	{
 		txid		cur = pq_getmsgint64(buf);
 
 		if (cur <= last || cur < xmin || cur >= xmax)
 			goto bad_format;
 		snap->xip[i] = cur;
 		last = cur;
 	}
 	PG_RETURN_POINTER(snap);
 
 bad_format:
 	elog(ERROR, ""invalid snapshot data"");
 	return (Datum) NULL;
 }","[18, 8, 9, 15, 16, 17]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
205079,"  void RenderWidgetHostViewAura::OnLostResources() {
    image_transport_clients_.clear();
    current_surface_ = 0;
  protection_state_id_ = 0;
  current_surface_is_protected_ = true;
  current_surface_in_use_by_compositor_ = true;
  surface_route_id_ = 0;
    UpdateExternalTexture();
    locks_pending_commit_.clear();
  
   DCHECK(!shared_surface_handle_.is_null());
   ImageTransportFactory* factory = ImageTransportFactory::GetInstance();
   factory->DestroySharedSurfaceHandle(shared_surface_handle_);
   shared_surface_handle_ = factory->CreateSharedSurfaceHandle();
   host_->CompositingSurfaceUpdated();
   host_->ScheduleComposite();
 }","[4, 5, 6, 7]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
9912,"static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)
{
struct virtproc_info *vrp = vdev->priv;
struct virtio_rpmsg_channel *vch;
struct rpmsg_device *rpdev_ctrl;
int err = 0;

vch = kzalloc(sizeof(*vch), GFP_KERNEL);
if (!vch)
return ERR_PTR(-ENOMEM);


vch->vrp = vrp;


rpdev_ctrl = &vch->rpdev;
rpdev_ctrl->ops = &virtio_rpmsg_ops;

rpdev_ctrl->dev.parent = &vrp->vdev->dev;
rpdev_ctrl->dev.release = virtio_rpmsg_release_device;
rpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);

err = rpmsg_ctrldev_register_device(rpdev_ctrl);
if (err) {
kfree(vch);
return ERR_PTR(err);
}

return rpdev_ctrl;
}",[25],rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.
7435,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
struct bpf_reg_state *src_reg)
{
bool src_known = tnum_subreg_is_const(src_reg->var_off);
bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
struct tnum var32_off = tnum_subreg(dst_reg->var_off);
s32 smin_val = src_reg->smin_value;
u32 umin_val = src_reg->umin_value;




if (src_known && dst_known)
return;




dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
dst_reg->u32_max_value = var32_off.value | var32_off.mask;
if (dst_reg->s32_min_value < 0 || smin_val < 0) {



dst_reg->s32_min_value = S32_MIN;
dst_reg->s32_max_value = S32_MAX;
} else {



dst_reg->s32_min_value = dst_reg->umin_value;
dst_reg->s32_max_value = dst_reg->umax_value;
}
}","[7, 8, 31, 32]","An issue was discovered in the Linux kernel before 5.8.15. scalar32_min_max_or in kernel/bpf/verifier.c mishandles bounds tracking during use of 64-bit values, aka CID-5b9fbeb75b6a."
8464,"static int rm_rf_children_inner(
int fd,
const char *fname,
int is_dir,
RemoveFlags flags,
const struct stat *root_dev) {

struct stat st;
int r, q = 0;

assert(fd >= 0);
assert(fname);

if (is_dir < 0 ||
root_dev ||
(is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {

r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);
if (r < 0)
return r;

is_dir = S_ISDIR(st.st_mode);
}

if (is_dir) {
_cleanup_close_ int subdir_fd = -1;


if (root_dev && st.st_dev != root_dev->st_dev)
return 0;


r = fd_is_mount_point(fd, fname, 0);
if (r < 0)
return r;
if (r > 0)
return 0;

if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {



r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);
if (r < 0) {
if (!IN_SET(r, -ENOTTY, -EINVAL))
return r;


} else

return 1;
}

subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);
if (subdir_fd < 0)
return -errno;



q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);

} else if (flags & REMOVE_ONLY_DIRECTORIES)
return 0;

r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);
if (r < 0)
return r;
if (q < 0)
return q;
return 1;
}","[6, 26, 54, 60]",A flaw was found in systemd. An uncontrolled recursion in systemd-tmpfiles may lead to a denial of service at boot time when too many nested directories are created in /tmp.
201866," jas_image_t *jas_image_create(int numcmpts, jas_image_cmptparm_t *cmptparms,
    int clrspc)
  {
  	jas_image_t *image;
	uint_fast32_t rawsize;
 	size_t rawsize;
  	uint_fast32_t inmem;
  	int cmptno;
  	jas_image_cmptparm_t *cmptparm;
  
 	image = 0;
 
 	JAS_DBGLOG(100, (""jas_image_create(%d, %p, %d)\n"", numcmpts, cmptparms,
 	  clrspc));
 
  	if (!(image = jas_image_create0())) {
		return 0;
 		goto error;
  	}
  
  	image->clrspc_ = clrspc;
  	image->maxcmpts_ = numcmpts;
	image->inmem_ = true;
  
  
  	 
  	if (!(image->cmpts_ = jas_alloc2(image->maxcmpts_,
  	  sizeof(jas_image_cmpt_t *)))) {
		jas_image_destroy(image);
		return 0;
 		goto error;
  	}
  	 
  	for (cmptno = 0; cmptno < image->maxcmpts_; ++cmptno) {
  		image->cmpts_[cmptno] = 0;
  	}
  
 #if 0
  	 
  	rawsize = 0;
  	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
 	  ++cmptparm) {
 		rawsize += cmptparm->width * cmptparm->height *
 		  (cmptparm->prec + 7) / 8;
 	}
  	 
  	inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);
 #endif
  
  	 
  	for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
  	  ++cmptparm) {
 		if (!jas_safe_size_mul3(cmptparm->width, cmptparm->height,
 		  (cmptparm->prec + 7), &rawsize)) {
 			goto error;
 		}
 		rawsize /= 8;
 		inmem = (rawsize < JAS_IMAGE_INMEMTHRESH);
  		if (!(image->cmpts_[cmptno] = jas_image_cmpt_create(cmptparm->tlx,
  		  cmptparm->tly, cmptparm->hstep, cmptparm->vstep,
  		  cmptparm->width, cmptparm->height, cmptparm->prec,
  		  cmptparm->sgnd, inmem))) {
			jas_image_destroy(image);
			return 0;
 			goto error;
  		}
  		++image->numcmpts_;
  	}
 
 	 
  	jas_image_setbbox(image);
  
  	return image;
 
 error:
 	if (image) {
 		jas_image_destroy(image);
 	}
 	return 0;
  }","[6, 11, 12, 13, 14, 15, 18, 31, 38, 48, 53, 54, 55, 56, 57, 58, 65, 74, 75, 76, 77, 78, 79, 5, 17, 23, 29, 30, 63, 64]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
202721," uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)
 uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)
  {
  	mp4object *mp4 = (mp4object *)handle;
	if (mp4 == NULL) return 0;
 	if (mp4 == NULL) return GPMF_ERROR_MEMORY;
  
	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;
 	if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;
  
	*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
	*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
	return 0;
 	*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
 	*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);
 	return GPMF_OK;
  }","[2, 6, 9, 14, 15, 16, 5, 8, 11, 12, 13]",GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.
202233," static int piv_general_io(sc_card_t *card, int ins, int p1, int p2,
 	const u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf,
 	size_t * recvbuflen)
 {
 	int r;
 	sc_apdu_t apdu;
 	u8 rbufinitbuf[4096];
 	u8 *rbuf;
 	size_t rbuflen;
 	unsigned int cla_out, tag_out;
 	const u8 *body;
 	size_t bodylen;
 	int find_len = 0;
 	piv_private_data_t * priv = PIV_DATA(card);
 
 
 	SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);
 
 	sc_log(card->ctx,
 	       ""%02x %02x %02x %""SC_FORMAT_LEN_SIZE_T""u : %""SC_FORMAT_LEN_SIZE_T""u %""SC_FORMAT_LEN_SIZE_T""u"",
 	       ins, p1, p2, sendbuflen, card->max_send_size,
 	       card->max_recv_size);
 
 	rbuf = rbufinitbuf;
 	rbuflen = sizeof(rbufinitbuf);
 
 	 
 	if (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {
 		rbuf = *recvbuf;
 		rbuflen = *recvbuflen;
 	}
 
 	r = sc_lock(card);
 	if (r != SC_SUCCESS)
 		LOG_FUNC_RETURN(card->ctx, r);
 
 	sc_format_apdu(card, &apdu,
 			recvbuf ? SC_APDU_CASE_4_SHORT: SC_APDU_CASE_3_SHORT,
 			ins, p1, p2);
 	apdu.flags |= SC_APDU_FLAGS_CHAINING;
 	 
 	if (rbuflen == 8 && card->reader->active_protocol == SC_PROTO_T1) {
 		apdu.flags |= SC_APDU_FLAGS_NO_GET_RESP;
 		find_len = 1;
 	}
 
 	apdu.lc = sendbuflen;
 	apdu.datalen = sendbuflen;
 	apdu.data = sendbuf;
 
 	if (recvbuf) {
 		apdu.resp = rbuf;
 		apdu.le = (rbuflen > 256) ? 256 : rbuflen;
 		apdu.resplen = rbuflen;
 	} else {
 		 apdu.resp =  rbuf;
 		 apdu.le = 0;
 		 apdu.resplen = 0;
 	}
 
 	sc_log(card->ctx,
 	       ""calling sc_transmit_apdu flags=%lx le=%""SC_FORMAT_LEN_SIZE_T""u, resplen=%""SC_FORMAT_LEN_SIZE_T""u, resp=%p"",
 	       apdu.flags, apdu.le, apdu.resplen, apdu.resp);
 
 	 
 	r = sc_transmit_apdu(card, &apdu);
 
 	sc_log(card->ctx,
 	       ""DEE r=%d apdu.resplen=%""SC_FORMAT_LEN_SIZE_T""u sw1=%02x sw2=%02x"",
 	       r, apdu.resplen, apdu.sw1, apdu.sw2);
 	if (r < 0) {
 		sc_log(card->ctx, ""Transmit failed"");
 		goto err;
 	}
 
 	if (!(find_len && apdu.sw1 == 0x61))
 	    r = sc_check_sw(card, apdu.sw1, apdu.sw2);
 
  
 	if (r < 0) {
 		sc_log(card->ctx, ""Card returned error "");
 		goto err;
 	}
 
 	 
 
 
 	rbuflen = 0;   
 	 
 	if ( recvbuflen && recvbuf && apdu.resplen > 3 && priv->pin_cmd_noparse != 1) {
 		*recvbuflen = 0;
 		 
  
  		body = rbuf;
		if (sc_asn1_read_tag(&body, 0xffff, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS
 		if (sc_asn1_read_tag(&body, rbuflen, &cla_out, &tag_out, &bodylen) !=  SC_SUCCESS
  				|| body == NULL)  {
  			 
  			sc_log(card->ctx, ""***** received buffer tag MISSING "");
 			body = rbuf;
 			 
 			if (apdu.sw1 == 0x61  || apdu.sw2 == 0x6c )
 				bodylen = 12000;
 			else
 				bodylen = apdu.resplen;
 		}
 
 		rbuflen = body - rbuf + bodylen;
 
 		 
 		if (rbuf == rbufinitbuf) {
 			*recvbuf = malloc(rbuflen);
 			if (*recvbuf == NULL) {
 				r = SC_ERROR_OUT_OF_MEMORY;
 				goto err;
 			}
 
 			memcpy(*recvbuf, rbuf, rbuflen);  
 		}
 	}
 
 	if (recvbuflen) {
 		*recvbuflen =  rbuflen;
 		r = *recvbuflen;
 	}
 
 err:
 	sc_unlock(card);
 	LOG_FUNC_RETURN(card->ctx, r);
 }","[96, 95]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
204000,"   void MaybeRestoreIBusConfig() {
     if (!ibus_) {
       return;
     }
 
     MaybeDestroyIBusConfig();
 
      if (!ibus_config_) {
        GDBusConnection* ibus_connection = ibus_bus_get_connection(ibus_);
        if (!ibus_connection) {
        LOG(INFO) << ""Couldn't create an ibus config object since ""
                  << ""IBus connection is not ready."";
         VLOG(1) << ""Couldn't create an ibus config object since ""
                 << ""IBus connection is not ready."";
          return;
        }
        const gboolean disconnected
           = g_dbus_connection_is_closed(ibus_connection);
       if (disconnected) {
         LOG(ERROR) << ""Couldn't create an ibus config object since ""
                    << ""IBus connection is closed."";
         return;
       }
       ibus_config_ = ibus_config_new(ibus_connection,
                                      NULL  ,
                                      NULL  );
       if (!ibus_config_) {
         LOG(ERROR) << ""ibus_config_new() failed. ibus-memconf is not ready?"";
         return;
       }
 
        g_object_ref(ibus_config_);
      LOG(INFO) << ""ibus_config_ is ready."";
       VLOG(1) << ""ibus_config_ is ready."";
      }
    }","[13, 14, 34, 11, 12, 33]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
204710,"  void RenderViewImpl::OnAllowBindings(int enabled_bindings_flags) {
    enabled_bindings_ |= enabled_bindings_flags;
 
    
   RenderProcess::current()->AddBindings(enabled_bindings_flags);
  }","[3, 4, 5]","Google Chrome before 19.0.1084.46 does not use a dedicated process for the loading of links found on an internal page, which might allow attackers to bypass intended sandbox restrictions via a crafted page."
202473," static int read_entry(
 	git_index_entry **out,
 	size_t *out_size,
 	git_index *index,
 	const void *buffer,
 	size_t buffer_size,
 	const char *last)
 {
 	size_t path_length, entry_size;
 	const char *path_ptr;
 	struct entry_short source;
 	git_index_entry entry = {{0}};
 	bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;
 	char *tmp_path = NULL;
 
 	if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)
 		return -1;
 
 	 
 	memcpy(&source, buffer, sizeof(struct entry_short));
 
 	entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);
 	entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);
 	entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);
 	entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);
 	entry.dev = ntohl(source.dev);
 	entry.ino = ntohl(source.ino);
 	entry.mode = ntohl(source.mode);
 	entry.uid = ntohl(source.uid);
 	entry.gid = ntohl(source.gid);
 	entry.file_size = ntohl(source.file_size);
 	git_oid_cpy(&entry.id, &source.oid);
 	entry.flags = ntohs(source.flags);
 
 	if (entry.flags & GIT_IDXENTRY_EXTENDED) {
 		uint16_t flags_raw;
 		size_t flags_offset;
 
 		flags_offset = offsetof(struct entry_long, flags_extended);
 		memcpy(&flags_raw, (const char *) buffer + flags_offset,
 			sizeof(flags_raw));
 		flags_raw = ntohs(flags_raw);
 
 		memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));
 		path_ptr = (const char *) buffer + offsetof(struct entry_long, path);
 	} else
 		path_ptr = (const char *) buffer + offsetof(struct entry_short, path);
 
 	if (!compressed) {
 		path_length = entry.flags & GIT_IDXENTRY_NAMEMASK;
 
 		 
 		if (path_length == 0xFFF) {
 			const char *path_end;
 
 			path_end = memchr(path_ptr, '\0', buffer_size);
 			if (path_end == NULL)
 				return -1;
 
 			path_length = path_end - path_ptr;
 		}
 
  		entry_size = index_entry_size(path_length, 0, entry.flags);
  		entry.path = (char *)path_ptr;
  	} else {
		size_t varint_len;
		size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,
						     &varint_len);
		size_t last_len = strlen(last);
		size_t prefix_len = last_len - strip_len;
		size_t suffix_len = strlen(path_ptr + varint_len);
		size_t path_len;
		if (varint_len == 0)
 		size_t varint_len, last_len, prefix_len, suffix_len, path_len;
 		uintmax_t strip_len;
 
 		strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);
 		last_len = strlen(last);
 
 		if (varint_len == 0 || last_len < strip_len)
  			return index_error_invalid(""incorrect prefix length"");
  
 		prefix_len = last_len - strip_len;
 		suffix_len = strlen(path_ptr + varint_len);
 
  		GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);
  		GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);
  		tmp_path = git__malloc(path_len);
 		GITERR_CHECK_ALLOC(tmp_path);
 
 		memcpy(tmp_path, last, prefix_len);
 		memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);
 		entry_size = index_entry_size(suffix_len, varint_len, entry.flags);
 		entry.path = tmp_path;
 	}
 
 	if (entry_size == 0)
 		return -1;
 
 	if (INDEX_FOOTER_SIZE + entry_size > buffer_size)
 		return -1;
 
 	if (index_entry_dup(out, index, &entry) < 0) {
 		git__free(tmp_path);
 		return -1;
 	}
 
 	git__free(tmp_path);
 	*out_size = entry_size;
 	return 0;
 }","[74, 75, 76, 77, 78, 79, 80, 83, 84, 85, 66, 67, 68, 69, 70, 71, 72, 73]",Integer overflow in the index.c:read_entry() function while decompressing a compressed prefix length in libgit2 before v0.26.2 allows an attacker to cause a denial of service (out-of-bounds read) via a crafted repository index file.
202043," static void start_auth_request(PgSocket *client, const char *username)
 {
  	int res;
  	PktBuf *buf;
  
	client->auth_user = client->db->auth_user;
  	 
  	client->pool = get_pool(client->db, client->db->auth_user);
  	if (!find_server(client)) {
 		client->wait_for_user_conn = true;
 		return;
 	}
 	slog_noise(client, ""Doing auth_conn query"");
 	client->wait_for_user_conn = false;
 	client->wait_for_user = true;
 	if (!sbuf_pause(&client->sbuf)) {
 		release_server(client->link);
 		disconnect_client(client, true, ""pause failed"");
 		return;
 	}
 	client->link->ready = 0;
 
 	res = 0;
 	buf = pktbuf_dynamic(512);
 	if (buf) {
 		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
 		res = pktbuf_send_immediate(buf, client->link);
 		pktbuf_free(buf);
 		 
 	}
 	if (!res)
 		disconnect_server(client->link, false, ""unable to send login query"");
 }",[6],"PgBouncer 1.6.x before 1.6.1, when configured with auth_user, allows remote attackers to gain login access as auth_user via an unknown username."
205965,"   void ProcessControlLaunchFailed() {
   void ProcessControlLaunchFailed(base::OnceClosure on_done) {
      ADD_FAILURE();
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
     std::move(on_done).Run();
    }","[2, 6, 4, 5]","The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL."
9108,"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {
RList *bins = r_list_newf ((RListFree)free_bin);
ut16 *depArray = NULL;
cache_imgxtr_t *extras = NULL;
if (!bins) {
return NULL;
}

char *target_libs = NULL;
RList *target_lib_names = NULL;
int *deps = NULL;
target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER"");
if (target_libs) {
target_lib_names = r_str_split_list (target_libs, "":"", 0);
if (!target_lib_names) {
r_list_free (bins);
return NULL;
}
deps = R_NEWS0 (int, cache->hdr->imagesCount);
if (!deps) {
r_list_free (bins);
r_list_free (target_lib_names);
return NULL;
}
}

ut32 i;
for (i = 0; i < cache->n_hdr; i++) {
cache_hdr_t *hdr = &cache->hdr[i];
ut64 hdr_offset = cache->hdr_offset[i];
ut32 maps_index = cache->maps_index[i];
cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);
if (!img) {
goto next;
}

ut32 j;
if (target_libs) {
HtPU *path_to_idx = NULL;
if (cache->accel) {
depArray = R_NEWS0 (ut16, cache->accel->depListCount);
if (!depArray) {
goto next;
}

if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) {
goto next;
}

extras = read_cache_imgextra (cache->buf, hdr, cache->accel);
if (!extras) {
goto next;
}
} else {
path_to_idx = create_path_to_index (cache->buf, img, hdr);
}

for (j = 0; j < hdr->imagesCount; j++) {
bool printing = !deps[j];
char *lib_name = get_lib_name (cache->buf, &img[j]);
if (!lib_name) {
break;
}
if (strstr (lib_name, ""libobjc.A.dylib"")) {
deps[j]++;
}
if (!r_list_find (target_lib_names, lib_name, string_contains)) {
R_FREE (lib_name);
continue;
}
if (printing) {
eprintf (""FILTER: %s\n"", lib_name);
}
R_FREE (lib_name);
deps[j]++;

if (extras && depArray) {
ut32 k;
for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {
ut16 dep_index = depArray[k] & 0x7fff;
deps[dep_index]++;

char *dep_name = get_lib_name (cache->buf, &img[dep_index]);
if (!dep_name) {
break;
}
if (printing) {
eprintf (""-> %s\n"", dep_name);
}
free (dep_name);
}
} else if (path_to_idx) {
carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);
}
}

ht_pu_free (path_to_idx);
R_FREE (depArray);
R_FREE (extras);
}

for (j = 0; j < hdr->imagesCount; j++) {
if (deps && !deps[j]) {
continue;
}
ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);
if (pa == UT64_MAX) {
continue;
}
ut8 magicbytes[4];
r_buf_read_at (cache->buf, pa, magicbytes, 4);
int magic = r_read_le32 (magicbytes);
switch (magic) {
case MH_MAGIC_64:
{
char file[256];
RDyldBinImage *bin = R_NEW0 (RDyldBinImage);
if (!bin) {
goto next;
}
bin->header_at = pa;
bin->hdr_offset = hdr_offset;
bin->symbols_off = resolve_symbols_off (cache, pa);
bin->va = img[j].address;
if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {
file[255] = 0;
char *last_slash = strrchr (file, '/');
if (last_slash && *last_slash) {
if (last_slash > file) {
char *scan = last_slash - 1;
while (scan > file && *scan != '/') {
scan--;
}
if (*scan == '/') {
bin->file = strdup (scan + 1);
} else {
bin->file = strdup (last_slash + 1);
}
} else {
bin->file = strdup (last_slash + 1);
}
} else {
bin->file = strdup (file);
}
}
r_list_append (bins, bin);
break;
}
default:
eprintf (""Unknown sub-bin\n"");
break;
}
}
next:
R_FREE (depArray);
R_FREE (extras);
R_FREE (img);
}
if (r_list_empty (bins)) {
r_list_free (bins);
bins = NULL;
}
R_FREE (deps);
R_FREE (target_libs);
r_list_free (target_lib_names);
return bins;
}",[106],heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.
201232," int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,
 			     unsigned long size, bool kernel, bool pinned,
 			     struct virtio_gpu_object **bo_ptr)
 {
 	struct virtio_gpu_object *bo;
 	enum ttm_bo_type type;
 	size_t acc_size;
 	int ret;
 
 	if (kernel)
 		type = ttm_bo_type_kernel;
 	else
 		type = ttm_bo_type_device;
 	*bo_ptr = NULL;
 
 	acc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,
 				       sizeof(struct virtio_gpu_object));
 
 	bo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);
 	if (bo == NULL)
  		return -ENOMEM;
  	size = roundup(size, PAGE_SIZE);
  	ret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);
	if (ret != 0)
 	if (ret != 0) {
 		kfree(bo);
  		return ret;
 	}
  	bo->dumb = false;
  	virtio_gpu_init_ttm_placement(bo, pinned);
  
 	ret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,
 			  &bo->placement, 0, !kernel, NULL, acc_size,
 			  NULL, NULL, &virtio_gpu_ttm_bo_destroy);
 	 
 	if (ret != 0)
 		return ret;
 
 	*bo_ptr = bo;
 	return 0;
 }","[25, 26, 28, 24]",Memory leak in the virtio_gpu_object_create function in drivers/gpu/drm/virtio/virtgpu_object.c in the Linux kernel through 4.11.8 allows attackers to cause a denial of service (memory consumption) by triggering object-initialization failures.
3784,"bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)
{
int frameSize = afGetVirtualFrameSize(infile, trackid, 1);

const int kBufferFrameCount = 65536;
void *buffer = malloc(kBufferFrameCount * frameSize);

AFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);
AFframecount totalFramesWritten = 0;

bool success = true;

while (totalFramesWritten < totalFrames)
{
AFframecount framesToRead = totalFrames - totalFramesWritten;
if (framesToRead > kBufferFrameCount)
framesToRead = kBufferFrameCount;

AFframecount framesRead = afReadFrames(infile, trackid, buffer,
framesToRead);

if (framesRead < framesToRead)
{
fprintf(stderr, ""Bad read of audio track data.\n"");
success = false;
break;
}

AFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,
framesRead);

if (framesWritten < framesRead)
{
fprintf(stderr, ""Bad write of audio track data.\n"");
success = false;
break;
}

totalFramesWritten += framesWritten;
}

free(buffer);

return success;
}","[5, 6]",Integer overflow in sfcommands/sfconvert.c in Audio File Library (aka audiofile) 0.3.6 allows remote attackers to cause a denial of service (crash) via a crafted file.
203183," static Image *ReadWPGImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   typedef struct
   {
     size_t FileId;
     MagickOffsetType DataOffset;
     unsigned int ProductType;
     unsigned int FileType;
     unsigned char MajorVersion;
     unsigned char MinorVersion;
     unsigned int EncryptKey;
     unsigned int Reserved;
   } WPGHeader;
 
   typedef struct
   {
     unsigned char RecType;
     size_t RecordLength;
   } WPGRecord;
 
   typedef struct
   {
     unsigned char Class;
     unsigned char RecType;
     size_t Extension;
     size_t RecordLength;
   } WPG2Record;
 
   typedef struct
   {
     unsigned  HorizontalUnits;
     unsigned  VerticalUnits;
     unsigned char PosSizePrecision;
   } WPG2Start;
 
   typedef struct
   {
     unsigned int Width;
     unsigned int Height;
     unsigned int Depth;
     unsigned int HorzRes;
     unsigned int VertRes;
   } WPGBitmapType1;
 
   typedef struct
   {
     unsigned int Width;
     unsigned int Height;
     unsigned char Depth;
     unsigned char Compression;
   } WPG2BitmapType1;
 
   typedef struct
   {
     unsigned int RotAngle;
     unsigned int LowLeftX;
     unsigned int LowLeftY;
     unsigned int UpRightX;
     unsigned int UpRightY;
     unsigned int Width;
     unsigned int Height;
     unsigned int Depth;
     unsigned int HorzRes;
     unsigned int VertRes;
   } WPGBitmapType2;
 
   typedef struct
   {
     unsigned int StartIndex;
     unsigned int NumOfEntries;
   } WPGColorMapRec;
 
    
 
   Image
     *image;
 
   unsigned int
     status;
 
   WPGHeader
     Header;
 
   WPGRecord
     Rec;
 
   WPG2Record
     Rec2;
 
   WPG2Start StartWPG;
 
   WPGBitmapType1
     BitmapHeader1;
 
   WPG2BitmapType1
     Bitmap2Header1;
 
   WPGBitmapType2
     BitmapHeader2;
 
   WPGColorMapRec
     WPG_Palette;
 
   int
     i,
     bpp,
     WPG2Flags;
 
   ssize_t
     ldblk;
 
   size_t
     one;
 
   unsigned char
     *BImgBuff;
 
   tCTM CTM;          
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   one=1;
   image=AcquireImage(image_info);
   image->depth=8;
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   Header.FileId=ReadBlobLSBLong(image);
   Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);
   Header.ProductType=ReadBlobLSBShort(image);
   Header.FileType=ReadBlobLSBShort(image);
   Header.MajorVersion=ReadBlobByte(image);
   Header.MinorVersion=ReadBlobByte(image);
   Header.EncryptKey=ReadBlobLSBShort(image);
   Header.Reserved=ReadBlobLSBShort(image);
 
   if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (Header.EncryptKey!=0)
     ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported"");
 
   image->columns = 1;
   image->rows = 1;
   image->colors = 0;
   bpp=0;
   BitmapHeader2.RotAngle=0;
   Rec2.RecordLength = 0;
 
   switch(Header.FileType)
     {
     case 1:      
       while(!EOFBlob(image))  
         {
           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
           if(EOFBlob(image))
             break;
 
           Rec.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec.RecordLength);
           if (Rec.RecordLength > GetBlobSize(image))
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           if(EOFBlob(image))
             break;
 
           Header.DataOffset=TellBlob(image)+Rec.RecordLength;
 
           switch(Rec.RecType)
             {
             case 0x0B:  
               BitmapHeader1.Width=ReadBlobLSBShort(image);
               BitmapHeader1.Height=ReadBlobLSBShort(image);
               if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               BitmapHeader1.Depth=ReadBlobLSBShort(image);
               BitmapHeader1.HorzRes=ReadBlobLSBShort(image);
               BitmapHeader1.VertRes=ReadBlobLSBShort(image);
 
               if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)
                 {
                   image->units=PixelsPerCentimeterResolution;
                   image->x_resolution=BitmapHeader1.HorzRes/470.0;
                   image->y_resolution=BitmapHeader1.VertRes/470.0;
                 }
               image->columns=BitmapHeader1.Width;
               image->rows=BitmapHeader1.Height;
               bpp=BitmapHeader1.Depth;
 
               goto UnpackRaster;
 
             case 0x0E:   
               WPG_Palette.StartIndex=ReadBlobLSBShort(image);
               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
                if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                    (Rec2.RecordLength-2-2) / 3)
                  ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
               if (WPG_Palette.StartIndex > WPG_Palette.NumOfEntries)
                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
                image->colors=WPG_Palette.NumOfEntries;
                if (!AcquireImageColormap(image,image->colors))
                  goto NoMemory;
               for (i=WPG_Palette.StartIndex;
                    i < (int)WPG_Palette.NumOfEntries; i++)
                 {
                   image->colormap[i].red=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                   image->colormap[i].green=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                   image->colormap[i].blue=ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image));
                 }
               break;
 
             case 0x11:   
               if(Rec.RecordLength > 8)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+8,    
                   (ssize_t) Rec.RecordLength-8,exception);
               break;
 
             case 0x14:   
               BitmapHeader2.RotAngle=ReadBlobLSBShort(image);
               BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);
               BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);
               BitmapHeader2.UpRightX=ReadBlobLSBShort(image);
               BitmapHeader2.UpRightY=ReadBlobLSBShort(image);
               BitmapHeader2.Width=ReadBlobLSBShort(image);
               BitmapHeader2.Height=ReadBlobLSBShort(image);
               if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               BitmapHeader2.Depth=ReadBlobLSBShort(image);
               BitmapHeader2.HorzRes=ReadBlobLSBShort(image);
               BitmapHeader2.VertRes=ReadBlobLSBShort(image);
 
               image->units=PixelsPerCentimeterResolution;
               image->page.width=(unsigned int)
                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);
               image->page.height=(unsigned int)
                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);
               image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);
               image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);
               if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)
                 {
                   image->x_resolution=BitmapHeader2.HorzRes/470.0;
                   image->y_resolution=BitmapHeader2.VertRes/470.0;
                 }
               image->columns=BitmapHeader2.Width;
               image->rows=BitmapHeader2.Height;
               bpp=BitmapHeader2.Depth;
 
             UnpackRaster:
               status=SetImageExtent(image,image->columns,image->rows);
               if (status == MagickFalse)
                 break;
               if ((image->colors == 0) && (bpp <= 16))
                 {
                   image->colors=one << bpp;
                   if (!AcquireImageColormap(image,image->colors))
                     {
                     NoMemory:
                       ThrowReaderException(ResourceLimitError,
                         ""MemoryAllocationFailed"");
                     }
                    
                   for (i=0; (i < (int) image->colors) && (i < 256); i++)
                     {
                       image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);
                       image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);
                       image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);
                     }
                 }
               else
                 {
                   if (bpp < 24)
                     if ( (image->colors < (one << bpp)) && (bpp != 24) )
                       image->colormap=(PixelPacket *) ResizeQuantumMemory(
                         image->colormap,(size_t) (one << bpp),
                         sizeof(*image->colormap));
                 }
 
               if (bpp == 1)
                 {
                   if(image->colormap[0].red==0 &&
                      image->colormap[0].green==0 &&
                      image->colormap[0].blue==0 &&
                      image->colormap[1].red==0 &&
                      image->colormap[1].green==0 &&
                      image->colormap[1].blue==0)
                     {   
                       image->colormap[1].red =
                         image->colormap[1].green =
                         image->colormap[1].blue = QuantumRange;
                     }
                 }
 
               if(UnpackWPGRaster(image,bpp) < 0)
                  
                 {
                 DecompressionFailed:
                   ThrowReaderException(CoderError,""UnableToDecompressImage"");
                     }
 
               if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)
                 {
                    
                   if(BitmapHeader2.RotAngle & 0x8000)
                     {
                       Image
                         *flop_image;
 
                       flop_image = FlopImage(image, exception);
                       if (flop_image != (Image *) NULL) {
                         DuplicateBlob(flop_image,image);
                         ReplaceImageInList(&image,flop_image);
                       }
                     }
                    
                   if(BitmapHeader2.RotAngle & 0x2000)
                     {
                       Image
                         *flip_image;
 
                       flip_image = FlipImage(image, exception);
                       if (flip_image != (Image *) NULL) {
                         DuplicateBlob(flip_image,image);
                         ReplaceImageInList(&image,flip_image);
                       }
                     }
                    
                   if(BitmapHeader2.RotAngle & 0x0FFF)
                     {
                       Image
                         *rotate_image;
 
                       rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &
                         0x0FFF), exception);
                       if (rotate_image != (Image *) NULL) {
                         DuplicateBlob(rotate_image,image);
                         ReplaceImageInList(&image,rotate_image);
                       }
                     }
                 }
 
                
               AcquireNextImage(image_info,image);
               image->depth=8;
               if (image->next == (Image *) NULL)
                 goto Finish;
               image=SyncNextImageInList(image);
               image->columns=image->rows=1;
               image->colors=0;
               break;
 
             case 0x1B:   
               if(Rec.RecordLength>0x3C)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+0x3C,    
                   (ssize_t) Rec.RecordLength-0x3C,exception);
               break;
             }
         }
       break;
 
     case 2:   
       (void) memset(CTM,0,sizeof(CTM));
       StartWPG.PosSizePrecision = 0;
       while(!EOFBlob(image))  
         {
           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);
           if(EOFBlob(image))
             break;
 
           Rec2.Class=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rec2.RecType=(i=ReadBlobByte(image));
           if(i==EOF)
             break;
           Rd_WP_DWORD(image,&Rec2.Extension);
           Rd_WP_DWORD(image,&Rec2.RecordLength);
           if(EOFBlob(image))
             break;
 
           Header.DataOffset=TellBlob(image)+Rec2.RecordLength;
 
           switch(Rec2.RecType)
             {
       case 1:
               StartWPG.HorizontalUnits=ReadBlobLSBShort(image);
               StartWPG.VerticalUnits=ReadBlobLSBShort(image);
               StartWPG.PosSizePrecision=ReadBlobByte(image);
               break;
             case 0x0C:     
               WPG_Palette.StartIndex=ReadBlobLSBShort(image);
               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);
               if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) >
                   (Rec2.RecordLength-2-2) / 3)
                 ThrowReaderException(CorruptImageError,""InvalidColormapIndex"");
               image->colors=WPG_Palette.NumOfEntries;
               if (AcquireImageColormap(image,image->colors) == MagickFalse)
                 ThrowReaderException(ResourceLimitError,
                   ""MemoryAllocationFailed"");
               for (i=WPG_Palette.StartIndex;
                    i < (int)WPG_Palette.NumOfEntries; i++)
                 {
                   image->colormap[i].red=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   image->colormap[i].green=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   image->colormap[i].blue=ScaleCharToQuantum((char)
                     ReadBlobByte(image));
                   (void) ReadBlobByte(image);    
                 }
               break;
             case 0x0E:
               Bitmap2Header1.Width=ReadBlobLSBShort(image);
               Bitmap2Header1.Height=ReadBlobLSBShort(image);
               if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))
                 ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
               Bitmap2Header1.Depth=ReadBlobByte(image);
               Bitmap2Header1.Compression=ReadBlobByte(image);
 
               if(Bitmap2Header1.Compression > 1)
                 continue;  
               switch(Bitmap2Header1.Depth)
                 {
                 case 1:
                   bpp=1;
                   break;
                 case 2:
                   bpp=2;
                   break;
                 case 3:
                   bpp=4;
                   break;
                 case 4:
                   bpp=8;
                   break;
                 case 8:
                   bpp=24;
                   break;
                 default:
                   continue;   
                 }
               image->columns=Bitmap2Header1.Width;
               image->rows=Bitmap2Header1.Height;
               status=SetImageExtent(image,image->columns,image->rows);
               if (status == MagickFalse)
                 break;
               if ((image->colors == 0) && (bpp != 24))
                 {
                   size_t
                     one;
 
                   one=1;
                   image->colors=one << bpp;
                   if (!AcquireImageColormap(image,image->colors))
                     goto NoMemory;
                 }
               else
                 {
                   if(bpp < 24)
                     if( image->colors<(one << bpp) && bpp!=24 )
                       image->colormap=(PixelPacket *) ResizeQuantumMemory(
                        image->colormap,(size_t) (one << bpp),
                        sizeof(*image->colormap));
                 }
 
 
               switch(Bitmap2Header1.Compression)
                 {
                 case 0:     
                   {
                     ldblk=(ssize_t) ((bpp*image->columns+7)/8);
                     BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)
                       ldblk+1,sizeof(*BImgBuff));
                     if (BImgBuff == (unsigned char *) NULL)
                       goto NoMemory;
 
                     for(i=0; i< (ssize_t) image->rows; i++)
                       {
                         (void) ReadBlob(image,ldblk,BImgBuff);
                         InsertRow(BImgBuff,i,image,bpp);
                       }
 
                     if(BImgBuff)
                       BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
                     break;
                   }
                 case 1:     
                   {
                     if( UnpackWPG2Raster(image,bpp) < 0)
                       goto DecompressionFailed;
                     break;
                   }
                 }
 
               if(CTM[0][0]<0 && !image_info->ping)
                 {     
                   Image
                     *flop_image;
 
                   flop_image = FlopImage(image, exception);
                   if (flop_image != (Image *) NULL) {
                     DuplicateBlob(flop_image,image);
                     ReplaceImageInList(&image,flop_image);
                   }
                    
                 }
               if(CTM[1][1]<0 && !image_info->ping)
                 {     
                   Image
                     *flip_image;
 
                   flip_image = FlipImage(image, exception);
                   if (flip_image != (Image *) NULL) {
                     DuplicateBlob(flip_image,image);
                     ReplaceImageInList(&image,flip_image);
                   }
                    
                 }
 
 
                
               AcquireNextImage(image_info,image);
               image->depth=8;
               if (image->next == (Image *) NULL)
                 goto Finish;
               image=SyncNextImageInList(image);
               image->columns=image->rows=1;
               image->colors=0;
               break;
 
             case 0x12:   
         i=ReadBlobLSBShort(image);
               if(Rec2.RecordLength > (unsigned int) i)
                 image=ExtractPostscript(image,image_info,
                   TellBlob(image)+i,     
                   (ssize_t) (Rec2.RecordLength-i-2),exception);
               break;
 
       case 0x1B:           
               WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);
               (void) WPG2Flags;
               break;
             }
         }
 
       break;
 
     default:
       {
          ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
       }
    }
 
  Finish:
   (void) CloseBlob(image);
 
   {
     Image
       *p;
 
     ssize_t
       scene=0;
 
      
     p=image;
     image=NULL;
     while (p != (Image *) NULL)
       {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
           p=p->previous;
         }
       }
      
     for (p=image; p != (Image *) NULL; p=p->next)
       p->scene=(size_t) scene++;
   }
   if (image == (Image *) NULL)
     ThrowReaderException(CorruptImageError,
       ""ImageFileDoesNotContainAnyImageData"");
   return(image);
 }","[206, 207]","The ReadWPGImage function in coders/wpg.c in ImageMagick 7.0.7-9 does not properly validate the colormap index in a WPG palette, which allows remote attackers to cause a denial of service (use of uninitialized data or invalid memory allocation) or possibly have unspecified other impact via a malformed WPG file."
201577," ModuleExport MagickBooleanType ReadPSDLayers(Image *image,
   const ImageInfo *image_info,const PSDInfo *psd_info,
   const MagickBooleanType skip_layers,ExceptionInfo *exception)
 {
   char
     type[4];
 
   LayerInfo
     *layer_info;
 
   MagickSizeType
     size;
 
   MagickBooleanType
     status;
 
   register ssize_t
     i;
 
   ssize_t
     count,
     j,
     number_layers;
 
   size=GetPSDSize(psd_info,image);
   if (size == 0)
     {
        
       (void) ReadBlobLong(image);
       count=ReadBlob(image,4,(unsigned char *) type);
       ReversePSDString(image,type,4);
       status=MagickFalse;
       if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
         return(MagickTrue);
       else
         {
           count=ReadBlob(image,4,(unsigned char *) type);
           ReversePSDString(image,type,4);
           if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
             size=GetPSDSize(psd_info,image);
           else
             return(MagickTrue);
         }
     }
   status=MagickTrue;
   if (size != 0)
     {
       layer_info=(LayerInfo *) NULL;
       number_layers=(short) ReadBlobShort(image);
 
       if (number_layers < 0)
         {
            
           number_layers=MagickAbsoluteValue(number_layers);
           if (image->debug != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  negative layer count corrected for"");
           image->alpha_trait=BlendPixelTrait;
         }
 
        
       if (skip_layers != MagickFalse)
         return(MagickTrue);
 
       if (image->debug != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  image contains %.20g layers"",(double) number_layers);
 
       if (number_layers == 0)
         ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
           image->filename);
 
       layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
         sizeof(*layer_info));
       if (layer_info == (LayerInfo *) NULL)
         {
           if (image->debug != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  allocation of LayerInfo failed"");
           ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
             image->filename);
         }
       (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
         sizeof(*layer_info));
 
       for (i=0; i < number_layers; i++)
       {
         ssize_t
           x,
           y;
 
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  reading layer #%.20g"",(double) i+1);
         layer_info[i].page.y=ReadBlobSignedLong(image);
         layer_info[i].page.x=ReadBlobSignedLong(image);
         y=ReadBlobSignedLong(image);
         x=ReadBlobSignedLong(image);
         layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
         layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
         layer_info[i].channels=ReadBlobShort(image);
         if (layer_info[i].channels > MaxPSDChannels)
           {
             layer_info=DestroyLayerInfo(layer_info,number_layers);
             ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
               image->filename);
           }
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
             (double) layer_info[i].page.x,(double) layer_info[i].page.y,
             (double) layer_info[i].page.height,(double)
             layer_info[i].page.width,(double) layer_info[i].channels);
         for (j=0; j < (ssize_t) layer_info[i].channels; j++)
         {
           layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
           layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
             image);
           if (image->debug != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
               (double) layer_info[i].channel_info[j].type,
               (double) layer_info[i].channel_info[j].size);
         }
         count=ReadBlob(image,4,(unsigned char *) type);
         ReversePSDString(image,type,4);
         if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
           {
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  layer type was %.4s instead of 8BIM"", type);
             layer_info=DestroyLayerInfo(layer_info,number_layers);
             ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
               image->filename);
           }
         count=ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
         ReversePSDString(image,layer_info[i].blendkey,4);
         layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
           ReadBlobByte(image));
         layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
         layer_info[i].flags=(unsigned char) ReadBlobByte(image);
         layer_info[i].visible=!(layer_info[i].flags & 0x02);
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
             layer_info[i].blendkey,(double) layer_info[i].opacity,
             layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
             layer_info[i].visible ? ""true"" : ""false"");
         (void) ReadBlobByte(image);   
 
         size=ReadBlobLong(image);
         if (size != 0)
           {
             MagickSizeType
               combined_length,
               length;
 
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    layer contains additional info"");
             length=ReadBlobLong(image);
             combined_length=length+4;
             if (length != 0)
               {
                  
                 layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                 layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                 layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-
                   layer_info[i].mask.page.y);
                 layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-
                   layer_info[i].mask.page.x);
                 layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                   image);
                 layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                 if (!(layer_info[i].mask.flags & 0x01))
                   {
                     layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                       layer_info[i].page.y;
                     layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                       layer_info[i].page.x;
                   }
                 if (image->debug != MagickFalse)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                     (double) layer_info[i].mask.page.x,(double) 
                     layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                     (double) layer_info[i].mask.page.height,(double)
                     ((MagickOffsetType) length)-18);
                  
                  if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                     ThrowBinaryException(CorruptImageError,
                       ""UnexpectedEndOfFile"",image->filename);
                    }
                }
              length=ReadBlobLong(image);
             combined_length+=length+4;
             if (length != 0)
               {
                  
                 if (image->debug != MagickFalse)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      layer blending ranges: length=%.20g"",(double)
                     ((MagickOffsetType) length));
                  
                 for (j=0; j < (ssize_t) length; j+=8)
                 {
                   size_t blend_source=ReadBlobLong(image);
                   size_t blend_dest=ReadBlobLong(image);
                   if (image->debug != MagickFalse)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""        source(%x), dest(%x)"",(unsigned int)
                       blend_source,(unsigned int) blend_dest);
                 }
               }
              
             length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
             combined_length+=length+1;
             if (length > 0)
               (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
             layer_info[i].name[length]='\0';
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer name: %s"",layer_info[i].name);
             if ((length % 4) != 0)
               {
                 length=4-(length % 4);
                 combined_length+=length;
                  
                 if (DiscardBlobBytes(image,length) == MagickFalse)
                   {
                     layer_info=DestroyLayerInfo(layer_info,number_layers);
                     ThrowBinaryException(CorruptImageError,
                       ""UnexpectedEndOfFile"",image->filename);
                   }
               }
             length=(MagickSizeType) size-combined_length;
             if (length > 0)
               {
                 unsigned char
                   *info;
 
                 layer_info[i].info=AcquireStringInfo((const size_t) length);
                 info=GetStringInfoDatum(layer_info[i].info);
                 (void) ReadBlob(image,(const size_t) length,info);
               }
           }
       }
 
       for (i=0; i < number_layers; i++)
       {
         if ((layer_info[i].page.width == 0) ||
               (layer_info[i].page.height == 0))
           {
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""      layer data is empty"");
             if (layer_info[i].info != (StringInfo *) NULL)
               layer_info[i].info=DestroyStringInfo(layer_info[i].info);
             continue;
           }
 
          
         layer_info[i].image=CloneImage(image,layer_info[i].page.width,
           layer_info[i].page.height,MagickFalse,exception);
         if (layer_info[i].image == (Image *) NULL)
           {
             layer_info=DestroyLayerInfo(layer_info,number_layers);
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  allocation of image for layer %.20g failed"",(double) i);
             ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
               image->filename);
           }
 
         if (layer_info[i].info != (StringInfo *) NULL)
           {
             (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
               layer_info[i].info,exception);
             layer_info[i].info=DestroyStringInfo(layer_info[i].info);
           }
       }
 
       if (image_info->ping == MagickFalse)
         {
           for (i=0; i < number_layers; i++)
           {
             if (layer_info[i].image == (Image *) NULL)
               {
                 for (j=0; j < layer_info[i].channels; j++)
                 {
                   if (DiscardBlobBytes(image,(MagickSizeType)
                       layer_info[i].channel_info[j].size) == MagickFalse)
                     {
                       layer_info=DestroyLayerInfo(layer_info,number_layers);
                       ThrowBinaryException(CorruptImageError,
                         ""UnexpectedEndOfFile"",image->filename);
                     }
                 }
                 continue;
               }
 
             if (image->debug != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  reading data for layer %.20g"",(double) i);
 
             status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
               exception);
             if (status == MagickFalse)
               break;
 
             status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
               number_layers);
             if (status == MagickFalse)
               break;
           }
         }
 
       if (status != MagickFalse)
         {
           for (i=0; i < number_layers; i++)
           {
             if (layer_info[i].image == (Image *) NULL)
               {
                 for (j=i; j < number_layers - 1; j++)
                   layer_info[j] = layer_info[j+1];
                 number_layers--;
                 i--;
               }
           }
 
           if (number_layers > 0)
             {
               for (i=0; i < number_layers; i++)
               {
                 if (i > 0)
                   layer_info[i].image->previous=layer_info[i-1].image;
                 if (i < (number_layers-1))
                   layer_info[i].image->next=layer_info[i+1].image;
                 layer_info[i].image->page=layer_info[i].page;
               }
               image->next=layer_info[0].image;
               layer_info[0].image->previous=image;
             }
           layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
         }
       else
         layer_info=DestroyLayerInfo(layer_info,number_layers);
     }
 
   return(status);
 }","[195, 196, 193, 194]","coders/psd.c in ImageMagick allows remote attackers to have unspecified impact via a crafted PSD file, which triggers an out-of-bounds write."
8823,"void CPCIDSKBinarySegment::Load()
{

if (loaded_) {
return;
}

seg_data.SetSize((int)data_size - 1024);

ReadFromFile(seg_data.buffer, 0, data_size - 1024);


loaded_ = true;
}","[8, 8]",GDAL 3.3.0 through 3.4.0 has a heap-based buffer overflow in PCIDSK::CPCIDSKFile::ReadFromFile (called from PCIDSK::CPCIDSKSegment::ReadFromFile and PCIDSK::CPCIDSKBinarySegment::CPCIDSKBinarySegment).
197846,"  char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)
  {
         char *dst;
        size_t len;
         if (!value.length)
                 return NULL;
  
 	 
 	dst = talloc_array(mem_ctx, char, value.length * 3 + 1);
 	if ( ! dst) {
 		talloc_free(dst);
                 return NULL;
         }
  
       ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
       dst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);
        len = ldb_dn_escape_internal(dst, (const char *)value.data, value.length);
  
        dst = talloc_realloc(mem_ctx, dst, char, len + 1);
        if ( ! dst) {
                talloc_free(dst);
                return NULL;
        }
        dst[len] = '\0';
         return dst;
  }","[4, 17, 19, 20, 21, 22, 23, 24, 15, 16]","ldb before 1.1.24, as used in the AD LDAP server in Samba 4.x before 4.1.22, 4.2.x before 4.2.7, and 4.3.x before 4.3.3, mishandles string lengths, which allows remote attackers to obtain sensitive information from daemon heap memory by sending crafted packets and then reading (1) an error message or (2) a database value."
5376,"int data_on_connection(int fd, callback_remove_handler remove)
{
int nread;
char *network_packet;
char network_line[8192];
char *p;
unsigned long id;

char string[1024];
unsigned long msg_id = UINT32_MAX;
enum network_protocol version = network_client_get_version(fd);

ioctl(fd, FIONREAD, &nread);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""new connection data = %d\n"",nread);

if(nread == 0)
{
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""%d failed, got 0 close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
network_client_dump ();
return 0;
}


if ( nread >= 8192 ) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, more than 8192 close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);

return 0;
}


network_packet=malloc((nread+1) * sizeof(char));
read(fd, network_packet, nread);
network_packet[nread]='\0';

memset(network_line, 0, 8192);
p=network_packet;
p_sem(sem_id);

while ( get_network_line(p, network_line) ) {

if ( strlen(network_line) > 0 ) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""line = [%s]"",network_line);
}


if ( !strncmp(network_line, ""MSGID: "", strlen(""MSGID: "")) ) {


msg_id=strtoul(&(network_line[strlen(""MSGID: "")]), NULL, 10);

p+=strlen(network_line);


} else if ( !strncmp(network_line, ""Version: "", strlen(""Version: "")) ) {
char *head = network_line, *end;

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: VERSION"");

version = strtoul(head + 9, &end, 10);
if (!head[9] || *end)
goto failed;

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""VERSION=%d"", version);

if (version < network_procotol_version) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Forbidden VERSION=%d < %d, close connection to listener"", version, network_procotol_version);
goto close;
} else if (version >= PROTOCOL_LAST) {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Future VERSION=%d"", version);
version = PROTOCOL_LAST - 1;
}
network_client_set_version(fd, version);


msg_id = UINT32_MAX;

p+=strlen(network_line);


} else if ( !strncmp(network_line, ""Capabilities: "", strlen(""Capabilities: "")) ) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: Capabilities"");

if ( version > PROTOCOL_UNKNOWN ) {

memset(string, 0, sizeof(string));

snprintf(string, sizeof(string), ""Version: %d\nCapabilities: \n\n"", version);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""SEND: %s"", string);

write(fd, string, strlen(string));

} else {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""Capabilities recv, but no version line"");

}

p+=strlen(network_line);


} else if ( !strncmp(network_line, ""GET_DN "", strlen(""GET_DN "")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_DN"");

id=strtoul(&(network_line[strlen(""GET_DN "")]), NULL, 10);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"",id);

if ( id <= notify_last_id.id) {

char *dn_string = NULL;

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""try to read %ld from cache"", id);


if ( (dn_string = notifier_cache_get(id)) == NULL ) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld not found in cache"", id);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld get one dn"", id);


if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld failed "", id);


univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, close connection to listener "", fd);
close(fd);
FD_CLR(fd, &readfds);
remove(fd);

return 0;
}
}

if ( dn_string != NULL ) {

snprintf(string, sizeof(string), ""MSGID: %ld\n%s\n\n"",msg_id,dn_string);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);

write(fd, string, strlen(string));

free(dn_string);

}


} else {


network_client_set_next_id(fd, id);
network_client_set_msg_id(fd, msg_id);

}

p+=strlen(network_line)+1;
msg_id = UINT32_MAX;

} else if (!strncmp(p, ""WAIT_ID "", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {
char *head = network_line, *end;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: WAIT_ID"");
id = strtoul(head + 8, &end, 10);
if (!head[8] || *end)
goto failed;
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"", id);

if (id <= notify_last_id.id) {
snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"", msg_id, notify_last_id.id);
write(fd, string, strlen(string));
} else {

network_client_set_next_id(fd, id);
network_client_set_msg_id(fd, msg_id);
}

p += strlen(network_line) + 1;
msg_id = UINT32_MAX;

} else if ( !strncmp(network_line, ""GET_ID"", strlen(""GET_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_ID"");

memset(string, 0, sizeof(string));

snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,notify_last_id.id);

write(fd, string, strlen(string));

p+=strlen(network_line)+1;
msg_id = UINT32_MAX;


} else if ( !strncmp(network_line, ""GET_SCHEMA_ID"", strlen(""GET_SCHEMA_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_SCHEMA_ID"");

memset(string, 0, sizeof(string));

snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,SCHEMA_ID);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);

write(fd, string, strlen(string));

p+=strlen(network_line)+1;
msg_id = UINT32_MAX;


} else if ( !strncmp(network_line, ""ALIVE"", strlen(""ALIVE"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: ALIVE"");

snprintf(string, sizeof(string), ""MSGID: %ld\nOKAY\n\n"",msg_id);

write(fd, string, strlen(string));

p+=strlen(network_line)+1;
msg_id = UINT32_MAX;

} else {

p+=strlen(network_line);

if (strlen(network_line) == 0 ) {
p+=1;
} else {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""Drop package [%s]"", network_line);
}

}
}
v_sem(sem_id);

univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""END Package"");


network_client_dump ();

return 0;

failed:
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Failed parsing [%s]"", p);
close:
close(fd);
FD_CLR(fd, &readfds);
remove(fd);
return 0;
}",[111],Univention Corporate Server univention-directory-notifier 12.0.1-3 and earlier is affected by: CWE-213: Intentional Information Exposure. The impact is: Loss of Confidentiality. The component is: function data_on_connection() in src/callback.c. The attack vector is: network connectivity. The fixed version is: 12.0.1-4 and later.
201525," parse_file (FILE* input_file, char* directory, 
 	    char *body_filename, char *body_pref,
 	    int flags)
 {
     uint32 d;
     uint16 key;
     Attr *attr = NULL;
     File *file = NULL;
     int rtf_size = 0, html_size = 0;
     MessageBody body;
     memset (&body, '\0', sizeof (MessageBody));
 
      
     g_flags = flags;
 
      
     d = geti32(input_file);
     if (d != TNEF_SIGNATURE)
     {
 	fprintf (stdout, ""Seems not to be a TNEF file\n"");
 	return 1;
     }
 
      
     key = geti16(input_file);
     debug_print (""TNEF Key: %hx\n"", key);
 
      
     while ( data_left( input_file ) )
     {
 	attr = read_object( input_file );
 
 	if ( attr == NULL ) break;
 
 	 
 	if (attr->name == attATTACHRENDDATA)
 	{
 	    if (file)
 	    {
 		file_write (file, directory);
 		file_free (file);
 	    }
 	    else
 	    {
 		file = CHECKED_XCALLOC (File, 1);
 	    }
 	}
 
 	 
 	switch (attr->lvl_type)
 	{
 	case LVL_MESSAGE:
 	    if (attr->name == attBODY)
 	    {
 		body.text_body = get_text_data (attr);
 	    }
 	    else if (attr->name == attMAPIPROPS) 
 	    { 
 		MAPI_Attr **mapi_attrs 
 		    = mapi_attr_read (attr->len, attr->buf); 
 		if (mapi_attrs)
 		{ 
 		    int i;
  		    for (i = 0; mapi_attrs[i]; i++)
  		    {
  			MAPI_Attr *a = mapi_attrs[i];
			if (a->name == MAPI_BODY_HTML)
 		
 			if (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)
  			{
  			    body.html_bodies = get_html_data (a);
                                  html_size = a->num_values;
  			}
			else if (a->name == MAPI_RTF_COMPRESSED)
 			else if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)
  			{
  			    body.rtf_bodies = get_rtf_data (a);
                                  rtf_size = a->num_values;
 			}
 		    }
 		      
 		     
 		    mapi_attr_free_list (mapi_attrs); 
 		    XFREE (mapi_attrs); 
 		}
 	    }
 	    break;
 	case LVL_ATTACHMENT:
 	    file_add_attr (file, attr);
 	    break;
 	default:
 	    fprintf (stderr, ""Invalid lvl type on attribute: %d\n"",
 		     attr->lvl_type);
 	    return 1;
 	    break;
 	}
 	attr_free (attr);
 	XFREE (attr);
     }
 
     if (file)
     {
 	file_write (file, directory);
 	file_free (file);
 	XFREE (file);
     }
     
      
     if (flags & SAVEBODY)
     {
 	int i = 0;
 	int all_flag = 0;
 	if (strcmp (body_pref, ""all"") == 0) 
 	{
 	    all_flag = 1;
 	    body_pref = ""rht"";
 	}
 
 	for (; i < 3; i++)
 	{
 	    File **files
 		= get_body_files (body_filename, body_pref[i], &body);
 	    if (files)
 	    {
 		int j = 0; 
 		for (; files[j]; j++)
 		{
 		    file_write(files[j], directory);
 		    file_free (files[j]);
                     XFREE(files[j]);
 		}
 		XFREE(files);
 		if (!all_flag) break;
 	    }
 	}
     }
 
     if (body.text_body)
     {
         free_bodies(body.text_body, 1);
         XFREE(body.text_body);
     }
     if (rtf_size > 0)
     {
         free_bodies(body.rtf_bodies, rtf_size);
         XFREE(body.rtf_bodies);
     }
     if (html_size > 0)
     {
         free_bodies(body.html_bodies, html_size);
         XFREE(body.html_bodies);
     }
     return 0;
 }","[68, 69, 75, 67, 74]","An issue was discovered in tnef before 1.4.13. Four type confusions have been identified in the file_add_mapi_attrs() function. These might lead to invalid read and write operations, controlled by an attacker."
6164,"bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)
{
int i, j;
int negative;
unsigned char byte[5];
BITCODE_UMC mask;
BITCODE_UMC value;

value = val;
mask = 0x0000007f;
for (i = 4, j = 0; i >= 0; i--, j += 7)
{
byte[i] = (unsigned char)((value & mask) >> j);
byte[i] |= 0x80;
mask = mask << 7;
}
for (i = 0; i < 4; i++)
if (byte[i] & 0x7f)
break;

if (byte[i] & 0x40)
i--;
byte[i] &= 0x7f;
for (j = 4; j >= i; j--)
bit_write_RC (dat, byte[j]);
}",[21],"An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to a stack overflow in bits.c, possibly related to bit_read_TF."
9410,".SetShapeFn([](InferenceContext* c) {
ShapeHandle unused;

TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 0, &unused));

const Tensor* size_tensor = c->input_tensor(1);
if (size_tensor == nullptr) {

c->set_output(0, c->UnknownShapeOfRank(1));
return Status::OK();
}


int32_t size_val = size_tensor->scalar<int32>()();
if (size_val < 0) {
return errors::InvalidArgument(""size ("", size_val,
"") must be non-negative"");
}
c->set_output(0, c->MakeShape({size_val}));
return Status::OK();
});",[14],"Tensorflow is an Open Source Machine Learning Framework. The implementation of `*Bincount` operations allows malicious users to cause denial of service by passing in arguments which would trigger a `CHECK`-fail. There are several conditions that the input arguments must satisfy. Some are not caught during shape inference and others are not caught during kernel implementation. This results in `CHECK` failures later when the output tensors get allocated. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
202807," int trigger_fpga_config(void)
 {
 	int ret = 0, init_l;
 	 
 	u32 timeout = 10000;
 
 	 
  	toggle_fpga_eeprom_bus(false);
  
  	 
	qrio_gpio_direction_output(GPIO_A, CONF_SEL_L, 0);
 	qrio_gpio_direction_output(QRIO_GPIO_A, CONF_SEL_L, 0);
  
  	 
	qrio_gpio_direction_output(GPIO_A, FPGA_PROG_L, 0);
 	qrio_gpio_direction_output(QRIO_GPIO_A, FPGA_PROG_L, 0);
  
  	 
  	udelay(10);
  
  	 
  	do {
		init_l = qrio_get_gpio(GPIO_A, FPGA_INIT_L);
 		init_l = qrio_get_gpio(QRIO_GPIO_A, FPGA_INIT_L);
  		if (timeout-- == 0) {
  			printf(""FPGA_INIT timeout\n"");
  			ret = -EFAULT;
 			break;
 		}
 		udelay(10);
  	} while (init_l);
  
  	 
	qrio_set_gpio(GPIO_A, FPGA_PROG_L, 1);
 	qrio_set_gpio(QRIO_GPIO_A, FPGA_PROG_L, 1);
  
  	return ret;
  }","[12, 16, 24, 35, 11, 15, 23, 34]","Das U-Boot versions 2016.09 through 2019.07-rc4 can memset() too much data while reading a crafted ext4 filesystem, which results in a stack buffer overflow and likely code execution."
201701," static int parse_report(transport_smart *transport, git_push *push)
 {
 	git_pkt *pkt = NULL;
 	const char *line_end = NULL;
 	gitno_buffer *buf = &transport->buffer;
 	int error, recvd;
 	git_buf data_pkt_buf = GIT_BUF_INIT;
 
 	for (;;) {
 		if (buf->offset > 0)
 			error = git_pkt_parse_line(&pkt, buf->data,
 						   &line_end, buf->offset);
 		else
 			error = GIT_EBUFS;
 
 		if (error < 0 && error != GIT_EBUFS) {
 			error = -1;
 			goto done;
 		}
 
 		if (error == GIT_EBUFS) {
 			if ((recvd = gitno_recv(buf)) < 0) {
 				error = recvd;
 				goto done;
 			}
 
 			if (recvd == 0) {
 				giterr_set(GITERR_NET, ""early EOF"");
 				error = GIT_EEOF;
 				goto done;
 			}
 			continue;
 		}
 
 		gitno_consume(buf, line_end);
  
  		error = 0;
  
		if (pkt == NULL)
			continue;
  		switch (pkt->type) {
  			case GIT_PKT_DATA:
  				 
 				error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
 				break;
 			case GIT_PKT_ERR:
 				giterr_set(GITERR_NET, ""report-status: Error reported: %s"",
 					((git_pkt_err *)pkt)->error);
 				error = -1;
 				break;
 			case GIT_PKT_PROGRESS:
 				if (transport->progress_cb) {
 					git_pkt_progress *p = (git_pkt_progress *) pkt;
 					error = transport->progress_cb(p->data, p->len, transport->message_cb_payload);
 				}
 				break;
 			default:
 				error = add_push_report_pkt(push, pkt);
 				break;
 		}
 
 		git_pkt_free(pkt);
 
 		 
 		if (error == GIT_ITEROVER) {
 			error = 0;
 			if (data_pkt_buf.size > 0) {
 				 
 				giterr_set(GITERR_NET, ""Incomplete pack data pkt-line"");
 				error = GIT_ERROR;
 			}
 			goto done;
 		}
 
 		if (error < 0) {
 			goto done;
 		}
 	}
 done:
 	git_buf_free(&data_pkt_buf);
 	return error;
 }","[39, 40]",The Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to cause a denial of service (NULL pointer dereference) via an empty packet line.
200400," archive_read_format_cpio_read_header(struct archive_read *a,
     struct archive_entry *entry)
 {
 	struct cpio *cpio;
 	const void *h;
 	struct archive_string_conv *sconv;
 	size_t namelength;
 	size_t name_pad;
 	int r;
 
 	cpio = (struct cpio *)(a->format->data);
 	sconv = cpio->opt_sconv;
 	if (sconv == NULL) {
 		if (!cpio->init_default_conversion) {
 			cpio->sconv_default =
 			    archive_string_default_conversion_for_read(
 			      &(a->archive));
 			cpio->init_default_conversion = 1;
 		}
 		sconv = cpio->sconv_default;
 	}
 	
 	r = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));
 
 	if (r < ARCHIVE_WARN)
 		return (r);
 
 	 
 	h = __archive_read_ahead(a, namelength + name_pad, NULL);
 	if (h == NULL)
 	    return (ARCHIVE_FATAL);
 	if (archive_entry_copy_pathname_l(entry,
 	    (const char *)h, namelength, sconv) != 0) {
 		if (errno == ENOMEM) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Can't allocate memory for Pathname"");
 			return (ARCHIVE_FATAL);
 		}
 		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
 		    ""Pathname can't be converted from %s to current locale."",
 		    archive_string_conversion_charset_name(sconv));
 		r = ARCHIVE_WARN;
 	}
 	cpio->entry_offset = 0;
 
 	__archive_read_consume(a, namelength + name_pad);
  
  	 
  	if (archive_entry_filetype(entry) == AE_IFLNK) {
 		if (cpio->entry_bytes_remaining > 1024 * 1024) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
 			return (ARCHIVE_FATAL);
 		}
  		h = __archive_read_ahead(a,
  			(size_t)cpio->entry_bytes_remaining, NULL);
  		if (h == NULL)
 			return (ARCHIVE_FATAL);
 		if (archive_entry_copy_symlink_l(entry, (const char *)h,
 		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
 			if (errno == ENOMEM) {
 				archive_set_error(&a->archive, ENOMEM,
 				    ""Can't allocate memory for Linkname"");
 				return (ARCHIVE_FATAL);
 			}
 			archive_set_error(&a->archive,
 			    ARCHIVE_ERRNO_FILE_FORMAT,
 			    ""Linkname can't be converted from %s to ""
 			    ""current locale."",
 			    archive_string_conversion_charset_name(sconv));
 			r = ARCHIVE_WARN;
 		}
 		__archive_read_consume(a, cpio->entry_bytes_remaining);
 		cpio->entry_bytes_remaining = 0;
 	}
 
 	 
 
 	 
 	if (namelength == 11 && strcmp((const char *)h, ""TRAILER!!!"") == 0) {
 		 
 		archive_clear_error(&a->archive);
 		return (ARCHIVE_EOF);
 	}
 
 	 
 	if (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {
 		return (ARCHIVE_FATAL);
 	}
 
 	return (r);
 }","[50, 51, 52, 53, 54]",The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.
8277,"Status CompressElement(const std::vector<Tensor>& element,
CompressedElement* out) {


std::vector<TensorProto> non_memcpy_components;
int64 total_size = 0;
for (auto& component : element) {
if (DataTypeCanUseMemcpy(component.dtype())) {


total_size += DMAHelper::buffer(&component)->size();
} else {
non_memcpy_components.emplace_back();
component.AsProtoTensorContent(&non_memcpy_components.back());
total_size += non_memcpy_components.back().ByteSizeLong();
}
}



tstring uncompressed;
uncompressed.resize_uninitialized(total_size);

char* position = uncompressed.mdata();
int non_memcpy_component_index = 0;
for (auto& component : element) {
CompressedComponentMetadata* metadata =
out->mutable_component_metadata()->Add();
metadata->set_dtype(component.dtype());
component.shape().AsProto(metadata->mutable_tensor_shape());
if (DataTypeCanUseMemcpy(component.dtype())) {
const TensorBuffer* buffer = DMAHelper::buffer(&component);
memcpy(position, buffer->data(), buffer->size());
metadata->set_tensor_size_bytes(buffer->size());
} else {
TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];
proto.SerializeToArray(position, proto.ByteSizeLong());
metadata->set_tensor_size_bytes(proto.ByteSizeLong());
}
position += metadata->tensor_size_bytes();
}
DCHECK_EQ(position, uncompressed.mdata() + total_size);

if (!port::Snappy_Compress(uncompressed.mdata(), total_size,
out->mutable_data())) {
return errors::Internal(""Failed to compress using snappy."");
}
VLOG(3) << ""Compressed element from "" << total_size << "" bytes to ""
<< out->data().size() << "" bytes"";
return Status::OK();
}","[11, 33, 34]","TensorFlow is an end-to-end open source platform for machine learning. It is possible to trigger a null pointer dereference in TensorFlow by passing an invalid input to `tf.raw_ops.CompressElement`. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/data/compression_utils.cc#L34) was accessing the size of a buffer obtained from the return of a separate function call before validating that said buffer is valid. We have patched the issue in GitHub commit 5dc7f6981fdaf74c8c5be41f393df705841fb7c5. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
8313,"void Compute(OpKernelContext* ctx) override {
const Tensor& input = ctx->input(0);
const Tensor& input_min_range = ctx->input(1);
const Tensor& input_max_range = ctx->input(2);

int num_slices = 1;
if (axis_ > -1) {
num_slices = input.dim_size(axis_);
}

const TensorShape& minmax_shape = ctx->input(1).shape();
Tensor* output = nullptr;
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));

Tensor* output_min_tensor = nullptr;
Tensor* output_max_tensor = nullptr;

if (num_slices == 1) {
OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));
OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));
const float min_range = input_min_range.template flat<float>()(0);
const float max_range = input_max_range.template flat<float>()(0);
QuantizeTensor(ctx, input, min_range, max_range, output,
output_min_tensor, output_max_tensor);
return;
}

OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,
errors::Unimplemented(""MIN_FIRST mode is not implemented for ""
""Quantize with axis != -1.""));
OP_REQUIRES_OK(ctx,
ctx->allocate_output(1, minmax_shape, &output_min_tensor));
OP_REQUIRES_OK(ctx,
ctx->allocate_output(2, minmax_shape, &output_max_tensor));

auto input_tensor =
input.template flat_inner_outer_dims<float, 3>(axis_ - 1);
int64_t pre_dim = 1, post_dim = 1;
for (int i = 0; i < axis_; ++i) {
pre_dim *= output->dim_size(i);
}
for (int i = axis_ + 1; i < output->dims(); ++i) {
post_dim *= output->dim_size(i);
}
auto output_tensor = output->template bit_casted_shaped<T, 3>(
{pre_dim, num_slices, post_dim});
auto min_ranges = input_min_range.template vec<float>();
auto max_ranges = input_max_range.template vec<float>();
for (int i = 0; i < num_slices; ++i) {
QuantizeSlice(ctx->eigen_device<Device>(), ctx,
input_tensor.template chip<1>(i), min_ranges(i),
max_ranges(i), output_tensor.template chip<1>(i),
&output_min_tensor->flat<float>()(i),
&output_max_tensor->flat<float>()(i));
}
}","[8, 11]","TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in `tf.raw_ops.QuantizeV2`, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/quantize_op.cc#L59) has some validation but does not check that `min_range` and `max_range` both have the same non-zero number of elements. If `axis` is provided (i.e., not `-1`), then validation should check that it is a value in range for the rank of `input` tensor and then the lengths of `min_range` and `max_range` inputs match the `axis` dimension of the `input` tensor. We have patched the issue in GitHub commit 6da6620efad397c85493b8f8667b821403516708. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
9909,"int read_config (char *config_file) {
char buf[512];
char *cp;
FILE *config_fp;
char *args[MAXARGS];
int argcnt, errcnt, linenum;

if (T.debug > 0)
syslog (LOG_DEBUG, ""config file: %s"", config_file);

config_fp = fopen (config_file, ""r"");
if (!config_fp) {
syslog (LOG_ERR, ""can't open config file: %s"", config_file);
return -1;
}
linenum = errcnt = 0;
while (fgets (buf, sizeof (buf), config_fp)) {
linenum++;

cp = strchr (buf, '\n');
if (cp)
*cp = '\0';
cp = strchr (buf, '\n');
if (cp)
*cp = '\0';
cp = strchr (buf, '#');
if (cp)
*cp = '\0';
cp = strchr (buf, ';');
if (cp)
*cp = '\0';


args[argcnt = 0] = strtok (buf, "" \t"");
while (args[argcnt] && ++argcnt < MAXARGS)
args[argcnt] = strtok (NULL, "" \t"");

if (!args[0])
continue;

if (!strcasecmp (args[0], ""forwarder"")) {
if (argcnt < 2 || argcnt > 4 ) {
syslog (LOG_ERR, ""line %d: invalid format: forwarder <IPaddr> [port <port>]"", linenum);
errcnt++;
} else {
int port = PORT_TO, i;

i = 2;
if (argcnt > i) {
if (!strcasecmp (args[i], ""port"")) {
if (argcnt >= ++i) {
port = atoi (args[i++]);
} else {
syslog (LOG_ERR, ""line %d: invalid format, missing <port> after port attribute"", linenum);
errcnt++;
continue;
}
} else {
syslog (LOG_ERR, ""line %d: invalid format, cannot parse unknown attribute: %s"", linenum, args[i]);
errcnt++;
continue;
}
}
if (fwd_add (args[1], port) == -1)
return -1;
}
} else if (!strcasecmp (args[0], ""prefix"")) {
if (argcnt != 2) {
syslog (LOG_ERR, ""line %d: invalid format: prefix <IPv6prefix>"", linenum);
errcnt++;
} else {
if (conv_trick_conf ((u_char *)args[1])) {
syslog (LOG_INFO, ""can not add prefix %d: %s"", T.prefixnum, args[1]);
errcnt++;
} else
syslog (LOG_INFO, ""prefix %d added: %s"", T.prefixnum, args[1]);
}
} else if (!strcasecmp (args[0], ""allow"")) {
if (argcnt != 2) {
syslog (LOG_ERR, ""line %d: invalid format: allow <IP address>"", linenum);
errcnt++;
} else {
#ifdef SWILL
if (T.http_port) {
swill_allow(args[1]);
syslog (LOG_INFO, ""allow http connects from %s"", args[1]);
} else
#endif
syslog (LOG_INFO, ""NOTE: http support not enabled!!!"");
}
} else if (!strcasecmp (args[0], ""retry"")) {
if (argcnt != 2) {
syslog (LOG_ERR, ""line %d: invalid format: retry <seconds>"", linenum);
errcnt++;
} else {
T.retry_interval = atoi(args[1]);
}
} else if (!strcasecmp (args[0], ""pidfile"")) {
if (argcnt != 2) {
syslog (LOG_ERR, ""line %d: invalid format: pidfile <filename>"", linenum);
errcnt++;
} else {
T.pidfile = strdup(args[1]);
}
} else if (!strcasecmp (args[0], ""interfaces"")) {
int i;

if (argcnt < 2) {
syslog (LOG_ERR, ""line %d: invalid format: interfaces <ifa> <ifb> ..."", linenum);
errcnt++;
}

for (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);

if (i + argcnt-1 > MAXINTERFACES) {
syslog (LOG_ERR, ""line %d: to many interfaces, more than %d"", linenum, MAXINTERFACES);
errcnt++;
} else {
syslog (LOG_DEBUG, ""line %d: %d interfaces listed, no wildcard socket"", linenum, argcnt-1);

T.iflist[i + argcnt--] = NULL;
while (argcnt) {
if (!strcmp(args[argcnt], ""*"")) {

T.iflist[0] = NULL;
T.wildcard = 1;
break;
}
T.iflist[i+argcnt-1] = strdup(args[argcnt]);
argcnt--;
}
if (T.iflist[0])
T.wildcard = 0;
}
} else if (!strcasecmp (args[0], ""port"")) {
if (argcnt != 2) {
syslog (LOG_ERR, ""line %d: invalid format: port <portnum>"", linenum);
errcnt++;
} else {
T.port = atoi(args[1]);
}
}
#ifdef SCOPED_REWRITE
else if (!strcasecmp(args[0], ""scoped"")) {
if (argcnt != 4) {
syslog (LOG_ERR, ""line %d: invalid format: scoped <from> <to> <plen>"", linenum);
errcnt++;
} else {
if (conv_scoped_conf(args[1], args[2], atoi(args[3]))) {
syslog (LOG_INFO, ""can not add scoped %d: %s %s %s"",
T.scoped_prefixes, args[1], args[2], args[3]);
errcnt++;
} else {
syslog(LOG_INFO, ""scoped %d added: %s %s %d"",
T.scoped_prefixes, args[1], args[2], atoi(args[3]));
}
}
}
#endif
#ifdef STF
else if  (!strcasecmp(args[0], ""stf"")) {
if (argcnt != 1) {
syslog (LOG_ERR, ""line %d: invalid format: stf"", linenum);
errcnt++;
} else {
T.stf = 1;
}
}
#endif
else {
syslog (LOG_WARNING, ""line %d: unknown keyword in config file: %s"",
linenum, args[0]);
errcnt++;
}
}

fclose (config_fp);

if (errcnt) {
syslog (LOG_ERR, ""errors found in config file. errcnt = %d"", errcnt);
return -1;
}
else
syslog (LOG_INFO, ""configuration file loaded."");

return 0;
}",[113],totd before 1.5.3 does not properly randomize mesg IDs.
3196,"int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)
{
const u_char* data_start = data;

if ( len <= 0 )
return 0;

for ( ; len > 0; --len, ++data )
{
if ( offset >= buf_len )
InitBuffer(buf_len * 2);

int c = data[0];

#define EMIT_LINE \
	{ \
	buf[offset] = '\0'; \
	int seq_len = data + 1 - data_start; \
	seq_delivered_in_lines = seq + seq_len; \
	last_char = c; \
	ForwardStream(offset, buf, IsOrig()); \
	offset = 0; \
	return seq_len; \
	}

switch ( c ) {
case '\r':

if ( len > 1 && data[1] == '\n' )
{
--len; ++data;
last_char = c;
c = data[0];
EMIT_LINE
}

else if ( CR_LF_as_EOL & CR_as_EOL )
EMIT_LINE

else
buf[offset++] = c;
break;

case '\n':
if ( last_char == '\r' )
{
--offset;
EMIT_LINE
}

else if ( CR_LF_as_EOL & LF_as_EOL )
EMIT_LINE

else
{
if ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )
Conn()->Weird(""line_terminated_with_single_LF"");
buf[offset++] = c;
}
break;

case '\0':
if ( flag_NULs )
CheckNUL();
else
buf[offset++] = c;
break;

default:
buf[offset++] = c;
break;
}

if ( last_char == '\r' )
if ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )
Conn()->Weird(""line_terminated_with_single_CR"");

last_char = c;
}

return data - data_start;
}",[47],Bro before Bro v2.5.2 is vulnerable to an out of bounds write in the ContentLine analyzer allowing remote attackers to cause a denial of service (crash) and possibly other exploitation.
206489,"  void TabStrip::ChangeTabGroup(int model_index,
                                base::Optional<int> old_group,
                                base::Optional<int> new_group) {
   tab_at(model_index)->SetGroup(new_group);
    if (new_group.has_value() && !group_headers_[new_group.value()]) {
    const TabGroupData* group_data =
        controller_->GetDataForGroup(new_group.value());
    auto header = std::make_unique<TabGroupHeader>(group_data->title());
     auto header = std::make_unique<TabGroupHeader>(this, new_group.value());
      header->set_owned_by_client();
      AddChildView(header.get());
      group_headers_[new_group.value()] = std::move(header);
   }
   if (old_group.has_value() &&
       controller_->ListTabsInGroup(old_group.value()).size() == 0) {
     group_headers_.erase(old_group.value());
   }
   UpdateIdealBounds();
   AnimateToIdealBounds();
 }","[4, 9, 6, 7, 8]","The extensions API in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android incorrectly handled navigation within PDFs, which allowed a remote attacker to temporarily spoof the contents of the Omnibox (URL bar) via a crafted HTML page containing PDF data."
6069,"static int lookupName(
Parse *pParse,
const char *zDb,
const char *zTab,
const char *zCol,
NameContext *pNC,
Expr *pExpr
){
int i, j;
int cnt = 0;
int cntTab = 0;
int nSubquery = 0;
sqlite3 *db = pParse->db;
struct SrcList_item *pItem;
struct SrcList_item *pMatch = 0;
NameContext *pTopNC = pNC;
Schema *pSchema = 0;
int eNewExprOp = TK_COLUMN;
Table *pTab = 0;
Column *pCol;

assert( pNC );
assert( zCol );
assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );


pExpr->iTable = -1;
ExprSetVVAProperty(pExpr, EP_NoReduce);





if( zDb ){
testcase( pNC->ncFlags & NC_PartIdx );
testcase( pNC->ncFlags & NC_IsCheck );
if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){




zDb = 0;
}else{
for(i=0; i<db->nDb; i++){
assert( db->aDb[i].zDbSName );
if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){
pSchema = db->aDb[i].pSchema;
break;
}
}
}
}


assert( pNC && cnt==0 );
do{
ExprList *pEList;
SrcList *pSrcList = pNC->pSrcList;

if( pSrcList ){
for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
pTab = pItem->pTab;
assert( pTab!=0 && pTab->zName!=0 );
assert( pTab->nCol>0 );
if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){
int hit = 0;
pEList = pItem->pSelect->pEList;
for(j=0; j<pEList->nExpr; j++){
if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){
cnt++;
cntTab = 2;
pMatch = pItem;
pExpr->iColumn = j;
hit = 1;
}
}
if( hit || zTab==0 ) continue;
}
if( zDb && pTab->pSchema!=pSchema ){
continue;
}
if( zTab ){
const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;
assert( zTabName!=0 );
if( sqlite3StrICmp(zTabName, zTab)!=0 ){
continue;
}
if( IN_RENAME_OBJECT && pItem->zAlias ){
sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);
}
}
if( 0==(cntTab++) ){
pMatch = pItem;
}
for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){
if( sqlite3StrICmp(pCol->zName, zCol)==0 ){




if( cnt==1 ){
if( pItem->fg.jointype & JT_NATURAL ) continue;
if( nameInUsingClause(pItem->pUsing, zCol) ) continue;
}
cnt++;
pMatch = pItem;

pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
break;
}
}
}
if( pMatch ){
pExpr->iTable = pMatch->iCursor;
pExpr->y.pTab = pMatch->pTab;

assert( (pMatch->fg.jointype & JT_RIGHT)==0 );
if( (pMatch->fg.jointype & JT_LEFT)!=0 ){
ExprSetProperty(pExpr, EP_CanBeNull);
}
pSchema = pExpr->y.pTab->pSchema;
}
}

#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)




if( zDb==0 && zTab!=0 && cntTab==0 ){
pTab = 0;
#ifndef SQLITE_OMIT_TRIGGER
if( pParse->pTriggerTab!=0 ){
int op = pParse->eTriggerOp;
assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );
if( op!=TK_DELETE && sqlite3StrICmp(""new"",zTab) == 0 ){
pExpr->iTable = 1;
pTab = pParse->pTriggerTab;
}else if( op!=TK_INSERT && sqlite3StrICmp(""old"",zTab)==0 ){
pExpr->iTable = 0;
pTab = pParse->pTriggerTab;
}
}
#endif /* SQLITE_OMIT_TRIGGER */
#ifndef SQLITE_OMIT_UPSERT
if( (pNC->ncFlags & NC_UUpsert)!=0 ){
Upsert *pUpsert = pNC->uNC.pUpsert;
if( pUpsert && sqlite3StrICmp(""excluded"",zTab)==0 ){
pTab = pUpsert->pUpsertSrc->a[0].pTab;
pExpr->iTable = 2;
}
}
#endif /* SQLITE_OMIT_UPSERT */

if( pTab ){
int iCol;
pSchema = pTab->pSchema;
cntTab++;
for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){
if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
if( iCol==pTab->iPKey ){
iCol = -1;
}
break;
}
}
if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){

iCol = -1;
}
if( iCol<pTab->nCol ){
cnt++;
#ifndef SQLITE_OMIT_UPSERT
if( pExpr->iTable==2 ){
testcase( iCol==(-1) );
if( IN_RENAME_OBJECT ){
pExpr->iColumn = iCol;
pExpr->y.pTab = pTab;
eNewExprOp = TK_COLUMN;
}else{
pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;
eNewExprOp = TK_REGISTER;
ExprSetProperty(pExpr, EP_Alias);
}
}else
#endif /* SQLITE_OMIT_UPSERT */
{
#ifndef SQLITE_OMIT_TRIGGER
if( iCol<0 ){
pExpr->affExpr = SQLITE_AFF_INTEGER;
}else if( pExpr->iTable==0 ){
testcase( iCol==31 );
testcase( iCol==32 );
pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
}else{
testcase( iCol==31 );
testcase( iCol==32 );
pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
}
pExpr->y.pTab = pTab;
pExpr->iColumn = (i16)iCol;
eNewExprOp = TK_TRIGGER;
#endif /* SQLITE_OMIT_TRIGGER */
}
}
}
}
#endif /* !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT) */




if( cnt==0
&& cntTab==1
&& pMatch
&& (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0
&& sqlite3IsRowid(zCol)
&& VisibleRowid(pMatch->pTab)
){
cnt = 1;
pExpr->iColumn = -1;
pExpr->affExpr = SQLITE_AFF_INTEGER;
}



















if( (pNC->ncFlags & NC_UEList)!=0
&& cnt==0
&& zTab==0
){
pEList = pNC->uNC.pEList;
assert( pEList!=0 );
for(j=0; j<pEList->nExpr; j++){
char *zAs = pEList->a[j].zName;
if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
Expr *pOrig;
assert( pExpr->pLeft==0 && pExpr->pRight==0 );
assert( pExpr->x.pList==0 );
assert( pExpr->x.pSelect==0 );
pOrig = pEList->a[j].pExpr;
if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){
sqlite3ErrorMsg(pParse, ""misuse of aliased aggregate %s"", zAs);
return WRC_Abort;
}
if( (pNC->ncFlags&NC_AllowWin)==0 && ExprHasProperty(pOrig, EP_Win) ){
sqlite3ErrorMsg(pParse, ""misuse of aliased window function %s"",zAs);
return WRC_Abort;
}
if( sqlite3ExprVectorSize(pOrig)!=1 ){
sqlite3ErrorMsg(pParse, ""row value misused"");
return WRC_Abort;
}
resolveAlias(pParse, pEList, j, pExpr, """", nSubquery);
cnt = 1;
pMatch = 0;
assert( zTab==0 && zDb==0 );
if( IN_RENAME_OBJECT ){
sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
}
goto lookupname_end;
}
}
}




if( cnt ) break;
pNC = pNC->pNext;
nSubquery++;
}while( pNC );












if( cnt==0 && zTab==0 ){
assert( pExpr->op==TK_ID );
if( ExprHasProperty(pExpr,EP_DblQuoted)
&& areDoubleQuotedStringsEnabled(db, pTopNC)
){














sqlite3_log(SQLITE_WARNING,
""double-quoted string literal: \""%w\"""", zCol);
#ifdef SQLITE_ENABLE_NORMALIZE
sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);
#endif
pExpr->op = TK_STRING;
pExpr->y.pTab = 0;
return WRC_Prune;
}
if( sqlite3ExprIdToTrueFalse(pExpr) ){
return WRC_Prune;
}
}





if( cnt!=1 ){
const char *zErr;
zErr = cnt==0 ? ""no such column"" : ""ambiguous column name"";
if( zDb ){
sqlite3ErrorMsg(pParse, ""%s: %s.%s.%s"", zErr, zDb, zTab, zCol);
}else if( zTab ){
sqlite3ErrorMsg(pParse, ""%s: %s.%s"", zErr, zTab, zCol);
}else{
sqlite3ErrorMsg(pParse, ""%s: %s"", zErr, zCol);
}
pParse->checkSchema = 1;
pTopNC->nErr++;
}







if( pExpr->iColumn>=0 && pMatch!=0 ){
int n = pExpr->iColumn;
testcase( n==BMS-1 );
if( n>=BMS ){
n = BMS-1;
}
assert( pMatch->iCursor==pExpr->iTable );
pMatch->colUsed |= ((Bitmask)1)<<n;
}



sqlite3ExprDelete(db, pExpr->pLeft);
pExpr->pLeft = 0;
sqlite3ExprDelete(db, pExpr->pRight);
pExpr->pRight = 0;
pExpr->op = eNewExprOp;
ExprSetProperty(pExpr, EP_Leaf);
lookupname_end:
if( cnt==1 ){
assert( pNC!=0 );
if( !ExprHasProperty(pExpr, EP_Alias) ){
sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
}


for(;;){
assert( pTopNC!=0 );
pTopNC->nRef++;
if( pTopNC==pNC ) break;
pTopNC = pTopNC->pNext;
}
return WRC_Prune;
} else {
return WRC_Abort;
}
}","[363, 364]","lookupName in resolve.c in SQLite 3.30.1 omits bits from the colUsed bitmask in the case of a generated column, which allows attackers to cause a denial of service or possibly have unspecified other impact."
205729," void FrameLoader::StopAllLoaders() {
   if (frame_->GetDocument()->PageDismissalEventBeingDispatched() !=
       Document::kNoDismissal)
     return;
 
    if (in_stop_all_loaders_)
      return;
  
  in_stop_all_loaders_ = true;
   AutoReset<bool> in_stop_all_loaders(&in_stop_all_loaders_, true);
  
    for (Frame* child = frame_->Tree().FirstChild(); child;
         child = child->Tree().NextSibling()) {
     if (child->IsLocalFrame())
       ToLocalFrame(child)->Loader().StopAllLoaders();
   }
  
    frame_->GetDocument()->CancelParsing();
    if (document_loader_)
    document_loader_->Fetcher()->StopFetching();
     document_loader_->StopLoading();
    if (!protect_provisional_loader_)
      DetachDocumentLoader(provisional_document_loader_);
    frame_->GetNavigationScheduler().Cancel();
  if (document_loader_ && !document_loader_->SentDidFinishLoad()) {
    document_loader_->LoadFailed(
        ResourceError::CancelledError(document_loader_->Url()));
  }
  in_stop_all_loaders_ = false;
   DidFinishNavigation();
  
    TakeObjectSnapshot();
  }","[10, 21, 30, 9, 20, 25, 26, 27, 28, 29]","The update_dimensions function in libavcodec/vp8.c in FFmpeg through 2.8.1, as used in Google Chrome before 46.0.2490.71 and other products, relies on a coefficient-partition count during multi-threaded operation, which allows remote attackers to cause a denial of service (race condition and memory corruption) or possibly have unspecified other impact via a crafted WebM file."
200621," nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,
 		struct nfs4_acl *acl)
 {
 	__be32 error;
 	int host_error;
 	struct dentry *dentry;
 	struct inode *inode;
 	struct posix_acl *pacl = NULL, *dpacl = NULL;
 	unsigned int flags = 0;
 
 	 
 	error = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);
 	if (error)
 		return error;
 
  	dentry = fhp->fh_dentry;
  	inode = d_inode(dentry);
  
	if (!inode->i_op->set_acl || !IS_POSIXACL(inode))
		return nfserr_attrnotsupp;
  	if (S_ISDIR(inode->i_mode))
  		flags = NFS4_ACL_DIR;
  
 	host_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);
 	if (host_error == -EINVAL)
 		return nfserr_attrnotsupp;
  	if (host_error < 0)
  		goto out_nfserr;
  
	host_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);
 	fh_lock(fhp);
 
 	host_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);
  	if (host_error < 0)
		goto out_release;
 		goto out_drop_lock;
  
  	if (S_ISDIR(inode->i_mode)) {
		host_error = inode->i_op->set_acl(inode, dpacl,
						  ACL_TYPE_DEFAULT);
 		host_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);
  	}
  
out_release:
 out_drop_lock:
 	fh_unlock(fhp);
 
  	posix_acl_release(pacl);
  	posix_acl_release(dpacl);
  out_nfserr:
 	if (host_error == -EOPNOTSUPP)
 		return nfserr_attrnotsupp;
 	else
 		return nfserrno(host_error);
 }","[31, 32, 33, 36, 41, 45, 46, 47, 19, 20, 30, 35, 39, 40, 44]","nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c."
203314," void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const
 {
     PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));
 
      tTcpIpPacketParsingResult packetReview;
      packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,
                                                 pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,
                                                FALSE,
                                                 __FUNCTION__);
  
      if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)
     {
         auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;
         auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);
         auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;
 
         VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;
         VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;
         VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);
         VHeader->gso_size = (USHORT)m_ParentNBL->MSS();
         VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);
         VHeader->csum_offset = TCP_CHECKSUM_OFFSET;
     }
 }",[8],"The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options."
8245,"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) {
char uint32_buffer[5];
Trackage track = {0};

AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0);
if (mvhdAtom != NULL) {
APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom);
fprintf(stdout,
""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate ""
""(*=approximate)\n"",
movie_info.seconds,
secsTOtime(movie_info.seconds),
movie_info.simple_bitrate_calc);
if (optional_output & SHOW_DATE_INFO) {
fprintf(stdout,
""  Presentation Creation Date (UTC):     %s\n"",
APar_extract_UTC(movie_info.creation_time));
fprintf(stdout,
""  Presentation Modification Date (UTC): %s\n"",
APar_extract_UTC(movie_info.modified_time));
}
}

AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0);
if (iodsAtom != NULL) {
movie_info.contains_iods = true;
APar_Extract_iods_Info(isofile, iodsAtom);
}

if (optional_output & SHOW_TRACK_INFO) {
APar_TrackLevelInfo(&track,
NULL);


fprintf(
stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks);
fprintf(stdout,
""Trk  Type  Handler                    Kind  Lang  Bytes\n"");

if (track.total_tracks > 0) {
while (track.total_tracks > track.track_num) {
track.track_num += 1;
TrackInfo track_info = {0};


APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info);
uint16_t more_whitespace =
purge_extraneous_characters(track_info.track_hdlr_name);

if (strlen(track_info.track_hdlr_name) == 0) {
memcpy(track_info.track_hdlr_name, ""[none listed]"", 13);
}
fprintf(stdout,
""%u    %s  %s"",
track.track_num,
uint32tochar4(track_info.track_type, uint32_buffer),
track_info.track_hdlr_name);

uint16_t handler_len = strlen(track_info.track_hdlr_name);
if (handler_len < 25 + more_whitespace) {
for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) {
fprintf(stdout, "" "");
}
}


fprintf(stdout,
""  %s  %s   %"" PRIu64,
uint32tochar4(track_info.track_codec, uint32_buffer),
track_info.unpacked_lang,
track_info.sample_aggregate);

if (track_info.encoder_name[0] != 0 && track_info.contains_esds) {
purge_extraneous_characters(track_info.encoder_name);
fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name);
}
if (track_info.type_of_track & DRM_PROTECTED_TRACK) {
fprintf(stdout,
"" (protected %s)"",
uint32tochar4(track_info.protected_codec, uint32_buffer));
}

fprintf(stdout, ""\n"");


if (track_info.type_of_track & VIDEO_TRACK ||
track_info.type_of_track & AUDIO_TRACK) {
APar_Print_TrackDetails(&track_info);
}

if (optional_output & SHOW_DATE_INFO) {
fprintf(stdout,
""       Creation Date (UTC):     %s\n"",
APar_extract_UTC(track_info.creation_time));
fprintf(stdout,
""       Modification Date (UTC): %s\n"",
APar_extract_UTC(track_info.modified_time));
}
}
}
}
}",[2],A stack overflow vulnerability occurs in Atomicparsley 20210124.204813.840499f through APar_read64() in src/util.cpp due to the lack of buffer size of uint32_buffer while reading more bytes in APar_read64.
10025,"void Compute(OpKernelContext* context) override {
const Tensor& tensor_in = context->input(0);

PoolParameters params{
context,      ksize_,           stride_, padding_, explicit_paddings_,
data_format_, tensor_in.shape()};
if (!context->status().ok()) {
return;
}

TensorShape out_shape =
ShapeFromFormat(data_format_, params.tensor_in_batch, params.out_height,
params.out_width, params.depth);


constexpr bool is_int8x4 = std::is_same<T, qint8>::value;
OP_REQUIRES(context, (is_int8x4 == (data_format_ == FORMAT_NCHW_VECT_C)),
errors::InvalidArgument(
""qint8 should be used with data_format NCHW_VECT_C.""));

#if CUDNN_VERSION >= 7300
DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,
stride_, padding_, explicit_paddings_,
data_format_, tensor_in, out_shape,
propagate_nans_);
#else

if (!is_int8x4 && data_format_ == FORMAT_NCHW) {
DnnPoolingOp<T>::Compute(context, se::dnn::PoolingMode::kMaximum, ksize_,
stride_, padding_, explicit_paddings_,
data_format_, tensor_in, out_shape,
propagate_nans_);
} else {
#if !defined(TENSORFLOW_USE_ROCM)
OP_REQUIRES(context, padding_ != EXPLICIT,
errors::Unimplemented(""Explicit padding is not supported "",
""when CUDNN is not enabled.""));
#endif
Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));
if (is_int8x4) {
LaunchMaxPoolingNoMask_NCHW_VECT_C<Device>::launch(context, params,
tensor_in, output);
} else if (data_format_ == FORMAT_NHWC) {
LaunchMaxPoolingNoMask<Device, T>::launch(context, params, tensor_in,
output, propagate_nans_);
} else {
LOG(FATAL) << ""MaxPool currently only supports the following (layout, ""
""type) combinations: (NHWC, non-qint8), ""
""(NCHW, non-qint8) or (NCHW_VECT_C, qint8). The ""
""requested combination (""
<< ToString(data_format_) << "", ""
<< DataTypeString(DataTypeToEnum<T>::v())
<< "") is not supported."";
}
}
#endif
}",[16],"TensorFlow is an open source platform for machine learning. When `MaxPool` receives a window size input array `ksize` with dimensions greater than its input tensor `input`, the GPU kernel gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 32d7bd3defd134f21a4e344c8dfd40099aaf6b18. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
201702," int git_pkt_parse_line(
 	git_pkt **head, const char *line, const char **out, size_t bufflen)
 {
 	int ret;
 	int32_t len;
 
 	 
 	if (bufflen > 0 && bufflen < PKT_LEN_SIZE)
 		return GIT_EBUFS;
 
 	len = parse_len(line);
 	if (len < 0) {
 		 
 		if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) {
 			giterr_clear();
 			*out = line;
 			return pack_pkt(head);
 		}
 
 		return (int)len;
 	}
 
 	 
  	if (bufflen > 0 && bufflen < (size_t)len)
  		return GIT_EBUFS;
  
 	 
 	if (len != 0 && len < PKT_LEN_SIZE)
 		return GIT_ERROR;
 
  	line += PKT_LEN_SIZE;
  	 
 	if (len == PKT_LEN_SIZE) {
 		*head = NULL;
 		*out = line;
 		return 0;
 	}
 
 	if (len == 0) {  
 		*out = line;
 		return flush_pkt(head);
 	}
 
 	len -= PKT_LEN_SIZE;  
 
 	if (*line == GIT_SIDE_BAND_DATA)
 		ret = data_pkt(head, line, len);
 	else if (*line == GIT_SIDE_BAND_PROGRESS)
 		ret = sideband_progress_pkt(head, line, len);
 	else if (*line == GIT_SIDE_BAND_ERROR)
 		ret = sideband_error_pkt(head, line, len);
 	else if (!git__prefixcmp(line, ""ACK""))
 		ret = ack_pkt(head, line, len);
 	else if (!git__prefixcmp(line, ""NAK""))
 		ret = nak_pkt(head);
 	else if (!git__prefixcmp(line, ""ERR ""))
 		ret = err_pkt(head, line, len);
 	else if (*line == '#')
 		ret = comment_pkt(head, line, len);
 	else if (!git__prefixcmp(line, ""ok""))
 		ret = ok_pkt(head, line, len);
 	else if (!git__prefixcmp(line, ""ng""))
 		ret = ng_pkt(head, line, len);
 	else if (!git__prefixcmp(line, ""unpack""))
 		ret = unpack_pkt(head, line, len);
 	else
 		ret = ref_pkt(head, line, len);
 
 	*out = line + len;
 
 	return ret;
 }","[27, 28, 29, 30]",Buffer overflow in the git_pkt_parse_line function in transports/smart_pkt.c in the Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to have unspecified impact via a crafted non-flush packet.
8606,"TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {
ShapeInferenceTestOp op(""QuantizeAndDequantizeV2"");
op.input_tensors.resize(3);
TF_ASSERT_OK(NodeDefBuilder(""test"", ""QuantizeAndDequantizeV2"")
.Input(""input"", 0, DT_FLOAT)
.Input(""input_min"", 1, DT_FLOAT)
.Input(""input_max"", 2, DT_FLOAT)
.Attr(""signed_input"", true)
.Attr(""num_bits"", 8)
.Attr(""range_given"", false)
.Attr(""narrow_range"", false)
.Attr(""axis"", -1)
.Finalize(&op.node_def));
INFER_OK(op, ""?;?;?"", ""in0"");
INFER_OK(op, ""[];?;?"", ""in0"");
INFER_OK(op, ""[1,2,?,4,5];?;?"", ""in0"");

INFER_ERROR(""Shape must be rank 0 but is rank 1"", op, ""[1,2,?,4,5];[1];[]"");
INFER_ERROR(""Shapes must be equal rank, but are 1 and 0"", op,
""[1,2,?,4,5];[];[1]"");
INFER_ERROR(""Shape must be rank 0 but is rank 1"", op, ""[1,2,?,4,5];[1];[1]"");
}",[19],"TensorFlow is an open source platform for machine learning. In affected versions the shape inference functions for the `QuantizeAndDequantizeV*` operations can trigger a read outside of bounds of heap allocated array. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
5871,"void handle_debug_usb_rx(const void *msg, size_t len)
{
if (msg_tiny_flag) {
uint8_t buf[64];
memcpy(buf, msg, sizeof(buf));

uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;
uint32_t msgSize = buf[8]        |
((uint32_t)buf[7]) <<  8 |
((uint32_t)buf[6]) << 16 |
((uint32_t)buf[5]) << 24;

if (msgSize > 64 - 9) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Malformed tiny packet"");
return;
}


const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);
if (!entry) {
(*msg_failure)(FailureType_Failure_UnexpectedMessage, ""Unknown message"");
return;
}

tiny_dispatch(entry, buf + 9, msgSize);
} else {
usb_rx_helper(msg, len, DEBUG_MSG);
}
}","[4, 5, 7, 8, 9, 10, 11, 13, 14, 15, 19, 20, 21, 22, 25]",Insufficient checks in the USB packet handling of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow out-of-bounds writes in the .bss segment via crafted messages. The vulnerability could allow code execution or other forms of impact. It can be triggered by unauthenticated attackers and the interface is reachable via WebUSB.
198096," XGetModifierMapping(register Display *dpy)
 {
     xGetModifierMappingReply rep;
     register xReq *req;
     unsigned long nbytes;
     XModifierKeymap *res;
 
     LockDisplay(dpy);
      GetEmptyReq(GetModifierMapping, req);
      (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
  
    if (rep.length < (INT_MAX >> 2)) {
     if (rep.length < (INT_MAX >> 2) &&
 	(rep.length >> 1) == rep.numKeyPerModifier) {
  	nbytes = (unsigned long)rep.length << 2;
  	res = Xmalloc(sizeof (XModifierKeymap));
  	if (res)
     } else
 	res = NULL;
     if ((! res) || (! res->modifiermap)) {
 	Xfree(res);
 	res = (XModifierKeymap *) NULL;
 	_XEatDataWords(dpy, rep.length);
     } else {
 	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
 	res->max_keypermod = rep.numKeyPerModifier;
     }
 
     UnlockDisplay(dpy);
     SyncHandle();
     return (res);
 }","[13, 14, 12]","The XListFonts function in X.org libX11 before 1.6.4 might allow remote X servers to gain privileges via vectors involving length fields, which trigger out-of-bounds write operations."
7508,"static __latent_entropy struct task_struct *copy_process(
struct pid *pid,
int trace,
int node,
struct kernel_clone_args *args)
{
int pidfd = -1, retval;
struct task_struct *p;
struct multiprocess_signals delayed;
struct file *pidfile = NULL;
u64 clone_flags = args->flags;
struct nsproxy *nsp = current->nsproxy;





if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))
return ERR_PTR(-EINVAL);

if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))
return ERR_PTR(-EINVAL);





if ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))
return ERR_PTR(-EINVAL);






if ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))
return ERR_PTR(-EINVAL);







if ((clone_flags & CLONE_PARENT) &&
current->signal->flags & SIGNAL_UNKILLABLE)
return ERR_PTR(-EINVAL);





if (clone_flags & CLONE_THREAD) {
if ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||
(task_active_pid_ns(current) != nsp->pid_ns_for_children))
return ERR_PTR(-EINVAL);
}





if (clone_flags & (CLONE_THREAD | CLONE_VM)) {
if (nsp->time_ns != nsp->time_ns_for_children)
return ERR_PTR(-EINVAL);
}

if (clone_flags & CLONE_PIDFD) {





if (clone_flags & (CLONE_DETACHED | CLONE_THREAD))
return ERR_PTR(-EINVAL);
}







sigemptyset(&delayed.signal);
INIT_HLIST_NODE(&delayed.node);

spin_lock_irq(&current->sighand->siglock);
if (!(clone_flags & CLONE_THREAD))
hlist_add_head(&delayed.node, &current->signal->multiprocess);
recalc_sigpending();
spin_unlock_irq(&current->sighand->siglock);
retval = -ERESTARTNOINTR;
if (signal_pending(current))
goto fork_out;

retval = -ENOMEM;
p = dup_task_struct(current, node);
if (!p)
goto fork_out;







p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;



p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;

ftrace_graph_init_task(p);

rt_mutex_init_task(p);

lockdep_assert_irqs_enabled();
#ifdef CONFIG_PROVE_LOCKING
DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);
#endif
retval = -EAGAIN;
if (atomic_read(&p->real_cred->user->processes) >=
task_rlimit(p, RLIMIT_NPROC)) {
if (p->real_cred->user != INIT_USER &&
!capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))
goto bad_fork_free;
}
current->flags &= ~PF_NPROC_EXCEEDED;

retval = copy_creds(p, clone_flags);
if (retval < 0)
goto bad_fork_free;






retval = -EAGAIN;
if (data_race(nr_threads >= max_threads))
goto bad_fork_cleanup_count;

delayacct_tsk_init(p);
p->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);
p->flags |= PF_FORKNOEXEC;
INIT_LIST_HEAD(&p->children);
INIT_LIST_HEAD(&p->sibling);
rcu_copy_process(p);
p->vfork_done = NULL;
spin_lock_init(&p->alloc_lock);

init_sigpending(&p->pending);

p->utime = p->stime = p->gtime = 0;
#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME
p->utimescaled = p->stimescaled = 0;
#endif
prev_cputime_init(&p->prev_cputime);

#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN
seqcount_init(&p->vtime.seqcount);
p->vtime.starttime = 0;
p->vtime.state = VTIME_INACTIVE;
#endif

#ifdef CONFIG_IO_URING
p->io_uring = NULL;
#endif

#if defined(SPLIT_RSS_COUNTING)
memset(&p->rss_stat, 0, sizeof(p->rss_stat));
#endif

p->default_timer_slack_ns = current->timer_slack_ns;

#ifdef CONFIG_PSI
p->psi_flags = 0;
#endif

task_io_accounting_init(&p->ioac);
acct_clear_integrals(p);

posix_cputimers_init(&p->posix_cputimers);

p->io_context = NULL;
audit_set_context(p, NULL);
cgroup_fork(p);
#ifdef CONFIG_NUMA
p->mempolicy = mpol_dup(p->mempolicy);
if (IS_ERR(p->mempolicy)) {
retval = PTR_ERR(p->mempolicy);
p->mempolicy = NULL;
goto bad_fork_cleanup_threadgroup_lock;
}
#endif
#ifdef CONFIG_CPUSETS
p->cpuset_mem_spread_rotor = NUMA_NO_NODE;
p->cpuset_slab_spread_rotor = NUMA_NO_NODE;
seqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);
#endif
#ifdef CONFIG_TRACE_IRQFLAGS
memset(&p->irqtrace, 0, sizeof(p->irqtrace));
p->irqtrace.hardirq_disable_ip = _THIS_IP_;
p->irqtrace.softirq_enable_ip = _THIS_IP_;
p->softirqs_enabled  = 1;
p->softirq_context  = 0;
#endif

p->pagefault_disabled = 0;

#ifdef CONFIG_LOCKDEP
lockdep_init_task(p);
#endif

#ifdef CONFIG_DEBUG_MUTEXES
p->blocked_on = NULL;
#endif
#ifdef CONFIG_BCACHE
p->sequential_io = 0;
p->sequential_io_avg = 0;
#endif


retval = sched_fork(clone_flags, p);
if (retval)
goto bad_fork_cleanup_policy;

retval = perf_event_init_task(p);
if (retval)
goto bad_fork_cleanup_policy;
retval = audit_alloc(p);
if (retval)
goto bad_fork_cleanup_perf;

shm_init_task(p);
retval = security_task_alloc(p, clone_flags);
if (retval)
goto bad_fork_cleanup_audit;
retval = copy_semundo(clone_flags, p);
if (retval)
goto bad_fork_cleanup_security;
retval = copy_files(clone_flags, p);
if (retval)
goto bad_fork_cleanup_semundo;
retval = copy_fs(clone_flags, p);
if (retval)
goto bad_fork_cleanup_files;
retval = copy_sighand(clone_flags, p);
if (retval)
goto bad_fork_cleanup_fs;
retval = copy_signal(clone_flags, p);
if (retval)
goto bad_fork_cleanup_sighand;
retval = copy_mm(clone_flags, p);
if (retval)
goto bad_fork_cleanup_signal;
retval = copy_namespaces(clone_flags, p);
if (retval)
goto bad_fork_cleanup_mm;
retval = copy_io(clone_flags, p);
if (retval)
goto bad_fork_cleanup_namespaces;
retval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);
if (retval)
goto bad_fork_cleanup_io;

stackleak_task_init(p);

if (pid != &init_struct_pid) {
pid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,
args->set_tid_size);
if (IS_ERR(pid)) {
retval = PTR_ERR(pid);
goto bad_fork_cleanup_thread;
}
}






if (clone_flags & CLONE_PIDFD) {
retval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);
if (retval < 0)
goto bad_fork_free_pid;

pidfd = retval;

pidfile = anon_inode_getfile(""[pidfd]"", &pidfd_fops, pid,
O_RDWR | O_CLOEXEC);
if (IS_ERR(pidfile)) {
put_unused_fd(pidfd);
retval = PTR_ERR(pidfile);
goto bad_fork_free_pid;
}
get_pid(pid);

retval = put_user(pidfd, args->pidfd);
if (retval)
goto bad_fork_put_pidfd;
}

#ifdef CONFIG_BLOCK
p->plug = NULL;
#endif
futex_init_task(p);




if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)
sas_ss_reset(p);





user_disable_single_step(p);
clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);
#ifdef TIF_SYSCALL_EMU
clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);
#endif
clear_tsk_latency_tracing(p);


p->pid = pid_nr(pid);
if (clone_flags & CLONE_THREAD) {
p->exit_signal = -1;
p->group_leader = current->group_leader;
p->tgid = current->tgid;
} else {
if (clone_flags & CLONE_PARENT)
p->exit_signal = current->group_leader->exit_signal;
else
p->exit_signal = args->exit_signal;
p->group_leader = p;
p->tgid = p->pid;
}

p->nr_dirtied = 0;
p->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);
p->dirty_paused_when = 0;

p->pdeath_signal = 0;
INIT_LIST_HEAD(&p->thread_group);
p->task_works = NULL;







retval = cgroup_can_fork(p, args);
if (retval)
goto bad_fork_put_pidfd;









p->start_time = ktime_get_ns();
p->start_boottime = ktime_get_boottime_ns();





write_lock_irq(&tasklist_lock);


if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {
p->real_parent = current->real_parent;
p->parent_exec_id = current->parent_exec_id;
} else {
p->real_parent = current;
p->parent_exec_id = current->self_exec_id;
}

klp_copy_process(p);

spin_lock(&current->sighand->siglock);





copy_seccomp(p);

rseq_fork(p, clone_flags);


if (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {
retval = -ENOMEM;
goto bad_fork_cancel_cgroup;
}


if (fatal_signal_pending(current)) {
retval = -EINTR;
goto bad_fork_cancel_cgroup;
}


if (pidfile)
fd_install(pidfd, pidfile);

init_task_pid_links(p);
if (likely(p->pid)) {
ptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);

init_task_pid(p, PIDTYPE_PID, pid);
if (thread_group_leader(p)) {
init_task_pid(p, PIDTYPE_TGID, pid);
init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));
init_task_pid(p, PIDTYPE_SID, task_session(current));

if (is_child_reaper(pid)) {
ns_of_pid(pid)->child_reaper = p;
p->signal->flags |= SIGNAL_UNKILLABLE;
}
p->signal->shared_pending.signal = delayed.signal;
p->signal->tty = tty_kref_get(current->signal->tty);





p->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||
p->real_parent->signal->is_child_subreaper;
list_add_tail(&p->sibling, &p->real_parent->children);
list_add_tail_rcu(&p->tasks, &init_task.tasks);
attach_pid(p, PIDTYPE_TGID);
attach_pid(p, PIDTYPE_PGID);
attach_pid(p, PIDTYPE_SID);
__this_cpu_inc(process_counts);
} else {
current->signal->nr_threads++;
atomic_inc(&current->signal->live);
refcount_inc(&current->signal->sigcnt);
task_join_group_stop(p);
list_add_tail_rcu(&p->thread_group,
&p->group_leader->thread_group);
list_add_tail_rcu(&p->thread_node,
&p->signal->thread_head);
}
attach_pid(p, PIDTYPE_PID);
nr_threads++;
}
total_forks++;
hlist_del_init(&delayed.node);
spin_unlock(&current->sighand->siglock);
syscall_tracepoint_update(p);
write_unlock_irq(&tasklist_lock);

proc_fork_connector(p);
sched_post_fork(p);
cgroup_post_fork(p, args);
perf_event_fork(p);

trace_task_newtask(p, clone_flags);
uprobe_copy_process(p, clone_flags);

copy_oom_score_adj(clone_flags, p);

return p;

bad_fork_cancel_cgroup:
spin_unlock(&current->sighand->siglock);
write_unlock_irq(&tasklist_lock);
cgroup_cancel_fork(p, args);
bad_fork_put_pidfd:
if (clone_flags & CLONE_PIDFD) {
fput(pidfile);
put_unused_fd(pidfd);
}
bad_fork_free_pid:
if (pid != &init_struct_pid)
free_pid(pid);
bad_fork_cleanup_thread:
exit_thread(p);
bad_fork_cleanup_io:
if (p->io_context)
exit_io_context(p);
bad_fork_cleanup_namespaces:
exit_task_namespaces(p);
bad_fork_cleanup_mm:
if (p->mm) {
mm_clear_owner(p->mm, p);
mmput(p->mm);
}
bad_fork_cleanup_signal:
if (!(clone_flags & CLONE_THREAD))
free_signal_struct(p->signal);
bad_fork_cleanup_sighand:
__cleanup_sighand(p->sighand);
bad_fork_cleanup_fs:
exit_fs(p);
bad_fork_cleanup_files:
exit_files(p);
bad_fork_cleanup_semundo:
exit_sem(p);
bad_fork_cleanup_security:
security_task_free(p);
bad_fork_cleanup_audit:
audit_free(p);
bad_fork_cleanup_perf:
perf_event_free_task(p);
bad_fork_cleanup_policy:
lockdep_free_task(p);
#ifdef CONFIG_NUMA
mpol_put(p->mempolicy);
bad_fork_cleanup_threadgroup_lock:
#endif
delayacct_tsk_free(p);
bad_fork_cleanup_count:
atomic_dec(&p->cred->user->processes);
exit_creds(p);
bad_fork_free:
p->state = TASK_DEAD;
put_task_stack(p);
delayed_free_task(p);
fork_out:
spin_lock_irq(&current->sighand->siglock);
hlist_del_init(&delayed.node);
spin_unlock_irq(&current->sighand->siglock);
return ERR_PTR(retval);
}","[329, 333, 334, 335, 336, 380, 385]",A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process.
197880," check_file_permissions_reduced(i_ctx_t *i_ctx_p, const char *fname, int len,
                         gx_io_device *iodev, const char *permitgroup)
 {
     long i;
     ref *permitlist = NULL;
      
      
     const char *win_sep2 = ""\\"";
     bool use_windows_pathsep = (gs_file_name_check_separator(win_sep2, 1, win_sep2) == 1);
     uint plen = gp_file_name_parents(fname, len);
 
       
    if (iodev != iodev_default(imemory)) {
     if (iodev && iodev != iodev_default(imemory)) {
          return 0;
      }
  
      
     if (dict_find_string(&(i_ctx_p->userparams), permitgroup, &permitlist) <= 0)
         return 0;        
 
     for (i=0; i<r_size(permitlist); i++) {
         ref permitstring;
         const string_match_params win_filename_params = {
                 '*', '?', '\\', true, true       
         };
         const byte *permstr;
         uint permlen;
         int cwd_len = 0;
 
         if (array_get(imemory, permitlist, i, &permitstring) < 0 ||
             r_type(&permitstring) != t_string
            )
             break;       
         permstr = permitstring.value.bytes;
         permlen = r_size(&permitstring);
          
         if (permlen == 1 && permstr[0] == '*')
             return 0;            
          
         if (plen != 0 && plen != gp_file_name_parents((const char *)permstr, permlen))
             continue;
         cwd_len = gp_file_name_cwds((const char *)permstr, permlen);
          
         if (cwd_len > 0 && gp_file_name_is_absolute(fname, len))
             continue;
          
         if (string_match( (const unsigned char*) fname, len,
                           permstr + cwd_len, permlen - cwd_len,
                 use_windows_pathsep ? &win_filename_params : NULL))
             return 0;            
     }
      
     return gs_error_invalidfileaccess;
 }","[14, 13]","In Artifex Ghostscript 9.23 before 2018-08-23, attackers are able to supply malicious PostScript files to bypass .tempfile restrictions and write files."
205823," void Microtask::performCheckpoint()
 void Microtask::performCheckpoint(v8::Isolate* isolate)
  {
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
      V8PerIsolateData* isolateData = V8PerIsolateData::from(isolate);
      ASSERT(isolateData);
      if (isolateData->recursionLevel() || isolateData->performingMicrotaskCheckpoint() || isolateData->destructionPending() || ScriptForbiddenScope::isScriptForbidden())
         return;
     isolateData->setPerformingMicrotaskCheckpoint(true);
     {
         V8RecursionScope recursionScope(isolate);
         isolate->RunMicrotasks();
     }
     isolateData->setPerformingMicrotaskCheckpoint(false);
 }","[2, 4]","core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source."
207002," void DownloadManagerImpl::DownloadUrl(
     std::unique_ptr<download::DownloadUrlParameters> params,
     std::unique_ptr<storage::BlobDataHandle> blob_data_handle,
     scoped_refptr<network::SharedURLLoaderFactory> blob_url_loader_factory) {
   if (params->post_id() >= 0) {
     DCHECK(params->prefer_cache());
     DCHECK_EQ(""POST"", params->method());
   }
 
   download::RecordDownloadCountWithSource(
       download::DownloadCountTypes::DOWNLOAD_TRIGGERED_COUNT,
        params->download_source());
    auto* rfh = RenderFrameHost::FromID(params->render_process_host_id(),
                                        params->render_frame_host_routing_id());
   if (rfh)
     params->set_frame_tree_node_id(rfh->GetFrameTreeNodeId());
    BeginDownloadInternal(std::move(params), std::move(blob_data_handle),
                          std::move(blob_url_loader_factory), true,
                          rfh ? rfh->GetSiteInstance()->GetSiteURL() : GURL());
 }","[15, 16]",Inappropriate implementation in Blink in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
201947," static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)
 {
     double mul2 = mul * mul, mul3 = mul2 * mul;
     double kernel[] = {
         (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
         (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
         ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
          (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
      };
  
    double mat_freq[13];
     double mat_freq[14];
      memcpy(mat_freq, kernel, sizeof(kernel));
      memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
      int n = 6;
     coeff_filter(mat_freq, n, kernel);
     for (int k = 0; k < 2 * prefilter; ++k)
         coeff_blur121(mat_freq, ++n);
 
     double vec_freq[13];
     n = index[3] + prefilter + 3;
     calc_gauss(vec_freq, n, r2);
     memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
     n -= 3;
     coeff_filter(vec_freq, n, kernel);
     for (int k = 0; k < prefilter; ++k)
         coeff_blur121(vec_freq, --n);
 
     double mat[4][4];
     calc_matrix(mat, mat_freq, index);
 
     double vec[4];
     for (int i = 0; i < 4; ++i)
         vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];
 
     for (int i = 0; i < 4; ++i) {
         double res = 0;
         for (int j = 0; j < 4; ++j)
             res += mat[i][j] * vec[j];
         mu[i] = FFMAX(0, res);
     }
 }","[12, 11]",Buffer overflow in the calc_coeff function in libass/ass_blur.c in libass before 0.13.4 allows remote attackers to cause a denial of service via unspecified vectors.
207878," long long Segment::ParseHeaders() {
  long long total, available;
 
  const int status = m_pReader->Length(&total, &available);
 
 
    if (status < 0)   
      return status;
  
  assert((total < 0) || (available <= total));
   if (total > 0 && available > total)
     return E_FILE_FORMAT_INVALID;
  
    const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
  assert((segment_stop < 0) || (m_pos <= segment_stop));
 
   if ((segment_stop >= 0 && total >= 0 && segment_stop > total) ||
       (segment_stop >= 0 && m_pos > segment_stop)) {
     return E_FILE_FORMAT_INVALID;
   }
  
    for (;;) {
      if ((total >= 0) && (m_pos >= total))
  break;
 
  if ((segment_stop >= 0) && (m_pos >= segment_stop))
  break;
 
 
      long long pos = m_pos;
      const long long element_start = pos;
  
      
     unsigned long long rollover_check = pos + 1ULL;
     if (rollover_check > LONG_LONG_MAX)
       return E_FILE_FORMAT_INVALID;
 
      if ((pos + 1) > available)
        return (pos + 1);
  
  long len;
  long long result = GetUIntLength(m_pReader, pos, len);
 
 
      if (result < 0)   
        return result;
  
    if (result > 0)   
     if (result > 0) {
        
        return (pos + 1);
     }
  
      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > available)
 
        return pos + len;
  
      const long long idpos = pos;
    const long long id = ReadUInt(m_pReader, idpos, len);
     const long long id = ReadID(m_pReader, idpos, len);
  
    if (id < 0)   
      return id;
     if (id < 0)
       return E_FILE_FORMAT_INVALID;
  
      if (id == 0x0F43B675)   
        break;
 
     pos += len;  
 
  if ((pos + 1) > available)
  return (pos + 1);
 
     result = GetUIntLength(m_pReader, pos, len);
 
 
      if (result < 0)   
        return result;
  
    if (result > 0)   
     if (result > 0) {
        
        return (pos + 1);
     }
  
      if ((segment_stop >= 0) && ((pos + len) > segment_stop))
        return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > available)
  return pos + len;
 
  
      const long long size = ReadUInt(m_pReader, pos, len);
  
    if (size < 0)   
     if (size < 0 || len < 1 || len > 8) {
        
        
        return size;
     }
  
      pos += len;   
  
      
     rollover_check = static_cast<unsigned long long>(pos) + size;
     if (rollover_check > LONG_LONG_MAX)
       return E_FILE_FORMAT_INVALID;
 
      const long long element_size = size + pos - element_start;
  
 
  if ((segment_stop >= 0) && ((pos + size) > segment_stop))
  return E_FILE_FORMAT_INVALID;
 
 
  if ((pos + size) > available)
  return pos + size;
 
  if (id == 0x0549A966) {  
  if (m_pInfo)
  return E_FILE_FORMAT_INVALID;
 
       m_pInfo = new (std::nothrow)
  SegmentInfo(this, pos, size, element_start, element_size);
 
  if (m_pInfo == NULL)
  return -1;
 
  const long status = m_pInfo->Parse();
 
  if (status)
  return status;
  } else if (id == 0x0654AE6B) {  
  if (m_pTracks)
  return E_FILE_FORMAT_INVALID;
 
       m_pTracks = new (std::nothrow)
  Tracks(this, pos, size, element_start, element_size);
 
  if (m_pTracks == NULL)
  return -1;
 
  const long status = m_pTracks->Parse();
 
  if (status)
  return status;
  } else if (id == 0x0C53BB6B) {  
  if (m_pCues == NULL) {
         m_pCues = new (std::nothrow)
  Cues(this, pos, size, element_start, element_size);
 
  if (m_pCues == NULL)
  return -1;
  }
  } else if (id == 0x014D9B74) {  
  if (m_pSeekHead == NULL) {
         m_pSeekHead = new (std::nothrow)
  SeekHead(this, pos, size, element_start, element_size);
 
  if (m_pSeekHead == NULL)
  return -1;
 
  const long status = m_pSeekHead->Parse();
 
  if (status)
  return status;
  }
  } else if (id == 0x0043A770) {  
  if (m_pChapters == NULL) {
         m_pChapters = new (std::nothrow)
  Chapters(this, pos, size, element_start, element_size);
 
  if (m_pChapters == NULL)
  return -1;
 
  const long status = m_pChapters->Parse();
 
 
          if (status)
            return status;
        }
     } else if (id == 0x0254C367) {   
       if (m_pTags == NULL) {
         m_pTags = new (std::nothrow)
             Tags(this, pos, size, element_start, element_size);
 
         if (m_pTags == NULL)
           return -1;
 
         const long status = m_pTags->Parse();
 
         if (status)
           return status;
       }
      }
  
      m_pos = pos + size;   
    }
  
  assert((segment_stop < 0) || (m_pos <= segment_stop));
   if (segment_stop >= 0 && m_pos > segment_stop)
     return E_FILE_FORMAT_INVALID;
  
    if (m_pInfo == NULL)   
      return E_FILE_FORMAT_INVALID;
 
  if (m_pTracks == NULL)
  return E_FILE_FORMAT_INVALID;
 
  return 0;  
 }","[11, 12, 17, 18, 19, 20, 21, 34, 35, 36, 37, 38, 50, 51, 53, 64, 68, 69, 86, 87, 89, 101, 102, 103, 105, 109, 110, 111, 112, 113, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 206, 207, 10, 15, 16, 49, 63, 66, 67, 85, 100, 205]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
203331," static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)
 {
 	__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;
 	struct kvm_regs *regs = vcpu_gp_regs(vcpu);
 	int nr_regs = sizeof(*regs) / sizeof(__u32);
 	__uint128_t tmp;
 	void *valp = &tmp;
 	u64 off;
 	int err = 0;
 
 	 
 	off = core_reg_offset_from_id(reg->id);
 	if (off >= nr_regs ||
 	    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)
 		return -ENOENT;
 
 	if (validate_core_offset(reg))
 		return -EINVAL;
 
 	if (KVM_REG_SIZE(reg->id) > sizeof(tmp))
 		return -EINVAL;
 
 	if (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {
 		err = -EFAULT;
 		goto out;
  	}
  
  	if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {
		u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;
 		u64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;
  		switch (mode) {
  		case PSR_AA32_MODE_USR:
 			if (!system_supports_32bit_el0())
 				return -EINVAL;
 			break;
  		case PSR_AA32_MODE_FIQ:
  		case PSR_AA32_MODE_IRQ:
  		case PSR_AA32_MODE_SVC:
  		case PSR_AA32_MODE_ABT:
  		case PSR_AA32_MODE_UND:
 			if (!vcpu_el1_is_32bit(vcpu))
 				return -EINVAL;
 			break;
  		case PSR_MODE_EL0t:
  		case PSR_MODE_EL1t:
  		case PSR_MODE_EL1h:
 			if (vcpu_el1_is_32bit(vcpu))
 				return -EINVAL;
  			break;
  		default:
  			err = -EINVAL;
 			goto out;
 		}
 	}
 
 	memcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));
 out:
 	return err;
 }","[30, 33, 34, 35, 41, 42, 43, 47, 48, 29]","arch/arm64/kvm/guest.c in KVM in the Linux kernel before 4.18.12 on the arm64 platform mishandles the KVM_SET_ON_REG ioctl. This is exploitable by attackers who can create virtual machines. An attacker can arbitrarily redirect the hypervisor flow of control (with full register control). An attacker can also cause a denial of service (hypervisor panic) via an illegal exception return. This occurs because of insufficient restrictions on userspace access to the core register file, and because PSTATE.M validation does not prevent unintended execution modes."
201199," gss_verify_mic (minor_status,
 		context_handle,
 		message_buffer,
 		token_buffer,
 		qop_state)
 
 OM_uint32 *		minor_status;
 gss_ctx_id_t		context_handle;
 gss_buffer_t		message_buffer;
 gss_buffer_t		token_buffer;
 gss_qop_t *		qop_state;
 
 {
     OM_uint32		status;
     gss_union_ctx_id_t	ctx;
     gss_mechanism	mech;
 
 
     if (minor_status == NULL)
 	return (GSS_S_CALL_INACCESSIBLE_WRITE);
     *minor_status = 0;
 
     if (context_handle == GSS_C_NO_CONTEXT)
 	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);
 
     if ((message_buffer == GSS_C_NO_BUFFER) ||
 	GSS_EMPTY_BUFFER(token_buffer))
 
 	return (GSS_S_CALL_INACCESSIBLE_READ);
 
      
  
      ctx = (gss_union_ctx_id_t) context_handle;
     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
 	return (GSS_S_NO_CONTEXT);
      mech = gssint_get_mechanism (ctx->mech_type);
  
      if (mech) {
 	if (mech->gss_verify_mic) {
 	    status = mech->gss_verify_mic(
 					  minor_status,
 					  ctx->internal_ctx_id,
 					  message_buffer,
 					  token_buffer,
 					  qop_state);
 	    if (status != GSS_S_COMPLETE)
 		map_error(minor_status, mech);
 	} else
 	    status = GSS_S_UNAVAILABLE;
 
 	return(status);
     }
 
     return (GSS_S_BAD_MECH);
 }","[34, 35]",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
206255," v8::Local<v8::Value> ModuleSystem::LoadModule(const std::string& module_name) {
   v8::EscapableHandleScope handle_scope(GetIsolate());
   v8::Local<v8::Context> v8_context = context()->v8_context();
   v8::Context::Scope context_scope(v8_context);
 
   v8::Local<v8::Value> source(GetSource(module_name));
   if (source.IsEmpty() || source->IsUndefined()) {
     Fatal(context_, ""No source for require("" + module_name + "")"");
     return v8::Undefined(GetIsolate());
   }
   v8::Local<v8::String> wrapped_source(
       WrapSource(v8::Local<v8::String>::Cast(source)));
   v8::Local<v8::String> v8_module_name;
   if (!ToV8String(GetIsolate(), module_name.c_str(), &v8_module_name)) {
     NOTREACHED() << ""module_name is too long"";
     return v8::Undefined(GetIsolate());
   }
   v8::Local<v8::Value> func_as_value =
       RunString(wrapped_source, v8_module_name);
   if (func_as_value.IsEmpty() || func_as_value->IsUndefined()) {
     Fatal(context_, ""Bad source for require("" + module_name + "")"");
     return v8::Undefined(GetIsolate());
   }
 
   v8::Local<v8::Function> func = v8::Local<v8::Function>::Cast(func_as_value);
 
    v8::Local<v8::Object> define_object = v8::Object::New(GetIsolate());
    gin::ModuleRegistry::InstallGlobals(GetIsolate(), define_object);
  
  v8::Local<v8::Value> exports = v8::Object::New(GetIsolate());
   v8::Local<v8::Object> exports = v8::Object::New(GetIsolate());
 
   v8::Local<v8::FunctionTemplate> tmpl = v8::FunctionTemplate::New(
       GetIsolate(),
       &SetExportsProperty);
   v8::Local<v8::String> v8_key;
   if (!v8_helpers::ToV8String(GetIsolate(), ""$set"", &v8_key)) {
     NOTREACHED();
     return v8::Undefined(GetIsolate());
   }
 
   v8::Local<v8::Function> function;
   if (!tmpl->GetFunction(v8_context).ToLocal(&function)) {
     NOTREACHED();
     return v8::Undefined(GetIsolate());
   }
 
   exports->ForceSet(v8_key, function, v8::ReadOnly);
 
    v8::Local<v8::Object> natives(NewInstance());
    CHECK(!natives.IsEmpty());   
  
   v8::Local<v8::Value> args[] = {
       GetPropertyUnsafe(v8_context, define_object, ""define""),
       GetPropertyUnsafe(v8_context, natives, ""require"",
                         v8::NewStringType::kInternalized),
       GetPropertyUnsafe(v8_context, natives, ""requireNative"",
                         v8::NewStringType::kInternalized),
       GetPropertyUnsafe(v8_context, natives, ""requireAsync"",
                         v8::NewStringType::kInternalized),
       exports,
       console::AsV8Object(GetIsolate()),
       GetPropertyUnsafe(v8_context, natives, ""privates"",
                         v8::NewStringType::kInternalized),
       context_->safe_builtins()->GetArray(),
       context_->safe_builtins()->GetFunction(),
       context_->safe_builtins()->GetJSON(),
       context_->safe_builtins()->GetObjekt(),
       context_->safe_builtins()->GetRegExp(),
       context_->safe_builtins()->GetString(),
       context_->safe_builtins()->GetError(),
   };
   {
     v8::TryCatch try_catch(GetIsolate());
     try_catch.SetCaptureMessage(true);
     context_->CallFunction(func, arraysize(args), args);
     if (try_catch.HasCaught()) {
       HandleException(try_catch);
       return v8::Undefined(GetIsolate());
     }
   }
   return handle_scope.Escape(exports);
 }","[31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 30]","The Extensions subsystem in Google Chrome before 48.0.2564.109 does not prevent use of the Object.defineProperty method to override intended extension behavior, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code."
204021,"  JSValue JSWebKitMutationObserver::observe(ExecState* exec)
  {
      if (exec->argumentCount() < 2)
        return throwError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwError(exec, createNotEnoughArgumentsError(exec));
      Node* target = toNode(exec->argument(0));
      if (exec->hadException())
          return jsUndefined();
 
     JSObject* optionsObject = exec->argument(1).getObject();
     if (!optionsObject) {
         setDOMException(exec, TYPE_MISMATCH_ERR);
         return jsUndefined();
     }
 
     JSDictionary dictionary(exec, optionsObject);
     MutationObserverOptions options = 0;
     for (unsigned i = 0; i < numBooleanOptions; ++i) {
         bool option = false;
         if (!dictionary.tryGetProperty(booleanOptions[i].name, option))
             return jsUndefined();
         if (option)
             options |= booleanOptions[i].value;
     }
 
     HashSet<AtomicString> attributeFilter;
     if (!dictionary.tryGetProperty(""attributeFilter"", attributeFilter))
         return jsUndefined();
     if (!attributeFilter.isEmpty())
         options |= WebKitMutationObserver::AttributeFilter;
 
     ExceptionCode ec = 0;
     impl()->observe(target, options, attributeFilter, ec);
     if (ec)
         setDOMException(exec, ec);
     return jsUndefined();
 }","[5, 4]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
9091,"static bool set_reg_profile(RAnal *anal) {
const char *p =
""=PC	pc\n""
""=SP	r14\n""
""=BP	srp\n""
""=A0	r0\n""
""=A1	r1\n""
""=A2	r2\n""
""=A3	r3\n""
""gpr	sp	.32	56	0\n""
""gpr	acr	.32	60	0\n""
""gpr	pc	.32	64	0\n""
""gpr	srp	.32	68	0\n""

""gpr	r0	.32	0	0\n""
""gpr	r1	.32	4	0\n""
""gpr	r2	.32	8	0\n""
""gpr	r3	.32	12	0\n""
""gpr	r4	.32	16	0\n""
""gpr	r5	.32	20	0\n""
""gpr	r6	.32	24	0\n""
""gpr	r7	.32	28	0\n""
""gpr	r8	.32	32	0\n""
""gpr	r9	.32	36	0\n""
""gpr	r10	.32	40	0\n""
""gpr	r11	.32	44	0\n""
""gpr	r12	.32	48	0\n""
""gpr	r13	.32	52	0\n""


""gpr	r14	.32	56	0\n""
""gpr	r15	.32	60	0\n""

;
return r_reg_set_profile_string (anal->reg, p);
}",[6],Out-of-bounds read in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers to read sensitive information from outside the allocated buffer boundary.
208060," WORD32 ih264d_parse_nal_unit(iv_obj_t *dec_hdl,
  ivd_video_decode_op_t *ps_dec_op,
                           UWORD8 *pu1_buf,
                           UWORD32 u4_length)
 {
 
  dec_bit_stream_t *ps_bitstrm;
 
 
  dec_struct_t *ps_dec = (dec_struct_t *)dec_hdl->pv_codec_handle;
  ivd_video_decode_ip_t *ps_dec_in =
  (ivd_video_decode_ip_t *)ps_dec->pv_dec_in;
  dec_slice_params_t * ps_cur_slice = ps_dec->ps_cur_slice;
     UWORD8 u1_first_byte, u1_nal_ref_idc;
     UWORD8 u1_nal_unit_type;
     WORD32 i_status = OK;
     ps_bitstrm = ps_dec->ps_bitstrm;
 
  if(pu1_buf)
  {
  if(u4_length)
  {
             ps_dec_op->u4_frame_decoded_flag = 0;
             ih264d_process_nal_unit(ps_dec->ps_bitstrm, pu1_buf,
                                     u4_length);
 
             SWITCHOFFTRACE;
             u1_first_byte = ih264d_get_bits_h264(ps_bitstrm, 8);
 
  if(NAL_FORBIDDEN_BIT(u1_first_byte))
  {
                 H264_DEC_DEBUG_PRINT(""\nForbidden bit set in Nal Unit, Let's try\n"");
  }
             u1_nal_unit_type = NAL_UNIT_TYPE(u1_first_byte);
  if ((ps_dec->u4_slice_start_code_found == 1)
  && (ps_dec->u1_pic_decode_done != 1)
  && (u1_nal_unit_type > IDR_SLICE_NAL))
  {
  return ERROR_INCOMPLETE_FRAME;
  }
             ps_dec->u1_nal_unit_type = u1_nal_unit_type;
             u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_first_byte));
  switch(u1_nal_unit_type)
  {
  case SLICE_DATA_PARTITION_A_NAL:
  case SLICE_DATA_PARTITION_B_NAL:
  case SLICE_DATA_PARTITION_C_NAL:
  if(!ps_dec->i4_decode_header)
                         ih264d_parse_slice_partition(ps_dec, ps_bitstrm);
 
  break;
 
  case IDR_SLICE_NAL:
  case SLICE_NAL:
 
   
                     DEBUG_THREADS_PRINTF(""Decoding  a slice NAL\n"");
  if(!ps_dec->i4_decode_header)
  {
  if(ps_dec->i4_header_decoded == 3)
  {
   
                             ps_dec->u4_slice_start_code_found = 1;
 
                             ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
 
                             i_status = ih264d_parse_decode_slice(
  (UWORD8)(u1_nal_unit_type
 
                                                              == IDR_SLICE_NAL),
                                              u1_nal_ref_idc, ps_dec);
  
                            if((ps_dec->u4_first_slice_in_pic != 0)&&
                                ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0))
                            {
                                 
                                ps_dec->u4_first_slice_in_pic = 1;
                            }
                              if(i_status != OK)
                              {
                                  return i_status;
  }
  }
  else
  {
                             H264_DEC_DEBUG_PRINT(
  ""\nSlice NAL Supplied but no header has been supplied\n"");
  }
  }
  break;
 
  case SEI_NAL:
  if(!ps_dec->i4_decode_header)
  {
                         ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                         i_status = ih264d_parse_sei_message(ps_dec, ps_bitstrm);
  if(i_status != OK)
  return i_status;
                         ih264d_parse_sei(ps_dec, ps_bitstrm);
  }
  break;
  case SEQ_PARAM_NAL:
   
                     ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                     i_status = ih264d_parse_sps(ps_dec, ps_bitstrm);
  if(i_status == ERROR_INV_SPS_PPS_T)
  return i_status;
  if(!i_status)
                         ps_dec->i4_header_decoded |= 0x1;
  break;
 
  case PIC_PARAM_NAL:
   
                     ih264d_rbsp_to_sodb(ps_dec->ps_bitstrm);
                     i_status = ih264d_parse_pps(ps_dec, ps_bitstrm);
  if(i_status == ERROR_INV_SPS_PPS_T)
  return i_status;
  if(!i_status)
                         ps_dec->i4_header_decoded |= 0x2;
  break;
  case ACCESS_UNIT_DELIMITER_RBSP:
  if(!ps_dec->i4_decode_header)
  {
                         ih264d_access_unit_delimiter_rbsp(ps_dec);
  }
  break;
  case END_OF_STREAM_RBSP:
  if(!ps_dec->i4_decode_header)
  {
                         ih264d_parse_end_of_stream(ps_dec);
  }
  break;
  case FILLER_DATA_NAL:
  if(!ps_dec->i4_decode_header)
  {
                         ih264d_parse_filler_data(ps_dec, ps_bitstrm);
  }
  break;
  default:
                     H264_DEC_DEBUG_PRINT(""\nUnknown NAL type %d\n"", u1_nal_unit_type);
  break;
  }
 
  }
 
  }
 
  return i_status;
 
 }","[73, 74, 75, 76, 77, 78]","An information disclosure vulnerability in libavc in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33551775."
208551," void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct16x16_c(in, out, stride);
 void fdct16x16_ref(const int16_t *in, tran_low_t *out, int stride,
                    int  ) {
   vpx_fdct16x16_c(in, out, stride);
  }","[3, 4, 5, 2]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
200072," static long vfio_pci_ioctl(void *device_data,
 			   unsigned int cmd, unsigned long arg)
 {
 	struct vfio_pci_device *vdev = device_data;
 	unsigned long minsz;
 
 	if (cmd == VFIO_DEVICE_GET_INFO) {
 		struct vfio_device_info info;
 
 		minsz = offsetofend(struct vfio_device_info, num_irqs);
 
 		if (copy_from_user(&info, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (info.argsz < minsz)
 			return -EINVAL;
 
 		info.flags = VFIO_DEVICE_FLAGS_PCI;
 
 		if (vdev->reset_works)
 			info.flags |= VFIO_DEVICE_FLAGS_RESET;
 
 		info.num_regions = VFIO_PCI_NUM_REGIONS + vdev->num_regions;
 		info.num_irqs = VFIO_PCI_NUM_IRQS;
 
 		return copy_to_user((void __user *)arg, &info, minsz) ?
 			-EFAULT : 0;
 
 	} else if (cmd == VFIO_DEVICE_GET_REGION_INFO) {
 		struct pci_dev *pdev = vdev->pdev;
 		struct vfio_region_info info;
 		struct vfio_info_cap caps = { .buf = NULL, .size = 0 };
 		int i, ret;
 
 		minsz = offsetofend(struct vfio_region_info, offset);
 
 		if (copy_from_user(&info, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (info.argsz < minsz)
 			return -EINVAL;
 
 		switch (info.index) {
 		case VFIO_PCI_CONFIG_REGION_INDEX:
 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 			info.size = pdev->cfg_size;
 			info.flags = VFIO_REGION_INFO_FLAG_READ |
 				     VFIO_REGION_INFO_FLAG_WRITE;
 			break;
 		case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:
 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 			info.size = pci_resource_len(pdev, info.index);
 			if (!info.size) {
 				info.flags = 0;
 				break;
 			}
 
 			info.flags = VFIO_REGION_INFO_FLAG_READ |
 				     VFIO_REGION_INFO_FLAG_WRITE;
 			if (vdev->bar_mmap_supported[info.index]) {
 				info.flags |= VFIO_REGION_INFO_FLAG_MMAP;
 				if (info.index == vdev->msix_bar) {
 					ret = msix_sparse_mmap_cap(vdev, &caps);
 					if (ret)
 						return ret;
 				}
 			}
 
 			break;
 		case VFIO_PCI_ROM_REGION_INDEX:
 		{
 			void __iomem *io;
 			size_t size;
 
 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 			info.flags = 0;
 
 			 
 			info.size = pci_resource_len(pdev, info.index);
 			if (!info.size) {
 				 
 				if (pdev->resource[PCI_ROM_RESOURCE].flags &
 							IORESOURCE_ROM_SHADOW)
 					info.size = 0x20000;
 				else
 					break;
 			}
 
 			 
 			io = pci_map_rom(pdev, &size);
 			if (!io || !size) {
 				info.size = 0;
 				break;
 			}
 			pci_unmap_rom(pdev, io);
 
 			info.flags = VFIO_REGION_INFO_FLAG_READ;
 			break;
 		}
 		case VFIO_PCI_VGA_REGION_INDEX:
 			if (!vdev->has_vga)
 				return -EINVAL;
 
 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 			info.size = 0xc0000;
 			info.flags = VFIO_REGION_INFO_FLAG_READ |
 				     VFIO_REGION_INFO_FLAG_WRITE;
 
 			break;
 		default:
 			if (info.index >=
 			    VFIO_PCI_NUM_REGIONS + vdev->num_regions)
 				return -EINVAL;
 
 			i = info.index - VFIO_PCI_NUM_REGIONS;
 
 			info.offset = VFIO_PCI_INDEX_TO_OFFSET(info.index);
 			info.size = vdev->region[i].size;
 			info.flags = vdev->region[i].flags;
 
 			ret = region_type_cap(vdev, &caps,
 					      vdev->region[i].type,
 					      vdev->region[i].subtype);
 			if (ret)
 				return ret;
 		}
 
 		if (caps.size) {
 			info.flags |= VFIO_REGION_INFO_FLAG_CAPS;
 			if (info.argsz < sizeof(info) + caps.size) {
 				info.argsz = sizeof(info) + caps.size;
 				info.cap_offset = 0;
 			} else {
 				vfio_info_cap_shift(&caps, sizeof(info));
 				if (copy_to_user((void __user *)arg +
 						  sizeof(info), caps.buf,
 						  caps.size)) {
 					kfree(caps.buf);
 					return -EFAULT;
 				}
 				info.cap_offset = sizeof(info);
 			}
 
 			kfree(caps.buf);
 		}
 
 		return copy_to_user((void __user *)arg, &info, minsz) ?
 			-EFAULT : 0;
 
 	} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {
 		struct vfio_irq_info info;
 
 		minsz = offsetofend(struct vfio_irq_info, count);
 
 		if (copy_from_user(&info, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)
 			return -EINVAL;
 
 		switch (info.index) {
 		case VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:
 		case VFIO_PCI_REQ_IRQ_INDEX:
 			break;
 		case VFIO_PCI_ERR_IRQ_INDEX:
 			if (pci_is_pcie(vdev->pdev))
 				break;
 		 
 		default:
 			return -EINVAL;
 		}
 
 		info.flags = VFIO_IRQ_INFO_EVENTFD;
 
 		info.count = vfio_pci_get_irq_count(vdev, info.index);
 
 		if (info.index == VFIO_PCI_INTX_IRQ_INDEX)
 			info.flags |= (VFIO_IRQ_INFO_MASKABLE |
 				       VFIO_IRQ_INFO_AUTOMASKED);
 		else
 			info.flags |= VFIO_IRQ_INFO_NORESIZE;
 
 		return copy_to_user((void __user *)arg, &info, minsz) ?
 			-EFAULT : 0;
  
  	} else if (cmd == VFIO_DEVICE_SET_IRQS) {
  		struct vfio_irq_set hdr;
 		size_t size;
  		u8 *data = NULL;
		int ret = 0;
 		int max, ret = 0;
  
  		minsz = offsetofend(struct vfio_irq_set, count);
  
  		if (copy_from_user(&hdr, (void __user *)arg, minsz))
  			return -EFAULT;
  
  		if (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||
 		    hdr.count >= (U32_MAX - hdr.start) ||
  		    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |
  				  VFIO_IRQ_SET_ACTION_TYPE_MASK))
  			return -EINVAL;
  
		if (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {
			size_t size;
			int max = vfio_pci_get_irq_count(vdev, hdr.index);
 		max = vfio_pci_get_irq_count(vdev, hdr.index);
 		if (hdr.start >= max || hdr.start + hdr.count > max)
 			return -EINVAL;
  
			if (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)
				size = sizeof(uint8_t);
			else if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)
				size = sizeof(int32_t);
			else
				return -EINVAL;
 		switch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {
 		case VFIO_IRQ_SET_DATA_NONE:
 			size = 0;
 			break;
 		case VFIO_IRQ_SET_DATA_BOOL:
 			size = sizeof(uint8_t);
 			break;
 		case VFIO_IRQ_SET_DATA_EVENTFD:
 			size = sizeof(int32_t);
 			break;
 		default:
 			return -EINVAL;
 		}
  
			if (hdr.argsz - minsz < hdr.count * size ||
			    hdr.start >= max || hdr.start + hdr.count > max)
 		if (size) {
 			if (hdr.argsz - minsz < hdr.count * size)
  				return -EINVAL;
  
  			data = memdup_user((void __user *)(arg + minsz),
 					   hdr.count * size);
 			if (IS_ERR(data))
 				return PTR_ERR(data);
 		}
 
 		mutex_lock(&vdev->igate);
 
 		ret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,
 					      hdr.start, hdr.count, data);
 
 		mutex_unlock(&vdev->igate);
 		kfree(data);
 
 		return ret;
 
 	} else if (cmd == VFIO_DEVICE_RESET) {
 		return vdev->reset_works ?
 			pci_try_reset_function(vdev->pdev) : -EINVAL;
 
 	} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {
 		struct vfio_pci_hot_reset_info hdr;
 		struct vfio_pci_fill_info fill = { 0 };
 		struct vfio_pci_dependent_device *devices = NULL;
 		bool slot = false;
 		int ret = 0;
 
 		minsz = offsetofend(struct vfio_pci_hot_reset_info, count);
 
 		if (copy_from_user(&hdr, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (hdr.argsz < minsz)
 			return -EINVAL;
 
 		hdr.flags = 0;
 
 		 
 		if (!pci_probe_reset_slot(vdev->pdev->slot))
 			slot = true;
 		else if (pci_probe_reset_bus(vdev->pdev->bus))
 			return -ENODEV;
 
 		 
 		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
 						    vfio_pci_count_devs,
 						    &fill.max, slot);
 		if (ret)
 			return ret;
 
 		WARN_ON(!fill.max);  
 
 		 
 		if (hdr.argsz < sizeof(hdr) + (fill.max * sizeof(*devices))) {
 			ret = -ENOSPC;
 			hdr.count = fill.max;
 			goto reset_info_exit;
 		}
 
 		devices = kcalloc(fill.max, sizeof(*devices), GFP_KERNEL);
 		if (!devices)
 			return -ENOMEM;
 
 		fill.devices = devices;
 
 		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
 						    vfio_pci_fill_devs,
 						    &fill, slot);
 
 		 
 		if (!ret)
 			hdr.count = fill.cur;
 
 reset_info_exit:
 		if (copy_to_user((void __user *)arg, &hdr, minsz))
 			ret = -EFAULT;
 
 		if (!ret) {
 			if (copy_to_user((void __user *)(arg + minsz), devices,
 					 hdr.count * sizeof(*devices)))
 				ret = -EFAULT;
 		}
 
 		kfree(devices);
 		return ret;
 
 	} else if (cmd == VFIO_DEVICE_PCI_HOT_RESET) {
 		struct vfio_pci_hot_reset hdr;
 		int32_t *group_fds;
 		struct vfio_pci_group_entry *groups;
 		struct vfio_pci_group_info info;
 		bool slot = false;
 		int i, count = 0, ret = 0;
 
 		minsz = offsetofend(struct vfio_pci_hot_reset, count);
 
 		if (copy_from_user(&hdr, (void __user *)arg, minsz))
 			return -EFAULT;
 
 		if (hdr.argsz < minsz || hdr.flags)
 			return -EINVAL;
 
 		 
 		if (!pci_probe_reset_slot(vdev->pdev->slot))
 			slot = true;
 		else if (pci_probe_reset_bus(vdev->pdev->bus))
 			return -ENODEV;
 
 		 
 		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
 						    vfio_pci_count_devs,
 						    &count, slot);
 		if (ret)
 			return ret;
 
 		 
 		if (!hdr.count || hdr.count > count)
 			return -EINVAL;
 
 		group_fds = kcalloc(hdr.count, sizeof(*group_fds), GFP_KERNEL);
 		groups = kcalloc(hdr.count, sizeof(*groups), GFP_KERNEL);
 		if (!group_fds || !groups) {
 			kfree(group_fds);
 			kfree(groups);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(group_fds, (void __user *)(arg + minsz),
 				   hdr.count * sizeof(*group_fds))) {
 			kfree(group_fds);
 			kfree(groups);
 			return -EFAULT;
 		}
 
 		 
 		for (i = 0; i < hdr.count; i++) {
 			struct vfio_group *group;
 			struct fd f = fdget(group_fds[i]);
 			if (!f.file) {
 				ret = -EBADF;
 				break;
 			}
 
 			group = vfio_group_get_external_user(f.file);
 			fdput(f);
 			if (IS_ERR(group)) {
 				ret = PTR_ERR(group);
 				break;
 			}
 
 			groups[i].group = group;
 			groups[i].id = vfio_external_user_iommu_id(group);
 		}
 
 		kfree(group_fds);
 
 		 
 		if (ret)
 			goto hot_reset_release;
 
 		info.count = hdr.count;
 		info.groups = groups;
 
 		 
 		ret = vfio_pci_for_each_slot_or_bus(vdev->pdev,
 						    vfio_pci_validate_devs,
 						    &info, slot);
 		if (!ret)
 			 
 			ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :
 				     pci_try_reset_bus(vdev->pdev->bus);
 
 hot_reset_release:
 		for (i--; i >= 0; i--)
 			vfio_group_put_external_user(groups[i].group);
 
 		kfree(groups);
 		return ret;
 	}
 
 	return -ENOTTY;
 }","[188, 191, 199, 207, 208, 209, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 233, 234, 190, 204, 205, 206, 211, 212, 213, 214, 215, 216, 231, 232]","drivers/vfio/pci/vfio_pci_intrs.c in the Linux kernel through 4.8.11 misuses the kzalloc function, which allows local users to cause a denial of service (integer overflow) or have unspecified other impact by leveraging access to a vfio PCI device file."
200666," static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 {
 	struct usb_device *hdev = hub->hdev;
 	struct usb_hcd *hcd;
 	int ret;
 	int port1;
 	int status;
 	bool need_debounce_delay = false;
  	unsigned delay;
  
  	 
	if (type == HUB_INIT2)
		goto init2;
	if (type == HUB_INIT3)
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
 		device_lock(hub->intfdev);
 
 		 
 		if (hub->disconnected) {
 			device_unlock(hub->intfdev);
 			kref_put(&hub->kref, hub_release);
 			return;
 		}
 		if (type == HUB_INIT2)
 			goto init2;
  		goto init3;
 	}
 	kref_get(&hub->kref);
  
  	 
 	if (type != HUB_RESUME) {
 		if (hdev->parent && hub_is_superspeed(hdev)) {
 			ret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
 					HUB_SET_DEPTH, USB_RT_HUB,
 					hdev->level - 1, 0, NULL, 0,
 					USB_CTRL_SET_TIMEOUT);
 			if (ret < 0)
 				dev_err(hub->intfdev,
 						""set hub depth failed\n"");
 		}
 
 		 
 		if (type == HUB_INIT) {
 			delay = hub_power_on_good_delay(hub);
 
 			hub_power_on(hub, false);
 			INIT_DELAYED_WORK(&hub->init_work, hub_init_func2);
 			queue_delayed_work(system_power_efficient_wq,
 					&hub->init_work,
 					msecs_to_jiffies(delay));
 
 			 
 			usb_autopm_get_interface_no_resume(
 					to_usb_interface(hub->intfdev));
 			return;		 
 		} else if (type == HUB_RESET_RESUME) {
 			 
 			hcd = bus_to_hcd(hdev->bus);
 			if (hcd->driver->update_hub_device) {
 				ret = hcd->driver->update_hub_device(hcd, hdev,
 						&hub->tt, GFP_NOIO);
 				if (ret < 0) {
 					dev_err(hub->intfdev, ""Host not ""
 							""accepting hub info ""
 							""update.\n"");
 					dev_err(hub->intfdev, ""LS/FS devices ""
 							""and hubs may not work ""
 							""under this hub\n."");
 				}
 			}
 			hub_power_on(hub, true);
 		} else {
 			hub_power_on(hub, true);
 		}
 	}
  init2:
 
 	 
 	for (port1 = 1; port1 <= hdev->maxchild; ++port1) {
 		struct usb_port *port_dev = hub->ports[port1 - 1];
 		struct usb_device *udev = port_dev->child;
 		u16 portstatus, portchange;
 
 		portstatus = portchange = 0;
 		status = hub_port_status(hub, port1, &portstatus, &portchange);
 		if (udev || (portstatus & USB_PORT_STAT_CONNECTION))
 			dev_dbg(&port_dev->dev, ""status %04x change %04x\n"",
 					portstatus, portchange);
 
 		 
 		if ((portstatus & USB_PORT_STAT_ENABLE) && (
 				type != HUB_RESUME ||
 				!(portstatus & USB_PORT_STAT_CONNECTION) ||
 				!udev ||
 				udev->state == USB_STATE_NOTATTACHED)) {
 			 
 			portstatus &= ~USB_PORT_STAT_ENABLE;
 			if (!hub_is_superspeed(hdev))
 				usb_clear_port_feature(hdev, port1,
 						   USB_PORT_FEAT_ENABLE);
 		}
 
 		 
 		if (portchange & USB_PORT_STAT_C_CONNECTION) {
 			need_debounce_delay = true;
 			usb_clear_port_feature(hub->hdev, port1,
 					USB_PORT_FEAT_C_CONNECTION);
 		}
 		if (portchange & USB_PORT_STAT_C_ENABLE) {
 			need_debounce_delay = true;
 			usb_clear_port_feature(hub->hdev, port1,
 					USB_PORT_FEAT_C_ENABLE);
 		}
 		if (portchange & USB_PORT_STAT_C_RESET) {
 			need_debounce_delay = true;
 			usb_clear_port_feature(hub->hdev, port1,
 					USB_PORT_FEAT_C_RESET);
 		}
 		if ((portchange & USB_PORT_STAT_C_BH_RESET) &&
 				hub_is_superspeed(hub->hdev)) {
 			need_debounce_delay = true;
 			usb_clear_port_feature(hub->hdev, port1,
 					USB_PORT_FEAT_C_BH_PORT_RESET);
 		}
 		 
 		if (!(portstatus & USB_PORT_STAT_CONNECTION) ||
 				(portchange & USB_PORT_STAT_C_CONNECTION))
 			clear_bit(port1, hub->removed_bits);
 
 		if (!udev || udev->state == USB_STATE_NOTATTACHED) {
 			 
 			if (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||
 			    (portstatus & USB_PORT_STAT_OVERCURRENT))
 				set_bit(port1, hub->change_bits);
 
 		} else if (portstatus & USB_PORT_STAT_ENABLE) {
 			bool port_resumed = (portstatus &
 					USB_PORT_STAT_LINK_STATE) ==
 				USB_SS_PORT_LS_U0;
 			 
 			if (portchange || (hub_is_superspeed(hub->hdev) &&
 						port_resumed))
 				set_bit(port1, hub->change_bits);
 
 		} else if (udev->persist_enabled) {
 #ifdef CONFIG_PM
 			udev->reset_resume = 1;
 #endif
 			 
 			if (test_bit(port1, hub->power_bits))
 				set_bit(port1, hub->change_bits);
 
 		} else {
 			 
 			usb_set_device_state(udev, USB_STATE_NOTATTACHED);
 			set_bit(port1, hub->change_bits);
 		}
 	}
 
 	 
 	if (need_debounce_delay) {
 		delay = HUB_DEBOUNCE_STABLE;
 
 		 
 		if (type == HUB_INIT2) {
 			INIT_DELAYED_WORK(&hub->init_work, hub_init_func3);
  			queue_delayed_work(system_power_efficient_wq,
  					&hub->init_work,
  					msecs_to_jiffies(delay));
 			device_unlock(hub->intfdev);
  			return;		 
  		} else {
  			msleep(delay);
 		}
 	}
  init3:
 	hub->quiescing = 0;
 
 	status = usb_submit_urb(hub->urb, GFP_NOIO);
 	if (status < 0)
 		dev_err(hub->intfdev, ""activate --> %d\n"", status);
 	if (hub->has_indicators && blinkenlights)
 		queue_delayed_work(system_power_efficient_wq,
 				&hub->leds, LED_CYCLE_PERIOD);
 
 	 
 	kick_hub_wq(hub);
 
  	 
  	if (type <= HUB_INIT3)
  		usb_autopm_put_interface_async(to_usb_interface(hub->intfdev));
 
 	if (type == HUB_INIT2 || type == HUB_INIT3)
 		device_unlock(hub->intfdev);
 
 	kref_put(&hub->kref, hub_release);
  }","[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 170, 192, 193, 194, 195, 196, 12, 13, 14]","The hub_activate function in drivers/usb/core/hub.c in the Linux kernel before 4.3.5 does not properly maintain a hub-interface data structure, which allows physically proximate attackers to cause a denial of service (invalid memory access and system crash) or possibly have unspecified other impact by unplugging a USB hub device."
205630," void Editor::ChangeSelectionAfterCommand(
     const SelectionInDOMTree& new_selection,
     const SetSelectionData& options) {
   if (new_selection.IsNone())
     return;
 
    bool selection_did_not_change_dom_position =
        new_selection == GetFrame().Selection().GetSelectionInDOMTree();
    GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder(new_selection)
          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())
          .Build(),
      options);
       new_selection,
       SetSelectionData::Builder(options)
           .SetShouldShowHandle(GetFrame().Selection().IsHandleVisible())
           .Build());
  
   if (selection_did_not_change_dom_position) {
     Client().RespondToChangedSelection(
         frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());
   }
 }","[14, 15, 16, 17, 10, 11, 12, 13]","The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data."
207688," make_transform_images(png_store *ps)
 make_transform_images(png_modifier *pm)
  {
     png_byte colour_type = 0;
     png_byte bit_depth = 0;
     unsigned int palette_number = 0;
  
      
   safecat(ps->test, sizeof ps->test, 0, ""make standard images"");
    safecat(pm->this.test, sizeof pm->this.test, 0, ""make standard images"");
  
      
   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
    while (next_format(&colour_type, &bit_depth, &palette_number, 1, 1))
     {
        int interlace_type;
  
  for (interlace_type = PNG_INTERLACE_NONE;
            interlace_type < INTERLACE_LAST; ++interlace_type)
  {
 
           char name[FILE_NAME_SIZE];
  
           standard_name(name, sizeof name, 0, colour_type, bit_depth,
            palette_number, interlace_type, 0, 0, 0);
         make_transform_image(ps, colour_type, bit_depth, palette_number,
             palette_number, interlace_type, 0, 0, do_own_interlace);
          make_transform_image(&pm->this, colour_type, bit_depth, palette_number,
              interlace_type, name);
        }
     }
  }","[2, 10, 14, 27, 28, 9, 13, 25, 26]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
197926," gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,
 gst_vorbis_tag_add_coverart (GstTagList * tags, gchar * img_data_base64,
      gint base64_len)
  {
    GstBuffer *img;
  guchar *img_data;
    gsize img_len;
   guchar *out;
    guint save = 0;
    gint state = 0;
  
    if (base64_len < 2)
      goto not_enough_data;
  
  img_data = g_try_malloc0 (base64_len * 3 / 4);
  if (img_data == NULL)
    goto alloc_failed;
  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,
      &state, &save);
    
   out = (guchar *) img_data_base64;
   img_len = g_base64_decode_step (img_data_base64, base64_len,
       out, &state, &save);
  
    if (img_len == 0)
      goto decode_failed;
  
  img = gst_tag_image_data_to_image_buffer (img_data, img_len,
   img = gst_tag_image_data_to_image_buffer (out, img_len,
        GST_TAG_IMAGE_TYPE_NONE);
  
    if (img == NULL)
   gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,
       GST_TAG_PREVIEW_IMAGE, img, NULL);
 
        GST_TAG_PREVIEW_IMAGE, img, NULL);
  
    gst_buffer_unref (img);
  g_free (img_data);
    return;
  
   
   {
     GST_WARNING (""COVERART tag with too little base64-encoded data"");
      GST_WARNING (""COVERART tag with too little base64-encoded data"");
      return;
    }
alloc_failed:
  {
    GST_WARNING (""Couldn't allocate enough memory to decode COVERART tag"");
    return;
  }
  decode_failed:
    {
    GST_WARNING (""Couldn't decode bas64 image data from COVERART tag"");
    g_free (img_data);
     GST_WARNING (""Couldn't decode base64 image data from COVERART tag"");
      return;
    }
  convert_failed:
    {
      GST_WARNING (""Couldn't extract image or image type from COVERART tag"");
    g_free (img_data);
      return;
    }
  }","[2, 8, 20, 21, 22, 23, 29, 57, 6, 15, 16, 17, 18, 19, 28, 39, 48, 49, 50, 51, 52, 55, 56, 63]","Integer overflow in the gst_vorbis_tag_add_coverart function (gst-libs/gst/tag/gstvorbistag.c) in vorbistag in gst-plugins-base (aka gstreamer-plugins-base) before 0.10.23 in GStreamer allows context-dependent attackers to execute arbitrary code via a crafted COVERART tag that is converted from a base64 representation, which triggers a heap-based buffer overflow."
200697," setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)
  {
      static generic_ret              ret;
      char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
      OM_uint32                       minor_stat;
      kadm5_server_handle_t           handle;
      const char                      *errmsg = NULL;
 
     xdr_free(xdr_generic_ret, &ret);
 
     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
         goto exit_func;
 
     if ((ret.code = check_handle((void *)handle)))
         goto exit_func;
 
     ret.api_version = handle->api_version;
 
     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
         ret.code = KADM5_FAILURE;
         goto exit_func;
     }
     if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
         ret.code = KADM5_BAD_PRINCIPAL;
         goto exit_func;
     }
 
     if (!(CHANGEPW_SERVICE(rqstp)) &&
         kadm5int_acl_check(handle->context, rqst2name(rqstp),
                            ACL_SETKEY, arg->princ, NULL)) {
         ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,
                                             arg->keepold,
                                             arg->n_ks_tuple,
                                             arg->ks_tuple,
                                             arg->keyblocks, arg->n_keys);
     } else {
         log_unauth(""kadm5_setkey_principal"", prime_arg,
                    &client_name, &service_name, rqstp);
         ret.code = KADM5_AUTH_SETKEY;
     }
 
     if(ret.code != KADM5_AUTH_SETKEY) {
         if( ret.code != 0 )
             errmsg = krb5_get_error_message(handle->context, ret.code);
 
         log_done(""kadm5_setkey_principal"", prime_arg, errmsg,
                  &client_name, &service_name, rqstp);
 
         if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
      }
  
      free(prime_arg);
 exit_func:
      gss_release_buffer(&minor_stat, &client_name);
      gss_release_buffer(&minor_stat, &service_name);
exit_func:
      free_server_handle(handle);
      return &ret;
  }","[7, 8, 58, 5, 6, 61]",Multiple memory leaks in kadmin/server/server_stubs.c in kadmind in MIT Kerberos 5 (aka krb5) before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (memory consumption) via a request specifying a NULL principal name.
208150,"      void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
        if (!mIsBackup) {
         if (!mCopyToOmx) {
              return;
          }
  
         memcpy(header->pBuffer + header->nOffset,
  (const OMX_U8 *)mMem->pointer() + header->nOffset,
                 header->nFilledLen);
  }","[3, 2]","An information disclosure vulnerability in libstagefright in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-11-01, and 7.0 before 2016-11-01 could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access sensitive data without permission. Android ID: A-29422020."
199289,"  static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)
  {
	if (!vcpu->arch.time_page)
 	if (!vcpu->arch.pv_time_enabled)
  		return -EINVAL;
  	vcpu->arch.pvclock_set_guest_stopped_request = true;
  	kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
 	return 0;
 }","[4, 3]",Use-after-free vulnerability in arch/x86/kvm/x86.c in the Linux kernel through 3.8.4 allows guest OS users to cause a denial of service (host OS memory corruption) or possibly have unspecified other impact via a crafted application that triggers use of a guest physical address (GPA) in (1) movable or (2) removable memory during an MSR_KVM_SYSTEM_TIME kvm_set_msr_common operation.
199644," static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,
 					    struct pluto_crypto_req *r,
 					    err_t ugh)
 {
 	struct dh_continuation *dh = (struct dh_continuation *)pcrc;
 	struct msg_digest *md = dh->md;
 	struct state *const st = md->st;
 	stf_status e;
 
 	DBG(DBG_CONTROLMORE,
 	    DBG_log(""ikev2 parent inR1outI2: calculating g^{xy}, sending I2""));
 
 	if (st == NULL) {
 		loglog(RC_LOG_SERIOUS,
 		       ""%s: Request was disconnected from state"",
 		       __FUNCTION__);
 		if (dh->md)
 			release_md(dh->md);
 		return;
 	}
 
 	 
 	passert(ugh == NULL);
 	passert(cur_state == NULL);
 	passert(st != NULL);
 
 	passert(st->st_suspended_md == dh->md);
 	set_suspended(st, NULL);  
 
 	set_cur_state(st);
 
 	st->st_calculating = FALSE;
 
 	e = ikev2_parent_inR1outI2_tail(pcrc, r);
 
 	if (dh->md != NULL) {
 		complete_v2_state_transition(&dh->md, e);
 		if (dh->md)
  			release_md(dh->md);
  	}
  	reset_globals();
	passert(GLOBALS_ARE_RESET());
  }",[42],The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.
19,"rb_dlhandle_sym(VALUE self, VALUE sym)
{
void (*func)();
struct dl_handle *dlhandle;
void *handle;
const char *name;
const char *err;
int i;

#if defined(HAVE_DLERROR)
# define CHECK_DLERROR if( err = dlerror() ){ func = 0; }
#else
# define CHECK_DLERROR
#endif

rb_secure(2);

name = StringValuePtr(sym);

Data_Get_Struct(self, struct dl_handle, dlhandle);
if( ! dlhandle->open ){
rb_raise(rb_eDLError, ""closed handle"");
}
handle = dlhandle->ptr;

func = dlsym(handle, name);
CHECK_DLERROR;
#if defined(FUNC_STDCALL)
if( !func ){
int  len = strlen(name);
char *name_n;
#if defined(__CYGWIN__) || defined(_WIN32) || defined(__MINGW32__)
{
char *name_a = (char*)xmalloc(len+2);
strcpy(name_a, name);
name_n = name_a;
name_a[len]   = 'A';
name_a[len+1] = '\0';
func = dlsym(handle, name_a);
CHECK_DLERROR;
if( func ) goto found;
name_n = xrealloc(name_a, len+6);
}
#else
name_n = (char*)xmalloc(len+6);
#endif
memcpy(name_n, name, len);
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
if( func ) goto found;
name_n[len-1] = 'A';
name_n[len++] = '@';
for( i = 0; i < 256; i += 4 ){
sprintf(name_n + len, ""%d"", i);
func = dlsym(handle, name_n);
CHECK_DLERROR;
if( func ) break;
}
found:
xfree(name_n);
}
#endif
if( !func ){
rb_raise(rb_eDLError, ""unknown symbol \""%s\"""", name);
}

return PTR2NUM(func);
}",[18],"DL::dlopen in Ruby 1.8, 1.9.0, 1.9.2, 1.9.3, 2.0.0 before patchlevel 648, and 2.1 before 2.1.8 opens libraries with tainted names."
207827," long Cluster::CreateBlock(long long id,
  long long pos,  
  long long size, long long discard_padding) {
   assert((id == 0x20) || (id == 0x23));  
 
  if (m_entries_count < 0) {  
     assert(m_entries == NULL);
 
      assert(m_entries_size == 0);
  
      m_entries_size = 1024;
    m_entries = new BlockEntry* [m_entries_size];
     m_entries = new (std::nothrow) BlockEntry*[m_entries_size];
     if (m_entries == NULL)
       return -1;
  
      m_entries_count = 0;
    } else {
     assert(m_entries);
     assert(m_entries_size > 0);
     assert(m_entries_count <= m_entries_size);
 
 
      if (m_entries_count >= m_entries_size) {
        const long entries_size = 2 * m_entries_size;
  
      BlockEntry** const entries = new BlockEntry* [entries_size];
      assert(entries);
       BlockEntry** const entries = new (std::nothrow) BlockEntry*[entries_size];
       if (entries == NULL)
         return -1;
  
        BlockEntry** src = m_entries;
        BlockEntry** const src_end = src + m_entries_count;
 
  BlockEntry** dst = entries;
 
  while (src != src_end)
  *dst++ = *src++;
 
  delete[] m_entries;
 
       m_entries = entries;
       m_entries_size = entries_size;
  }
  }
 
  if (id == 0x20)  
  return CreateBlockGroup(pos, size, discard_padding);
  else  
  return CreateSimpleBlock(pos, size);
 }","[13, 14, 15, 29, 30, 31, 12, 27, 28]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
204425,"  void ChromeMockRenderThread::OnGetDefaultPrintSettings(
      PrintMsg_Print_Params* params) {
  if (printer_.get())
    printer_->GetDefaultPrintSettings(params);
   printer_->GetDefaultPrintSettings(params);
  }","[5, 3, 4]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
198742," int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
 	struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
 	struct inet_sock *inet = inet_sk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 	__be16 orig_sport, orig_dport;
 	__be32 daddr, nexthop;
  	struct flowi4 fl4;
  	struct rtable *rt;
  	int err;
 	struct ip_options_rcu *inet_opt;
  
  	if (addr_len < sizeof(struct sockaddr_in))
  		return -EINVAL;
 
 	if (usin->sin_family != AF_INET)
  		return -EAFNOSUPPORT;
  
  	nexthop = daddr = usin->sin_addr.s_addr;
	if (inet->opt && inet->opt->srr) {
 	inet_opt = rcu_dereference_protected(inet->inet_opt,
 					     sock_owned_by_user(sk));
 	if (inet_opt && inet_opt->opt.srr) {
  		if (!daddr)
  			return -EINVAL;
		nexthop = inet->opt->faddr;
 		nexthop = inet_opt->opt.faddr;
  	}
  
  	orig_sport = inet->inet_sport;
 	orig_dport = usin->sin_port;
 	rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,
 			      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
 			      IPPROTO_TCP,
 			      orig_sport, orig_dport, sk, true);
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		if (err == -ENETUNREACH)
 			IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);
 		return err;
 	}
 
 	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
 		ip_rt_put(rt);
  		return -ENETUNREACH;
  	}
  
	if (!inet->opt || !inet->opt->srr)
 	if (!inet_opt || !inet_opt->opt.srr)
  		daddr = rt->rt_dst;
  
  	if (!inet->inet_saddr)
 		inet->inet_saddr = rt->rt_src;
 	inet->inet_rcv_saddr = inet->inet_saddr;
 
 	if (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) {
 		 
 		tp->rx_opt.ts_recent	   = 0;
 		tp->rx_opt.ts_recent_stamp = 0;
 		tp->write_seq		   = 0;
 	}
 
 	if (tcp_death_row.sysctl_tw_recycle &&
 	    !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) {
 		struct inet_peer *peer = rt_get_peer(rt);
 		 
 		if (peer) {
 			inet_peer_refcheck(peer);
 			if ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) {
 				tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp;
 				tp->rx_opt.ts_recent = peer->tcp_ts;
 			}
 		}
 	}
 
 	inet->inet_dport = usin->sin_port;
  	inet->inet_daddr = daddr;
  
  	inet_csk(sk)->icsk_ext_hdr_len = 0;
	if (inet->opt)
		inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;
 	if (inet_opt)
 		inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;
  
  	tp->rx_opt.mss_clamp = TCP_MSS_DEFAULT;
  
 	 
 	tcp_set_state(sk, TCP_SYN_SENT);
 	err = inet_hash_connect(&tcp_death_row, sk);
 	if (err)
 		goto failure;
 
 	rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,
 			       inet->inet_sport, inet->inet_dport, sk);
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		rt = NULL;
 		goto failure;
 	}
 	 
 	sk->sk_gso_type = SKB_GSO_TCPV4;
 	sk_setup_caps(sk, &rt->dst);
 
 	if (!tp->write_seq)
 		tp->write_seq = secure_tcp_sequence_number(inet->inet_saddr,
 							   inet->inet_daddr,
 							   inet->inet_sport,
 							   usin->sin_port);
 
 	inet->inet_id = tp->write_seq ^ jiffies;
 
 	err = tcp_connect(sk);
 	rt = NULL;
 	if (err)
 		goto failure;
 
 	return 0;
 
 failure:
 	 
 	tcp_set_state(sk, TCP_CLOSE);
 	ip_rt_put(rt);
 	sk->sk_route_caps = 0;
 	inet->inet_dport = 0;
 	return err;
 }","[11, 21, 22, 23, 27, 49, 82, 83, 20, 26, 48, 80, 81]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
202692," static void pcd_init_units(void)
 {
 	struct pcd_unit *cd;
 	int unit;
 
 	pcd_drive_count = 0;
 	for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {
 		struct gendisk *disk = alloc_disk(1);
 
 		if (!disk)
 			continue;
 
  		disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,
  						   1, BLK_MQ_F_SHOULD_MERGE);
  		if (IS_ERR(disk->queue)) {
 			put_disk(disk);
  			disk->queue = NULL;
  			continue;
  		}
 
 		INIT_LIST_HEAD(&cd->rq_list);
 		disk->queue->queuedata = cd;
 		blk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);
 		cd->disk = disk;
 		cd->pi = &cd->pia;
 		cd->present = 0;
 		cd->last_sense = 0;
 		cd->changed = 1;
 		cd->drive = (*drives[unit])[D_SLV];
 		if ((*drives[unit])[D_PRT])
 			pcd_drive_count++;
 
 		cd->name = &cd->info.name[0];
 		snprintf(cd->name, sizeof(cd->info.name), ""%s%d"", name, unit);
 		cd->info.ops = &pcd_dops;
 		cd->info.handle = cd;
 		cd->info.speed = 0;
 		cd->info.capacity = 1;
 		cd->info.mask = 0;
 		disk->major = major;
 		disk->first_minor = unit;
 		strcpy(disk->disk_name, cd->name);	 
 		disk->fops = &pcd_bdops;
 		disk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;
 	}
 }",[16],An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.
206496," void GLES2Implementation::BeginQueryEXT(GLenum target, GLuint id) {
   GPU_CLIENT_SINGLE_THREAD_CHECK();
   GPU_CLIENT_LOG(""["" << GetLogPrefix() << ""] BeginQueryEXT(""
                      << GLES2Util::GetStringQueryTarget(target) << "", "" << id
                      << "")"");
 
   switch (target) {
     case GL_COMMANDS_ISSUED_CHROMIUM:
      case GL_LATENCY_QUERY_CHROMIUM:
      case GL_ASYNC_PIXEL_PACK_COMPLETED_CHROMIUM:
      case GL_GET_ERROR_QUERY_CHROMIUM:
     case GL_PROGRAM_COMPLETION_QUERY_CHROMIUM:
        break;
      case GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM:
      case GL_COMMANDS_COMPLETED_CHROMIUM:
       if (!capabilities_.sync_query) {
         SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"",
                    ""not enabled for commands completed queries"");
         return;
       }
       break;
     case GL_SAMPLES_PASSED_ARB:
       if (!capabilities_.occlusion_query) {
         SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"",
                    ""not enabled for occlusion queries"");
         return;
       }
       break;
     case GL_ANY_SAMPLES_PASSED:
     case GL_ANY_SAMPLES_PASSED_CONSERVATIVE:
       if (!capabilities_.occlusion_query_boolean) {
         SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"",
                    ""not enabled for boolean occlusion queries"");
         return;
       }
       break;
     case GL_TIME_ELAPSED_EXT:
       if (!capabilities_.timer_queries) {
         SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"",
                    ""not enabled for timing queries"");
         return;
       }
       break;
     case GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:
       if (capabilities_.major_version >= 3)
         break;
       FALLTHROUGH;
     default:
       SetGLError(GL_INVALID_ENUM, ""glBeginQueryEXT"", ""unknown query target"");
       return;
   }
 
   if (query_tracker_->GetCurrentQuery(target)) {
     SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"",
                ""query already in progress"");
     return;
   }
 
   if (id == 0) {
     SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"", ""id is 0"");
     return;
   }
 
   if (!GetIdAllocator(IdNamespaces::kQueries)->InUse(id)) {
     SetGLError(GL_INVALID_OPERATION, ""glBeginQueryEXT"", ""invalid id"");
     return;
   }
 
   switch (target) {
     case GL_TIME_ELAPSED_EXT:
       if (!query_tracker_->SetDisjointSync(this)) {
         SetGLError(GL_OUT_OF_MEMORY, ""glBeginQueryEXT"",
                    ""buffer allocation failed"");
         return;
       }
       break;
     default:
       break;
   }
 
   if (query_tracker_->BeginQuery(id, target, this))
     CheckGLError();
 
   if (target == GL_READBACK_SHADOW_COPIES_UPDATED_CHROMIUM) {
     AllocateShadowCopiesForReadback();
   }
 }",[12],"A heap use after free in V8 in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
199656," static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
 			struct msghdr *msg, size_t len, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct alg_sock *ask = alg_sk(sk);
 	struct hash_ctx *ctx = ask->private;
 	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
 	int err;
 
 	if (len > ds)
 		len = ds;
  	else if (len < ds)
  		msg->msg_flags |= MSG_TRUNC;
  
	msg->msg_namelen = 0;
  	lock_sock(sk);
  	if (ctx->more) {
  		ctx->more = 0;
 		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
 		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
 						 &ctx->completion);
 		if (err)
 			goto unlock;
 	}
 
 	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);
 
 unlock:
 	release_sock(sk);
 
 	return err ?: len;
 }",[15],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
200705," static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
 {
 	struct encrypted_key_payload *epayload = key->payload.data[0];
 	struct encrypted_key_payload *new_epayload;
 	char *buf;
 	char *new_master_desc = NULL;
 	const char *format = NULL;
  	size_t datalen = prep->datalen;
  	int ret = 0;
  
 	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
 		return -ENOKEY;
  	if (datalen <= 0 || datalen > 32767 || !prep->data)
  		return -EINVAL;
  
 	buf = kmalloc(datalen + 1, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
 	buf[datalen] = 0;
 	memcpy(buf, prep->data, datalen);
 	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
 	if (ret < 0)
 		goto out;
 
 	ret = valid_master_desc(new_master_desc, epayload->master_desc);
 	if (ret < 0)
 		goto out;
 
 	new_epayload = encrypted_key_alloc(key, epayload->format,
 					   new_master_desc, epayload->datalen);
 	if (IS_ERR(new_epayload)) {
 		ret = PTR_ERR(new_epayload);
 		goto out;
 	}
 
 	__ekey_init(new_epayload, epayload->format, new_master_desc,
 		    epayload->datalen);
 
 	memcpy(new_epayload->iv, epayload->iv, ivsize);
 	memcpy(new_epayload->payload_data, epayload->payload_data,
 	       epayload->payload_datalen);
 
 	rcu_assign_keypointer(key, new_epayload);
 	call_rcu(&epayload->rcu, encrypted_rcu_free);
 out:
 	kfree(buf);
 	return ret;
 }","[11, 12]","The KEYS subsystem in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (BUG) via crafted keyctl commands that negatively instantiate a key, related to security/keys/encrypted-keys/encrypted.c, security/keys/trusted.c, and security/keys/user_defined.c."
201027," pimv1_join_prune_print(netdissect_options *ndo,
                        register const u_char *bp, register u_int len)
 {
 	int ngroups, njoin, nprune;
 	int njp;
 
 	 
 	if (ND_TTEST2(bp[0], 30) && bp[11] == 1 &&
 	    ((njoin = EXTRACT_16BITS(&bp[20])) + EXTRACT_16BITS(&bp[22])) == 1) {
 		int hold;
 
 		ND_PRINT((ndo, "" RPF %s "", ipaddr_string(ndo, bp)));
 		hold = EXTRACT_16BITS(&bp[6]);
 		if (hold != 180) {
 			ND_PRINT((ndo, ""Hold ""));
 			unsigned_relts_print(ndo, hold);
 		}
 		ND_PRINT((ndo, ""%s (%s/%d, %s"", njoin ? ""Join"" : ""Prune"",
 		ipaddr_string(ndo, &bp[26]), bp[25] & 0x3f,
 		ipaddr_string(ndo, &bp[12])));
 		if (EXTRACT_32BITS(&bp[16]) != 0xffffffff)
 			ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[16])));
 		ND_PRINT((ndo, "") %s%s %s"",
 		    (bp[24] & 0x01) ? ""Sparse"" : ""Dense"",
 		    (bp[25] & 0x80) ? "" WC"" : """",
 		    (bp[25] & 0x40) ? ""RP"" : ""SPT""));
  		return;
  	}
  
 	if (len < sizeof(struct in_addr))
 		goto trunc;
  	ND_TCHECK2(bp[0], sizeof(struct in_addr));
  	if (ndo->ndo_vflag > 1)
  		ND_PRINT((ndo, ""\n""));
  	ND_PRINT((ndo, "" Upstream Nbr: %s"", ipaddr_string(ndo, bp)));
	ND_TCHECK2(bp[6], 2);
 	bp += 4;
 	len -= 4;
 	if (len < 4)
 		goto trunc;
 	ND_TCHECK2(bp[2], 2);
  	if (ndo->ndo_vflag > 1)
  		ND_PRINT((ndo, ""\n""));
  	ND_PRINT((ndo, "" Hold time: ""));
	unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[6]));
 	unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[2]));
  	if (ndo->ndo_vflag < 2)
  		return;
	bp += 8;
	len -= 8;
 	bp += 4;
 	len -= 4;
  
 	if (len < 4)
 		goto trunc;
  	ND_TCHECK2(bp[0], 4);
  	ngroups = bp[3];
  	bp += 4;
 	len -= 4;
 	while (ngroups--) {
 		 
 		if (len < 4)
 			goto trunc;
  		ND_TCHECK2(bp[0], sizeof(struct in_addr));
  		ND_PRINT((ndo, ""\n\tGroup: %s"", ipaddr_string(ndo, bp)));
		ND_TCHECK2(bp[4], sizeof(struct in_addr));
		if (EXTRACT_32BITS(&bp[4]) != 0xffffffff)
			ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[4])));
		ND_TCHECK2(bp[8], 4);
		njoin = EXTRACT_16BITS(&bp[8]);
		nprune = EXTRACT_16BITS(&bp[10]);
 		bp += 4;
 		len -= 4;
 		if (len < 4)
 			goto trunc;
 		ND_TCHECK2(bp[0], sizeof(struct in_addr));
 		if (EXTRACT_32BITS(&bp[0]) != 0xffffffff)
 			ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[0])));
 		bp += 4;
 		len -= 4;
 		if (len < 4)
 			goto trunc;
 		ND_TCHECK2(bp[0], 4);
 		njoin = EXTRACT_16BITS(&bp[0]);
 		nprune = EXTRACT_16BITS(&bp[2]);
  		ND_PRINT((ndo, "" joined: %d pruned: %d"", njoin, nprune));
		bp += 12;
		len -= 12;
 		bp += 4;
 		len -= 4;
  		for (njp = 0; njp < (njoin + nprune); njp++) {
  			const char *type;
  
  			if (njp < njoin)
  				type = ""Join "";
  			else
  				type = ""Prune"";
 			if (len < 6)
 				goto trunc;
  			ND_TCHECK2(bp[0], 6);
  			ND_PRINT((ndo, ""\n\t%s %s%s%s%s/%d"", type,
  			    (bp[0] & 0x01) ? ""Sparse "" : ""Dense "",
  			    (bp[1] & 0x80) ? ""WC "" : """",
  			    (bp[1] & 0x40) ? ""RP "" : ""SPT "",
			ipaddr_string(ndo, &bp[2]), bp[1] & 0x3f));
 			    ipaddr_string(ndo, &bp[2]),
 			    bp[1] & 0x3f));
  			bp += 6;
  			len -= 6;
  		}
 	}
 	return;
 trunc:
 	ND_PRINT((ndo, ""[|pim]""));
 	return;
 }","[30, 31, 37, 38, 39, 40, 41, 46, 51, 52, 54, 55, 62, 63, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 89, 90, 98, 99, 106, 107, 36, 45, 49, 50, 66, 67, 68, 69, 70, 71, 87, 88, 105]","The PIM parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c, several functions."
208135," void lppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans,  
                     QMF_SCALE_FACTOR  *sbrScaleFactor,  
                     FIXP_DBL **qmfBufferReal,  
 
                     FIXP_DBL *degreeAlias,  
                     FIXP_DBL **qmfBufferImag,  
  const int useLP,
  const int timeStep,  
  const int firstSlotOffs,  
  const int lastSlotOffs,  
  const int nInvfBands,  
                     INVF_MODE *sbr_invf_mode,  
                     INVF_MODE *sbr_invf_mode_prev       
  )
 {
   INT    bwIndex[MAX_NUM_PATCHES];
   FIXP_DBL  bwVector[MAX_NUM_PATCHES];  
 
  int    i;
  int    loBand, start, stop;
   TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;
   PATCH_PARAM *patchParam = pSettings->patchParam;
  int    patch;
 
   FIXP_SGL  alphar[LPC_ORDER], a0r, a1r;
   FIXP_SGL  alphai[LPC_ORDER], a0i=0, a1i=0;
   FIXP_SGL  bw = FL2FXCONST_SGL(0.0f);
 
  int    autoCorrLength;
 
   FIXP_DBL k1, k1_below=0, k1_below2=0;
 
   ACORR_COEFS ac;
  int    startSample;
  int    stopSample;
  int    stopSampleClear;
 
  int comLowBandScale;
  int ovLowBandShift;
  int lowBandShift;
  
  int targetStopBand;
 
 
   alphai[0] = FL2FXCONST_SGL(0.0f);
   alphai[1] = FL2FXCONST_SGL(0.0f);
 
 
   startSample = firstSlotOffs * timeStep;
   stopSample  = pSettings->nCols + lastSlotOffs * timeStep;
 
 
   inverseFilteringLevelEmphasis(hLppTrans, nInvfBands, sbr_invf_mode, sbr_invf_mode_prev, bwVector);
 
   stopSampleClear = stopSample;
 
   autoCorrLength = pSettings->nCols + pSettings->overlap;
 
   
   targetStopBand = patchParam[pSettings->noOfPatches-1].targetStartBand
  + patchParam[pSettings->noOfPatches-1].numBandsInPatch;
 
  int memSize = ((64) - targetStopBand) * sizeof(FIXP_DBL);
 
  if (!useLP) {
  for (i = startSample; i < stopSampleClear; i++) {
  FDKmemclear(&qmfBufferReal[i][targetStopBand], memSize);
  FDKmemclear(&qmfBufferImag[i][targetStopBand], memSize);
  }
  } else
  for (i = startSample; i < stopSampleClear; i++) {
  FDKmemclear(&qmfBufferReal[i][targetStopBand], memSize);
 
    }
  
     
  FDKmemclear(bwIndex, pSettings->noOfPatches*sizeof(INT));
   FDKmemclear(bwIndex, MAX_NUM_PATCHES*sizeof(INT));
  
     
   comLowBandScale = fixMin(sbrScaleFactor->ov_lb_scale,sbrScaleFactor->lb_scale);
 
   ovLowBandShift =  sbrScaleFactor->ov_lb_scale - comLowBandScale;
   lowBandShift   =  sbrScaleFactor->lb_scale - comLowBandScale;
   
 
   
 
  if (!useLP) {
     start = pSettings->lbStartPatching;
     stop = pSettings->lbStopPatching;
  } else
  {
     start = fixMax(1, pSettings->lbStartPatching - 2);
     stop = patchParam[0].targetStartBand;
  }
 
 
  for ( loBand = start; loBand <  stop; loBand++ ) {
 
     FIXP_DBL  lowBandReal[(((1024)/(32))+(6))+LPC_ORDER];
     FIXP_DBL *plowBandReal = lowBandReal;
     FIXP_DBL **pqmfBufferReal = qmfBufferReal;
     FIXP_DBL  lowBandImag[(((1024)/(32))+(6))+LPC_ORDER];
     FIXP_DBL *plowBandImag = lowBandImag;
     FIXP_DBL **pqmfBufferImag = qmfBufferImag;
  int resetLPCCoeffs=0;
  int dynamicScale = DFRACT_BITS-1-LPC_SCALE_FACTOR;
  int acDetScale = 0;  
 
  for(i=0;i<LPC_ORDER;i++){
  *plowBandReal++ = hLppTrans->lpcFilterStatesReal[i][loBand];
  if (!useLP)
  *plowBandImag++ = hLppTrans->lpcFilterStatesImag[i][loBand];
  }
 
   
  if (!useLP) {
  for(i=0;i<pSettings->nCols+pSettings->overlap;i++){
  *plowBandReal++ = (*pqmfBufferReal++)[loBand];
  *plowBandImag++ = (*pqmfBufferImag++)[loBand];
  }
  } else
  {
   
       FDK_ASSERT((pSettings->overlap & 1) == 0);
 
  for(i=0;i<((pSettings->overlap+pSettings->nCols)>>1);i++) {
  *plowBandReal++ = (*pqmfBufferReal++)[loBand];
  *plowBandReal++ = (*pqmfBufferReal++)[loBand];
  }
  if (pSettings->nCols & 1) {
  *plowBandReal++ = (*pqmfBufferReal++)[loBand];
  }
  }
 
   
     dynamicScale = fixMin(dynamicScale, getScalefactor(lowBandReal, LPC_ORDER+pSettings->overlap) + ovLowBandShift);
     dynamicScale = fixMin(dynamicScale, getScalefactor(&lowBandReal[LPC_ORDER+pSettings->overlap], pSettings->nCols) + lowBandShift);
  if (!useLP) {
       dynamicScale = fixMin(dynamicScale, getScalefactor(lowBandImag, LPC_ORDER+pSettings->overlap) + ovLowBandShift);
       dynamicScale = fixMin(dynamicScale, getScalefactor(&lowBandImag[LPC_ORDER+pSettings->overlap], pSettings->nCols) + lowBandShift);
  }
     dynamicScale = fixMax(0, dynamicScale-1);  
 
   
     scaleValues(&lowBandReal[0], LPC_ORDER+pSettings->overlap, dynamicScale-ovLowBandShift);
     scaleValues(&lowBandReal[LPC_ORDER+pSettings->overlap], pSettings->nCols, dynamicScale-lowBandShift);
 
  if (!useLP) {
       scaleValues(&lowBandImag[0], LPC_ORDER+pSettings->overlap, dynamicScale-ovLowBandShift);
       scaleValues(&lowBandImag[LPC_ORDER+pSettings->overlap], pSettings->nCols, dynamicScale-lowBandShift);
  }
 
 
  if (!useLP) {
         acDetScale += autoCorr2nd_cplx(&ac, lowBandReal+LPC_ORDER, lowBandImag+LPC_ORDER, autoCorrLength);
  }
  else
  {
         acDetScale += autoCorr2nd_real(&ac, lowBandReal+LPC_ORDER, autoCorrLength);
  }
 
   
       acDetScale += 2*(comLowBandScale + dynamicScale);
       acDetScale *= 2;  
       acDetScale += ac.det_scale;  
 
   
  if (acDetScale>126 ) {
         resetLPCCoeffs = 1;
  }
 
 
     alphar[1] = FL2FXCONST_SGL(0.0f);
  if (!useLP)
       alphai[1] = FL2FXCONST_SGL(0.0f);
 
  if (ac.det != FL2FXCONST_DBL(0.0f)) {
       FIXP_DBL tmp,absTmp,absDet;
 
       absDet = fixp_abs(ac.det);
 
  if (!useLP) {
         tmp = ( fMultDiv2(ac.r01r,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) -
  ( (fMultDiv2(ac.r01i,ac.r12i) + fMultDiv2(ac.r02r,ac.r11r)) >> (LPC_SCALE_FACTOR-1) );
  } else
  {
         tmp = ( fMultDiv2(ac.r01r,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) -
  ( fMultDiv2(ac.r02r,ac.r11r) >> (LPC_SCALE_FACTOR-1) );
  }
       absTmp = fixp_abs(tmp);
 
   
  {
         INT scale;
         FIXP_DBL result = fDivNorm(absTmp, absDet, &scale);
         scale = scale+ac.det_scale;
 
  if ( (scale > 0) && (result >= (FIXP_DBL)MAXVAL_DBL>>scale) ) {
           resetLPCCoeffs = 1;
  }
  else {
           alphar[1] = FX_DBL2FX_SGL(scaleValue(result,scale));
  if((tmp<FL2FX_DBL(0.0f)) ^ (ac.det<FL2FX_DBL(0.0f))) {
             alphar[1] = -alphar[1];
  }
  }
  }
 
  if (!useLP)
  {
         tmp = ( fMultDiv2(ac.r01i,ac.r12r) >> (LPC_SCALE_FACTOR-1) ) +
  ( (fMultDiv2(ac.r01r,ac.r12i) - (FIXP_DBL)fMultDiv2(ac.r02i,ac.r11r)) >> (LPC_SCALE_FACTOR-1) ) ;
 
         absTmp = fixp_abs(tmp);
 
   
  {
           INT scale;
           FIXP_DBL result = fDivNorm(absTmp, absDet, &scale);
           scale = scale+ac.det_scale;
 
  if ( (scale > 0) && (result >=   (FIXP_DBL)MAXVAL_DBL>>scale) ) {
             resetLPCCoeffs = 1;
  }
  else {
             alphai[1] = FX_DBL2FX_SGL(scaleValue(result,scale));
  if((tmp<FL2FX_DBL(0.0f)) ^ (ac.det<FL2FX_DBL(0.0f))) {
               alphai[1] = -alphai[1];
  }
  }
  }
  }
  }
 
     alphar[0] =  FL2FXCONST_SGL(0.0f);
  if (!useLP)
       alphai[0] = FL2FXCONST_SGL(0.0f);
 
  if ( ac.r11r != FL2FXCONST_DBL(0.0f) ) {
 
   
       FIXP_DBL tmp,absTmp;
 
  if (!useLP) {
         tmp = (ac.r01r>>(LPC_SCALE_FACTOR+1)) +
  (fMultDiv2(alphar[1],ac.r12r) + fMultDiv2(alphai[1],ac.r12i));
  } else
  {
  if(ac.r01r>=FL2FXCONST_DBL(0.0f))
           tmp = (ac.r01r>>(LPC_SCALE_FACTOR+1)) + fMultDiv2(alphar[1],ac.r12r);
  else
           tmp = -((-ac.r01r)>>(LPC_SCALE_FACTOR+1)) + fMultDiv2(alphar[1],ac.r12r);
  }
 
       absTmp = fixp_abs(tmp);
 
   
 
  if (absTmp >= (ac.r11r>>1)) {
         resetLPCCoeffs=1;
  }
  else {
         INT scale;
         FIXP_DBL result = fDivNorm(absTmp, fixp_abs(ac.r11r), &scale);
         alphar[0] =  FX_DBL2FX_SGL(scaleValue(result,scale+1));
 
  if((tmp>FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))
           alphar[0] = -alphar[0];
  }
 
  if (!useLP)
  {
         tmp = (ac.r01i>>(LPC_SCALE_FACTOR+1)) +
  (fMultDiv2(alphai[1],ac.r12r) - fMultDiv2(alphar[1],ac.r12i));
 
         absTmp = fixp_abs(tmp);
 
   
  if (absTmp >= (ac.r11r>>1)) {
           resetLPCCoeffs=1;
  }
  else {
           INT scale;
           FIXP_DBL result = fDivNorm(absTmp, fixp_abs(ac.r11r), &scale);
           alphai[0] = FX_DBL2FX_SGL(scaleValue(result,scale+1));
  if((tmp>FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))
             alphai[0] = -alphai[0];
  }
  }
  }
 
 
  if (!useLP)
  {
   
  if( (fMultDiv2(alphar[0],alphar[0]) + fMultDiv2(alphai[0],alphai[0])) >= FL2FXCONST_DBL(0.5f) )
         resetLPCCoeffs=1;
  if( (fMultDiv2(alphar[1],alphar[1]) + fMultDiv2(alphai[1],alphai[1])) >= FL2FXCONST_DBL(0.5f) )
         resetLPCCoeffs=1;
  }
 
  if(resetLPCCoeffs){
       alphar[0] = FL2FXCONST_SGL(0.0f);
       alphar[1] = FL2FXCONST_SGL(0.0f);
  if (!useLP)
  {
         alphai[0] = FL2FXCONST_SGL(0.0f);
         alphai[1] = FL2FXCONST_SGL(0.0f);
  }
  }
 
  if (useLP)
  {
 
   
  if(ac.r11r==FL2FXCONST_DBL(0.0f)) {
         k1 = FL2FXCONST_DBL(0.0f);
  }
  else {
  if ( fixp_abs(ac.r01r) >= fixp_abs(ac.r11r) ) {
  if ( fMultDiv2(ac.r01r,ac.r11r) < FL2FX_DBL(0.0f)) {
             k1 = (FIXP_DBL)MAXVAL_DBL  ;
  }else {
   
             k1 = (FIXP_DBL)(MINVAL_DBL+1)  ;
  }
  }
  else {
           INT scale;
           FIXP_DBL result = fDivNorm(fixp_abs(ac.r01r), fixp_abs(ac.r11r), &scale);
           k1 = scaleValue(result,scale);
 
  if(!((ac.r01r<FL2FX_DBL(0.0f)) ^ (ac.r11r<FL2FX_DBL(0.0f)))) {
             k1 = -k1;
  }
  }
  }
  if(loBand > 1){
   
         FIXP_DBL deg =   (FIXP_DBL)MAXVAL_DBL - fPow2(k1_below);
         degreeAlias[loBand] = FL2FXCONST_DBL(0.0f);
  if (((loBand & 1) == 0) && (k1 < FL2FXCONST_DBL(0.0f))){
  if (k1_below < FL2FXCONST_DBL(0.0f)) {  
             degreeAlias[loBand] = (FIXP_DBL)MAXVAL_DBL  ;
  if ( k1_below2 > FL2FXCONST_DBL(0.0f) ) {  
               degreeAlias[loBand-1] = deg;
  }
  }
  else if ( k1_below2 > FL2FXCONST_DBL(0.0f) ) {  
             degreeAlias[loBand] = deg;
  }
  }
  if (((loBand & 1) == 1) && (k1 > FL2FXCONST_DBL(0.0f))){
  if (k1_below > FL2FXCONST_DBL(0.0f)) {  
             degreeAlias[loBand] = (FIXP_DBL)MAXVAL_DBL  ;
  if ( k1_below2 < FL2FXCONST_DBL(0.0f) ) {  
               degreeAlias[loBand-1] = deg;
  }
  }
  else if ( k1_below2 < FL2FXCONST_DBL(0.0f) ) {  
             degreeAlias[loBand] = deg;
  }
  }
  }
   
       k1_below2 = k1_below;
       k1_below = k1;
  }
 
     patch = 0;
 
  while ( patch < pSettings->noOfPatches ) {  
 
  int hiBand = loBand + patchParam[patch].targetBandOffs;
 
  if ( loBand < patchParam[patch].sourceStartBand
  || loBand >= patchParam[patch].sourceStopBand
  ) {
   
         patch++;
  continue;
  }
 
 
        FDK_ASSERT( hiBand < (64) );
  
         
      while (hiBand >= pSettings->bwBorders[bwIndex[patch]])
       while (hiBand >= pSettings->bwBorders[bwIndex[patch]] && bwIndex[patch] < MAX_NUM_PATCHES-1) {
          bwIndex[patch]++;
       }
  
         
       bw = FX_DBL2FX_SGL(bwVector[bwIndex[patch]]);
 
       a0r = FX_DBL2FX_SGL(fMult(bw,alphar[0]));  
 
 
  if (!useLP)
         a0i = FX_DBL2FX_SGL(fMult(bw,alphai[0]));
       bw =  FX_DBL2FX_SGL(fPow2(bw));
       a1r = FX_DBL2FX_SGL(fMult(bw,alphar[1]));
  if (!useLP)
         a1i = FX_DBL2FX_SGL(fMult(bw,alphai[1]));
 
 
 
   
 
  if ( bw <= FL2FXCONST_SGL(0.0f) ) {
  if (!useLP) {
  int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));
  for(i = startSample; i < stopSample; i++ ) {
             qmfBufferReal[i][hiBand] = lowBandReal[LPC_ORDER+i]>>descale;
             qmfBufferImag[i][hiBand] = lowBandImag[LPC_ORDER+i]>>descale;
  }
  } else
  {
  int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));
  for(i = startSample; i < stopSample; i++ ) {
             qmfBufferReal[i][hiBand] = lowBandReal[LPC_ORDER+i]>>descale;
  }
  }
  }
  else {  
 
  if (!useLP) {
  int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));
 #ifdef FUNCTION_LPPTRANSPOSER_func1
           lppTransposer_func1(lowBandReal+LPC_ORDER+startSample,lowBandImag+LPC_ORDER+startSample,
                               qmfBufferReal+startSample,qmfBufferImag+startSample,
                               stopSample-startSample, (int) hiBand,
                               dynamicScale,descale,
                               a0r, a0i, a1r, a1i);
 #else
  for(i = startSample; i < stopSample; i++ ) {
             FIXP_DBL accu1, accu2;
 
             accu1 = (fMultDiv2(a0r,lowBandReal[LPC_ORDER+i-1]) - fMultDiv2(a0i,lowBandImag[LPC_ORDER+i-1]) +
                      fMultDiv2(a1r,lowBandReal[LPC_ORDER+i-2]) - fMultDiv2(a1i,lowBandImag[LPC_ORDER+i-2]))>>dynamicScale;
             accu2 = (fMultDiv2(a0i,lowBandReal[LPC_ORDER+i-1]) + fMultDiv2(a0r,lowBandImag[LPC_ORDER+i-1]) +
                      fMultDiv2(a1i,lowBandReal[LPC_ORDER+i-2]) + fMultDiv2(a1r,lowBandImag[LPC_ORDER+i-2]))>>dynamicScale;
 
             qmfBufferReal[i][hiBand] = (lowBandReal[LPC_ORDER+i]>>descale) + (accu1<<1);
             qmfBufferImag[i][hiBand] = (lowBandImag[LPC_ORDER+i]>>descale) + (accu2<<1);
  }
 #endif
  } else
  {
  int descale = fixMin(DFRACT_BITS-1, (LPC_SCALE_FACTOR+dynamicScale));
 
           FDK_ASSERT(dynamicScale >= 0);
  for(i = startSample; i < stopSample; i++ ) {
             FIXP_DBL accu1;
 
             accu1 = (fMultDiv2(a0r,lowBandReal[LPC_ORDER+i-1]) + fMultDiv2(a1r,lowBandReal[LPC_ORDER+i-2]))>>dynamicScale;
 
             qmfBufferReal[i][hiBand] = (lowBandReal[LPC_ORDER+i]>>descale) + (accu1<<1);
  }
  }
  }  
 
       patch++;
 
  }  
 
   
 
 
  }  
 
  if (useLP)
  {
  for ( loBand = pSettings->lbStartPatching; loBand <  pSettings->lbStopPatching; loBand++ ) {
       patch = 0;
  while ( patch < pSettings->noOfPatches ) {
 
         UCHAR hiBand = loBand + patchParam[patch].targetBandOffs;
 
  if ( loBand < patchParam[patch].sourceStartBand
  || loBand >= patchParam[patch].sourceStopBand
  || hiBand >= (64)  
  ) {
   
           patch++;
  continue;
  }
 
  if(hiBand != patchParam[patch].targetStartBand)
           degreeAlias[hiBand] = degreeAlias[loBand];
 
         patch++;
  }
  } 
  }
 
  for (i = 0; i < nInvfBands; i++ ) {
    hLppTrans->bwVectorOld[i] = bwVector[i];
  }
 
   
   sbrScaleFactor->hb_scale = comLowBandScale-(LPC_SCALE_FACTOR);
 
 }","[78, 391, 393, 77, 390]","An information disclosure vulnerability in the Android media framework (aac). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65280786."
202394,"  INST_HANDLER (cpse) {	 
  	int r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);
  	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);
	RAnalOp next_op;
 	RAnalOp next_op = {0};
  
 	avr_op_analyze (anal,
 			&next_op,
 			op->addr + op->size, buf + op->size, len - op->size,
 			cpu);
 	r_strbuf_fini (&next_op.esil);
 	op->jump = op->addr + next_op.size + 2;
 
 	op->cycles = 1;	 
 	ESIL_A (""r%d,r%d,^,!,"", r, d);			 
 	ESIL_A (""?{,%""PFMT64d"",pc,=,},"", op->jump);	 
 }","[5, 4]",The r_strbuf_fini() function in radare2 2.5.0 allows remote attackers to cause a denial of service (invalid free and application crash) via a crafted ELF file because of an uninitialized variable in the CPSE handler in libr/anal/p/anal_avr.c.
204747," static void testInspectorDefault(InspectorTest* test, gconstpointer)
 {
     test->showInWindowAndWaitUntilMapped(GTK_WINDOW_TOPLEVEL);
     test->resizeView(200, 200);
     test->loadHtml(""<html><body><p>WebKitGTK+ Inspector test</p></body></html>"", 0);
     test->waitUntilLoadFinished();
 
     test->showAndWaitUntilFinished(false);
     GRefPtr<WebKitWebViewBase> inspectorView = webkit_web_inspector_get_web_view(test->m_inspector);
     g_assert(inspectorView.get());
     test->assertObjectIsDeletedWhenTestFinishes(G_OBJECT(inspectorView.get()));
     g_assert(!webkit_web_inspector_is_attached(test->m_inspector));
     g_assert_cmpuint(webkit_web_inspector_get_attached_height(test->m_inspector), ==, 0);
     Vector<InspectorTest::InspectorEvents>& events = test->m_events;
     g_assert_cmpint(events.size(), ==, 2);
     g_assert_cmpint(events[0], ==, InspectorTest::BringToFront);
     g_assert_cmpint(events[1], ==, InspectorTest::OpenWindow);
     test->m_events.clear();
 
     test->showAndWaitUntilFinished(true);
     events = test->m_events;
     g_assert_cmpint(events.size(), ==, 1);
     g_assert_cmpint(events[0], ==, InspectorTest::BringToFront);
     test->m_events.clear();
  
      test->resizeViewAndAttach();
      g_assert(webkit_web_inspector_is_attached(test->m_inspector));
     g_assert_cmpuint(webkit_web_inspector_get_attached_height(test->m_inspector), >=, InspectorTest::gMinimumAttachedInspectorHeight);
      events = test->m_events;
      g_assert_cmpint(events.size(), ==, 1);
      g_assert_cmpint(events[0], ==, InspectorTest::Attach);
     test->m_events.clear();
 
     test->detachAndWaitUntilWindowOpened();
     g_assert(!webkit_web_inspector_is_attached(test->m_inspector));
     events = test->m_events;
     g_assert_cmpint(events.size(), ==, 2);
     g_assert_cmpint(events[0], ==, InspectorTest::Detach);
     g_assert_cmpint(events[1], ==, InspectorTest::OpenWindow);
     test->m_events.clear();
 
     test->closeAndWaitUntilClosed();
     events = test->m_events;
     g_assert_cmpint(events.size(), ==, 1);
     g_assert_cmpint(events[0], ==, InspectorTest::Closed);
     test->m_events.clear();
 }",[28],Use-after-free vulnerability in the PDF functionality in Google Chrome before 19.0.1084.46 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving a malformed name for the font encoding.
9405,"void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,
DatasetBase* input,
DatasetBase** output) {
int64_t num_threads = 0;
OP_REQUIRES_OK(
ctx, ParseScalarArgument<int64_t>(ctx, ""num_threads"", &num_threads));
OP_REQUIRES(ctx, num_threads >= 0,
errors::InvalidArgument(""`num_threads` must be >= 0""));
*output = new Dataset(ctx, input, num_threads);
}","[7, 8]","Tensorflow is an Open Source Machine Learning Framework. The implementation of `ThreadPoolHandle` can be used to trigger a denial of service attack by allocating too much memory. This is because the `num_threads` argument is only checked to not be negative, but there is no upper bound on its value. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
203763,"  bool WebSocketJob::SendDataInternal(const char* data, int length) {
    if (spdy_websocket_stream_.get())
      return ERR_IO_PENDING == spdy_websocket_stream_->SendData(data, length);
  return socket_->SendData(data, length);
   if (socket_.get())
     return socket_->SendData(data, length);
   return false;
  }","[5, 6, 7, 4]",The WebSockets implementation in Google Chrome before 14.0.835.163 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via unspecified vectors.
198855," static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)
 static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)
  {
  	 
 	write_seqlock(&state->seqlock);
 	if (deleg_stateid != NULL) {
 		memcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));
  		set_bit(NFS_DELEGATED_STATE, &state->flags);
  	}
  	if (open_stateid != NULL)
		nfs_set_open_stateid_locked(state, open_stateid, open_flags);
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
  	write_sequnlock(&state->seqlock);
  	spin_lock(&state->owner->so_lock);
	update_open_stateflags(state, open_flags);
 	update_open_stateflags(state, fmode);
  	spin_unlock(&state->owner->so_lock);
  }","[2, 12, 16, 11, 15]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
204572,"  bool AddPolicyForRenderer(sandbox::TargetPolicy* policy) {
    
    sandbox::ResultCode result;
    result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,
                             sandbox::TargetPolicy::HANDLES_DUP_ANY,
                             L""Section"");
  if (result != sandbox::SBOX_ALL_OK) {
    NOTREACHED();
   if (result != sandbox::SBOX_ALL_OK)
     return false;
 
    
   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,
                            sandbox::TargetPolicy::HANDLES_DUP_ANY,
                            L""Event"");
   if (result != sandbox::SBOX_ALL_OK)
      return false;
  }
  
    policy->SetJobLevel(sandbox::JOB_LOCKDOWN, 0);
  
   sandbox::TokenLevel initial_token = sandbox::USER_UNPROTECTED;
   if (base::win::GetVersion() > base::win::VERSION_XP) {
     initial_token = sandbox::USER_RESTRICTED_SAME_ACCESS;
   }
 
   policy->SetTokenLevel(initial_token, sandbox::USER_LOCKDOWN);
   policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);
 
   bool use_winsta = !CommandLine::ForCurrentProcess()->HasSwitch(
                         switches::kDisableAltWinstation);
 
   if (sandbox::SBOX_ALL_OK !=  policy->SetAlternateDesktop(use_winsta)) {
     DLOG(WARNING) << ""Failed to apply desktop security to the renderer"";
   }
 
   AddGenericDllEvictionPolicy(policy);
 
   return true;
 }","[2, 9, 10, 11, 12, 13, 14, 15, 16, 7, 8, 18]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
197795,"  DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : saml2md::DynamicMetadataProvider(e),
     : saml2md::DynamicMetadataProvider(e), MetadataProvider(e),
          m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),
          m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),
          m_encoded(true), m_trust(nullptr)
 {
     const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);
     if (child && child->hasChildNodes()) {
         auto_ptr_char s(child->getFirstChild()->getNodeValue());
         if (s.get() && *s.get()) {
             m_subst = s.get();
             m_encoded = XMLHelper::getAttrBool(child, true, encoded);
             m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);
         }
     }
 
     if (m_subst.empty()) {
         child = XMLHelper::getFirstChildElement(e, Regex);
         if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {
             m_match = XMLHelper::getAttrString(child, nullptr, match);
             auto_ptr_char repl(child->getFirstChild()->getNodeValue());
             if (repl.get() && *repl.get())
                 m_regex = repl.get();
         }
     }
 
     if (!m_ignoreTransport) {
         child = XMLHelper::getFirstChildElement(e, _TrustEngine);
         string t = XMLHelper::getAttrString(child, nullptr, _type);
         if (!t.empty()) {
             TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);
             if (!dynamic_cast<X509TrustEngine*>(trust)) {
                 delete trust;
                 throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin."");
             }
             m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));
             m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));
         }
 
         if (!m_trust.get() || !m_dummyCR.get())
             throw ConfigurationException(""DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true."");
     }
 }","[3, 2]","shibsp/metadata/DynamicMetadataProvider.cpp in the Dynamic MetadataProvider plugin in Shibboleth Service Provider before 2.6.1 fails to properly configure itself with the MetadataFilter plugins and does not perform critical security checks such as signature verification, enforcement of validity periods, and other checks specific to deployments, aka SSPCPP-763."
202120," void edge_sparse_csr_reader_double( const char*           i_csr_file_in,
                                     unsigned int**        o_row_idx,
                                     unsigned int**        o_column_idx,
                                     double**              o_values,
                                     unsigned int*         o_row_count,
                                     unsigned int*         o_column_count,
                                     unsigned int*         o_element_count ) {
   FILE *l_csr_file_handle;
   const unsigned int l_line_length = 512;
   char l_line[512 +1];
   unsigned int l_header_read = 0;
   unsigned int* l_row_idx_id = NULL;
   unsigned int l_i = 0;
 
   l_csr_file_handle = fopen( i_csr_file_in, ""r"" );
   if ( l_csr_file_handle == NULL ) {
     fprintf( stderr, ""cannot open CSR file!\n"" );
     return;
   }
 
   while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {
     if ( strlen(l_line) == l_line_length ) {
       fprintf( stderr, ""could not read file length!\n"" );
       return;
     }
      
     if ( l_line[0] == '%' ) {
       continue;
      } else {
         
        if ( l_header_read == 0 ) {
        if ( sscanf(l_line, ""%u %u %u"", o_row_count, o_column_count, o_element_count) == 3 ) {
         if (3 == sscanf(l_line, ""%u %u %u"", o_row_count, o_column_count, o_element_count) &&
             0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)
         {
             
            *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));
            *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));
           *o_values = (double*) malloc(sizeof(double) * (*o_element_count));
           l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));
 
            
           if ( ( *o_row_idx == NULL )      ||
                ( *o_column_idx == NULL )   ||
                ( *o_values == NULL )       ||
                ( l_row_idx_id == NULL ) ) {
             fprintf( stderr, ""could not allocate sp data!\n"" );
             return;
           }
 
            
           memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));
           memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));
           memset(*o_values, 0, sizeof(double)*(*o_element_count));
           memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));
 
            
           for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)
             (*o_row_idx)[l_i] = (*o_element_count);
 
            
           (*o_row_idx)[0] = 0;
           l_i = 0;
           l_header_read = 1;
         } else {
           fprintf( stderr, ""could not csr description!\n"" );
           return;
         }
        
       } else {
         unsigned int l_row, l_column;
         double l_value;
          
         if ( sscanf(l_line, ""%u %u %lf"", &l_row, &l_column, &l_value) != 3 ) {
           fprintf( stderr, ""could not read element!\n"" );
           return;
         }
          
         l_row--;
         l_column--;
          
         (*o_column_idx)[l_i] = l_column;
         (*o_values)[l_i] = l_value;
         l_i++;
          
         l_row_idx_id[l_row] = 1;
         (*o_row_idx)[l_row+1] = l_i;
       }
     }
   }
 
    
   fclose( l_csr_file_handle );
 
    
   if ( l_i != (*o_element_count) ) {
     fprintf( stderr, ""we were not able to read all elements!\n"" );
     return;
   }
 
    
   for ( l_i = 0; l_i < (*o_row_count); l_i++) {
     if ( l_row_idx_id[l_i] == 0 ) {
       (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];
     }
   }
 
    
   if ( l_row_idx_id != NULL ) {
     free( l_row_idx_id );
   }
 }","[33, 34, 35, 32]","There is a heap-based buffer-overflow at generator_spgemm_csc_reader.c (function libxsmm_sparse_csc_reader) in LIBXSMM 1.10, a different vulnerability than CVE-2018-20541 (which is in a different part of the source code and is seen at a different address)."
205793," AccessibilityExpanded AXNodeObject::isExpanded() const {
   if (getNode() && isHTMLSummaryElement(*getNode())) {
     if (getNode()->parentNode() &&
         isHTMLDetailsElement(getNode()->parentNode()))
       return toElement(getNode()->parentNode())->hasAttribute(openAttr)
                  ? ExpandedExpanded
                  : ExpandedCollapsed;
    }
  
    const AtomicString& expanded = getAttribute(aria_expandedAttr);
  if (equalIgnoringCase(expanded, ""true""))
   if (equalIgnoringASCIICase(expanded, ""true""))
      return ExpandedExpanded;
  if (equalIgnoringCase(expanded, ""false""))
   if (equalIgnoringASCIICase(expanded, ""false""))
      return ExpandedCollapsed;
  
    return ExpandedUndefined;
 }","[12, 15, 11, 14]","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
207290," v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
     v8::Local<v8::String> module_name) {
   v8::EscapableHandleScope handle_scope(GetIsolate());
   v8::Local<v8::Context> v8_context = context()->v8_context();
   v8::Context::Scope context_scope(v8_context);
 
   v8::Local<v8::Object> global(context()->v8_context()->Global());
 
   v8::Local<v8::Value> modules_value;
   if (!GetPrivate(global, kModulesField, &modules_value) ||
       modules_value->IsUndefined()) {
     Warn(GetIsolate(), ""Extension view no longer exists"");
     return v8::Undefined(GetIsolate());
   }
  
    v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
    v8::Local<v8::Value> exports;
  if (!GetProperty(v8_context, modules, module_name, &exports) ||
   if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||
        !exports->IsUndefined())
      return handle_scope.Escape(exports);
  
    exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetProperty(v8_context, modules, module_name, exports);
   SetPrivateProperty(v8_context, modules, module_name, exports);
    return handle_scope.Escape(exports);
  }","[19, 25, 18, 24]","The ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the extension bindings in Google Chrome before 51.0.2704.63 mishandles properties, which allows remote attackers to conduct bindings-interception attacks and bypass the Same Origin Policy via unspecified vectors."
205154,"  DictionaryValue* ExtensionTabUtil::CreateTabValue(
      const WebContents* contents,
      TabStripModel* tab_strip,
    int tab_index,
    IncludePrivacySensitiveFields include_privacy_sensitive_fields) {
     int tab_index) {
    NOTIMPLEMENTED();
    return NULL;
  }","[6, 4, 5]","Google Chrome before 26.0.1410.43 does not ensure that an extension has the tabs (aka APIPermission::kTab) permission before providing a URL to this extension, which has unspecified impact and remote attack vectors."
200096," static void ffs_user_copy_worker(struct work_struct *work)
 {
 	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
  						   work);
  	int ret = io_data->req->status ? io_data->req->status :
  					 io_data->req->actual;
 	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
  
  	if (io_data->read && ret > 0) {
  		use_mm(io_data->mm);
 		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
 		if (iov_iter_count(&io_data->data))
 			ret = -EFAULT;
 		unuse_mm(io_data->mm);
 	}
  
  	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
  
	if (io_data->ffs->ffs_eventfd &&
	    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))
 	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
  		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
  
  	usb_ep_free_request(io_data->ep, io_data->req);
  
	io_data->kiocb->private = NULL;
  	if (io_data->read)
  		kfree(io_data->to_free);
  	kfree(io_data->buf);
 	kfree(io_data);
 }","[7, 21, 19, 20, 26]",Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.
6322,"__mptctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
mpt_ioctl_header __user *uhdr = (void __user *) arg;
mpt_ioctl_header  khdr;
int iocnum;
unsigned iocnumX;
int nonblock = (file->f_flags & O_NONBLOCK);
int ret;
MPT_ADAPTER *iocp = NULL;

if (copy_from_user(&khdr, uhdr, sizeof(khdr))) {
printk(KERN_ERR MYNAM ""%s::mptctl_ioctl() @%d - ""
""Unable to copy mpt_ioctl_header data @ %p\n"",
__FILE__, __LINE__, uhdr);
return -EFAULT;
}
ret = -ENXIO;




iocnumX = khdr.iocnum & 0xFF;
if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||
(iocp == NULL))
return -ENODEV;

if (!iocp->active) {
printk(KERN_DEBUG MYNAM ""%s::mptctl_ioctl() @%d - Controller disabled.\n"",
__FILE__, __LINE__);
return -EFAULT;
}






if ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {
return mptctl_getiocinfo(arg, _IOC_SIZE(cmd));
} else if (cmd == MPTTARGETINFO) {
return mptctl_gettargetinfo(arg);
} else if (cmd == MPTTEST) {
return mptctl_readtest(arg);
} else if (cmd == MPTEVENTQUERY) {
return mptctl_eventquery(arg);
} else if (cmd == MPTEVENTENABLE) {
return mptctl_eventenable(arg);
} else if (cmd == MPTEVENTREPORT) {
return mptctl_eventreport(arg);
} else if (cmd == MPTFWREPLACE) {
return mptctl_replace_fw(arg);
}




if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)
return ret;

if (cmd == MPTFWDOWNLOAD)
ret = mptctl_fw_download(arg);
else if (cmd == MPTCOMMAND)
ret = mptctl_mpt_command(arg);
else if (cmd == MPTHARDRESET)
ret = mptctl_do_reset(arg);
else if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))
ret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));
else if (cmd == HP_GETTARGETINFO)
ret = mptctl_hp_targetinfo(arg);
else
ret = -EINVAL;

mutex_unlock(&iocp->ioctl_cmds.mutex);

return ret;
}","[39, 41, 43, 45, 47, 49, 51, 61, 63, 65, 67, 69]","The __mptctl_ioctl function in drivers/message/fusion/mptctl.c in the Linux kernel before 5.4.14 allows local users to hold an incorrect lock during the ioctl operation and trigger a race condition, i.e., a ""double fetch"" vulnerability, aka CID-28d76df18f0a. NOTE: the vendor states ""The security impact of this bug is not as bad as it could have been because these operations are all privileged and root already has enormous destructive power."""
198888,"  static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)
  {
	struct page *pages[NFS4ACL_MAXPAGES];
 	struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };
  	struct nfs_getaclargs args = {
  		.fh = NFS_FH(inode),
  		.acl_pages = pages,
 		.acl_len = buflen,
 	};
 	struct nfs_getaclres res = {
 		.acl_len = buflen,
 	};
 	void *resp_buf;
 	struct rpc_message msg = {
 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],
  		.rpc_argp = &args,
  		.rpc_resp = &res,
  	};
	struct page *localpage = NULL;
	int ret;
 	int ret = -ENOMEM, npages, i, acl_len = 0;
  
	if (buflen < PAGE_SIZE) {
 	npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	 
 	if (npages == 0)
 		npages = 1;
 
 	for (i = 0; i < npages; i++) {
 		pages[i] = alloc_page(GFP_KERNEL);
 		if (!pages[i])
 			goto out_free;
 	}
 	if (npages > 1) {
 		 
		localpage = alloc_page(GFP_KERNEL);
		resp_buf = page_address(localpage);
		if (localpage == NULL)
			return -ENOMEM;
		args.acl_pages[0] = localpage;
		args.acl_pgbase = 0;
		args.acl_len = PAGE_SIZE;
	} else {
		resp_buf = buf;
		buf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);
 		args.acl_scratch = alloc_page(GFP_KERNEL);
 		if (!args.acl_scratch)
 			goto out_free;
  	}
	ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);
 	args.acl_len = npages * PAGE_SIZE;
 	args.acl_pgbase = 0;
 	 
 	if (buf == NULL)
 		res.acl_flags |= NFS4_ACL_LEN_REQUEST;
 	resp_buf = page_address(pages[0]);
 
 	dprintk(""%s  buf %p buflen %ld npages %d args.acl_len %ld\n"",
 		__func__, buf, buflen, npages, args.acl_len);
 	ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),
 			     &msg, &args.seq_args, &res.seq_res, 0);
  	if (ret)
  		goto out_free;
	if (res.acl_len > args.acl_len)
		nfs4_write_cached_acl(inode, NULL, res.acl_len);
 
 	acl_len = res.acl_len - res.acl_data_offset;
 	if (acl_len > args.acl_len)
 		nfs4_write_cached_acl(inode, NULL, acl_len);
  	else
		nfs4_write_cached_acl(inode, resp_buf, res.acl_len);
 		nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,
 				      acl_len);
  	if (buf) {
  		ret = -ERANGE;
		if (res.acl_len > buflen)
 		if (acl_len > buflen)
  			goto out_free;
		if (localpage)
			memcpy(buf, resp_buf, res.acl_len);
 		_copy_from_pages(buf, pages, res.acl_data_offset,
 				res.acl_len);
  	}
	ret = res.acl_len;
 	ret = acl_len;
  out_free:
	if (localpage)
		__free_page(localpage);
 	for (i = 0; i < npages; i++)
 		if (pages[i])
 			__free_page(pages[i]);
 	if (args.acl_scratch)
 		__free_page(args.acl_scratch);
  	return ret;
  }","[4, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 46, 47, 48, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 66, 67, 68, 69, 72, 73, 77, 81, 82, 85, 89, 90, 91, 92, 93, 3, 19, 20, 23, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 50, 64, 65, 71, 76, 79, 80, 84, 87, 88]","The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words."
207043," void FrameLoader::Trace(blink::Visitor* visitor) {
   visitor->Trace(frame_);
    visitor->Trace(progress_tracker_);
    visitor->Trace(document_loader_);
    visitor->Trace(provisional_document_loader_);
   visitor->Trace(last_origin_document_);
  }",[6],Incorrect inheritance of a new document's policy in Content Security Policy in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to bypass content security policy via a crafted HTML page.
201903," static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,
   jas_stream_t *in)
 {
 	jpc_siz_t *siz = &ms->parms.siz;
  	unsigned int i;
  	uint_fast8_t tmp;
  
 	siz->comps = 0;
 
  	 
  	cstate = 0;
  
 	if (jpc_getuint16(in, &siz->caps) ||
 	  jpc_getuint32(in, &siz->width) ||
 	  jpc_getuint32(in, &siz->height) ||
 	  jpc_getuint32(in, &siz->xoff) ||
 	  jpc_getuint32(in, &siz->yoff) ||
 	  jpc_getuint32(in, &siz->tilewidth) ||
 	  jpc_getuint32(in, &siz->tileheight) ||
  	  jpc_getuint32(in, &siz->tilexoff) ||
  	  jpc_getuint32(in, &siz->tileyoff) ||
  	  jpc_getuint16(in, &siz->numcomps)) {
		return -1;
 		goto error;
  	}
	if (!siz->width || !siz->height || !siz->tilewidth ||
	  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {
		return -1;
 	if (!siz->width || !siz->height) {
 		jas_eprintf(""reference grid cannot have zero area\n"");
 		goto error;
  	}
	if (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {
		jas_eprintf(""all tiles are outside the image area\n"");
		return -1;
 	if (!siz->tilewidth || !siz->tileheight) {
 		jas_eprintf(""tile cannot have zero area\n"");
 		goto error;
 	}
 	if (!siz->numcomps || siz->numcomps > 16384) {
 		jas_eprintf(""number of components not in permissible range\n"");
 		goto error;
  	}
 	if (siz->xoff >= siz->width) {
 		jas_eprintf(""XOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->yoff >= siz->height) {
 		jas_eprintf(""YOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->tilexoff > siz->xoff || siz->tilexoff + siz->tilewidth <= siz->xoff) {
 		jas_eprintf(""XTOsiz not in permissible range\n"");
 		goto error;
 	}
 	if (siz->tileyoff > siz->yoff || siz->tileyoff + siz->tileheight <= siz->yoff) {
 		jas_eprintf(""YTOsiz not in permissible range\n"");
 		goto error;
 	}
 
  	if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {
		return -1;
 		goto error;
  	}
  	for (i = 0; i < siz->numcomps; ++i) {
  		if (jpc_getuint8(in, &tmp) ||
  		  jpc_getuint8(in, &siz->comps[i].hsamp) ||
  		  jpc_getuint8(in, &siz->comps[i].vsamp)) {
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {
  			jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp);
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {
  			jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp);
			jas_free(siz->comps);
			return -1;
 			goto error;
  		}
  		siz->comps[i].sgnd = (tmp >> 7) & 1;
  		siz->comps[i].prec = (tmp & 0x7f) + 1;
  	}
  	if (jas_stream_eof(in)) {
		jas_free(siz->comps);
		return -1;
 		goto error;
  	}
  	return 0;
 
 error:
 	if (siz->comps) {
 		jas_free(siz->comps);
 	}
 	return -1;
  }","[8, 9, 24, 29, 30, 31, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 71, 77, 83, 91, 94, 95, 96, 97, 98, 99, 23, 26, 27, 28, 33, 34, 35, 62, 69, 70, 75, 76, 81, 82, 89, 90]",The jas_seq2d_create function in jas_seq.c in JasPer before 1.900.17 allows remote attackers to cause a denial of service (assertion failure) via a crafted file.
200771," rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
 {
 	rdpCredssp* credssp;
 
 	credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
 	ZeroMemory(credssp, sizeof(rdpCredssp));
 
 	if (credssp != NULL)
 	{
 		HKEY hKey;
 		LONG status;
 		DWORD dwType;
 		DWORD dwSize;
 
 		credssp->instance = instance;
 		credssp->settings = settings;
 		credssp->server = settings->ServerMode;
 		credssp->transport = transport;
 		credssp->send_seq_num = 0;
 		credssp->recv_seq_num = 0;
  		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
  		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
  		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
 		SecInvalidateHandle(&credssp->context);
  
  		if (credssp->server)
  		{
 			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
 					0, KEY_READ | KEY_WOW64_64KEY, &hKey);
 
 			if (status == ERROR_SUCCESS)
 			{
 				status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType, NULL, &dwSize);
 
 				if (status == ERROR_SUCCESS)
 				{
 					credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));
 
 					status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType,
 							(BYTE*) credssp->SspiModule, &dwSize);
 
 					if (status == ERROR_SUCCESS)
 					{
 						_tprintf(_T(""Using SSPI Module: %s\n""), credssp->SspiModule);
 						RegCloseKey(hKey);
 					}
 				}
 			}
 		}
 	}
 
 	return credssp;
 }",[24],FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.
8294,"void Compute(OpKernelContext* context) override {















typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
ConstEigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>>
EigenDoubleMatrixMap;


const Tensor& orig_input_tensor_shape = context->input(0);
OP_REQUIRES(context,
orig_input_tensor_shape.dims() == 1 &&
orig_input_tensor_shape.NumElements() == 4,
errors::InvalidArgument(""original input tensor shape must be""
""1-dimensional and 4 elements""));
const Tensor& out_backprop = context->input(1);
const Tensor& row_seq_tensor = context->input(2);
const Tensor& col_seq_tensor = context->input(3);

const int64_t out_batch = out_backprop.dim_size(0);
const int64_t out_rows = out_backprop.dim_size(1);
const int64_t out_cols = out_backprop.dim_size(2);
const int64_t out_depth = out_backprop.dim_size(3);

OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows,
errors::InvalidArgument(""Given out_backprop shape "",
out_backprop.shape().DebugString(),
"", row_seq_tensor must have at least "",
out_rows + 1, "" elements, but got "",
row_seq_tensor.NumElements()));
OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols,
errors::InvalidArgument(""Given out_backprop shape "",
out_backprop.shape().DebugString(),
"", col_seq_tensor must have at least "",
out_cols + 1, "" elements, but got "",
col_seq_tensor.NumElements()));

auto row_seq_tensor_flat = row_seq_tensor.flat<int64>();
auto col_seq_tensor_flat = col_seq_tensor.flat<int64>();
auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>();

const int64_t in_batch = orig_input_tensor_shape_flat(0);
const int64_t in_rows = orig_input_tensor_shape_flat(1);
const int64_t in_cols = orig_input_tensor_shape_flat(2);
const int64_t in_depth = orig_input_tensor_shape_flat(3);

constexpr int tensor_in_and_out_dims = 4;

TensorShape in_shape;
for (auto i = 0; i < tensor_in_and_out_dims; ++i) {
in_shape.AddDim(orig_input_tensor_shape_flat(i));
}


Tensor in_backprop_tensor_temp;
OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(
{0}, DataTypeToEnum<double>::v(), in_shape,
&in_backprop_tensor_temp));
in_backprop_tensor_temp.flat<double>().setZero();

EigenDoubleMatrixMap in_backprop_tensor_temp_mat(
in_backprop_tensor_temp.flat<double>().data(), in_depth,
in_cols * in_rows * in_batch);
ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(),
out_depth,
out_cols * out_rows * out_batch);


const int64_t in_max_row_index = in_rows - 1;
const int64_t in_max_col_index = in_cols - 1;
for (int64_t b = 0; b < out_batch; ++b) {
for (int64_t r = 0; r < out_rows; ++r) {
const int64_t in_row_start = row_seq_tensor_flat(r);
int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1)
: row_seq_tensor_flat(r + 1) - 1;
in_row_end = std::min(in_row_end, in_max_row_index);
for (int64_t c = 0; c < out_cols; ++c) {
const int64_t in_col_start = col_seq_tensor_flat(c);
int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1)
: col_seq_tensor_flat(c + 1) - 1;
in_col_end = std::min(in_col_end, in_max_col_index);

const int64_t num_elements_in_pooling_cell =
(in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1);
const int64_t out_index = (b * out_rows + r) * out_cols + c;


for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) {
for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) {
const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c;

for (int64_t d = 0; d < out_depth; ++d) {
const double out_backprop_element = static_cast<double>(
out_backprop_mat.coeffRef(d, out_index));
double& in_backprop_ref =
in_backprop_tensor_temp_mat.coeffRef(d, in_index);
in_backprop_ref +=
out_backprop_element / num_elements_in_pooling_cell;
}
}
}
}
}
}


Tensor* in_backprop_tensor = nullptr;
OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(
{0}, 0, in_shape, &in_backprop_tensor));
auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>();
auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>();
for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) {
in_backprop_tensor_flat(i) =
static_cast<T>(in_backprop_tensor_temp_flat(i));
}
}",[60],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
201501," static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   char
     magick[14];
 
   Image
     *image;
 
   int
     foundPropEnd = 0;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     offset;
 
   register ssize_t
     i;
 
   size_t
     image_type,
     length;
 
   ssize_t
     count;
 
   XCFDocInfo
     doc_info;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   count=ReadBlob(image,14,(unsigned char *) magick);
   if ((count != 14) ||
       (LocaleNCompare((char *) magick,""gimp xcf"",8) != 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   (void) ResetMagickMemory(&doc_info,0,sizeof(XCFDocInfo));
   doc_info.exception=exception;
   doc_info.width=ReadBlobMSBLong(image);
   doc_info.height=ReadBlobMSBLong(image);
   if ((doc_info.width > 262144) || (doc_info.height > 262144))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   doc_info.image_type=ReadBlobMSBLong(image);
    
   image->columns=doc_info.width;
   image->rows=doc_info.height;
   image_type=doc_info.image_type;
   doc_info.file_size=GetBlobSize(image);
   image->compression=NoCompression;
   image->depth=8;
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
   if (image_type == GIMP_RGB)
     ;
   else
     if (image_type == GIMP_GRAY)
       image->colorspace=GRAYColorspace;
     else
       if (image_type == GIMP_INDEXED)
         ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
   (void) SetImageOpacity(image,OpaqueOpacity); 
   (void) SetImageBackgroundColor(image);
    
   while ((foundPropEnd == MagickFalse) && (EOFBlob(image) == MagickFalse))
   {
     PropType prop_type = (PropType) ReadBlobMSBLong(image);
     size_t prop_size = ReadBlobMSBLong(image);
 
     switch (prop_type)
     {
       case PROP_END:
         foundPropEnd=1;
         break;
       case PROP_COLORMAP:
       {
          
         size_t num_colours = ReadBlobMSBLong(image);
         if (DiscardBlobBytes(image,3*num_colours) == MagickFalse)
           ThrowFileException(&image->exception,CorruptImageError,
             ""UnexpectedEndOfFile"",image->filename);
      
         break;
       }
       case PROP_COMPRESSION:
       {
         doc_info.compression = ReadBlobByte(image);
         if ((doc_info.compression != COMPRESS_NONE) &&
             (doc_info.compression != COMPRESS_RLE) &&
             (doc_info.compression != COMPRESS_ZLIB) &&
             (doc_info.compression != COMPRESS_FRACTAL))
           ThrowReaderException(CorruptImageError,""UnrecognizedImageCompression"");
       }
       break;
 
       case PROP_GUIDES:
       {
           
         if (DiscardBlobBytes(image,prop_size) == MagickFalse)
           ThrowFileException(&image->exception,CorruptImageError,
             ""UnexpectedEndOfFile"",image->filename);
       }
       break;
 
     case PROP_RESOLUTION:
       {
           (void) ReadBlobMSBLong(image);
           (void) ReadBlobMSBLong(image);
 
          
 
 
          
       }
       break;
 
     case PROP_TATTOO:
       {
          
           (void) ReadBlobMSBLong(image);
       }
       break;
 
     case PROP_PARASITES:
       {
          
         if (DiscardBlobBytes(image,prop_size) == MagickFalse)
           ThrowFileException(&image->exception,CorruptImageError,
             ""UnexpectedEndOfFile"",image->filename);
          
           }
       break;
 
     case PROP_UNIT:
       {
          
         (void) ReadBlobMSBLong(image);
       }
       break;
 
     case PROP_PATHS:
       {
        
         if (DiscardBlobBytes(image,prop_size) == MagickFalse)
           ThrowFileException(&image->exception,CorruptImageError,
             ""UnexpectedEndOfFile"",image->filename);
 
          
       }
       break;
 
     case PROP_USER_UNIT:
       {
         char  unit_string[1000];
          
           (void) ReadBlobMSBLong(image);
           (void) ReadBlobMSBLong(image);
         for (i=0; i<5; i++)
          (void) ReadBlobStringWithLongSize(image, unit_string,
            sizeof(unit_string));
       }
      break;
 
       default:
       {
         int buf[16];
         ssize_t amount;
 
        
       while ((prop_size > 0) && (EOFBlob(image) == MagickFalse))
       {
         amount=(ssize_t) MagickMin(16, prop_size);
         amount=(ssize_t) ReadBlob(image,(size_t) amount,(unsigned char *) &buf);
         if (!amount)
           ThrowReaderException(CorruptImageError,""CorruptImage"");
         prop_size -= (size_t) MagickMin(16,(size_t) amount);
       }
     }
     break;
   }
   }
   if (foundPropEnd == MagickFalse)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
     {
       ;  
     }
   else
     {
       int
         current_layer = 0,
         foundAllLayers = MagickFalse,
         number_layers = 0;
 
       MagickOffsetType
         oldPos=TellBlob(image);
 
       XCFLayerInfo
         *layer_info;
 
        
       do
       {
         ssize_t offset = ReadBlobMSBSignedLong(image);
         if (offset == 0)
           foundAllLayers=MagickTrue;
         else
           number_layers++;
         if (EOFBlob(image) != MagickFalse)
           {
             ThrowFileException(exception,CorruptImageError,
               ""UnexpectedEndOfFile"",image->filename);
             break;
           }
     } while (foundAllLayers == MagickFalse);
     doc_info.number_layers=number_layers;
     offset=SeekBlob(image,oldPos,SEEK_SET);  
     if (offset < 0)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
      
     length=(size_t) number_layers;
     layer_info=(XCFLayerInfo *) AcquireQuantumMemory(length,
       sizeof(*layer_info));
     if (layer_info == (XCFLayerInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     (void) ResetMagickMemory(layer_info,0,number_layers*sizeof(XCFLayerInfo));
     for ( ; ; )
     {
       MagickBooleanType
         layer_ok;
 
       MagickOffsetType
         offset,
         saved_pos;
 
        
       offset=(MagickOffsetType) ReadBlobMSBLong(image);
        
       if (offset == 0)
         break;
        
       saved_pos=TellBlob(image);
        
       if (SeekBlob(image,offset,SEEK_SET) != offset)
         ThrowReaderException(ResourceLimitError,""NotEnoughPixelData"");
        
       layer_ok=ReadOneLayer(image_info,image,&doc_info,
         &layer_info[current_layer],current_layer);
       if (layer_ok == MagickFalse)
         {
           int j;
 
           for (j=0; j < current_layer; j++)
             layer_info[j].image=DestroyImage(layer_info[j].image);
           layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         }
        
       offset=SeekBlob(image, saved_pos, SEEK_SET);
       current_layer++;
     }
 #if 0
         {
          
         signed int  j;
         for (j=number_layers-1; j>=0; j--) {
            
 
           if ( layer_info[j].visible ) {  
             CompositeImage(image, OverCompositeOp, layer_info[j].image,
                      layer_info[j].offset_x, layer_info[j].offset_y );
              layer_info[j].image =DestroyImage( layer_info[j].image );
 
              
             if ( image_type == GIMP_GRAY ) {
               QuantizeInfo  qi;
               GetQuantizeInfo(&qi);
               qi.colorspace = GRAYColorspace;
               QuantizeImage( &qi, layer_info[j].image );
             }
           }
         }
       }
 #else
       {
          
         ssize_t  j;
 
          
         for (j=(long) number_layers-1; j >= 0; j--)
           AppendImageToList(&image,layer_info[j].image);
       }
 #endif
 
     layer_info=(XCFLayerInfo *) RelinquishMagickMemory(layer_info);
 
 #if 0   
     while (MagickTrue)
     {
        
       info->cp += xcf_read_int32 (info->fp, &offset, 1);
 
        
       if (offset == 0)
         break;
 
        
       saved_pos = info->cp;
 
        
       xcf_seek_pos (info, offset);
 
        
       channel = xcf_load_channel (info, gimage);
       if (channel == 0)
         goto error;
 
       num_successful_elements++;
 
        
       if (channel != gimage->selection_mask)
         gimp_image_add_channel (gimage, channel, -1);
 
        
       xcf_seek_pos (info, saved_pos);
     }
 #endif
    }
  
    (void) CloseBlob(image);
  DestroyImage(RemoveFirstImageFromList(&image));
   if (GetNextImageInList(image) != (Image *) NULL)
     DestroyImage(RemoveFirstImageFromList(&image));
    if (image_type == GIMP_GRAY)
      image->type=GrayscaleType;
    return(GetFirstImageInList(image));
 }","[349, 350, 348]",An issue was discovered in ImageMagick 6.9.7. A specially crafted xcf file could lead to a NULL pointer dereference.
4172,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
const auto converted = base::WideToUTF8(arg);
const char* a = converted.c_str();
#else
const char* a = arg;
#endif

static const char* prefixes[] = {""--"", ""-"", ""/""};

int prefix_length = 0;
for (auto& prefix : prefixes) {
if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
prefix_length = strlen(prefix);
break;
}
}

if (prefix_length > 0) {
a += prefix_length;
std::string switch_name(a, strcspn(a, ""=""));
auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
switch_name);
if (iter != std::end(kBlacklist) && switch_name == *iter) {
return true;
}
}

return false;
}",[21],"Github Electron version Electron 1.8.2-beta.4 and earlier contains a Command Injection vulnerability in Protocol Handler that can result in command execute. This attack appear to be exploitable via the victim opening an electron protocol handler in their browser. This vulnerability appears to have been fixed in Electron 1.8.2-beta.5. This issue is due to an incomplete fix for CVE-2018-1000006, specifically the black list used was not case insensitive allowing an attacker to potentially bypass it."
6345,"static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr)
{
bool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG;
u32 chunk_size = mr->chunk_size, headroom = mr->headroom;
unsigned int chunks, chunks_per_page;
u64 addr = mr->addr, size = mr->len;
int size_chk, err;

if (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) {






return -EINVAL;
}

if (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG |
XDP_UMEM_USES_NEED_WAKEUP))
return -EINVAL;

if (!unaligned_chunks && !is_power_of_2(chunk_size))
return -EINVAL;

if (!PAGE_ALIGNED(addr)) {



return -EINVAL;
}

if ((addr + size) < addr)
return -EINVAL;

chunks = (unsigned int)div_u64(size, chunk_size);
if (chunks == 0)
return -EINVAL;

if (!unaligned_chunks) {
chunks_per_page = PAGE_SIZE / chunk_size;
if (chunks < chunks_per_page || chunks % chunks_per_page)
return -EINVAL;
}

size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM;
if (size_chk < 0)
return -EINVAL;

umem->address = (unsigned long)addr;
umem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK
: ~((u64)chunk_size - 1);
umem->size = size;
umem->headroom = headroom;
umem->chunk_size_nohr = chunk_size - headroom;
umem->npgs = size / PAGE_SIZE;
umem->pgs = NULL;
umem->user = NULL;
umem->flags = mr->flags;
INIT_LIST_HEAD(&umem->xsk_list);
spin_lock_init(&umem->xsk_list_lock);

refcount_set(&umem->users, 1);

err = xdp_umem_account_pages(umem);
if (err)
return err;

err = xdp_umem_pin_pages(umem);
if (err)
goto out_account;

umem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages),
GFP_KERNEL_ACCOUNT);
if (!umem->pages) {
err = -ENOMEM;
goto out_pin;
}

err = xdp_umem_map_pages(umem);
if (!err)
return 0;

kvfree(umem->pages);

out_pin:
xdp_umem_unpin_pages(umem);
out_account:
xdp_umem_unaccount_pages(umem);
return err;
}","[7, 46, 47]",An issue was discovered in the Linux kernel before 5.6.7. xdp_umem_reg in net/xdp/xdp_umem.c has an out-of-bounds write (by a user with the CAP_NET_ADMIN capability) because of a lack of headroom validation.
202875,"  static void Np_toString(js_State *J)
  {
	char buf[32];
 	char buf[100];
  	js_Object *self = js_toobject(J, 0);
  	int radix = js_isundefined(J, 1) ? 10 : js_tointeger(J, 1);
  	if (self->type != JS_CNUMBER)
 		js_typeerror(J, ""not a number"");
 	if (radix == 10) {
 		js_pushstring(J, jsV_numbertostring(J, buf, self->u.number));
 		return;
 	}
 	if (radix < 2 || radix > 36)
 		js_rangeerror(J, ""invalid radix"");
 
  	 
  	{
  		static const char digits[] = ""0123456789abcdefghijklmnopqrstuvwxyz"";
		char buf[100];
  		double number = self->u.number;
  		int sign = self->u.number < 0;
  		js_Buffer *sb = NULL;
 		uint64_t u, limit = ((uint64_t)1<<52);
 
 		int ndigits, exp, point;
 
 		if (number == 0) { js_pushstring(J, ""0""); return; }
 		if (isnan(number)) { js_pushstring(J, ""NaN""); return; }
 		if (isinf(number)) { js_pushstring(J, sign ? ""-Infinity"" : ""Infinity""); return; }
 
 		if (sign)
 			number = -number;
 
 		 
 		exp = 0;
 		while (number * pow(radix, exp) > limit)
 			--exp;
 		while (number * pow(radix, exp+1) < limit)
 			++exp;
 		u = number * pow(radix, exp) + 0.5;
 
 		 
 		while (u > 0 && (u % radix) == 0) {
 			u /= radix;
 			--exp;
 		}
 
 		 
 		ndigits = 0;
 		while (u > 0) {
 			buf[ndigits++] = digits[u % radix];
 			u /= radix;
 		}
 		point = ndigits - exp;
 
 		if (js_try(J)) {
 			js_free(J, sb);
 			js_throw(J);
 		}
 
 		if (sign)
 			js_putc(J, &sb, '-');
 
 		if (point <= 0) {
 			js_putc(J, &sb, '0');
 			js_putc(J, &sb, '.');
 			while (point++ < 0)
 				js_putc(J, &sb, '0');
 			while (ndigits-- > 0)
 				js_putc(J, &sb, buf[ndigits]);
 		} else {
 			while (ndigits-- > 0) {
 				js_putc(J, &sb, buf[ndigits]);
 				if (--point == 0 && ndigits > 0)
 					js_putc(J, &sb, '.');
 			}
 			while (point-- > 0)
 				js_putc(J, &sb, '0');
 		}
 
 		js_putc(J, &sb, 0);
 		js_pushstring(J, sb->s);
 
 		js_endtry(J);
 		js_free(J, sb);
 	}
 }","[4, 3, 19]",An issue was discovered in Artifex MuJS 1.0.5. The Number#toFixed() and numtostr implementations in jsnumber.c have a stack-based buffer overflow.
8326,"Status check_index_uninitialized(const Tensor& key, std::size_t index,
const OptionalTuple& tuple)
TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
if (tuple[index].has_value()) {
return Status(errors::InvalidArgument(
""The tensor for index '"", index, ""' for key '"", key.scalar<int64>()(),
""' was already initialized '"", dtypes_.size(), ""'.""));
}

return Status::OK();
}","[5, 7]","TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in `tf.raw_ops.Map*` and `tf.raw_ops.OrderedMap*` operations. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/map_stage_op.cc#L222-L248) has a check in place to ensure that `indices` is in ascending order, but does not check that `indices` is not empty. We have patched the issue in GitHub commit 532f5c5a547126c634fefd43bbad1dc6417678ac. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
205327," CastCastView::CastCastView(CastConfigDelegate* cast_config_delegate)
     : cast_config_delegate_(cast_config_delegate) {
 
   set_background(views::Background::CreateSolidBackground(kBackgroundColor));
   ui::ResourceBundle& bundle = ui::ResourceBundle::GetSharedInstance();
   SetLayoutManager(new views::BoxLayout(views::BoxLayout::kHorizontal,
                                         kTrayPopupPaddingHorizontal, 0,
                                         kTrayPopupPaddingBetweenItems));
   icon_ = new FixedSizedImageView(0, kTrayPopupItemHeight);
   icon_->SetImage(
       bundle.GetImageNamed(IDR_AURA_UBER_TRAY_CAST_ENABLED).ToImageSkia());
   AddChildView(icon_);
 
   label_container_ = new views::View;
   label_container_->SetLayoutManager(
       new views::BoxLayout(views::BoxLayout::kVertical, 0, 0, 0));
 
    title_ = new views::Label;
    title_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    title_->SetFontList(bundle.GetFontList(ui::ResourceBundle::BoldFont));
   title_->SetText(
       bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_CAST_TYPE));
    label_container_->AddChildView(title_);
  
    details_ = new views::Label;
    details_->SetHorizontalAlignment(gfx::ALIGN_LEFT);
    details_->SetMultiLine(false);
    details_->SetEnabledColor(kHeaderTextColorNormal);
   details_->SetText(
       bundle.GetLocalizedString(IDS_ASH_STATUS_TRAY_CAST_UNKNOWN_RECEIVER));
    label_container_->AddChildView(details_);
  
    AddChildView(label_container_);
 
   base::string16 stop_button_text =
       ui::ResourceBundle::GetSharedInstance().GetLocalizedString(
           IDS_ASH_STATUS_TRAY_CAST_STOP);
   stop_button_ = new TrayPopupLabelButton(this, stop_button_text);
   AddChildView(stop_button_);
 
   UpdateLabel();
 }","[21, 22, 29, 30]","Cross-site scripting (XSS) vulnerability in the DocumentLoader::maybeCreateArchive function in core/loader/DocumentLoader.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to inject arbitrary web script or HTML via crafted MHTML content, aka *Universal XSS (UXSS).*"
206141,"  png_get_int_32(png_bytep buf)
  {
   png_int_32 i = ((png_int_32)(*buf) << 24) +
      ((png_int_32)(*(buf + 1)) << 16) +
      ((png_int_32)(*(buf + 2)) << 8) +
      (png_int_32)(*(buf + 3));
    png_int_32 i = ((png_int_32)((*(buf    )) & 0xff) << 24) +
                   ((png_int_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_int_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_int_32)((*(buf + 3)) & 0xff)      );
  
     return (i);
  }","[7, 8, 9, 10, 3, 4, 5, 6]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
199890,"  static int mount_entry_on_relative_rootfs(struct mntent *mntent,
 					  const char *rootfs)
 {
 	char path[MAXPATHLEN];
 	int ret;
 
 	 
 	ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir);
 	if (ret >= sizeof(path)) {
 		ERROR(""path name too long"");
  		return -1;
  	}
  
	return mount_entry_on_generic(mntent, path);
 	return mount_entry_on_generic(mntent, path, rootfs);
  }","[15, 14]",lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.
5928,"v3d_submit_cl_ioctl(struct drm_device *dev, void *data,
struct drm_file *file_priv)
{
struct v3d_dev *v3d = to_v3d_dev(dev);
struct v3d_file_priv *v3d_priv = file_priv->driver_priv;
struct drm_v3d_submit_cl *args = data;
struct v3d_bin_job *bin = NULL;
struct v3d_render_job *render;
struct ww_acquire_ctx acquire_ctx;
int ret = 0;

trace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);

if (args->pad != 0) {
DRM_INFO(""pad must be zero: %d\n"", args->pad);
return -EINVAL;
}

render = kcalloc(1, sizeof(*render), GFP_KERNEL);
if (!render)
return -ENOMEM;

render->start = args->rcl_start;
render->end = args->rcl_end;
INIT_LIST_HEAD(&render->unref_list);

ret = v3d_job_init(v3d, file_priv, &render->base,
v3d_render_job_free, args->in_sync_rcl);
if (ret) {
kfree(render);
return ret;
}

if (args->bcl_start != args->bcl_end) {
bin = kcalloc(1, sizeof(*bin), GFP_KERNEL);
if (!bin)
return -ENOMEM;

ret = v3d_job_init(v3d, file_priv, &bin->base,
v3d_job_free, args->in_sync_bcl);
if (ret) {
v3d_job_put(&render->base);
return ret;
}

bin->start = args->bcl_start;
bin->end = args->bcl_end;
bin->qma = args->qma;
bin->qms = args->qms;
bin->qts = args->qts;
bin->render = render;
}

ret = v3d_lookup_bos(dev, file_priv, &render->base,
args->bo_handles, args->bo_handle_count);
if (ret)
goto fail;

ret = v3d_lock_bo_reservations(&render->base, &acquire_ctx);
if (ret)
goto fail;

mutex_lock(&v3d->sched_lock);
if (bin) {
ret = v3d_push_job(v3d_priv, &bin->base, V3D_BIN);
if (ret)
goto fail_unreserve;

ret = drm_gem_fence_array_add(&render->base.deps,
dma_fence_get(bin->base.done_fence));
if (ret)
goto fail_unreserve;
}

ret = v3d_push_job(v3d_priv, &render->base, V3D_RENDER);
if (ret)
goto fail_unreserve;
mutex_unlock(&v3d->sched_lock);

v3d_attach_fences_and_unlock_reservation(file_priv,
&render->base,
&acquire_ctx,
args->out_sync,
render->base.done_fence);

if (bin)
v3d_job_put(&bin->base);
v3d_job_put(&render->base);

return 0;

fail_unreserve:
mutex_unlock(&v3d->sched_lock);
drm_gem_unlock_reservations(render->base.bo,
render->base.bo_count, &acquire_ctx);
fail:
if (bin)
v3d_job_put(&bin->base);
v3d_job_put(&render->base);

return ret;
}","[36, 39, 43]","Two memory leaks in the v3d_submit_cl_ioctl() function in drivers/gpu/drm/v3d/v3d_gem.c in the Linux kernel before 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering kcalloc() or v3d_job_init() failures, aka CID-29cd13cfd762."
201743," static Image *ReadHRZImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   Image
     *image;
 
   MagickBooleanType
     status;
 
   register ssize_t
     x;
 
   register PixelPacket
     *q;
 
   register unsigned char
     *p;
 
   ssize_t
     count,
     y;
 
   size_t
     length;
 
   unsigned char
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
    image->columns=256;
    image->rows=240;
    image->depth=8;
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
    pixels=(unsigned char *) AcquireQuantumMemory(image->columns,3*
      sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   length=(size_t) (3*image->columns);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     count=ReadBlob(image,length,pixels);
     if ((size_t) count != length)
       ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
     p=pixels;
     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
     if (q == (PixelPacket *) NULL)
       break;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       SetPixelRed(q,ScaleCharToQuantum(4**p++));
       SetPixelGreen(q,ScaleCharToQuantum(4**p++));
       SetPixelBlue(q,ScaleCharToQuantum(4**p++));
       SetPixelOpacity(q,OpaqueOpacity);
       q++;
     }
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
     if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)
       break;
   }
   pixels=(unsigned char *) RelinquishMagickMemory(pixels);
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[47, 48, 49, 50, 51, 52]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
6288,"GF_Err audio_sample_entry_Read(GF_Box *s, GF_BitStream *bs)
{
GF_MPEGAudioSampleEntryBox *ptr;
char *data;
u8 a, b, c, d;
u32 i, size, v, nb_alnum;
GF_Err e;
u64 pos, start;

ptr = (GF_MPEGAudioSampleEntryBox *)s;

start = gf_bs_get_position(bs);
gf_bs_seek(bs, start + 8);
v = gf_bs_read_u16(bs);
if (v)
ptr->is_qtff = 1;


if (v==1) {

gf_bs_seek(bs, start + 8 + 20  + 4);
a = gf_bs_read_u8(bs);
b = gf_bs_read_u8(bs);
c = gf_bs_read_u8(bs);
d = gf_bs_read_u8(bs);
nb_alnum = 0;
if (isalnum(a)) nb_alnum++;
if (isalnum(b)) nb_alnum++;
if (isalnum(c)) nb_alnum++;
if (isalnum(d)) nb_alnum++;
if (nb_alnum>2) ptr->is_qtff = 0;
}

gf_bs_seek(bs, start);
e = gf_isom_audio_sample_entry_read((GF_AudioSampleEntryBox*)s, bs);
if (e) return e;
pos = gf_bs_get_position(bs);
size = (u32) s->size;



if (gf_bs_get_cookie(bs)) {
ptr->is_qtff |= 1<<16;
}

e = gf_isom_box_array_read(s, bs, audio_sample_entry_AddBox);
if (!e) return GF_OK;
if (size<8) return GF_ISOM_INVALID_FILE;


gf_bs_seek(bs, pos);
data = (char*)gf_malloc(sizeof(char) * size);
gf_bs_read_data(bs, data, size);
for (i=0; i<size-8; i++) {
if (GF_4CC((u32)data[i+4], (u8)data[i+5], (u8)data[i+6], (u8)data[i+7]) == GF_ISOM_BOX_TYPE_ESDS) {
GF_BitStream *mybs = gf_bs_new(data + i, size - i, GF_BITSTREAM_READ);
if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}

e = gf_isom_box_parse((GF_Box **)&ptr->esd, mybs);

if (e==GF_OK) {
gf_isom_box_add_for_dump_mode((GF_Box*)ptr, (GF_Box*)ptr->esd);
} else if (ptr->esd) {
gf_isom_box_del((GF_Box *)ptr->esd);
ptr->esd=NULL;
}

gf_bs_del(mybs);
break;
}
}
gf_free(data);
return e;
}","[56, 58]","An issue was discovered in libgpac.a in GPAC 0.8.0, as demonstrated by MP4Box. audio_sample_entry_Read in isomedia/box_code_base.c does not properly decide when to make gf_isom_box_del calls. This leads to various use-after-free outcomes involving mdia_Read, gf_isom_delete_movie, and gf_isom_parse_movie_boxes."
207686," make_size_image(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type,
    png_byte PNG_CONST bit_depth, int PNG_CONST interlace_type,
    png_uint_32 PNG_CONST w, png_uint_32 PNG_CONST h,
    int PNG_CONST do_interlace)
 make_size_image(png_store* const ps, png_byte const colour_type,
     png_byte const bit_depth, int const interlace_type,
     png_uint_32 const w, png_uint_32 const h,
     int const do_interlace)
  {
     context(ps, fault);
  
    
     check_interlace_type(interlace_type);
  
     Try
  {
       png_infop pi;
       png_structp pp;
  unsigned int pixel_size;
 
  
         
        char name[FILE_NAME_SIZE];
      PNG_CONST png_uint_32 id = FILEID(colour_type, bit_depth, 0 ,
       const png_uint_32 id = FILEID(colour_type, bit_depth, 0 ,
           interlace_type, w, h, do_interlace);
  
        standard_name_from_id(name, sizeof name, 0, id);
       pp = set_store_for_write(ps, &pi, name);
 
   
  if (pp == NULL)
  Throw ps;
 
       png_set_IHDR(pp, pi, w, h, bit_depth, colour_type, interlace_type,
          PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
 
 #ifdef PNG_TEXT_SUPPORTED
  {
  static char key[] = ""image name"";  
  size_t pos;
          png_text text;
  char copy[FILE_NAME_SIZE];
 
   
          text.compression = TEXT_COMPRESSION;
          text.key = key;
   
          pos = safecat(copy, sizeof copy, 0, ps->wname);
          text.text = copy;
          text.text_length = pos;
          text.itxt_length = 0;
          text.lang = 0;
          text.lang_key = 0;
 
          png_set_text(pp, pi, &text, 1);
  }
 #endif
 
  if (colour_type == 3)  
          init_standard_palette(ps, pp, pi, 1U << bit_depth, 0 );
 
       png_write_info(pp, pi);
 
   
        pixel_size = bit_size(pp, colour_type, bit_depth);
        if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)
         png_error(pp, ""row size incorrect"");
          png_error(pp, ""size row size incorrect"");
  
        else
        {
  int npasses = npasses_from_interlace_type(pp, interlace_type);
          png_uint_32 y;
  int pass;
 #        ifdef PNG_WRITE_FILTER_SUPPORTED
  int nfilter = PNG_FILTER_VALUE_LAST;
 #        endif
          png_byte image[16][SIZE_ROWMAX];
 
   
           memset(image, 0xff, sizeof image);
  
         if (!do_interlace && npasses != png_set_interlace_handling(pp))
          if (!do_interlace &&
              npasses != set_write_interlace_handling(pp, interlace_type))
              png_error(pp, ""write: png_set_interlace_handling failed"");
  
            
  for (y=0; y<h; ++y)
             size_row(image[y], w * pixel_size, y);
 
 
           for (pass=0; pass<npasses; ++pass)
           {
               
            PNG_CONST png_uint_32 wPass = PNG_PASS_COLS(w, pass);
             const png_uint_32 wPass = PNG_PASS_COLS(w, pass);
  
               
  for (y=0; y<h; ++y)
  {
                png_const_bytep row = image[y];
                png_byte tempRow[SIZE_ROWMAX];
 
   
  if (do_interlace && interlace_type == PNG_INTERLACE_ADAM7)
  {
   
  if (PNG_ROW_IN_INTERLACE_PASS(y, pass) && wPass > 0)
  {
   
                       memset(tempRow, 0xff, sizeof tempRow);
                     interlace_row(tempRow, row, pixel_size, w, pass);
                      interlace_row(tempRow, row, pixel_size, w, pass,
                            0 );
                       row = tempRow;
                    }
                    else
  continue;
  }
 
 #           ifdef PNG_WRITE_FILTER_SUPPORTED
   
                png_set_filter(pp, 0 ,
                   nfilter >= PNG_FILTER_VALUE_LAST ? PNG_ALL_FILTERS : nfilter);
 
  if (nfilter-- == 0)
                   nfilter = PNG_FILTER_VALUE_LAST-1;
 #           endif
 
                png_write_row(pp, row);
  }
  }
  }
 
 #ifdef PNG_TEXT_SUPPORTED
  {
  static char key[] = ""end marker"";
  static char comment[] = ""end"";
          png_text text;
 
   
          text.compression = TEXT_COMPRESSION;
          text.key = key;
          text.text = comment;
          text.text_length = (sizeof comment)-1;
          text.itxt_length = 0;
          text.lang = 0;
          text.lang_key = 0;
 
          png_set_text(pp, pi, &text, 1);
  }
 #endif
 
       png_write_end(pp, pi);
 
   
       store_storefile(ps, id);
 
       store_write_reset(ps);
  }
 
  Catch(fault)
  {
   
       store_write_reset(fault);
  }
 
  }","[5, 6, 7, 8, 25, 69, 85, 86, 98, 115, 116, 2, 3, 4, 12, 24, 68, 84, 97, 114]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
208136," resetLppTransposer (HANDLE_SBR_LPP_TRANS hLppTrans,  
                     UCHAR  highBandStartSb,  
                     UCHAR *v_k_master,  
                     UCHAR  numMaster,  
                     UCHAR *noiseBandTable,  
                     UCHAR  noNoiseBands,  
                     UCHAR  usb,  
                     UINT   fs                         
  )
 {
   TRANSPOSER_SETTINGS *pSettings = hLppTrans->pSettings;
   PATCH_PARAM  *patchParam = pSettings->patchParam;
 
  int i, patch;
  int targetStopBand;
  int sourceStartBand;
  int patchDistance;
  int numBandsInPatch;
 
  int lsb = v_k_master[0];  
  int xoverOffset = highBandStartSb - lsb;  
  int startFreqHz;
 
  int desiredBorder;
 
   usb = fixMin(usb, v_k_master[numMaster]);  
 
   
 
  if ( lsb - SHIFT_START_SB < 4 ) {
  return SBRDEC_UNSUPPORTED_CONFIG;
  }
 
 
   
   
   desiredBorder    = (((2048000*2) / fs) + 1) >> 1;
 
   desiredBorder = findClosestEntry(desiredBorder, v_k_master, numMaster, 1);  
 
   
   sourceStartBand = SHIFT_START_SB + xoverOffset;
   targetStopBand = lsb + xoverOffset;  
 
   
   patch = 0;
  while(targetStopBand < usb) {
 
   
  if (patch > MAX_NUM_PATCHES) {
  return SBRDEC_UNSUPPORTED_CONFIG;
  }
 
     patchParam[patch].guardStartBand = targetStopBand;
     patchParam[patch].targetStartBand = targetStopBand;
 
     numBandsInPatch = desiredBorder - targetStopBand;  
 
  if ( numBandsInPatch >= lsb - sourceStartBand ) {
   
       patchDistance   = targetStopBand - sourceStartBand;  
       patchDistance   = patchDistance & ~1;  
       numBandsInPatch = lsb - (targetStopBand - patchDistance);  
       numBandsInPatch = findClosestEntry(targetStopBand + numBandsInPatch, v_k_master, numMaster, 0) -
                         targetStopBand;  
  }
 
   
     patchDistance   = numBandsInPatch + targetStopBand - lsb;  
     patchDistance   = (patchDistance + 1) & ~1;  
 
  if (numBandsInPatch > 0) {
       patchParam[patch].sourceStartBand = targetStopBand - patchDistance;
       patchParam[patch].targetBandOffs  = patchDistance;
       patchParam[patch].numBandsInPatch = numBandsInPatch;
       patchParam[patch].sourceStopBand  = patchParam[patch].sourceStartBand + numBandsInPatch;
 
       targetStopBand += patchParam[patch].numBandsInPatch;
       patch++;
  }
 
   
     sourceStartBand = SHIFT_START_SB;
 
   
  if( desiredBorder - targetStopBand < 3)  
  {
       desiredBorder = usb;
  }
 
  }
 
   patch--;
 
   
  if ( (patch>0) && (patchParam[patch].numBandsInPatch < 3) ) {
     patch--;
     targetStopBand = patchParam[patch].targetStartBand + patchParam[patch].numBandsInPatch;
  }
 
   
  if (patch >= MAX_NUM_PATCHES) {
  return SBRDEC_UNSUPPORTED_CONFIG;
  }
 
   pSettings->noOfPatches = patch + 1;
 
   
   pSettings->lbStartPatching = targetStopBand;
   pSettings->lbStopPatching  = 0;
  for ( patch = 0; patch < pSettings->noOfPatches; patch++ ) {
     pSettings->lbStartPatching = fixMin( pSettings->lbStartPatching, patchParam[patch].sourceStartBand );
     pSettings->lbStopPatching  = fixMax( pSettings->lbStopPatching, patchParam[patch].sourceStopBand );
  }
 
 
    for(i = 0 ; i < noNoiseBands; i++){
      pSettings->bwBorders[i] = noiseBandTable[i+1];
    }
   for (;i < MAX_NUM_NOISE_VALUES; i++) {
     pSettings->bwBorders[i] = 255;
   }
 
  
     
 
   startFreqHz = ( (lsb + xoverOffset)*fs ) >> 7;  
 
  for( i = 1; i < NUM_WHFACTOR_TABLE_ENTRIES; i++ )
  {
  if( startFreqHz < FDK_sbrDecoder_sbr_whFactorsIndex[i])
  break;
  }
   i--;
 
   pSettings->whFactors.off = FDK_sbrDecoder_sbr_whFactorsTable[i][0];
   pSettings->whFactors.transitionLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][1];
   pSettings->whFactors.lowLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][2];
   pSettings->whFactors.midLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][3];
   pSettings->whFactors.highLevel = FDK_sbrDecoder_sbr_whFactorsTable[i][4];
 
  return SBRDEC_OK;
 }","[120, 121, 122, 123]","An information disclosure vulnerability in the Android media framework (aac). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0, 8.1. Android ID: A-65280786."
7706,"PJ_DEF(pj_status_t) pjmedia_sdp_neg_modify_local_offer2(
pj_pool_t *pool,
pjmedia_sdp_neg *neg,
unsigned flags,
const pjmedia_sdp_session *local)
{
pjmedia_sdp_session *new_offer;
pjmedia_sdp_session *old_offer;
char media_used[PJMEDIA_MAX_SDP_MEDIA];
unsigned oi;
pj_status_t status;


PJ_ASSERT_RETURN(pool && neg && local, PJ_EINVAL);


PJ_ASSERT_RETURN(neg->state == PJMEDIA_SDP_NEG_STATE_DONE,
PJMEDIA_SDPNEG_EINSTATE);


status = pjmedia_sdp_validate(local);
if (status != PJ_SUCCESS)
return status;


neg->state = PJMEDIA_SDP_NEG_STATE_LOCAL_OFFER;


pj_bzero(media_used, sizeof(media_used));
old_offer = neg->active_local_sdp;
new_offer = pjmedia_sdp_session_clone(pool, local);






pj_strdup(pool, &new_offer->origin.user, &old_offer->origin.user);
new_offer->origin.id = old_offer->origin.id;

pj_strdup(pool, &new_offer->origin.net_type, &old_offer->origin.net_type);
pj_strdup(pool, &new_offer->origin.addr_type,&old_offer->origin.addr_type);
pj_strdup(pool, &new_offer->origin.addr, &old_offer->origin.addr);

if ((flags & PJMEDIA_SDP_NEG_ALLOW_MEDIA_CHANGE) == 0) {






for (oi = 0; oi < old_offer->media_count; ++oi) {
pjmedia_sdp_media *om;
pjmedia_sdp_media *nm;
unsigned ni;
pj_bool_t found = PJ_FALSE;

om = old_offer->media[oi];
for (ni = oi; ni < new_offer->media_count; ++ni) {
nm = new_offer->media[ni];
if (pj_strcmp(&nm->desc.media, &om->desc.media) == 0) {
if (ni != oi) {




pj_array_insert(
new_offer->media,
sizeof(new_offer->media[0]),
ni,
oi,
&nm);
}
found = PJ_TRUE;
break;
}
}
if (!found) {
pjmedia_sdp_media *m;

m = sdp_media_clone_deactivate(pool, om, om, local);

pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
new_offer->media_count++, oi, &m);
}
}
} else {




for (oi = new_offer->media_count; oi < old_offer->media_count; ++oi) {
pjmedia_sdp_media *m;

m = sdp_media_clone_deactivate(pool, old_offer->media[oi],
old_offer->media[oi], local);

pj_array_insert(new_offer->media, sizeof(new_offer->media[0]),
new_offer->media_count++, oi, &m);

}
}


#if PJMEDIA_SDP_NEG_COMPARE_BEFORE_INC_VERSION
new_offer->origin.version = old_offer->origin.version;

if (pjmedia_sdp_session_cmp(new_offer, neg->initial_sdp, 0) != PJ_SUCCESS)
{
++new_offer->origin.version;
}
#else
new_offer->origin.version = old_offer->origin.version + 1;
#endif

neg->initial_sdp_tmp = neg->initial_sdp;
neg->initial_sdp = new_offer;
neg->neg_local_sdp = pjmedia_sdp_session_clone(pool, new_offer);

return PJ_SUCCESS;
}","[9, 29, 29]","PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In PJSIP version 2.10 and earlier, after an initial INVITE has been sent, when two 183 responses are received, with the first one causing negotiation failure, a crash will occur. This results in a denial of service."
204461," void LauncherView::ButtonPressed(views::Button* sender,
                                  const views::Event& event) {
    if (dragging_)
      return;
  
  if (sender == overflow_button_)
    ShowOverflowMenu();
   if (sender == overflow_button_) {
     ShowOverflowBubble();
     return;
   }
  
    if (!delegate_)
      return;
   int view_index = view_model_->GetIndexOfView(sender);
   if (view_index == -1)
     return;
 
   switch (model_->items()[view_index].type) {
     case TYPE_TABBED:
     case TYPE_APP_PANEL:
     case TYPE_APP_SHORTCUT:
     case TYPE_PLATFORM_APP:
       delegate_->ItemClicked(model_->items()[view_index], event.flags());
       break;
 
     case TYPE_APP_LIST:
       Shell::GetInstance()->ToggleAppList();
       break;
 
     case TYPE_BROWSER_SHORTCUT:
       if (event.flags() & ui::EF_CONTROL_DOWN)
         delegate_->CreateNewWindow();
       else
         delegate_->CreateNewTab();
       break;
   }
 }","[8, 9, 10, 11, 6, 7]",The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.
207087,"  void MediaStreamManager::GenerateStream(
      int render_process_id,
      int render_frame_id,
     int requester_id,
      int page_request_id,
      const StreamControls& controls,
      MediaDeviceSaltAndOrigin salt_and_origin,
     bool user_gesture,
     GenerateStreamCallback generate_stream_cb,
     DeviceStoppedCallback device_stopped_cb,
     DeviceChangedCallback device_changed_cb) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
    DVLOG(1) << ""GenerateStream()"";
  
    DeviceRequest* request = new DeviceRequest(
      render_process_id, render_frame_id, page_request_id, user_gesture,
      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),
       render_process_id, render_frame_id, requester_id, page_request_id,
       user_gesture, MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),
        std::move(device_stopped_cb));
    request->device_changed_cb = std::move(device_changed_cb);
  
   const std::string& label = AddRequest(request);
 
   request->generate_stream_cb = std::move(generate_stream_cb);
 
   if (generate_stream_test_callback_) {
     if (std::move(generate_stream_test_callback_).Run(controls)) {
       FinalizeGenerateStream(label, request);
     } else {
       FinalizeRequestFailed(label, request, MEDIA_DEVICE_INVALID_STATE);
     }
     return;
   }
 
   base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},
                            base::BindOnce(&MediaStreamManager::SetUpRequest,
                                           base::Unretained(this), label));
 }","[4, 18, 19, 16, 17]",Incorrect handling of negative zero in V8 in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to perform arbitrary read/write via a crafted HTML page.
201874,"  jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
  {
  	jas_matrix_t *y;
	int i;
	int j;
 	jas_matind_t i;
 	jas_matind_t j;
  	y = jas_matrix_create(x->numrows_, x->numcols_);
  	for (i = 0; i < x->numrows_; ++i) {
  		for (j = 0; j < x->numcols_; ++j) {
 			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
 		}
 	}
 	return y;
 }","[6, 7, 4, 5]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
202108," static UINT drdynvc_process_create_request(drdynvcPlugin* drdynvc, int Sp,
         int cbChId, wStream* s)
 {
 	size_t pos;
 	UINT status;
  	UINT32 ChannelId;
  	wStream* data_out;
  	UINT channel_status;
 	char* name;
 	size_t length;
  
  	if (!drdynvc)
  		return CHANNEL_RC_BAD_CHANNEL_HANDLE;
 
 	if (drdynvc->state == DRDYNVC_STATE_CAPABILITIES)
 	{
 		 
 		drdynvc->version = 3;
 
 		if ((status = drdynvc_send_capability_response(drdynvc)))
 		{
 			WLog_Print(drdynvc->log, WLOG_ERROR, ""drdynvc_send_capability_response failed!"");
 			return status;
 		}
 
  		drdynvc->state = DRDYNVC_STATE_READY;
  	}
  
 	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
 		return ERROR_INVALID_DATA;
 
  	ChannelId = drdynvc_read_variable_uint(s, cbChId);
  	pos = Stream_GetPosition(s);
 	name = Stream_Pointer(s);
 	length = Stream_GetRemainingLength(s);
 
 	if (strnlen(name, length) >= length)
 		return ERROR_INVALID_DATA;
 
  	WLog_Print(drdynvc->log, WLOG_DEBUG, ""process_create_request: ChannelId=%""PRIu32"" ChannelName=%s"",
	           ChannelId,
	           Stream_Pointer(s));
	channel_status = dvcman_create_channel(drdynvc, drdynvc->channel_mgr, ChannelId,
	                                       (char*) Stream_Pointer(s));
 	           ChannelId, name);
 	channel_status = dvcman_create_channel(drdynvc, drdynvc->channel_mgr, ChannelId, name);
  	data_out = Stream_New(NULL, pos + 4);
  
  	if (!data_out)
 	{
 		WLog_Print(drdynvc->log, WLOG_ERROR, ""Stream_New failed!"");
 		return CHANNEL_RC_NO_MEMORY;
 	}
 
 	Stream_Write_UINT8(data_out, 0x10 | cbChId);
 	Stream_SetPosition(s, 1);
 	Stream_Copy(s, data_out, pos - 1);
 
 	if (channel_status == CHANNEL_RC_OK)
 	{
 		WLog_Print(drdynvc->log, WLOG_DEBUG, ""channel created"");
 		Stream_Write_UINT32(data_out, 0);
 	}
 	else
 	{
 		WLog_Print(drdynvc->log, WLOG_DEBUG, ""no listener"");
 		Stream_Write_UINT32(data_out, (UINT32)0xC0000001);  
 	}
 
 	status = drdynvc_send(drdynvc, data_out);
 
 	if (status != CHANNEL_RC_OK)
 	{
 		WLog_Print(drdynvc->log, WLOG_ERROR, ""VirtualChannelWriteEx failed with %s [%08""PRIX32""]"",
 		           WTSErrorToString(status), status);
 		return status;
 	}
 
 	if (channel_status == CHANNEL_RC_OK)
 	{
 		if ((status = dvcman_open_channel(drdynvc, drdynvc->channel_mgr, ChannelId)))
 		{
 			WLog_Print(drdynvc->log, WLOG_ERROR, ""dvcman_open_channel failed with error %""PRIu32""!"", status);
 			return status;
 		}
 	}
 	else
 	{
 		if ((status = dvcman_close_channel(drdynvc->channel_mgr, ChannelId)))
 			WLog_Print(drdynvc->log, WLOG_ERROR, ""dvcman_close_channel failed with error %""PRIu32""!"", status);
 	}
 
 	return status;
 }","[9, 10, 29, 30, 31, 34, 35, 36, 37, 38, 39, 45, 46, 41, 42, 43, 44]","FreeRDP FreeRDP 2.0.0-rc3 released version before commit 205c612820dac644d665b5bb1cdf437dc5ca01e3 contains a Other/Unknown vulnerability in channels/drdynvc/client/drdynvc_main.c, drdynvc_process_capability_request that can result in The RDP server can read the client's memory.. This attack appear to be exploitable via RDPClient must connect the rdp server with echo option. This vulnerability appears to have been fixed in after commit 205c612820dac644d665b5bb1cdf437dc5ca01e3."
204751," xmlXPtrEvalXPtrPart(xmlXPathParserContextPtr ctxt, xmlChar *name) {
     xmlChar *buffer, *cur;
     int len;
     int level;
 
     if (name == NULL)
     name = xmlXPathParseName(ctxt);
     if (name == NULL)
 	XP_ERROR(XPATH_EXPR_ERROR);
 
     if (CUR != '(')
 	XP_ERROR(XPATH_EXPR_ERROR);
     NEXT;
     level = 1;
 
     len = xmlStrlen(ctxt->cur);
     len++;
     buffer = (xmlChar *) xmlMallocAtomic(len * sizeof (xmlChar));
     if (buffer == NULL) {
         xmlXPtrErrMemory(""allocating buffer"");
 	return;
     }
 
     cur = buffer;
     while (CUR != 0) {
 	if (CUR == ')') {
 	    level--;
 	    if (level == 0) {
  		NEXT;
  		break;
  	    }
	    *cur++ = CUR;
  	} else if (CUR == '(') {
  	    level++;
	    *cur++ = CUR;
  	} else if (CUR == '^') {
	    NEXT;
	    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {
		*cur++ = CUR;
	    } else {
		*cur++ = '^';
		*cur++ = CUR;
 	    if ((NXT(1) == ')') || (NXT(1) == '(') || (NXT(1) == '^')) {
 	        NEXT;
  	    }
	} else {
	    *cur++ = CUR;
  	}
 	*cur++ = CUR;
  	NEXT;
      }
      *cur = 0;
 
     if ((level != 0) && (CUR == 0)) {
 	xmlFree(buffer);
 	XP_ERROR(XPTR_SYNTAX_ERROR);
     }
 
     if (xmlStrEqual(name, (xmlChar *) ""xpointer"")) {
 	const xmlChar *left = CUR_PTR;
 
 	CUR_PTR = buffer;
 	 
 	ctxt->context->node = (xmlNodePtr)ctxt->context->doc;
 	ctxt->context->proximityPosition = 1;
 	ctxt->context->contextSize = 1;
 	xmlXPathEvalExpr(ctxt);
 	CUR_PTR=left;
     } else if (xmlStrEqual(name, (xmlChar *) ""element"")) {
 	const xmlChar *left = CUR_PTR;
 	xmlChar *name2;
 
 	CUR_PTR = buffer;
 	if (buffer[0] == '/') {
 	    xmlXPathRoot(ctxt);
 	    xmlXPtrEvalChildSeq(ctxt, NULL);
 	} else {
 	    name2 = xmlXPathParseName(ctxt);
 	    if (name2 == NULL) {
 		CUR_PTR = left;
 		xmlFree(buffer);
 		XP_ERROR(XPATH_EXPR_ERROR);
 	    }
 	    xmlXPtrEvalChildSeq(ctxt, name2);
 	}
 	CUR_PTR = left;
 #ifdef XPTR_XMLNS_SCHEME
     } else if (xmlStrEqual(name, (xmlChar *) ""xmlns"")) {
 	const xmlChar *left = CUR_PTR;
 	xmlChar *prefix;
 	xmlChar *URI;
 	xmlURIPtr value;
 
 	CUR_PTR = buffer;
         prefix = xmlXPathParseNCName(ctxt);
 	if (prefix == NULL) {
 	    xmlFree(buffer);
 	    xmlFree(name);
 	    XP_ERROR(XPTR_SYNTAX_ERROR);
 	}
 	SKIP_BLANKS;
 	if (CUR != '=') {
 	    xmlFree(prefix);
 	    xmlFree(buffer);
 	    xmlFree(name);
 	    XP_ERROR(XPTR_SYNTAX_ERROR);
 	}
 	NEXT;
 	SKIP_BLANKS;
 	 
 
 	value = xmlParseURI((const char *)ctxt->cur);
 	if (value == NULL) {
 	    xmlFree(prefix);
 	    xmlFree(buffer);
 	    xmlFree(name);
 	    XP_ERROR(XPTR_SYNTAX_ERROR);
 	}
 	URI = xmlSaveUri(value);
 	xmlFreeURI(value);
 	if (URI == NULL) {
 	    xmlFree(prefix);
 	    xmlFree(buffer);
 	    xmlFree(name);
 	    XP_ERROR(XPATH_MEMORY_ERROR);
 	}
 	
 	xmlXPathRegisterNs(ctxt->context, prefix, URI);
 	CUR_PTR = left;
 	xmlFree(URI);
 	xmlFree(prefix);
 #endif  
     } else {
         xmlXPtrErr(ctxt, XML_XPTR_UNKNOWN_SCHEME,
 		   ""unsupported scheme '%s'\n"", name);
     }
     xmlFree(buffer);
     xmlFree(name);
 }","[43, 44, 49, 32, 35, 37, 38, 39, 40, 41, 42, 46, 47]","Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors."
7226,"static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
Jsi_Value **ret, Jsi_Func *funcPtr)
{
const char *verStr = NULL;
verStr = lws_get_library_version();
if (verStr) {
char buf[100], *cp;
snprintf(buf, sizeof(buf), ""%s"", verStr);
cp = Jsi_Strchr(buf, ' ');
if (cp) *cp = 0;
Jsi_ValueMakeStringDup(interp, ret, buf);
}
return JSI_OK;
}",[7],"Buffer overflow vulnerability in function NumberToPrecisionCmd in jsish before 3.0.7, allows remote attackers to execute arbitrary code."
200028," static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
 {
 	u32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 	u32 exit_reason = vmx->exit_reason;
 
 	trace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,
 				vmcs_readl(EXIT_QUALIFICATION),
 				vmx->idt_vectoring_info,
 				intr_info,
 				vmcs_read32(VM_EXIT_INTR_ERROR_CODE),
 				KVM_ISA_VMX);
 
 	if (vmx->nested.nested_run_pending)
 		return false;
 
 	if (unlikely(vmx->fail)) {
 		pr_info_ratelimited(""%s failed vm entry %x\n"", __func__,
 				    vmcs_read32(VM_INSTRUCTION_ERROR));
 		return true;
 	}
  
  	switch (exit_reason) {
  	case EXIT_REASON_EXCEPTION_NMI:
		if (!is_exception(intr_info))
 		if (is_nmi(intr_info))
  			return false;
  		else if (is_page_fault(intr_info))
  			return enable_ept;
 		else if (is_no_device(intr_info) &&
 			 !(vmcs12->guest_cr0 & X86_CR0_TS))
 			return false;
 		else if (is_debug(intr_info) &&
 			 vcpu->guest_debug &
 			 (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
 			return false;
 		else if (is_breakpoint(intr_info) &&
 			 vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
 			return false;
 		return vmcs12->exception_bitmap &
 				(1u << (intr_info & INTR_INFO_VECTOR_MASK));
 	case EXIT_REASON_EXTERNAL_INTERRUPT:
 		return false;
 	case EXIT_REASON_TRIPLE_FAULT:
 		return true;
 	case EXIT_REASON_PENDING_INTERRUPT:
 		return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);
 	case EXIT_REASON_NMI_WINDOW:
 		return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);
 	case EXIT_REASON_TASK_SWITCH:
 		return true;
 	case EXIT_REASON_CPUID:
 		if (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)
 			return false;
 		return true;
 	case EXIT_REASON_HLT:
 		return nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);
 	case EXIT_REASON_INVD:
 		return true;
 	case EXIT_REASON_INVLPG:
 		return nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);
 	case EXIT_REASON_RDPMC:
 		return nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);
 	case EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:
 		return nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);
 	case EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:
 	case EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:
 	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:
 	case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:
 	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
 	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
 		 
 		return true;
 	case EXIT_REASON_CR_ACCESS:
 		return nested_vmx_exit_handled_cr(vcpu, vmcs12);
 	case EXIT_REASON_DR_ACCESS:
 		return nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);
 	case EXIT_REASON_IO_INSTRUCTION:
 		return nested_vmx_exit_handled_io(vcpu, vmcs12);
 	case EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:
 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);
 	case EXIT_REASON_MSR_READ:
 	case EXIT_REASON_MSR_WRITE:
 		return nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);
 	case EXIT_REASON_INVALID_STATE:
 		return true;
 	case EXIT_REASON_MWAIT_INSTRUCTION:
 		return nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);
 	case EXIT_REASON_MONITOR_TRAP_FLAG:
 		return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);
 	case EXIT_REASON_MONITOR_INSTRUCTION:
 		return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);
 	case EXIT_REASON_PAUSE_INSTRUCTION:
 		return nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||
 			nested_cpu_has2(vmcs12,
 				SECONDARY_EXEC_PAUSE_LOOP_EXITING);
 	case EXIT_REASON_MCE_DURING_VMENTRY:
 		return false;
 	case EXIT_REASON_TPR_BELOW_THRESHOLD:
 		return nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);
 	case EXIT_REASON_APIC_ACCESS:
 		return nested_cpu_has2(vmcs12,
 			SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);
 	case EXIT_REASON_APIC_WRITE:
 	case EXIT_REASON_EOI_INDUCED:
 		 
 		return true;
 	case EXIT_REASON_EPT_VIOLATION:
 		 
 		return false;
 	case EXIT_REASON_EPT_MISCONFIG:
 		 
 		return false;
 	case EXIT_REASON_WBINVD:
 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);
 	case EXIT_REASON_XSETBV:
 		return true;
 	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
 		 
 		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);
 	case EXIT_REASON_PREEMPTION_TIMER:
 		return false;
 	default:
 		return true;
 	}
 }","[27, 26]","arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest."
206903," static void ProxyLocaltimeCallToBrowser(time_t input, struct tm* output,
                                         char* timezone_out,
                                         size_t timezone_out_len) {
   base::Pickle request;
   request.WriteInt(LinuxSandbox::METHOD_LOCALTIME);
    request.WriteString(
        std::string(reinterpret_cast<char*>(&input), sizeof(input)));
  
   memset(output, 0, sizeof(struct tm));
 
    uint8_t reply_buf[512];
    const ssize_t r = base::UnixDomainSocket::SendRecvMsg(
        GetSandboxFD(), reply_buf, sizeof(reply_buf), NULL, request);
    if (r == -1) {
    memset(output, 0, sizeof(struct tm));
      return;
    }
  
    base::Pickle reply(reinterpret_cast<char*>(reply_buf), r);
    base::PickleIterator iter(reply);
  std::string result;
  std::string timezone;
  if (!iter.ReadString(&result) ||
      !iter.ReadString(&timezone) ||
      result.size() != sizeof(struct tm)) {
   if (!ReadTimeStruct(&iter, output, timezone_out, timezone_out_len)) {
      memset(output, 0, sizeof(struct tm));
    return;
  }
  memcpy(output, result.data(), sizeof(struct tm));
  if (timezone_out_len) {
    const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());
    memcpy(timezone_out, timezone.data(), copy_len);
    timezone_out[copy_len] = 0;
    output->tm_zone = timezone_out;
  } else {
    base::AutoLock lock(g_timezones_lock.Get());
    auto ret_pair = g_timezones.Get().insert(timezone);
    output->tm_zone = ret_pair.first->c_str();
    }
  }","[9, 10, 26, 15, 21, 22, 23, 24, 25, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39]",Incorrect serialization in IPC in Google Chrome prior to 63.0.3239.84 allowed a remote attacker to leak the value of a pointer via a crafted HTML page.
200663," int ext4_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = d_inode(dentry);
 	int error, rc = 0;
 	int orphan = 0;
 	const unsigned int ia_valid = attr->ia_valid;
 
 	error = inode_change_ok(inode, attr);
 	if (error)
 		return error;
 
 	if (is_quota_modification(inode, attr)) {
 		error = dquot_initialize(inode);
 		if (error)
 			return error;
 	}
 	if ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||
 	    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {
 		handle_t *handle;
 
 		 
 		handle = ext4_journal_start(inode, EXT4_HT_QUOTA,
 			(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +
 			 EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);
 		if (IS_ERR(handle)) {
 			error = PTR_ERR(handle);
 			goto err_out;
 		}
 		error = dquot_transfer(inode, attr);
 		if (error) {
 			ext4_journal_stop(handle);
 			return error;
 		}
 		 
 		if (attr->ia_valid & ATTR_UID)
 			inode->i_uid = attr->ia_uid;
 		if (attr->ia_valid & ATTR_GID)
 			inode->i_gid = attr->ia_gid;
 		error = ext4_mark_inode_dirty(handle, inode);
 		ext4_journal_stop(handle);
 	}
 
 	if (attr->ia_valid & ATTR_SIZE) {
 		handle_t *handle;
 		loff_t oldsize = inode->i_size;
 		int shrink = (attr->ia_size <= inode->i_size);
 
 		if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 			struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
 
 			if (attr->ia_size > sbi->s_bitmap_maxbytes)
 				return -EFBIG;
 		}
 		if (!S_ISREG(inode->i_mode))
 			return -EINVAL;
 
 		if (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)
 			inode_inc_iversion(inode);
 
 		if (ext4_should_order_data(inode) &&
 		    (attr->ia_size < inode->i_size)) {
 			error = ext4_begin_ordered_truncate(inode,
 							    attr->ia_size);
 			if (error)
 				goto err_out;
 		}
 		if (attr->ia_size != inode->i_size) {
 			handle = ext4_journal_start(inode, EXT4_HT_INODE, 3);
 			if (IS_ERR(handle)) {
 				error = PTR_ERR(handle);
 				goto err_out;
 			}
 			if (ext4_handle_valid(handle) && shrink) {
 				error = ext4_orphan_add(handle, inode);
 				orphan = 1;
 			}
 			 
 			if (!shrink) {
 				inode->i_mtime = ext4_current_time(inode);
 				inode->i_ctime = inode->i_mtime;
 			}
 			down_write(&EXT4_I(inode)->i_data_sem);
 			EXT4_I(inode)->i_disksize = attr->ia_size;
 			rc = ext4_mark_inode_dirty(handle, inode);
 			if (!error)
 				error = rc;
 			 
 			if (!error)
 				i_size_write(inode, attr->ia_size);
 			up_write(&EXT4_I(inode)->i_data_sem);
 			ext4_journal_stop(handle);
 			if (error) {
 				if (orphan)
 					ext4_orphan_del(NULL, inode);
 				goto err_out;
 			}
 		}
 		if (!shrink)
 			pagecache_isize_extended(inode, oldsize, inode->i_size);
 
 		 
 		if (orphan) {
 			if (!ext4_should_journal_data(inode)) {
 				ext4_inode_block_unlocked_dio(inode);
 				inode_dio_wait(inode);
 				ext4_inode_resume_unlocked_dio(inode);
  			} else
  				ext4_wait_for_tail_page_commit(inode);
  		}
 		down_write(&EXT4_I(inode)->i_mmap_sem);
  		 
  		truncate_pagecache(inode, inode->i_size);
  		if (shrink)
  			ext4_truncate(inode);
 		up_write(&EXT4_I(inode)->i_mmap_sem);
  	}
  
  	if (!rc) {
 		setattr_copy(inode, attr);
 		mark_inode_dirty(inode);
 	}
 
 	 
 	if (orphan && inode->i_nlink)
 		ext4_orphan_del(NULL, inode);
 
 	if (!rc && (ia_valid & ATTR_MODE))
 		rc = posix_acl_chmod(inode, inode->i_mode);
 
 err_out:
 	ext4_std_error(inode->i_sb, error);
 	if (!error)
 		error = rc;
 	return error;
 }","[110, 115]",Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.
199837," spnego_gss_set_sec_context_option(
 		OM_uint32 *minor_status,
 		gss_ctx_id_t *context_handle,
 		const gss_OID desired_object,
  		const gss_buffer_t value)
  {
  	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;
 
 	 
 	if (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)
 		return (GSS_S_UNAVAILABLE);
 
  	ret = gss_set_sec_context_option(minor_status,
			    context_handle,
 			    &sc->ctx_handle,
  			    desired_object,
  			    value);
  	return (ret);
 }","[8, 9, 10, 11, 12, 13, 16, 15]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
207837," ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
     ContentEncoding::GetCompressionByIndex(unsigned long idx) const {
    const ptrdiff_t count = compression_entries_end_ - compression_entries_;
    assert(count >= 0);
  
  if (idx >= static_cast<unsigned long>(count))
  return NULL;
 
  return compression_entries_[idx];
 }",[2],"libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
198551," CStarter::removeDeferredJobs() {
 	bool ret = true;
 	
 	if ( this->deferral_tid == -1 ) {
 		return ( ret );
 	}
 	
 	m_deferred_job_update = true;
 	
 	if ( daemonCore->Cancel_Timer( this->deferral_tid ) >= 0 ) {
 		dprintf( D_FULLDEBUG, ""Cancelled time deferred execution for ""
 							  ""Job %d.%d\n"", 
 					this->jic->jobCluster(),
 					this->jic->jobProc() );
 		this->deferral_tid = -1;
 
 	} else {
 		MyString error = ""Failed to cancel deferred execution timer for Job "";
                 error += this->jic->jobCluster();
                 error += ""."";
                 error += this->jic->jobProc();
               EXCEPT( error.Value() );
                EXCEPT( ""%s"", error.Value() );
                 ret = false;
         }
         return ( ret );
 }","[23, 22]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
6298,"static inline void init_keys(at91_aes_key_size_t *key_size,
unsigned int *cipher_key,
unsigned int *cmac_key,
unsigned int *iv)
{
#if defined(CONFIG_AES_KEY_SIZE_128)
*key_size = AT91_AES_KEY_SIZE_128;
#elif defined(CONFIG_AES_KEY_SIZE_192)
*key_size = AT91_AES_KEY_SIZE_192;
#elif defined(CONFIG_AES_KEY_SIZE_256)
*key_size = AT91_AES_KEY_SIZE_256;
#else
#error ""bad AES key size""
#endif

iv[0]  = CONFIG_AES_IV_WORD0;
iv[1]  = CONFIG_AES_IV_WORD1;
iv[2]  = CONFIG_AES_IV_WORD2;
iv[3]  = CONFIG_AES_IV_WORD3;

cipher_key[0] = CONFIG_AES_CIPHER_KEY_WORD0;
cmac_key[0] = CONFIG_AES_CMAC_KEY_WORD0;
cipher_key[1] = CONFIG_AES_CIPHER_KEY_WORD1;
cmac_key[1] = CONFIG_AES_CMAC_KEY_WORD1;
cipher_key[2] = CONFIG_AES_CIPHER_KEY_WORD2;
cmac_key[2] = CONFIG_AES_CMAC_KEY_WORD2;
cipher_key[3] = CONFIG_AES_CIPHER_KEY_WORD3;
cmac_key[3] = CONFIG_AES_CMAC_KEY_WORD3;

#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)
cipher_key[4] = CONFIG_AES_CIPHER_KEY_WORD4;
cmac_key[4] = CONFIG_AES_CMAC_KEY_WORD4;
cipher_key[5] = CONFIG_AES_CIPHER_KEY_WORD5;
cmac_key[5] = CONFIG_AES_CMAC_KEY_WORD5;
#endif

#if defined(CONFIG_AES_KEY_SIZE_256)
cipher_key[6] = CONFIG_AES_CIPHER_KEY_WORD6;
cmac_key[6] = CONFIG_AES_CMAC_KEY_WORD6;
cipher_key[7] = CONFIG_AES_CIPHER_KEY_WORD7;
cmac_key[7] = CONFIG_AES_CMAC_KEY_WORD7;
#endif
}","[16, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 31, 32, 33, 34, 38, 39, 40, 41]",AT91bootstrap before 3.9.2 does not properly wipe encryption and authentication keys from memory before passing control to a less privileged software component. This can be exploited to disclose these keys and subsequently encrypt and sign the next boot stage (such as the bootloader).
7360,"char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr)
{
for (char *q; p < end; p = q) {
while (*p != '\\' && p != end)
++p;
if (*p != '\\')
break;
++p;
if (p != end)
skip_spaces(&p);

q = p;
while (*q != '(' && *q != '\\' && q != end)
++q;
if (q == p)
continue;

char *name_end = q;


struct arg args[MAX_VALID_NARGS + 1];
int nargs = 0;
for (int i = 0; i <= MAX_VALID_NARGS; ++i)
args[i].start = args[i].end = """";



if (*q == '(') {
++q;
while (1) {
if (q != end)
skip_spaces(&q);






char *r = q;
while (*r != ',' && *r != '\\' && *r != ')' && r != end)
++r;

if (*r == ',') {
push_arg(args, &nargs, q, r);
q = r + 1;
} else {


while (*r != ')' && r != end)
++r;
push_arg(args, &nargs, q, r);
q = r;

if (q != end)
++q;
break;
}
}
}

#define tag(name) (mystrcmp(&p, (name)) && (push_arg(args, &nargs, p, name_end), 1))
#define complex_tag(name) mystrcmp(&p, (name))


if (tag(""xbord"")) {
double val;
if (nargs) {
val = argtod(*args);
val = render_priv->state.border_x * (1 - pwr) + val * pwr;
val = (val < 0) ? 0 : val;
} else
val = render_priv->state.style->Outline;
render_priv->state.border_x = val;
} else if (tag(""ybord"")) {
double val;
if (nargs) {
val = argtod(*args);
val = render_priv->state.border_y * (1 - pwr) + val * pwr;
val = (val < 0) ? 0 : val;
} else
val = render_priv->state.style->Outline;
render_priv->state.border_y = val;
} else if (tag(""xshad"")) {
double val;
if (nargs) {
val = argtod(*args);
val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
} else
val = render_priv->state.style->Shadow;
render_priv->state.shadow_x = val;
} else if (tag(""yshad"")) {
double val;
if (nargs) {
val = argtod(*args);
val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
} else
val = render_priv->state.style->Shadow;
render_priv->state.shadow_y = val;
} else if (tag(""fax"")) {
double val;
if (nargs) {
val = argtod(*args);
render_priv->state.fax =
val * pwr + render_priv->state.fax * (1 - pwr);
} else
render_priv->state.fax = 0.;
} else if (tag(""fay"")) {
double val;
if (nargs) {
val = argtod(*args);
render_priv->state.fay =
val * pwr + render_priv->state.fay * (1 - pwr);
} else
render_priv->state.fay = 0.;
} else if (complex_tag(""iclip"")) {
if (nargs == 4) {
int x0, y0, x1, y1;
x0 = argtoi(args[0]);
y0 = argtoi(args[1]);
x1 = argtoi(args[2]);
y1 = argtoi(args[3]);
render_priv->state.clip_x0 =
render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
render_priv->state.clip_x1 =
render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
render_priv->state.clip_y0 =
render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
render_priv->state.clip_y1 =
render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
render_priv->state.clip_mode = 1;
} else if (!render_priv->state.clip_drawing) {
if (parse_vector_clip(render_priv, args, nargs))
render_priv->state.clip_drawing_mode = 1;
}
} else if (tag(""blur"")) {
double val;
if (nargs) {
val = argtod(*args);
val = render_priv->state.blur * (1 - pwr) + val * pwr;
val = (val < 0) ? 0 : val;
val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
render_priv->state.blur = val;
} else
render_priv->state.blur = 0.0;

} else if (tag(""fscx"")) {
double val;
if (nargs) {
val = argtod(*args) / 100;
val = render_priv->state.scale_x * (1 - pwr) + val * pwr;
val = (val < 0) ? 0 : val;
} else
val = render_priv->state.style->ScaleX;
render_priv->state.scale_x = val;
} else if (tag(""fscy"")) {
double val;
if (nargs) {
val = argtod(*args) / 100;
val = render_priv->state.scale_y * (1 - pwr) + val * pwr;
val = (val < 0) ? 0 : val;
} else
val = render_priv->state.style->ScaleY;
render_priv->state.scale_y = val;
} else if (tag(""fsc"")) {
render_priv->state.scale_x = render_priv->state.style->ScaleX;
render_priv->state.scale_y = render_priv->state.style->ScaleY;
} else if (tag(""fsp"")) {
double val;
if (nargs) {
val = argtod(*args);
render_priv->state.hspacing =
render_priv->state.hspacing * (1 - pwr) + val * pwr;
} else
render_priv->state.hspacing = render_priv->state.style->Spacing;
} else if (tag(""fs"")) {
double val = 0;
if (nargs) {
val = argtod(*args);
if (*args->start == '+' || *args->start == '-')
val = render_priv->state.font_size * (1 + pwr * val / 10);
else
val = render_priv->state.font_size * (1 - pwr) + val * pwr;
}
if (val <= 0)
val = render_priv->state.style->FontSize;
if (render_priv->state.font)
change_font_size(render_priv, val);
} else if (tag(""bord"")) {
double val, xval, yval;
if (nargs) {
val = argtod(*args);
xval = render_priv->state.border_x * (1 - pwr) + val * pwr;
yval = render_priv->state.border_y * (1 - pwr) + val * pwr;
xval = (xval < 0) ? 0 : xval;
yval = (yval < 0) ? 0 : yval;
} else
xval = yval = render_priv->state.style->Outline;
render_priv->state.border_x = xval;
render_priv->state.border_y = yval;
} else if (complex_tag(""move"")) {
double x1, x2, y1, y2;
long long t1, t2, delta_t, t;
double x, y;
double k;
if (nargs == 4 || nargs == 6) {
x1 = argtod(args[0]);
y1 = argtod(args[1]);
x2 = argtod(args[2]);
y2 = argtod(args[3]);
t1 = t2 = 0;
if (nargs == 6) {
t1 = argtoll(args[4]);
t2 = argtoll(args[5]);
if (t1 > t2) {
long long tmp = t2;
t2 = t1;
t1 = tmp;
}
}
} else
continue;
if (t1 <= 0 && t2 <= 0) {
t1 = 0;
t2 = render_priv->state.event->Duration;
}
delta_t = t2 - t1;
t = render_priv->time - render_priv->state.event->Start;
if (t <= t1)
k = 0.;
else if (t >= t2)
k = 1.;
else
k = ((double) (t - t1)) / delta_t;
x = k * (x2 - x1) + x1;
y = k * (y2 - y1) + y1;
if (render_priv->state.evt_type != EVENT_POSITIONED) {
render_priv->state.pos_x = x;
render_priv->state.pos_y = y;
render_priv->state.detect_collisions = 0;
render_priv->state.evt_type = EVENT_POSITIONED;
}
} else if (tag(""frx"")) {
double val;
if (nargs) {
val = argtod(*args);
val *= M_PI / 180;
render_priv->state.frx =
val * pwr + render_priv->state.frx * (1 - pwr);
} else
render_priv->state.frx = 0.;
} else if (tag(""fry"")) {
double val;
if (nargs) {
val = argtod(*args);
val *= M_PI / 180;
render_priv->state.fry =
val * pwr + render_priv->state.fry * (1 - pwr);
} else
render_priv->state.fry = 0.;
} else if (tag(""frz"") || tag(""fr"")) {
double val;
if (nargs) {
val = argtod(*args);
val *= M_PI / 180;
render_priv->state.frz =
val * pwr + render_priv->state.frz * (1 - pwr);
} else
render_priv->state.frz =
M_PI * render_priv->state.style->Angle / 180.;
} else if (tag(""fn"")) {
char *family;
char *start = args->start;
if (nargs && strncmp(start, ""0"", args->end - start)) {
skip_spaces(&start);
family = strndup(start, args->end - start);
} else
family = strdup(render_priv->state.style->FontName);
free(render_priv->state.family);
render_priv->state.family = family;
update_font(render_priv);
} else if (tag(""alpha"")) {
int i;
if (nargs) {
int32_t a = parse_alpha_tag(args->start);
for (i = 0; i < 4; ++i)
change_alpha(&render_priv->state.c[i], a, pwr);
} else {
change_alpha(&render_priv->state.c[0],
_a(render_priv->state.style->PrimaryColour), 1);
change_alpha(&render_priv->state.c[1],
_a(render_priv->state.style->SecondaryColour), 1);
change_alpha(&render_priv->state.c[2],
_a(render_priv->state.style->OutlineColour), 1);
change_alpha(&render_priv->state.c[3],
_a(render_priv->state.style->BackColour), 1);
}

} else if (tag(""an"")) {
int val = argtoi(*args);
if ((render_priv->state.parsed_tags & PARSED_A) == 0) {
if (val >= 1 && val <= 9)
render_priv->state.alignment = numpad2align(val);
else
render_priv->state.alignment =
render_priv->state.style->Alignment;
render_priv->state.parsed_tags |= PARSED_A;
}
} else if (tag(""a"")) {
int val = argtoi(*args);
if ((render_priv->state.parsed_tags & PARSED_A) == 0) {
if (val >= 1 && val <= 11)


render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;
else
render_priv->state.alignment =
render_priv->state.style->Alignment;
render_priv->state.parsed_tags |= PARSED_A;
}
} else if (complex_tag(""pos"")) {
double v1, v2;
if (nargs == 2) {
v1 = argtod(args[0]);
v2 = argtod(args[1]);
} else
continue;
if (render_priv->state.evt_type == EVENT_POSITIONED) {
ass_msg(render_priv->library, MSGL_V, ""Subtitle has a new \\pos ""
""after \\move or \\pos, ignoring"");
} else {
render_priv->state.evt_type = EVENT_POSITIONED;
render_priv->state.detect_collisions = 0;
render_priv->state.pos_x = v1;
render_priv->state.pos_y = v2;
}
} else if (complex_tag(""fade"") || complex_tag(""fad"")) {
int a1, a2, a3;
long long t1, t2, t3, t4;
if (nargs == 2) {

a1 = 0xFF;
a2 = 0;
a3 = 0xFF;
t1 = -1;
t2 = argtoll(args[0]);
t3 = argtoll(args[1]);
t4 = -1;
} else if (nargs == 7) {

a1 = argtoi(args[0]);
a2 = argtoi(args[1]);
a3 = argtoi(args[2]);
t1 = argtoll(args[3]);
t2 = argtoll(args[4]);
t3 = argtoll(args[5]);
t4 = argtoll(args[6]);
} else
continue;
if (t1 == -1 && t4 == -1) {
t1 = 0;
t4 = render_priv->state.event->Duration;
t3 = t4 - t3;
}
if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {
render_priv->state.fade =
interpolate_alpha(render_priv->time -
render_priv->state.event->Start, t1, t2,
t3, t4, a1, a2, a3);
render_priv->state.parsed_tags |= PARSED_FADE;
}
} else if (complex_tag(""org"")) {
double v1, v2;
if (nargs == 2) {
v1 = argtod(args[0]);
v2 = argtod(args[1]);
} else
continue;
if (!render_priv->state.have_origin) {
render_priv->state.org_x = v1;
render_priv->state.org_y = v2;
render_priv->state.have_origin = 1;
render_priv->state.detect_collisions = 0;
}
} else if (complex_tag(""t"")) {
double accel;
int cnt = nargs - 1;
long long t1, t2, t, delta_t;
double k;
if (cnt == 3) {
t1 = argtoll(args[0]);
t2 = argtoll(args[1]);
accel = argtod(args[2]);
} else if (cnt == 2) {
t1 = argtoll(args[0]);
t2 = argtoll(args[1]);
accel = 1.;
} else if (cnt == 1) {
t1 = 0;
t2 = 0;
accel = argtod(args[0]);
} else if (cnt == 0) {
t1 = 0;
t2 = 0;
accel = 1.;
} else
continue;
render_priv->state.detect_collisions = 0;
if (t2 == 0)
t2 = render_priv->state.event->Duration;
delta_t = t2 - t1;
t = render_priv->time - render_priv->state.event->Start;
if (t <= t1)
k = 0.;
else if (t >= t2)
k = 1.;
else {
assert(delta_t != 0.);
k = pow(((double) (t - t1)) / delta_t, accel);
}
p = args[cnt].start;
p = parse_tags(render_priv, p, args[cnt].end, k);
} else if (complex_tag(""clip"")) {
if (nargs == 4) {
int x0, y0, x1, y1;
x0 = argtoi(args[0]);
y0 = argtoi(args[1]);
x1 = argtoi(args[2]);
y1 = argtoi(args[3]);
render_priv->state.clip_x0 =
render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
render_priv->state.clip_x1 =
render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
render_priv->state.clip_y0 =
render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
render_priv->state.clip_y1 =
render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
render_priv->state.clip_mode = 0;
} else if (!render_priv->state.clip_drawing) {
if (parse_vector_clip(render_priv, args, nargs))
render_priv->state.clip_drawing_mode = 0;
}
} else if (tag(""c"") || tag(""1c"")) {
if (nargs) {
uint32_t val = parse_color_tag(args->start);
change_color(&render_priv->state.c[0], val, pwr);
} else
change_color(&render_priv->state.c[0],
render_priv->state.style->PrimaryColour, 1);
} else if (tag(""2c"")) {
if (nargs) {
uint32_t val = parse_color_tag(args->start);
change_color(&render_priv->state.c[1], val, pwr);
} else
change_color(&render_priv->state.c[1],
render_priv->state.style->SecondaryColour, 1);
} else if (tag(""3c"")) {
if (nargs) {
uint32_t val = parse_color_tag(args->start);
change_color(&render_priv->state.c[2], val, pwr);
} else
change_color(&render_priv->state.c[2],
render_priv->state.style->OutlineColour, 1);
} else if (tag(""4c"")) {
if (nargs) {
uint32_t val = parse_color_tag(args->start);
change_color(&render_priv->state.c[3], val, pwr);
} else
change_color(&render_priv->state.c[3],
render_priv->state.style->BackColour, 1);
} else if (tag(""1a"")) {
if (nargs) {
uint32_t val = parse_alpha_tag(args->start);
change_alpha(&render_priv->state.c[0], val, pwr);
} else
change_alpha(&render_priv->state.c[0],
_a(render_priv->state.style->PrimaryColour), 1);
} else if (tag(""2a"")) {
if (nargs) {
uint32_t val = parse_alpha_tag(args->start);
change_alpha(&render_priv->state.c[1], val, pwr);
} else
change_alpha(&render_priv->state.c[1],
_a(render_priv->state.style->SecondaryColour), 1);
} else if (tag(""3a"")) {
if (nargs) {
uint32_t val = parse_alpha_tag(args->start);
change_alpha(&render_priv->state.c[2], val, pwr);
} else
change_alpha(&render_priv->state.c[2],
_a(render_priv->state.style->OutlineColour), 1);
} else if (tag(""4a"")) {
if (nargs) {
uint32_t val = parse_alpha_tag(args->start);
change_alpha(&render_priv->state.c[3], val, pwr);
} else
change_alpha(&render_priv->state.c[3],
_a(render_priv->state.style->BackColour), 1);
} else if (tag(""r"")) {
if (nargs) {
int len = args->end - args->start;
reset_render_context(render_priv,
lookup_style_strict(render_priv->track, args->start, len));
} else
reset_render_context(render_priv, NULL);
} else if (tag(""be"")) {
double dval;
if (nargs) {
int val;
dval = argtod(*args);

val = (int) (render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);

val = (val < 0) ? 0 : val;
val = (val > MAX_BE) ? MAX_BE : val;
render_priv->state.be = val;
} else
render_priv->state.be = 0;
} else if (tag(""b"")) {
int val = argtoi(*args);
if (!nargs || !(val == 0 || val == 1 || val >= 100))
val = render_priv->state.style->Bold;
render_priv->state.bold = val;
update_font(render_priv);
} else if (tag(""i"")) {
int val = argtoi(*args);
if (!nargs || !(val == 0 || val == 1))
val = render_priv->state.style->Italic;
render_priv->state.italic = val;
update_font(render_priv);
} else if (tag(""kf"") || tag(""K"")) {
double val = 100;
if (nargs)
val = argtod(*args);
render_priv->state.effect_type = EF_KARAOKE_KF;
if (render_priv->state.effect_timing)
render_priv->state.effect_skip_timing +=
render_priv->state.effect_timing;
render_priv->state.effect_timing = val * 10;
} else if (tag(""ko"")) {
double val = 100;
if (nargs)
val = argtod(*args);
render_priv->state.effect_type = EF_KARAOKE_KO;
if (render_priv->state.effect_timing)
render_priv->state.effect_skip_timing +=
render_priv->state.effect_timing;
render_priv->state.effect_timing = val * 10;
} else if (tag(""k"")) {
double val = 100;
if (nargs)
val = argtod(*args);
render_priv->state.effect_type = EF_KARAOKE;
if (render_priv->state.effect_timing)
render_priv->state.effect_skip_timing +=
render_priv->state.effect_timing;
render_priv->state.effect_timing = val * 10;
} else if (tag(""shad"")) {
double val, xval, yval;
if (nargs) {
val = argtod(*args);
xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;

xval = (xval < 0) ? 0 : xval;
yval = (yval < 0) ? 0 : yval;
} else
xval = yval = render_priv->state.style->Shadow;
render_priv->state.shadow_x = xval;
render_priv->state.shadow_y = yval;
} else if (tag(""s"")) {
int val = argtoi(*args);
if (!nargs || !(val == 0 || val == 1))
val = render_priv->state.style->StrikeOut;
if (val)
render_priv->state.flags |= DECO_STRIKETHROUGH;
else
render_priv->state.flags &= ~DECO_STRIKETHROUGH;
} else if (tag(""u"")) {
int val = argtoi(*args);
if (!nargs || !(val == 0 || val == 1))
val = render_priv->state.style->Underline;
if (val)
render_priv->state.flags |= DECO_UNDERLINE;
else
render_priv->state.flags &= ~DECO_UNDERLINE;
} else if (tag(""pbo"")) {
double val = argtod(*args);
render_priv->state.pbo = val;
} else if (tag(""p"")) {
int val = argtoi(*args);
val = (val < 0) ? 0 : val;
render_priv->state.drawing_scale = val;
} else if (tag(""q"")) {
int val = argtoi(*args);
if (!nargs || !(val >= 0 && val <= 3))
val = render_priv->track->WrapStyle;
render_priv->state.wrap_style = val;
} else if (tag(""fe"")) {
int val;
if (nargs)
val = argtoi(*args);
else
val = render_priv->state.style->Encoding;
render_priv->state.font_encoding = val;
}
}

return p;
}",[421],Stack overflow in the parse_tag function in libass/ass_parse.c in libass before 0.15.0 allows remote attackers to cause a denial of service or remote code execution via a crafted file.
7836,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const TensorShape& input_shape = input.shape();

const Tensor& out_backprop = context->input(2);
const TensorShape& out_backprop_shape = out_backprop.shape();

TensorShape filter_shape;
if (takes_shape_) {
const Tensor& filter_sizes = context->input(1);
OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(
filter_sizes.vec<int32>(), &filter_shape));
} else {
filter_shape = context->input(1).shape();
}

ConvBackpropDimensions dims;
OP_REQUIRES_OK(context,
ConvBackpropComputeDimensions(
""Conv3DBackpropFilterOp"",                      3,
input_shape, filter_shape, out_backprop_shape, stride_,
padding_, data_format_, &dims));

Tensor* filter_backprop;
OP_REQUIRES_OK(context,
context->allocate_output(0, filter_shape, &filter_backprop));

if (input_shape.num_elements() == 0) {
filter_backprop->template flat<T>().setZero();
return;
}

int64 top_pad_planes, bottom_pad_planes;
int64 top_pad_rows, bottom_pad_rows;
int64 left_pad_cols, right_pad_cols;

OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
dims.spatial_dims[0].input_size,
dims.spatial_dims[0].filter_size,
dims.spatial_dims[0].stride, padding_,
&dims.spatial_dims[0].output_size,
&top_pad_planes, &bottom_pad_planes));
OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
dims.spatial_dims[1].input_size,
dims.spatial_dims[1].filter_size,
dims.spatial_dims[1].stride, padding_,
&dims.spatial_dims[1].output_size,
&top_pad_rows, &bottom_pad_rows));
OP_REQUIRES_OK(context, GetWindowedOutputSizeVerbose(
dims.spatial_dims[2].input_size,
dims.spatial_dims[2].filter_size,
dims.spatial_dims[2].stride, padding_,
&dims.spatial_dims[2].output_size,
&left_pad_cols, &right_pad_cols));





const int64 filter_total_size =
dims.spatial_dims[0].filter_size * dims.spatial_dims[1].filter_size *
dims.spatial_dims[2].filter_size * dims.in_depth;

const int64 output_image_size = dims.spatial_dims[0].output_size *
dims.spatial_dims[1].output_size *
dims.spatial_dims[2].output_size;






const auto cache_sizes = Eigen::internal::CacheSizes();
const ptrdiff_t l3_cache_size = cache_sizes.m_l3;




const size_t target_working_set_size = l3_cache_size / sizeof(T);

const int64 size_A = output_image_size * filter_total_size;

const int64 size_B = output_image_size * dims.out_depth;

const int64 size_C = filter_total_size * dims.out_depth;

const int64 work_unit_size = size_A + size_B + size_C;

const size_t shard_size =
(target_working_set_size + work_unit_size - 1) / work_unit_size;


int64 total_tensor_elements = input_shape.num_elements() +
filter_shape.num_elements() +
out_backprop_shape.num_elements();


TensorShape col_buffer_shape = {static_cast<int64>(shard_size),
static_cast<int64>(output_image_size),
static_cast<int64>(filter_total_size)};
int64 col_buffer_elements = col_buffer_shape.num_elements();



int64 col_buffer_overhead = col_buffer_elements / total_tensor_elements;
if (col_buffer_overhead > kMaxTempAllocationOverhead) {
VLOG(2) << ""Fallback on Eigen implementation of Conv3DBackpropFilterOp: ""
""col_buffer_overhead=""
<< col_buffer_overhead;

functor::CuboidConvolutionBackwardFilter<Device, T>()(
context->eigen_device<Device>(),
filter_backprop->tensor<T, 5>(),
input.tensor<T, 5>(),
out_backprop.tensor<T, 5>(),
static_cast<int>(dims.spatial_dims[0].stride),
static_cast<int>(dims.spatial_dims[1].stride),
static_cast<int>(dims.spatial_dims[2].stride));

return;
}

Tensor col_buffer;
OP_REQUIRES_OK(context,
context->allocate_temp(DataTypeToEnum<T>::value,
col_buffer_shape, &col_buffer));


const int64 input_offset = dims.spatial_dims[0].input_size *
dims.spatial_dims[1].input_size *
dims.spatial_dims[2].input_size * dims.in_depth;

const int64 output_offset =
dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size *
dims.spatial_dims[2].output_size * dims.out_depth;

const T* input_data = input.template flat<T>().data();
T* col_buffer_data = col_buffer.template flat<T>().data();
const T* out_backprop_data = out_backprop.template flat<T>().data();
T* filter_backprop_data = filter_backprop->template flat<T>().data();

typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
TensorMap;
typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,
Eigen::Unaligned>
ConstTensorMap;

TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);
C.setZero();


Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;
contract_dims[0].first = 0;
contract_dims[0].second = 0;

auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());

for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {
const int shard_limit =
std::min(static_cast<int>(shard_size),
static_cast<int>(dims.batch_size) - image_id);

auto shard = [&input_data, &col_buffer_data, &dims, &top_pad_planes,
&top_pad_rows, &left_pad_cols, &bottom_pad_planes,
&bottom_pad_rows, &right_pad_cols, &input_offset,
&size_A](int64 start, int64 limit) {
for (int shard_id = start; shard_id < limit; ++shard_id) {
const T* input_data_shard = input_data + shard_id * input_offset;
T* col_data_shard = col_buffer_data + shard_id * size_A;



Im2col<T>(input_data_shard, dims.in_depth,

dims.spatial_dims[0].input_size,
dims.spatial_dims[1].input_size,
dims.spatial_dims[2].input_size,

dims.spatial_dims[0].filter_size,
dims.spatial_dims[1].filter_size,
dims.spatial_dims[2].filter_size,

top_pad_planes, top_pad_rows, left_pad_cols,
bottom_pad_planes, bottom_pad_rows, right_pad_cols,

dims.spatial_dims[0].stride,
dims.spatial_dims[1].stride,
dims.spatial_dims[2].stride,
col_data_shard);
}
};
Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,
size_A, shard);

ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,
filter_total_size);
ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,
dims.out_depth);


C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);

input_data += input_offset * shard_limit;
out_backprop_data += output_offset * shard_limit;
}
}",[17],"TensorFlow is an end-to-end open source platform for machine learning. Missing validation between arguments to `tf.raw_ops.Conv3DBackprop*` operations can result in heap buffer overflows. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/4814fafb0ca6b5ab58a09411523b2193fed23fed/tensorflow/core/kernels/conv_grad_shape_utils.cc#L94-L153) assumes that the `input`, `filter_sizes` and `out_backprop` tensors have the same shape, as they are accessed in parallel. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
204935," void OneClickSigninHelper::DidStopLoading(
     content::RenderViewHost* render_view_host) {
   content::WebContents* contents = web_contents();
   const GURL url = contents->GetURL();
   Profile* profile =
       Profile::FromBrowserContext(contents->GetBrowserContext());
   VLOG(1) << ""OneClickSigninHelper::DidStopLoading: url="" << url.spec();
 
   if (!error_message_.empty() && auto_accept_ == AUTO_ACCEPT_EXPLICIT) {
     VLOG(1) << ""OneClickSigninHelper::DidStopLoading: error="" << error_message_;
     RemoveCurrentHistoryItem(contents);
     Browser* browser = chrome::FindBrowserWithWebContents(contents);
 
     RedirectToNtpOrAppsPage(web_contents(), source_);
     ShowSigninErrorBubble(browser, error_message_);
     CleanTransientState();
     return;
   }
 
   if (AreWeShowingSignin(url, source_, email_)) {
     if (!showing_signin_) {
       if (source_ == SyncPromoUI::SOURCE_UNKNOWN)
         LogOneClickHistogramValue(one_click_signin::HISTOGRAM_SHOWN);
       else
         LogHistogramValue(source_, one_click_signin::HISTOGRAM_SHOWN);
     }
     showing_signin_ = true;
   }
 
   GURL::Replacements replacements;
   replacements.ClearQuery();
   const bool continue_url_match = (
       continue_url_.is_valid() &&
       url.ReplaceComponents(replacements) ==
         continue_url_.ReplaceComponents(replacements));
 
   if (continue_url_match)
     RemoveCurrentHistoryItem(contents);
 
   if (email_.empty()) {
     VLOG(1) << ""OneClickSigninHelper::DidStopLoading: nothing to do"";
     if (continue_url_match && auto_accept_ == AUTO_ACCEPT_EXPLICIT)
       RedirectToSignin();
     std::string unused_value;
     if (net::GetValueForKeyInQuery(url, ""ntp"", &unused_value)) {
       SyncPromoUI::SetUserSkippedSyncPromo(profile);
       RedirectToNtpOrAppsPage(web_contents(), source_);
     }
 
     if (!continue_url_match && !IsValidGaiaSigninRedirectOrResponseURL(url) &&
         ++untrusted_navigations_since_signin_visit_ > kMaxNavigationsSince) {
       CleanTransientState();
     }
 
     return;
   }
 
   bool force_same_tab_navigation = false;
 
   if (!continue_url_match && IsValidGaiaSigninRedirectOrResponseURL(url))
     return;
 
   if (auto_accept_ == AUTO_ACCEPT_EXPLICIT) {
     DCHECK(source_ != SyncPromoUI::SOURCE_UNKNOWN);
     if (!continue_url_match) {
       VLOG(1) << ""OneClickSigninHelper::DidStopLoading: invalid url='""
               << url.spec()
               << ""' expected continue url="" << continue_url_;
       CleanTransientState();
       return;
     }
 
     SyncPromoUI::Source source =
         SyncPromoUI::GetSourceForSyncPromoURL(url);
     if (source != source_) {
       original_source_ = source_;
       source_ = source;
       force_same_tab_navigation = source == SyncPromoUI::SOURCE_SETTINGS;
       switched_to_advanced_ = source == SyncPromoUI::SOURCE_SETTINGS;
     }
   }
 
   Browser* browser = chrome::FindBrowserWithWebContents(contents);
 
   VLOG(1) << ""OneClickSigninHelper::DidStopLoading: signin is go.""
           << "" auto_accept="" << auto_accept_
           << "" source="" << source_;
 
   switch (auto_accept_) {
     case AUTO_ACCEPT_NONE:
       if (showing_signin_)
         LogOneClickHistogramValue(one_click_signin::HISTOGRAM_DISMISSED);
       break;
     case AUTO_ACCEPT_ACCEPTED:
       LogOneClickHistogramValue(one_click_signin::HISTOGRAM_ACCEPTED);
       LogOneClickHistogramValue(one_click_signin::HISTOGRAM_WITH_DEFAULTS);
       SigninManager::DisableOneClickSignIn(profile);
       StartSync(StartSyncArgs(profile, browser, auto_accept_,
                               session_index_, email_, password_,
                               false  ,
                               true  , source_),
                 OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS);
       break;
     case AUTO_ACCEPT_CONFIGURE:
        LogOneClickHistogramValue(one_click_signin::HISTOGRAM_ACCEPTED);
        LogOneClickHistogramValue(one_click_signin::HISTOGRAM_WITH_ADVANCED);
        SigninManager::DisableOneClickSignIn(profile);
        
        
        StartSync(
            StartSyncArgs(profile, browser, auto_accept_, session_index_, email_,
                          password_, false  ,
                        false  , source_),
                         true  , source_),
            OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST);
        break;
      case AUTO_ACCEPT_EXPLICIT: {
       if (switched_to_advanced_) {
         LogHistogramValue(original_source_,
                           one_click_signin::HISTOGRAM_WITH_ADVANCED);
         LogHistogramValue(original_source_,
                           one_click_signin::HISTOGRAM_ACCEPTED);
       } else {
         LogHistogramValue(source_, one_click_signin::HISTOGRAM_ACCEPTED);
         LogHistogramValue(source_, one_click_signin::HISTOGRAM_WITH_DEFAULTS);
       }
       OneClickSigninSyncStarter::StartSyncMode start_mode =
           source_ == SyncPromoUI::SOURCE_SETTINGS ?
               OneClickSigninSyncStarter::CONFIGURE_SYNC_FIRST :
               OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS;
 
       std::string last_email =
           profile->GetPrefs()->GetString(prefs::kGoogleServicesLastUsername);
 
       if (!last_email.empty() && !gaia::AreEmailsSame(last_email, email_)) {
 
         ConfirmEmailDialogDelegate::AskForConfirmation(
             contents,
             last_email,
             email_,
             base::Bind(
                 &StartExplicitSync,
                 StartSyncArgs(profile, browser, auto_accept_,
                               session_index_, email_, password_,
                               force_same_tab_navigation,
                               false  , source_),
                 contents,
                 start_mode));
       } else {
         StartSync(
             StartSyncArgs(profile, browser, auto_accept_, session_index_,
                           email_, password_, force_same_tab_navigation,
                           untrusted_confirmation_required_, source_),
             start_mode);
 
         RedirectToNtpOrAppsPageIfNecessary(web_contents(), source_);
       }
 
       if (source_ == SyncPromoUI::SOURCE_SETTINGS &&
           SyncPromoUI::GetSourceForSyncPromoURL(continue_url_) ==
           SyncPromoUI::SOURCE_WEBSTORE_INSTALL) {
         redirect_url_ = continue_url_;
         ProfileSyncService* sync_service =
           ProfileSyncServiceFactory::GetForProfile(profile);
         if (sync_service)
           sync_service->AddObserver(this);
       }
       break;
     }
     case AUTO_ACCEPT_REJECTED_FOR_PROFILE:
       AddEmailToOneClickRejectedList(profile, email_);
       LogOneClickHistogramValue(one_click_signin::HISTOGRAM_REJECTED);
       break;
     default:
       NOTREACHED() << ""Invalid auto_accept="" << auto_accept_;
       break;
   }
 
   CleanTransientState();
 }","[108, 109, 114, 113]","Google Chrome before 28.0.1500.71 does not properly determine the circumstances in which a renderer process can be considered a trusted process for sign-in and subsequent sync operations, which makes it easier for remote attackers to conduct phishing attacks via a crafted web site."
202470," int libevt_record_values_read_event(
      libevt_record_values_t *record_values,
      uint8_t *record_data,
      size_t record_data_size,
      uint8_t strict_mode,
      libcerror_error_t **error )
 {
 	static char *function      = ""libevt_record_values_read_event"";
 	size_t record_data_offset  = 0;
 	size_t strings_data_offset = 0;
 	ssize_t value_data_size    = 0;
 	uint32_t data_offset       = 0;
 	uint32_t data_size         = 0;
 	uint32_t members_data_size = 0;
 	uint32_t size              = 0;
 	uint32_t size_copy         = 0;
 	uint32_t strings_offset    = 0;
 	uint32_t strings_size      = 0;
 	uint32_t user_sid_offset   = 0;
 	uint32_t user_sid_size     = 0;
 
 #if defined( HAVE_DEBUG_OUTPUT )
 	uint32_t value_32bit       = 0;
 	uint16_t value_16bit       = 0;
 #endif
 
 	if( record_values == NULL )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
 		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
 		 ""%s: invalid record values."",
 		 function );
 
 		return( -1 );
 	}
 	if( record_data == NULL )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
 		 LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE,
 		 ""%s: invalid record data."",
 		 function );
 
 		return( -1 );
 	}
 	if( record_data_size > (size_t) SSIZE_MAX )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_ARGUMENTS,
 		 LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM,
 		 ""%s: invalid record data size value exceeds maximum."",
 		 function );
 
 		return( -1 );
 	}
 	if( record_data_size < ( sizeof( evt_record_event_header_t ) + 4 ) )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 		 ""%s: record data size value out of bounds."",
 		 function );
 
 		return( -1 );
 	}
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->size,
 	 size );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->record_number,
 	 record_values->number );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->creation_time,
 	 record_values->creation_time );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->written_time,
 	 record_values->written_time );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->event_identifier,
 	 record_values->event_identifier );
 
 	byte_stream_copy_to_uint16_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->event_type,
 	 record_values->event_type );
 
 	byte_stream_copy_to_uint16_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->event_category,
 	 record_values->event_category );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->strings_offset,
 	 strings_offset );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->user_sid_size,
 	 user_sid_size );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->user_sid_offset,
 	 user_sid_offset );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->data_size,
 	 data_size );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 ( (evt_record_event_header_t *) record_data )->data_offset,
 	 data_offset );
 
 	byte_stream_copy_to_uint32_little_endian(
 	 &( record_data[ record_data_size - 4 ] ),
 	 size_copy );
 
 #if defined( HAVE_DEBUG_OUTPUT )
 	if( libcnotify_verbose != 0 )
 	{
 		libcnotify_printf(
 		 ""%s: size\t\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 size );
 
 		libcnotify_printf(
 		 ""%s: signature\t\t\t\t: %c%c%c%c\n"",
 		 function,
 		 ( (evt_record_event_header_t *) record_data )->signature[ 0 ],
 		 ( (evt_record_event_header_t *) record_data )->signature[ 1 ],
 		 ( (evt_record_event_header_t *) record_data )->signature[ 2 ],
 		 ( (evt_record_event_header_t *) record_data )->signature[ 3 ] );
 
 		libcnotify_printf(
 		 ""%s: record number\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 record_values->number );
 
 		if( libevt_debug_print_posix_time_value(
 		     function,
 		     ""creation time\t\t\t\t"",
 		     ( (evt_record_event_header_t *) record_data )->creation_time,
 		     4,
 		     LIBFDATETIME_ENDIAN_LITTLE,
 		     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,
 		     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
 			 ""%s: unable to print POSIX time value."",
 			 function );
 
 			goto on_error;
 		}
 		if( libevt_debug_print_posix_time_value(
 		     function,
 		     ""written time\t\t\t\t"",
 		     ( (evt_record_event_header_t *) record_data )->written_time,
 		     4,
 		     LIBFDATETIME_ENDIAN_LITTLE,
 		     LIBFDATETIME_POSIX_TIME_VALUE_TYPE_SECONDS_32BIT_SIGNED,
 		     LIBFDATETIME_STRING_FORMAT_TYPE_CTIME | LIBFDATETIME_STRING_FORMAT_FLAG_DATE_TIME,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
 			 ""%s: unable to print POSIX time value."",
 			 function );
 
 			goto on_error;
 		}
 		libcnotify_printf(
 		 ""%s: event identifier\t\t\t: 0x%08"" PRIx32 ""\n"",
 		 function,
 		 record_values->event_identifier );
 
 		libcnotify_printf(
 		 ""%s: event identifier: code\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 record_values->event_identifier & 0x0000ffffUL );
 
 		libcnotify_printf(
 		 ""%s: event identifier: facility\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 ( record_values->event_identifier & 0x0fff0000UL ) >> 16 );
 
 		libcnotify_printf(
 		 ""%s: event identifier: reserved\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 ( record_values->event_identifier & 0x10000000UL ) >> 28 );
 
 		libcnotify_printf(
 		 ""%s: event identifier: customer flags\t: %"" PRIu32 ""\n"",
 		 function,
 		 ( record_values->event_identifier & 0x20000000UL ) >> 29 );
 
 		libcnotify_printf(
 		 ""%s: event identifier: severity\t\t: %"" PRIu32 "" ("",
 		 function,
 		 ( record_values->event_identifier & 0xc0000000UL ) >> 30 );
 		libevt_debug_print_event_identifier_severity(
 		 record_values->event_identifier );
 		libcnotify_printf(
 		 "")\n"" );
 
 		libcnotify_printf(
 		 ""%s: event type\t\t\t\t: %"" PRIu16 "" ("",
 		 function,
 		 record_values->event_type );
 		libevt_debug_print_event_type(
 		 record_values->event_type );
 		libcnotify_printf(
 		 "")\n"" );
 
 		byte_stream_copy_to_uint16_little_endian(
 		 ( (evt_record_event_header_t *) record_data )->number_of_strings,
 		 value_16bit );
 		libcnotify_printf(
 		 ""%s: number of strings\t\t\t: %"" PRIu16 ""\n"",
 		 function,
 		 value_16bit );
 
 		libcnotify_printf(
 		 ""%s: event category\t\t\t\t: %"" PRIu16 ""\n"",
 		 function,
 		 record_values->event_category );
 
 		byte_stream_copy_to_uint16_little_endian(
 		 ( (evt_record_event_header_t *) record_data )->event_flags,
 		 value_16bit );
 		libcnotify_printf(
 		 ""%s: event flags\t\t\t\t: 0x%04"" PRIx16 ""\n"",
 		 function,
 		 value_16bit );
 
 		byte_stream_copy_to_uint32_little_endian(
 		 ( (evt_record_event_header_t *) record_data )->closing_record_number,
 		 value_32bit );
 		libcnotify_printf(
 		 ""%s: closing record values number\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 value_32bit );
 
 		libcnotify_printf(
 		 ""%s: strings offset\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 strings_offset );
 
 		libcnotify_printf(
 		 ""%s: user security identifier (SID) size\t: %"" PRIu32 ""\n"",
 		 function,
 		 user_sid_size );
 
 		libcnotify_printf(
 		 ""%s: user security identifier (SID) offset\t: %"" PRIu32 ""\n"",
 		 function,
 		 user_sid_offset );
 
 		libcnotify_printf(
 		 ""%s: data size\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 data_size );
 
 		libcnotify_printf(
 		 ""%s: data offset\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 data_offset );
 	}
 #endif
 	record_data_offset = sizeof( evt_record_event_header_t );
 
 	if( ( user_sid_offset == 0 )
 	 && ( user_sid_size != 0 ) )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 		 ""%s: user SID offset or size value out of bounds."",
 		 function );
 
 		goto on_error;
 	}
 	if( user_sid_offset != 0 )
 	{
 		if( ( (size_t) user_sid_offset < record_data_offset )
 		 || ( (size_t) user_sid_offset >= ( record_data_size - 4 ) ) )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: user SID offset value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
 		if( user_sid_size != 0 )
 		{
 			if( (size_t) ( user_sid_offset + user_sid_size ) > ( record_data_size - 4 ) )
 			{
 				libcerror_error_set(
 				 error,
 				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 				 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 				 ""%s: user SID size value out of bounds."",
 				 function );
 
 				goto on_error;
 			}
 		}
 	}
 	 
 	if( ( (size_t) strings_offset < user_sid_offset )
 	 || ( (size_t) strings_offset >= ( record_data_size - 4 ) ) )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 		 ""%s: strings offset value out of bounds."",
 		 function );
 
 		goto on_error;
 	}
 	if( ( (size_t) data_offset < strings_offset )
 	 || ( (size_t) data_offset >= ( record_data_size - 4 ) ) )
 	{
 		if( data_size != 0 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: data offset value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
 		data_offset = (uint32_t) record_data_size - 4;
 	}
 	if( ( (size_t) strings_offset >= ( record_data_size - 4 ) )
 	 && ( strings_offset != data_offset ) )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 		 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 		 ""%s: strings offset value out of bounds."",
 		 function );
 
 		goto on_error;
 	}
 	if( strings_offset != 0 )
 	{
 		if( strings_offset < record_data_offset )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: strings offset value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
 	}
 	if( user_sid_offset != 0 )
 	{
 		members_data_size = user_sid_offset - (uint32_t) record_data_offset;
 	}
 	else if( strings_offset != 0 )
 	{
 		members_data_size = strings_offset - (uint32_t) record_data_offset;
 	}
 	if( strings_offset != 0 )
 	{
 		strings_size = data_offset - strings_offset;
 	}
 	if( data_size != 0 )
 	{
 		if( (size_t) ( data_offset + data_size ) > ( record_data_size - 4 ) )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: data size value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
 	}
 	if( members_data_size != 0 )
 	{
 #if defined( HAVE_DEBUG_OUTPUT )
 		if( libcnotify_verbose != 0 )
 		{
 			libcnotify_printf(
 			 ""%s: members data:\n"",
 			 function );
 			libcnotify_print_data(
 			 &( record_data[ record_data_offset ] ),
 			 members_data_size,
 			 LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );
 		}
 #endif
 		if( libfvalue_value_type_initialize(
 		     &( record_values->source_name ),
 		     LIBFVALUE_VALUE_TYPE_STRING_UTF16,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
 			 ""%s: unable to create source name value."",
 			 function );
 
 			goto on_error;
 		}
 		value_data_size = libfvalue_value_type_set_data_string(
 		                   record_values->source_name,
 		                   &( record_data[ record_data_offset ] ),
 		                   members_data_size,
 		                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,
 		                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,
 		                   error );
 
 		if( value_data_size == -1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
 			 ""%s: unable to set data of source name value."",
 			 function );
 
 			goto on_error;
 		}
 #if defined( HAVE_DEBUG_OUTPUT )
 		if( libcnotify_verbose != 0 )
 		{
 			libcnotify_printf(
 			 ""%s: source name\t\t\t\t: "",
 			 function );
 
 			if( libfvalue_value_print(
 			     record_values->source_name,
 			     0,
 			     0,
 			     error ) != 1 )
 			{
 				libcerror_error_set(
 				 error,
 				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 				 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
 				 ""%s: unable to print source name value."",
 				 function );
 
 				goto on_error;
 			}
 			libcnotify_printf(
 			 ""\n"" );
 		}
 #endif
 		record_data_offset += value_data_size;
 		members_data_size  -= (uint32_t) value_data_size;
 
 		if( libfvalue_value_type_initialize(
 		     &( record_values->computer_name ),
 		     LIBFVALUE_VALUE_TYPE_STRING_UTF16,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
 			 ""%s: unable to create computer name value."",
 			 function );
 
 			goto on_error;
 		}
 		value_data_size = libfvalue_value_type_set_data_string(
 		                   record_values->computer_name,
 		                   &( record_data[ record_data_offset ] ),
 		                   members_data_size,
 		                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,
 		                   LIBFVALUE_VALUE_DATA_FLAG_MANAGED,
 		                   error );
 
 		if( value_data_size == -1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
 			 ""%s: unable to set data of computer name value."",
 			 function );
 
 			goto on_error;
 		}
 #if defined( HAVE_DEBUG_OUTPUT )
 		if( libcnotify_verbose != 0 )
 		{
 			libcnotify_printf(
 			 ""%s: computer name\t\t\t\t: "",
 			 function );
 
 			if( libfvalue_value_print(
 			     record_values->computer_name,
 			     0,
 			     0,
 			     error ) != 1 )
 			{
 				libcerror_error_set(
 				 error,
 				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 				 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
 				 ""%s: unable to print computer name value."",
 				 function );
 
 				goto on_error;
 			}
 			libcnotify_printf(
 			 ""\n"" );
 		}
 #endif
 		record_data_offset += value_data_size;
 		members_data_size  -= (uint32_t) value_data_size;
 
 		if( members_data_size > 0 )
 		{
 #if defined( HAVE_DEBUG_OUTPUT )
 			if( libcnotify_verbose != 0 )
 			{
 				libcnotify_printf(
 				 ""%s: members trailing data:\n"",
 				 function );
 				libcnotify_print_data(
 				 &( record_data[ record_data_offset ] ),
 				 members_data_size,
 				 LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );
 			}
 #endif
 			record_data_offset += members_data_size;
 		}
  	}
  	if( user_sid_size != 0 )
  	{
 		if( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: user SID data size value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
  		if( libfvalue_value_type_initialize(
  		     &( record_values->user_security_identifier ),
  		     LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
 			 ""%s: unable to create user security identifier (SID) value."",
 			 function );
 
 			goto on_error;
 		}
 		if( libfvalue_value_set_data(
 		     record_values->user_security_identifier,
 		     &( record_data[ user_sid_offset ] ),
 		     (size_t) user_sid_size,
 		     LIBFVALUE_ENDIAN_LITTLE,
 		     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
 			 ""%s: unable to set data of user security identifier (SID) value."",
 			 function );
 
 			goto on_error;
 		}
 #if defined( HAVE_DEBUG_OUTPUT )
 		if( libcnotify_verbose != 0 )
 		{
 			libcnotify_printf(
 			 ""%s: user security identifier (SID)\t\t: "",
 			 function );
 
 			if( libfvalue_value_print(
 			     record_values->user_security_identifier,
 			     0,
 			     0,
 			     error ) != 1 )
 			{
 				libcerror_error_set(
 				 error,
 				 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 				 LIBCERROR_RUNTIME_ERROR_PRINT_FAILED,
 				 ""%s: unable to print user security identifier (SID) value."",
 				 function );
 
 				goto on_error;
 			}
 			libcnotify_printf(
 			 ""\n"" );
 		}
 #endif
 		record_data_offset += user_sid_size;
  	}
  	if( strings_size != 0 )
  	{
 		if( strings_size > ( ( record_data_size - 4 ) - strings_offset ) )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: strings size value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
  #if defined( HAVE_DEBUG_OUTPUT )
  		if( libcnotify_verbose != 0 )
  		{
 			libcnotify_printf(
 			 ""%s: strings data:\n"",
 			 function );
 			libcnotify_print_data(
 			 &( record_data[ strings_offset ] ),
 			 strings_size,
 			 LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );
 		}
 #endif
 		if( size_copy == 0 )
 		{
 			 
 			strings_data_offset = strings_offset + strings_size - 2;
 
 			while( strings_data_offset > strings_offset )
 			{
 				if( ( record_data[ strings_data_offset ] != 0 )
 				 || ( record_data[ strings_data_offset + 1 ] != 0 ) )
 				{
 					strings_size += 2;
 
 					break;
 				}
 				strings_data_offset -= 2;
 				strings_size        -= 2;
 			}
 		}
 		if( libfvalue_value_type_initialize(
 		     &( record_values->strings ),
 		     LIBFVALUE_VALUE_TYPE_STRING_UTF16,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
 			 ""%s: unable to create strings value."",
 			 function );
 
 			goto on_error;
 		}
 		value_data_size = libfvalue_value_type_set_data_strings_array(
 		                   record_values->strings,
 		                   &( record_data[ strings_offset ] ),
 		                   strings_size,
 		                   LIBFVALUE_CODEPAGE_UTF16_LITTLE_ENDIAN,
 		                   error );
 
 		if( value_data_size == -1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
 			 ""%s: unable to set data of strings value."",
 			 function );
 
 			goto on_error;
 		}
 		record_data_offset += strings_size;
  	}
  	if( data_size != 0 )
  	{
 		if( data_size > ( ( record_data_size - 4 ) - data_offset ) )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,
 			 ""%s: data size value out of bounds."",
 			 function );
 
 			goto on_error;
 		}
  #if defined( HAVE_DEBUG_OUTPUT )
  		if( libcnotify_verbose != 0 )
  		{
  			libcnotify_printf(
  			 ""%s: data:\n"",
  			 function );
  			libcnotify_print_data(
			 &( record_data[ data_offset ] ),
 			 &( record_data[ record_data_offset ] ),
  			 (size_t) data_size,
  			 LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );
  		}
 #endif
 		if( libfvalue_value_type_initialize(
 		     &( record_values->data ),
 		     LIBFVALUE_VALUE_TYPE_BINARY_DATA,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_INITIALIZE_FAILED,
 			 ""%s: unable to create data value."",
 			 function );
 
 			goto on_error;
 		}
 		if( libfvalue_value_set_data(
 		     record_values->data,
 		     &( record_data[ record_data_offset ] ),
 		     (size_t) data_size,
 		     LIBFVALUE_ENDIAN_LITTLE,
 		     LIBFVALUE_VALUE_DATA_FLAG_MANAGED,
 		     error ) != 1 )
 		{
 			libcerror_error_set(
 			 error,
 			 LIBCERROR_ERROR_DOMAIN_RUNTIME,
 			 LIBCERROR_RUNTIME_ERROR_SET_FAILED,
 			 ""%s: unable to set data of data value."",
 			 function );
 
 			goto on_error;
 		}
 #if defined( HAVE_DEBUG_OUTPUT )
 		record_data_offset += data_size;
 #endif
 	}
 #if defined( HAVE_DEBUG_OUTPUT )
 	if( libcnotify_verbose != 0 )
 	{
 		if( record_data_offset < ( record_data_size - 4 ) )
 		{
 			libcnotify_printf(
 			 ""%s: padding:\n"",
 			 function );
 			libcnotify_print_data(
 			 &( record_data[ record_data_offset ] ),
 			 (size_t) record_data_size - record_data_offset - 4,
 			 LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );
 		}
 		libcnotify_printf(
 		 ""%s: size copy\t\t\t\t: %"" PRIu32 ""\n"",
 		 function,
 		 size_copy );
 
 		libcnotify_printf(
 		 ""\n"" );
 	}
 #endif
 	if( ( strict_mode == 0 )
 	 && ( size_copy == 0 ) )
 	{
 		size_copy = size;
 	}
 	if( size != size_copy )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_INPUT,
 		 LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,
 		 ""%s: value mismatch for size and size copy."",
 		 function );
 
 		goto on_error;
 	}
 	if( record_data_size != (size_t) size )
 	{
 		libcerror_error_set(
 		 error,
 		 LIBCERROR_ERROR_DOMAIN_INPUT,
 		 LIBCERROR_INPUT_ERROR_VALUE_MISMATCH,
 		 ""%s: value mismatch for record_values data size and size."",
 		 function );
 
 		goto on_error;
 	}
 	return( 1 );
 
 on_error:
 	if( record_values->data != NULL )
 	{
 		libfvalue_value_free(
 		 &( record_values->data ),
 		 NULL );
 	}
 	if( record_values->strings != NULL )
 	{
 		libfvalue_value_free(
 		 &( record_values->strings ),
 		 NULL );
 	}
 	if( record_values->user_security_identifier != NULL )
 	{
 		libfvalue_value_free(
 		 &( record_values->user_security_identifier ),
 		 NULL );
 	}
 	if( record_values->computer_name != NULL )
 	{
 		libfvalue_value_free(
 		 &( record_values->computer_name ),
 		 NULL );
 	}
 	if( record_values->source_name != NULL )
 	{
 		libfvalue_value_free(
 		 &( record_values->source_name ),
 		 NULL );
 	}
 	return( -1 );
 }","[561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 729, 728]","** DISPUTED ** The libevt_record_values_read_event() function in libevt_record_values.c in libevt before 2018-03-17 does not properly check for out-of-bounds values of user SID data size, strings size, or data size. NOTE: the vendor has disputed this as described in libyal/libevt issue 5 on GitHub."
204711," WebNavigationPolicy RenderViewImpl::decidePolicyForNavigation(
     WebFrame* frame, const WebURLRequest& request, WebNavigationType type,
     const WebNode&, WebNavigationPolicy default_policy, bool is_redirect) {
   if (is_swapped_out_) {
     if (request.url() != GURL(""about:swappedout""))
       return WebKit::WebNavigationPolicyIgnore;
 
     return default_policy;
   }
 
   const GURL& url = request.url();
 
   bool is_content_initiated =
       DocumentState::FromDataSource(frame->provisionalDataSource())->
           navigation_state()->is_content_initiated();
 
   const CommandLine& command_line = *CommandLine::ForCurrentProcess();
   if (command_line.HasSwitch(switches::kEnableStrictSiteIsolation) &&
       !frame->parent() && (is_content_initiated || is_redirect)) {
     WebString origin_str = frame->document().securityOrigin().toString();
     GURL frame_url(origin_str.utf8().data());
     if (frame_url.GetOrigin() != url.GetOrigin()) {
       Referrer referrer(
           GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
           GetReferrerPolicyFromRequest(request));
       OpenURL(frame, url, referrer, default_policy);
       return WebKit::WebNavigationPolicyIgnore;
     }
   }
 
   if (is_content_initiated) {
     bool browser_handles_top_level_requests =
         renderer_preferences_.browser_handles_top_level_requests &&
         IsNonLocalTopLevelNavigation(url, frame, type);
     if (browser_handles_top_level_requests ||
         renderer_preferences_.browser_handles_all_requests) {
       Referrer referrer(
           GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
           GetReferrerPolicyFromRequest(request));
       page_id_ = -1;
       last_page_id_sent_to_browser_ = -1;
       OpenURL(frame, url, referrer, default_policy);
       return WebKit::WebNavigationPolicyIgnore;   
     }
   }
  
    
    
    
    
    
    
    
    
    if (!frame->parent() && is_content_initiated &&
      default_policy == WebKit::WebNavigationPolicyCurrentTab &&
      request.httpMethod() == ""GET"" && !url.SchemeIs(chrome::kAboutScheme)) {
       !url.SchemeIs(chrome::kAboutScheme)) {
      bool send_referrer = false;
 
      
      
      
      
      
     int cumulative_bindings =
         RenderProcess::current()->GetEnabledBindings();
      bool should_fork =
        (enabled_bindings_ & content::BINDINGS_POLICY_WEB_UI) ||
        frame->isViewSourceModeEnabled() ||
        url.SchemeIs(chrome::kViewSourceScheme);
         content::GetContentClient()->HasWebUIScheme(url) ||
         (cumulative_bindings & content::BINDINGS_POLICY_WEB_UI) ||
         url.SchemeIs(chrome::kViewSourceScheme) ||
         frame->isViewSourceModeEnabled();
  
      if (!should_fork) {
      bool is_initial_navigation = page_id_ == -1;
      should_fork = content::GetContentClient()->renderer()->ShouldFork(
          frame, url, is_initial_navigation, &send_referrer);
        
        
        
        
       if (request.httpMethod() == ""GET"") {
         bool is_initial_navigation = page_id_ == -1;
         should_fork = content::GetContentClient()->renderer()->ShouldFork(
             frame, url, is_initial_navigation, &send_referrer);
       }
      }
  
      if (should_fork) {
       Referrer referrer(
           GURL(request.httpHeaderField(WebString::fromUTF8(""Referer""))),
           GetReferrerPolicyFromRequest(request));
       OpenURL(
           frame, url, send_referrer ? referrer : Referrer(), default_policy);
       return WebKit::WebNavigationPolicyIgnore;   
     }
   }
 
   GURL old_url(frame->dataSource()->request().url());
 
   bool is_fork =
       old_url == GURL(chrome::kAboutBlankURL) &&
       historyBackListCount() < 1 &&
       historyForwardListCount() < 1 &&
       frame->opener() == NULL &&
       frame->parent() == NULL &&
       is_content_initiated &&
       default_policy == WebKit::WebNavigationPolicyCurrentTab &&
       type == WebKit::WebNavigationTypeOther;
 
   if (is_fork) {
     OpenURL(frame, url, Referrer(), default_policy);
     return WebKit::WebNavigationPolicyIgnore;
   }
 
   return default_policy;
 }","[47, 48, 49, 50, 51, 52, 53, 54, 58, 60, 61, 62, 63, 64, 65, 66, 67, 72, 73, 74, 75, 81, 82, 83, 84, 85, 86, 87, 88, 89, 56, 57, 69, 70, 71, 78, 79, 80]","Google Chrome before 19.0.1084.46 does not use a dedicated process for the loading of links found on an internal page, which might allow attackers to bypass intended sandbox restrictions via a crafted page."
9796,"int callback_static_compressed_inmemory_website (const struct _u_request * request, struct _u_response * response, void * user_data) {
struct _u_compressed_inmemory_website_config * config = (struct _u_compressed_inmemory_website_config *)user_data;
char ** accept_list = NULL;
int ret = U_CALLBACK_CONTINUE, compress_mode = U_COMPRESS_NONE, res;
z_stream defstream;
unsigned char * file_content, * file_content_orig = NULL;
size_t length, read_length, offset, data_zip_len = 0;
FILE * f;
char * file_requested, * file_path, * url_dup_save, * data_zip = NULL;
const char * content_type;




if (request->callback_position > 0) {
return U_CALLBACK_IGNORE;
} else {
file_requested = o_strdup(request->http_url);
url_dup_save = file_requested;

file_requested += o_strlen((config->url_prefix));
while (file_requested[0] == '/') {
file_requested++;
}

if (strchr(file_requested, '#') != NULL) {
*strchr(file_requested, '#') = '\0';
}

if (strchr(file_requested, '?') != NULL) {
*strchr(file_requested, '?') = '\0';
}

if (file_requested == NULL || o_strnullempty(file_requested) || 0 == o_strcmp(""/"", file_requested)) {
o_free(url_dup_save);
url_dup_save = file_requested = o_strdup(""index.html"");
}

if (!u_map_has_key_case(response->map_header, U_CONTENT_HEADER)) {
if (split_string(u_map_get_case(request->map_header, U_ACCEPT_HEADER), "","", &accept_list)) {
if (config->allow_gzip && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_GZIP)) {
compress_mode = U_COMPRESS_GZIP;
} else if (config->allow_deflate && string_array_has_trimmed_value((const char **)accept_list, U_ACCEPT_DEFLATE)) {
compress_mode = U_COMPRESS_DEFL;
}


if (compress_mode != U_COMPRESS_NONE) {
if (compress_mode == U_COMPRESS_GZIP && config->allow_cache_compressed && u_map_has_key(&config->gzip_files, file_requested)) {
ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));
u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_GZIP);

content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));
if (content_type == NULL) {
content_type = u_map_get(&config->mime_types, ""*"");
}
u_map_put(response->map_header, ""Content-Type"", content_type);
u_map_copy_into(response->map_header, &config->map_header);
} else if (compress_mode == U_COMPRESS_DEFL && config->allow_cache_compressed && u_map_has_key(&config->deflate_files, file_requested)) {
ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));
u_map_put(response->map_header, U_CONTENT_HEADER, U_ACCEPT_DEFLATE);

content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));
if (content_type == NULL) {
content_type = u_map_get(&config->mime_types, ""*"");
}
u_map_put(response->map_header, ""Content-Type"", content_type);
u_map_copy_into(response->map_header, &config->map_header);
} else {
file_path = msprintf(""%s/%s"", ((struct _u_compressed_inmemory_website_config *)user_data)->files_path, file_requested);

if (!pthread_mutex_lock(&config->lock)) {
f = fopen (file_path, ""rb"");
if (f) {
content_type = u_map_get_case(&config->mime_types, get_filename_ext(file_requested));
if (content_type == NULL) {
content_type = u_map_get(&config->mime_types, ""*"");
y_log_message(Y_LOG_LEVEL_WARNING, ""Static File Server - Unknown mime type for extension %s"", get_filename_ext(file_requested));
}
if (!string_array_has_value((const char **)config->mime_types_compressed, content_type)) {
compress_mode = U_COMPRESS_NONE;
}

u_map_put(response->map_header, ""Content-Type"", content_type);
u_map_copy_into(response->map_header, &config->map_header);

fseek (f, 0, SEEK_END);
offset = length = ftell (f);
fseek (f, 0, SEEK_SET);

if (length) {
if ((file_content_orig = file_content = o_malloc(length)) != NULL && (data_zip = o_malloc((2*length)+20)) != NULL) {
defstream.zalloc = u_zalloc;
defstream.zfree = u_zfree;
defstream.opaque = Z_NULL;
defstream.avail_in = (uInt)length;
defstream.next_in = (Bytef *)file_content;
while ((read_length = fread(file_content, sizeof(char), offset, f))) {
file_content += read_length;
offset -= read_length;
}

if (compress_mode == U_COMPRESS_GZIP) {
if (deflateInit2(&defstream,
Z_DEFAULT_COMPRESSION,
Z_DEFLATED,
U_GZIP_WINDOW_BITS | U_GZIP_ENCODING,
8,
Z_DEFAULT_STRATEGY) != Z_OK) {
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error deflateInit (gzip)"");
ret = U_CALLBACK_ERROR;
}
} else {
if (deflateInit(&defstream, Z_BEST_COMPRESSION) != Z_OK) {
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error deflateInit (deflate)"");
ret = U_CALLBACK_ERROR;
}
}
if (ret == U_CALLBACK_CONTINUE) {
do {
if ((data_zip = o_realloc(data_zip, data_zip_len+_U_W_BLOCK_SIZE)) != NULL) {
defstream.avail_out = _U_W_BLOCK_SIZE;
defstream.next_out = ((Bytef *)data_zip)+data_zip_len;
switch ((res = deflate(&defstream, Z_FINISH))) {
case Z_OK:
case Z_STREAM_END:
case Z_BUF_ERROR:
break;
default:
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error deflate %d"", res);
ret = U_CALLBACK_ERROR;
break;
}
data_zip_len += _U_W_BLOCK_SIZE - defstream.avail_out;
} else {
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error allocating resources for data_zip"");
ret = U_CALLBACK_ERROR;
}
} while (U_CALLBACK_CONTINUE == ret && defstream.avail_out == 0);

if (ret == U_CALLBACK_CONTINUE) {
if (compress_mode == U_COMPRESS_GZIP) {
if (config->allow_cache_compressed) {
u_map_put_binary(&config->gzip_files, file_requested, data_zip, 0, defstream.total_out);
}
ulfius_set_binary_body_response(response, 200, u_map_get(&config->gzip_files, file_requested), u_map_get_length(&config->gzip_files, file_requested));
} else {
if (config->allow_cache_compressed) {
u_map_put_binary(&config->deflate_files, file_requested, data_zip, 0, defstream.total_out);
}
ulfius_set_binary_body_response(response, 200, u_map_get(&config->deflate_files, file_requested), u_map_get_length(&config->deflate_files, file_requested));
}
u_map_put(response->map_header, U_CONTENT_HEADER, compress_mode==U_COMPRESS_GZIP?U_ACCEPT_GZIP:U_ACCEPT_DEFLATE);
}
}
deflateEnd(&defstream);
o_free(data_zip);
} else {
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error allocating resource for file_content or data_zip"");
ret = U_CALLBACK_ERROR;
}
o_free(file_content_orig);
}
fclose(f);
} else {
if (((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404 == NULL) {
ret = U_CALLBACK_IGNORE;
} else {
ulfius_add_header_to_response(response, ""Location"", ((struct _u_compressed_inmemory_website_config *)user_data)->redirect_on_404);
response->status = 302;
}
}
pthread_mutex_unlock(&config->lock);
} else {
y_log_message(Y_LOG_LEVEL_ERROR, ""callback_static_compressed_inmemory_website - Error pthread_lock_mutex"");
ret = U_CALLBACK_ERROR;
}
o_free(file_path);
}
} else {
ret = callback_static_file_uncompressed(request, response, user_data);
}
free_string_array(accept_list);
}
}
o_free(url_dup_save);
}

return ret;
}","[9, 72, 72, 73, 74, 75, 76, 77, 78, 80, 81, 84, 85, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 103, 104, 105, 106, 107, 109, 110, 111, 113, 114, 115, 116, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 134, 135, 136, 139, 142, 143, 144, 146, 147, 148, 149, 151, 153, 156, 156, 157, 159, 160, 162, 164, 166, 167, 168, 169, 170, 173, 175, 176, 180, 186, 186]",static_compressed_inmemory_website_callback.c in Glewlwyd through 2.6.2 allows directory traversal.
200486," get_results(struct iperf_test *test)
 {
     int r = 0;
     cJSON *j;
     cJSON *j_cpu_util_total;
     cJSON *j_cpu_util_user;
     cJSON *j_cpu_util_system;
     cJSON *j_sender_has_retransmits;
     int result_has_retransmits;
     cJSON *j_streams;
     int n, i;
     cJSON *j_stream;
     cJSON *j_id;
     cJSON *j_bytes;
     cJSON *j_retransmits;
     cJSON *j_jitter;
     cJSON *j_errors;
     cJSON *j_packets;
     cJSON *j_server_output;
     int sid, cerror, pcount;
     double jitter;
     iperf_size_t bytes_transferred;
     int retransmits;
     struct iperf_stream *sp;
 
     j = JSON_read(test->ctrl_sck);
     if (j == NULL) {
 	i_errno = IERECVRESULTS;
         r = -1;
     } else {
 	j_cpu_util_total = cJSON_GetObjectItem(j, ""cpu_util_total"");
 	j_cpu_util_user = cJSON_GetObjectItem(j, ""cpu_util_user"");
 	j_cpu_util_system = cJSON_GetObjectItem(j, ""cpu_util_system"");
 	j_sender_has_retransmits = cJSON_GetObjectItem(j, ""sender_has_retransmits"");
 	if (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {
 	    i_errno = IERECVRESULTS;
 	    r = -1;
 	} else {
 	    if (test->debug) {
  		printf(""get_results\n%s\n"", cJSON_Print(j));
  	    }
  
	    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;
	    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;
	    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;
 	    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;
 	    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;
 	    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;
  	    result_has_retransmits = j_sender_has_retransmits->valueint;
  	    if (! test->sender)
  		test->sender_has_retransmits = result_has_retransmits;
 	    j_streams = cJSON_GetObjectItem(j, ""streams"");
 	    if (j_streams == NULL) {
 		i_errno = IERECVRESULTS;
 		r = -1;
 	    } else {
 	        n = cJSON_GetArraySize(j_streams);
 		for (i=0; i<n; ++i) {
 		    j_stream = cJSON_GetArrayItem(j_streams, i);
 		    if (j_stream == NULL) {
 			i_errno = IERECVRESULTS;
 			r = -1;
 		    } else {
 			j_id = cJSON_GetObjectItem(j_stream, ""id"");
 			j_bytes = cJSON_GetObjectItem(j_stream, ""bytes"");
 			j_retransmits = cJSON_GetObjectItem(j_stream, ""retransmits"");
 			j_jitter = cJSON_GetObjectItem(j_stream, ""jitter"");
 			j_errors = cJSON_GetObjectItem(j_stream, ""errors"");
 			j_packets = cJSON_GetObjectItem(j_stream, ""packets"");
 			if (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {
 			    i_errno = IERECVRESULTS;
 			    r = -1;
 			} else {
  			    sid = j_id->valueint;
  			    bytes_transferred = j_bytes->valueint;
  			    retransmits = j_retransmits->valueint;
			    jitter = j_jitter->valuefloat;
 			    jitter = j_jitter->valuedouble;
  			    cerror = j_errors->valueint;
  			    pcount = j_packets->valueint;
  			    SLIST_FOREACH(sp, &test->streams, streams)
 				if (sp->id == sid) break;
 			    if (sp == NULL) {
 				i_errno = IESTREAMID;
 				r = -1;
 			    } else {
 				if (test->sender) {
 				    sp->jitter = jitter;
 				    sp->cnt_error = cerror;
 				    sp->packet_count = pcount;
 				    sp->result->bytes_received = bytes_transferred;
 				} else {
 				    sp->result->bytes_sent = bytes_transferred;
 				    sp->result->stream_retrans = retransmits;
 				}
 			    }
 			}
 		    }
 		}
 		 
 		if (test->role == 'c' && iperf_get_test_get_server_output(test)) {
 		     
 		    j_server_output = cJSON_DetachItemFromObject(j, ""server_output_json"");
 		    if (j_server_output != NULL) {
 			test->json_server_output = j_server_output;
 		    }
 		    else {
 			 
 			j_server_output = cJSON_GetObjectItem(j, ""server_output_text"");
 			if (j_server_output != NULL) {
 			    test->server_output_text = strdup(j_server_output->valuestring);
 			}
 		    }
 		}
 	    }
 	}
 	cJSON_Delete(j);
     }
     return r;
 }","[46, 47, 48, 78, 43, 44, 45, 77]","The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow."
199328," cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)
 cib_tls_signon(cib_t * cib, struct remote_connection_s *connection, gboolean event_channel)
  {
      int sock;
      cib_remote_opaque_t *private = cib->variant_opaque;
    struct sockaddr_in addr;
      int rc = 0;
    char *server = private->server;
    int ret_ga;
    struct addrinfo *res;
    struct addrinfo hints;
     int disconnected = 0;
  
      xmlNode *answer = NULL;
      xmlNode *login = NULL;
  
    static struct mainloop_fd_callbacks cib_fd_callbacks = 
        {
            .dispatch = cib_remote_dispatch,
            .destroy = cib_remote_connection_destroy,
        };
     static struct mainloop_fd_callbacks cib_fd_callbacks = { 0, };
 
     cib_fd_callbacks.dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch;
     cib_fd_callbacks.destroy = cib_remote_connection_destroy;
  
      connection->socket = 0;
      connection->session = NULL;
  
     
    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == -1) {
        crm_perror(LOG_ERR, ""Socket creation failed"");
        return -1;
    }
     
    bzero(&hints, sizeof(struct addrinfo));
    hints.ai_flags = AI_CANONNAME;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_RAW;
    if (hints.ai_family == AF_INET6) {
        hints.ai_protocol = IPPROTO_ICMPV6;
    } else {
        hints.ai_protocol = IPPROTO_ICMP;
    }
    crm_debug(""Looking up %s"", server);
    ret_ga = getaddrinfo(server, NULL, &hints, &res);
    if (ret_ga) {
        crm_err(""getaddrinfo: %s"", gai_strerror(ret_ga));
        close(sock);
        return -1;
    }
    if (res->ai_canonname) {
        server = res->ai_canonname;
    }
    crm_debug(""Got address %s for %s"", server, private->server);
    if (!res->ai_addr) {
        fprintf(stderr, ""getaddrinfo failed"");
        crm_exit(1);
    }
#if 1
    memcpy(&addr, res->ai_addr, res->ai_addrlen);
#else
     
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(server);
#endif
    addr.sin_port = htons(private->port);
    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        crm_perror(LOG_ERR, ""Connection to %s:%d failed"", server, private->port);
        close(sock);
        return -1;
     sock = crm_remote_tcp_connect(private->server, private->port);
     if (sock <= 0) {
         crm_perror(LOG_ERR, ""remote tcp connection to %s:%d failed"", private->server, private->port);
      }
  
     connection->socket = sock;
      if (connection->encrypted) {
           
  #ifdef HAVE_GNUTLS_GNUTLS_H
        gnutls_global_init();
        gnutls_anon_allocate_client_credentials(&anon_cred_c);
         if (remote_gnutls_credentials_init == FALSE) {
             gnutls_global_init();
             gnutls_anon_allocate_client_credentials(&anon_cred_c);
             remote_gnutls_credentials_init = TRUE;
         }
  
           
        connection->session = create_tls_session(sock, GNUTLS_CLIENT);
        if (connection->session == NULL) {
            crm_perror(LOG_ERR, ""Session creation for %s:%d failed"", server, private->port);
            close(sock);
         connection->session = crm_create_anon_tls_session(sock, GNUTLS_CLIENT, anon_cred_c);
 
         if (crm_initiate_client_tls_handshake(connection->session, DEFAULT_CLIENT_HANDSHAKE_TIMEOUT) != 0) {
             crm_err(""Session creation for %s:%d failed"", private->server, private->port);
 
             gnutls_deinit(*connection->session);
             gnutls_free(connection->session);
             connection->session = NULL;
              cib_tls_close(cib);
              return -1;
          }
 #else
         return -EPROTONOSUPPORT;
 #endif
     } else {
         connection->session = GUINT_TO_POINTER(sock);
     }
 
      
     login = create_xml_node(NULL, ""cib_command"");
     crm_xml_add(login, ""op"", ""authenticate"");
     crm_xml_add(login, ""user"", private->user);
     crm_xml_add(login, ""password"", private->passwd);
     crm_xml_add(login, ""hidden"", ""password"");
 
      crm_send_remote_msg(connection->session, login, connection->encrypted);
      free_xml(login);
  
    answer = crm_recv_remote_msg(connection->session, connection->encrypted);
     crm_recv_remote_msg(connection->session, &connection->recv_buf, connection->encrypted, -1, &disconnected);
 
     if (disconnected) {
         rc = -ENOTCONN;
     }
 
     answer = crm_parse_remote_buffer(&connection->recv_buf);
 
      crm_log_xml_trace(answer, ""Reply"");
      if (answer == NULL) {
          rc = -EPROTO;
 
     } else {
          
         const char *msg_type = crm_element_value(answer, F_CIB_OPERATION);
         const char *tmp_ticket = crm_element_value(answer, F_CIB_CLIENTID);
 
         if (safe_str_neq(msg_type, CRM_OP_REGISTER)) {
             crm_err(""Invalid registration message: %s"", msg_type);
             rc = -EPROTO;
 
         } else if (tmp_ticket == NULL) {
             rc = -EPROTO;
 
         } else {
              connection->token = strdup(tmp_ticket);
          }
      }
     free_xml(answer);
     answer = NULL;
  
      if (rc != 0) {
          cib_tls_close(cib);
         return rc;
      }
  
    connection->socket = sock;
     crm_trace(""remote client connection established"");
      connection->source = mainloop_add_fd(""cib-remote"", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);
      return rc;
  }","[2, 12, 22, 23, 24, 25, 74, 75, 76, 79, 85, 86, 87, 88, 89, 96, 97, 98, 99, 100, 101, 102, 103, 125, 126, 127, 128, 129, 130, 131, 132, 153, 154, 158, 162, 6, 8, 9, 10, 11, 17, 18, 19, 20, 21, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 83, 84, 92, 93, 94, 95, 124, 161]","Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking)."
198662,"  jbig2_image_compose_unopt(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
  {
    int i, j;
    int sw = src->width;
    int sh = src->height;
    int sx = 0;
    int sy = 0;
     uint32_t i, j;
     uint32_t sw = src->width;
     uint32_t sh = src->height;
     uint32_t sx = 0;
     uint32_t sy = 0;
  
       
      if (x < 0) {
         sx += -x;
         sw -= -x;
         x = 0;
     }
     if (y < 0) {
         sy += -y;
         sh -= -y;
         y = 0;
     }
     if (x + sw >= dst->width)
         sw = dst->width - x;
     if (y + sh >= dst->height)
         sh = dst->height - y;
 
     switch (op) {
     case JBIG2_COMPOSE_OR:
         for (j = 0; j < sh; j++) {
             for (i = 0; i < sw; i++) {
                 jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) | jbig2_image_get_pixel(dst, i + x, j + y));
             }
         }
         break;
     case JBIG2_COMPOSE_AND:
         for (j = 0; j < sh; j++) {
             for (i = 0; i < sw; i++) {
                 jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) & jbig2_image_get_pixel(dst, i + x, j + y));
             }
         }
         break;
     case JBIG2_COMPOSE_XOR:
         for (j = 0; j < sh; j++) {
             for (i = 0; i < sw; i++) {
                 jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) ^ jbig2_image_get_pixel(dst, i + x, j + y));
             }
         }
         break;
     case JBIG2_COMPOSE_XNOR:
         for (j = 0; j < sh; j++) {
             for (i = 0; i < sw; i++) {
                 jbig2_image_set_pixel(dst, i + x, j + y, (jbig2_image_get_pixel(src, i + sx, j + sy) == jbig2_image_get_pixel(dst, i + x, j + y)));
             }
         }
         break;
     case JBIG2_COMPOSE_REPLACE:
         for (j = 0; j < sh; j++) {
             for (i = 0; i < sw; i++) {
                 jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy));
             }
         }
         break;
     }
 
     return 0;
 }","[8, 9, 10, 11, 12, 3, 4, 5, 6, 7]","ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript."
7074,"CallResult<HermesValue> Interpreter::interpretFunction(
Runtime *runtime,
InterpreterState &state) {














struct IPSaver {
IPSaver(Runtime *runtime)
: ip_(runtime->getCurrentIP()), runtime_(runtime) {}

~IPSaver() {
runtime_->setCurrentIP(ip_);
}

private:
const Inst *ip_;
Runtime *runtime_;
};
IPSaver ipSaver(runtime);

#ifndef HERMES_ENABLE_DEBUGGER
static_assert(!SingleStep, ""can't use single-step mode without the debugger"");
#endif


static_assert(
HiddenClass::kDictionaryThreshold <=
SegmentedArray::kValueToSegmentThreshold,
""Cannot avoid branches in cache check if the dictionary ""
""crossover point is larger than the inline storage"");

CodeBlock *curCodeBlock = state.codeBlock;
const Inst *ip = nullptr;


PinnedHermesValue *frameRegs;

bool strictMode;

PropOpFlags defaultPropOpFlags;
















#define CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr) \
  runtime->setCurrentIP(ip);                       \
  dst = expr;                                      \
  ip = runtime->getCurrentIP();

#ifdef NDEBUG

#define CAPTURE_IP(expr)     \
  runtime->setCurrentIP(ip); \
  (void)expr;                \
  ip = runtime->getCurrentIP();

#define CAPTURE_IP_ASSIGN(dst, expr) CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr)

#else  !NDEBUG

#define CAPTURE_IP(expr)        \
  runtime->setCurrentIP(ip);    \
  (void)expr;                   \
  ip = runtime->getCurrentIP(); \
  runtime->invalidateCurrentIP();

#define CAPTURE_IP_ASSIGN(dst, expr) \
  runtime->setCurrentIP(ip);         \
  dst = expr;                        \
  ip = runtime->getCurrentIP();      \
  runtime->invalidateCurrentIP();

#endif  NDEBUG

LLVM_DEBUG(dbgs() << ""interpretFunction() called\n"");

ScopedNativeDepthTracker depthTracker{runtime};
if (LLVM_UNLIKELY(depthTracker.overflowed())) {
return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);
}

if (!SingleStep) {
if (auto jitPtr = runtime->jitContext_.compile(runtime, curCodeBlock)) {
return (*jitPtr)(runtime);
}
}

GCScope gcScope(runtime);

MutableHandle<> tmpHandle(runtime);
CallResult<HermesValue> res{ExecutionStatus::EXCEPTION};
CallResult<PseudoHandle<>> resPH{ExecutionStatus::EXCEPTION};
CallResult<Handle<Arguments>> resArgs{ExecutionStatus::EXCEPTION};
CallResult<bool> boolRes{ExecutionStatus::EXCEPTION};



static constexpr unsigned KEEP_HANDLES = 1;
assert(
gcScope.getHandleCountDbg() == KEEP_HANDLES &&
""scope has unexpected number of handles"");

INIT_OPCODE_PROFILER;

#if !defined(HERMESVM_PROFILER_EXTERN)
tailCall:
#endif
PROFILER_ENTER_FUNCTION(curCodeBlock);

#ifdef HERMES_ENABLE_DEBUGGER
runtime->getDebugger().willEnterCodeBlock(curCodeBlock);
#endif

runtime->getCodeCoverageProfiler().markExecuted(runtime, curCodeBlock);


curCodeBlock->incrementExecutionCount();

if (!SingleStep) {
auto newFrame = runtime->setCurrentFrameToTopOfStack();
runtime->saveCallerIPInStackFrame();
#ifndef NDEBUG
runtime->invalidateCurrentIP();
#endif




frameRegs = &newFrame.getFirstLocalRef();

#ifndef NDEBUG
LLVM_DEBUG(
dbgs() << ""function entry: stackLevel="" << runtime->getStackLevel()
<< "", argCount="" << runtime->getCurrentFrame().getArgCount()
<< "", frameSize="" << curCodeBlock->getFrameSize() << ""\n"");

LLVM_DEBUG(
dbgs() << "" callee ""
<< DumpHermesValue(
runtime->getCurrentFrame().getCalleeClosureOrCBRef())
<< ""\n"");
LLVM_DEBUG(
dbgs() << ""   this ""
<< DumpHermesValue(runtime->getCurrentFrame().getThisArgRef())
<< ""\n"");
for (uint32_t i = 0; i != runtime->getCurrentFrame()->getArgCount(); ++i) {
LLVM_DEBUG(
dbgs() << ""   "" << llvh::format_decimal(i, 4) << "" ""
<< DumpHermesValue(runtime->getCurrentFrame().getArgRef(i))
<< ""\n"");
}
#endif


if (LLVM_UNLIKELY(!runtime->checkAndAllocStack(
curCodeBlock->getFrameSize() +
StackFrameLayout::CalleeExtraRegistersAtStart,
HermesValue::encodeUndefinedValue())))
goto stackOverflow;

ip = (Inst const *)curCodeBlock->begin();


if (LLVM_UNLIKELY(curCodeBlock->getHeaderFlags().isCallProhibited(
newFrame.isConstructorCall()))) {
if (!newFrame.isConstructorCall()) {
CAPTURE_IP(
runtime->raiseTypeError(""Class constructor invoked without new""));
} else {
CAPTURE_IP(runtime->raiseTypeError(""Function is not a constructor""));
}
goto handleExceptionInParent;
}
} else {

frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();
ip = (Inst const *)(curCodeBlock->begin() + state.offset);
}

assert((const uint8_t *)ip < curCodeBlock->end() && ""CodeBlock is empty"");

INIT_STATE_FOR_CODEBLOCK(curCodeBlock);

#define BEFORE_OP_CODE                                                       \
  {                                                                          \
    UPDATE_OPCODE_TIME_SPENT;                                                \
    HERMES_SLOW_ASSERT(                                                      \
        curCodeBlock->contains(ip) && ""curCodeBlock must contain ip"");       \
    HERMES_SLOW_ASSERT((printDebugInfo(curCodeBlock, frameRegs, ip), true)); \
    HERMES_SLOW_ASSERT(                                                      \
        gcScope.getHandleCountDbg() == KEEP_HANDLES &&                       \
        ""unaccounted handles were created"");                                 \
    HERMES_SLOW_ASSERT(tmpHandle->isUndefined() && ""tmpHandle not cleared""); \
    RECORD_OPCODE_START_TIME;                                                \
    INC_OPCODE_COUNT;                                                        \
  }

#ifdef HERMESVM_INDIRECT_THREADING
static void *opcodeDispatch[] = {
#define DEFINE_OPCODE(name) &&case_##name,
#include ""hermes/BCGen/HBC/BytecodeList.def""
&&case__last};

#define CASE(name) case_##name:
#define DISPATCH                                \
  BEFORE_OP_CODE;                               \
  if (SingleStep) {                             \
    state.codeBlock = curCodeBlock;             \
    state.offset = CUROFFSET;                   \
    return HermesValue::encodeUndefinedValue(); \
  }                                             \
  goto *opcodeDispatch[(unsigned)ip->opCode]

#else  HERMESVM_INDIRECT_THREADING

#define CASE(name) case OpCode::name:
#define DISPATCH                                \
  if (SingleStep) {                             \
    state.codeBlock = curCodeBlock;             \
    state.offset = CUROFFSET;                   \
    return HermesValue::encodeUndefinedValue(); \
  }                                             \
  continue

#endif  HERMESVM_INDIRECT_THREADING

#define RUN_DEBUGGER_ASYNC_BREAK(flags)                                      \
  do {                                                                       \
    CAPTURE_IP_ASSIGN(                                                       \
        auto dRes,                                                           \
        runDebuggerUpdatingState(                                            \
            (uint8_t)(flags) &                                               \
                    (uint8_t)Runtime::AsyncBreakReasonBits::DebuggerExplicit \
                ? Debugger::RunReason::AsyncBreakExplicit                    \
                : Debugger::RunReason::AsyncBreakImplicit,                   \
            runtime,                                                         \
            curCodeBlock,                                                    \
            ip,                                                              \
            frameRegs));                                                     \
    if (dRes == ExecutionStatus::EXCEPTION)                                  \
      goto exception;                                                        \
  } while (0)

for (;;) {
BEFORE_OP_CODE;

#ifdef HERMESVM_INDIRECT_THREADING
goto *opcodeDispatch[(unsigned)ip->opCode];
#else
switch (ip->opCode)
#endif
{
const Inst *nextIP;
uint32_t idVal;
bool tryProp;
uint32_t callArgCount;




HermesValue::RawType callNewTarget;






#define CASE_OUTOFLINE(name)                                         \
  CASE(name) {                                                       \
    CAPTURE_IP_ASSIGN(auto res, case##name(runtime, frameRegs, ip)); \
    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {          \
      goto exception;                                                \
    }                                                                \
    gcScope.flushToSmallCount(KEEP_HANDLES);                         \
    ip = NEXTINST(name);                                             \
    DISPATCH;                                                        \
  }







#define BINOP(name, oper)                                                  \
  CASE(name) {                                                             \
    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {   \
      /* Fast-path. */                                                     \
      CASE(name##N) {                                                      \
        O1REG(name) = HermesValue::encodeDoubleValue(                      \
            oper(O2REG(name).getNumber(), O3REG(name).getNumber()));       \
        ip = NEXTINST(name);                                               \
        DISPATCH;                                                          \
      }                                                                    \
    }                                                                      \
    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(name)))); \
    if (res == ExecutionStatus::EXCEPTION)                                 \
      goto exception;                                                      \
    double left = res->getDouble();                                        \
    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(name)))); \
    if (res == ExecutionStatus::EXCEPTION)                                 \
      goto exception;                                                      \
    O1REG(name) =                                                          \
        HermesValue::encodeDoubleValue(oper(left, res->getDouble()));      \
    gcScope.flushToSmallCount(KEEP_HANDLES);                               \
    ip = NEXTINST(name);                                                   \
    DISPATCH;                                                              \
  }









#define SHIFTOP(name, oper, lConv, lType, returnType)                      \
  CASE(name) {                                                             \
    if (LLVM_LIKELY(                                                       \
            O2REG(name).isNumber() &&                                      \
            O3REG(name).isNumber())) { /* Fast-path. */                    \
      auto lnum = static_cast<lType>(                                      \
          hermes::truncateToInt32(O2REG(name).getNumber()));               \
      auto rnum = static_cast<uint32_t>(                                   \
                      hermes::truncateToInt32(O3REG(name).getNumber())) &  \
          0x1f;                                                            \
      O1REG(name) = HermesValue::encodeDoubleValue(                        \
          static_cast<returnType>(lnum oper rnum));                        \
      ip = NEXTINST(name);                                                 \
      DISPATCH;                                                            \
    }                                                                      \
    CAPTURE_IP_ASSIGN(res, lConv(runtime, Handle<>(&O2REG(name))));        \
    if (res == ExecutionStatus::EXCEPTION) {                               \
      goto exception;                                                      \
    }                                                                      \
    auto lnum = static_cast<lType>(res->getNumber());                      \
    CAPTURE_IP_ASSIGN(res, toUInt32_RJS(runtime, Handle<>(&O3REG(name)))); \
    if (res == ExecutionStatus::EXCEPTION) {                               \
      goto exception;                                                      \
    }                                                                      \
    auto rnum = static_cast<uint32_t>(res->getNumber()) & 0x1f;            \
    gcScope.flushToSmallCount(KEEP_HANDLES);                               \
    O1REG(name) = HermesValue::encodeDoubleValue(                          \
        static_cast<returnType>(lnum oper rnum));                          \
    ip = NEXTINST(name);                                                   \
    DISPATCH;                                                              \
  }






#define BITWISEBINOP(name, oper)                                               \
  CASE(name) {                                                                 \
    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {       \
      /* Fast-path. */                                                         \
      O1REG(name) = HermesValue::encodeDoubleValue(                            \
          hermes::truncateToInt32(O2REG(name).getNumber())                     \
              oper hermes::truncateToInt32(O3REG(name).getNumber()));          \
      ip = NEXTINST(name);                                                     \
      DISPATCH;                                                                \
    }                                                                          \
    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(name))));      \
    if (res == ExecutionStatus::EXCEPTION) {                                   \
      goto exception;                                                          \
    }                                                                          \
    int32_t left = res->getNumberAs<int32_t>();                                \
    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O3REG(name))));      \
    if (res == ExecutionStatus::EXCEPTION) {                                   \
      goto exception;                                                          \
    }                                                                          \
    O1REG(name) =                                                              \
        HermesValue::encodeNumberValue(left oper res->getNumberAs<int32_t>()); \
    gcScope.flushToSmallCount(KEEP_HANDLES);                                   \
    ip = NEXTINST(name);                                                       \
    DISPATCH;                                                                  \
  }






#define CONDOP(name, oper, operFuncName)                                 \
  CASE(name) {                                                           \
    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) { \
      /* Fast-path. */                                                   \
      O1REG(name) = HermesValue::encodeBoolValue(                        \
          O2REG(name).getNumber() oper O3REG(name).getNumber());         \
      ip = NEXTINST(name);                                               \
      DISPATCH;                                                          \
    }                                                                    \
    CAPTURE_IP_ASSIGN(                                                   \
        boolRes,                                                         \
        operFuncName(                                                    \
            runtime, Handle<>(&O2REG(name)), Handle<>(&O3REG(name))));   \
    if (boolRes == ExecutionStatus::EXCEPTION)                           \
      goto exception;                                                    \
    gcScope.flushToSmallCount(KEEP_HANDLES);                             \
    O1REG(name) = HermesValue::encodeBoolValue(boolRes.getValue());      \
    ip = NEXTINST(name);                                                 \
    DISPATCH;                                                            \
  }











#define JCOND_IMPL(name, suffix, oper, operFuncName, trueDest, falseDest) \
  CASE(name##suffix) {                                                    \
    if (LLVM_LIKELY(                                                      \
            O2REG(name##suffix).isNumber() &&                             \
            O3REG(name##suffix).isNumber())) {                            \
      /* Fast-path. */                                                    \
      CASE(name##N##suffix) {                                             \
        if (O2REG(name##N##suffix)                                        \
                .getNumber() oper O3REG(name##N##suffix)                  \
                .getNumber()) {                                           \
          ip = trueDest;                                                  \
          DISPATCH;                                                       \
        }                                                                 \
        ip = falseDest;                                                   \
        DISPATCH;                                                         \
      }                                                                   \
    }                                                                     \
    CAPTURE_IP_ASSIGN(                                                    \
        boolRes,                                                          \
        operFuncName(                                                     \
            runtime,                                                      \
            Handle<>(&O2REG(name##suffix)),                               \
            Handle<>(&O3REG(name##suffix))));                             \
    if (boolRes == ExecutionStatus::EXCEPTION)                            \
      goto exception;                                                     \
    gcScope.flushToSmallCount(KEEP_HANDLES);                              \
    if (boolRes.getValue()) {                                             \
      ip = trueDest;                                                      \
      DISPATCH;                                                           \
    }                                                                     \
    ip = falseDest;                                                       \
    DISPATCH;                                                             \
  }






#define JCOND_STRICT_EQ_IMPL(name, suffix, trueDest, falseDest)         \
  CASE(name##suffix) {                                                  \
    if (strictEqualityTest(O2REG(name##suffix), O3REG(name##suffix))) { \
      ip = trueDest;                                                    \
      DISPATCH;                                                         \
    }                                                                   \
    ip = falseDest;                                                     \
    DISPATCH;                                                           \
  }






#define JCOND_EQ_IMPL(name, suffix, trueDest, falseDest) \
  CASE(name##suffix) {                                   \
    CAPTURE_IP_ASSIGN(                                   \
        res,                                             \
        abstractEqualityTest_RJS(                        \
            runtime,                                     \
            Handle<>(&O2REG(name##suffix)),              \
            Handle<>(&O3REG(name##suffix))));            \
    if (res == ExecutionStatus::EXCEPTION) {             \
      goto exception;                                    \
    }                                                    \
    gcScope.flushToSmallCount(KEEP_HANDLES);             \
    if (res->getBool()) {                                \
      ip = trueDest;                                     \
      DISPATCH;                                          \
    }                                                    \
    ip = falseDest;                                      \
    DISPATCH;                                            \
  }


#define JCOND(name, oper, operFuncName) \
  JCOND_IMPL(                           \
      J##name,                          \
      ,                                 \
      oper,                             \
      operFuncName,                     \
      IPADD(ip->iJ##name.op1),          \
      NEXTINST(J##name));               \
  JCOND_IMPL(                           \
      J##name,                          \
      Long,                             \
      oper,                             \
      operFuncName,                     \
      IPADD(ip->iJ##name##Long.op1),    \
      NEXTINST(J##name##Long));         \
  JCOND_IMPL(                           \
      JNot##name,                       \
      ,                                 \
      oper,                             \
      operFuncName,                     \
      NEXTINST(JNot##name),             \
      IPADD(ip->iJNot##name.op1));      \
  JCOND_IMPL(                           \
      JNot##name,                       \
      Long,                             \
      oper,                             \
      operFuncName,                     \
      NEXTINST(JNot##name##Long),       \
      IPADD(ip->iJNot##name##Long.op1));



#define LOAD_CONST(name, value) \
  CASE(name) {                  \
    O1REG(name) = value;        \
    ip = NEXTINST(name);        \
    DISPATCH;                   \
  }

#define LOAD_CONST_CAPTURE_IP(name, value) \
  CASE(name) {                             \
    CAPTURE_IP_ASSIGN(O1REG(name), value); \
    ip = NEXTINST(name);                   \
    DISPATCH;                              \
  }

CASE(Mov) {
O1REG(Mov) = O2REG(Mov);
ip = NEXTINST(Mov);
DISPATCH;
}

CASE(MovLong) {
O1REG(MovLong) = O2REG(MovLong);
ip = NEXTINST(MovLong);
DISPATCH;
}

CASE(LoadParam) {
if (LLVM_LIKELY(ip->iLoadParam.op2 <= FRAME.getArgCount())) {

O1REG(LoadParam) = FRAME.getArgRef((int32_t)ip->iLoadParam.op2 - 1);
ip = NEXTINST(LoadParam);
DISPATCH;
}
O1REG(LoadParam) = HermesValue::encodeUndefinedValue();
ip = NEXTINST(LoadParam);
DISPATCH;
}

CASE(LoadParamLong) {
if (LLVM_LIKELY(ip->iLoadParamLong.op2 <= FRAME.getArgCount())) {

O1REG(LoadParamLong) =
FRAME.getArgRef((int32_t)ip->iLoadParamLong.op2 - 1);
ip = NEXTINST(LoadParamLong);
DISPATCH;
}
O1REG(LoadParamLong) = HermesValue::encodeUndefinedValue();
ip = NEXTINST(LoadParamLong);
DISPATCH;
}

CASE(CoerceThisNS) {
if (LLVM_LIKELY(O2REG(CoerceThisNS).isObject())) {
O1REG(CoerceThisNS) = O2REG(CoerceThisNS);
} else if (
O2REG(CoerceThisNS).isNull() || O2REG(CoerceThisNS).isUndefined()) {
O1REG(CoerceThisNS) = runtime->global_;
} else {
tmpHandle = O2REG(CoerceThisNS);
nextIP = NEXTINST(CoerceThisNS);
goto coerceThisSlowPath;
}
ip = NEXTINST(CoerceThisNS);
DISPATCH;
}
CASE(LoadThisNS) {
if (LLVM_LIKELY(FRAME.getThisArgRef().isObject())) {
O1REG(LoadThisNS) = FRAME.getThisArgRef();
} else if (
FRAME.getThisArgRef().isNull() ||
FRAME.getThisArgRef().isUndefined()) {
O1REG(LoadThisNS) = runtime->global_;
} else {
tmpHandle = FRAME.getThisArgRef();
nextIP = NEXTINST(LoadThisNS);
goto coerceThisSlowPath;
}
ip = NEXTINST(LoadThisNS);
DISPATCH;
}
coerceThisSlowPath : {
CAPTURE_IP_ASSIGN(res, toObject(runtime, tmpHandle));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CoerceThisNS) = res.getValue();
tmpHandle.clear();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(ConstructLong) {
callArgCount = (uint32_t)ip->iConstructLong.op3;
nextIP = NEXTINST(ConstructLong);
callNewTarget = O2REG(ConstructLong).getRaw();
goto doCall;
}
CASE(CallLong) {
callArgCount = (uint32_t)ip->iCallLong.op3;
nextIP = NEXTINST(CallLong);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();
goto doCall;
}





CASE(Call1) {
callArgCount = 1;
nextIP = NEXTINST(Call1);
StackFramePtr fr{runtime->stackPointer_};
fr.getArgRefUnsafe(-1) = O3REG(Call1);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();
goto doCall;
}

CASE(Call2) {
callArgCount = 2;
nextIP = NEXTINST(Call2);
StackFramePtr fr{runtime->stackPointer_};
fr.getArgRefUnsafe(-1) = O3REG(Call2);
fr.getArgRefUnsafe(0) = O4REG(Call2);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();
goto doCall;
}

CASE(Call3) {
callArgCount = 3;
nextIP = NEXTINST(Call3);
StackFramePtr fr{runtime->stackPointer_};
fr.getArgRefUnsafe(-1) = O3REG(Call3);
fr.getArgRefUnsafe(0) = O4REG(Call3);
fr.getArgRefUnsafe(1) = O5REG(Call3);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();
goto doCall;
}

CASE(Call4) {
callArgCount = 4;
nextIP = NEXTINST(Call4);
StackFramePtr fr{runtime->stackPointer_};
fr.getArgRefUnsafe(-1) = O3REG(Call4);
fr.getArgRefUnsafe(0) = O4REG(Call4);
fr.getArgRefUnsafe(1) = O5REG(Call4);
fr.getArgRefUnsafe(2) = O6REG(Call4);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();
goto doCall;
}

CASE(Construct) {
callArgCount = (uint32_t)ip->iConstruct.op3;
nextIP = NEXTINST(Construct);
callNewTarget = O2REG(Construct).getRaw();
goto doCall;
}
CASE(Call) {
callArgCount = (uint32_t)ip->iCall.op3;
nextIP = NEXTINST(Call);
callNewTarget = HermesValue::encodeUndefinedValue().getRaw();

}

doCall : {
#ifdef HERMES_ENABLE_DEBUGGER

if (uint8_t asyncFlags =
runtime->testAndClearDebuggerAsyncBreakRequest()) {
RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);
gcScope.flushToSmallCount(KEEP_HANDLES);
DISPATCH;
}
#endif



CAPTURE_IP_ASSIGN_NO_INVALIDATE(
auto newFrame,
StackFramePtr::initFrame(
runtime->stackPointer_,
FRAME,
ip,
curCodeBlock,
callArgCount - 1,
O2REG(Call),
HermesValue::fromRaw(callNewTarget)));
(void)newFrame;

SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));

if (auto *func = dyn_vmcast<JSFunction>(O2REG(Call))) {
assert(!SingleStep && ""can't single-step a call"");

#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES
runtime->pushCallStack(curCodeBlock, ip);
#endif

CodeBlock *calleeBlock = func->getCodeBlock();
calleeBlock->lazyCompile(runtime);
#if defined(HERMESVM_PROFILER_EXTERN)
CAPTURE_IP_ASSIGN_NO_INVALIDATE(
res, runtime->interpretFunction(calleeBlock));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(Call) = *res;
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
#else
if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {
res = (*jitPtr)(runtime);
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))
goto exception;
O1REG(Call) = *res;
SLOW_DEBUG(
dbgs() << ""JIT return value r"" << (unsigned)ip->iCall.op1 << ""=""
<< DumpHermesValue(O1REG(Call)) << ""\n"");
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}
curCodeBlock = calleeBlock;
goto tailCall;
#endif
}
CAPTURE_IP_ASSIGN_NO_INVALIDATE(
resPH, Interpreter::handleCallSlowPath(runtime, &O2REG(Call)));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(Call) = std::move(resPH->get());
SLOW_DEBUG(
dbgs() << ""native return value r"" << (unsigned)ip->iCall.op1 << ""=""
<< DumpHermesValue(O1REG(Call)) << ""\n"");
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(CallDirect)
CASE(CallDirectLongIndex) {
#ifdef HERMES_ENABLE_DEBUGGER

if (uint8_t asyncFlags =
runtime->testAndClearDebuggerAsyncBreakRequest()) {
RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);
gcScope.flushToSmallCount(KEEP_HANDLES);
DISPATCH;
}
#endif

CAPTURE_IP_ASSIGN(
CodeBlock * calleeBlock,
ip->opCode == OpCode::CallDirect
? curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(
ip->iCallDirect.op3)
: curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(
ip->iCallDirectLongIndex.op3));

CAPTURE_IP_ASSIGN_NO_INVALIDATE(
auto newFrame,
StackFramePtr::initFrame(
runtime->stackPointer_,
FRAME,
ip,
curCodeBlock,
(uint32_t)ip->iCallDirect.op2 - 1,
HermesValue::encodeNativePointer(calleeBlock),
HermesValue::encodeUndefinedValue()));
(void)newFrame;

LLVM_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));

assert(!SingleStep && ""can't single-step a call"");

calleeBlock->lazyCompile(runtime);
#if defined(HERMESVM_PROFILER_EXTERN)
CAPTURE_IP_ASSIGN_NO_INVALIDATE(
res, runtime->interpretFunction(calleeBlock));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CallDirect) = *res;
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)
: NEXTINST(CallDirectLongIndex);
DISPATCH;
#else
if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {
res = (*jitPtr)(runtime);
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))
goto exception;
O1REG(CallDirect) = *res;
LLVM_DEBUG(
dbgs() << ""JIT return value r"" << (unsigned)ip->iCallDirect.op1
<< ""="" << DumpHermesValue(O1REG(Call)) << ""\n"");
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)
: NEXTINST(CallDirectLongIndex);
DISPATCH;
}
curCodeBlock = calleeBlock;
goto tailCall;
#endif
}

CASE(CallBuiltin) {
NativeFunction *nf =
runtime->getBuiltinNativeFunction(ip->iCallBuiltin.op2);

CAPTURE_IP_ASSIGN(
auto newFrame,
StackFramePtr::initFrame(
runtime->stackPointer_,
FRAME,
ip,
curCodeBlock,
(uint32_t)ip->iCallBuiltin.op3 - 1,
nf,
false));

newFrame.getThisArgRef() = HermesValue::encodeUndefinedValue();

SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));

CAPTURE_IP_ASSIGN(resPH, NativeFunction::_nativeCall(nf, runtime));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION))
goto exception;
O1REG(CallBuiltin) = std::move(resPH->get());
SLOW_DEBUG(
dbgs() << ""native return value r"" << (unsigned)ip->iCallBuiltin.op1
<< ""="" << DumpHermesValue(O1REG(CallBuiltin)) << ""\n"");
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CallBuiltin);
DISPATCH;
}

CASE(CompleteGenerator) {
auto *innerFn = vmcast<GeneratorInnerFunction>(
runtime->getCurrentFrame().getCalleeClosure());
innerFn->setState(GeneratorInnerFunction::State::Completed);
ip = NEXTINST(CompleteGenerator);
DISPATCH;
}

CASE(SaveGenerator) {
nextIP = IPADD(ip->iSaveGenerator.op1);
goto doSaveGen;
}
CASE(SaveGeneratorLong) {
nextIP = IPADD(ip->iSaveGeneratorLong.op1);
goto doSaveGen;
}

doSaveGen : {
auto *innerFn = vmcast<GeneratorInnerFunction>(
runtime->getCurrentFrame().getCalleeClosure());

innerFn->saveStack(runtime);
innerFn->setNextIP(nextIP);
innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);
ip = NEXTINST(SaveGenerator);
DISPATCH;
}

CASE(StartGenerator) {
auto *innerFn = vmcast<GeneratorInnerFunction>(
runtime->getCurrentFrame().getCalleeClosure());
if (innerFn->getState() ==
GeneratorInnerFunction::State::SuspendedStart) {
nextIP = NEXTINST(StartGenerator);
} else {
nextIP = innerFn->getNextIP();
innerFn->restoreStack(runtime);
}
innerFn->setState(GeneratorInnerFunction::State::Executing);
ip = nextIP;
DISPATCH;
}

CASE(ResumeGenerator) {
auto *innerFn = vmcast<GeneratorInnerFunction>(
runtime->getCurrentFrame().getCalleeClosure());
O1REG(ResumeGenerator) = innerFn->getResult();
O2REG(ResumeGenerator) = HermesValue::encodeBoolValue(
innerFn->getAction() == GeneratorInnerFunction::Action::Return);
innerFn->clearResult(runtime);
if (innerFn->getAction() == GeneratorInnerFunction::Action::Throw) {
runtime->setThrownValue(O1REG(ResumeGenerator));
goto exception;
}
ip = NEXTINST(ResumeGenerator);
DISPATCH;
}

CASE(Ret) {
#ifdef HERMES_ENABLE_DEBUGGER

if (uint8_t asyncFlags =
runtime->testAndClearDebuggerAsyncBreakRequest()) {
RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);
gcScope.flushToSmallCount(KEEP_HANDLES);
DISPATCH;
}
#endif

PROFILER_EXIT_FUNCTION(curCodeBlock);

#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES
runtime->popCallStack();
#endif


res = O1REG(Ret);

ip = FRAME.getSavedIP();
curCodeBlock = FRAME.getSavedCodeBlock();

frameRegs =
&runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();

SLOW_DEBUG(
dbgs() << ""function exit: restored stackLevel=""
<< runtime->getStackLevel() << ""\n"");


if (!curCodeBlock) {
SLOW_DEBUG(dbgs() << ""function exit: returning to native code\n"");
return res;
}


#if defined(HERMESVM_PROFILER_EXTERN)
return res;
#endif

INIT_STATE_FOR_CODEBLOCK(curCodeBlock);
O1REG(Call) = res.getValue();
ip = nextInstCall(ip);
DISPATCH;
}

CASE(Catch) {
assert(!runtime->thrownValue_.isEmpty() && ""Invalid thrown value"");
assert(
!isUncatchableError(runtime->thrownValue_) &&
""Uncatchable thrown value was caught"");
O1REG(Catch) = runtime->thrownValue_;
runtime->clearThrownValue();
#ifdef HERMES_ENABLE_DEBUGGER


runtime->debugger_.finishedUnwindingException();
#endif
ip = NEXTINST(Catch);
DISPATCH;
}

CASE(Throw) {
runtime->thrownValue_ = O1REG(Throw);
SLOW_DEBUG(
dbgs() << ""Exception thrown: ""
<< DumpHermesValue(runtime->thrownValue_) << ""\n"");
goto exception;
}

CASE(ThrowIfUndefinedInst) {
if (LLVM_UNLIKELY(O1REG(ThrowIfUndefinedInst).isUndefined())) {
SLOW_DEBUG(
dbgs() << ""Throwing ReferenceError for undefined variable"");
CAPTURE_IP(runtime->raiseReferenceError(
""accessing an uninitialized variable""));
goto exception;
}
ip = NEXTINST(ThrowIfUndefinedInst);
DISPATCH;
}

CASE(Debugger) {
SLOW_DEBUG(dbgs() << ""debugger statement executed\n"");
#ifdef HERMES_ENABLE_DEBUGGER
{
if (!runtime->debugger_.isDebugging()) {


CAPTURE_IP_ASSIGN(
auto res,
runDebuggerUpdatingState(
Debugger::RunReason::Opcode,
runtime,
curCodeBlock,
ip,
frameRegs));
if (res == ExecutionStatus::EXCEPTION) {






goto exception;
}
}
auto breakpointOpt = runtime->debugger_.getBreakpointLocation(ip);
if (breakpointOpt.hasValue()) {

curCodeBlock->uninstallBreakpointAtOffset(
CUROFFSET, breakpointOpt->opCode);
if (ip->opCode == OpCode::Debugger) {


ip = NEXTINST(Debugger);
} else {
InterpreterState newState{curCodeBlock, (uint32_t)CUROFFSET};
CAPTURE_IP_ASSIGN(
ExecutionStatus status, runtime->stepFunction(newState));
curCodeBlock->installBreakpointAtOffset(CUROFFSET);
if (status == ExecutionStatus::EXCEPTION) {
goto exception;
}
curCodeBlock = newState.codeBlock;
ip = newState.codeBlock->getOffsetPtr(newState.offset);
INIT_STATE_FOR_CODEBLOCK(curCodeBlock);

frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();
}
} else if (ip->opCode == OpCode::Debugger) {




ip = NEXTINST(Debugger);
}
gcScope.flushToSmallCount(KEEP_HANDLES);
}
DISPATCH;
#else
ip = NEXTINST(Debugger);
DISPATCH;
#endif
}

CASE(AsyncBreakCheck) {
if (LLVM_UNLIKELY(runtime->hasAsyncBreak())) {
#ifdef HERMES_ENABLE_DEBUGGER
if (uint8_t asyncFlags =
runtime->testAndClearDebuggerAsyncBreakRequest()) {
RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);
}
#endif
if (runtime->testAndClearTimeoutAsyncBreakRequest()) {
CAPTURE_IP_ASSIGN(auto nRes, runtime->notifyTimeout());
if (nRes == ExecutionStatus::EXCEPTION) {
goto exception;
}
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);

ip = NEXTINST(AsyncBreakCheck);
DISPATCH;
}

CASE(ProfilePoint) {
#ifdef HERMESVM_PROFILER_BB
auto pointIndex = ip->iProfilePoint.op1;
SLOW_DEBUG(llvh::dbgs() << ""ProfilePoint: "" << pointIndex << ""\n"");
CAPTURE_IP(runtime->getBasicBlockExecutionInfo().executeBlock(
curCodeBlock, pointIndex));
#endif
ip = NEXTINST(ProfilePoint);
DISPATCH;
}

CASE(Unreachable) {
llvm_unreachable(""Hermes bug: unreachable instruction"");
}

CASE(CreateClosure) {
idVal = ip->iCreateClosure.op3;
nextIP = NEXTINST(CreateClosure);
goto createClosure;
}
CASE(CreateClosureLongIndex) {
idVal = ip->iCreateClosureLongIndex.op3;
nextIP = NEXTINST(CreateClosureLongIndex);
goto createClosure;
}
createClosure : {
auto *runtimeModule = curCodeBlock->getRuntimeModule();
CAPTURE_IP_ASSIGN(
O1REG(CreateClosure),
JSFunction::create(
runtime,
runtimeModule->getDomain(runtime),
Handle<JSObject>::vmcast(&runtime->functionPrototype),
Handle<Environment>::vmcast(&O2REG(CreateClosure)),
runtimeModule->getCodeBlockMayAllocate(idVal))
.getHermesValue());
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(CreateGeneratorClosure) {
CAPTURE_IP_ASSIGN(
auto res,
createGeneratorClosure(
runtime,
curCodeBlock->getRuntimeModule(),
ip->iCreateClosure.op3,
Handle<Environment>::vmcast(&O2REG(CreateGeneratorClosure))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CreateGeneratorClosure) = res->getHermesValue();
res->invalidate();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateGeneratorClosure);
DISPATCH;
}
CASE(CreateGeneratorClosureLongIndex) {
CAPTURE_IP_ASSIGN(
auto res,
createGeneratorClosure(
runtime,
curCodeBlock->getRuntimeModule(),
ip->iCreateClosureLongIndex.op3,
Handle<Environment>::vmcast(
&O2REG(CreateGeneratorClosureLongIndex))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CreateGeneratorClosureLongIndex) = res->getHermesValue();
res->invalidate();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateGeneratorClosureLongIndex);
DISPATCH;
}

CASE(CreateGenerator) {
CAPTURE_IP_ASSIGN(
auto res,
createGenerator_RJS(
runtime,
curCodeBlock->getRuntimeModule(),
ip->iCreateGenerator.op3,
Handle<Environment>::vmcast(&O2REG(CreateGenerator)),
FRAME.getNativeArgs()));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CreateGenerator) = res->getHermesValue();
res->invalidate();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateGenerator);
DISPATCH;
}
CASE(CreateGeneratorLongIndex) {
CAPTURE_IP_ASSIGN(
auto res,
createGenerator_RJS(
runtime,
curCodeBlock->getRuntimeModule(),
ip->iCreateGeneratorLongIndex.op3,
Handle<Environment>::vmcast(&O2REG(CreateGeneratorLongIndex)),
FRAME.getNativeArgs()));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(CreateGeneratorLongIndex) = res->getHermesValue();
res->invalidate();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateGeneratorLongIndex);
DISPATCH;
}

CASE(GetEnvironment) {

Environment *curEnv =
FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime);
for (unsigned level = ip->iGetEnvironment.op2; level; --level) {
assert(curEnv && ""invalid environment relative level"");
curEnv = curEnv->getParentEnvironment(runtime);
}
O1REG(GetEnvironment) = HermesValue::encodeObjectValue(curEnv);
ip = NEXTINST(GetEnvironment);
DISPATCH;
}

CASE(CreateEnvironment) {
tmpHandle = HermesValue::encodeObjectValue(
FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime));

CAPTURE_IP_ASSIGN(
res,
Environment::create(
runtime,
tmpHandle->getPointer() ? Handle<Environment>::vmcast(tmpHandle)
: Handle<Environment>::vmcast_or_null(
&runtime->nullPointer_),
curCodeBlock->getEnvironmentSize()));
if (res == ExecutionStatus::EXCEPTION) {
goto exception;
}
O1REG(CreateEnvironment) = *res;
#ifdef HERMES_ENABLE_DEBUGGER
FRAME.getDebugEnvironmentRef() = *res;
#endif
tmpHandle = HermesValue::encodeUndefinedValue();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateEnvironment);
DISPATCH;
}

CASE(StoreToEnvironment) {
vmcast<Environment>(O1REG(StoreToEnvironment))
->slot(ip->iStoreToEnvironment.op2)
.set(O3REG(StoreToEnvironment), &runtime->getHeap());
ip = NEXTINST(StoreToEnvironment);
DISPATCH;
}
CASE(StoreToEnvironmentL) {
vmcast<Environment>(O1REG(StoreToEnvironmentL))
->slot(ip->iStoreToEnvironmentL.op2)
.set(O3REG(StoreToEnvironmentL), &runtime->getHeap());
ip = NEXTINST(StoreToEnvironmentL);
DISPATCH;
}

CASE(StoreNPToEnvironment) {
vmcast<Environment>(O1REG(StoreNPToEnvironment))
->slot(ip->iStoreNPToEnvironment.op2)
.setNonPtr(O3REG(StoreNPToEnvironment), &runtime->getHeap());
ip = NEXTINST(StoreNPToEnvironment);
DISPATCH;
}
CASE(StoreNPToEnvironmentL) {
vmcast<Environment>(O1REG(StoreNPToEnvironmentL))
->slot(ip->iStoreNPToEnvironmentL.op2)
.setNonPtr(O3REG(StoreNPToEnvironmentL), &runtime->getHeap());
ip = NEXTINST(StoreNPToEnvironmentL);
DISPATCH;
}

CASE(LoadFromEnvironment) {
O1REG(LoadFromEnvironment) =
vmcast<Environment>(O2REG(LoadFromEnvironment))
->slot(ip->iLoadFromEnvironment.op3);
ip = NEXTINST(LoadFromEnvironment);
DISPATCH;
}

CASE(LoadFromEnvironmentL) {
O1REG(LoadFromEnvironmentL) =
vmcast<Environment>(O2REG(LoadFromEnvironmentL))
->slot(ip->iLoadFromEnvironmentL.op3);
ip = NEXTINST(LoadFromEnvironmentL);
DISPATCH;
}

CASE(GetGlobalObject) {
O1REG(GetGlobalObject) = runtime->global_;
ip = NEXTINST(GetGlobalObject);
DISPATCH;
}

CASE(GetNewTarget) {
O1REG(GetNewTarget) = FRAME.getNewTargetRef();
ip = NEXTINST(GetNewTarget);
DISPATCH;
}

CASE(DeclareGlobalVar) {
DefinePropertyFlags dpf =
DefinePropertyFlags::getDefaultNewPropertyFlags();
dpf.configurable = 0;

dpf.setValue = 0;

CAPTURE_IP_ASSIGN(
auto res,
JSObject::defineOwnProperty(
runtime->getGlobal(),
runtime,
ID(ip->iDeclareGlobalVar.op1),
dpf,
Runtime::getUndefinedValue(),
PropOpFlags().plusThrowOnError()));
if (res == ExecutionStatus::EXCEPTION) {
assert(
!runtime->getGlobal()->isProxyObject() &&
""global can't be a proxy object"");






NamedPropertyDescriptor desc;
CAPTURE_IP_ASSIGN(
auto res,
JSObject::getOwnNamedDescriptor(
runtime->getGlobal(),
runtime,
ID(ip->iDeclareGlobalVar.op1),
desc));
if (!res) {
goto exception;
} else {
runtime->clearThrownValue();
}

}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(DeclareGlobalVar);
DISPATCH;
}

CASE(TryGetByIdLong) {
tryProp = true;
idVal = ip->iTryGetByIdLong.op4;
nextIP = NEXTINST(TryGetByIdLong);
goto getById;
}
CASE(GetByIdLong) {
tryProp = false;
idVal = ip->iGetByIdLong.op4;
nextIP = NEXTINST(GetByIdLong);
goto getById;
}
CASE(GetByIdShort) {
tryProp = false;
idVal = ip->iGetByIdShort.op4;
nextIP = NEXTINST(GetByIdShort);
goto getById;
}
CASE(TryGetById) {
tryProp = true;
idVal = ip->iTryGetById.op4;
nextIP = NEXTINST(TryGetById);
goto getById;
}
CASE(GetById) {
tryProp = false;
idVal = ip->iGetById.op4;
nextIP = NEXTINST(GetById);
}
getById : {
++NumGetById;



CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};
if (LLVM_LIKELY(O2REG(GetById).isObject())) {
auto *obj = vmcast<JSObject>(O2REG(GetById));
auto cacheIdx = ip->iGetById.op3;
auto *cacheEntry = curCodeBlock->getReadCacheEntry(cacheIdx);

#ifdef HERMESVM_PROFILER_BB
{
HERMES_SLOW_ASSERT(
gcScope.getHandleCountDbg() == KEEP_HANDLES &&
""unaccounted handles were created"");
auto objHandle = runtime->makeHandle(obj);
auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(
cacheEntry->clazz.get(runtime, &runtime->getHeap())));
CAPTURE_IP(runtime->recordHiddenClass(
curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));

obj = objHandle.get();
}
gcScope.flushToSmallCount(KEEP_HANDLES);
#endif
auto clazzGCPtr = obj->getClassGCPtr();
#ifndef NDEBUG
if (clazzGCPtr.get(runtime)->isDictionary())
++NumGetByIdDict;
#else
(void)NumGetByIdDict;
#endif



if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {
++NumGetByIdCacheHits;
CAPTURE_IP_ASSIGN(
O1REG(GetById),
JSObject::getNamedSlotValue<PropStorage::Inline::Yes>(
obj, runtime, cacheEntry->slot));
ip = nextIP;
DISPATCH;
}
auto id = ID(idVal);
NamedPropertyDescriptor desc;
CAPTURE_IP_ASSIGN(
OptValue<bool> fastPathResult,
JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));
if (LLVM_LIKELY(
fastPathResult.hasValue() && fastPathResult.getValue()) &&
!desc.flags.accessor) {
++NumGetByIdFastPaths;



auto *clazz = clazzGCPtr.getNonNull(runtime);
if (LLVM_LIKELY(!clazz->isDictionaryNoCache()) &&
LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {
#ifdef HERMES_SLOW_DEBUG
if (cacheEntry->clazz &&
cacheEntry->clazz != clazzGCPtr.getStorageType())
++NumGetByIdCacheEvicts;
#else
(void)NumGetByIdCacheEvicts;
#endif

cacheEntry->clazz = clazzGCPtr.getStorageType();
cacheEntry->slot = desc.slot;
}

CAPTURE_IP_ASSIGN(
O1REG(GetById), JSObject::getNamedSlotValue(obj, runtime, desc));
ip = nextIP;
DISPATCH;
}




if (fastPathResult.hasValue() && !fastPathResult.getValue() &&
!obj->isProxyObject()) {
CAPTURE_IP_ASSIGN(JSObject * parent, obj->getParent(runtime));




if (parent &&
cacheEntry->clazz == parent->getClassGCPtr().getStorageType() &&
LLVM_LIKELY(!obj->isLazy())) {
++NumGetByIdProtoHits;
CAPTURE_IP_ASSIGN(
O1REG(GetById),
JSObject::getNamedSlotValue(parent, runtime, cacheEntry->slot));
ip = nextIP;
DISPATCH;
}
}

#ifdef HERMES_SLOW_DEBUG
CAPTURE_IP_ASSIGN(
JSObject * propObj,
JSObject::getNamedDescriptor(
Handle<JSObject>::vmcast(&O2REG(GetById)), runtime, id, desc));
if (propObj) {
if (desc.flags.accessor)
++NumGetByIdAccessor;
else if (propObj != vmcast<JSObject>(O2REG(GetById)))
++NumGetByIdProto;
} else {
++NumGetByIdNotFound;
}
#else
(void)NumGetByIdAccessor;
(void)NumGetByIdProto;
(void)NumGetByIdNotFound;
#endif
#ifdef HERMES_SLOW_DEBUG
auto *savedClass = cacheIdx != hbc::PROPERTY_CACHING_DISABLED
? cacheEntry->clazz.get(runtime, &runtime->getHeap())
: nullptr;
#endif
++NumGetByIdSlow;
CAPTURE_IP_ASSIGN(
resPH,
JSObject::getNamed_RJS(
Handle<JSObject>::vmcast(&O2REG(GetById)),
runtime,
id,
!tryProp ? defaultPropOpFlags
: defaultPropOpFlags.plusMustExist(),
cacheIdx != hbc::PROPERTY_CACHING_DISABLED ? cacheEntry
: nullptr));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
#ifdef HERMES_SLOW_DEBUG
if (cacheIdx != hbc::PROPERTY_CACHING_DISABLED && savedClass &&
cacheEntry->clazz.get(runtime, &runtime->getHeap()) != savedClass) {
++NumGetByIdCacheEvicts;
}
#endif
} else {
++NumGetByIdTransient;
assert(!tryProp && ""TryGetById can only be used on the global object"");

CAPTURE_IP_ASSIGN(
resPH,
Interpreter::getByIdTransient_RJS(
runtime, Handle<>(&O2REG(GetById)), ID(idVal)));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
}
O1REG(GetById) = resPH->get();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(TryPutByIdLong) {
tryProp = true;
idVal = ip->iTryPutByIdLong.op4;
nextIP = NEXTINST(TryPutByIdLong);
goto putById;
}
CASE(PutByIdLong) {
tryProp = false;
idVal = ip->iPutByIdLong.op4;
nextIP = NEXTINST(PutByIdLong);
goto putById;
}
CASE(TryPutById) {
tryProp = true;
idVal = ip->iTryPutById.op4;
nextIP = NEXTINST(TryPutById);
goto putById;
}
CASE(PutById) {
tryProp = false;
idVal = ip->iPutById.op4;
nextIP = NEXTINST(PutById);
}
putById : {
++NumPutById;
if (LLVM_LIKELY(O1REG(PutById).isObject())) {
auto *obj = vmcast<JSObject>(O1REG(PutById));
auto cacheIdx = ip->iPutById.op3;
auto *cacheEntry = curCodeBlock->getWriteCacheEntry(cacheIdx);

#ifdef HERMESVM_PROFILER_BB
{
HERMES_SLOW_ASSERT(
gcScope.getHandleCountDbg() == KEEP_HANDLES &&
""unaccounted handles were created"");
auto objHandle = runtime->makeHandle(obj);
auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(
cacheEntry->clazz.get(runtime, &runtime->getHeap())));
CAPTURE_IP(runtime->recordHiddenClass(
curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));

obj = objHandle.get();
}
gcScope.flushToSmallCount(KEEP_HANDLES);
#endif
auto clazzGCPtr = obj->getClassGCPtr();


if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {
++NumPutByIdCacheHits;
CAPTURE_IP(JSObject::setNamedSlotValue<PropStorage::Inline::Yes>(
obj, runtime, cacheEntry->slot, O2REG(PutById)));
ip = nextIP;
DISPATCH;
}
auto id = ID(idVal);
NamedPropertyDescriptor desc;
CAPTURE_IP_ASSIGN(
OptValue<bool> hasOwnProp,
JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));
if (LLVM_LIKELY(hasOwnProp.hasValue() && hasOwnProp.getValue()) &&
!desc.flags.accessor && desc.flags.writable &&
!desc.flags.internalSetter) {
++NumPutByIdFastPaths;



auto *clazz = clazzGCPtr.getNonNull(runtime);
if (LLVM_LIKELY(!clazz->isDictionary()) &&
LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {
#ifdef HERMES_SLOW_DEBUG
if (cacheEntry->clazz &&
cacheEntry->clazz != clazzGCPtr.getStorageType())
++NumPutByIdCacheEvicts;
#else
(void)NumPutByIdCacheEvicts;
#endif

cacheEntry->clazz = clazzGCPtr.getStorageType();
cacheEntry->slot = desc.slot;
}

CAPTURE_IP(JSObject::setNamedSlotValue(
obj, runtime, desc.slot, O2REG(PutById)));
ip = nextIP;
DISPATCH;
}

CAPTURE_IP_ASSIGN(
auto putRes,
JSObject::putNamed_RJS(
Handle<JSObject>::vmcast(&O1REG(PutById)),
runtime,
id,
Handle<>(&O2REG(PutById)),
!tryProp ? defaultPropOpFlags
: defaultPropOpFlags.plusMustExist()));
if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {
goto exception;
}
} else {
++NumPutByIdTransient;
assert(!tryProp && ""TryPutById can only be used on the global object"");
CAPTURE_IP_ASSIGN(
auto retStatus,
Interpreter::putByIdTransient_RJS(
runtime,
Handle<>(&O1REG(PutById)),
ID(idVal),
Handle<>(&O2REG(PutById)),
strictMode));
if (retStatus == ExecutionStatus::EXCEPTION) {
goto exception;
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(GetByVal) {
CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};
if (LLVM_LIKELY(O2REG(GetByVal).isObject())) {
CAPTURE_IP_ASSIGN(
resPH,
JSObject::getComputed_RJS(
Handle<JSObject>::vmcast(&O2REG(GetByVal)),
runtime,
Handle<>(&O3REG(GetByVal))));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
} else {

CAPTURE_IP_ASSIGN(
resPH,
Interpreter::getByValTransient_RJS(
runtime,
Handle<>(&O2REG(GetByVal)),
Handle<>(&O3REG(GetByVal))));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(GetByVal) = resPH->get();
ip = NEXTINST(GetByVal);
DISPATCH;
}

CASE(PutByVal) {
if (LLVM_LIKELY(O1REG(PutByVal).isObject())) {
CAPTURE_IP_ASSIGN(
auto putRes,
JSObject::putComputed_RJS(
Handle<JSObject>::vmcast(&O1REG(PutByVal)),
runtime,
Handle<>(&O2REG(PutByVal)),
Handle<>(&O3REG(PutByVal)),
defaultPropOpFlags));
if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {
goto exception;
}
} else {

CAPTURE_IP_ASSIGN(
auto retStatus,
Interpreter::putByValTransient_RJS(
runtime,
Handle<>(&O1REG(PutByVal)),
Handle<>(&O2REG(PutByVal)),
Handle<>(&O3REG(PutByVal)),
strictMode));
if (LLVM_UNLIKELY(retStatus == ExecutionStatus::EXCEPTION)) {
goto exception;
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(PutByVal);
DISPATCH;
}

CASE(PutOwnByIndexL) {
nextIP = NEXTINST(PutOwnByIndexL);
idVal = ip->iPutOwnByIndexL.op3;
goto putOwnByIndex;
}
CASE(PutOwnByIndex) {
nextIP = NEXTINST(PutOwnByIndex);
idVal = ip->iPutOwnByIndex.op3;
}
putOwnByIndex : {
tmpHandle = HermesValue::encodeDoubleValue(idVal);
CAPTURE_IP(JSObject::defineOwnComputedPrimitive(
Handle<JSObject>::vmcast(&O1REG(PutOwnByIndex)),
runtime,
tmpHandle,
DefinePropertyFlags::getDefaultNewPropertyFlags(),
Handle<>(&O2REG(PutOwnByIndex))));
gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();
ip = nextIP;
DISPATCH;
}

CASE(GetPNameList) {
CAPTURE_IP_ASSIGN(
auto pRes, handleGetPNameList(runtime, frameRegs, ip));
if (LLVM_UNLIKELY(pRes == ExecutionStatus::EXCEPTION)) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(GetPNameList);
DISPATCH;
}

CASE(GetNextPName) {
{
assert(
vmisa<BigStorage>(O2REG(GetNextPName)) &&
""GetNextPName's second op must be BigStorage"");
auto obj = Handle<JSObject>::vmcast(&O3REG(GetNextPName));
auto arr = Handle<BigStorage>::vmcast(&O2REG(GetNextPName));
uint32_t idx = O4REG(GetNextPName).getNumber();
uint32_t size = O5REG(GetNextPName).getNumber();
MutableHandle<JSObject> propObj{runtime};

while (idx < size) {
tmpHandle = arr->at(idx);
ComputedPropertyDescriptor desc;
CAPTURE_IP(JSObject::getComputedPrimitiveDescriptor(
obj, runtime, tmpHandle, propObj, desc));
if (LLVM_LIKELY(propObj))
break;
++idx;
}
if (idx < size) {

if (tmpHandle->isNumber()) {
CAPTURE_IP_ASSIGN(auto status, toString_RJS(runtime, tmpHandle));
assert(
status == ExecutionStatus::RETURNED &&
""toString on number cannot fail"");
tmpHandle = status->getHermesValue();
}
O1REG(GetNextPName) = tmpHandle.get();
O4REG(GetNextPName) = HermesValue::encodeNumberValue(idx + 1);
} else {
O1REG(GetNextPName) = HermesValue::encodeUndefinedValue();
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();
ip = NEXTINST(GetNextPName);
DISPATCH;
}

CASE(ToNumber) {
if (LLVM_LIKELY(O2REG(ToNumber).isNumber())) {
O1REG(ToNumber) = O2REG(ToNumber);
ip = NEXTINST(ToNumber);
} else {
CAPTURE_IP_ASSIGN(
res, toNumber_RJS(runtime, Handle<>(&O2REG(ToNumber))));
if (res == ExecutionStatus::EXCEPTION)
goto exception;
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(ToNumber) = res.getValue();
ip = NEXTINST(ToNumber);
}
DISPATCH;
}

CASE(ToInt32) {
CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(ToInt32))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))
goto exception;
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(ToInt32) = res.getValue();
ip = NEXTINST(ToInt32);
DISPATCH;
}

CASE(AddEmptyString) {
if (LLVM_LIKELY(O2REG(AddEmptyString).isString())) {
O1REG(AddEmptyString) = O2REG(AddEmptyString);
ip = NEXTINST(AddEmptyString);
} else {
CAPTURE_IP_ASSIGN(
res,
toPrimitive_RJS(
runtime,
Handle<>(&O2REG(AddEmptyString)),
PreferredType::NONE));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))
goto exception;
tmpHandle = res.getValue();
CAPTURE_IP_ASSIGN(auto strRes, toString_RJS(runtime, tmpHandle));
if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION))
goto exception;
tmpHandle.clear();
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(AddEmptyString) = strRes->getHermesValue();
ip = NEXTINST(AddEmptyString);
}
DISPATCH;
}

CASE(Jmp) {
ip = IPADD(ip->iJmp.op1);
DISPATCH;
}
CASE(JmpLong) {
ip = IPADD(ip->iJmpLong.op1);
DISPATCH;
}
CASE(JmpTrue) {
if (toBoolean(O2REG(JmpTrue)))
ip = IPADD(ip->iJmpTrue.op1);
else
ip = NEXTINST(JmpTrue);
DISPATCH;
}
CASE(JmpTrueLong) {
if (toBoolean(O2REG(JmpTrueLong)))
ip = IPADD(ip->iJmpTrueLong.op1);
else
ip = NEXTINST(JmpTrueLong);
DISPATCH;
}
CASE(JmpFalse) {
if (!toBoolean(O2REG(JmpFalse)))
ip = IPADD(ip->iJmpFalse.op1);
else
ip = NEXTINST(JmpFalse);
DISPATCH;
}
CASE(JmpFalseLong) {
if (!toBoolean(O2REG(JmpFalseLong)))
ip = IPADD(ip->iJmpFalseLong.op1);
else
ip = NEXTINST(JmpFalseLong);
DISPATCH;
}
CASE(JmpUndefined) {
if (O2REG(JmpUndefined).isUndefined())
ip = IPADD(ip->iJmpUndefined.op1);
else
ip = NEXTINST(JmpUndefined);
DISPATCH;
}
CASE(JmpUndefinedLong) {
if (O2REG(JmpUndefinedLong).isUndefined())
ip = IPADD(ip->iJmpUndefinedLong.op1);
else
ip = NEXTINST(JmpUndefinedLong);
DISPATCH;
}
CASE(Add) {
if (LLVM_LIKELY(
O2REG(Add).isNumber() &&
O3REG(Add).isNumber())) {
CASE(AddN) {
O1REG(Add) = HermesValue::encodeDoubleValue(
O2REG(Add).getNumber() + O3REG(Add).getNumber());
ip = NEXTINST(Add);
DISPATCH;
}
}
CAPTURE_IP_ASSIGN(
res,
addOp_RJS(runtime, Handle<>(&O2REG(Add)), Handle<>(&O3REG(Add))));
if (res == ExecutionStatus::EXCEPTION) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(Add) = res.getValue();
ip = NEXTINST(Add);
DISPATCH;
}

CASE(BitNot) {
if (LLVM_LIKELY(O2REG(BitNot).isNumber())) {
O1REG(BitNot) = HermesValue::encodeDoubleValue(
~hermes::truncateToInt32(O2REG(BitNot).getNumber()));
ip = NEXTINST(BitNot);
DISPATCH;
}
CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(BitNot))));
if (res == ExecutionStatus::EXCEPTION) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(BitNot) = HermesValue::encodeDoubleValue(
~static_cast<int32_t>(res->getNumber()));
ip = NEXTINST(BitNot);
DISPATCH;
}

CASE(GetArgumentsLength) {

if (O2REG(GetArgumentsLength).isUndefined()) {
O1REG(GetArgumentsLength) =
HermesValue::encodeNumberValue(FRAME.getArgCount());
ip = NEXTINST(GetArgumentsLength);
DISPATCH;
}


assert(
O2REG(GetArgumentsLength).isObject() &&
""arguments lazy register is not an object"");
CAPTURE_IP_ASSIGN(
resPH,
JSObject::getNamed_RJS(
Handle<JSObject>::vmcast(&O2REG(GetArgumentsLength)),
runtime,
Predefined::getSymbolID(Predefined::length)));
if (resPH == ExecutionStatus::EXCEPTION) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(GetArgumentsLength) = resPH->get();
ip = NEXTINST(GetArgumentsLength);
DISPATCH;
}

CASE(GetArgumentsPropByVal) {


if (O3REG(GetArgumentsPropByVal).isUndefined()) {

if (auto index = toArrayIndexFastPath(O2REG(GetArgumentsPropByVal))) {

if (*index < FRAME.getArgCount()) {
O1REG(GetArgumentsPropByVal) = FRAME.getArgRef(*index);
ip = NEXTINST(GetArgumentsPropByVal);
DISPATCH;
}
}
}

CAPTURE_IP_ASSIGN(
auto res,
getArgumentsPropByValSlowPath_RJS(
runtime,
&O3REG(GetArgumentsPropByVal),
&O2REG(GetArgumentsPropByVal),
FRAME.getCalleeClosureHandleUnsafe(),
strictMode));
if (res == ExecutionStatus::EXCEPTION) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(GetArgumentsPropByVal) = res->getHermesValue();
ip = NEXTINST(GetArgumentsPropByVal);
DISPATCH;
}

CASE(ReifyArguments) {

if (!O1REG(ReifyArguments).isUndefined()) {
assert(
O1REG(ReifyArguments).isObject() &&
""arguments lazy register is not an object"");
ip = NEXTINST(ReifyArguments);
DISPATCH;
}
CAPTURE_IP_ASSIGN(
resArgs,
reifyArgumentsSlowPath(
runtime, FRAME.getCalleeClosureHandleUnsafe(), strictMode));
if (LLVM_UNLIKELY(resArgs == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(ReifyArguments) = resArgs->getHermesValue();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(ReifyArguments);
DISPATCH;
}

CASE(NewObject) {



CAPTURE_IP_ASSIGN(
O1REG(NewObject), JSObject::create(runtime).getHermesValue());
assert(
gcScope.getHandleCountDbg() == KEEP_HANDLES &&
""Should not create handles."");
ip = NEXTINST(NewObject);
DISPATCH;
}
CASE(NewObjectWithParent) {
CAPTURE_IP_ASSIGN(
O1REG(NewObjectWithParent),
JSObject::create(
runtime,
O2REG(NewObjectWithParent).isObject()
? Handle<JSObject>::vmcast(&O2REG(NewObjectWithParent))
: O2REG(NewObjectWithParent).isNull()
? Runtime::makeNullHandle<JSObject>()
: Handle<JSObject>::vmcast(&runtime->objectPrototype))
.getHermesValue());
assert(
gcScope.getHandleCountDbg() == KEEP_HANDLES &&
""Should not create handles."");
ip = NEXTINST(NewObjectWithParent);
DISPATCH;
}

CASE(NewObjectWithBuffer) {
CAPTURE_IP_ASSIGN(
resPH,
Interpreter::createObjectFromBuffer(
runtime,
curCodeBlock,
ip->iNewObjectWithBuffer.op3,
ip->iNewObjectWithBuffer.op4,
ip->iNewObjectWithBuffer.op5));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(NewObjectWithBuffer) = resPH->get();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(NewObjectWithBuffer);
DISPATCH;
}

CASE(NewObjectWithBufferLong) {
CAPTURE_IP_ASSIGN(
resPH,
Interpreter::createObjectFromBuffer(
runtime,
curCodeBlock,
ip->iNewObjectWithBufferLong.op3,
ip->iNewObjectWithBufferLong.op4,
ip->iNewObjectWithBufferLong.op5));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(NewObjectWithBufferLong) = resPH->get();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(NewObjectWithBufferLong);
DISPATCH;
}

CASE(NewArray) {



CAPTURE_IP_ASSIGN(
auto createRes,
JSArray::create(runtime, ip->iNewArray.op2, ip->iNewArray.op2));
if (createRes == ExecutionStatus::EXCEPTION) {
goto exception;
}
O1REG(NewArray) = createRes->getHermesValue();
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(NewArray);
DISPATCH;
}

CASE(NewArrayWithBuffer) {
CAPTURE_IP_ASSIGN(
resPH,
Interpreter::createArrayFromBuffer(
runtime,
curCodeBlock,
ip->iNewArrayWithBuffer.op2,
ip->iNewArrayWithBuffer.op3,
ip->iNewArrayWithBuffer.op4));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(NewArrayWithBuffer) = resPH->get();
gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();
ip = NEXTINST(NewArrayWithBuffer);
DISPATCH;
}

CASE(NewArrayWithBufferLong) {
CAPTURE_IP_ASSIGN(
resPH,
Interpreter::createArrayFromBuffer(
runtime,
curCodeBlock,
ip->iNewArrayWithBufferLong.op2,
ip->iNewArrayWithBufferLong.op3,
ip->iNewArrayWithBufferLong.op4));
if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(NewArrayWithBufferLong) = resPH->get();
gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();
ip = NEXTINST(NewArrayWithBufferLong);
DISPATCH;
}

CASE(CreateThis) {

if (LLVM_UNLIKELY(!vmisa<Callable>(O3REG(CreateThis)))) {
CAPTURE_IP(runtime->raiseTypeError(""constructor is not callable""));
goto exception;
}
CAPTURE_IP_ASSIGN(
auto res,
Callable::newObject(
Handle<Callable>::vmcast(&O3REG(CreateThis)),
runtime,
Handle<JSObject>::vmcast(
O2REG(CreateThis).isObject() ? &O2REG(CreateThis)
: &runtime->objectPrototype)));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(CreateThis) = res->getHermesValue();
ip = NEXTINST(CreateThis);
DISPATCH;
}

CASE(SelectObject) {

O1REG(SelectObject) = O3REG(SelectObject).isObject()
? O3REG(SelectObject)
: O2REG(SelectObject);
ip = NEXTINST(SelectObject);
DISPATCH;
}

CASE(Eq)
CASE(Neq) {
CAPTURE_IP_ASSIGN(
res,
abstractEqualityTest_RJS(
runtime, Handle<>(&O2REG(Eq)), Handle<>(&O3REG(Eq))));
if (res == ExecutionStatus::EXCEPTION) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(Eq) = ip->opCode == OpCode::Eq
? res.getValue()
: HermesValue::encodeBoolValue(!res->getBool());
ip = NEXTINST(Eq);
DISPATCH;
}
CASE(StrictEq) {
O1REG(StrictEq) = HermesValue::encodeBoolValue(
strictEqualityTest(O2REG(StrictEq), O3REG(StrictEq)));
ip = NEXTINST(StrictEq);
DISPATCH;
}
CASE(StrictNeq) {
O1REG(StrictNeq) = HermesValue::encodeBoolValue(
!strictEqualityTest(O2REG(StrictNeq), O3REG(StrictNeq)));
ip = NEXTINST(StrictNeq);
DISPATCH;
}
CASE(Not) {
O1REG(Not) = HermesValue::encodeBoolValue(!toBoolean(O2REG(Not)));
ip = NEXTINST(Not);
DISPATCH;
}
CASE(Negate) {
if (LLVM_LIKELY(O2REG(Negate).isNumber())) {
O1REG(Negate) =
HermesValue::encodeDoubleValue(-O2REG(Negate).getNumber());
} else {
CAPTURE_IP_ASSIGN(
res, toNumber_RJS(runtime, Handle<>(&O2REG(Negate))));
if (res == ExecutionStatus::EXCEPTION)
goto exception;
gcScope.flushToSmallCount(KEEP_HANDLES);
O1REG(Negate) = HermesValue::encodeDoubleValue(-res->getNumber());
}
ip = NEXTINST(Negate);
DISPATCH;
}
CASE(TypeOf) {
CAPTURE_IP_ASSIGN(
O1REG(TypeOf), typeOf(runtime, Handle<>(&O2REG(TypeOf))));
ip = NEXTINST(TypeOf);
DISPATCH;
}
CASE(Mod) {








if (LLVM_LIKELY(O2REG(Mod).isNumber() && O3REG(Mod).isNumber())) {

O1REG(Mod) = HermesValue::encodeDoubleValue(
std::fmod(O2REG(Mod).getNumber(), O3REG(Mod).getNumber()));
ip = NEXTINST(Mod);
DISPATCH;
}
CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(Mod))));
if (res == ExecutionStatus::EXCEPTION)
goto exception;
double left = res->getDouble();
CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(Mod))));
if (res == ExecutionStatus::EXCEPTION)
goto exception;
O1REG(Mod) =
HermesValue::encodeDoubleValue(std::fmod(left, res->getDouble()));
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(Mod);
DISPATCH;
}
CASE(InstanceOf) {
CAPTURE_IP_ASSIGN(
auto result,
instanceOfOperator_RJS(
runtime,
Handle<>(&O2REG(InstanceOf)),
Handle<>(&O3REG(InstanceOf))));
if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(InstanceOf) = HermesValue::encodeBoolValue(*result);
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(InstanceOf);
DISPATCH;
}
CASE(IsIn) {
{
if (LLVM_UNLIKELY(!O3REG(IsIn).isObject())) {
CAPTURE_IP(runtime->raiseTypeError(
""right operand of 'in' is not an object""));
goto exception;
}
CAPTURE_IP_ASSIGN(
auto cr,
JSObject::hasComputed(
Handle<JSObject>::vmcast(&O3REG(IsIn)),
runtime,
Handle<>(&O2REG(IsIn))));
if (cr == ExecutionStatus::EXCEPTION) {
goto exception;
}
O1REG(IsIn) = HermesValue::encodeBoolValue(*cr);
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(IsIn);
DISPATCH;
}

CASE(PutNewOwnByIdShort) {
nextIP = NEXTINST(PutNewOwnByIdShort);
idVal = ip->iPutNewOwnByIdShort.op3;
goto putOwnById;
}
CASE(PutNewOwnNEByIdLong)
CASE(PutNewOwnByIdLong) {
nextIP = NEXTINST(PutNewOwnByIdLong);
idVal = ip->iPutNewOwnByIdLong.op3;
goto putOwnById;
}
CASE(PutNewOwnNEById)
CASE(PutNewOwnById) {
nextIP = NEXTINST(PutNewOwnById);
idVal = ip->iPutNewOwnById.op3;
}
putOwnById : {
assert(
O1REG(PutNewOwnById).isObject() &&
""Object argument of PutNewOwnById must be an object"");
CAPTURE_IP_ASSIGN(
auto res,
JSObject::defineNewOwnProperty(
Handle<JSObject>::vmcast(&O1REG(PutNewOwnById)),
runtime,
ID(idVal),
ip->opCode <= OpCode::PutNewOwnByIdLong
? PropertyFlags::defaultNewNamedPropertyFlags()
: PropertyFlags::nonEnumerablePropertyFlags(),
Handle<>(&O2REG(PutNewOwnById))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(DelByIdLong) {
idVal = ip->iDelByIdLong.op3;
nextIP = NEXTINST(DelByIdLong);
goto DelById;
}

CASE(DelById) {
idVal = ip->iDelById.op3;
nextIP = NEXTINST(DelById);
}
DelById : {
if (LLVM_LIKELY(O2REG(DelById).isObject())) {
CAPTURE_IP_ASSIGN(
auto status,
JSObject::deleteNamed(
Handle<JSObject>::vmcast(&O2REG(DelById)),
runtime,
ID(idVal),
defaultPropOpFlags));
if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());
} else {

CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelById))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {



CAPTURE_IP(amendPropAccessErrorMsgWithPropName(
runtime, Handle<>(&O2REG(DelById)), ""delete"", ID(idVal)));
goto exception;
}
tmpHandle = res.getValue();
CAPTURE_IP_ASSIGN(
auto status,
JSObject::deleteNamed(
Handle<JSObject>::vmcast(tmpHandle),
runtime,
ID(idVal),
defaultPropOpFlags));
if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());
tmpHandle.clear();
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = nextIP;
DISPATCH;
}

CASE(DelByVal) {
if (LLVM_LIKELY(O2REG(DelByVal).isObject())) {
CAPTURE_IP_ASSIGN(
auto status,
JSObject::deleteComputed(
Handle<JSObject>::vmcast(&O2REG(DelByVal)),
runtime,
Handle<>(&O3REG(DelByVal)),
defaultPropOpFlags));
if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());
} else {

CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelByVal))));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
goto exception;
}
tmpHandle = res.getValue();
CAPTURE_IP_ASSIGN(
auto status,
JSObject::deleteComputed(
Handle<JSObject>::vmcast(tmpHandle),
runtime,
Handle<>(&O3REG(DelByVal)),
defaultPropOpFlags));
if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {
goto exception;
}
O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());
}
gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();
ip = NEXTINST(DelByVal);
DISPATCH;
}
CASE(CreateRegExp) {
{

CAPTURE_IP_ASSIGN(auto re, JSRegExp::create(runtime));

CAPTURE_IP_ASSIGN(
auto pattern,
runtime->makeHandle(curCodeBlock->getRuntimeModule()
->getStringPrimFromStringIDMayAllocate(
ip->iCreateRegExp.op2)));
CAPTURE_IP_ASSIGN(
auto flags,
runtime->makeHandle(curCodeBlock->getRuntimeModule()
->getStringPrimFromStringIDMayAllocate(
ip->iCreateRegExp.op3)));
CAPTURE_IP_ASSIGN(
auto bytecode,
curCodeBlock->getRuntimeModule()->getRegExpBytecodeFromRegExpID(
ip->iCreateRegExp.op4));
CAPTURE_IP_ASSIGN(
auto initRes,
JSRegExp::initialize(re, runtime, pattern, flags, bytecode));
if (LLVM_UNLIKELY(initRes == ExecutionStatus::EXCEPTION)) {
goto exception;
}

O1REG(CreateRegExp) = re.getHermesValue();
}
gcScope.flushToSmallCount(KEEP_HANDLES);
ip = NEXTINST(CreateRegExp);
DISPATCH;
}

CASE(SwitchImm) {
if (LLVM_LIKELY(O1REG(SwitchImm).isNumber())) {
double numVal = O1REG(SwitchImm).getNumber();
uint32_t uintVal = (uint32_t)numVal;
if (LLVM_LIKELY(numVal == uintVal) &&
LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) &&
LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5))
{


const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(
(const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));



const int32_t *loc =
(const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;

ip = IPADD(*loc);
DISPATCH;
}
}

ip = IPADD(ip->iSwitchImm.op3);
DISPATCH;
}
LOAD_CONST(
LoadConstUInt8,
HermesValue::encodeDoubleValue(ip->iLoadConstUInt8.op2));
LOAD_CONST(
LoadConstInt, HermesValue::encodeDoubleValue(ip->iLoadConstInt.op2));
LOAD_CONST(
LoadConstDouble,
HermesValue::encodeDoubleValue(ip->iLoadConstDouble.op2));
LOAD_CONST_CAPTURE_IP(
LoadConstString,
HermesValue::encodeStringValue(
curCodeBlock->getRuntimeModule()
->getStringPrimFromStringIDMayAllocate(
ip->iLoadConstString.op2)));
LOAD_CONST_CAPTURE_IP(
LoadConstStringLongIndex,
HermesValue::encodeStringValue(
curCodeBlock->getRuntimeModule()
->getStringPrimFromStringIDMayAllocate(
ip->iLoadConstStringLongIndex.op2)));
LOAD_CONST(LoadConstUndefined, HermesValue::encodeUndefinedValue());
LOAD_CONST(LoadConstNull, HermesValue::encodeNullValue());
LOAD_CONST(LoadConstTrue, HermesValue::encodeBoolValue(true));
LOAD_CONST(LoadConstFalse, HermesValue::encodeBoolValue(false));
LOAD_CONST(LoadConstZero, HermesValue::encodeDoubleValue(0));
BINOP(Sub, doSub);
BINOP(Mul, doMult);
BINOP(Div, doDiv);
BITWISEBINOP(BitAnd, &);
BITWISEBINOP(BitOr, |);
BITWISEBINOP(BitXor, ^);


SHIFTOP(LShift, <<, toUInt32_RJS, uint32_t, int32_t);
SHIFTOP(RShift, >>, toInt32_RJS, int32_t, int32_t);
SHIFTOP(URshift, >>, toUInt32_RJS, uint32_t, uint32_t);
CONDOP(Less, <, lessOp_RJS);
CONDOP(LessEq, <=, lessEqualOp_RJS);
CONDOP(Greater, >, greaterOp_RJS);
CONDOP(GreaterEq, >=, greaterEqualOp_RJS);
JCOND(Less, <, lessOp_RJS);
JCOND(LessEqual, <=, lessEqualOp_RJS);
JCOND(Greater, >, greaterOp_RJS);
JCOND(GreaterEqual, >=, greaterEqualOp_RJS);

JCOND_STRICT_EQ_IMPL(
JStrictEqual, , IPADD(ip->iJStrictEqual.op1), NEXTINST(JStrictEqual));
JCOND_STRICT_EQ_IMPL(
JStrictEqual,
Long,
IPADD(ip->iJStrictEqualLong.op1),
NEXTINST(JStrictEqualLong));
JCOND_STRICT_EQ_IMPL(
JStrictNotEqual,
,
NEXTINST(JStrictNotEqual),
IPADD(ip->iJStrictNotEqual.op1));
JCOND_STRICT_EQ_IMPL(
JStrictNotEqual,
Long,
NEXTINST(JStrictNotEqualLong),
IPADD(ip->iJStrictNotEqualLong.op1));

JCOND_EQ_IMPL(JEqual, , IPADD(ip->iJEqual.op1), NEXTINST(JEqual));
JCOND_EQ_IMPL(
JEqual, Long, IPADD(ip->iJEqualLong.op1), NEXTINST(JEqualLong));
JCOND_EQ_IMPL(
JNotEqual, , NEXTINST(JNotEqual), IPADD(ip->iJNotEqual.op1));
JCOND_EQ_IMPL(
JNotEqual,
Long,
NEXTINST(JNotEqualLong),
IPADD(ip->iJNotEqualLong.op1));

CASE_OUTOFLINE(PutOwnByVal);
CASE_OUTOFLINE(PutOwnGetterSetterByVal);
CASE_OUTOFLINE(DirectEval);

CASE_OUTOFLINE(IteratorBegin);
CASE_OUTOFLINE(IteratorNext);
CASE(IteratorClose) {
if (LLVM_UNLIKELY(O1REG(IteratorClose).isObject())) {



CAPTURE_IP_ASSIGN(
auto res,
iteratorClose(
runtime,
Handle<JSObject>::vmcast(&O1REG(IteratorClose)),
Runtime::getEmptyValue()));
if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {
if (ip->iIteratorClose.op2 &&
!isUncatchableError(runtime->thrownValue_)) {

runtime->clearThrownValue();
} else {
goto exception;
}
}
gcScope.flushToSmallCount(KEEP_HANDLES);
}
ip = NEXTINST(IteratorClose);
DISPATCH;
}

CASE(_last) {
llvm_unreachable(""Invalid opcode _last"");
}
}

llvm_unreachable(""unreachable"");


stackOverflow:
CAPTURE_IP(runtime->raiseStackOverflow(
Runtime::StackOverflowKind::JSRegisterStack));



handleExceptionInParent:

curCodeBlock = FRAME.getSavedCodeBlock();
ip = FRAME.getSavedIP();


frameRegs =
&runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();


if (!curCodeBlock)
return ExecutionStatus::EXCEPTION;


#ifdef HERMESVM_PROFILER_EXTERN
return ExecutionStatus::EXCEPTION;
#endif

exception:
UPDATE_OPCODE_TIME_SPENT;
assert(
!runtime->thrownValue_.isEmpty() &&
""thrownValue unavailable at exception"");

bool catchable = true;


if (auto *jsError = dyn_vmcast<JSError>(runtime->thrownValue_)) {
catchable = jsError->catchable();
if (!jsError->getStackTrace()) {

CAPTURE_IP_ASSIGN(
auto errorHandle,
runtime->makeHandle(vmcast<JSError>(runtime->thrownValue_)));
runtime->clearThrownValue();

CAPTURE_IP(JSError::recordStackTrace(
errorHandle, runtime, false, curCodeBlock, ip));


runtime->setThrownValue(errorHandle.getHermesValue());
}
}

gcScope.flushToSmallCount(KEEP_HANDLES);
tmpHandle.clear();

#ifdef HERMES_ENABLE_DEBUGGER
if (SingleStep) {


state.codeBlock = curCodeBlock;
state.offset = CUROFFSET;
return ExecutionStatus::EXCEPTION;
}

using PauseOnThrowMode = facebook::hermes::debugger::PauseOnThrowMode;
auto mode = runtime->debugger_.getPauseOnThrowMode();
if (mode != PauseOnThrowMode::None) {
if (!runtime->debugger_.isDebugging()) {

bool caught =
runtime->debugger_
.findCatchTarget(InterpreterState(curCodeBlock, CUROFFSET))
.hasValue();
bool shouldStop = mode == PauseOnThrowMode::All ||
(mode == PauseOnThrowMode::Uncaught && !caught);
if (shouldStop) {





InterpreterState tmpState{curCodeBlock, (uint32_t)CUROFFSET};
CAPTURE_IP_ASSIGN(
ExecutionStatus resultStatus,
runtime->debugger_.runDebugger(
Debugger::RunReason::Exception, tmpState));
(void)resultStatus;
assert(
tmpState == InterpreterState(curCodeBlock, CUROFFSET) &&
""not allowed to step internally in a pauseOnThrow"");
gcScope.flushToSmallCount(KEEP_HANDLES);
}
}
}
#endif

int32_t handlerOffset = 0;


while (((handlerOffset = curCodeBlock->findCatchTargetOffset(CUROFFSET)) ==
-1) ||
!catchable) {
PROFILER_EXIT_FUNCTION(curCodeBlock);

#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES
runtime->popCallStack();
#endif


curCodeBlock = FRAME.getSavedCodeBlock();
ip = FRAME.getSavedIP();


frameRegs =
&runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();

SLOW_DEBUG(
dbgs() << ""function exit with exception: restored stackLevel=""
<< runtime->getStackLevel() << ""\n"");


if (!curCodeBlock) {
SLOW_DEBUG(
dbgs()
<< ""function exit with exception: returning to native code\n"");
return ExecutionStatus::EXCEPTION;
}

assert(
isCallType(ip->opCode) &&
""return address is not Call-type instruction"");


#ifdef HERMESVM_PROFILER_EXTERN
return ExecutionStatus::EXCEPTION;
#endif
}

INIT_STATE_FOR_CODEBLOCK(curCodeBlock);

ip = IPADD(handlerOffset - CUROFFSET);
}
}","[98, 895, 896, 899, 900, 903, 904, 905, 907, 908, 909, 910, 911]","A logic vulnerability when handling the SaveGeneratorLong instruction in Facebook Hermes prior to commit b2021df620824627f5a8c96615edbd1eb7fdddfc allows attackers to potentially read out of bounds or theoretically execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."
6406,"m.def(""TFE_ToDlpackCapsule"", [](py::handle& o) {
PyObject* eager_tensor_pyobject_ptr = o.ptr();
TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);
tensorflow::Safe_TF_StatusPtr status =
tensorflow::make_safe(TF_NewStatus());
void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());
tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());

py::capsule capsule(
dlm_ptr, tensorflow::kDlTensorCapsuleName, [](PyObject* capsule) {
if (PyCapsule_IsValid(capsule, tensorflow::kDlTensorCapsuleName)) {
void* dlm_rptr =
PyCapsule_GetPointer(capsule, tensorflow::kDlTensorCapsuleName);
if (dlm_rptr) {
tensorflow::TFE_CallDLManagedTensorDeleter(dlm_rptr);
PyCapsule_SetDestructor(capsule, nullptr);
}
}
});
return capsule;
});","[3, 6]","In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1."
3765,"MagickPPExport void Magick::throwException(ExceptionInfo *exception_,
const bool quiet_)
{
const ExceptionInfo
*p;

Exception
*nestedException,
*q;

ExceptionType
severity;

size_t
index;


if (exception_->severity == UndefinedException)
return;

std::string message=formatExceptionMessage(exception_);
nestedException=(Exception *) NULL;
LockSemaphoreInfo(exception_->semaphore);
if (exception_->exceptions != (void *) NULL)
{
index=GetNumberOfElementsInLinkedList((LinkedListInfo *)
exception_->exceptions);
while(index > 0)
{
p=(const ExceptionInfo *) GetValueFromLinkedList((LinkedListInfo *)
exception_->exceptions,--index);
if ((p->severity != exception_->severity) || (LocaleCompare(p->reason,
exception_->reason) != 0) || (LocaleCompare(p->description,
exception_->description) != 0))
{
if (nestedException == (Exception *) NULL)
nestedException=createException(p);
else
{
q=createException(p);
nestedException->nested(q);
nestedException=q;
}
}
}
}
severity=exception_->severity;
UnlockSemaphoreInfo(exception_->semaphore);

if ((quiet_) && (severity < MagickCore::ErrorException))
{
delete nestedException;
return;
}

DestroyExceptionInfo(exception_);

switch (severity)
{
case BlobError:
case BlobFatalError:
throw ErrorBlob(message,nestedException);
case BlobWarning:
throw WarningBlob(message,nestedException);
case CacheError:
case CacheFatalError:
throw ErrorCache(message,nestedException);
case CacheWarning:
throw WarningCache(message,nestedException);
case CoderError:
case CoderFatalError:
throw ErrorCoder(message,nestedException);
case CoderWarning:
throw WarningCoder(message,nestedException);
case ConfigureError:
case ConfigureFatalError:
throw ErrorConfigure(message,nestedException);
case ConfigureWarning:
throw WarningConfigure(message,nestedException);
case CorruptImageError:
case CorruptImageFatalError:
throw ErrorCorruptImage(message,nestedException);
case CorruptImageWarning:
throw WarningCorruptImage(message,nestedException);
case DelegateError:
case DelegateFatalError:
throw ErrorDelegate(message,nestedException);
case DelegateWarning:
throw WarningDelegate(message,nestedException);
case DrawError:
case DrawFatalError:
throw ErrorDraw(message,nestedException);
case DrawWarning:
throw WarningDraw(message,nestedException);
case FileOpenError:
case FileOpenFatalError:
throw ErrorFileOpen(message,nestedException);
case FileOpenWarning:
throw WarningFileOpen(message,nestedException);
case ImageError:
case ImageFatalError:
throw ErrorImage(message,nestedException);
case ImageWarning:
throw WarningImage(message,nestedException);
case MissingDelegateError:
case MissingDelegateFatalError:
throw ErrorMissingDelegate(message,nestedException);
case MissingDelegateWarning:
throw WarningMissingDelegate(message,nestedException);
case ModuleError:
case ModuleFatalError:
throw ErrorModule(message,nestedException);
case ModuleWarning:
throw WarningModule(message,nestedException);
case MonitorError:
case MonitorFatalError:
throw ErrorMonitor(message,nestedException);
case MonitorWarning:
throw WarningMonitor(message,nestedException);
case OptionError:
case OptionFatalError:
throw ErrorOption(message,nestedException);
case OptionWarning:
throw WarningOption(message,nestedException);
case PolicyWarning:
throw WarningPolicy(message,nestedException);
case PolicyError:
case PolicyFatalError:
throw ErrorPolicy(message,nestedException);
case RegistryError:
case RegistryFatalError:
throw ErrorRegistry(message,nestedException);
case RegistryWarning:
throw WarningRegistry(message,nestedException);
case ResourceLimitError:
case ResourceLimitFatalError:
throw ErrorResourceLimit(message,nestedException);
case ResourceLimitWarning:
throw WarningResourceLimit(message,nestedException);
case StreamError:
case StreamFatalError:
throw ErrorStream(message,nestedException);
case StreamWarning:
throw WarningStream(message,nestedException);
case TypeError:
case TypeFatalError:
throw ErrorType(message,nestedException);
case TypeWarning:
throw WarningType(message,nestedException);
case UndefinedException:
default:
throw ErrorUndefined(message,nestedException);
case XServerError:
case XServerFatalError:
throw ErrorXServer(message,nestedException);
case XServerWarning:
throw WarningXServer(message,nestedException);
}
}","[37, 40, 41, 42]","An issue was discovered in Magick++ in ImageMagick 6.9.7. A specially crafted file creating a nested exception could lead to a memory leak (thus, a DoS)."
203898,"  void HTMLElement::setInnerHTML(const String& html, ExceptionCode& ec)
  {
    RefPtr<DocumentFragment> fragment = createFragmentFromSource(html, this, ec);
    if (fragment)
     if (RefPtr<DocumentFragment> fragment = createFragmentForInnerOuterHTML(html, this, ec))
          replaceChildrenWithFragment(this, fragment.release(), ec);
  }","[5, 3, 4]","Google Chrome before 13.0.782.107 does not prevent calls to functions in other frames, which allows remote attackers to bypass intended access restrictions via a crafted web site, related to a *cross-frame function leak.*"
18,"rb_dlhandle_initialize(int argc, VALUE argv[], VALUE self)
{
void *ptr;
struct dl_handle *dlhandle;
VALUE lib, flag;
char  *clib;
int   cflag;
const char *err;

switch( rb_scan_args(argc, argv, ""02"", &lib, &flag) ){
case 0:
clib = NULL;
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 1:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = RTLD_LAZY | RTLD_GLOBAL;
break;
case 2:
clib = NIL_P(lib) ? NULL : StringValuePtr(lib);
cflag = NUM2INT(flag);
break;
default:
rb_bug(""rb_dlhandle_new"");
}

ptr = dlopen(clib, cflag);
#if defined(HAVE_DLERROR)
if( !ptr && (err = dlerror()) ){
rb_raise(rb_eDLError, ""%s"", err);
}
#else
if( !ptr ){
err = dlerror();
rb_raise(rb_eDLError, ""%s"", err);
}
#endif
Data_Get_Struct(self, struct dl_handle, dlhandle);
if( dlhandle->ptr && dlhandle->open && dlhandle->enable_close ){
dlclose(dlhandle->ptr);
}
dlhandle->ptr = ptr;
dlhandle->open = 1;
dlhandle->enable_close = 0;

if( rb_block_given_p() ){
rb_ensure(rb_yield, self, rb_dlhandle_close, self);
}

return Qnil;
}","[16, 20]","DL::dlopen in Ruby 1.8, 1.9.0, 1.9.2, 1.9.3, 2.0.0 before patchlevel 648, and 2.1 before 2.1.8 opens libraries with tainted names."
208183," static jboolean enableNative(JNIEnv* env, jobject obj) {
 static jboolean enableNative(JNIEnv* env, jobject obj, jboolean isGuest) {
      ALOGV(""%s:"",__FUNCTION__);
  
      jboolean result = JNI_FALSE;
      if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable();
     int ret = sBluetoothInterface->enable(isGuest == JNI_TRUE ? 1 : 0);
      result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
      return result;
  }","[2, 8, 7]","Bluetooth in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows local users to gain privileges by establishing a pairing that remains present during a session of the primary user, aka internal bug 27410683."
199927," static int udf_readdir(struct file *file, struct dir_context *ctx)
 {
 	struct inode *dir = file_inode(file);
 	struct udf_inode_info *iinfo = UDF_I(dir);
 	struct udf_fileident_bh fibh = { .sbh = NULL, .ebh = NULL};
 	struct fileIdentDesc *fi = NULL;
 	struct fileIdentDesc cfi;
 	int block, iblock;
 	loff_t nf_pos;
 	int flen;
 	unsigned char *fname = NULL;
 	unsigned char *nameptr;
 	uint16_t liu;
 	uint8_t lfi;
 	loff_t size = udf_ext0_offset(dir) + dir->i_size;
 	struct buffer_head *tmp, *bha[16];
 	struct kernel_lb_addr eloc;
 	uint32_t elen;
 	sector_t offset;
 	int i, num, ret = 0;
 	struct extent_position epos = { NULL, 0, {0, 0} };
 
 	if (ctx->pos == 0) {
 		if (!dir_emit_dot(file, ctx))
 			return 0;
 		ctx->pos = 1;
 	}
 	nf_pos = (ctx->pos - 1) << 2;
 	if (nf_pos >= size)
 		goto out;
 
 	fname = kmalloc(UDF_NAME_LEN, GFP_NOFS);
 	if (!fname) {
 		ret = -ENOMEM;
 		goto out;
 	}
 
 	if (nf_pos == 0)
 		nf_pos = udf_ext0_offset(dir);
 
 	fibh.soffset = fibh.eoffset = nf_pos & (dir->i_sb->s_blocksize - 1);
 	if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {
 		if (inode_bmap(dir, nf_pos >> dir->i_sb->s_blocksize_bits,
 		    &epos, &eloc, &elen, &offset)
 		    != (EXT_RECORDED_ALLOCATED >> 30)) {
 			ret = -ENOENT;
 			goto out;
 		}
 		block = udf_get_lb_pblock(dir->i_sb, &eloc, offset);
 		if ((++offset << dir->i_sb->s_blocksize_bits) < elen) {
 			if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
 				epos.offset -= sizeof(struct short_ad);
 			else if (iinfo->i_alloc_type ==
 					ICBTAG_FLAG_AD_LONG)
 				epos.offset -= sizeof(struct long_ad);
 		} else {
 			offset = 0;
 		}
 
 		if (!(fibh.sbh = fibh.ebh = udf_tread(dir->i_sb, block))) {
 			ret = -EIO;
 			goto out;
 		}
 
 		if (!(offset & ((16 >> (dir->i_sb->s_blocksize_bits - 9)) - 1))) {
 			i = 16 >> (dir->i_sb->s_blocksize_bits - 9);
 			if (i + offset > (elen >> dir->i_sb->s_blocksize_bits))
 				i = (elen >> dir->i_sb->s_blocksize_bits) - offset;
 			for (num = 0; i > 0; i--) {
 				block = udf_get_lb_pblock(dir->i_sb, &eloc, offset + i);
 				tmp = udf_tgetblk(dir->i_sb, block);
 				if (tmp && !buffer_uptodate(tmp) && !buffer_locked(tmp))
 					bha[num++] = tmp;
 				else
 					brelse(tmp);
 			}
 			if (num) {
 				ll_rw_block(READA, num, bha);
 				for (i = 0; i < num; i++)
 					brelse(bha[i]);
 			}
 		}
 	}
 
 	while (nf_pos < size) {
 		struct kernel_lb_addr tloc;
 
 		ctx->pos = (nf_pos >> 2) + 1;
 
 		fi = udf_fileident_read(dir, &nf_pos, &fibh, &cfi, &epos, &eloc,
 					&elen, &offset);
 		if (!fi)
 			goto out;
 
 		liu = le16_to_cpu(cfi.lengthOfImpUse);
 		lfi = cfi.lengthFileIdent;
 
 		if (fibh.sbh == fibh.ebh) {
 			nameptr = fi->fileIdent + liu;
 		} else {
 			int poffset;	 
 
 			poffset = fibh.soffset + sizeof(struct fileIdentDesc) + liu + lfi;
 
 			if (poffset >= lfi) {
 				nameptr = (char *)(fibh.ebh->b_data + poffset - lfi);
 			} else {
 				nameptr = fname;
 				memcpy(nameptr, fi->fileIdent + liu,
 				       lfi - poffset);
 				memcpy(nameptr + lfi - poffset,
 				       fibh.ebh->b_data, poffset);
 			}
 		}
 
 		if ((cfi.fileCharacteristics & FID_FILE_CHAR_DELETED) != 0) {
 			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNDELETE))
 				continue;
 		}
 
 		if ((cfi.fileCharacteristics & FID_FILE_CHAR_HIDDEN) != 0) {
 			if (!UDF_QUERY_FLAG(dir->i_sb, UDF_FLAG_UNHIDE))
 				continue;
 		}
 
 		if (cfi.fileCharacteristics & FID_FILE_CHAR_PARENT) {
 			if (!dir_emit_dotdot(file, ctx))
 				goto out;
  			continue;
  		}
  
		flen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);
 		flen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,
 					UDF_NAME_LEN);
  		if (!flen)
  			continue;
  
 		tloc = lelb_to_cpu(cfi.icb.extLocation);
 		iblock = udf_get_lb_pblock(dir->i_sb, &tloc, 0);
 		if (!dir_emit(ctx, fname, flen, iblock, DT_UNKNOWN))
 			goto out;
 	}  
 
 	ctx->pos = (nf_pos >> 2) + 1;
 
 out:
 	if (fibh.sbh != fibh.ebh)
 		brelse(fibh.ebh);
 	brelse(fibh.sbh);
 	brelse(epos.bh);
 	kfree(fname);
 
 	return ret;
 }","[133, 134, 132]","The UDF filesystem implementation in the Linux kernel before 3.18.2 does not ensure that space is available for storing a symlink target's name along with a trailing 0 character, which allows local users to obtain sensitive information via a crafted filesystem image, related to fs/udf/symlink.c and fs/udf/unicode.c."
9041,"static void http_manage_server_side_cookies(struct stream *s, struct channel *res)
{
struct session *sess = s->sess;
struct http_txn *txn = s->txn;
struct htx *htx;
struct http_hdr_ctx ctx;
struct server *srv;
char *hdr_beg, *hdr_end;
char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;
int is_cookie2 = 0;

htx = htxbuf(&res->buf);

ctx.blk = NULL;
while (1) {
int is_first = 1;

if (!http_find_header(htx, ist(""Set-Cookie""), &ctx, 1)) {
if (!http_find_header(htx, ist(""Set-Cookie2""), &ctx, 1))
break;
is_cookie2 = 1;
}




txn->flags |= TX_SCK_PRESENT;





if (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)
break;






































hdr_beg = ctx.value.ptr;
hdr_end = hdr_beg + ctx.value.len;
for (prev = hdr_beg; prev < hdr_end; prev = next) {




att_beg = prev;
if (!is_first)
att_beg++;
is_first = 0;

while (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))
att_beg++;




equal = att_end = att_beg;

while (equal < hdr_end) {
if (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))
break;
if (HTTP_IS_SPHT(*equal++))
continue;
att_end = equal;
}






if (equal < hdr_end && *equal == '=') {

val_beg = equal + 1;
while (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))
val_beg++;


next = http_find_cookie_value_end(val_beg, hdr_end);


val_end = next;
while (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))
val_end--;
}
else {

val_beg = val_end = next = equal;
}

if (next < hdr_end) {





if (is_cookie2)
next = http_find_hdr_value_end(next, hdr_end);
else
next = hdr_end;
}




if (equal == val_end)
continue;






if (unlikely(att_end != equal || val_beg > equal + 1)) {
int stripped_before = 0;
int stripped_after = 0;

if (att_end != equal) {
memmove(att_end, equal, hdr_end - equal);
stripped_before = (att_end - equal);
equal   += stripped_before;
val_beg += stripped_before;
}

if (val_beg > equal + 1) {
memmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);
stripped_after = (equal + 1) - val_beg;
val_beg += stripped_after;
stripped_before += stripped_after;
}

val_end      += stripped_before;
next         += stripped_before;
hdr_end      += stripped_before;

htx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);
ctx.value.len = hdr_end - hdr_beg;
}






if (sess->fe->capture_name != NULL &&
txn->srv_cookie == NULL &&
(val_end - att_beg >= sess->fe->capture_namelen) &&
memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {
int log_len = val_end - att_beg;
if ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {
ha_alert(""HTTP logging : out of memory.\n"");
}
else {
if (log_len > sess->fe->capture_len)
log_len = sess->fe->capture_len;
memcpy(txn->srv_cookie, att_beg, log_len);
txn->srv_cookie[log_len] = 0;
}
}

srv = objt_server(s->target);

if (!(s->flags & SF_IGNORE_PRST) &&
(att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&
(memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {

txn->flags &= ~TX_SCK_MASK;
txn->flags |= TX_SCK_FOUND;






if (s->be->ck_opts & PR_CK_PSV) {



}
else if ((srv && (s->be->ck_opts & PR_CK_INS)) ||
((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {

if (prev == hdr_beg && next == hdr_end) {

http_remove_header(htx, &ctx);



} else {

int delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);
next      = prev;
hdr_end  += delta;
}
txn->flags &= ~TX_SCK_MASK;
txn->flags |= TX_SCK_DELETED;

}
else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {



int sliding, delta;

ctx.value = ist2(val_beg, val_end - val_beg);
ctx.lws_before = ctx.lws_after = 0;
http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));
delta     = srv->cklen - (val_end - val_beg);
sliding   = (ctx.value.ptr - val_beg);
hdr_beg  += sliding;
val_beg  += sliding;
next     += sliding + delta;
hdr_end  += sliding + delta;

txn->flags &= ~TX_SCK_MASK;
txn->flags |= TX_SCK_REPLACED;
}
else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {



int sliding, delta;
ctx.value = ist2(val_beg, 0);
ctx.lws_before = ctx.lws_after = 0;
http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));
delta     = srv->cklen + 1;
sliding   = (ctx.value.ptr - val_beg);
hdr_beg  += sliding;
val_beg  += sliding;
next     += sliding + delta;
hdr_end  += sliding + delta;

val_beg[srv->cklen] = COOKIE_DELIM;
txn->flags &= ~TX_SCK_MASK;
txn->flags |= TX_SCK_REPLACED;
}
}



}
}
}",[18],"A flaw was found in the way HAProxy processed HTTP responses containing the ""Set-Cookie2"" header. This flaw could allow an attacker to send crafted HTTP response packets which lead to an infinite loop, eventually resulting in a denial of service condition. The highest threat from this vulnerability is availability."
200551," process_db_args(krb5_context context, char **db_args, xargs_t *xargs,
                 OPERATION optype)
 {
     int                   i=0;
     krb5_error_code       st=0;
     char                  *arg=NULL, *arg_val=NULL;
     char                  **dptr=NULL;
     unsigned int          arg_val_len=0;
 
      if (db_args) {
          for (i=0; db_args[i]; ++i) {
              arg = strtok_r(db_args[i], ""="", &arg_val);
             arg = (arg != NULL) ? arg : """";
              if (strcmp(arg, TKTPOLICY_ARG) == 0) {
                  dptr = &xargs->tktpolicydn;
              } else {
                 if (strcmp(arg, USERDN_ARG) == 0) {
                     if (optype == MODIFY_PRINCIPAL ||
                         xargs->dn != NULL || xargs->containerdn != NULL ||
                         xargs->linkdn != NULL) {
                         st = EINVAL;
                         k5_setmsg(context, st, _(""%s option not supported""),
                                   arg);
                         goto cleanup;
                     }
                     dptr = &xargs->dn;
                 } else if (strcmp(arg, CONTAINERDN_ARG) == 0) {
                     if (optype == MODIFY_PRINCIPAL ||
                         xargs->dn != NULL || xargs->containerdn != NULL) {
                         st = EINVAL;
                         k5_setmsg(context, st, _(""%s option not supported""),
                                   arg);
                         goto cleanup;
                     }
                     dptr = &xargs->containerdn;
                 } else if (strcmp(arg, LINKDN_ARG) == 0) {
                     if (xargs->dn != NULL || xargs->linkdn != NULL) {
                         st = EINVAL;
                         k5_setmsg(context, st, _(""%s option not supported""),
                                   arg);
                         goto cleanup;
                     }
                     dptr = &xargs->linkdn;
                 } else {
                     st = EINVAL;
                     k5_setmsg(context, st, _(""unknown option: %s""), arg);
                     goto cleanup;
                 }
 
                 xargs->dn_from_kbd = TRUE;
                 if (arg_val == NULL || strlen(arg_val) == 0) {
                     st = EINVAL;
                     k5_setmsg(context, st, _(""%s option value missing""), arg);
                     goto cleanup;
                 }
             }
 
             if (arg_val == NULL) {
                 st = EINVAL;
                 k5_setmsg(context, st, _(""%s option value missing""), arg);
                 goto cleanup;
             }
             arg_val_len = strlen(arg_val) + 1;
 
             if (strcmp(arg, TKTPOLICY_ARG) == 0) {
                 if ((st = krb5_ldap_name_to_policydn (context,
                                                       arg_val,
                                                       dptr)) != 0)
                     goto cleanup;
             } else {
                 *dptr = k5memdup(arg_val, arg_val_len, &st);
                 if (*dptr == NULL)
                     goto cleanup;
             }
         }
     }
 
 cleanup:
     return st;
 }",[13],"The process_db_args function in plugins/kdb/ldap/libkdb_ldap/ldap_principal2.c in the LDAP KDB module in kadmind in MIT Kerberos 5 (aka krb5) through 1.13.4 and 1.14.x through 1.14.1 mishandles the DB argument, which allows remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) via a crafted request to modify a principal."
6397,"bool all_tests () {
mu_run_test (test_r_str_newf);
mu_run_test (test_r_str_replace_char_once);
mu_run_test (test_r_str_replace_char);
mu_run_test (test_r_str_replace);
mu_run_test (test_r_str_bits64);
mu_run_test (test_r_str_rwx);
mu_run_test (test_r_str_rwx_i);
mu_run_test (test_r_str_bool);
mu_run_test (test_r_str_trim);
mu_run_test (test_r_str_case);
mu_run_test (test_r_str_split);
mu_run_test (test_r_str_tokenize);
mu_run_test (test_r_str_char_count);
mu_run_test (test_r_str_word_count);
mu_run_test (test_r_str_ichr);
mu_run_test (test_r_str_lchr);
mu_run_test (test_r_sub_str_lchr);
mu_run_test (test_r_sub_str_rchr);
mu_run_test (test_r_str_rchr);
mu_run_test (test_r_str_ansi_len);
mu_run_test (test_r_str_len_utf8_ansi);
mu_run_test (test_r_str_utf8_charsize);
mu_run_test (test_r_str_utf8_charsize_prev);
mu_run_test (test_r_str_sanitize_sdb_key);
mu_run_test (test_r_str_unescape);
mu_run_test (test_r_str_constpool);
mu_run_test (test_r_str_format_msvc_argv);
mu_run_test (test_r_str_str_xy);
return tests_passed != tests_run;
}",[26],"In radare2 before version 4.5.0, malformed PDB file names in the PDB server path cause shell injection. To trigger the problem it's required to open the executable in radare2 and run idpd to trigger the download. The shell code will execute, and will create a file called pwned in the current directory."
199487," static int rd_build_device_space(struct rd_dev *rd_dev)
 static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
 				 u32 total_sg_needed, unsigned char init_payload)
  {
	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
 	u32 i = 0, j, page_offset = 0, sg_per_table;
  	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
  				sizeof(struct scatterlist));
	struct rd_dev_sg_table *sg_table;
  	struct page *pg;
  	struct scatterlist *sg;
	if (rd_dev->rd_page_count <= 0) {
		pr_err(""Illegal page count: %u for Ramdisk device\n"",
			rd_dev->rd_page_count);
		return -EINVAL;
	}
	 
	if (rd_dev->rd_flags & RDF_NULLIO)
		return 0;
	total_sg_needed = rd_dev->rd_page_count;
	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
	if (!sg_table) {
		pr_err(""Unable to allocate memory for Ramdisk""
			"" scatterlist tables\n"");
		return -ENOMEM;
	}
	rd_dev->sg_table_array = sg_table;
	rd_dev->sg_table_count = sg_tables;
 	unsigned char *p;
  
  	while (total_sg_needed) {
  		sg_per_table = (total_sg_needed > max_sg_per_table) ?
 			max_sg_per_table : total_sg_needed;
 
 		sg = kzalloc(sg_per_table * sizeof(struct scatterlist),
 				GFP_KERNEL);
 		if (!sg) {
 			pr_err(""Unable to allocate scatterlist array""
 				"" for struct rd_dev\n"");
 			return -ENOMEM;
 		}
 
 		sg_init_table(sg, sg_per_table);
 
 		sg_table[i].sg_table = sg;
 		sg_table[i].rd_sg_count = sg_per_table;
 		sg_table[i].page_start_offset = page_offset;
 		sg_table[i++].page_end_offset = (page_offset + sg_per_table)
 						- 1;
 
 		for (j = 0; j < sg_per_table; j++) {
 			pg = alloc_pages(GFP_KERNEL, 0);
 			if (!pg) {
 				pr_err(""Unable to allocate scatterlist""
 					"" pages for struct rd_dev_sg_table\n"");
 				return -ENOMEM;
  			}
  			sg_assign_page(&sg[j], pg);
  			sg[j].length = PAGE_SIZE;
 
 			p = kmap(pg);
 			memset(p, init_payload, PAGE_SIZE);
 			kunmap(pg);
  		}
  
  		page_offset += sg_per_table;
  		total_sg_needed -= sg_per_table;
  	}
  
 	return 0;
 }
 
 static int rd_build_device_space(struct rd_dev *rd_dev)
 {
 	struct rd_dev_sg_table *sg_table;
 	u32 sg_tables, total_sg_needed;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
 	int rc;
 
 	if (rd_dev->rd_page_count <= 0) {
 		pr_err(""Illegal page count: %u for Ramdisk device\n"",
 		       rd_dev->rd_page_count);
 		return -EINVAL;
 	}
 
 	 
 	if (rd_dev->rd_flags & RDF_NULLIO)
 		return 0;
 
 	total_sg_needed = rd_dev->rd_page_count;
 
 	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
 
 	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
 	if (!sg_table) {
 		pr_err(""Unable to allocate memory for Ramdisk""
 		       "" scatterlist tables\n"");
 		return -ENOMEM;
 	}
 
 	rd_dev->sg_table_array = sg_table;
 	rd_dev->sg_table_count = sg_tables;
 
 	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
 	if (rc)
 		return rc;
 
  	pr_debug(""CORE_RD[%u] - Built Ramdisk Device ID: %u space of""
		"" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
		rd_dev->rd_dev_id, rd_dev->rd_page_count,
		rd_dev->sg_table_count);
 		 "" %u pages in %u tables\n"", rd_dev->rd_host->rd_host_id,
 		 rd_dev->rd_dev_id, rd_dev->rd_page_count,
 		 rd_dev->sg_table_count);
  
  	return 0;
  }","[2, 3, 6, 30, 61, 62, 63, 64, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 114, 115, 116, 5, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 111, 112, 113]","The rd_build_device_space function in drivers/target/target_core_rd.c in the Linux kernel before 3.14 does not properly initialize a certain data structure, which allows local users to obtain sensitive information from ramdisk_mcp memory by leveraging access to a SCSI initiator."
202495," gplotAddPlot(GPLOT       *gplot,
              NUMA        *nax,
              NUMA        *nay,
               l_int32      plotstyle,
               const char  *plottitle)
  {
char       buf[L_BUF_SIZE];
 char       buf[L_BUFSIZE];
  char       emptystring[] = """";
  char      *datastr, *title;
  l_int32    n, i;
 l_float32  valx, valy, startx, delx;
 SARRAY    *sa;
 
     PROCNAME(""gplotAddPlot"");
 
     if (!gplot)
         return ERROR_INT(""gplot not defined"", procName, 1);
     if (!nay)
         return ERROR_INT(""nay not defined"", procName, 1);
     if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)
         return ERROR_INT(""invalid plotstyle"", procName, 1);
 
     if ((n = numaGetCount(nay)) == 0)
         return ERROR_INT(""no points to plot"", procName, 1);
     if (nax && (n != numaGetCount(nax)))
         return ERROR_INT(""nax and nay sizes differ"", procName, 1);
     if (n == 1 && plotstyle == GPLOT_LINES) {
         L_INFO(""only 1 pt; changing style to points\n"", procName);
         plotstyle = GPLOT_POINTS;
     }
 
          
     numaGetParameters(nay, &startx, &delx);
     numaAddNumber(gplot->plotstyles, plotstyle);
     if (plottitle) {
         title = stringNew(plottitle);
         sarrayAddString(gplot->plottitles, title, L_INSERT);
     } else {
         sarrayAddString(gplot->plottitles, emptystring, L_COPY);
     }
  
           
      gplot->nplots++;
    snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
     snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
      sarrayAddString(gplot->datanames, buf, L_COPY);
  
           
     sa = sarrayCreate(n);
     for (i = 0; i < n; i++) {
         if (nax)
             numaGetFValue(nax, i, &valx);
          else
              valx = startx + i * delx;
          numaGetFValue(nay, i, &valy);
        snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);
         snprintf(buf, L_BUFSIZE, ""%f %f\n"", valx, valy);
          sarrayAddString(sa, buf, L_COPY);
      }
      datastr = sarrayToString(sa, 0);
     sarrayAddString(gplot->plotdata, datastr, L_INSERT);
     sarrayDestroy(&sa);
 
     return 0;
 }","[8, 46, 58, 7, 45, 57]","Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions."
204844," void InProcessBrowserTest::PrepareTestCommandLine(CommandLine* command_line) {
   test_launcher_utils::PrepareBrowserCommandLineForTests(command_line);
 
   command_line->AppendSwitchASCII(switches::kTestType, kBrowserTestType);
 
 #if defined(OS_WIN)
   if (command_line->HasSwitch(switches::kAshBrowserTests)) {
     command_line->AppendSwitchNative(switches::kViewerLaunchViaAppId,
                                      win8::test::kDefaultTestAppUserModelId);
     command_line->AppendSwitch(switches::kSilentLaunch);
   }
 #endif
 
 #if defined(OS_MACOSX)
   base::FilePath subprocess_path;
   PathService::Get(base::FILE_EXE, &subprocess_path);
   subprocess_path = subprocess_path.DirName().DirName();
   DCHECK_EQ(subprocess_path.BaseName().value(), ""Contents"");
   subprocess_path =
       subprocess_path.Append(""Versions"").Append(chrome::kChromeVersion);
   subprocess_path =
       subprocess_path.Append(chrome::kHelperProcessExecutablePath);
   command_line->AppendSwitchPath(switches::kBrowserSubprocessPath,
                                  subprocess_path);
 #endif
 
    if (exit_when_last_browser_closes_)
      command_line->AppendSwitch(switches::kDisableZeroBrowsersOpenForTests);
  
  if (command_line->GetArgs().empty())
   if (open_about_blank_on_browser_launch_ && command_line->GetArgs().empty())
      command_line->AppendArg(url::kAboutBlankURL);
  }","[31, 30]","The SVG implementation in Blink, as used in Google Chrome before 31.0.1650.48, allows remote attackers to cause a denial of service (out-of-bounds read) by leveraging the use of tree order, rather than transitive dependency order, for layout."
8895,"static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {
st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
r_buf_seek (b, addr, R_BUF_SET);
module->base_of_image = r_buf_read_le64 (b);
module->size_of_image = r_buf_read_le32 (b);
module->check_sum = r_buf_read_le32 (b);
module->time_date_stamp = r_buf_read_le32 (b);
module->module_name_rva = r_buf_read_le32 (b);
module->version_info.dw_signature = r_buf_read_le32 (b);
module->version_info.dw_struc_version = r_buf_read_le32 (b);
module->version_info.dw_file_version_ms = r_buf_read_le32 (b);
module->version_info.dw_file_version_ls = r_buf_read_le32 (b);
module->version_info.dw_product_version_ms = r_buf_read_le32 (b);
module->version_info.dw_product_version_ls = r_buf_read_le32 (b);
module->version_info.dw_file_flags_mask = r_buf_read_le32 (b);
module->version_info.dw_file_flags = r_buf_read_le32 (b);
module->version_info.dw_file_os = r_buf_read_le32 (b);
module->version_info.dw_file_type = r_buf_read_le32 (b);
module->version_info.dw_file_subtype = r_buf_read_le32 (b);
module->version_info.dw_file_date_ms = r_buf_read_le32 (b);
module->version_info.dw_file_date_ls = r_buf_read_le32 (b);
module->cv_record.data_size = r_buf_read_le32 (b);
module->cv_record.rva = r_buf_read_le32 (b);
module->misc_record.data_size = r_buf_read_le32 (b);
module->misc_record.rva = r_buf_read_le32 (b);
module->reserved_0 = r_buf_read_le64 (b);
module->reserved_1 = r_buf_read_le64 (b);
r_buf_seek (b, o_addr, R_BUF_SET);
}","[3, 27]",Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.
198212," void _xml_characterDataHandler(void *userData, const XML_Char *s, int len)
 {
 	xml_parser *parser = (xml_parser *)userData;
 
 	if (parser) {
 		zval *retval, *args[2];
 
 		if (parser->characterDataHandler) {
 			args[0] = _xml_resource_zval(parser->index);
 			args[1] = _xml_xmlchar_zval(s, len, parser->target_encoding);
                         if ((retval = xml_call_handler(parser, parser->characterDataHandler, parser->characterDataPtr, 2, args))) {
                                 zval_ptr_dtor(&retval);
                         }
               } 
                }
  
                 if (parser->data) {
                         int i;
 			int doprint = 0;
  
                         char *decoded_value;
                         int decoded_len;
 
                         decoded_value = xml_utf8_decode(s,len,&decoded_len,parser->target_encoding);
                         for (i = 0; i < decoded_len; i++) {
                                 switch (decoded_value[i]) {
 				case ' ':
 				case '\t':
 				case '\n':
 					continue;
 				default:
 					doprint = 1;
 					break;
 				}
 				if (doprint) {
 					break;
 				}
 			}
                         if (doprint || (! parser->skipwhite)) {
                                 if (parser->lastwasopen) {
                                         zval **myval;
 
                                          
                                         if (zend_hash_find(Z_ARRVAL_PP(parser->ctag),""value"",sizeof(""value""),(void **) &myval) == SUCCESS) {
                                                 int newlen = Z_STRLEN_PP(myval) + decoded_len;
 						Z_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);
 						strncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);
 						Z_STRLEN_PP(myval) += decoded_len;
 						efree(decoded_value);
                                         } else {
                                                 add_assoc_string(*(parser->ctag),""value"",decoded_value,0);
                                         }
 
                                 } else {
                                         zval *tag;
                                         zval **curtag, **mytype, **myval;
 					HashPosition hpos=NULL;
 
 					zend_hash_internal_pointer_end_ex(Z_ARRVAL_P(parser->data), &hpos);
 
 					if (hpos && (zend_hash_get_current_data_ex(Z_ARRVAL_P(parser->data), (void **) &curtag, &hpos) == SUCCESS)) {
 						if (zend_hash_find(Z_ARRVAL_PP(curtag),""type"",sizeof(""type""),(void **) &mytype) == SUCCESS) {
 							if (!strcmp(Z_STRVAL_PP(mytype), ""cdata"")) {
 								if (zend_hash_find(Z_ARRVAL_PP(curtag),""value"",sizeof(""value""),(void **) &myval) == SUCCESS) {
 									int newlen = Z_STRLEN_PP(myval) + decoded_len;
 									Z_STRVAL_PP(myval) = erealloc(Z_STRVAL_PP(myval),newlen+1);
 									strncpy(Z_STRVAL_PP(myval) + Z_STRLEN_PP(myval), decoded_value, decoded_len + 1);
 									Z_STRLEN_PP(myval) += decoded_len;
 									efree(decoded_value);
 									return;
 								}
 							}
                                                 }
                                         }
  
                                       if (parser->level <= XML_MAXLEVEL) {
                                        if (parser->level <= XML_MAXLEVEL && parser->level > 0) {
                                                 MAKE_STD_ZVAL(tag);
  
                                                 array_init(tag);
 
 						_xml_add_to_info(parser,parser->ltags[parser->level-1] + parser->toffset);
 
 						add_assoc_string(tag,""tag"",parser->ltags[parser->level-1] + parser->toffset,1);
 						add_assoc_string(tag,""value"",decoded_value,0);
 						add_assoc_string(tag,""type"",""cdata"",1);
 						add_assoc_long(tag,""level"",parser->level);
 
 						zend_hash_next_index_insert(Z_ARRVAL_P(parser->data),&tag,sizeof(zval*),NULL);
 					} else if (parser->level == (XML_MAXLEVEL + 1)) {
 						TSRMLS_FETCH();
 						php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Maximum depth exceeded - Results truncated"");
 					}
 				}
 			} else {
 				efree(decoded_value);
 			}
 		}
 	}
 }","[15, 23, 42, 53, 77, 14, 76]","The xml_parse_into_struct function in ext/xml/xml.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 allows remote attackers to cause a denial of service (buffer under-read and segmentation fault) or possibly have unspecified other impact via crafted XML data in the second argument, leading to a parser level of zero."
201822," newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)
 {
 	struct sshbuf *b = NULL;
 	struct sshcomp *comp;
 	struct sshenc *enc;
 	struct sshmac *mac;
 	struct newkeys *newkey = NULL;
 	size_t keylen, ivlen, maclen;
 	int r;
 
 	if ((newkey = calloc(1, sizeof(*newkey))) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
 	if ((r = sshbuf_froms(m, &b)) != 0)
 		goto out;
 #ifdef DEBUG_PK
 	sshbuf_dump(b, stderr);
 #endif
 	enc = &newkey->enc;
 	mac = &newkey->mac;
 	comp = &newkey->comp;
 
 	if ((r = sshbuf_get_cstring(b, &enc->name, NULL)) != 0 ||
 	    (r = sshbuf_get(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
 	    (r = sshbuf_get_u32(b, (u_int *)&enc->enabled)) != 0 ||
 	    (r = sshbuf_get_u32(b, &enc->block_size)) != 0 ||
 	    (r = sshbuf_get_string(b, &enc->key, &keylen)) != 0 ||
 	    (r = sshbuf_get_string(b, &enc->iv, &ivlen)) != 0)
 		goto out;
 	if (cipher_authlen(enc->cipher) == 0) {
 		if ((r = sshbuf_get_cstring(b, &mac->name, NULL)) != 0)
 			goto out;
 		if ((r = mac_setup(mac, mac->name)) != 0)
 			goto out;
 		if ((r = sshbuf_get_u32(b, (u_int *)&mac->enabled)) != 0 ||
 		    (r = sshbuf_get_string(b, &mac->key, &maclen)) != 0)
 			goto out;
 		if (maclen > mac->key_len) {
 			r = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
  		mac->key_len = maclen;
  	}
  	if ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||
	    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||
  	    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)
  		goto out;
  	if (enc->name == NULL ||
 	    cipher_by_name(enc->name) != enc->cipher) {
 		r = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
 	if (sshbuf_len(b) != 0) {
 		r = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
 	enc->key_len = keylen;
 	enc->iv_len = ivlen;
 	ssh->kex->newkeys[mode] = newkey;
 	newkey = NULL;
 	r = 0;
  out:
 	free(newkey);
 	sshbuf_free(b);
 	return r;
 }",[46],"The shared memory manager (associated with pre-authentication compression) in sshd in OpenSSH before 7.4 does not ensure that a bounds check is enforced by all compilers, which might allows local users to gain privileges by leveraging access to a sandboxed privilege-separation process, related to the m_zback and m_zlib data structures."
206788," bool VaapiVideoDecodeAccelerator::VaapiH264Accelerator::SubmitFrameMetadata(
     const H264SPS* sps,
     const H264PPS* pps,
     const H264DPB& dpb,
     const H264Picture::Vector& ref_pic_listp0,
      const H264Picture::Vector& ref_pic_listb0,
      const H264Picture::Vector& ref_pic_listb1,
      const scoped_refptr<H264Picture>& pic) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
    VAPictureParameterBufferH264 pic_param;
    memset(&pic_param, 0, sizeof(pic_param));
  
 #define FROM_SPS_TO_PP(a) pic_param.a = sps->a
 #define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a
   FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);
   FROM_SPS_TO_PP2(pic_height_in_map_units_minus1, picture_height_in_mbs_minus1);
   FROM_SPS_TO_PP(bit_depth_luma_minus8);
   FROM_SPS_TO_PP(bit_depth_chroma_minus8);
 #undef FROM_SPS_TO_PP
 #undef FROM_SPS_TO_PP2
 
 #define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a
 #define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a
   FROM_SPS_TO_PP_SF(chroma_format_idc);
   FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,
                      residual_colour_transform_flag);
   FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);
   FROM_SPS_TO_PP_SF(frame_mbs_only_flag);
   FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);
   FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);
   pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);
   FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);
   FROM_SPS_TO_PP_SF(pic_order_cnt_type);
   FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);
   FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);
 #undef FROM_SPS_TO_PP_SF
 #undef FROM_SPS_TO_PP_SF2
 
 #define FROM_PPS_TO_PP(a) pic_param.a = pps->a
   FROM_PPS_TO_PP(pic_init_qp_minus26);
   FROM_PPS_TO_PP(pic_init_qs_minus26);
   FROM_PPS_TO_PP(chroma_qp_index_offset);
   FROM_PPS_TO_PP(second_chroma_qp_index_offset);
 #undef FROM_PPS_TO_PP
 
 #define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a
 #define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a
   FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);
   FROM_PPS_TO_PP_PF(weighted_pred_flag);
   FROM_PPS_TO_PP_PF(weighted_bipred_idc);
   FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);
 
   pic_param.pic_fields.bits.field_pic_flag = 0;
   FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);
   FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,
                      pic_order_present_flag);
   FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);
   FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);
   pic_param.pic_fields.bits.reference_pic_flag = pic->ref;
 #undef FROM_PPS_TO_PP_PF
 #undef FROM_PPS_TO_PP_PF2
 
   pic_param.frame_num = pic->frame_num;
 
   InitVAPicture(&pic_param.CurrPic);
   FillVAPicture(&pic_param.CurrPic, pic);
 
   for (int i = 0; i < 16; ++i)
     InitVAPicture(&pic_param.ReferenceFrames[i]);
 
   FillVARefFramesFromDPB(dpb, pic_param.ReferenceFrames,
                          arraysize(pic_param.ReferenceFrames));
 
   pic_param.num_ref_frames = sps->max_num_ref_frames;
 
   if (!vaapi_wrapper_->SubmitBuffer(VAPictureParameterBufferType,
                                     sizeof(pic_param), &pic_param))
     return false;
 
   VAIQMatrixBufferH264 iq_matrix_buf;
   memset(&iq_matrix_buf, 0, sizeof(iq_matrix_buf));
 
   if (pps->pic_scaling_matrix_present_flag) {
     for (int i = 0; i < 6; ++i) {
       for (int j = 0; j < 16; ++j)
         iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =
             pps->scaling_list4x4[i][j];
     }
 
     for (int i = 0; i < 2; ++i) {
       for (int j = 0; j < 64; ++j)
         iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =
             pps->scaling_list8x8[i][j];
     }
   } else {
     for (int i = 0; i < 6; ++i) {
       for (int j = 0; j < 16; ++j)
         iq_matrix_buf.ScalingList4x4[i][kZigzagScan4x4[j]] =
             sps->scaling_list4x4[i][j];
     }
 
     for (int i = 0; i < 2; ++i) {
       for (int j = 0; j < 64; ++j)
         iq_matrix_buf.ScalingList8x8[i][kZigzagScan8x8[j]] =
             sps->scaling_list8x8[i][j];
     }
   }
 
   return vaapi_wrapper_->SubmitBuffer(VAIQMatrixBufferType,
                                       sizeof(iq_matrix_buf), &iq_matrix_buf);
 }",[9],A race in the handling of SharedArrayBuffers in WebAssembly in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
205225," void BrowserView::TabDetachedAt(TabContents* contents, int index) {
 void BrowserView::TabDetachedAt(WebContents* contents, int index) {
   if (index == browser_->active_index()) {
     contents_container_->SetWebContents(NULL);
     infobar_container_->ChangeTabContents(NULL);
     UpdateDevToolsForContents(NULL);
   }
 }",[2],"The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors."
201312," nfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,
 					struct nfsd3_readargs *args)
 {
 	unsigned int len;
 	int v;
 	u32 max_blocksize = svc_max_payload(rqstp);
 
 	p = decode_fh(p, &args->fh);
  	if (!p)
  		return 0;
  	p = xdr_decode_hyper(p, &args->offset);
  	args->count = ntohl(*p++);
 
 	if (!xdr_argsize_check(rqstp, p))
 		return 0;
 
  	len = min(args->count, max_blocksize);
  
  	 
 	v=0;
 	while (len > 0) {
 		struct page *p = *(rqstp->rq_next_page++);
 
 		rqstp->rq_vec[v].iov_base = page_address(p);
 		rqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);
 		len -= rqstp->rq_vec[v].iov_len;
  		v++;
  	}
  	args->vlen = v;
	return xdr_argsize_check(rqstp, p);
 	return 1;
  }","[13, 14, 15, 16, 31, 30]","The NFSv4 implementation in the Linux kernel through 4.11.1 allows local users to cause a denial of service (resource consumption) by leveraging improper channel callback shutdown when unmounting an NFSv4 filesystem, aka a *module reference and kernel daemon* leak."
1052,"bool Messageheader::Parser::state_fieldbody_crlf(char ch)
{
if (ch == '\r')
SET_STATE(state_end_cr);
else if (ch == '\n')
{
log_debug(""header "" << fieldnamePtr << "": "" << fieldbodyPtr);
switch (header.onField(fieldnamePtr, fieldbodyPtr))
{
case OK:
case END:  return true;
break;
case FAIL: failedFlag = true;
log_warn(""invalid character "" << chartoprint(ch) << "" in fieldbody"");
break;
}

return true;
}
else if (std::isspace(ch))
{

checkHeaderspace(1);
*(headerdataPtr - 1) = '\n';
*headerdataPtr++ = ch;
SET_STATE(state_fieldbody);
}
else if (ch >= 33 && ch <= 126)
{
switch (header.onField(fieldnamePtr, fieldbodyPtr))
{
case OK:   SET_STATE(state_fieldname);
break;
case FAIL: failedFlag = true;
log_warn(""invalid character "" << chartoprint(ch) << "" in fieldbody"");
break;
case END:  return true;
break;
}

fieldnamePtr = headerdataPtr;
checkHeaderspace(1);
*headerdataPtr++ = ch;
}
return false;
}",[18],"framework/common/messageheaderparser.cpp in Tntnet before 2.2.1 allows remote attackers to obtain sensitive information via a header that ends in \n instead of \r\n, which prevents a null terminator from being added and causes Tntnet to include headers from other requests."
206340,"  void ReportPreconnectAccuracy(
      const PreconnectStats& stats,
    const std::map<GURL, OriginRequestSummary>& requests) {
     const std::map<url::Origin, OriginRequestSummary>& requests) {
    if (stats.requests_stats.empty())
      return;
  
   int preresolve_hits_count = 0;
   int preresolve_misses_count = 0;
   int preconnect_hits_count = 0;
   int preconnect_misses_count = 0;
 
   for (const auto& request_stats : stats.requests_stats) {
     bool hit = requests.find(request_stats.origin) != requests.end();
     bool preconnect = request_stats.was_preconnected;
 
     preresolve_hits_count += hit;
     preresolve_misses_count += !hit;
     preconnect_hits_count += preconnect && hit;
     preconnect_misses_count += preconnect && !hit;
   }
 
   int total_preresolves = preresolve_hits_count + preresolve_misses_count;
   int total_preconnects = preconnect_hits_count + preconnect_misses_count;
   DCHECK_EQ(static_cast<int>(stats.requests_stats.size()),
             preresolve_hits_count + preresolve_misses_count);
   DCHECK_GT(total_preresolves, 0);
 
   size_t preresolve_hits_percentage =
       (100 * preresolve_hits_count) / total_preresolves;
 
   if (total_preconnects > 0) {
     size_t preconnect_hits_percentage =
         (100 * preconnect_hits_count) / total_preconnects;
     UMA_HISTOGRAM_PERCENTAGE(
         internal::kLoadingPredictorPreconnectHitsPercentage,
         preconnect_hits_percentage);
   }
 
   UMA_HISTOGRAM_PERCENTAGE(internal::kLoadingPredictorPreresolveHitsPercentage,
                            preresolve_hits_percentage);
   UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreresolveCount,
                            total_preresolves);
   UMA_HISTOGRAM_COUNTS_100(internal::kLoadingPredictorPreconnectCount,
                            total_preconnects);
 }","[4, 3]","Insufficient validation of untrusted input in Skia in Google Chrome prior to 59.0.3071.86 for Linux, Windows, and Mac, and 59.0.3071.92 for Android, allowed a remote attacker to perform an out of bounds memory read via a crafted HTML page."
204828," void OneClickSigninHelper::ShowInfoBarIfPossible(net::URLRequest* request,
                                                  ProfileIOData* io_data,
                                                  int child_id,
                                                  int route_id) {
   std::string google_chrome_signin_value;
   std::string google_accounts_signin_value;
   request->GetResponseHeaderByName(""Google-Chrome-SignIn"",
                                    &google_chrome_signin_value);
   request->GetResponseHeaderByName(""Google-Accounts-SignIn"",
                                    &google_accounts_signin_value);
 
   if (!google_accounts_signin_value.empty() ||
       !google_chrome_signin_value.empty()) {
     VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
             << "" g-a-s='"" << google_accounts_signin_value << ""'""
              << "" g-c-s='"" << google_chrome_signin_value << ""'"";
    }
  
  if (!gaia::IsGaiaSignonRealm(request->original_url().GetOrigin()))
   if (!gaia::IsGaiaSignonRealm(request->url().GetOrigin()))
      return;
  
   std::vector<std::pair<std::string, std::string> > pairs;
   base::SplitStringIntoKeyValuePairs(google_accounts_signin_value, '=', ',',
                                      &pairs);
   std::string session_index;
   std::string email;
   for (size_t i = 0; i < pairs.size(); ++i) {
     const std::pair<std::string, std::string>& pair = pairs[i];
     const std::string& key = pair.first;
     const std::string& value = pair.second;
     if (key == ""email"") {
       TrimString(value, ""\"""", &email);
     } else if (key == ""sessionindex"") {
       session_index = value;
     }
   }
 
   if (!email.empty())
     io_data->set_reverse_autologin_pending_email(email);
 
   if (!email.empty() || !session_index.empty()) {
     VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
             << "" email="" << email
             << "" sessionindex="" << session_index;
   }
 
   AutoAccept auto_accept = AUTO_ACCEPT_NONE;
   signin::Source source = signin::SOURCE_UNKNOWN;
   GURL continue_url;
   std::vector<std::string> tokens;
   base::SplitString(google_chrome_signin_value, ',', &tokens);
   for (size_t i = 0; i < tokens.size(); ++i) {
     const std::string& token = tokens[i];
     if (token == ""accepted"") {
       auto_accept = AUTO_ACCEPT_ACCEPTED;
     } else if (token == ""configure"") {
       auto_accept = AUTO_ACCEPT_CONFIGURE;
     } else if (token == ""rejected-for-profile"") {
       auto_accept = AUTO_ACCEPT_REJECTED_FOR_PROFILE;
     }
   }
 
   source = GetSigninSource(request->url(), &continue_url);
   if (source != signin::SOURCE_UNKNOWN)
     auto_accept = AUTO_ACCEPT_EXPLICIT;
 
   if (auto_accept != AUTO_ACCEPT_NONE) {
     VLOG(1) << ""OneClickSigninHelper::ShowInfoBarIfPossible:""
             << "" auto_accept="" << auto_accept;
   }
 
   if (session_index.empty() && email.empty() &&
       auto_accept == AUTO_ACCEPT_NONE && !continue_url.is_valid()) {
     return;
   }
 
   content::BrowserThread::PostTask(
       content::BrowserThread::UI, FROM_HERE,
       base::Bind(&OneClickSigninHelper::ShowInfoBarUIThread, session_index,
                  email, auto_accept, source, continue_url, child_id, route_id));
 }","[20, 19]","The OneClickSigninHelper::ShowInfoBarIfPossible function in browser/ui/sync/one_click_signin_helper.cc in Google Chrome before 31.0.1650.63 uses an incorrect URL during realm validation, which allows remote attackers to conduct session fixation attacks and hijack web sessions by triggering improper sync after a 302 (aka Found) HTTP status code."
203750," void CCLayerTreeHostTest::endTest()
  {
      if (!isMainThread())
        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));
         m_mainThreadProxy->postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));
      else {
         if (m_beginning)
             m_endWhenBeginReturns = true;
         else
             onEndTest(static_cast<void*>(this));
     }
 }","[5, 4]","Google Chrome before 14.0.835.202 does not properly handle Google V8 hidden objects, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code."
202677," static int ecdsa_sign_det_restartable( mbedtls_ecp_group *grp,
                      mbedtls_mpi *r, mbedtls_mpi *s,
                      const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
                      mbedtls_md_type_t md_alg,
                     int (*f_rng_blind)(void *, unsigned char *, size_t),
                     void *p_rng_blind,
                      mbedtls_ecdsa_restart_ctx *rs_ctx )
  {
      int ret;
     mbedtls_hmac_drbg_context rng_ctx;
     mbedtls_hmac_drbg_context *p_rng = &rng_ctx;
     unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
     size_t grp_len = ( grp->nbits + 7 ) / 8;
     const mbedtls_md_info_t *md_info;
     mbedtls_mpi h;
 
     if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
         return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
 
     mbedtls_mpi_init( &h );
     mbedtls_hmac_drbg_init( &rng_ctx );
 
     ECDSA_RS_ENTER( det );
 
 #if defined(MBEDTLS_ECP_RESTARTABLE)
     if( rs_ctx != NULL && rs_ctx->det != NULL )
     {
          
         p_rng = &rs_ctx->det->rng_ctx;
 
          
         if( rs_ctx->det->state == ecdsa_det_sign )
             goto sign;
     }
 #endif  
 
      
     MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, data, grp_len ) );
     MBEDTLS_MPI_CHK( derive_mpi( grp, &h, buf, blen ) );
     MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &h, data + grp_len, grp_len ) );
     mbedtls_hmac_drbg_seed_buf( p_rng, md_info, data, 2 * grp_len );
 
 #if defined(MBEDTLS_ECP_RESTARTABLE)
     if( rs_ctx != NULL && rs_ctx->det != NULL )
         rs_ctx->det->state = ecdsa_det_sign;
 
 sign:
 #endif
 #if defined(MBEDTLS_ECDSA_SIGN_ALT)
      ret = mbedtls_ecdsa_sign( grp, r, s, d, buf, blen,
                                mbedtls_hmac_drbg_random, p_rng );
  #else
    ret = ecdsa_sign_restartable( grp, r, s, d, buf, blen,
                      mbedtls_hmac_drbg_random, p_rng, rs_ctx );
     if( f_rng_blind != NULL )
         ret = ecdsa_sign_restartable( grp, r, s, d, buf, blen,
                                       mbedtls_hmac_drbg_random, p_rng,
                                       f_rng_blind, p_rng_blind, rs_ctx );
     else
     {
         mbedtls_hmac_drbg_context *p_rng_blind_det;
 
 #if !defined(MBEDTLS_ECP_RESTARTABLE)
          
         const char* blind_label = ""BLINDING CONTEXT"";
         mbedtls_hmac_drbg_context rng_ctx_blind;
 
         mbedtls_hmac_drbg_init( &rng_ctx_blind );
         p_rng_blind_det = &rng_ctx_blind;
 
         mbedtls_hmac_drbg_seed_buf( p_rng_blind_det, md_info,
                                     data, 2 * grp_len );
         ret = mbedtls_hmac_drbg_update_ret( p_rng_blind_det,
                                             (const unsigned char*) blind_label,
                                             strlen( blind_label ) );
         if( ret != 0 )
         {
             mbedtls_hmac_drbg_free( &rng_ctx_blind );
             goto cleanup;
         }
 #else
          
         p_rng_blind_det = p_rng;
 #endif  
 
          
         ret = ecdsa_sign_restartable( grp, r, s, d, buf, blen,
                                       mbedtls_hmac_drbg_random, p_rng,
                                       mbedtls_hmac_drbg_random, p_rng_blind_det,
                                       rs_ctx );
 
 #if !defined(MBEDTLS_ECP_RESTARTABLE)
         mbedtls_hmac_drbg_free( &rng_ctx_blind );
 #endif
     }
  #endif  
  
  cleanup:
     mbedtls_hmac_drbg_free( &rng_ctx );
     mbedtls_mpi_free( &h );
 
     ECDSA_RS_LEAVE( det );
 
     return( ret );
  }","[5, 6, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 53, 54]","Arm Mbed TLS before 2.19.0 and Arm Mbed Crypto before 2.0.0, when deterministic ECDSA is enabled, use an RNG with insufficient entropy for blinding, which might allow an attacker to recover a private key via side-channel attacks if a victim signs the same message many times. (For Mbed TLS, the fix is also available in versions 2.7.12 and 2.16.3.)"
8375,"static enum sctp_disposition sctp_sf_do_unexpected_init(
struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const union sctp_subtype type,
void *arg,
struct sctp_cmd_seq *commands)
{
struct sctp_chunk *chunk = arg, *repl, *err_chunk;
struct sctp_unrecognized_param *unk_param;
struct sctp_association *new_asoc;
enum sctp_disposition retval;
struct sctp_packet *packet;
int len;


if (security_sctp_assoc_request((struct sctp_endpoint *)ep,
chunk->skb))
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);










if (!chunk->singleton)
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);




if (chunk->sctp_hdr->vtag != 0)
return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);





if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))
return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
commands);

if (SCTP_INPUT_CB(chunk->skb)->encap_port != chunk->transport->encap_port)
return sctp_sf_new_encap_port(net, ep, asoc, type, arg, commands);


chunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;


chunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));


err_chunk = NULL;
if (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,
(struct sctp_init_chunk *)chunk->chunk_hdr, chunk,
&err_chunk)) {



if (err_chunk) {
packet = sctp_abort_pkt_new(net, ep, asoc, arg,
(__u8 *)(err_chunk->chunk_hdr) +
sizeof(struct sctp_chunkhdr),
ntohs(err_chunk->chunk_hdr->length) -
sizeof(struct sctp_chunkhdr));

if (packet) {
sctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,
SCTP_PACKET(packet));
SCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);
retval = SCTP_DISPOSITION_CONSUME;
} else {
retval = SCTP_DISPOSITION_NOMEM;
}
goto cleanup;
} else {
return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,
commands);
}
}








new_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);
if (!new_asoc)
goto nomem;

if (sctp_assoc_set_bind_addr_from_ep(new_asoc,
sctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)
goto nomem;





if (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),
(struct sctp_init_chunk *)chunk->chunk_hdr,
GFP_ATOMIC))
goto nomem;






if (!sctp_state(asoc, COOKIE_WAIT)) {
if (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,
commands)) {
retval = SCTP_DISPOSITION_CONSUME;
goto nomem_retval;
}
}

sctp_tietags_populate(new_asoc, asoc);






len = 0;
if (err_chunk) {
len = ntohs(err_chunk->chunk_hdr->length) -
sizeof(struct sctp_chunkhdr);
}

repl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);
if (!repl)
goto nomem;





if (err_chunk) {







unk_param = (struct sctp_unrecognized_param *)
((__u8 *)(err_chunk->chunk_hdr) +
sizeof(struct sctp_chunkhdr));



sctp_addto_chunk(repl, len, unk_param);
}

sctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));
sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));






sctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());
retval = SCTP_DISPOSITION_CONSUME;

return retval;

nomem:
retval = SCTP_DISPOSITION_NOMEM;
nomem_retval:
if (new_asoc)
sctp_association_free(new_asoc);
cleanup:
if (err_chunk)
sctp_chunk_free(err_chunk);
return retval;
}","[36, 43, 44, 45]",A flaw was found in the Linux SCTP stack. A blind attacker may be able to kill an existing SCTP association through invalid chunks if the attacker knows the IP-addresses and port numbers being used and the attacker can send packets with spoofed IP addresses.
198499," static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,
                               BN_GENCB *cb)
 {
     BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;
     int bitsp, bitsq, ok = -1, n = 0;
     BN_CTX *ctx = NULL;
     unsigned long error = 0;
 
      
     if (bits < 16) {
         ok = 0;              
         RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);
         goto err;
     }
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
     BN_CTX_start(ctx);
     r0 = BN_CTX_get(ctx);
     r1 = BN_CTX_get(ctx);
     r2 = BN_CTX_get(ctx);
     r3 = BN_CTX_get(ctx);
     if (r3 == NULL)
         goto err;
 
     bitsp = (bits + 1) / 2;
     bitsq = bits - bitsp;
 
      
     if (!rsa->n && ((rsa->n = BN_new()) == NULL))
         goto err;
     if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))
         goto err;
     if (!rsa->e && ((rsa->e = BN_new()) == NULL))
         goto err;
     if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))
         goto err;
     if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))
         goto err;
     if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))
         goto err;
     if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))
         goto err;
     if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))
         goto err;
 
      if (BN_copy(rsa->e, e_value) == NULL)
          goto err;
  
     BN_set_flags(rsa->p, BN_FLG_CONSTTIME);
     BN_set_flags(rsa->q, BN_FLG_CONSTTIME);
      BN_set_flags(r2, BN_FLG_CONSTTIME);
       
      for (;;) {
         if (!BN_sub(r2, rsa->p, BN_value_one()))
             goto err;
         ERR_set_mark();
         if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {
              
             break;
         }
         error = ERR_peek_last_error();
         if (ERR_GET_LIB(error) == ERR_LIB_BN
             && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {
              
             ERR_pop_to_mark();
         } else {
             goto err;
         }
         if (!BN_GENCB_call(cb, 2, n++))
             goto err;
     }
     if (!BN_GENCB_call(cb, 3, 0))
         goto err;
     for (;;) {
         do {
             if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))
                 goto err;
         } while (BN_cmp(rsa->p, rsa->q) == 0);
         if (!BN_sub(r2, rsa->q, BN_value_one()))
             goto err;
         ERR_set_mark();
         if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {
              
             break;
         }
         error = ERR_peek_last_error();
         if (ERR_GET_LIB(error) == ERR_LIB_BN
             && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {
              
             ERR_pop_to_mark();
         } else {
             goto err;
         }
         if (!BN_GENCB_call(cb, 2, n++))
             goto err;
     }
     if (!BN_GENCB_call(cb, 3, 1))
         goto err;
     if (BN_cmp(rsa->p, rsa->q) < 0) {
         tmp = rsa->p;
         rsa->p = rsa->q;
         rsa->q = tmp;
     }
 
      
     if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))
         goto err;
 
      
     if (!BN_sub(r1, rsa->p, BN_value_one()))
         goto err;                
     if (!BN_sub(r2, rsa->q, BN_value_one()))
         goto err;                
     if (!BN_mul(r0, r1, r2, ctx))
         goto err;                
     {
         BIGNUM *pr0 = BN_new();
 
         if (pr0 == NULL)
             goto err;
         BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);
         if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx)) {
             BN_free(pr0);
             goto err;                
         }
          
         BN_free(pr0);
     }
 
     {
         BIGNUM *d = BN_new();
 
         if (d == NULL)
             goto err;
         BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
 
         if (    
                !BN_mod(rsa->dmp1, d, r1, ctx)
                 
             || !BN_mod(rsa->dmq1, d, r2, ctx)) {
             BN_free(d);
             goto err;
         }
          
         BN_free(d);
     }
 
     {
         BIGNUM *p = BN_new();
 
         if (p == NULL)
             goto err;
         BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);
 
          
         if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx)) {
             BN_free(p);
             goto err;
         }
          
         BN_free(p);
     }
 
     ok = 1;
  err:
     if (ok == -1) {
         RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);
         ok = 0;
     }
     if (ctx != NULL)
         BN_CTX_end(ctx);
     BN_CTX_free(ctx);
 
     return ok;
 }","[51, 52]",The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).
7490,"decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,
void *val)
{
krb5_error_code ret;
const uint8_t *contents;
size_t i, j, clen;
taginfo t;

assert(seq->n_fields > 0);
for (i = 0; i < seq->n_fields; i++) {
if (len == 0)
break;
ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);
if (ret)
goto error;







for (; i < seq->n_fields; i++) {
if (check_atype_tag(seq->fields[i], &t))
break;
ret = omit_atype(seq->fields[i], val);
if (ret)
goto error;
}


if (i == seq->n_fields)
break;
ret = decode_atype(&t, contents, clen, seq->fields[i], val);
if (ret)
goto error;
}


for (; i < seq->n_fields; i++) {
ret = omit_atype(seq->fields[i], val);
if (ret)
goto error;
}
return 0;

error:


for (j = 0; j < i; j++)
free_atype(seq->fields[j], val);
for (j = 0; j < i; j++)
free_atype_ptr(seq->fields[j], val);
return ret;
}",[13],MIT Kerberos 5 (aka krb5) before 1.17.2 and 1.18.x before 1.18.3 allows unbounded recursion via an ASN.1-encoded Kerberos message because the lib/krb5/asn.1/asn1_encode.c support for BER indefinite lengths lacks a recursion limit.
198313," int ssl3_send_alert(SSL *s, int level, int desc)
 {
      
     desc = s->method->ssl3_enc->alert_value(desc);
     if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
         desc = SSL_AD_HANDSHAKE_FAILURE;  
                                            * protocol_version alerts */
      if (desc < 0)
          return -1;
      
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);
     if (level == SSL3_AL_FATAL) {
         if (s->session != NULL)
             SSL_CTX_remove_session(s->session_ctx, s->session);
         s->state = SSL_ST_ERR;
     }
  
      s->s3->alert_dispatch = 1;
      s->s3->send_alert[0] = level;
      * else data is still being written out, we will get written some time in
      * the future
      */
     return -1;
 }","[13, 14, 15, 16, 17, 11, 12]","If an application encounters a fatal protocol error and then calls SSL_shutdown() twice (once to send a close_notify, and once to receive one) then OpenSSL can respond differently to the calling application if a 0 byte record is received with invalid padding compared to if a 0 byte record is received with an invalid MAC. If the application then behaves differently based on that in a way that is detectable to the remote peer, then this amounts to a padding oracle that could be used to decrypt data. In order for this to be exploitable ""non-stitched"" ciphersuites must be in use. Stitched ciphersuites are optimised implementations of certain commonly used ciphersuites. Also the application must call SSL_shutdown() twice even if a protocol error has occurred (applications should not do this but some do anyway). Fixed in OpenSSL 1.0.2r (Affected 1.0.2-1.0.2q)."
207762," zlib_advance(struct zlib *zlib, png_uint_32 nbytes)
   
 #  define ZLIB_TOO_FAR_BACK (-1)
 #  define ZLIB_OK           0
 #  define ZLIB_STREAM_END   1
 #  define ZLIB_FATAL        2
 {
  int state = zlib->state;
  int endrc = ZLIB_OK;
    png_uint_32 in_bytes = 0;
  struct file *file = zlib->file;
 
    assert(state >= 0);
 
  while (in_bytes < nbytes && endrc == ZLIB_OK)
  {
       png_uint_32 out_bytes;
  int flush;
       png_byte bIn = reread_byte(file);
       png_byte bOut;
 
  switch (state)
  {
  case 0:  
  {
  int file_bits = 8+(bIn >> 4);
  int new_bits = zlib->window_bits;
 
 
                 zlib->file_bits = file_bits;
  
                  
                 if (new_bits == 0)  
                  zlib->window_bits = file_bits;
                   zlib->window_bits = ((file_bits > 15) ? 15 : file_bits);
  
                 else if (new_bits != file_bits)  
                    bIn = (png_byte)((bIn & 0xf) + ((new_bits-8) << 4));
  }
 
             zlib->header[0] = bIn;
             zlib->state = state = 1;
  break;
 
  case 1:  
  {
  int b2 = bIn & 0xe0;  
 
   
                b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;
 
   
 
                 if (bIn != b2)
                 {
                     
                    if (zlib->file_bits == zlib->window_bits)
                       zlib->cksum = 1;
 
                   bIn = (png_byte)b2;
  }
  }
 
             zlib->header[1] = bIn;
             zlib->state = state = 2;
  break;
 
  default:  
  break;
  }
 
   
       zlib->z.next_in = &bIn;
       zlib->z.avail_in = 1;
       zlib->z.next_out = &bOut;
       zlib->z.avail_out = 0;  
 
   
       flush = Z_NO_FLUSH;
       out_bytes = 0;
 
   
  for (;endrc == ZLIB_OK;
          flush = Z_SYNC_FLUSH,
          zlib->z.next_out = &bOut,
          zlib->z.avail_out = 1,
  ++out_bytes)
  {
          zlib->rc = inflate(&zlib->z, flush);
          out_bytes -= zlib->z.avail_out;
 
  switch (zlib->rc)
  {
  case Z_BUF_ERROR:
  if (zlib->z.avail_out == 0)
  continue;  
 
  if (zlib->z.avail_in == 0)
  break;  
 
   
                zlib_message(zlib, 1 );
                endrc = ZLIB_FATAL;  
  break;
 
  case Z_OK:
   
                assert(zlib->z.avail_out == 0 || zlib->z.avail_in == 0);
  continue;
 
  case Z_STREAM_END:
   
                zlib->state = 3;  
                endrc = ZLIB_STREAM_END;
  break;
 
  case Z_NEED_DICT:
                zlib_message(zlib, 0 );
                endrc = ZLIB_FATAL;
  break;
 
  case Z_DATA_ERROR:
   
  if (zlib->z.msg != NULL &&
                   strcmp(zlib->z.msg, ""invalid distance too far back"") == 0)
  {
                   endrc = ZLIB_TOO_FAR_BACK;
  break;
  }
   
 
  default:
                zlib_message(zlib, 0 );
                endrc = ZLIB_FATAL;
  break;
  }  
 
   
  break;
  }  
 
   
       zlib->uncompressed_digits = uarb_add32(zlib->uncompressed_bytes,
          zlib->uncompressed_digits, out_bytes);
 
   
       assert(zlib->z.avail_in == 0 || endrc != ZLIB_OK);
 
       in_bytes += 1 - zlib->z.avail_in;
  }  
 
    assert(in_bytes == nbytes || endrc != ZLIB_OK);
 
   
    zlib->compressed_digits = uarb_add32(zlib->compressed_bytes,
       zlib->compressed_digits, in_bytes - zlib->z.avail_in);
 
   
  if (endrc == ZLIB_STREAM_END && zlib->window_bits < zlib->ok_bits)
  {
  struct chunk *chunk = zlib->chunk;
 
       chunk->uncompressed_digits = uarb_copy(chunk->uncompressed_bytes,
          zlib->uncompressed_bytes, zlib->uncompressed_digits);
       chunk->compressed_digits = uarb_copy(chunk->compressed_bytes,
          zlib->compressed_bytes, zlib->compressed_digits);
       chunk->rewrite_buffer[0] = zlib->header[0];
       chunk->rewrite_buffer[1] = zlib->header[1];
 
  if (zlib->window_bits != zlib->file_bits || zlib->cksum)
  {
   
          chunk->rewrite_offset = zlib->rewrite_offset;
          chunk->rewrite_length = 2;
  }
 
  else
  {
          chunk->rewrite_offset = 0;
          chunk->rewrite_length = 0;
  }
 
  if (in_bytes < nbytes)
          chunk_message(chunk, ""extra compressed data"");
 
       zlib->extra_bytes = nbytes - in_bytes;
       zlib->ok_bits = zlib->window_bits;
  }
 
  return endrc;
 }","[35, 34]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
198108,"  pvscsi_convert_sglist(PVSCSIRequest *r)
  {
    int chunk_size;
     uint32_t chunk_size, elmcnt = 0;
      uint64_t data_length = r->req.dataLen;
      PVSCSISGState sg = r->sg;
    while (data_length) {
        while (!sg.resid) {
     while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {
         while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {
              pvscsi_get_next_sg_elem(&sg);
              trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,
                                          r->sg.resid);
          }
        assert(data_length > 0);
        chunk_size = MIN((unsigned) data_length, sg.resid);
         chunk_size = MIN(data_length, sg.resid);
          if (chunk_size) {
              qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);
          }
         sg.dataAddr += chunk_size;
         data_length -= chunk_size;
         sg.resid -= chunk_size;
     }
 }","[4, 9, 10, 17, 3, 7, 8, 15, 16]",The pvscsi_convert_sglist function in hw/scsi/vmw_pvscsi.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) by leveraging an incorrect cast.
203056,"  cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,
      size_t len, const cdf_header_t *h, cdf_secid_t id)
  {
	assert((size_t)CDF_SHORT_SEC_SIZE(h) == len);
 	size_t ss = CDF_SHORT_SEC_SIZE(h);
 	size_t pos = CDF_SHORT_SEC_POS(h, id);
 	assert(ss == len);
 	if (sst->sst_len < (size_t)id) {
 		DPRINTF((""bad sector id %d > %d\n"", id, sst->sst_len));
 		return -1;
 	}
  	(void)memcpy(((char *)buf) + offs,
	    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);
 	    ((const char *)sst->sst_tab) + pos, len);
  	return len;
  }","[5, 6, 7, 8, 9, 10, 11, 14, 4, 13]",file before 5.11 and libmagic allow remote attackers to cause a denial of service (crash) via a crafted Composite Document File (CDF) file that triggers (1) an out-of-bounds read or (2) an invalid pointer dereference.
198606," ProcXResQueryResourceBytes (ClientPtr client)
 {
     REQUEST(xXResQueryResourceBytesReq);
 
     int                          rc;
      ConstructResourceBytesCtx    ctx;
  
      REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);
     if (stuff->numSpecs > UINT32_MAX / sizeof(ctx.specs[0]))
         return BadLength;
      REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,
                         stuff->numSpecs * sizeof(ctx.specs[0]));
  
                                        (void*) ((char*) stuff +
                                                 sz_xXResQueryResourceBytesReq))) {
         return BadAlloc;
     }
 
     rc = ConstructResourceBytes(stuff->client, &ctx);
 
     if (rc == Success) {
         xXResQueryResourceBytesReply rep = {
             .type = X_Reply,
             .sequenceNumber = client->sequence,
             .length = bytes_to_int32(ctx.resultBytes),
             .numSizes = ctx.numSizes
         };
 
         if (client->swapped) {
             swaps (&rep.sequenceNumber);
             swapl (&rep.length);
             swapl (&rep.numSizes);
 
             SwapXResQueryResourceBytes(&ctx.response);
         }
 
         WriteToClient(client, sizeof(rep), &rep);
         WriteFragmentsToClient(client, &ctx.response);
     }
 
     DestroyConstructResourceBytesCtx(&ctx);
 
     return rc;
 }","[9, 10]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.
207055,"  void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {
   ContextLifecycleObserver::Trace(visitor);
    visitor->Trace(factory_);
    visitor->Trace(resolver_);
    visitor->Trace(options_);
 }",[2],Incorrect object lifecycle management in Blink in Google Chrome prior to 72.0.3626.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
206896," void ResourceCoordinatorService::OnStart() {
   ref_factory_.reset(new service_manager::ServiceContextRefFactory(
       base::Bind(&service_manager::ServiceContext::RequestQuit,
                  base::Unretained(context()))));
 
   ukm_recorder_ = ukm::MojoUkmRecorder::Create(context()->connector());
 
   registry_.AddInterface(
       base::Bind(&CoordinationUnitIntrospectorImpl::BindToInterface,
                  base::Unretained(&introspector_)));
 
   auto page_signal_generator_impl = std::make_unique<PageSignalGeneratorImpl>();
   registry_.AddInterface(
       base::Bind(&PageSignalGeneratorImpl::BindToInterface,
                  base::Unretained(page_signal_generator_impl.get())));
   coordination_unit_manager_.RegisterObserver(
       std::move(page_signal_generator_impl));
 
   coordination_unit_manager_.RegisterObserver(
       std::make_unique<MetricsCollector>());
 
   coordination_unit_manager_.RegisterObserver(
       std::make_unique<IPCVolumeReporter>(
           std::make_unique<base::OneShotTimer>()));
 
   coordination_unit_manager_.OnStart(&registry_, ref_factory_.get());
   coordination_unit_manager_.set_ukm_recorder(ukm_recorder_.get());
 
   memory_instrumentation_coordinator_ =
       std::make_unique<memory_instrumentation::CoordinatorImpl>(
           context()->connector());
    registry_.AddInterface(base::BindRepeating(
        &memory_instrumentation::CoordinatorImpl::BindCoordinatorRequest,
        base::Unretained(memory_instrumentation_coordinator_.get())));
   registry_.AddInterface(base::BindRepeating(
       &memory_instrumentation::CoordinatorImpl::BindHeapProfilerHelperRequest,
       base::Unretained(memory_instrumentation_coordinator_.get())));
  
    tracing_agent_registry_ = std::make_unique<tracing::AgentRegistry>();
    registry_.AddInterface(
       base::BindRepeating(&tracing::AgentRegistry::BindAgentRegistryRequest,
                           base::Unretained(tracing_agent_registry_.get())));
 
   tracing_coordinator_ = std::make_unique<tracing::Coordinator>();
   registry_.AddInterface(
       base::BindRepeating(&tracing::Coordinator::BindCoordinatorRequest,
                           base::Unretained(tracing_coordinator_.get())));
 }","[35, 36, 37]",Lack of access control checks in Instrumentation in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to obtain memory metadata from privileged processes .
202563," int sas_ex_revalidate_domain(struct domain_device *port_dev)
 {
 	int res;
  	struct domain_device *dev = NULL;
  
  	res = sas_find_bcast_dev(port_dev, &dev);
	while (res == 0 && dev) {
 	if (res == 0 && dev) {
  		struct expander_device *ex = &dev->ex_dev;
  		int i = 0, phy_id;
  
 		do {
 			phy_id = -1;
 			res = sas_find_bcast_phy(dev, &phy_id, i, true);
 			if (phy_id == -1)
 				break;
  			res = sas_rediscover(dev, phy_id);
  			i = phy_id + 1;
  		} while (i < ex->num_phys);
		dev = NULL;
		res = sas_find_bcast_dev(port_dev, &dev);
  	}
  	return res;
  }","[8, 7, 20, 21]","The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code."
206790,"      VP8PictureToVaapiDecodeSurface(const scoped_refptr<VP8Picture>& pic) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
    VaapiVP8Picture* vaapi_pic = pic->AsVaapiVP8Picture();
    CHECK(vaapi_pic);
    return vaapi_pic->dec_surface();
 }",[2],A race in the handling of SharedArrayBuffers in WebAssembly in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
201417," static int decode_zbuf(AVBPrint *bp, const uint8_t *data,
                        const uint8_t *data_end)
 {
     z_stream zstream;
     unsigned char *buf;
     unsigned buf_size;
     int ret;
 
     zstream.zalloc = ff_png_zalloc;
     zstream.zfree  = ff_png_zfree;
     zstream.opaque = NULL;
     if (inflateInit(&zstream) != Z_OK)
         return AVERROR_EXTERNAL;
     zstream.next_in  = (unsigned char *)data;
     zstream.avail_in = data_end - data;
      av_bprint_init(bp, 0, -1);
  
      while (zstream.avail_in > 0) {
        av_bprint_get_buffer(bp, 1, &buf, &buf_size);
        if (!buf_size) {
         av_bprint_get_buffer(bp, 2, &buf, &buf_size);
         if (buf_size < 2) {
              ret = AVERROR(ENOMEM);
              goto fail;
          }
          zstream.next_out  = buf;
        zstream.avail_out = buf_size;
         zstream.avail_out = buf_size - 1;
          ret = inflate(&zstream, Z_PARTIAL_FLUSH);
          if (ret != Z_OK && ret != Z_STREAM_END) {
              ret = AVERROR_EXTERNAL;
             goto fail;
         }
         bp->len += zstream.next_out - buf;
         if (ret == Z_STREAM_END)
             break;
     }
     inflateEnd(&zstream);
     bp->str[bp->len] = 0;
     return 0;
 
 fail:
     inflateEnd(&zstream);
     av_bprint_finalize(bp, NULL);
     return ret;
 }","[21, 22, 28, 19, 20, 27]",FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.
199520," static int wrmsr_interception(struct vcpu_svm *svm)
 {
 	struct msr_data msr;
 	u32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];
 	u64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)
 		| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);
 
 	msr.data = data;
 	msr.index = ecx;
  	msr.host_initiated = false;
  
  	svm->next_rip = kvm_rip_read(&svm->vcpu) + 2;
	if (svm_set_msr(&svm->vcpu, &msr)) {
 	if (kvm_set_msr(&svm->vcpu, &msr)) {
  		trace_kvm_msr_write_ex(ecx, data);
  		kvm_inject_gp(&svm->vcpu, 0);
  	} else {
 		trace_kvm_msr_write(ecx, data);
 		skip_emulated_instruction(&svm->vcpu);
 	}
 	return 1;
 }","[14, 13]","The WRMSR processing functionality in the KVM subsystem in the Linux kernel through 3.17.2 does not properly handle the writing of a non-canonical address to a model-specific register, which allows guest OS users to cause a denial of service (host OS crash) by leveraging guest OS privileges, related to the wrmsr_interception function in arch/x86/kvm/svm.c and the handle_wrmsr function in arch/x86/kvm/vmx.c."
198583," WebContext* WebContext::FromBrowserContext(oxide::BrowserContext* context) {
 WebContext* WebContext::FromBrowserContext(BrowserContext* context) {
    BrowserContextDelegate* delegate =
        static_cast<BrowserContextDelegate*>(context->GetDelegate());
    if (!delegate) {
     return nullptr;
   }
 
    return delegate->context();
  }",[2],A malicious webview could install long-lived unload handlers that re-use an incognito BrowserContext that is queued for destruction in versions of Oxide before 1.18.3.
204393,"    int GetAvailableDraftPageCount() {
      int page_data_map_size = page_data_map_.size();
    if (page_data_map_.find(printing::COMPLETE_PREVIEW_DOCUMENT_INDEX) !=
        page_data_map_.end()) {
     if (ContainsKey(page_data_map_, printing::COMPLETE_PREVIEW_DOCUMENT_INDEX))
        page_data_map_size--;
    }
      return page_data_map_size;
    }","[5, 3, 4, 7]",The IPC implementation in Google Chrome before 22.0.1229.79 allows attackers to obtain potentially sensitive information about memory addresses via unspecified vectors.
199727," static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                      uint32_t lun, void *hba_private)
  {
      SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
      SCSIRequest *req;
    SCSIDiskReq *r;
  
      req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
      return req;
  }","[6, 9, 10]","Buffer overflow in hw/scsi-disk.c in the SCSI subsystem in QEMU before 0.15.2, as used by Xen, might allow local guest users with permission to access the CD-ROM to cause a denial of service (guest crash) via a crafted SAI READ CAPACITY SCSI command.  NOTE: this is only a vulnerability when root has manually modified certain permissions or ACLs."
199579," makepol(QPRS_STATE *state)
 {
 	int32		val = 0,
 				type;
 	int32		lenval = 0;
 	char	   *strval = NULL;
 	int32		stack[STACKDEPTH];
  	int32		lenstack = 0;
  	uint16		flag = 0;
  
 	 
 	check_stack_depth();
 
  	while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)
  	{
  		switch (type)
 		{
 			case VAL:
 				pushval_asis(state, VAL, strval, lenval, flag);
 				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
 									stack[lenstack - 1] == (int32) '!'))
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				}
 				break;
 			case OPR:
 				if (lenstack && val == (int32) '|')
 					pushquery(state, OPR, val, 0, 0, 0);
 				else
 				{
 					if (lenstack == STACKDEPTH)
 						 
 						elog(ERROR, ""stack too short"");
 					stack[lenstack] = val;
 					lenstack++;
 				}
 				break;
 			case OPEN:
 				if (makepol(state) == ERR)
 					return ERR;
 				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
 									stack[lenstack - 1] == (int32) '!'))
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				}
 				break;
 			case CLOSE:
 				while (lenstack)
 				{
 					lenstack--;
 					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 				};
 				return END;
 				break;
 			case ERR:
 			default:
 				ereport(ERROR,
 						(errcode(ERRCODE_SYNTAX_ERROR),
 						 errmsg(""syntax error"")));
 
 				return ERR;
 
 		}
 	}
 	while (lenstack)
 	{
 		lenstack--;
 		pushquery(state, OPR, stack[lenstack], 0, 0, 0);
 	};
 	return END;
 }","[11, 12, 13]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
201533," ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,
 			struct pipe_inode_info *pipe, size_t len,
 			unsigned int flags)
 {
 	struct sock *sk = sock->sk;
 	struct tcp_splice_state tss = {
 		.pipe = pipe,
 		.len = len,
 		.flags = flags,
 	};
 	long timeo;
 	ssize_t spliced;
 	int ret;
 
 	sock_rps_record_flow(sk);
 	 
 	if (unlikely(*ppos))
 		return -ESPIPE;
 
 	ret = spliced = 0;
 
 	lock_sock(sk);
 
 	timeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);
 	while (tss.len) {
 		ret = __tcp_splice_read(sk, &tss);
 		if (ret < 0)
 			break;
 		else if (!ret) {
 			if (spliced)
 				break;
 			if (sock_flag(sk, SOCK_DONE))
 				break;
 			if (sk->sk_err) {
 				ret = sock_error(sk);
 				break;
 			}
 			if (sk->sk_shutdown & RCV_SHUTDOWN)
 				break;
 			if (sk->sk_state == TCP_CLOSE) {
 				 
 				if (!sock_flag(sk, SOCK_DONE))
 					ret = -ENOTCONN;
 				break;
 			}
 			if (!timeo) {
  				ret = -EAGAIN;
  				break;
  			}
 			 
 			if (!skb_queue_empty(&sk->sk_receive_queue))
 				break;
  			sk_wait_data(sk, &timeo, NULL);
  			if (signal_pending(current)) {
  				ret = sock_intr_errno(timeo);
 				break;
 			}
 			continue;
 		}
 		tss.len -= ret;
 		spliced += ret;
 
 		if (!timeo)
 			break;
 		release_sock(sk);
 		lock_sock(sk);
 
 		if (sk->sk_err || sk->sk_state == TCP_CLOSE ||
 		    (sk->sk_shutdown & RCV_SHUTDOWN) ||
 		    signal_pending(current))
 			break;
 	}
 
 	release_sock(sk);
 
 	if (spliced)
 		return spliced;
 
 	return ret;
 }","[50, 51, 52]",The tcp_splice_read function in net/ipv4/tcp.c in the Linux kernel before 4.9.11 allows remote attackers to cause a denial of service (infinite loop and soft lockup) via vectors involving a TCP packet with the URG flag.
202536," ip6t_do_table(struct sk_buff *skb,
 	      const struct nf_hook_state *state,
 	      struct xt_table *table)
 {
 	unsigned int hook = state->hook;
 	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
 	 
 	unsigned int verdict = NF_DROP;
 	const char *indev, *outdev;
 	const void *table_base;
 	struct ip6t_entry *e, **jumpstack;
 	unsigned int stackidx, cpu;
 	const struct xt_table_info *private;
 	struct xt_action_param acpar;
 	unsigned int addend;
 
 	 
 	stackidx = 0;
 	indev = state->in ? state->in->name : nulldevname;
 	outdev = state->out ? state->out->name : nulldevname;
 	 
 	acpar.hotdrop = false;
 	acpar.state   = state;
 
 	WARN_ON(!(table->valid_hooks & (1 << hook)));
 
 	local_bh_disable();
 	addend = xt_write_recseq_begin();
 	private = READ_ONCE(table->private);  
 	cpu        = smp_processor_id();
 	table_base = private->entries;
 	jumpstack  = (struct ip6t_entry **)private->jumpstack[cpu];
 
 	 
 	if (static_key_false(&xt_tee_enabled))
 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
 
 	e = get_entry(table_base, private->hook_entry[hook]);
 
 	do {
 		const struct xt_entry_target *t;
 		const struct xt_entry_match *ematch;
 		struct xt_counters *counter;
 
 		WARN_ON(!e);
 		acpar.thoff = 0;
 		if (!ip6_packet_match(skb, indev, outdev, &e->ipv6,
 		    &acpar.thoff, &acpar.fragoff, &acpar.hotdrop)) {
  no_match:
 			e = ip6t_next_entry(e);
 			continue;
 		}
 
 		xt_ematch_foreach(ematch, e) {
 			acpar.match     = ematch->u.kernel.match;
 			acpar.matchinfo = ematch->data;
 			if (!acpar.match->match(skb, &acpar))
 				goto no_match;
 		}
 
 		counter = xt_get_this_cpu_counter(&e->counters);
 		ADD_COUNTER(*counter, skb->len, 1);
 
 		t = ip6t_get_target_c(e);
 		WARN_ON(!t->u.kernel.target);
 
 #if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
 		 
 		if (unlikely(skb->nf_trace))
 			trace_packet(state->net, skb, hook, state->in,
 				     state->out, table->name, private, e);
 #endif
 		 
 		if (!t->u.kernel.target->target) {
 			int v;
 
 			v = ((struct xt_standard_target *)t)->verdict;
 			if (v < 0) {
 				 
 				if (v != XT_RETURN) {
 					verdict = (unsigned int)(-v) - 1;
 					break;
 				}
 				if (stackidx == 0)
 					e = get_entry(table_base,
 					    private->underflow[hook]);
 				else
 					e = ip6t_next_entry(jumpstack[--stackidx]);
 				continue;
  			}
  			if (table_base + v != ip6t_next_entry(e) &&
  			    !(e->ipv6.flags & IP6T_F_GOTO)) {
 				if (unlikely(stackidx >= private->stacksize)) {
 					verdict = NF_DROP;
 					break;
 				}
  				jumpstack[stackidx++] = e;
  			}
  
 			e = get_entry(table_base, v);
 			continue;
 		}
 
 		acpar.target   = t->u.kernel.target;
 		acpar.targinfo = t->data;
 
 		verdict = t->u.kernel.target->target(skb, &acpar);
 		if (verdict == XT_CONTINUE)
 			e = ip6t_next_entry(e);
 		else
 			 
 			break;
 	} while (!acpar.hotdrop);
 
 	xt_write_recseq_end(addend);
 	local_bh_enable();
 
 	if (acpar.hotdrop)
 		return NF_DROP;
 	else return verdict;
 }","[93, 94, 95, 96]","The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c."
201031," print_bacp_config_options(netdissect_options *ndo,
                           const u_char *p, int length)
 {
 	int len, opt;
 
 	if (length < 2)
 		return 0;
 	ND_TCHECK2(*p, 2);
 	len = p[1];
 	opt = p[0];
 	if (length < len)
 		return 0;
 	if (len < 2) {
 		ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)"",
 		          tok2str(bacconfopts_values, ""Unknown"", opt),
 		          opt,
 		          len));
 		return 0;
 	}
 
 	ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"",
 	          tok2str(bacconfopts_values, ""Unknown"", opt),
 	          opt,
 	          len));
 
 	switch (opt) {
 	case BACPOPT_FPEER:
 		if (len != 6) {
  			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
  			return len;
  		}
		ND_TCHECK2(*(p + 2), 4);
 		ND_TCHECK_32BITS(p + 2);
  		ND_PRINT((ndo, "": Magic-Num 0x%08x"", EXTRACT_32BITS(p + 2)));
  		break;
  	default:
 		 
 		if (ndo->ndo_vflag < 2)
 			print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);
 		break;
 	}
 	if (ndo->ndo_vflag > 1)
 		print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);  
 
 	return len;
 
 trunc:
 	ND_PRINT((ndo, ""[|bacp]""));
 	return 0;
 }","[33, 32]",The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:print_ccp_config_options().
197999,"  ActionReply Smb4KMountHelper::mount(const QVariantMap &args)
  {
    
    
    
    ActionReply reply;
    
    
    
   const QString mount = findMountExecutable();
   
    
    QMapIterator<QString, QVariant> it(args);
     proc.setOutputChannelMode(KProcess::SeparateChannels);
     proc.setProcessEnvironment(QProcessEnvironment::systemEnvironment());
 #if defined(Q_OS_LINUX)
     proc.setEnv(""PASSWD"", entry[""mh_url""].toUrl().password(), true);
 #endif
      QVariantMap entry = it.value().toMap();
      
      
      
     if (mount != entry[""mh_command""].toString())
     {
        
       reply.setType(ActionReply::HelperErrorType);
       return reply;
     }
     else
     {
        
     }
     
      
      KProcess proc(this);
     command << entry[""mh_mountpoint""].toString();
     command << entry[""mh_options""].toStringList();
 #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)
     command << entry[""mh_command""].toString();
     command << entry[""mh_options""].toStringList();
     command << entry[""mh_unc""].toString();
     command << entry[""mh_mountpoint""].toString();
 #else
 #endif
     proc.setProgram(command);
 
     proc.start();
     
     if (proc.waitForStarted(-1))
     {
       bool userKill = false;
      QStringList command;
  #if defined(Q_OS_LINUX)
    command << entry[""mh_command""].toString();
     command << mount;
      command << entry[""mh_unc""].toString();
      command << entry[""mh_mountpoint""].toString();
      command << entry[""mh_options""].toStringList();
  #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)
    command << entry[""mh_command""].toString();
     command << mount;
      command << entry[""mh_options""].toStringList();
      command << entry[""mh_unc""].toString();
      command << entry[""mh_mountpoint""].toString();
         else
         {
         }
 
         if (HelperSupport::isStopped())
         {
           proc.kill();
           userKill = true;
           break;
         }
         else
         {
         }
       }
 
       if (proc.exitStatus() == KProcess::CrashExit)
       {
         if (!userKill)
         {
           reply.setType(ActionReply::HelperErrorType);
           reply.setErrorDescription(i18n(""The mount process crashed.""));
           break;
         }
         else
         {
         }
       }
       else
       {
         QString stdErr = QString::fromUtf8(proc.readAllStandardError());
         reply.addData(QString(""mh_error_message_%1"").arg(index), stdErr.trimmed());
       }
     }","[3, 4, 5, 8, 9, 10, 11, 12, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 55, 61, 54, 60]",smb4k before 2.0.1 allows local users to gain root privileges by leveraging failure to verify arguments to the mount helper DBUS service.
199841," spnego_gss_verify_mic(
 		OM_uint32 *minor_status,
 		const gss_ctx_id_t context_handle,
 		const gss_buffer_t msg_buffer,
 		const gss_buffer_t token_buffer,
  		gss_qop_t *qop_state)
  {
  	OM_uint32 ret;
 	spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
 
 	if (sc->ctx_handle == GSS_C_NO_CONTEXT)
 		return (GSS_S_NO_CONTEXT);
 
  	ret = gss_verify_mic(minor_status,
			    context_handle,
 			    sc->ctx_handle,
  			    msg_buffer,
  			    token_buffer,
  			    qop_state);
 	return (ret);
 }","[9, 10, 11, 12, 13, 16, 15]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
206821,"  void PlatformSensorProviderLinux::CreateSensorInternal(
      mojom::SensorType type,
    mojo::ScopedSharedBufferMapping mapping,
     SensorReadingSharedBuffer* reading_buffer,
      const CreateSensorCallback& callback) {
    if (!sensor_device_manager_)
      sensor_device_manager_.reset(new SensorDeviceManager());
  
    if (IsFusionSensorType(type)) {
    CreateFusionSensor(type, std::move(mapping), callback);
     CreateFusionSensor(type, reading_buffer, callback);
      return;
    }
  
   if (!sensor_nodes_enumerated_) {
     if (!sensor_nodes_enumeration_started_) {
       sensor_nodes_enumeration_started_ = file_task_runner_->PostTask(
           FROM_HERE,
           base::Bind(&SensorDeviceManager::Start,
                      base::Unretained(sensor_device_manager_.get()), this));
     }
     return;
   }
 
   SensorInfoLinux* sensor_device = GetSensorDevice(type);
   if (!sensor_device) {
     callback.Run(nullptr);
      return;
    }
  
  SensorDeviceFound(type, std::move(mapping), callback, sensor_device);
   SensorDeviceFound(type, reading_buffer, callback, sensor_device);
  }","[4, 11, 32, 3, 10, 31]",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
206629," void InstallablePaymentAppCrawler::OnPaymentMethodManifestParsed(
     const GURL& method_manifest_url,
     const std::vector<GURL>& default_applications,
     const std::vector<url::Origin>& supported_origins,
     bool all_origins_supported) {
   number_of_payment_method_manifest_to_parse_--;
 
   if (web_contents() == nullptr)
     return;
   content::PermissionManager* permission_manager =
       web_contents()->GetBrowserContext()->GetPermissionManager();
   if (permission_manager == nullptr)
     return;
 
   for (const auto& url : default_applications) {
     if (downloaded_web_app_manifests_.find(url) !=
         downloaded_web_app_manifests_.end()) {
        continue;
      }
  
     if (!net::registry_controlled_domains::SameDomainOrHost(
             method_manifest_url, url,
             net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES)) {
       WarnIfPossible(""Installable payment app from "" + url.spec() +
                      "" is not allowed for the method "" +
                      method_manifest_url.spec());
       continue;
     }
 
      if (permission_manager->GetPermissionStatus(
              content::PermissionType::PAYMENT_HANDLER, url.GetOrigin(),
              url.GetOrigin()) != blink::mojom::PermissionStatus::GRANTED) {
       continue;
     }
 
     number_of_web_app_manifest_to_download_++;
     downloaded_web_app_manifests_.insert(url);
     downloader_->DownloadWebAppManifest(
         url,
         base::BindOnce(
             &InstallablePaymentAppCrawler::OnPaymentWebAppManifestDownloaded,
             weak_ptr_factory_.GetWeakPtr(), method_manifest_url, url));
   }
 
   FinishCrawlingPaymentAppsIfReady();
 }","[21, 22, 23, 24, 25, 26, 27, 28, 29]",Insufficiently strict origin checks during JIT payment app installation in Payments in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to install a service worker for a domain that can host attacker controled files via a crafted HTML page.
110,"SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,
unsigned long, nbytes, int __user *, start, void __user *, arg)
{
unsigned long w;
struct percpu_struct *cpu;

switch (op) {
case GSI_IEEE_FP_CONTROL:



w = current_thread_info()->ieee_state & IEEE_SW_MASK;
w = swcr_update_status(w, rdfpcr());
if (put_user(w, (unsigned long __user *) buffer))
return -EFAULT;
return 0;

case GSI_IEEE_STATE_AT_SIGNAL:





break;

case GSI_UACPROC:
if (nbytes < sizeof(unsigned int))
return -EINVAL;
w = (current_thread_info()->flags >> UAC_SHIFT) & UAC_BITMASK;
if (put_user(w, (unsigned int __user *)buffer))
return -EFAULT;
return 1;

case GSI_PROC_TYPE:
if (nbytes < sizeof(unsigned long))
return -EINVAL;
cpu = (struct percpu_struct*)
((char*)hwrpb + hwrpb->processor_offset);
w = cpu->type;
if (put_user(w, (unsigned long  __user*)buffer))
return -EFAULT;
return 1;

case GSI_GET_HWRPB:
if (nbytes < sizeof(*hwrpb))
return -EINVAL;
if (copy_to_user(buffer, hwrpb, nbytes) != 0)
return -EFAULT;
return 1;

default:
break;
}

return -EOPNOTSUPP;
}",[45],Integer signedness error in the osf_getdomainname function in arch/alpha/kernel/osf_sys.c in the Linux kernel before 2.6.39.4 on the Alpha platform allows local users to obtain sensitive information from kernel memory via a crafted call.
201633," static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
         uint8* bufp = buf;
         int32  bytes_read = 0;
         uint32 strip, nstrips   = TIFFNumberOfStrips(in);
         uint32 stripsize = TIFFStripSize(in);
         uint32 rows = 0;
         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
         tsize_t scanline_size = TIFFScanlineSize(in);
 
         if (scanline_size == 0) {
                 TIFFError("""", ""TIFF scanline size is zero!"");    
                 return 0;
         }
 
         for (strip = 0; strip < nstrips; strip++) {
                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                 rows = bytes_read / scanline_size;
                 if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
                         TIFFError("""", ""Strip %d: read %lu bytes, strip size %lu"",
                                   (int)strip + 1, (unsigned long) bytes_read,
                                   (unsigned long)stripsize);
 
                 if (bytes_read < 0 && !ignore) {
                         TIFFError("""", ""Error reading strip %lu after %lu rows"",
                                    (unsigned long) strip, (unsigned long)rows);
                          return 0;
                  }
                bufp += bytes_read;
                 bufp += stripsize;
          }
  
          return 1;
 }  ","[30, 29]","LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via a crafted TIFF image, related to *WRITE of size 2048* and libtiff/tif_next.c:64:9."
202702," externalParEntProcessor(XML_Parser parser, const char *s, const char *end,
                         const char **nextPtr) {
   const char *next = s;
   int tok;
 
   tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   if (tok <= 0) {
     if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {
       *nextPtr = s;
       return XML_ERROR_NONE;
     }
     switch (tok) {
     case XML_TOK_INVALID:
       return XML_ERROR_INVALID_TOKEN;
     case XML_TOK_PARTIAL:
       return XML_ERROR_UNCLOSED_TOKEN;
     case XML_TOK_PARTIAL_CHAR:
       return XML_ERROR_PARTIAL_CHAR;
     case XML_TOK_NONE:  
     default:
       break;
     }
   }
    
   else if (tok == XML_TOK_BOM) {
     s = next;
     tok = XmlPrologTok(parser->m_encoding, s, end, &next);
   }
  
    parser->m_processor = prologProcessor;
    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);
                   (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
  }","[33, 32]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read."
7823,"void Compute(OpKernelContext* context) override {

OpInputList ragged_nested_splits_in;
OP_REQUIRES_OK(context, context->input_list(""rt_nested_splits"",
&ragged_nested_splits_in));
const int ragged_nested_splits_len = ragged_nested_splits_in.size();
RaggedTensorVariant batched_ragged_input;

batched_ragged_input.set_values(context->input(ragged_nested_splits_len));
batched_ragged_input.mutable_nested_splits()->reserve(
ragged_nested_splits_len);
for (int i = 0; i < ragged_nested_splits_len; i++) {
batched_ragged_input.append_splits(ragged_nested_splits_in[i]);
}

if (!batched_input_) {

Tensor* encoded_scalar;
OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),
&encoded_scalar));
encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);
return;
}


std::vector<RaggedTensorVariant> unbatched_ragged_input;
OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(
batched_ragged_input, &unbatched_ragged_input));


Tensor* encoded_vector;
int output_size = unbatched_ragged_input.size();
OP_REQUIRES_OK(context,
context->allocate_output(0, TensorShape({output_size}),
&encoded_vector));
auto encoded_vector_t = encoded_vector->vec<Variant>();
for (int i = 0; i < output_size; i++) {
encoded_vector_t(i) = unbatched_ragged_input[i];
}
}",[27],"TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.RaggedTensorToVariant` with arguments specifying an invalid ragged tensor results in a null pointer dereference. The implementation of `RaggedTensorToVariant` operations(https://github.com/tensorflow/tensorflow/blob/904b3926ed1c6c70380d5313d282d248a776baa1/tensorflow/core/kernels/ragged_tensor_to_variant_op.cc#L39-L40) does not validate that the ragged tensor argument is non-empty. Since `batched_ragged` contains no elements, `batched_ragged.splits` is a null vector, thus `batched_ragged.splits(0)` will result in dereferencing `nullptr`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
6076,"static int cac_read_binary(sc_card_t *card, unsigned int idx,
unsigned char *buf, size_t count, unsigned long flags)
{
cac_private_data_t * priv = CAC_DATA(card);
int r = 0;
u8 *val = NULL;
u8 *cert_ptr;
size_t val_len;
size_t len, cert_len;
u8 cert_type;

SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);


if (priv->cached) {
sc_log(card->ctx,
""returning cached value idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
idx, count);
if (idx > priv->cache_buf_len) {
LOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);
}
len = MIN(count, priv->cache_buf_len-idx);
memcpy(buf, &priv->cache_buf[idx], len);
LOG_FUNC_RETURN(card->ctx, len);
}

sc_log(card->ctx,
""clearing cache idx=%d count=%""SC_FORMAT_LEN_SIZE_T""u"",
idx, count);
free(priv->cache_buf);
priv->cache_buf = NULL;
priv->cache_buf_len = 0;

r = cac_cac1_get_certificate(card, &val, &val_len);
if (r < 0)
goto done;
if (val_len < 1) {
r = SC_ERROR_INVALID_DATA;
goto done;
}

cert_type = val[0];
cert_ptr = val + 1;
cert_len = val_len - 1;


if ((cert_type & 0x3) == 1) {
#ifdef ENABLE_ZLIB
r = sc_decompress_alloc(&priv->cache_buf, &priv->cache_buf_len,
cert_ptr, cert_len, COMPRESSION_AUTO);
#else
sc_log(card->ctx, ""CAC compression not supported, no zlib"");
r = SC_ERROR_NOT_SUPPORTED;
#endif
if (r)
goto done;
} else if (cert_len > 0) {
priv->cache_buf = malloc(cert_len);
if (priv->cache_buf == NULL) {
r = SC_ERROR_OUT_OF_MEMORY;
goto done;
}
priv->cache_buf_len = cert_len;
memcpy(priv->cache_buf, cert_ptr, cert_len);
}


priv->cached = 1;
len = MIN(count, priv->cache_buf_len-idx);
if (len && priv->cache_buf)
memcpy(buf, &priv->cache_buf[idx], len);
r = len;
done:
if (val)
free(val);
LOG_FUNC_RETURN(card->ctx, r);
}",[8],An issue was discovered in OpenSC through 0.19.0 and 0.20.x through 0.20.0-rc3. libopensc/card-cac1.c mishandles buffer limits for CAC certificates.
202457," static void nsc_rle_decompress_data(NSC_CONTEXT* context)
 static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)
  {
  	UINT16 i;
  	BYTE* rle;
  	UINT32 planeSize;
  	UINT32 originalSize;
 
 	if (!context)
 		return FALSE;
 
  	rle = context->Planes;
  
  	for (i = 0; i < 4; i++)
 	{
 		originalSize = context->OrgByteCount[i];
  		planeSize = context->PlaneByteCount[i];
  
  		if (planeSize == 0)
 		{
 			if (context->priv->PlaneBuffersLength < originalSize)
 				return FALSE;
 
  			FillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);
 		}
  		else if (planeSize < originalSize)
			nsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);
 		{
 			if (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,
 			                    originalSize))
 				return FALSE;
 		}
  		else
 		{
 			if (context->priv->PlaneBuffersLength < originalSize)
 				return FALSE;
 
  			CopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);
 		}
  
  		rle += planeSize;
  	}
 
 	return TRUE;
  }","[2, 8, 9, 10, 11, 20, 21, 22, 23, 25, 28, 29, 30, 31, 32, 34, 35, 36, 37, 39, 43, 44, 27]",FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.
207714,"  sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,
    png_uint_32 x, unsigned int sample_index)
     png_uint_32 x, unsigned int sample_index, int swap16, int littleendian)
  {
     png_uint_32 bit_index, result;
  
   
    x *= bit_depth;
    bit_index = x;
 
  if ((colour_type & 1) == 0)  
  {
  if (colour_type & 2)
          bit_index *= 3;
 
  if (colour_type & 4)
          bit_index += x;  
 
   
  if (colour_type & (2+4))
          bit_index += sample_index * bit_depth;
  }
 
   
    row += bit_index >> 3;
    result = *row;
 
  if (bit_depth == 8)
 
        return result;
  
     else if (bit_depth > 8)
      return (result << 8) + *++row;
    {
       if (swap16)
          return (*++row << 8) + result;
       else
          return (result << 8) + *++row;
    }
  
     
     bit_index &= 7;
   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
 
    if (!littleendian)
       bit_index = 8-bit_index-bit_depth;
 
    return (result >> bit_index) & ((1U<<bit_depth)-1);
  }","[3, 34, 35, 36, 37, 38, 39, 44, 45, 46, 47, 48, 2, 33, 43]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
208632," void impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)
 WORD32 impeg2d_dec_pnb_mb_params(dec_state_t *ps_dec)
  {
      stream_t *ps_stream = &ps_dec->s_bit_stream;
      UWORD16 u2_mb_addr_incr;
     UWORD16 u2_total_len;
     UWORD16 u2_len;
     UWORD16 u2_mb_type;
     UWORD32 u4_next_word;
  const dec_mb_params_t *ps_dec_mb_params;
  if(impeg2d_bit_stream_nxt(ps_stream,1) == 1)
  {
         impeg2d_bit_stream_flush(ps_stream,1);
 
  }
  else
  {
         u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream);
 
  if(ps_dec->u2_first_mb)
  {
   
   
   
   
   
   
   
   
   
             ps_dec->u2_mb_x = u2_mb_addr_incr - 1;
   
             ps_dec->u2_mb_x = MIN(ps_dec->u2_mb_x, (ps_dec->u2_num_horiz_mb - 1));
 
   
   
   
   
   
             u2_mb_addr_incr = 1;
             ps_dec->u2_first_mb = 0;
  }
  else
  {
   
   
   
   
   
   
   
   
  if(ps_dec->u2_is_mpeg2 &&
  ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb))
  {
                 u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x;
  }
 
 
             impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1));
  }
 
  }
     u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16);
   
   
   
  {
         u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)];
         u2_len      = BITS(u2_mb_type,15,8);
         u2_total_len = u2_len;
         u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len);
  }
   
   
   
  {
         WORD32 i4_motion_type = ps_dec->u2_motion_type;
 
  if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type)
  {
             ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14);
             u2_total_len += MB_MOTION_TYPE_LEN;
             u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN);
             i4_motion_type     = ps_dec->u2_motion_type;
 
  }
 
 
  if ((u2_mb_type & MB_FORW_OR_BACK) &&
  ((i4_motion_type == 0) ||
  (i4_motion_type == 3) ||
  (i4_motion_type == 4) ||
  (i4_motion_type >= 7)))
  {
             i4_motion_type = 1;
  }
 
  }
   
   
   
  {
  if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type)
  {
             ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15);
             u2_total_len += MB_DCT_TYPE_LEN;
             u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN);
  }
  }
   
   
   
  if(u2_mb_type & MB_QUANT)
  {
         UWORD16 u2_quant_scale_code;
         u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11);
 
         ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?
             gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);
         u2_total_len += MB_QUANT_SCALE_CODE_LEN;
  }
     impeg2d_bit_stream_flush(ps_stream,u2_total_len);
   
   
   
     ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED);
 
  if(u2_mb_type & MB_BIDRECT)
  {
         UWORD16 u2_index       = (ps_dec->u2_motion_type);
 
         ps_dec->u2_prev_intra_mb    = 0;
 
          ps_dec->e_mb_pred         = BIDIRECT;
          ps_dec_mb_params = &ps_dec->ps_func_bi_direct[u2_index];
          ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
         if(NULL == ps_dec_mb_params->pf_func_mb_params)
             return -1;
          ps_dec_mb_params->pf_func_mb_params(ps_dec);
      }
      else if(u2_mb_type & MB_FORW_OR_BACK)
  {
 
         UWORD16 u2_refPic      = !(u2_mb_type & MB_MV_FORW);
         UWORD16 u2_index       = (ps_dec->u2_motion_type);
         ps_dec->u2_prev_intra_mb    = 0;
 
          ps_dec->e_mb_pred         = (e_pred_direction_t)u2_refPic;
          ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[u2_index];
          ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type;
         if(NULL == ps_dec_mb_params->pf_func_mb_params)
             return -1;
          ps_dec_mb_params->pf_func_mb_params(ps_dec);
  
      }
  else if(u2_mb_type & MB_TYPE_INTRA)
  {
         ps_dec->u2_prev_intra_mb    = 1;
         impeg2d_dec_intra_mb(ps_dec);
 
  }
  else
  {
         ps_dec->u2_prev_intra_mb =0;
         ps_dec->e_mb_pred = FORW;
         ps_dec->u2_motion_type = 0;
         impeg2d_dec_0mv_coded_mb(ps_dec);
  }
 
   
   
   
  if((u2_mb_type & MB_TYPE_INTRA))
  {
         ps_dec->u2_cbp  = 0x3f;
         ps_dec->u2_prev_intra_mb    = 1;
  }
  else
  {
         ps_dec->u2_prev_intra_mb  = 0;
         ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision;
         ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
         ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision;
  if((ps_dec->u2_coded_mb))
  {
             UWORD16 cbpValue;
             cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)];
             ps_dec->u2_cbp  = cbpValue & 0xFF;
             impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF);
  }
  else
  {
 
              ps_dec->u2_cbp  = 0;
          }
      }
     return 0;
  }","[2, 138, 139, 152, 153, 198]","decoder/impeg2d_dec_hdr.c in mediaserver in Android 6.x before 2016-04-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a certain negative value, aka internal bug 26070014."
7864,"Status SparseTensorToCSRSparseMatrixCPUFunctor::operator()(
const int64 batch_size, const int num_rows,
TTypes<int64>::ConstMatrix indices, TTypes<int32>::Vec batch_ptr,
TTypes<int32>::Vec csr_row_ptr, TTypes<int32>::Vec csr_col_ind) {

if (batch_ptr.size() != batch_size + 1) {
return errors::InvalidArgument(
""Expected batch_ptr.size() == batch_size + 1. Got: "", batch_ptr.size(),
"" vs. "", batch_size + 1);
}
if (csr_row_ptr.size() != batch_size * (num_rows + 1)) {
return errors::InvalidArgument(
""Expected csr_row_ptr.size() == batch_size * (num_rows + 1). Got: "",
csr_row_ptr.size(), "" vs. "", batch_size * (num_rows + 1));
}

const int64 total_nnz = indices.dimension(0);
const int rank = indices.dimension(1);
if (rank == 2 && batch_size != 1) {
return errors::InvalidArgument(
""Expected batch_size == 1 when rank is 2. Got batch_size: "",
batch_size);
}
if (csr_col_ind.size() != total_nnz) {
return errors::InvalidArgument(
""Expected csr_col_ind.size() == total_nnz. Got: "", csr_col_ind.size(),
"" vs. "", total_nnz);
}

int prev_batch = -1;
if (rank == 2) {

batch_ptr(0) = 0;
++prev_batch;

for (int64 i = 0; i < total_nnz; ++i) {

csr_row_ptr(indices(i, 0) + 1) += 1;
csr_col_ind(i) = indices(i, 1);
}
} else {
for (int64 i = 0; i < total_nnz; ++i) {
const int cur_batch = indices(i, 0);

csr_row_ptr(cur_batch * (num_rows + 1) + indices(i, 1) + 1) += 1;
csr_col_ind(i) = indices(i, 2);


while (prev_batch < cur_batch) {

batch_ptr(prev_batch + 1) = i;
++prev_batch;
}
}
}

while (prev_batch < batch_size) {
batch_ptr(prev_batch + 1) = total_nnz;
++prev_batch;
}


for (int batch_idx = 0; batch_idx < batch_size; ++batch_idx) {
auto* row_ptr_batch = csr_row_ptr.data() + batch_idx * (num_rows + 1);
std::partial_sum(row_ptr_batch, row_ptr_batch + num_rows + 1,
row_ptr_batch);
}
return Status::OK();
}",[38],"TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a denial of service via a `CHECK`-fail in converting sparse tensors to CSR Sparse matrices. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/800346f2c03a27e182dd4fba48295f65e7790739/tensorflow/core/kernels/sparse/kernels.cc#L66) does a double redirection to access an element of an array allocated on the heap. If the value at `indices(i, 0)` is such that `indices(i, 0) + 1` is outside the bounds of `csr_row_ptr`, this results in writing outside of bounds of heap allocated data. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
205551," void AppListControllerDelegateImpl::DoCreateShortcutsFlow(
      Profile* profile,
      const std::string& extension_id) {
    DCHECK(CanDoCreateShortcutsFlow());
  ExtensionService* service =
      extensions::ExtensionSystem::Get(profile)->extension_service();
  DCHECK(service);
  const extensions::Extension* extension = service->GetInstalledExtension(
   extensions::ExtensionRegistry* registry =
       extensions::ExtensionRegistry::Get(profile);
   const extensions::Extension* extension = registry->GetInstalledExtension(
        extension_id);
    DCHECK(extension);
  
   gfx::NativeWindow parent_window = GetAppListWindow();
   if (!parent_window)
     return;
   OnShowChildDialog();
   chrome::ShowCreateChromeAppShortcutsDialog(
       parent_window, profile, extension,
       base::Bind(&AppListControllerDelegateImpl::OnCloseCreateShortcutsPrompt,
                  base::Unretained(this)));
 }","[9, 10, 11, 5, 6, 7, 8]",Multiple unspecified vulnerabilities in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
205675," void FragmentPaintPropertyTreeBuilder::UpdateInnerBorderRadiusClip() {
   DCHECK(properties_);
 
   if (NeedsPaintPropertyUpdate()) {
     if (NeedsInnerBorderRadiusClip(object_)) {
       const LayoutBox& box = ToLayoutBox(object_);
       ClipPaintPropertyNode::State state;
       state.local_transform_space = context_.current.transform;
       if (box.IsLayoutReplaced()) {
         state.clip_rect = box.StyleRef().GetRoundedInnerBorderFor(
             LayoutRect(context_.current.paint_offset, box.Size()),
             LayoutRectOutsets(-(box.PaddingTop() + box.BorderTop()),
                               -(box.PaddingRight() + box.BorderRight()),
                               -(box.PaddingBottom() + box.BorderBottom()),
                               -(box.PaddingLeft() + box.BorderLeft())));
       } else {
         state.clip_rect = box.StyleRef().GetRoundedInnerBorderFor(
              LayoutRect(context_.current.paint_offset, box.Size()));
        }
        OnUpdateClip(properties_->UpdateInnerBorderRadiusClip(
          context_.current.clip, std::move(state)));
           *context_.current.clip, std::move(state)));
      } else {
        OnClearClip(properties_->ClearInnerBorderRadiusClip());
      }
   }
 
   if (auto* border_radius_clip = properties_->InnerBorderRadiusClip())
     context_.current.clip = border_radius_clip;
 }","[22, 21]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
200147," static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,
 		       struct posix_acl *acl)
 {
 	char *ea_name;
 	int rc;
 	int size = 0;
 	char *value = NULL;
 
 	switch (type) {
  	case ACL_TYPE_ACCESS:
  		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
  		if (acl) {
			rc = posix_acl_equiv_mode(acl, &inode->i_mode);
			if (rc < 0)
 			rc = posix_acl_update_mode(inode, &inode->i_mode, &acl);
 			if (rc)
  				return rc;
  			inode->i_ctime = CURRENT_TIME;
  			mark_inode_dirty(inode);
			if (rc == 0)
				acl = NULL;
  		}
  		break;
  	case ACL_TYPE_DEFAULT:
 		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
 		break;
 	default:
 		return -EINVAL;
 	}
 
 	if (acl) {
 		size = posix_acl_xattr_size(acl->a_count);
 		value = kmalloc(size, GFP_KERNEL);
 		if (!value)
 			return -ENOMEM;
 		rc = posix_acl_to_xattr(&init_user_ns, acl, value, size);
 		if (rc < 0)
 			goto out;
 	}
 	rc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);
 out:
 	kfree(value);
 
 	if (!rc)
 		set_cached_acl(inode, type, acl);
 
 	return rc;
 }","[15, 16, 13, 14, 20, 21]","The filesystem implementation in the Linux kernel through 4.8.2 preserves the setgid bit during a setxattr call, which allows local users to gain group privileges by leveraging the existence of a setgid program with restrictions on execute permissions."
203879," void GraphicsContext::clipConvexPolygon(size_t numPoints, const FloatPoint* points, bool antialiased)
 {
     if (paintingDisabled())
         return;
 
      if (numPoints <= 1)
          return;
  
     notImplemented();
  }",[9],Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving floating styles.
207603," image_size_of_type(int color_type, int bit_depth, unsigned int *colors)
 image_size_of_type(int color_type, int bit_depth, unsigned int *colors,
    int small)
  {
     if (*colors)
        return 16;
 
  else
 
     {
        int pixel_depth = pixel_depth_of_type(color_type, bit_depth);
  
      if (pixel_depth < 8)
       if (small)
       {
          if (pixel_depth <= 8)  
             return 1 << pixel_depth;
 
          else
             return 256;
       }
 
       else if (pixel_depth < 8)
           return 64;
  
        else if (pixel_depth > 16)
  return 1024;
 
  else
  return 256;
  }
 }","[2, 3, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 13]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
199130," do_ip_vs_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)
 {
 	int ret;
 	unsigned char arg[MAX_ARG_LEN];
 	struct ip_vs_service_user *usvc_compat;
 	struct ip_vs_service_user_kern usvc;
 	struct ip_vs_service *svc;
 	struct ip_vs_dest_user *udest_compat;
 	struct ip_vs_dest_user_kern udest;
 
  	if (!capable(CAP_NET_ADMIN))
  		return -EPERM;
  
 	if (cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_SET_MAX)
 		return -EINVAL;
 	if (len < 0 || len >  MAX_ARG_LEN)
 		return -EINVAL;
  	if (len != set_arglen[SET_CMDID(cmd)]) {
  		pr_err(""set_ctl: len %u != %u\n"",
  		       len, set_arglen[SET_CMDID(cmd)]);
 		return -EINVAL;
 	}
 
 	if (copy_from_user(arg, user, len) != 0)
 		return -EFAULT;
 
 	 
 	ip_vs_use_count_inc();
 
 	if (mutex_lock_interruptible(&__ip_vs_mutex)) {
 		ret = -ERESTARTSYS;
 		goto out_dec;
 	}
 
 	if (cmd == IP_VS_SO_SET_FLUSH) {
 		 
 		ret = ip_vs_flush();
 		goto out_unlock;
 	} else if (cmd == IP_VS_SO_SET_TIMEOUT) {
 		 
 		ret = ip_vs_set_timeout((struct ip_vs_timeout_user *)arg);
 		goto out_unlock;
 	} else if (cmd == IP_VS_SO_SET_STARTDAEMON) {
 		struct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;
 		ret = start_sync_thread(dm->state, dm->mcast_ifn, dm->syncid);
 		goto out_unlock;
 	} else if (cmd == IP_VS_SO_SET_STOPDAEMON) {
 		struct ip_vs_daemon_user *dm = (struct ip_vs_daemon_user *)arg;
 		ret = stop_sync_thread(dm->state);
 		goto out_unlock;
 	}
 
 	usvc_compat = (struct ip_vs_service_user *)arg;
 	udest_compat = (struct ip_vs_dest_user *)(usvc_compat + 1);
 
 	 
 	ip_vs_copy_usvc_compat(&usvc, usvc_compat);
 	ip_vs_copy_udest_compat(&udest, udest_compat);
 
 	if (cmd == IP_VS_SO_SET_ZERO) {
 		 
 		if (!usvc.fwmark && !usvc.addr.ip && !usvc.port) {
 			ret = ip_vs_zero_all();
 			goto out_unlock;
 		}
 	}
 
 	 
 	if (usvc.protocol != IPPROTO_TCP && usvc.protocol != IPPROTO_UDP) {
 		pr_err(""set_ctl: invalid protocol: %d %pI4:%d %s\n"",
 		       usvc.protocol, &usvc.addr.ip,
 		       ntohs(usvc.port), usvc.sched_name);
 		ret = -EFAULT;
 		goto out_unlock;
 	}
 
 	 
 	if (usvc.fwmark == 0)
 		svc = __ip_vs_service_get(usvc.af, usvc.protocol,
 					  &usvc.addr, usvc.port);
 	else
 		svc = __ip_vs_svc_fwm_get(usvc.af, usvc.fwmark);
 
 	if (cmd != IP_VS_SO_SET_ADD
 	    && (svc == NULL || svc->protocol != usvc.protocol)) {
 		ret = -ESRCH;
 		goto out_unlock;
 	}
 
 	switch (cmd) {
 	case IP_VS_SO_SET_ADD:
 		if (svc != NULL)
 			ret = -EEXIST;
 		else
 			ret = ip_vs_add_service(&usvc, &svc);
 		break;
 	case IP_VS_SO_SET_EDIT:
 		ret = ip_vs_edit_service(svc, &usvc);
 		break;
 	case IP_VS_SO_SET_DEL:
 		ret = ip_vs_del_service(svc);
 		if (!ret)
 			goto out_unlock;
 		break;
 	case IP_VS_SO_SET_ZERO:
 		ret = ip_vs_zero_service(svc);
 		break;
 	case IP_VS_SO_SET_ADDDEST:
 		ret = ip_vs_add_dest(svc, &udest);
 		break;
 	case IP_VS_SO_SET_EDITDEST:
 		ret = ip_vs_edit_dest(svc, &udest);
 		break;
 	case IP_VS_SO_SET_DELDEST:
 		ret = ip_vs_del_dest(svc, &udest);
 		break;
 	default:
 		ret = -EINVAL;
 	}
 
 	if (svc)
 		ip_vs_service_put(svc);
 
   out_unlock:
 	mutex_unlock(&__ip_vs_mutex);
   out_dec:
 	 
 	ip_vs_use_count_dec();
 
 	return ret;
 }","[14, 15, 16, 17]","Multiple stack-based buffer overflows in net/netfilter/ipvs/ip_vs_ctl.c in the Linux kernel before 2.6.33, when CONFIG_IP_VS is used, allow local users to gain privileges by leveraging the CAP_NET_ADMIN capability for (1) a getsockopt system call, related to the do_ip_vs_get_ctl function, or (2) a setsockopt system call, related to the do_ip_vs_set_ctl function."
198970," static int misaligned_fpu_store(struct pt_regs *regs,
 			   __u32 opcode,
 			   int displacement_not_indexed,
 			   int width_shift,
 			   int do_paired_load)
 {
 	 
 	int error;
 	int srcreg;
 	__u64 address;
 
 	error = generate_and_check_address(regs, opcode,
 			displacement_not_indexed, width_shift, &address);
 	if (error < 0) {
  		return error;
  	}
  
	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);
 	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);
  
  	srcreg = (opcode >> 4) & 0x3f;
  	if (user_mode(regs)) {
 		__u64 buffer;
 		 
 		__u32 buflo=0xffffffffUL, bufhi=0xffffffffUL;
 
 		if (!access_ok(VERIFY_WRITE, (unsigned long) address, 1UL<<width_shift)) {
 			return -1;
 		}
 
 		 
 		if (last_task_used_math == current) {
 			enable_fpu();
 			save_fpu(current);
 			disable_fpu();
 			last_task_used_math = NULL;
 			regs->sr |= SR_FD;
 		}
 
 		switch (width_shift) {
 		case 2:
 			buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
 			break;
 		case 3:
 			if (do_paired_load) {
 				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
 				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
 			} else {
 #if defined(CONFIG_CPU_LITTLE_ENDIAN)
 				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg];
 				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
 #else
 				buflo = current->thread.xstate->hardfpu.fp_regs[srcreg];
 				bufhi = current->thread.xstate->hardfpu.fp_regs[srcreg+1];
 #endif
 			}
 			break;
 		default:
 			printk(""Unexpected width_shift %d in misaligned_fpu_store, PC=%08lx\n"",
 				width_shift, (unsigned long) regs->pc);
 			break;
 		}
 
 		*(__u32*) &buffer = buflo;
 		*(1 + (__u32*) &buffer) = bufhi;
 		if (__copy_user((void *)(int)address, &buffer, (1 << width_shift)) > 0) {
 			return -1;  
 		}
 		return 0;
 	} else {
 		die (""Misaligned FPU load inside kernel"", regs, 0);
 		return -1;
 	}
 }","[19, 18]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
202330," int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                             size_t size)
 {
     GetBitContext gb;
     AC3HeaderInfo *hdr;
     int err;
 
     if (!*phdr)
         *phdr = av_mallocz(sizeof(AC3HeaderInfo));
     if (!*phdr)
          return AVERROR(ENOMEM);
      hdr = *phdr;
  
    init_get_bits8(&gb, buf, size);
     err = init_get_bits8(&gb, buf, size);
     if (err < 0)
         return AVERROR_INVALIDDATA;
      err = ff_ac3_parse_header(&gb, hdr);
      if (err < 0)
          return AVERROR_INVALIDDATA;
 
     return get_bits_count(&gb);
 }","[15, 16, 17, 14]","In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service."
205119,"  Metadata* EntrySync::getMetadata(ExceptionState& exceptionState)
  {
    RefPtr<MetadataSyncCallbackHelper> helper = MetadataSyncCallbackHelper::create();
     MetadataSyncCallbackHelper* helper = MetadataSyncCallbackHelper::create();
      m_fileSystem->getMetadata(this, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
      return helper->getResult(exceptionState);
  }","[4, 3]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
199719," int sock_setsockopt(struct socket *sock, int level, int optname,
 		    char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
 	int val;
 	int valbool;
 	struct linger ling;
 	int ret = 0;
 
 	 
 
 	if (optname == SO_BINDTODEVICE)
 		return sock_bindtodevice(sk, optval, optlen);
 
 	if (optlen < sizeof(int))
 		return -EINVAL;
 
 	if (get_user(val, (int __user *)optval))
 		return -EFAULT;
 
 	valbool = val ? 1 : 0;
 
 	lock_sock(sk);
 
 	switch (optname) {
 	case SO_DEBUG:
 		if (val && !capable(CAP_NET_ADMIN))
 			ret = -EACCES;
 		else
 			sock_valbool_flag(sk, SOCK_DBG, valbool);
 		break;
 	case SO_REUSEADDR:
 		sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE);
 		break;
 	case SO_TYPE:
 	case SO_PROTOCOL:
 	case SO_DOMAIN:
 	case SO_ERROR:
 		ret = -ENOPROTOOPT;
 		break;
 	case SO_DONTROUTE:
 		sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool);
 		break;
 	case SO_BROADCAST:
 		sock_valbool_flag(sk, SOCK_BROADCAST, valbool);
 		break;
 	case SO_SNDBUF:
 		 
 		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk->sk_userlocks |= SOCK_SNDBUF_LOCK;
 		sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);
 		 
 		sk->sk_write_space(sk);
 		break;
 
 	case SO_SNDBUFFORCE:
 		if (!capable(CAP_NET_ADMIN)) {
 			ret = -EPERM;
 			break;
 		}
 		goto set_sndbuf;
 
 	case SO_RCVBUF:
 		 
 		val = min_t(u32, val, sysctl_rmem_max);
 set_rcvbuf:
 		sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
 		 
 		sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);
 		break;
 
 	case SO_RCVBUFFORCE:
 		if (!capable(CAP_NET_ADMIN)) {
 			ret = -EPERM;
 			break;
 		}
 		goto set_rcvbuf;
  
  	case SO_KEEPALIVE:
  #ifdef CONFIG_INET
		if (sk->sk_protocol == IPPROTO_TCP)
 		if (sk->sk_protocol == IPPROTO_TCP &&
 		    sk->sk_type == SOCK_STREAM)
  			tcp_set_keepalive(sk, valbool);
  #endif
  		sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);
 		break;
 
 	case SO_OOBINLINE:
 		sock_valbool_flag(sk, SOCK_URGINLINE, valbool);
 		break;
 
 	case SO_NO_CHECK:
 		sk->sk_no_check = valbool;
 		break;
 
 	case SO_PRIORITY:
 		if ((val >= 0 && val <= 6) || capable(CAP_NET_ADMIN))
 			sk->sk_priority = val;
 		else
 			ret = -EPERM;
 		break;
 
 	case SO_LINGER:
 		if (optlen < sizeof(ling)) {
 			ret = -EINVAL;	 
 			break;
 		}
 		if (copy_from_user(&ling, optval, sizeof(ling))) {
 			ret = -EFAULT;
 			break;
 		}
 		if (!ling.l_onoff)
 			sock_reset_flag(sk, SOCK_LINGER);
 		else {
 #if (BITS_PER_LONG == 32)
 			if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ)
 				sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT;
 			else
 #endif
 				sk->sk_lingertime = (unsigned int)ling.l_linger * HZ;
 			sock_set_flag(sk, SOCK_LINGER);
 		}
 		break;
 
 	case SO_BSDCOMPAT:
 		sock_warn_obsolete_bsdism(""setsockopt"");
 		break;
 
 	case SO_PASSCRED:
 		if (valbool)
 			set_bit(SOCK_PASSCRED, &sock->flags);
 		else
 			clear_bit(SOCK_PASSCRED, &sock->flags);
 		break;
 
 	case SO_TIMESTAMP:
 	case SO_TIMESTAMPNS:
 		if (valbool)  {
 			if (optname == SO_TIMESTAMP)
 				sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 			else
 				sock_set_flag(sk, SOCK_RCVTSTAMPNS);
 			sock_set_flag(sk, SOCK_RCVTSTAMP);
 			sock_enable_timestamp(sk, SOCK_TIMESTAMP);
 		} else {
 			sock_reset_flag(sk, SOCK_RCVTSTAMP);
 			sock_reset_flag(sk, SOCK_RCVTSTAMPNS);
 		}
 		break;
 
 	case SO_TIMESTAMPING:
 		if (val & ~SOF_TIMESTAMPING_MASK) {
 			ret = -EINVAL;
 			break;
 		}
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE,
 				  val & SOF_TIMESTAMPING_TX_HARDWARE);
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE,
 				  val & SOF_TIMESTAMPING_TX_SOFTWARE);
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE,
 				  val & SOF_TIMESTAMPING_RX_HARDWARE);
 		if (val & SOF_TIMESTAMPING_RX_SOFTWARE)
 			sock_enable_timestamp(sk,
 					      SOCK_TIMESTAMPING_RX_SOFTWARE);
 		else
 			sock_disable_timestamp(sk,
 					       (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE));
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SOFTWARE,
 				  val & SOF_TIMESTAMPING_SOFTWARE);
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE,
 				  val & SOF_TIMESTAMPING_SYS_HARDWARE);
 		sock_valbool_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE,
 				  val & SOF_TIMESTAMPING_RAW_HARDWARE);
 		break;
 
 	case SO_RCVLOWAT:
 		if (val < 0)
 			val = INT_MAX;
 		sk->sk_rcvlowat = val ? : 1;
 		break;
 
 	case SO_RCVTIMEO:
 		ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen);
 		break;
 
 	case SO_SNDTIMEO:
 		ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen);
 		break;
 
 	case SO_ATTACH_FILTER:
 		ret = -EINVAL;
 		if (optlen == sizeof(struct sock_fprog)) {
 			struct sock_fprog fprog;
 
 			ret = -EFAULT;
 			if (copy_from_user(&fprog, optval, sizeof(fprog)))
 				break;
 
 			ret = sk_attach_filter(&fprog, sk);
 		}
 		break;
 
 	case SO_DETACH_FILTER:
 		ret = sk_detach_filter(sk);
 		break;
 
 	case SO_PASSSEC:
 		if (valbool)
 			set_bit(SOCK_PASSSEC, &sock->flags);
 		else
 			clear_bit(SOCK_PASSSEC, &sock->flags);
 		break;
 	case SO_MARK:
 		if (!capable(CAP_NET_ADMIN))
 			ret = -EPERM;
 		else
 			sk->sk_mark = val;
 		break;
 
 		 
 	case SO_RXQ_OVFL:
 		sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool);
 		break;
 
 	case SO_WIFI_STATUS:
 		sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool);
 		break;
 
 	case SO_PEEK_OFF:
 		if (sock->ops->set_peek_off)
 			sock->ops->set_peek_off(sk, val);
 		else
 			ret = -EOPNOTSUPP;
 		break;
 
 	case SO_NOFCS:
 		sock_valbool_flag(sk, SOCK_NOFCS, valbool);
 		break;
 
 	default:
 		ret = -ENOPROTOOPT;
 		break;
 	}
 	release_sock(sk);
 	return ret;
 }","[83, 84, 82]","The sock_setsockopt function in net/core/sock.c in the Linux kernel before 3.5.7 does not ensure that a keepalive action is associated with a stream socket, which allows local users to cause a denial of service (system crash) by leveraging the ability to create a raw socket."
8715,"resolve_op_from_commit (FlatpakTransaction *self,
FlatpakTransactionOperation *op,
const char *checksum,
GFile *sideload_path,
GVariant *commit_data)
{
g_autoptr(GBytes) metadata_bytes = NULL;
g_autoptr(GVariant) commit_metadata = NULL;
const char *xa_metadata = NULL;
guint64 download_size = 0;
guint64 installed_size = 0;

commit_metadata = g_variant_get_child_value (commit_data, 0);
g_variant_lookup (commit_metadata, ""xa.metadata"", ""&s"", &xa_metadata);
if (xa_metadata == NULL)
g_message (""Warning: No xa.metadata in local commit %s ref %s"", checksum, flatpak_decomposed_get_ref (op->ref));
else
metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));

if (g_variant_lookup (commit_metadata, ""xa.download-size"", ""t"", &download_size))
op->download_size = GUINT64_FROM_BE (download_size);
if (g_variant_lookup (commit_metadata, ""xa.installed-size"", ""t"", &installed_size))
op->installed_size = GUINT64_FROM_BE (installed_size);

g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, ""s"", &op->eol);
g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, ""s"", &op->eol_rebase);

resolve_op_end (self, op, checksum, sideload_path, metadata_bytes);
}","[5, 16, 17, 18, 28]","Flatpak is a Linux application sandboxing and distribution framework. Prior to versions 1.12.3 and 1.10.6, Flatpak doesn't properly validate that the permissions displayed to the user for an app at install time match the actual permissions granted to the app at runtime, in the case that there's a null byte in the metadata file of an app. Therefore apps can grant themselves permissions without the consent of the user. Flatpak shows permissions to the user during install by reading them from the ""xa.metadata"" key in the commit metadata. This cannot contain a null terminator, because it is an untrusted GVariant. Flatpak compares these permissions to the *actual* metadata, from the ""metadata"" file to ensure it wasn't lied to. However, the actual metadata contents are loaded in several places where they are read as simple C-style strings. That means that, if the metadata file includes a null terminator, only the content of the file from *before* the terminator gets compared to xa.metadata. Thus, any permissions that appear in the metadata file after a null terminator are applied at runtime but not shown to the user. So maliciously crafted apps can give themselves hidden permissions. Users who have Flatpaks installed from untrusted sources are at risk in case the Flatpak has a maliciously crafted metadata file, either initially or in an update. This issue is patched in versions 1.12.3 and 1.10.6. As a workaround, users can manually check the permissions of installed apps by checking the metadata file or the xa.metadata key on the commit metadata."
207914," status_t BnOMX::onTransact(
  uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
  switch (code) {
  case LIVES_LOCALLY:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
             node_id node = (node_id)data.readInt32();
  pid_t pid = (pid_t)data.readInt32();
             reply->writeInt32(livesLocally(node, pid));
 
  return OK;
  }
 
  case LIST_NODES:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
  List<ComponentInfo> list;
             listNodes(&list);
 
             reply->writeInt32(list.size());
  for (List<ComponentInfo>::iterator it = list.begin();
                  it != list.end(); ++it) {
  ComponentInfo &cur = *it;
 
                 reply->writeString8(cur.mName);
                 reply->writeInt32(cur.mRoles.size());
  for (List<String8>::iterator role_it = cur.mRoles.begin();
                      role_it != cur.mRoles.end(); ++role_it) {
                     reply->writeString8(*role_it);
  }
  }
 
  return NO_ERROR;
  }
 
  case ALLOCATE_NODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
  const char *name = data.readCString();
 
             sp<IOMXObserver> observer =
                 interface_cast<IOMXObserver>(data.readStrongBinder());
 
             node_id node;
 
  status_t err = allocateNode(name, observer, &node);
             reply->writeInt32(err);
  if (err == OK) {
                 reply->writeInt32((int32_t)node);
  }
 
  return NO_ERROR;
  }
 
  case FREE_NODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
             reply->writeInt32(freeNode(node));
 
  return NO_ERROR;
  }
 
  case SEND_COMMAND:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
             OMX_COMMANDTYPE cmd =
  static_cast<OMX_COMMANDTYPE>(data.readInt32());
 
             OMX_S32 param = data.readInt32();
             reply->writeInt32(sendCommand(node, cmd, param));
 
  return NO_ERROR;
  }
 
  case GET_PARAMETER:
  case SET_PARAMETER:
  case GET_CONFIG:
  case SET_CONFIG:
  case SET_INTERNAL_OPTION:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());
 
  size_t size = data.readInt64();
 
  void *params = malloc(size);
             data.read(params, size);
 
  status_t err;
  switch (code) {
  case GET_PARAMETER:
                     err = getParameter(node, index, params, size);
  break;
  case SET_PARAMETER:
                     err = setParameter(node, index, params, size);
  break;
  case GET_CONFIG:
                     err = getConfig(node, index, params, size);
  break;
  case SET_CONFIG:
                     err = setConfig(node, index, params, size);
  break;
  case SET_INTERNAL_OPTION:
  {
  InternalOptionType type =
  (InternalOptionType)data.readInt32();
 
                     err = setInternalOption(node, index, type, params, size);
  break;
  }
 
  default:
                     TRESPASS();
  }
 
             reply->writeInt32(err);
 
  if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                 reply->write(params, size);
  }
 
             free(params);
             params = NULL;
 
  return NO_ERROR;
  }
 
  case GET_STATE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_STATETYPE state = OMX_StateInvalid;
 
  status_t err = getState(node, &state);
             reply->writeInt32(state);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case ENABLE_GRAPHIC_BUFFERS:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
 
  status_t err = enableGraphicBuffers(node, port_index, enable);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case GET_GRAPHIC_BUFFER_USAGE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
 
             OMX_U32 usage = 0;
  status_t err = getGraphicBufferUsage(node, port_index, &usage);
             reply->writeInt32(err);
             reply->writeInt32(usage);
 
  return NO_ERROR;
  }
 
  case USE_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<IMemory> params =
                 interface_cast<IMemory>(data.readStrongBinder());
             OMX_U32 allottedSize = data.readInt32();
 
             buffer_id buffer;
  status_t err = useBuffer(node, port_index, params, &buffer, allottedSize);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case USE_GRAPHIC_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
             data.read(*graphicBuffer);
 
             buffer_id buffer;
  status_t err = useGraphicBuffer(
                     node, port_index, graphicBuffer, &buffer);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case UPDATE_GRAPHIC_BUFFER_IN_META:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
             data.read(*graphicBuffer);
             buffer_id buffer = (buffer_id)data.readInt32();
 
  status_t err = updateGraphicBufferInMeta(
                     node, port_index, graphicBuffer, buffer);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case CREATE_INPUT_SURFACE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
              OMX_U32 port_index = data.readInt32();
  
              sp<IGraphicBufferProducer> bufferProducer;
            MetadataBufferType type;
             MetadataBufferType type = kMetadataBufferTypeInvalid;
              status_t err = createInputSurface(node, port_index, &bufferProducer, &type);
  
             if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                 android_errorWriteLog(0x534e4554, ""26324358"");
             }
 
              reply->writeInt32(type);
              reply->writeInt32(err);
  
  if (err == OK) {
                 reply->writeStrongBinder(IInterface::asBinder(bufferProducer));
  }
 
  return NO_ERROR;
  }
 
  case CREATE_PERSISTENT_INPUT_SURFACE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             sp<IGraphicBufferProducer> bufferProducer;
             sp<IGraphicBufferConsumer> bufferConsumer;
  status_t err = createPersistentInputSurface(
  &bufferProducer, &bufferConsumer);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeStrongBinder(IInterface::asBinder(bufferProducer));
                 reply->writeStrongBinder(IInterface::asBinder(bufferConsumer));
  }
 
  return NO_ERROR;
  }
 
  case SET_INPUT_SURFACE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
 
 
              sp<IGraphicBufferConsumer> bufferConsumer =
                      interface_cast<IGraphicBufferConsumer>(data.readStrongBinder());
  
            MetadataBufferType type;
             MetadataBufferType type = kMetadataBufferTypeInvalid;
              status_t err = setInputSurface(node, port_index, bufferConsumer, &type);
  
             if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                 android_errorWriteLog(0x534e4554, ""26324358"");
             }
 
              reply->writeInt32(type);
              reply->writeInt32(err);
              return NO_ERROR;
  }
 
  case SIGNAL_END_OF_INPUT_STREAM:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
  status_t err = signalEndOfInputStream(node);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case STORE_META_DATA_IN_BUFFERS:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
              OMX_U32 port_index = data.readInt32();
              OMX_BOOL enable = (OMX_BOOL)data.readInt32();
  
            MetadataBufferType type;
             MetadataBufferType type = kMetadataBufferTypeInvalid;
              status_t err = storeMetaDataInBuffers(node, port_index, enable, &type);
 
             if ((err != OK) && (type == kMetadataBufferTypeInvalid)) {
                 android_errorWriteLog(0x534e4554, ""26324358"");
             }
 
              reply->writeInt32(type);
              reply->writeInt32(err);
  
  return NO_ERROR;
  }
 
  case PREPARE_FOR_ADAPTIVE_PLAYBACK:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
             OMX_U32 max_width = data.readInt32();
             OMX_U32 max_height = data.readInt32();
 
  status_t err = prepareForAdaptivePlayback(
                     node, port_index, enable, max_width, max_height);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case CONFIGURE_VIDEO_TUNNEL_MODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
             OMX_U32 audio_hw_sync = data.readInt32();
 
  native_handle_t *sideband_handle = NULL;
  status_t err = configureVideoTunnelMode(
                     node, port_index, tunneled, audio_hw_sync, &sideband_handle);
             reply->writeInt32(err);
  if(err == OK){
                 reply->writeNativeHandle(sideband_handle);
  }
 
  return NO_ERROR;
  }
 
  case ALLOC_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
  if (!isSecure(node) || port_index != 0  ) {
                 ALOGE(""b/24310423"");
                 reply->writeInt32(INVALID_OPERATION);
  return NO_ERROR;
  }
 
  size_t size = data.readInt64();
 
             buffer_id buffer;
  void *buffer_data;
  status_t err = allocateBuffer(
                     node, port_index, size, &buffer, &buffer_data);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
                 reply->writeInt64((uintptr_t)buffer_data);
  }
 
  return NO_ERROR;
  }
 
  case ALLOC_BUFFER_WITH_BACKUP:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<IMemory> params =
                 interface_cast<IMemory>(data.readStrongBinder());
             OMX_U32 allottedSize = data.readInt32();
 
             buffer_id buffer;
  status_t err = allocateBufferWithBackup(
                     node, port_index, params, &buffer, allottedSize);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case FREE_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
             reply->writeInt32(freeBuffer(node, port_index, buffer));
 
  return NO_ERROR;
  }
 
  case FILL_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
  bool haveFence = data.readInt32();
  int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;
             reply->writeInt32(fillBuffer(node, buffer, fenceFd));
 
  return NO_ERROR;
  }
 
  case EMPTY_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
             OMX_U32 range_offset = data.readInt32();
             OMX_U32 range_length = data.readInt32();
             OMX_U32 flags = data.readInt32();
             OMX_TICKS timestamp = data.readInt64();
  bool haveFence = data.readInt32();
  int fenceFd = haveFence ? ::dup(data.readFileDescriptor()) : -1;
             reply->writeInt32(emptyBuffer(
                     node, buffer, range_offset, range_length, flags, timestamp, fenceFd));
 
  return NO_ERROR;
  }
 
  case GET_EXTENSION_INDEX:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
  const char *parameter_name = data.readCString();
 
             OMX_INDEXTYPE index;
  status_t err = getExtensionIndex(node, parameter_name, &index);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32(index);
  }
 
  return OK;
  }
 
  default:
  return BBinder::onTransact(code, data, reply, flags);
  }
 }","[250, 253, 254, 255, 256, 298, 301, 302, 303, 304, 332, 334, 335, 336, 337, 338, 249, 297, 331]","media/libmedia/IOMX.cpp in mediaserver in Android 6.x before 2016-04-01 does not initialize certain metadata buffer pointers, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26324358."
10047,"Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s,
const NodeDef &node) {
VLOG(4) << ""Importing: "" << node.name();
OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op()));



const OpDef *op_def;
const OpRegistrationData *op_reg_data = nullptr;
if ((op_reg_data = registry_.LookUp(node.op()))) {
op_def = &op_reg_data->op_def;
} else {
auto it = function_op_defs_.find(node.op());
if (it == function_op_defs_.end())
return InvalidArgument(""Unable to find OpDef for "", node.op());
op_def = it->second;
}


state.attributes.reserve(node.attr_size() + 3);
if (!node.device().empty()) {
state.addAttribute(dialect_->getDeviceAttrIdentifier(),
b_.getStringAttr(node.device()));
}
if (!node.name().empty()) {
state.addAttribute(dialect_->getNameAttrIdentifier(),
b_.getStringAttr(node.name()));
}


const auto add_full_type = [&](const FullTypeDef &full_type_def) {
TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr full_type,
ConvertAttribute(full_type_def, b_, dialect_));
state.addAttribute(dialect_->getFullTypeAttrIdentifier(), full_type);
return ::tensorflow::OkStatus();
};
if (node.has_experimental_type()) {
TF_RETURN_IF_ERROR(add_full_type(node.experimental_type()));
} else if (op_reg_data && op_reg_data->type_ctor) {
FullTypeDef full_type_def;
TF_RETURN_IF_ERROR(
tensorflow::full_type::SpecializeType(node, *op_def, full_type_def));
TF_RETURN_IF_ERROR(add_full_type(full_type_def));
}

for (auto &name_attr : node.attr()) {
if (name_attr.first.empty())
return InvalidArgument(""Node "", node.name(), "" has an empty attr name"");
TF_ASSIGN_OR_RETURN(Attribute attr,
ConvertAttributeValue(name_attr.second, b_, dialect_));
state.addAttribute(name_attr.first, attr);
}


for (const auto &attr_def : op_def->attr()) {
if (attr_def.has_default_value() &&
!state.attributes.get(attr_def.name())) {
TF_ASSIGN_OR_RETURN(
Attribute attr,
ConvertAttributeValue(attr_def.default_value(), b_, dialect_));
state.addAttribute(attr_def.name(), attr);
}
}



SmallVector<std::pair<unsigned, unsigned>> result_segments;
result_segments.reserve(op_def->output_arg_size());
state.types.reserve(op_def->output_arg_size() + 1);
for (const OpDef::ArgDef &def : op_def->output_arg()) {
unsigned index = state.types.size();
TF_ASSIGN_OR_RETURN(unsigned size,
ArgNumType(state.attributes, def, state.types));
result_segments.emplace_back(index, size);
}
state.types.push_back(dialect_->getControlType());



state.operands.reserve(node.input_size());
SmallVector<Value> control_operands;
struct BackedgeResolution {
ResultInfo *info;
size_t operand_index;
ResultId id;
};
SmallVector<BackedgeResolution> unresolved_data_operands,
unresolved_control_operands;
for (const std::string &input : node.input()) {
TF_ASSIGN_OR_RETURN(Result result, GetResult(s, input));
if (result.control) {
if (result.info) {
unresolved_control_operands.push_back(BackedgeResolution{
result.info, control_operands.size(), result.id});
}
control_operands.push_back(result.control);
} else {
if (result.info) {
unresolved_data_operands.push_back(
BackedgeResolution{result.info, state.operands.size(), result.id});
}
state.operands.push_back(result.data);
}
}
unsigned num_data_operands = state.operands.size();
state.addOperands(control_operands);


Operation *op = builder.create(state);
for (const BackedgeResolution &r : unresolved_data_operands) {
r.info->backedges.push_back(
Backedge{r.id, &op->getOpOperand(r.operand_index)});
}
for (const BackedgeResolution &r : unresolved_control_operands) {
r.info->backedges.push_back(
Backedge{r.id, &op->getOpOperand(num_data_operands + r.operand_index)});
}

std::unique_ptr<ResultInfo> &info = s[node.name()];
if (!info) {
info = std::make_unique<ResultInfo>();
}
info->resolved = true;
info->control = *std::prev(op->result_end());
info->data = op->getResults().drop_back();
for (auto it : llvm::zip(result_segments, op_def->output_arg())) {
const std::pair<unsigned, unsigned> &segment = std::get<0>(it);
info->outputs.emplace(std::get<1>(it).name(),
info->data.slice(segment.first, segment.second));
}


for (const Backedge &backedge : info->backedges) {
Value value;
if (backedge.id.IsControl()) {
value = info->control;
} else {
TF_ASSIGN_OR_RETURN(value, ResolveDataResult(backedge.id, info.get()));
}
backedge.operand->set(value);
}
info->backedges.clear();

return ::tensorflow::OkStatus();
}",[4],"TensorFlow is an open source platform for machine learning. When `mlir::tfg::GraphDefImporter::ConvertNodeDef` tries to convert NodeDefs without an op name, it crashes. We have patched the issue in GitHub commit a0f0b9a21c9270930457095092f558fbad4c03e5. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
205862,"  AudioRendererHost::AudioRendererHost(int render_process_id,
                                       media::AudioManager* audio_manager,
                                      media::AudioSystem* audio_system,
                                       AudioMirroringManager* mirroring_manager,
                                       MediaStreamManager* media_stream_manager,
                                       const std::string& salt)
     : BrowserMessageFilter(AudioMsgStart),
       render_process_id_(render_process_id),
       audio_manager_(audio_manager),
       mirroring_manager_(mirroring_manager),
        media_stream_manager_(media_stream_manager),
        salt_(salt),
        validate_render_frame_id_function_(&ValidateRenderFrameId),
      authorization_handler_(audio_manager_,
       authorization_handler_(audio_system,
                               media_stream_manager,
                               render_process_id_,
                               salt) {
   DCHECK(audio_manager_);
 }","[3, 15, 14]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
199552," getword(f, word, newlinep, filename)
     FILE *f;
     char *word;
     int *newlinep;
     char *filename;
 {
     int c, len, escape;
     int quoted, comment;
     int value, digit, got, n;
 
 #define isoctal(c) ((c) >= '0' && (c) < '8')
 
     *newlinep = 0;
     len = 0;
     escape = 0;
     comment = 0;
     quoted = 0;
 
      
     for (;;) {
 	c = getc(f);
 	if (c == EOF)
 	    break;
 
 	 
 	if (c == '\n') {
 	    if (!escape) {
 		*newlinep = 1;
 		comment = 0;
 	    } else
 		escape = 0;
 	    continue;
 	}
 
 	 
 	if (comment)
 	    continue;
 
 	 
 	if (escape)
 	    break;
 
 	 
 	if (c == '\\') {
 	    escape = 1;
 	    continue;
 	}
 
 	 
 	if (c == '#') {
 	    comment = 1;
 	    continue;
 	}
 
 	 
 	if (!isspace(c))
 	    break;
     }
 
      
     while (c != EOF) {
 	if (escape) {
 	     
 	    escape = 0;
 	    if (c == '\n') {
 	        c = getc(f);
 		continue;
 	    }
 
 	    got = 0;
 	    switch (c) {
 	    case 'a':
 		value = '\a';
 		break;
 	    case 'b':
 		value = '\b';
 		break;
 	    case 'f':
 		value = '\f';
 		break;
 	    case 'n':
 		value = '\n';
 		break;
 	    case 'r':
 		value = '\r';
 		break;
 	    case 's':
 		value = ' ';
 		break;
 	    case 't':
 		value = '\t';
 		break;
 
 	    default:
 		if (isoctal(c)) {
 		     
 		    value = 0;
 		    for (n = 0; n < 3 && isoctal(c); ++n) {
 			value = (value << 3) + (c & 07);
 			c = getc(f);
 		    }
 		    got = 1;
 		    break;
 		}
 
 		if (c == 'x') {
 		     
 		    value = 0;
 		    c = getc(f);
 		    for (n = 0; n < 2 && isxdigit(c); ++n) {
 			digit = toupper(c) - '0';
 			if (digit > 10)
 			    digit += '0' + 10 - 'A';
 			value = (value << 4) + digit;
 			c = getc (f);
 		    }
 		    got = 1;
 		    break;
 		}
 
 		 
 		value = c;
 		break;
 	    }
 
  	     
	    if (len < MAXWORDLEN-1)
 	    if (len < MAXWORDLEN) {
  		word[len] = value;
	    ++len;
 		++len;
 	    }
  
  	    if (!got)
  		c = getc(f);
 	    continue;
 	}
 
 	 
 	if (c == '\\') {
 	    escape = 1;
 	    c = getc(f);
 	    continue;
 	}
 
 	 
 	if (quoted) {
 	    if (c == quoted) {
 		quoted = 0;
 		c = getc(f);
 		continue;
 	    }
 	} else if (c == '""' || c == '\'') {
 	    quoted = c;
 	    c = getc(f);
 	    continue;
 	} else if (isspace(c) || c == '#') {
 	    ungetc (c, f);
 	    break;
 	}
 
  	 
	if (len < MAXWORDLEN-1)
 	if (len < MAXWORDLEN) {
  	    word[len] = c;
	++len;
 	    ++len;
 	}
  
  	c = getc(f);
      }
 
      
     if (c == EOF) {
 	if (ferror(f)) {
 	    if (errno == 0)
 		errno = EIO;
 	    option_error(""Error reading %s: %m"", filename);
 	    die(1);
 	}
 	 
 	if (len == 0)
 	    return 0;
 	if (quoted)
 	    option_error(""warning: quoted word runs to end of file (%.20s...)"",
 			 filename, word);
     }
 
      
     if (len >= MAXWORDLEN) {
 	option_error(""warning: word in file %s too long (%.20s...)"",
 		     filename, word);
 	len = MAXWORDLEN - 1;
     }
     word[len] = 0;
 
     return 1;
 
 #undef isoctal
 
 }","[128, 131, 132, 164, 167, 168, 127, 130, 163, 166]","Integer overflow in the getword function in options.c in pppd in Paul's PPP Package (ppp) before 2.4.7 allows attackers to *access privileged options* via a long word in an options file, which triggers a heap-based buffer overflow that *[corrupts] security-relevant variables.*"
207712,"  safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST color_encoding *e, double encoding_gamma)
    const color_encoding *e, double encoding_gamma)
  {
     if (e != 0)
     {
  if (encoding_gamma != 0)
          pos = safecat(buffer, bufsize, pos, ""("");
       pos = safecat(buffer, bufsize, pos, ""R("");
       pos = safecatd(buffer, bufsize, pos, e->red.X, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);
       pos = safecat(buffer, bufsize, pos, ""),G("");
       pos = safecatd(buffer, bufsize, pos, e->green.X, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);
       pos = safecat(buffer, bufsize, pos, ""),B("");
       pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);
       pos = safecat(buffer, bufsize, pos, "","");
       pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);
       pos = safecat(buffer, bufsize, pos, "")"");
  if (encoding_gamma != 0)
          pos = safecat(buffer, bufsize, pos, "")"");
  }
 
  if (encoding_gamma != 0)
  {
       pos = safecat(buffer, bufsize, pos, ""^"");
       pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);
  }
 
  
     return pos;
  }","[3, 2]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
204268," BlobDataHandle::BlobDataHandle(PassOwnPtr<BlobData> data, long long size)
  {
      UNUSED_PARAM(size);
      m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, data);
     BlobRegistry::registerBlobURL(m_internalURL, data);
  }","[6, 5]","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
8149,"int __cil_resolve_ast_node_helper(struct cil_tree_node *node, uint32_t *finished, void *extra_args)
{
int rc = SEPOL_OK;
struct cil_args_resolve *args = extra_args;
enum cil_pass pass = args->pass;
struct cil_tree_node *block = args->block;
struct cil_tree_node *macro = args->macro;
struct cil_tree_node *optional = args->optional;
struct cil_tree_node *boolif = args->boolif;

if (node == NULL) {
goto exit;
}

if (block != NULL) {
if (node->flavor == CIL_CAT ||
node->flavor == CIL_SENS) {
cil_tree_log(node, CIL_ERR, ""%s statement is not allowed in blocks"", cil_node_to_string(node));
rc = SEPOL_ERR;
goto exit;
}
}

if (macro != NULL) {
if (node->flavor == CIL_BLOCK ||
node->flavor == CIL_BLOCKINHERIT ||
node->flavor == CIL_BLOCKABSTRACT ||
node->flavor == CIL_MACRO) {
cil_tree_log(node, CIL_ERR, ""%s statement is not allowed in macros"", cil_node_to_string(node));
rc = SEPOL_ERR;
goto exit;
}
}

if (optional != NULL) {
if (node->flavor == CIL_TUNABLE ||
node->flavor == CIL_MACRO) {

cil_tree_log(node, CIL_ERR, ""%s statement is not allowed in optionals"", cil_node_to_string(node));
rc = SEPOL_ERR;
goto exit;
}
}

if (boolif != NULL) {
if (node->flavor != CIL_TUNABLEIF &&
node->flavor != CIL_CALL &&
node->flavor != CIL_CONDBLOCK &&
node->flavor != CIL_AVRULE &&
node->flavor != CIL_TYPE_RULE &&
node->flavor != CIL_NAMETYPETRANSITION) {
rc = SEPOL_ERR;
} else if (node->flavor == CIL_AVRULE) {
struct cil_avrule *rule = node->data;
if (rule->rule_kind == CIL_AVRULE_NEVERALLOW) {
rc = SEPOL_ERR;
}
}
if (rc == SEPOL_ERR) {
if (((struct cil_booleanif*)boolif->data)->preserved_tunable) {
cil_tree_log(node, CIL_ERR, ""%s statement is not allowed in booleanifs (tunableif treated as a booleanif)"", cil_node_to_string(node));
} else {
cil_tree_log(node, CIL_ERR, ""%s statement is not allowed in booleanifs"", cil_node_to_string(node));
}
goto exit;
}
}

if (node->flavor == CIL_MACRO) {
if (pass != CIL_PASS_TIF && pass != CIL_PASS_MACRO) {
*finished = CIL_TREE_SKIP_HEAD;
rc = SEPOL_OK;
goto exit;
}
}

if (node->flavor == CIL_BLOCK && ((((struct cil_block*)node->data)->is_abstract == CIL_TRUE) && (pass > CIL_PASS_BLKABS))) {
*finished = CIL_TREE_SKIP_HEAD;
rc = SEPOL_OK;
goto exit;
}

rc = __cil_resolve_ast_node(node, extra_args);
if (rc == SEPOL_ENOENT) {
enum cil_log_level lvl = CIL_ERR;

if (optional != NULL) {
lvl = CIL_INFO;

struct cil_optional *opt = (struct cil_optional *)optional->data;
struct cil_tree_node *opt_node = NODE(opt);;

opt->enabled = CIL_FALSE;
cil_tree_log(node, lvl, ""Failed to resolve %s statement"", cil_node_to_string(node));
cil_tree_log(opt_node, lvl, ""Disabling optional '%s'"", opt->datum.name);
rc = SEPOL_OK;
goto exit;
}

cil_tree_log(node, lvl, ""Failed to resolve %s statement"", cil_node_to_string(node));
goto exit;
}

return rc;

exit:
return rc;
}",[37],The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.
9661,"static void xudc_set_clear_feature(struct xusb_udc *udc)
{
struct xusb_ep *ep0 = &udc->ep[0];
struct xusb_req *req = udc->req;
struct xusb_ep *target_ep;
u8 endpoint;
u8 outinbit;
u32 epcfgreg;
int flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);
int ret;

switch (udc->setup.bRequestType) {
case USB_RECIP_DEVICE:
switch (udc->setup.wValue) {
case USB_DEVICE_TEST_MODE:




break;
case USB_DEVICE_REMOTE_WAKEUP:
if (flag)
udc->remote_wkp = 1;
else
udc->remote_wkp = 0;
break;
default:
xudc_ep0_stall(udc);
break;
}
break;
case USB_RECIP_ENDPOINT:
if (!udc->setup.wValue) {
endpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;
target_ep = &udc->ep[endpoint];
outinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;
outinbit = outinbit >> 7;


if (outinbit != target_ep->is_in) {
xudc_ep0_stall(udc);
return;
}
epcfgreg = udc->read_fn(udc->addr + target_ep->offset);
if (!endpoint) {

epcfgreg &= ~XUSB_EP_CFG_STALL_MASK;
udc->write_fn(udc->addr,
target_ep->offset, epcfgreg);
} else {
if (flag) {
epcfgreg |= XUSB_EP_CFG_STALL_MASK;
udc->write_fn(udc->addr,
target_ep->offset,
epcfgreg);
} else {

epcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |
XUSB_EP_CFG_DATA_TOGGLE_MASK);
udc->write_fn(udc->addr,
target_ep->offset,
epcfgreg);
}
}
}
break;
default:
xudc_ep0_stall(udc);
return;
}

req->usb_req.length = 0;
ret = __xudc_ep0_queue(ep0, req);
if (ret == 0)
return;

dev_err(udc->dev, ""Can't respond to SET/CLEAR FEATURE\n"");
xudc_ep0_stall(udc);
}",[35],"In drivers/usb/gadget/udc/udc-xilinx.c in the Linux kernel before 5.16.12, the endpoint index is not validated and might be manipulated by the host for out-of-array access."
203239," sf_open	(const char *path, int mode, SF_INFO *sfinfo)
 {	SF_PRIVATE 	*psf ;
 
  	 
  	assert (sizeof (sf_count_t) == 8) ;
  
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
 	if ((psf = psf_allocate ()) == NULL)
  	{	sf_errno = SFE_MALLOC_FAILED ;
  		return	NULL ;
  		} ;
 
 	psf_init_files (psf) ;
 
 	psf_log_printf (psf, ""File : %s\n"", path) ;
 
 	if (copy_filename (psf, path) != 0)
 	{	sf_errno = psf->error ;
 		return	NULL ;
 		} ;
 
 	psf->file.mode = mode ;
 	if (strcmp (path, ""-"") == 0)
 		psf->error = psf_set_stdio (psf) ;
 	else
 		psf->error = psf_fopen (psf) ;
 
 	return psf_open_file (psf, sfinfo) ;
 }  ","[8, 7]","In libsndfile before 1.0.28, an error in the *header_read()* function (common.c) when handling ID3 tags can be exploited to cause a stack-based buffer overflow via a specially crafted FLAC file."
207915," status_t BnOMX::onTransact(
  uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) {
  switch (code) {
  case LIVES_LOCALLY:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
             node_id node = (node_id)data.readInt32();
  pid_t pid = (pid_t)data.readInt32();
             reply->writeInt32(livesLocally(node, pid));
 
  return OK;
  }
 
  case LIST_NODES:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
  List<ComponentInfo> list;
             listNodes(&list);
 
             reply->writeInt32(list.size());
  for (List<ComponentInfo>::iterator it = list.begin();
                  it != list.end(); ++it) {
  ComponentInfo &cur = *it;
 
                 reply->writeString8(cur.mName);
                 reply->writeInt32(cur.mRoles.size());
  for (List<String8>::iterator role_it = cur.mRoles.begin();
                      role_it != cur.mRoles.end(); ++role_it) {
                     reply->writeString8(*role_it);
  }
  }
 
  return NO_ERROR;
  }
 
  case ALLOCATE_NODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
  const char *name = data.readCString();
 
             sp<IOMXObserver> observer =
                 interface_cast<IOMXObserver>(data.readStrongBinder());
 
             node_id node;
 
  status_t err = allocateNode(name, observer, &node);
             reply->writeInt32(err);
  if (err == OK) {
                 reply->writeInt32((int32_t)node);
  }
 
  return NO_ERROR;
  }
 
  case FREE_NODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
             reply->writeInt32(freeNode(node));
 
  return NO_ERROR;
  }
 
  case SEND_COMMAND:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
             OMX_COMMANDTYPE cmd =
  static_cast<OMX_COMMANDTYPE>(data.readInt32());
 
             OMX_S32 param = data.readInt32();
             reply->writeInt32(sendCommand(node, cmd, param));
 
  return NO_ERROR;
  }
 
  case GET_PARAMETER:
  case SET_PARAMETER:
  case GET_CONFIG:
  case SET_CONFIG:
  case SET_INTERNAL_OPTION:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_INDEXTYPE index = static_cast<OMX_INDEXTYPE>(data.readInt32());
 
  
              size_t size = data.readInt64();
  
            void *params = malloc(size);
            data.read(params, size);
             status_t err = NO_MEMORY;
             void *params = calloc(size, 1);
             if (params) {
                 err = data.read(params, size);
                 if (err != OK) {
                     android_errorWriteLog(0x534e4554, ""26914474"");
                 } else {
                     switch (code) {
                         case GET_PARAMETER:
                             err = getParameter(node, index, params, size);
                             break;
                         case SET_PARAMETER:
                             err = setParameter(node, index, params, size);
                             break;
                         case GET_CONFIG:
                             err = getConfig(node, index, params, size);
                             break;
                         case SET_CONFIG:
                             err = setConfig(node, index, params, size);
                             break;
                         case SET_INTERNAL_OPTION:
                         {
                             InternalOptionType type =
                                 (InternalOptionType)data.readInt32();
  
            status_t err;
            switch (code) {
                case GET_PARAMETER:
                    err = getParameter(node, index, params, size);
                    break;
                case SET_PARAMETER:
                    err = setParameter(node, index, params, size);
                    break;
                case GET_CONFIG:
                    err = getConfig(node, index, params, size);
                    break;
                case SET_CONFIG:
                    err = setConfig(node, index, params, size);
                    break;
                case SET_INTERNAL_OPTION:
                {
                    InternalOptionType type =
                        (InternalOptionType)data.readInt32();
                             err = setInternalOption(node, index, type, params, size);
                             break;
                         }
  
                    err = setInternalOption(node, index, type, params, size);
                    break;
                         default:
                             TRESPASS();
                     }
                  }
                default:
                    TRESPASS();
              }
  
              reply->writeInt32(err);
 
  if ((code == GET_PARAMETER || code == GET_CONFIG) && err == OK) {
                 reply->write(params, size);
  }
 
             free(params);
             params = NULL;
 
  return NO_ERROR;
  }
 
  case GET_STATE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_STATETYPE state = OMX_StateInvalid;
 
  status_t err = getState(node, &state);
             reply->writeInt32(state);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case ENABLE_GRAPHIC_BUFFERS:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
 
  status_t err = enableGraphicBuffers(node, port_index, enable);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case GET_GRAPHIC_BUFFER_USAGE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
 
             OMX_U32 usage = 0;
  status_t err = getGraphicBufferUsage(node, port_index, &usage);
             reply->writeInt32(err);
             reply->writeInt32(usage);
 
  return NO_ERROR;
  }
 
  case USE_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<IMemory> params =
                 interface_cast<IMemory>(data.readStrongBinder());
 
             buffer_id buffer;
  status_t err = useBuffer(node, port_index, params, &buffer);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case USE_GRAPHIC_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
             data.read(*graphicBuffer);
 
             buffer_id buffer;
  status_t err = useGraphicBuffer(
                     node, port_index, graphicBuffer, &buffer);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case UPDATE_GRAPHIC_BUFFER_IN_META:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<GraphicBuffer> graphicBuffer = new GraphicBuffer();
             data.read(*graphicBuffer);
             buffer_id buffer = (buffer_id)data.readInt32();
 
  status_t err = updateGraphicBufferInMeta(
                     node, port_index, graphicBuffer, buffer);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case CREATE_INPUT_SURFACE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
 
             sp<IGraphicBufferProducer> bufferProducer;
  status_t err = createInputSurface(node, port_index,
  &bufferProducer);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeStrongBinder(bufferProducer->asBinder());
  }
 
  return NO_ERROR;
  }
 
  case SIGNAL_END_OF_INPUT_STREAM:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
 
  status_t err = signalEndOfInputStream(node);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case STORE_META_DATA_IN_BUFFERS:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
 
  status_t err = storeMetaDataInBuffers(node, port_index, enable);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case PREPARE_FOR_ADAPTIVE_PLAYBACK:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL enable = (OMX_BOOL)data.readInt32();
             OMX_U32 max_width = data.readInt32();
             OMX_U32 max_height = data.readInt32();
 
  status_t err = prepareForAdaptivePlayback(
                     node, port_index, enable, max_width, max_height);
             reply->writeInt32(err);
 
  return NO_ERROR;
  }
 
  case CONFIGURE_VIDEO_TUNNEL_MODE:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             OMX_BOOL tunneled = (OMX_BOOL)data.readInt32();
             OMX_U32 audio_hw_sync = data.readInt32();
 
  native_handle_t *sideband_handle = NULL;
  status_t err = configureVideoTunnelMode(
                     node, port_index, tunneled, audio_hw_sync, &sideband_handle);
             reply->writeInt32(err);
  if(err == OK){
                 reply->writeNativeHandle(sideband_handle);
  }
 
  return NO_ERROR;
  }
 
  case ALLOC_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
  if (!isSecure(node) || port_index != 0  ) {
                 ALOGE(""b/24310423"");
                 reply->writeInt32(INVALID_OPERATION);
  return NO_ERROR;
  }
 
  size_t size = data.readInt64();
 
             buffer_id buffer;
  void *buffer_data;
  status_t err = allocateBuffer(
                     node, port_index, size, &buffer, &buffer_data);
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
                 reply->writeInt64((uintptr_t)buffer_data);
  }
 
  return NO_ERROR;
  }
 
  case ALLOC_BUFFER_WITH_BACKUP:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             sp<IMemory> params =
                 interface_cast<IMemory>(data.readStrongBinder());
 
             buffer_id buffer;
  status_t err = allocateBufferWithBackup(
                     node, port_index, params, &buffer);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32((int32_t)buffer);
  }
 
  return NO_ERROR;
  }
 
  case FREE_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             OMX_U32 port_index = data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
             reply->writeInt32(freeBuffer(node, port_index, buffer));
 
  return NO_ERROR;
  }
 
  case FILL_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
             reply->writeInt32(fillBuffer(node, buffer));
 
  return NO_ERROR;
  }
 
  case EMPTY_BUFFER:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
             buffer_id buffer = (buffer_id)data.readInt32();
             OMX_U32 range_offset = data.readInt32();
             OMX_U32 range_length = data.readInt32();
             OMX_U32 flags = data.readInt32();
             OMX_TICKS timestamp = data.readInt64();
 
             reply->writeInt32(
                     emptyBuffer(
                         node, buffer, range_offset, range_length,
                         flags, timestamp));
 
  return NO_ERROR;
  }
 
  case GET_EXTENSION_INDEX:
  {
             CHECK_OMX_INTERFACE(IOMX, data, reply);
 
             node_id node = (node_id)data.readInt32();
  const char *parameter_name = data.readCString();
 
             OMX_INDEXTYPE index;
  status_t err = getExtensionIndex(node, parameter_name, &index);
 
             reply->writeInt32(err);
 
  if (err == OK) {
                 reply->writeInt32(index);
  }
 
  return OK;
  }
 
  default:
  return BBinder::onTransact(code, data, reply, flags);
  }
 }","[99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 142, 143, 144, 148, 149, 150, 97, 98, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 146, 147, 152, 153]","media/libmedia/IOMX.cpp in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a parameter data structure, which allows attackers to obtain sensitive information from process memory, and consequently bypass an unspecified protection mechanism, via unspecified vectors, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26914474."
201804," static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)
 {
   MagickBooleanType
     status;
 
   register const IndexPacket
     *indexes;
 
   register const PixelPacket
     *p;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *q;
 
   size_t
     depth,
     packet_size;
 
   ssize_t
     y;
 
   unsigned char
     *colormap,
     *pixels;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(image != (Image *) NULL);
   assert(image->signature == MagickSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
   if (status == MagickFalse)
     return(status);
   (void) TransformImageColorspace(image,sRGBColorspace);
    
   if (IsPaletteImage(image,&image->exception) == MagickFalse)
     (void) SetImageType(image,PaletteType);
   depth=GetImageQuantumDepth(image,MagickTrue);
   packet_size=(size_t) (depth/8);
   pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*
     sizeof(*pixels));
   packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);
   colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*
     sizeof(*colormap));
   if ((pixels == (unsigned char *) NULL) ||
       (colormap == (unsigned char *) NULL))
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    
    q=colormap;
  if (image->depth <= 8)
   q=colormap;
   if (image->colors <= 256)
      for (i=0; i < (ssize_t) image->colors; i++)
      {
      *q++=(unsigned char) image->colormap[i].red;
      *q++=(unsigned char) image->colormap[i].green;
      *q++=(unsigned char) image->colormap[i].blue;
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);
       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);
      }
    else
      for (i=0; i < (ssize_t) image->colors; i++)
      {
      *q++=(unsigned char) ((size_t) image->colormap[i].red >> 8);
      *q++=(unsigned char) image->colormap[i].red;
      *q++=(unsigned char) ((size_t) image->colormap[i].green >> 8);
      *q++=(unsigned char) image->colormap[i].green;
      *q++=(unsigned char) ((size_t) image->colormap[i].blue >> 8);
      *q++=(unsigned char) image->colormap[i].blue;
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);
       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);
      }
    (void) WriteBlob(image,packet_size*image->colors,colormap);
    colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
     if (p == (const PixelPacket *) NULL)
       break;
     indexes=GetVirtualIndexQueue(image);
     q=pixels;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       if (image->colors > 256)
         *q++=(unsigned char) ((size_t) GetPixelIndex(indexes+x) >> 8);
       *q++=(unsigned char) GetPixelIndex(indexes+x);
     }
     (void) WriteBlob(image,(size_t) (q-pixels),pixels);
   }
   pixels=(unsigned char *) RelinquishMagickMemory(pixels);
   (void) CloseBlob(image);
   return(status);
 }","[57, 58, 64, 65, 66, 77, 78, 79, 80, 81, 82, 56, 61, 62, 63, 71, 72, 73, 74, 75, 76]",Buffer overflow in the WriteGROUP4Image function in coders/tiff.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
199094," int ff_jpeg2000_init_component(Jpeg2000Component *comp,
                                Jpeg2000CodingStyle *codsty,
                                Jpeg2000QuantStyle *qntsty,
                                int cbps, int dx, int dy,
                                AVCodecContext *avctx)
 {
     uint8_t log2_band_prec_width, log2_band_prec_height;
     int reslevelno, bandno, gbandno = 0, ret, i, j;
     uint32_t csize;
 
     if (codsty->nreslevels2decode <= 0) {
         av_log(avctx, AV_LOG_ERROR, ""nreslevels2decode %d invalid or uninitialized\n"", codsty->nreslevels2decode);
         return AVERROR_INVALIDDATA;
     }
 
     if (ret = ff_jpeg2000_dwt_init(&comp->dwt, comp->coord,
                                    codsty->nreslevels2decode - 1,
                                    codsty->transform))
         return ret;
     csize = (comp->coord[0][1] - comp->coord[0][0]) *
             (comp->coord[1][1] - comp->coord[1][0]);
 
     if (codsty->transform == FF_DWT97) {
         comp->i_data = NULL;
         comp->f_data = av_malloc_array(csize, sizeof(*comp->f_data));
         if (!comp->f_data)
             return AVERROR(ENOMEM);
     } else {
         comp->f_data = NULL;
         comp->i_data = av_malloc_array(csize, sizeof(*comp->i_data));
         if (!comp->i_data)
             return AVERROR(ENOMEM);
     }
     comp->reslevel = av_malloc_array(codsty->nreslevels, sizeof(*comp->reslevel));
     if (!comp->reslevel)
         return AVERROR(ENOMEM);
      
     for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {
         int declvl = codsty->nreslevels - reslevelno;     
         Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;
 
          
         for (i = 0; i < 2; i++)
             for (j = 0; j < 2; j++)
                 reslevel->coord[i][j] =
                     ff_jpeg2000_ceildivpow2(comp->coord_o[i][j], declvl - 1);
         reslevel->log2_prec_width  = codsty->log2_prec_widths[reslevelno];
         reslevel->log2_prec_height = codsty->log2_prec_heights[reslevelno];
 
          
         if (reslevelno == 0)
             reslevel->nbands = 1;
         else
             reslevel->nbands = 3;
 
          
         if (reslevel->coord[0][1] == reslevel->coord[0][0])
             reslevel->num_precincts_x = 0;
         else
             reslevel->num_precincts_x =
                 ff_jpeg2000_ceildivpow2(reslevel->coord[0][1],
                                         reslevel->log2_prec_width) -
                 (reslevel->coord[0][0] >> reslevel->log2_prec_width);
 
         if (reslevel->coord[1][1] == reslevel->coord[1][0])
             reslevel->num_precincts_y = 0;
         else
             reslevel->num_precincts_y =
                 ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],
                                          reslevel->log2_prec_height) -
                  (reslevel->coord[1][0] >> reslevel->log2_prec_height);
  
        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));
         reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));
          if (!reslevel->band)
              return AVERROR(ENOMEM);
  
         for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {
             Jpeg2000Band *band = reslevel->band + bandno;
             int cblkno, precno;
             int nb_precincts;
 
              
             switch (qntsty->quantsty) {
                 uint8_t gain;
                 int numbps;
             case JPEG2000_QSTY_NONE:
                  
                 band->f_stepsize = 1;
                 break;
             case JPEG2000_QSTY_SI:
                  
                 numbps = cbps +
                          lut_gain[codsty->transform == FF_DWT53][bandno + (reslevelno > 0)];
                 band->f_stepsize = SHL(2048 + qntsty->mant[gbandno],
                                        2 + numbps - qntsty->expn[gbandno]);
                 break;
             case JPEG2000_QSTY_SE:
                  
                  
                 gain            = cbps;
                 band->f_stepsize  = pow(2.0, gain - qntsty->expn[gbandno]);
                 band->f_stepsize *= qntsty->mant[gbandno] / 2048.0 + 1.0;
                 break;
             default:
                 band->f_stepsize = 0;
                 av_log(avctx, AV_LOG_ERROR, ""Unknown quantization format\n"");
                 break;
             }
              
             if (!av_codec_is_encoder(avctx->codec))
                 band->f_stepsize *= 0.5;
 
             band->i_stepsize = band->f_stepsize * (1 << 15);
 
              
             if (reslevelno == 0) {
                  
                 for (i = 0; i < 2; i++)
                     for (j = 0; j < 2; j++)
                         band->coord[i][j] =
                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0],
                                                     declvl - 1);
                 log2_band_prec_width  = reslevel->log2_prec_width;
                 log2_band_prec_height = reslevel->log2_prec_height;
                  
                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,
                                                reslevel->log2_prec_width);
                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,
                                                reslevel->log2_prec_height);
             } else {
                  
                  
                 for (i = 0; i < 2; i++)
                     for (j = 0; j < 2; j++)
                          
                         band->coord[i][j] =
                             ff_jpeg2000_ceildivpow2(comp->coord_o[i][j] - comp->coord_o[i][0] -
                                                     (((bandno + 1 >> i) & 1) << declvl - 1),
                                                     declvl);
                  
 
                  
                 band->log2_cblk_width  = FFMIN(codsty->log2_cblk_width,
                                                reslevel->log2_prec_width - 1);
                 band->log2_cblk_height = FFMIN(codsty->log2_cblk_height,
                                                reslevel->log2_prec_height - 1);
 
                 log2_band_prec_width  = reslevel->log2_prec_width  - 1;
                 log2_band_prec_height = reslevel->log2_prec_height - 1;
             }
 
             for (j = 0; j < 2; j++)
                 band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);
              for (j = 0; j < 2; j++)
                  band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);
  
            band->prec = av_malloc_array(reslevel->num_precincts_x *
             band->prec = av_calloc(reslevel->num_precincts_x *
                                           (uint64_t)reslevel->num_precincts_y,
                                           sizeof(*band->prec));
              if (!band->prec)
                 return AVERROR(ENOMEM);
 
             nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;
 
             for (precno = 0; precno < nb_precincts; precno++) {
                 Jpeg2000Prec *prec = band->prec + precno;
 
                  
                  
 
                  
                 prec->coord[0][0] = (precno % reslevel->num_precincts_x) *
                                     (1 << log2_band_prec_width);
                 prec->coord[0][0] = FFMAX(prec->coord[0][0], band->coord[0][0]);
 
                  
                 prec->coord[1][0] = (precno / reslevel->num_precincts_x) *
                                     (1 << log2_band_prec_height);
                 prec->coord[1][0] = FFMAX(prec->coord[1][0], band->coord[1][0]);
 
                  
                 prec->coord[0][1] = prec->coord[0][0] +
                                     (1 << log2_band_prec_width);
                 prec->coord[0][1] = FFMIN(prec->coord[0][1], band->coord[0][1]);
 
                  
                 prec->coord[1][1] = prec->coord[1][0] +
                                     (1 << log2_band_prec_height);
                 prec->coord[1][1] = FFMIN(prec->coord[1][1], band->coord[1][1]);
 
                 prec->nb_codeblocks_width =
                     ff_jpeg2000_ceildivpow2(prec->coord[0][1] -
                                             prec->coord[0][0],
                                             band->log2_cblk_width);
                 prec->nb_codeblocks_height =
                     ff_jpeg2000_ceildivpow2(prec->coord[1][1] -
                                             prec->coord[1][0],
                                             band->log2_cblk_height);
 
                  
                 prec->cblkincl =
                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,
                                               prec->nb_codeblocks_height);
                 if (!prec->cblkincl)
                     return AVERROR(ENOMEM);
 
                 prec->zerobits =
                     ff_jpeg2000_tag_tree_init(prec->nb_codeblocks_width,
                                               prec->nb_codeblocks_height);
                 if (!prec->zerobits)
                     return AVERROR(ENOMEM);
 
                 prec->cblk = av_mallocz_array(prec->nb_codeblocks_width *
                                               (uint64_t)prec->nb_codeblocks_height,
                                               sizeof(*prec->cblk));
                 if (!prec->cblk)
                     return AVERROR(ENOMEM);
                 for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {
                     Jpeg2000Cblk *cblk = prec->cblk + cblkno;
                     uint16_t Cx0, Cy0;
 
                      
                      
                     Cx0 = (prec->coord[0][0] >> band->log2_cblk_width) << band->log2_cblk_width;
                     Cx0 = Cx0 + ((cblkno % prec->nb_codeblocks_width)  << band->log2_cblk_width);
                     cblk->coord[0][0] = FFMAX(Cx0, prec->coord[0][0]);
 
                      
                     Cy0 = (prec->coord[1][0] >> band->log2_cblk_height) << band->log2_cblk_height;
                     Cy0 = Cy0 + ((cblkno / prec->nb_codeblocks_width)   << band->log2_cblk_height);
                     cblk->coord[1][0] = FFMAX(Cy0, prec->coord[1][0]);
 
                      
                     cblk->coord[0][1] = FFMIN(Cx0 + (1 << band->log2_cblk_width),
                                               prec->coord[0][1]);
 
                      
                     cblk->coord[1][1] = FFMIN(Cy0 + (1 << band->log2_cblk_height),
                                               prec->coord[1][1]);
                      
                     if ((bandno + !!reslevelno) & 1) {
                         cblk->coord[0][0] += comp->reslevel[reslevelno-1].coord[0][1] -
                                              comp->reslevel[reslevelno-1].coord[0][0];
                         cblk->coord[0][1] += comp->reslevel[reslevelno-1].coord[0][1] -
                                              comp->reslevel[reslevelno-1].coord[0][0];
                     }
                     if ((bandno + !!reslevelno) & 2) {
                         cblk->coord[1][0] += comp->reslevel[reslevelno-1].coord[1][1] -
                                              comp->reslevel[reslevelno-1].coord[1][0];
                         cblk->coord[1][1] += comp->reslevel[reslevelno-1].coord[1][1] -
                                              comp->reslevel[reslevelno-1].coord[1][0];
                     }
 
                     cblk->zero      = 0;
                     cblk->lblock    = 3;
                     cblk->length    = 0;
                     cblk->lengthinc = 0;
                     cblk->npasses   = 0;
                 }
             }
         }
     }
     return 0;
 }","[74, 159, 73, 158]",libavcodec/jpeg2000.c in FFmpeg before 2.1 allows remote attackers to cause a denial of service (invalid pointer dereference) or possibly have unspecified other impact via crafted JPEG2000 data.
2720,"int linenoiseHistorySave(const char* filename) {
FILE* fp = fopen(filename, ""wt"");
if (fp == NULL) {
return -1;
}

for (int j = 0; j < historyLen; ++j) {
if (history[j][0] != '\0') {
fprintf(fp, ""%s\n"", history[j]);
}
}
fclose(fp);
return 0;
}","[2, 12]","The client in MongoDB uses world-readable permissions on .dbshell history files, which might allow local users to obtain sensitive information by reading these files."
8291,"void Compute(OpKernelContext* context) override {
const Tensor& prefix = context->input(0);
const Tensor& tensor_names = context->input(1);
const Tensor& shape_and_slices = context->input(2);
OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),
errors::InvalidArgument(""Got "", tensor_names.NumElements(),
"" tensor names, but "", dtypes_.size(),
"" expected dtypes.""));
ValidateInputs(false                  , context, prefix, tensor_names,
shape_and_slices);

const string& prefix_string = prefix.scalar<tstring>()();





Env* env = Env::Default();
std::vector<string> paths;
if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||
paths.empty()) {


for (size_t i = 0; i < tensor_names.NumElements(); ++i) {
RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,
-1,                     true,
i);
if (!context->status().ok()) {
return;
}
}
return;
}

OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,
shape_and_slices, dtypes_));
}",[12],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions the code for `tf.raw_ops.SaveV2` does not properly validate the inputs and an attacker can trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/8d72537c6abf5a44103b57b9c2e22c14f5f49698/tensorflow/core/kernels/save_restore_v2_ops.cc) uses `ValidateInputs` to check that the input arguments are valid. This validation would have caught the illegal state represented by the reproducer above. However, the validation uses `OP_REQUIRES` which translates to setting the `Status` object of the current `OpKernelContext` to an error status, followed by an empty `return` statement which just terminates the execution of the function it is present in. However, this does not mean that the kernel execution is finalized: instead, execution continues from the next line in `Compute` that follows the call to `ValidateInputs`. This is equivalent to lacking the validation. We have patched the issue in GitHub commit 9728c60e136912a12d99ca56e106b7cce7af5986. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
5943,"static struct scatterlist *alloc_sgtable(int size)
{
int alloc_size, nents, i;
struct page *new_page;
struct scatterlist *iter;
struct scatterlist *table;

nents = DIV_ROUND_UP(size, PAGE_SIZE);
table = kcalloc(nents, sizeof(*table), GFP_KERNEL);
if (!table)
return NULL;
sg_init_table(table, nents);
iter = table;
for_each_sg(table, iter, sg_nents(table), i) {
new_page = alloc_page(GFP_KERNEL);
if (!new_page) {

iter = table;
for_each_sg(table, iter, sg_nents(table), i) {
new_page = sg_page(iter);
if (new_page)
__free_page(new_page);
}
return NULL;
}
alloc_size = min_t(int, size, PAGE_SIZE);
size -= PAGE_SIZE;
sg_set_page(iter, new_page, alloc_size, 0);
}
return table;
}",[24],"A memory leak in the alloc_sgtable() function in drivers/net/wireless/intel/iwlwifi/fw/dbg.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering alloc_page() failures, aka CID-b4b814fec1a5."
197988," static void get_socket_name(SingleInstData* data, char* buf, int len)
 {
     const char* dpy = g_getenv(""DISPLAY"");
     char* host = NULL;
     int dpynum;
     if(dpy)
     {
         const char* p = strrchr(dpy, ':');
         host = g_strndup(dpy, (p - dpy));
         dpynum = atoi(p + 1);
      }
      else
          dpynum = 0;
 #if GLIB_CHECK_VERSION(2, 28, 0)
     g_snprintf(buf, len, ""%s/%s-socket-%s-%d"", g_get_user_runtime_dir(),
                data->prog_name, host ? host : """", dpynum);
 #else
      g_snprintf(buf, len, ""%s/.%s-socket-%s-%d-%s"",
                  g_get_tmp_dir(),
                  data->prog_name,
                  host ? host : """",
                  dpynum,
                  g_get_user_name());
 #endif
  }","[14, 15, 16, 17, 24]","PCManFM 1.2.5 insecurely uses /tmp for a socket file, allowing a local user to cause a denial of service (application unavailability)."
204678," void ExtensionSettingsHandler::GetLocalizedValues(
     DictionaryValue* localized_strings) {
   RegisterTitle(localized_strings, ""extensionSettings"",
                 IDS_MANAGE_EXTENSIONS_SETTING_WINDOWS_TITLE);
 
   localized_strings->SetString(""extensionSettingsVisitWebsite"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_VISIT_WEBSITE));
 
   localized_strings->SetString(""extensionSettingsDeveloperMode"",
     l10n_util::GetStringUTF16(IDS_EXTENSIONS_DEVELOPER_MODE_LINK));
   localized_strings->SetString(""extensionSettingsNoExtensions"",
     l10n_util::GetStringUTF16(IDS_EXTENSIONS_NONE_INSTALLED));
   localized_strings->SetString(""extensionSettingsSuggestGallery"",
       l10n_util::GetStringFUTF16(IDS_EXTENSIONS_NONE_INSTALLED_SUGGEST_GALLERY,
           ASCIIToUTF16(google_util::AppendGoogleLocaleParam(
               GURL(extension_urls::GetWebstoreLaunchURL())).spec())));
   localized_strings->SetString(""extensionSettingsGetMoreExtensions"",
       l10n_util::GetStringFUTF16(IDS_GET_MORE_EXTENSIONS,
           ASCIIToUTF16(google_util::AppendGoogleLocaleParam(
               GURL(extension_urls::GetWebstoreLaunchURL())).spec())));
   localized_strings->SetString(""extensionSettingsExtensionId"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_ID));
   localized_strings->SetString(""extensionSettingsExtensionPath"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_PATH));
   localized_strings->SetString(""extensionSettingsInspectViews"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_INSPECT_VIEWS));
   localized_strings->SetString(""viewIncognito"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_VIEW_INCOGNITO));
   localized_strings->SetString(""extensionSettingsEnable"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLE));
   localized_strings->SetString(""extensionSettingsEnabled"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLED));
   localized_strings->SetString(""extensionSettingsRemove"",
     l10n_util::GetStringUTF16(IDS_EXTENSIONS_REMOVE));
   localized_strings->SetString(""extensionSettingsEnableIncognito"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_ENABLE_INCOGNITO));
    localized_strings->SetString(""extensionSettingsAllowFileAccess"",
        l10n_util::GetStringUTF16(IDS_EXTENSIONS_ALLOW_FILE_ACCESS));
    localized_strings->SetString(""extensionSettingsIncognitoWarning"",
      l10n_util::GetStringFUTF16(IDS_EXTENSIONS_INCOGNITO_WARNING,
                                 l10n_util::GetStringUTF16(IDS_PRODUCT_NAME)));
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_INCOGNITO_WARNING));
    localized_strings->SetString(""extensionSettingsReload"",
        l10n_util::GetStringUTF16(IDS_EXTENSIONS_RELOAD));
    localized_strings->SetString(""extensionSettingsOptions"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_OPTIONS));
   localized_strings->SetString(""extensionSettingsPolicyControlled"",
      l10n_util::GetStringUTF16(IDS_EXTENSIONS_POLICY_CONTROLLED));
   localized_strings->SetString(""extensionSettingsShowButton"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_SHOW_BUTTON));
   localized_strings->SetString(""extensionSettingsLoadUnpackedButton"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_LOAD_UNPACKED_BUTTON));
   localized_strings->SetString(""extensionSettingsPackButton"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_PACK_BUTTON));
   localized_strings->SetString(""extensionSettingsUpdateButton"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_UPDATE_BUTTON));
   localized_strings->SetString(""extensionSettingsCrashMessage"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_CRASHED_EXTENSION));
   localized_strings->SetString(""extensionSettingsInDevelopment"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_IN_DEVELOPMENT));
   localized_strings->SetString(""extensionSettingsWarningsTitle"",
       l10n_util::GetStringUTF16(IDS_EXTENSION_WARNINGS_TITLE));
   localized_strings->SetString(""extensionSettingsShowDetails"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_SHOW_DETAILS));
   localized_strings->SetString(""extensionSettingsHideDetails"",
       l10n_util::GetStringUTF16(IDS_EXTENSIONS_HIDE_DETAILS));
 }","[42, 40, 41]","Skia, as used in Google Chrome before 19.0.1084.52, allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
3410,"static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters,
opj_image_t *image, opj_event_mgr_t *p_manager)
{

int i;


parameters->tile_size_on = OPJ_FALSE;
parameters->cp_tdx = 1;
parameters->cp_tdy = 1;


parameters->tp_flag = 'C';
parameters->tp_on = 1;


parameters->cp_tx0 = 0;
parameters->cp_ty0 = 0;
parameters->image_offset_x0 = 0;
parameters->image_offset_y0 = 0;


parameters->cblockw_init = 32;
parameters->cblockh_init = 32;


parameters->mode = 0;


parameters->roi_compno = -1;


parameters->subsampling_dx = 1;
parameters->subsampling_dy = 1;


parameters->irreversible = 1;


if (parameters->tcp_numlayers > 1) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""1 single quality layer""
""-> Number of layers forced to 1 (rather than %d)\n""
""-> Rate of the last layer (%3.1f) will be used"",
parameters->tcp_numlayers,
parameters->tcp_rates[parameters->tcp_numlayers - 1]);
parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers - 1];
parameters->tcp_numlayers = 1;
}


switch (parameters->rsiz) {
case OPJ_PROFILE_CINEMA_2K:
if (parameters->numresolution > 6) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 (2k dc profile) requires:\n""
""Number of decomposition levels <= 5\n""
""-> Number of decomposition levels forced to 5 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 6;
}
break;
case OPJ_PROFILE_CINEMA_4K:
if (parameters->numresolution < 2) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 1 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 1;
} else if (parameters->numresolution > 7) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-4 (4k dc profile) requires:\n""
""Number of decomposition levels >= 1 && <= 6\n""
""-> Number of decomposition levels forced to 6 (rather than %d)\n"",
parameters->numresolution + 1);
parameters->numresolution = 7;
}
break;
default :
break;
}


parameters->csty |= 0x01;
parameters->res_spec = parameters->numresolution - 1;
for (i = 0; i < parameters->res_spec; i++) {
parameters->prcw_init[i] = 256;
parameters->prch_init[i] = 256;
}


parameters->prog_order = OPJ_CPRL;


if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {
parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,
parameters->numresolution);
} else {
parameters->numpocs = 0;
}


parameters->cp_disto_alloc = 1;
if (parameters->max_cs_size <= 0) {

parameters->max_cs_size = OPJ_CINEMA_24_CS;
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1302083 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n"");
parameters->max_cs_size = OPJ_CINEMA_24_CS;
}

if (parameters->max_comp_size <= 0) {

parameters->max_comp_size = OPJ_CINEMA_24_COMP;
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""As no rate has been given, this limit will be used.\n"");
} else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {
opj_event_msg(p_manager, EVT_WARNING,
""JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n""
""Maximum 1041666 compressed bytes @ 24fps\n""
""-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n"");
parameters->max_comp_size = OPJ_CINEMA_24_COMP;
}

parameters->tcp_rates[0] = (OPJ_FLOAT32)(image->numcomps * image->comps[0].w *
image->comps[0].h * image->comps[0].prec) /
(OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx *
image->comps[0].dy);

}","[87, 88, 89, 90]","A mishandled zero case was discovered in opj_j2k_set_cinema_parameters in lib/openjp2/j2k.c in OpenJPEG 2.2.0. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service (heap-based buffer overflow affecting opj_write_bytes_LE in lib/openjp2/cio.c and opj_j2k_write_sot in lib/openjp2/j2k.c) or possibly remote code execution."
201231,"  static void make_response(struct xen_blkif_ring *ring, u64 id,
  			  unsigned short op, int st)
  {
	struct blkif_response  resp;
 	struct blkif_response *resp;
  	unsigned long     flags;
  	union blkif_back_rings *blk_rings;
  	int notify;
  
	resp.id        = id;
	resp.operation = op;
	resp.status    = st;
  	spin_lock_irqsave(&ring->blk_ring_lock, flags);
  	blk_rings = &ring->blk_rings;
  	 
  	switch (ring->blkif->blk_protocol) {
  	case BLKIF_PROTOCOL_NATIVE:
		memcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		resp = RING_GET_RESPONSE(&blk_rings->native,
 					 blk_rings->native.rsp_prod_pvt);
  		break;
  	case BLKIF_PROTOCOL_X86_32:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
 					 blk_rings->x86_32.rsp_prod_pvt);
  		break;
  	case BLKIF_PROTOCOL_X86_64:
		memcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),
		       &resp, sizeof(resp));
 		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
 					 blk_rings->x86_64.rsp_prod_pvt);
  		break;
  	default:
  		BUG();
  	}
 
 	resp->id        = id;
 	resp->operation = op;
 	resp->status    = st;
 
  	blk_rings->common.rsp_prod_pvt++;
  	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
  	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
 	if (notify)
 		notify_remote_via_irq(ring->irq);
 }","[5, 20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 4, 10, 11, 12, 18, 19, 24, 25, 30, 31]","The make_response function in drivers/block/xen-blkback/blkback.c in the Linux kernel before 4.11.8 allows guest OS users to obtain sensitive information from host OS (or other guest OS) kernel memory by leveraging the copying of uninitialized padding fields in Xen block-interface response structures, aka XSA-216."
204036,"  EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethod2(ExecState* exec)
  {
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      return JSValue::encode(JSTestObj::classMethod2(exec));
  }","[5, 4]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
199805,"  apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
        ap_input_mode_t mode, apr_read_type_e block, apr_off_t readbytes)
                             ap_input_mode_t mode, apr_read_type_e block,
                             apr_off_t readbytes)
  {
      core_server_config *conf;
      apr_bucket *e;
     http_ctx_t *ctx = f->ctx;
     apr_status_t rv;
     apr_off_t totalread;
     int again;
 
     conf = (core_server_config *)
         ap_get_module_config(f->r->server->module_config, &core_module);
 
      
     if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {
         return ap_get_brigade(f->next, b, mode, block, readbytes);
     }
 
     if (!ctx) {
         const char *tenc, *lenp;
         f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));
         ctx->state = BODY_NONE;
 
          
         if (!f->r->proxyreq) {
             ctx->limit = ap_get_limit_req_body(f->r);
         }
         else {
             ctx->limit = 0;
         }
 
         tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");
         lenp = apr_table_get(f->r->headers_in, ""Content-Length"");
 
         if (tenc) {
             if (strcasecmp(tenc, ""chunked"") == 0  
                     || ap_find_last_token(f->r->pool, tenc, ""chunked"")) {
                 ctx->state = BODY_CHUNK;
             }
             else if (f->r->proxyreq == PROXYREQ_RESPONSE) {
                  
                  ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)
                              ""Unknown Transfer-Encoding: %s;""
                              "" using read-until-close"", tenc);
                               ""Unknown Transfer-Encoding: %s; ""
                               ""using read-until-close"", tenc);
                  tenc = NULL;
              }
              else {
                  
                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)
                               ""Unknown Transfer-Encoding: %s"", tenc);
                 return APR_EGENERAL;
             }
             lenp = NULL;
         }
         if (lenp) {
             char *endstr;
 
             ctx->state = BODY_LENGTH;
 
              
             if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)
                      || endstr == lenp || *endstr || ctx->remaining < 0) {
  
                  ctx->remaining = 0;
                ap_log_rerror(
                        APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)
                        ""Invalid Content-Length"");
                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)
                               ""Invalid Content-Length"");
  
                return APR_ENOSPC;
                 return APR_EINVAL;
              }
  
               
              if (ctx->limit && ctx->limit < ctx->remaining) {
                ap_log_rerror(
                        APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)
                        ""Requested content-length of %"" APR_OFF_T_FMT
                        "" is larger than the configured limit""
                        "" of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)
                           ""Requested content-length of %"" APR_OFF_T_FMT
                           "" is larger than the configured limit""
                           "" of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
                  return APR_ENOSPC;
              }
          }
 
          
         if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {
             e = apr_bucket_eos_create(f->c->bucket_alloc);
             APR_BRIGADE_INSERT_TAIL(b, e);
             ctx->eos_sent = 1;
             return APR_SUCCESS;
         }
 
          
         if ((ctx->state == BODY_CHUNK
                 || (ctx->state == BODY_LENGTH && ctx->remaining > 0))
                 && f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)
                 && !(f->r->eos_sent || f->r->bytes_sent)) {
             if (!ap_is_HTTP_SUCCESS(f->r->status)) {
                 ctx->state = BODY_NONE;
                 ctx->eos_sent = 1;
             }
             else {
                 char *tmp;
                 int len;
                 apr_bucket_brigade *bb;
 
                 bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);
 
                  
                 f->r->expecting_100 = 0;
                 tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL "" "",
                         ap_get_status_line(HTTP_CONTINUE), CRLF CRLF, NULL);
                 len = strlen(tmp);
                 ap_xlate_proto_to_ascii(tmp, len);
                 e = apr_bucket_pool_create(tmp, len, f->r->pool,
                         f->c->bucket_alloc);
                 APR_BRIGADE_INSERT_HEAD(bb, e);
                 e = apr_bucket_flush_create(f->c->bucket_alloc);
                  APR_BRIGADE_INSERT_TAIL(bb, e);
  
                  rv = ap_pass_brigade(f->c->output_filters, bb);
                 apr_brigade_cleanup(bb);
                  if (rv != APR_SUCCESS) {
                      return AP_FILTER_ERROR;
                  }
             }
         }
     }
 
      
     if (ctx->eos_sent) {
         e = apr_bucket_eos_create(f->c->bucket_alloc);
         APR_BRIGADE_INSERT_TAIL(b, e);
         return APR_SUCCESS;
     }
 
     do {
         apr_brigade_cleanup(b);
         again = 0;  
 
          
         switch (ctx->state) {
          case BODY_CHUNK:
          case BODY_CHUNK_PART:
          case BODY_CHUNK_EXT:
        case BODY_CHUNK_END: {
         case BODY_CHUNK_LF:
         case BODY_CHUNK_END:
         case BODY_CHUNK_END_LF: {
  
              rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);
  
              
             if (block == APR_NONBLOCK_READ
                     && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                             || (APR_STATUS_IS_EAGAIN(rv)))) {
                 return APR_EAGAIN;
             }
 
             if (rv == APR_EOF) {
                 return APR_INCOMPLETE;
             }
 
             if (rv != APR_SUCCESS) {
                 return rv;
             }
 
             e = APR_BRIGADE_FIRST(b);
             while (e != APR_BRIGADE_SENTINEL(b)) {
                 const char *buffer;
                 apr_size_t len;
 
                 if (!APR_BUCKET_IS_METADATA(e)) {
                     rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);
 
                     if (rv == APR_SUCCESS) {
                         rv = parse_chunk_size(ctx, buffer, len,
                                  f->r->server->limit_req_fieldsize);
                      }
                      if (rv != APR_SUCCESS) {
                        ap_log_rerror(
                                APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590) ""Error reading chunk %s "", (APR_ENOSPC == rv) ? ""(overflow)"" : """");
                         ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)
                                       ""Error reading chunk %s "",
                                       (APR_ENOSPC == rv) ? ""(overflow)"" : """");
                          return rv;
                      }
                  }
 
                 apr_bucket_delete(e);
                 e = APR_BRIGADE_FIRST(b);
             }
             again = 1;  
  
              if (ctx->state == BODY_CHUNK_TRAILER) {
                   
                int merge_trailers =
                    conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE;
                return read_chunked_trailers(ctx, f, b, merge_trailers);
                 return read_chunked_trailers(ctx, f, b,
                             conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE);
              }
  
              break;
         }
         case BODY_NONE:
         case BODY_LENGTH:
         case BODY_CHUNK_DATA: {
 
              
             if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {
                 readbytes = ctx->remaining;
             }
             if (readbytes > 0) {
 
                 rv = ap_get_brigade(f->next, b, mode, block, readbytes);
 
                  
                 if (block == APR_NONBLOCK_READ
                         && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                                 || (APR_STATUS_IS_EAGAIN(rv)))) {
                     return APR_EAGAIN;
                 }
 
                 if (rv == APR_EOF && ctx->state != BODY_NONE
                         && ctx->remaining > 0) {
                     return APR_INCOMPLETE;
                 }
 
                 if (rv != APR_SUCCESS) {
                     return rv;
                 }
 
                  
                 apr_brigade_length(b, 0, &totalread);
 
                  
                 AP_DEBUG_ASSERT(totalread >= 0);
 
                 if (ctx->state != BODY_NONE) {
                     ctx->remaining -= totalread;
                     if (ctx->remaining > 0) {
                         e = APR_BRIGADE_LAST(b);
                         if (APR_BUCKET_IS_EOS(e)) {
                             apr_bucket_delete(e);
                             return APR_INCOMPLETE;
                         }
                     }
                     else if (ctx->state == BODY_CHUNK_DATA) {
                          
                         ctx->state = BODY_CHUNK_END;
                         ctx->chunk_used = 0;
                     }
                 }
 
             }
 
              
             if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {
                 e = apr_bucket_eos_create(f->c->bucket_alloc);
                 APR_BRIGADE_INSERT_TAIL(b, e);
                 ctx->eos_sent = 1;
             }
 
              
             if (ctx->limit) {
                  
                  ctx->limit_used += totalread;
                  if (ctx->limit < ctx->limit_used) {
                    ap_log_rerror(
                            APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591) ""Read content-length of %"" APR_OFF_T_FMT "" is larger than the configured limit""
                            "" of %"" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
                     ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591)
                                   ""Read content-length of %"" APR_OFF_T_FMT
                                   "" is larger than the configured limit""
                                   "" of %"" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
                      return APR_ENOSPC;
                  }
              }
 
             break;
         }
         case BODY_CHUNK_TRAILER: {
 
             rv = ap_get_brigade(f->next, b, mode, block, readbytes);
 
              
             if (block == APR_NONBLOCK_READ
                     && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                             || (APR_STATUS_IS_EAGAIN(rv)))) {
                 return APR_EAGAIN;
             }
 
             if (rv != APR_SUCCESS) {
                 return rv;
             }
 
              break;
          }
          default: {
            break;
              
             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(02901)
                           ""Unexpected body state (%i)"", (int)ctx->state);
             return APR_EGENERAL;
          }
          }
  
     } while (again);
 
     return APR_SUCCESS;
 }","[3, 4, 47, 48, 72, 73, 76, 86, 87, 88, 89, 131, 156, 157, 158, 192, 193, 194, 209, 210, 282, 283, 284, 285, 311, 312, 313, 314, 2, 45, 46, 69, 70, 71, 75, 81, 82, 83, 84, 85, 155, 190, 191, 206, 207, 208, 279, 280, 281, 310]","The chunked transfer coding implementation in the Apache HTTP Server before 2.4.14 does not properly parse chunk headers, which allows remote attackers to conduct HTTP request smuggling attacks via a crafted request, related to mishandling of large chunk-size values and invalid chunk-extension characters in modules/http/http_filters.c."
198103," static void ssh_throttle_all(Ssh ssh, int enable, int bufsize)
 {
     int i;
     struct ssh_channel *c;
 
     if (enable == ssh->throttled_all)
 	return;
     ssh->throttled_all = enable;
     ssh->overall_bufsize = bufsize;
     if (!ssh->channels)
 	return;
     for (i = 0; NULL != (c = index234(ssh->channels, i)); i++) {
 	switch (c->type) {
 	  case CHAN_MAINSESSION:
 	     
 	    break;
             x11_override_throttle(c->u.x11.xconn, enable);
             break;
           case CHAN_AGENT:
             
             if (!enable)
                 ssh_agentf_try_forward(c);
             break;
           case CHAN_SOCKDATA:
             pfd_override_throttle(c->u.pfd.pf, enable);
 
 static void ssh_agent_callback(void *sshv, void *reply, int replylen)
 {
     Ssh ssh = (Ssh) sshv;
 
     ssh->auth_agent_query = NULL;
 
     ssh->agent_response = reply;
     ssh->agent_response_len = replylen;
 
     if (ssh->version == 1)
 	do_ssh1_login(ssh, NULL, -1, NULL);
     else
 	do_ssh2_authconn(ssh, NULL, -1, NULL);
 }
 
 static void ssh_dialog_callback(void *sshv, int ret)
 {
     Ssh ssh = (Ssh) sshv;
 
     ssh->user_response = ret;
 
     if (ssh->version == 1)
 	do_ssh1_login(ssh, NULL, -1, NULL);
     else
 	do_ssh2_transport(ssh, NULL, -1, NULL);
 
      
     ssh_process_queued_incoming_data(ssh);
 }
 
 static void ssh_agentf_callback(void *cv, void *reply, int replylen)
      ssh_process_queued_incoming_data(ssh);
  }
  
static void ssh_agentf_callback(void *cv, void *reply, int replylen)
 static void ssh_agentf_got_response(struct ssh_channel *c,
                                     void *reply, int replylen)
  {
    struct ssh_channel *c = (struct ssh_channel *)cv;
    const void *sentreply = reply;
      c->u.a.pending = NULL;
    c->u.a.outstanding_requests--;
    if (!sentreply) {
 
     if (!reply) {
         
       sentreply = ""\0\0\0\1\5"";
        reply = ""\0\0\0\1\5"";
         replylen = 5;
      }
    ssh_send_channel_data(c, sentreply, replylen);
    if (reply)
       sfree(reply);
 
     ssh_send_channel_data(c, reply, replylen);
 }
 
 static void ssh_agentf_callback(void *cv, void *reply, int replylen);
 
 static void ssh_agentf_try_forward(struct ssh_channel *c)
 {
     unsigned datalen, lengthfield, messagelen;
     unsigned char *message;
     unsigned char msglen[4];
     void *reply;
     int replylen;
 
       
    if (c->u.a.outstanding_requests == 0 && (c->closes & CLOSES_RCVD_EOF))
     if (c->u.a.pending)
         return;
 
      
     if (c->ssh->throttled_all ||
         (c->ssh->version == 2 && c->v.v2.remwindow == 0))
         return;
 
     while (1) {
          
         datalen = bufchain_size(&c->u.a.inbuffer);
         if (datalen < 4)
             break;          
 
         bufchain_fetch(&c->u.a.inbuffer, msglen, 4);
         lengthfield = GET_32BIT(msglen);
         if (lengthfield > datalen - 4)
             break;           
 
         messagelen = lengthfield + 4;
 
         message = snewn(messagelen, unsigned char);
         bufchain_fetch(&c->u.a.inbuffer, message, messagelen);
         bufchain_consume(&c->u.a.inbuffer, messagelen);
         c->u.a.pending = agent_query(
             message, messagelen, &reply, &replylen, ssh_agentf_callback, c);
         sfree(message);
 
         if (c->u.a.pending)
             return;    
 
          
         ssh_agentf_got_response(c, reply, replylen);
     }
 
      
     if (c->closes & CLOSES_RCVD_EOF)
          sshfwd_write_eof(c);
  }
  
 static void ssh_agentf_callback(void *cv, void *reply, int replylen)
 {
     struct ssh_channel *c = (struct ssh_channel *)cv;
 
     ssh_agentf_got_response(c, reply, replylen);
     sfree(reply);
 
      
     ssh_agentf_try_forward(c);
 }
 
   
     {
 	char logmsg[80];
 	logevent(""Host key fingerprint is:"");
 	strcpy(logmsg, ""      "");
 	s->hostkey.comment = NULL;
 	rsa_fingerprint(logmsg + strlen(logmsg),
 			sizeof(logmsg) - strlen(logmsg), &s->hostkey);
 	logevent(logmsg);
     }
 
     ssh->v1_remote_protoflags = ssh_pkt_getuint32(pktin);
     s->supported_ciphers_mask = ssh_pkt_getuint32(pktin);
     s->supported_auths_mask = ssh_pkt_getuint32(pktin);
     if ((ssh->remote_bugs & BUG_CHOKES_ON_RSA))
 	s->supported_auths_mask &= ~(1 << SSH1_AUTH_RSA);
 
     ssh->v1_local_protoflags =
 	ssh->v1_remote_protoflags & SSH1_PROTOFLAGS_SUPPORTED;
     ssh->v1_local_protoflags |= SSH1_PROTOFLAG_SCREEN_NUMBER;
 
     MD5Init(&md5c);
     MD5Update(&md5c, s->keystr2, s->hostkey.bytes);
     MD5Update(&md5c, s->keystr1, s->servkey.bytes);
     MD5Update(&md5c, cookie, 8);
     MD5Final(s->session_id, &md5c);
 
     for (i = 0; i < 32; i++)
 	ssh->session_key[i] = random_byte();
 
      
     if (s->hostkey.bits > s->hostkey.bytes * 8 ||
 	s->servkey.bits > s->servkey.bytes * 8) {
 	bombout((""SSH-1 public keys were badly formatted""));
 	crStop(0);
     }
 
     s->len = (s->hostkey.bytes > s->servkey.bytes ?
               s->hostkey.bytes : s->servkey.bytes);
 
     s->rsabuf = snewn(s->len, unsigned char);
 
      
     {
 	 
 	int len = rsastr_len(&s->hostkey);
 	char fingerprint[100];
 	char *keystr = snewn(len, char);
 	rsastr_fmt(keystr, &s->hostkey);
 	rsa_fingerprint(fingerprint, sizeof(fingerprint), &s->hostkey);
 
          
         s->dlgret = verify_ssh_manual_host_key(ssh, fingerprint, NULL, NULL);
         if (s->dlgret == 0) {           
             bombout((""Host key did not appear in manually configured list""));
             sfree(keystr);
             crStop(0);
         } else if (s->dlgret < 0) {  
             ssh_set_frozen(ssh, 1);
             s->dlgret = verify_ssh_host_key(ssh->frontend,
                                             ssh->savedhost, ssh->savedport,
                                             ""rsa"", keystr, fingerprint,
                                             ssh_dialog_callback, ssh);
             sfree(keystr);
 #ifdef FUZZING
 	    s->dlgret = 1;
 #endif
             if (s->dlgret < 0) {
                 do {
                     crReturn(0);
                     if (pktin) {
                         bombout((""Unexpected data from server while waiting""
                                  "" for user host key response""));
                         crStop(0);
                     }
                 } while (pktin || inlen > 0);
                 s->dlgret = ssh->user_response;
             }
             ssh_set_frozen(ssh, 0);
 
             if (s->dlgret == 0) {
                 ssh_disconnect(ssh, ""User aborted at host key verification"",
                                NULL, 0, TRUE);
                 crStop(0);
             }
         } else {
             sfree(keystr);
         }
     }
 
     for (i = 0; i < 32; i++) {
 	s->rsabuf[i] = ssh->session_key[i];
 	if (i < 16)
 	    s->rsabuf[i] ^= s->session_id[i];
     }
 
     if (s->hostkey.bytes > s->servkey.bytes) {
 	ret = rsaencrypt(s->rsabuf, 32, &s->servkey);
 	if (ret)
 	    ret = rsaencrypt(s->rsabuf, s->servkey.bytes, &s->hostkey);
     } else {
 	ret = rsaencrypt(s->rsabuf, 32, &s->hostkey);
 	if (ret)
 	    ret = rsaencrypt(s->rsabuf, s->hostkey.bytes, &s->servkey);
     }
     if (!ret) {
 	bombout((""SSH-1 public key encryptions failed due to bad formatting""));
 	crStop(0);	
     }
 
     logevent(""Encrypted session key"");
 
     {
 	int cipher_chosen = 0, warn = 0;
 	const char *cipher_string = NULL;
 	int i;
 	for (i = 0; !cipher_chosen && i < CIPHER_MAX; i++) {
 	    int next_cipher = conf_get_int_int(ssh->conf,
 					       CONF_ssh_cipherlist, i);
 	    if (next_cipher == CIPHER_WARN) {
 		 
 		warn = 1;
 	    } else if (next_cipher == CIPHER_AES) {
 		 
 		logevent(""AES not supported in SSH-1, skipping"");
 	    } else {
 		switch (next_cipher) {
 		  case CIPHER_3DES:     s->cipher_type = SSH_CIPHER_3DES;
 					cipher_string = ""3DES""; break;
 		  case CIPHER_BLOWFISH: s->cipher_type = SSH_CIPHER_BLOWFISH;
 					cipher_string = ""Blowfish""; break;
 		  case CIPHER_DES:	s->cipher_type = SSH_CIPHER_DES;
 					cipher_string = ""single-DES""; break;
 		}
 		if (s->supported_ciphers_mask & (1 << s->cipher_type))
 		    cipher_chosen = 1;
 	    }
 	}
 	if (!cipher_chosen) {
 	    if ((s->supported_ciphers_mask & (1 << SSH_CIPHER_3DES)) == 0)
 		bombout((""Server violates SSH-1 protocol by not ""
 			 ""supporting 3DES encryption""));
 	    else
 		 
 		bombout((""No supported ciphers found""));
 	    crStop(0);
 	}
 
 	 
 	if (warn) {
             ssh_set_frozen(ssh, 1);
 	    s->dlgret = askalg(ssh->frontend, ""cipher"", cipher_string,
 			       ssh_dialog_callback, ssh);
 	    if (s->dlgret < 0) {
 		do {
 		    crReturn(0);
 		    if (pktin) {
 			bombout((""Unexpected data from server while waiting""
 				 "" for user response""));
 			crStop(0);
 		    }
 		} while (pktin || inlen > 0);
 		s->dlgret = ssh->user_response;
 	    }
             ssh_set_frozen(ssh, 0);
 	    if (s->dlgret == 0) {
 		ssh_disconnect(ssh, ""User aborted at cipher warning"", NULL,
 			       0, TRUE);
 		crStop(0);
 	    }
         }
     }
 
     switch (s->cipher_type) {
       case SSH_CIPHER_3DES:
 	logevent(""Using 3DES encryption"");
 	break;
       case SSH_CIPHER_DES:
 	logevent(""Using single-DES encryption"");
 	break;
       case SSH_CIPHER_BLOWFISH:
 	logevent(""Using Blowfish encryption"");
 	break;
     }
 
     send_packet(ssh, SSH1_CMSG_SESSION_KEY,
 		PKT_CHAR, s->cipher_type,
 		PKT_DATA, cookie, 8,
 		PKT_CHAR, (s->len * 8) >> 8, PKT_CHAR, (s->len * 8) & 0xFF,
 		PKT_DATA, s->rsabuf, s->len,
 		PKT_INT, ssh->v1_local_protoflags, PKT_END);
 
     logevent(""Trying to enable encryption..."");
 
     sfree(s->rsabuf);
 
     ssh->cipher = (s->cipher_type == SSH_CIPHER_BLOWFISH ? &ssh_blowfish_ssh1 :
 		   s->cipher_type == SSH_CIPHER_DES ? &ssh_des :
 		   &ssh_3des);
     ssh->v1_cipher_ctx = ssh->cipher->make_context();
     ssh->cipher->sesskey(ssh->v1_cipher_ctx, ssh->session_key);
     logeventf(ssh, ""Initialised %s encryption"", ssh->cipher->text_name);
 
     ssh->crcda_ctx = crcda_make_context();
     logevent(""Installing CRC compensation attack detector"");
 
     if (s->servkey.modulus) {
 	sfree(s->servkey.modulus);
 	s->servkey.modulus = NULL;
     }
     if (s->servkey.exponent) {
 	sfree(s->servkey.exponent);
 	s->servkey.exponent = NULL;
     }
     if (s->hostkey.modulus) {
 	sfree(s->hostkey.modulus);
 	s->hostkey.modulus = NULL;
     }
     if (s->hostkey.exponent) {
 	sfree(s->hostkey.exponent);
 	s->hostkey.exponent = NULL;
     }
     crWaitUntil(pktin);
 
     if (pktin->type != SSH1_SMSG_SUCCESS) {
 	bombout((""Encryption not successfully enabled""));
 	crStop(0);
     }
 
     logevent(""Successfully started encryption"");
 
     fflush(stdout);  
     {
 	if ((ssh->username = get_remote_username(ssh->conf)) == NULL) {
 	    int ret;  
 	    s->cur_prompt = new_prompts(ssh->frontend);
 	    s->cur_prompt->to_server = TRUE;
 	    s->cur_prompt->name = dupstr(""SSH login name"");
 	    add_prompt(s->cur_prompt, dupstr(""login as: ""), TRUE);
 	    ret = get_userpass_input(s->cur_prompt, NULL, 0);
 	    while (ret < 0) {
 		ssh->send_ok = 1;
 		crWaitUntil(!pktin);
 		ret = get_userpass_input(s->cur_prompt, in, inlen);
 		ssh->send_ok = 0;
 	    }
 	    if (!ret) {
 		 
 		free_prompts(s->cur_prompt);
 		ssh_disconnect(ssh, ""No username provided"", NULL, 0, TRUE);
 		crStop(0);
 	    }
 	    ssh->username = dupstr(s->cur_prompt->prompts[0]->result);
 	    free_prompts(s->cur_prompt);
 	}
 
 	send_packet(ssh, SSH1_CMSG_USER, PKT_STR, ssh->username, PKT_END);
 	{
 	    char *userlog = dupprintf(""Sent username \""%s\"""", ssh->username);
 	    logevent(userlog);
 	    if (flags & FLAG_INTERACTIVE &&
 		(!((flags & FLAG_STDERR) && (flags & FLAG_VERBOSE)))) {
 		c_write_str(ssh, userlog);
 		c_write_str(ssh, ""\r\n"");
 	    }
 	    sfree(userlog);
 	}
     }
 
     crWaitUntil(pktin);
 
     if ((s->supported_auths_mask & (1 << SSH1_AUTH_RSA)) == 0) {
 	 
 	s->tried_publickey = s->tried_agent = 1;
     } else {
 	s->tried_publickey = s->tried_agent = 0;
     }
     s->tis_auth_refused = s->ccard_auth_refused = 0;
      
     s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);
     if (!filename_is_null(s->keyfile)) {
 	int keytype;
 	logeventf(ssh, ""Reading key file \""%.150s\"""",
 		  filename_to_str(s->keyfile));
 	keytype = key_type(s->keyfile);
 	if (keytype == SSH_KEYTYPE_SSH1 ||
             keytype == SSH_KEYTYPE_SSH1_PUBLIC) {
 	    const char *error;
 	    if (rsakey_pubblob(s->keyfile,
 			       &s->publickey_blob, &s->publickey_bloblen,
 			       &s->publickey_comment, &error)) {
                 s->privatekey_available = (keytype == SSH_KEYTYPE_SSH1);
                 if (!s->privatekey_available)
                     logeventf(ssh, ""Key file contains public key only"");
 		s->privatekey_encrypted = rsakey_encrypted(s->keyfile,
                                                            NULL);
 	    } else {
 		char *msgbuf;
 		logeventf(ssh, ""Unable to load key (%s)"", error);
 		msgbuf = dupprintf(""Unable to load key file ""
 				   ""\""%.150s\"" (%s)\r\n"",
 				   filename_to_str(s->keyfile),
 				   error);
 		c_write_str(ssh, msgbuf);
 		sfree(msgbuf);
 		s->publickey_blob = NULL;
 	    }
 	} else {
 	    char *msgbuf;
 	    logeventf(ssh, ""Unable to use this key file (%s)"",
 		      key_type_to_str(keytype));
 	    msgbuf = dupprintf(""Unable to use key file \""%.150s\""""
 			       "" (%s)\r\n"",
 			       filename_to_str(s->keyfile),
 			       key_type_to_str(keytype));
 	    c_write_str(ssh, msgbuf);
 	    sfree(msgbuf);
 	    s->publickey_blob = NULL;
 	}
     } else
 	s->publickey_blob = NULL;
 
     while (pktin->type == SSH1_SMSG_FAILURE) {
 	s->pwpkt_type = SSH1_CMSG_AUTH_PASSWORD;
 
 	if (conf_get_int(ssh->conf, CONF_tryagent) && agent_exists() && !s->tried_agent) {
 	     
 	    void *r;
 
 	    s->authed = FALSE;
 	    s->tried_agent = 1;
 	    logevent(""Pageant is running. Requesting keys."");
 
 	     
 	    PUT_32BIT(s->request, 1);
 	    s->request[4] = SSH1_AGENTC_REQUEST_RSA_IDENTITIES;
             ssh->auth_agent_query = agent_query(
                 s->request, 5, &r, &s->responselen, ssh_agent_callback, ssh);
 	    if (ssh->auth_agent_query) {
 		do {
 		    crReturn(0);
 		    if (pktin) {
 			bombout((""Unexpected data from server while waiting""
 				 "" for agent response""));
 			crStop(0);
 		    }
 		} while (pktin || inlen > 0);
 		r = ssh->agent_response;
 		s->responselen = ssh->agent_response_len;
 	    }
 	    s->response = (unsigned char *) r;
 	    if (s->response && s->responselen >= 5 &&
 		s->response[4] == SSH1_AGENT_RSA_IDENTITIES_ANSWER) {
 		s->p = s->response + 5;
 		s->nkeys = toint(GET_32BIT(s->p));
                 if (s->nkeys < 0) {
                     logeventf(ssh, ""Pageant reported negative key count %d"",
                               s->nkeys);
                     s->nkeys = 0;
                 }
 		s->p += 4;
 		logeventf(ssh, ""Pageant has %d SSH-1 keys"", s->nkeys);
 		for (s->keyi = 0; s->keyi < s->nkeys; s->keyi++) {
 		    unsigned char *pkblob = s->p;
 		    s->p += 4;
 		    {
 			int n, ok = FALSE;
 			do {	        
 			    n = ssh1_read_bignum
 				(s->p, toint(s->responselen-(s->p-s->response)),
 				 &s->key.exponent);
 			    if (n < 0)
 				break;
 			    s->p += n;
 			    n = ssh1_read_bignum
 				(s->p, toint(s->responselen-(s->p-s->response)),
 				 &s->key.modulus);
 			    if (n < 0)
                                 break;
 			    s->p += n;
 			    if (s->responselen - (s->p-s->response) < 4)
 				break;
 			    s->commentlen = toint(GET_32BIT(s->p));
 			    s->p += 4;
 			    if (s->commentlen < 0 ||
                                 toint(s->responselen - (s->p-s->response)) <
 				s->commentlen)
 				break;
 			    s->commentp = (char *)s->p;
 			    s->p += s->commentlen;
 			    ok = TRUE;
 			} while (0);
 			if (!ok) {
 			    logevent(""Pageant key list packet was truncated"");
 			    break;
 			}
 		    }
 		    if (s->publickey_blob) {
 			if (!memcmp(pkblob, s->publickey_blob,
 				    s->publickey_bloblen)) {
 			    logeventf(ssh, ""Pageant key #%d matches ""
 				      ""configured key file"", s->keyi);
 			    s->tried_publickey = 1;
 			} else
 			     
 			    continue;
 		    }
 		    logeventf(ssh, ""Trying Pageant key #%d"", s->keyi);
 		    send_packet(ssh, SSH1_CMSG_AUTH_RSA,
 				PKT_BIGNUM, s->key.modulus, PKT_END);
 		    crWaitUntil(pktin);
 		    if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {
 			logevent(""Key refused"");
 			continue;
 		    }
 		    logevent(""Received RSA challenge"");
 		    if ((s->challenge = ssh1_pkt_getmp(pktin)) == NULL) {
 			bombout((""Server's RSA challenge was badly formatted""));
 			crStop(0);
 		    }
 
 		    {
 			char *agentreq, *q, *ret;
 			void *vret;
 			int len, retlen;
 			len = 1 + 4;    
 			len += ssh1_bignum_length(s->key.exponent);
 			len += ssh1_bignum_length(s->key.modulus);
 			len += ssh1_bignum_length(s->challenge);
 			len += 16;      
 			len += 4;       
 			agentreq = snewn(4 + len, char);
 			PUT_32BIT(agentreq, len);
 			q = agentreq + 4;
 			*q++ = SSH1_AGENTC_RSA_CHALLENGE;
 			PUT_32BIT(q, bignum_bitcount(s->key.modulus));
 			q += 4;
 			q += ssh1_write_bignum(q, s->key.exponent);
 			q += ssh1_write_bignum(q, s->key.modulus);
 			q += ssh1_write_bignum(q, s->challenge);
 			memcpy(q, s->session_id, 16);
 			q += 16;
 			PUT_32BIT(q, 1);	 
                         ssh->auth_agent_query = agent_query(
                             agentreq, len + 4, &vret, &retlen,
                             ssh_agent_callback, ssh);
 			if (ssh->auth_agent_query) {
 			    sfree(agentreq);
 			    do {
 				crReturn(0);
 				if (pktin) {
 				    bombout((""Unexpected data from server""
 					     "" while waiting for agent""
 					     "" response""));
 				    crStop(0);
 				}
 			    } while (pktin || inlen > 0);
 			    vret = ssh->agent_response;
 			    retlen = ssh->agent_response_len;
 			} else
 			    sfree(agentreq);
 			ret = vret;
 			if (ret) {
 			    if (ret[4] == SSH1_AGENT_RSA_RESPONSE) {
 				logevent(""Sending Pageant's response"");
 				send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,
 					    PKT_DATA, ret + 5, 16,
 					    PKT_END);
 				sfree(ret);
 				crWaitUntil(pktin);
 				if (pktin->type == SSH1_SMSG_SUCCESS) {
 				    logevent
 					(""Pageant's response accepted"");
 				    if (flags & FLAG_VERBOSE) {
 					c_write_str(ssh, ""Authenticated using""
 						    "" RSA key \"""");
 					c_write(ssh, s->commentp,
 						s->commentlen);
 					c_write_str(ssh, ""\"" from agent\r\n"");
 				    }
 				    s->authed = TRUE;
 				} else
 				    logevent
 					(""Pageant's response not accepted"");
 			    } else {
 				logevent
 				    (""Pageant failed to answer challenge"");
 				sfree(ret);
 			    }
 			} else {
 			    logevent(""No reply received from Pageant"");
 			}
 		    }
 		    freebn(s->key.exponent);
 		    freebn(s->key.modulus);
 		    freebn(s->challenge);
 		    if (s->authed)
 			break;
 		}
 		sfree(s->response);
 		if (s->publickey_blob && !s->tried_publickey)
 		    logevent(""Configured key file not in Pageant"");
 	    } else {
                 logevent(""Failed to get reply from Pageant"");
             }
 	    if (s->authed)
 		break;
 	}
 	if (s->publickey_blob && s->privatekey_available &&
             !s->tried_publickey) {
 	     
 	    int got_passphrase;  
 	    if (flags & FLAG_VERBOSE)
 		c_write_str(ssh, ""Trying public key authentication.\r\n"");
 	    s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);
 	    logeventf(ssh, ""Trying public key \""%s\"""",
 		      filename_to_str(s->keyfile));
 	    s->tried_publickey = 1;
 	    got_passphrase = FALSE;
 	    while (!got_passphrase) {
 		 
 		char *passphrase = NULL;     
 		const char *error;
 		if (!s->privatekey_encrypted) {
 		    if (flags & FLAG_VERBOSE)
 			c_write_str(ssh, ""No passphrase required.\r\n"");
 		    passphrase = NULL;
 		} else {
 		    int ret;  
 		    s->cur_prompt = new_prompts(ssh->frontend);
 		    s->cur_prompt->to_server = FALSE;
 		    s->cur_prompt->name = dupstr(""SSH key passphrase"");
 		    add_prompt(s->cur_prompt,
 			       dupprintf(""Passphrase for key \""%.100s\"": "",
 					 s->publickey_comment), FALSE);
 		    ret = get_userpass_input(s->cur_prompt, NULL, 0);
 		    while (ret < 0) {
 			ssh->send_ok = 1;
 			crWaitUntil(!pktin);
 			ret = get_userpass_input(s->cur_prompt, in, inlen);
 			ssh->send_ok = 0;
 		    }
 		    if (!ret) {
 			 
 			free_prompts(s->cur_prompt);
 			ssh_disconnect(ssh, NULL, ""Unable to authenticate"",
 				       0, TRUE);
 			crStop(0);
 		    }
 		    passphrase = dupstr(s->cur_prompt->prompts[0]->result);
 		    free_prompts(s->cur_prompt);
 		}
 		 
 		s->keyfile = conf_get_filename(ssh->conf, CONF_keyfile);
 		ret = loadrsakey(s->keyfile, &s->key, passphrase,
 				 &error);
 		if (passphrase) {
 		    smemclr(passphrase, strlen(passphrase));
 		    sfree(passphrase);
 		}
 		if (ret == 1) {
 		     
 		    got_passphrase = TRUE;
 		} else if (ret == 0) {
 		    c_write_str(ssh, ""Couldn't load private key from "");
 		    c_write_str(ssh, filename_to_str(s->keyfile));
 		    c_write_str(ssh, "" ("");
 		    c_write_str(ssh, error);
 		    c_write_str(ssh, "").\r\n"");
 		    got_passphrase = FALSE;
 		    break;	        
 		} else if (ret == -1) {
 		    c_write_str(ssh, ""Wrong passphrase.\r\n"");  
 		    got_passphrase = FALSE;
 		     
 		} else {
 		    assert(0 && ""unexpected return from loadrsakey()"");
 		    got_passphrase = FALSE;    
 		}
 	    }
 
 	    if (got_passphrase) {
 
 		 
 		send_packet(ssh, SSH1_CMSG_AUTH_RSA,
 			    PKT_BIGNUM, s->key.modulus, PKT_END);
 
 		crWaitUntil(pktin);
 		if (pktin->type == SSH1_SMSG_FAILURE) {
 		    c_write_str(ssh, ""Server refused our public key.\r\n"");
 		    continue;	        
 		}
 		if (pktin->type != SSH1_SMSG_AUTH_RSA_CHALLENGE) {
 		    bombout((""Bizarre response to offer of public key""));
 		    crStop(0);
 		}
 
 		{
 		    int i;
 		    unsigned char buffer[32];
 		    Bignum challenge, response;
 
 		    if ((challenge = ssh1_pkt_getmp(pktin)) == NULL) {
 			bombout((""Server's RSA challenge was badly formatted""));
 			crStop(0);
 		    }
 		    response = rsadecrypt(challenge, &s->key);
 		    freebn(s->key.private_exponent); 
 
 		    for (i = 0; i < 32; i++) {
 			buffer[i] = bignum_byte(response, 31 - i);
 		    }
 
 		    MD5Init(&md5c);
 		    MD5Update(&md5c, buffer, 32);
 		    MD5Update(&md5c, s->session_id, 16);
 		    MD5Final(buffer, &md5c);
 
 		    send_packet(ssh, SSH1_CMSG_AUTH_RSA_RESPONSE,
 				PKT_DATA, buffer, 16, PKT_END);
 
 		    freebn(challenge);
 		    freebn(response);
 		}
 
 		crWaitUntil(pktin);
 		if (pktin->type == SSH1_SMSG_FAILURE) {
 		    if (flags & FLAG_VERBOSE)
 			c_write_str(ssh, ""Failed to authenticate with""
 				    "" our public key.\r\n"");
 		    continue;	        
 		} else if (pktin->type != SSH1_SMSG_SUCCESS) {
 		    bombout((""Bizarre response to RSA authentication response""));
 		    crStop(0);
 		}
 
 		break;		        
 	    }
 
 	}
 
 	 
 	s->cur_prompt = new_prompts(ssh->frontend);
 
 	if (conf_get_int(ssh->conf, CONF_try_tis_auth) &&
 	    (s->supported_auths_mask & (1 << SSH1_AUTH_TIS)) &&
 	    !s->tis_auth_refused) {
 	    s->pwpkt_type = SSH1_CMSG_AUTH_TIS_RESPONSE;
 	    logevent(""Requested TIS authentication"");
 	    send_packet(ssh, SSH1_CMSG_AUTH_TIS, PKT_END);
 	    crWaitUntil(pktin);
 	    if (pktin->type != SSH1_SMSG_AUTH_TIS_CHALLENGE) {
 		logevent(""TIS authentication declined"");
 		if (flags & FLAG_INTERACTIVE)
 		    c_write_str(ssh, ""TIS authentication refused.\r\n"");
 		s->tis_auth_refused = 1;
 		continue;
 	    } else {
 		char *challenge;
 		int challengelen;
 		char *instr_suf, *prompt;
 
 		ssh_pkt_getstring(pktin, &challenge, &challengelen);
 		if (!challenge) {
 		    bombout((""TIS challenge packet was badly formed""));
 		    crStop(0);
 		}
 		logevent(""Received TIS challenge"");
 		s->cur_prompt->to_server = TRUE;
 		s->cur_prompt->name = dupstr(""SSH TIS authentication"");
 		 
 		if (memchr(challenge, '\n', challengelen)) {
 		    instr_suf = dupstr("""");
 		    prompt = dupprintf(""%.*s"", challengelen, challenge);
 		} else {
 		    instr_suf = dupprintf(""%.*s"", challengelen, challenge);
 		    prompt = dupstr(""Response: "");
 		}
 		s->cur_prompt->instruction =
 		    dupprintf(""Using TIS authentication.%s%s"",
 			      (*instr_suf) ? ""\n"" : """",
 			      instr_suf);
 		s->cur_prompt->instr_reqd = TRUE;
 		add_prompt(s->cur_prompt, prompt, FALSE);
 		sfree(instr_suf);
 	    }
 	}
 	if (conf_get_int(ssh->conf, CONF_try_tis_auth) &&
 	    (s->supported_auths_mask & (1 << SSH1_AUTH_CCARD)) &&
 	    !s->ccard_auth_refused) {
 	    s->pwpkt_type = SSH1_CMSG_AUTH_CCARD_RESPONSE;
 	    logevent(""Requested CryptoCard authentication"");
 	    send_packet(ssh, SSH1_CMSG_AUTH_CCARD, PKT_END);
 	    crWaitUntil(pktin);
 	    if (pktin->type != SSH1_SMSG_AUTH_CCARD_CHALLENGE) {
 		logevent(""CryptoCard authentication declined"");
 		c_write_str(ssh, ""CryptoCard authentication refused.\r\n"");
 		s->ccard_auth_refused = 1;
 		continue;
 	    } else {
 		char *challenge;
 		int challengelen;
 		char *instr_suf, *prompt;
 
 		ssh_pkt_getstring(pktin, &challenge, &challengelen);
 		if (!challenge) {
 		    bombout((""CryptoCard challenge packet was badly formed""));
 		    crStop(0);
 		}
 		logevent(""Received CryptoCard challenge"");
 		s->cur_prompt->to_server = TRUE;
 		s->cur_prompt->name = dupstr(""SSH CryptoCard authentication"");
 		s->cur_prompt->name_reqd = FALSE;
 		 
 		if (memchr(challenge, '\n', challengelen)) {
 		    instr_suf = dupstr("""");
 		    prompt = dupprintf(""%.*s"", challengelen, challenge);
 		} else {
 		    instr_suf = dupprintf(""%.*s"", challengelen, challenge);
 		    prompt = dupstr(""Response: "");
 		}
 		s->cur_prompt->instruction =
 		    dupprintf(""Using CryptoCard authentication.%s%s"",
 			      (*instr_suf) ? ""\n"" : """",
 			      instr_suf);
 		s->cur_prompt->instr_reqd = TRUE;
 		add_prompt(s->cur_prompt, prompt, FALSE);
 		sfree(instr_suf);
 	    }
 	}
 	if (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {
 	    if ((s->supported_auths_mask & (1 << SSH1_AUTH_PASSWORD)) == 0) {
 		bombout((""No supported authentication methods available""));
 		crStop(0);
 	    }
 	    s->cur_prompt->to_server = TRUE;
 	    s->cur_prompt->name = dupstr(""SSH password"");
 	    add_prompt(s->cur_prompt, dupprintf(""%s@%s's password: "",
 						ssh->username, ssh->savedhost),
 		       FALSE);
 	}
 
 	 
 	{
 	    int ret;  
 	    ret = get_userpass_input(s->cur_prompt, NULL, 0);
 	    while (ret < 0) {
 		ssh->send_ok = 1;
 		crWaitUntil(!pktin);
 		ret = get_userpass_input(s->cur_prompt, in, inlen);
 		ssh->send_ok = 0;
 	    }
 	    if (!ret) {
 		 
 		free_prompts(s->cur_prompt);
 		ssh_disconnect(ssh, NULL, ""Unable to authenticate"", 0, TRUE);
 		crStop(0);
 	    }
 	}
 
 	if (s->pwpkt_type == SSH1_CMSG_AUTH_PASSWORD) {
 	     
 	    if (!(ssh->remote_bugs & BUG_CHOKES_ON_SSH1_IGNORE) &&
 	        !(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {
 		 
 		int bottom, top, pwlen, i;
 		char *randomstr;
 
 		pwlen = strlen(s->cur_prompt->prompts[0]->result);
 		if (pwlen < 16) {
 		    bottom = 0;     
 		    top = 15;
 		} else {
 		    bottom = pwlen & ~7;
 		    top = bottom + 7;
 		}
 
 		assert(pwlen >= bottom && pwlen <= top);
 
 		randomstr = snewn(top + 1, char);
 
 		for (i = bottom; i <= top; i++) {
 		    if (i == pwlen) {
 			defer_packet(ssh, s->pwpkt_type,
                                      PKT_STR,s->cur_prompt->prompts[0]->result,
 				     PKT_END);
 		    } else {
 			for (j = 0; j < i; j++) {
 			    do {
 				randomstr[j] = random_byte();
 			    } while (randomstr[j] == '\0');
 			}
 			randomstr[i] = '\0';
 			defer_packet(ssh, SSH1_MSG_IGNORE,
 				     PKT_STR, randomstr, PKT_END);
 		    }
 		}
 		logevent(""Sending password with camouflage packets"");
 		ssh_pkt_defersend(ssh);
 		sfree(randomstr);
 	    } 
 	    else if (!(ssh->remote_bugs & BUG_NEEDS_SSH1_PLAIN_PASSWORD)) {
 		 
 		char string[64];
 		char *ss;
 		int len;
 
 		len = strlen(s->cur_prompt->prompts[0]->result);
 		if (len < sizeof(string)) {
 		    ss = string;
 		    strcpy(string, s->cur_prompt->prompts[0]->result);
 		    len++;	        
 		    while (len < sizeof(string)) {
 			string[len++] = (char) random_byte();
 		    }
 		} else {
 		    ss = s->cur_prompt->prompts[0]->result;
 		}
 		logevent(""Sending length-padded password"");
 		send_packet(ssh, s->pwpkt_type,
 			    PKT_INT, len, PKT_DATA, ss, len,
 			    PKT_END);
 	    } else {
 		 
 		int len;
 		len = strlen(s->cur_prompt->prompts[0]->result);
 		logevent(""Sending unpadded password"");
 		send_packet(ssh, s->pwpkt_type,
                             PKT_INT, len,
 			    PKT_DATA, s->cur_prompt->prompts[0]->result, len,
 			    PKT_END);
 	    }
 	} else {
 	    send_packet(ssh, s->pwpkt_type,
 			PKT_STR, s->cur_prompt->prompts[0]->result,
 			PKT_END);
 	}
 	logevent(""Sent password"");
 	free_prompts(s->cur_prompt);
 	crWaitUntil(pktin);
 	if (pktin->type == SSH1_SMSG_FAILURE) {
 	    if (flags & FLAG_VERBOSE)
 		c_write_str(ssh, ""Access denied\r\n"");
 	    logevent(""Authentication refused"");
 	} else if (pktin->type != SSH1_SMSG_SUCCESS) {
 	    bombout((""Strange packet received, type %d"", pktin->type));
 	    crStop(0);
 	}
     }
 
      
     if (s->publickey_blob) {
 	sfree(s->publickey_blob);
 	sfree(s->publickey_comment);
     }
 
     logevent(""Authentication successful"");
 
     crFinish(1);
 }
 
 static void ssh_channel_try_eof(struct ssh_channel *c)
 {
     Ssh ssh = c->ssh;
     assert(c->pending_eof);           
     if (c->halfopen)
         return;                  
     if (ssh->version == 2 && bufchain_size(&c->v.v2.outbuffer) > 0)
         return;               
 
     c->pending_eof = FALSE;             
     if (ssh->version == 1) {
         send_packet(ssh, SSH1_MSG_CHANNEL_CLOSE, PKT_INT, c->remoteid,
                     PKT_END);
         c->closes |= CLOSES_SENT_EOF;
     } else {
         struct Packet *pktout;
         pktout = ssh2_pkt_init(SSH2_MSG_CHANNEL_EOF);
         ssh2_pkt_adduint32(pktout, c->remoteid);
         ssh2_pkt_send(ssh, pktout);
         c->closes |= CLOSES_SENT_EOF;
 	ssh2_channel_check_close(c);
     }
 }
 
 Conf *sshfwd_get_conf(struct ssh_channel *c)
 {
     Ssh ssh = c->ssh;
     return ssh->conf;
 }
 
 void sshfwd_write_eof(struct ssh_channel *c)
 {
     Ssh ssh = c->ssh;
 
     if (ssh->state == SSH_STATE_CLOSED)
 	return;
 
     if (c->closes & CLOSES_SENT_EOF)
         return;
 
     c->pending_eof = TRUE;
     ssh_channel_try_eof(c);
 }
 
 void sshfwd_unclean_close(struct ssh_channel *c, const char *err)
 {
     Ssh ssh = c->ssh;
     char *reason;
 
     if (ssh->state == SSH_STATE_CLOSED)
 	return;
 
     reason = dupprintf(""due to local error: %s"", err);
     ssh_channel_close_local(c, reason);
     sfree(reason);
     c->pending_eof = FALSE;    
 
     ssh2_channel_check_close(c);
 }
 
 int sshfwd_write(struct ssh_channel *c, char *buf, int len)
 {
     Ssh ssh = c->ssh;
 
     if (ssh->state == SSH_STATE_CLOSED)
 	return 0;
 
     return ssh_send_channel_data(c, buf, len);
 }
 
 void sshfwd_unthrottle(struct ssh_channel *c, int bufsize)
 {
     Ssh ssh = c->ssh;
 
     if (ssh->state == SSH_STATE_CLOSED)
 	return;
 
     ssh_channel_unthrottle(c, bufsize);
 }
 
 static void ssh_queueing_handler(Ssh ssh, struct Packet *pktin)
 {
     struct queued_handler *qh = ssh->qhead;
 
     assert(qh != NULL);
 
     assert(pktin->type == qh->msg1 || pktin->type == qh->msg2);
 
     if (qh->msg1 > 0) {
 	assert(ssh->packet_dispatch[qh->msg1] == ssh_queueing_handler);
 	ssh->packet_dispatch[qh->msg1] = ssh->q_saved_handler1;
     }
     if (qh->msg2 > 0) {
 	assert(ssh->packet_dispatch[qh->msg2] == ssh_queueing_handler);
 	ssh->packet_dispatch[qh->msg2] = ssh->q_saved_handler2;
     }
 
     if (qh->next) {
 	ssh->qhead = qh->next;
 
 	if (ssh->qhead->msg1 > 0) {
 	    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];
 	    ssh->packet_dispatch[ssh->qhead->msg1] = ssh_queueing_handler;
 	}
 	if (ssh->qhead->msg2 > 0) {
 	    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];
 	    ssh->packet_dispatch[ssh->qhead->msg2] = ssh_queueing_handler;
 	}
     } else {
 	ssh->qhead = ssh->qtail = NULL;
     }
 
     qh->handler(ssh, pktin, qh->ctx);
 
     sfree(qh);
 }
 
 static void ssh_queue_handler(Ssh ssh, int msg1, int msg2,
 			      chandler_fn_t handler, void *ctx)
 {
     struct queued_handler *qh;
 
     qh = snew(struct queued_handler);
     qh->msg1 = msg1;
     qh->msg2 = msg2;
     qh->handler = handler;
     qh->ctx = ctx;
     qh->next = NULL;
 
     if (ssh->qtail == NULL) {
 	ssh->qhead = qh;
 
 	if (qh->msg1 > 0) {
 	    ssh->q_saved_handler1 = ssh->packet_dispatch[ssh->qhead->msg1];
 	    ssh->packet_dispatch[qh->msg1] = ssh_queueing_handler;
 	}
 	if (qh->msg2 > 0) {
 	    ssh->q_saved_handler2 = ssh->packet_dispatch[ssh->qhead->msg2];
 	    ssh->packet_dispatch[qh->msg2] = ssh_queueing_handler;
 	}
     } else {
 	ssh->qtail->next = qh;
     }
     ssh->qtail = qh;
 }
 
 static void ssh_rportfwd_succfail(Ssh ssh, struct Packet *pktin, void *ctx)
 {
     struct ssh_rportfwd *rpf, *pf = (struct ssh_rportfwd *)ctx;
 
     if (pktin->type == (ssh->version == 1 ? SSH1_SMSG_SUCCESS :
 			SSH2_MSG_REQUEST_SUCCESS)) {
 	logeventf(ssh, ""Remote port forwarding from %s enabled"",
 		  pf->sportdesc);
     } else {
 	logeventf(ssh, ""Remote port forwarding from %s refused"",
 		  pf->sportdesc);
 
 	rpf = del234(ssh->rportfwds, pf);
 	assert(rpf == pf);
 	pf->pfrec->remote = NULL;
 	free_rportfwd(pf);
     }
 }
 
 int ssh_alloc_sharing_rportfwd(Ssh ssh, const char *shost, int sport,
                                void *share_ctx)
 {
     struct ssh_rportfwd *pf = snew(struct ssh_rportfwd);
     pf->dhost = NULL;
     pf->dport = 0;
     pf->share_ctx = share_ctx;
     pf->shost = dupstr(shost);
     pf->sport = sport;
     pf->sportdesc = NULL;
     if (!ssh->rportfwds) {
         assert(ssh->version == 2);
         ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);
     }
     if (add234(ssh->rportfwds, pf) != pf) {
         sfree(pf->shost);
         sfree(pf);
         return FALSE;
     }
     return TRUE;
 }
 
 static void ssh_sharing_global_request_response(Ssh ssh, struct Packet *pktin,
                                                 void *ctx)
 {
     share_got_pkt_from_server(ctx, pktin->type,
                               pktin->body, pktin->length);
 }
 
 void ssh_sharing_queue_global_request(Ssh ssh, void *share_ctx)
 {
     ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS, SSH2_MSG_REQUEST_FAILURE,
                       ssh_sharing_global_request_response, share_ctx);
 }
 
 static void ssh_setup_portfwd(Ssh ssh, Conf *conf)
 {
     struct ssh_portfwd *epf;
     int i;
     char *key, *val;
 
     if (!ssh->portfwds) {
 	ssh->portfwds = newtree234(ssh_portcmp);
     } else {
 	 
 	struct ssh_portfwd *epf;
 	int i;
 	for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)
 	    epf->status = DESTROY;
     }
 
     for (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);
 	 val != NULL;
 	 val = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {
 	char *kp, *kp2, *vp, *vp2;
 	char address_family, type;
 	int sport,dport,sserv,dserv;
 	char *sports, *dports, *saddr, *host;
 
 	kp = key;
 
 	address_family = 'A';
 	type = 'L';
 	if (*kp == 'A' || *kp == '4' || *kp == '6')
 	    address_family = *kp++;
 	if (*kp == 'L' || *kp == 'R')
 	    type = *kp++;
 
 	if ((kp2 = host_strchr(kp, ':')) != NULL) {
 	     
 	    char *saddr_tmp = dupprintf(""%.*s"", (int)(kp2 - kp), kp);
             saddr = host_strduptrim(saddr_tmp);
             sfree(saddr_tmp);
 	    sports = kp2+1;
 	} else {
 	    saddr = NULL;
 	    sports = kp;
 	}
 	sport = atoi(sports);
 	sserv = 0;
 	if (sport == 0) {
 	    sserv = 1;
 	    sport = net_service_lookup(sports);
 	    if (!sport) {
 		logeventf(ssh, ""Service lookup failed for source""
 			  "" port \""%s\"""", sports);
 	    }
 	}
 
 	if (type == 'L' && !strcmp(val, ""D"")) {
              
 	    host = NULL;
 	    dports = NULL;
 	    dport = -1;
 	    dserv = 0;
             type = 'D';
         } else {
              
 	    vp = val;
 	    vp2 = vp + host_strcspn(vp, "":"");
 	    host = dupprintf(""%.*s"", (int)(vp2 - vp), vp);
 	    if (*vp2)
 		vp2++;
 	    dports = vp2;
 	    dport = atoi(dports);
 	    dserv = 0;
 	    if (dport == 0) {
 		dserv = 1;
 		dport = net_service_lookup(dports);
 		if (!dport) {
 		    logeventf(ssh, ""Service lookup failed for destination""
 			      "" port \""%s\"""", dports);
 		}
 	    }
 	}
 
 	if (sport && dport) {
 	     
 	    struct ssh_portfwd *pfrec, *epfrec;
 
 	    pfrec = snew(struct ssh_portfwd);
 	    pfrec->type = type;
 	    pfrec->saddr = saddr;
 	    pfrec->sserv = sserv ? dupstr(sports) : NULL;
 	    pfrec->sport = sport;
 	    pfrec->daddr = host;
 	    pfrec->dserv = dserv ? dupstr(dports) : NULL;
 	    pfrec->dport = dport;
 	    pfrec->local = NULL;
 	    pfrec->remote = NULL;
 	    pfrec->addressfamily = (address_family == '4' ? ADDRTYPE_IPV4 :
 				    address_family == '6' ? ADDRTYPE_IPV6 :
 				    ADDRTYPE_UNSPEC);
 
 	    epfrec = add234(ssh->portfwds, pfrec);
 	    if (epfrec != pfrec) {
 		if (epfrec->status == DESTROY) {
 		     
 		    epfrec->status = KEEP;
 		}
 		 
 		free_portfwd(pfrec);
 	    } else {
 		pfrec->status = CREATE;
 	    }
 	} else {
 	    sfree(saddr);
 	    sfree(host);
 	}
     }
 
      
     for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)
 	if (epf->status == DESTROY) {
 	    char *message;
 
 	    message = dupprintf(""%s port forwarding from %s%s%d"",
 				epf->type == 'L' ? ""local"" :
 				epf->type == 'R' ? ""remote"" : ""dynamic"",
 				epf->saddr ? epf->saddr : """",
 				epf->saddr ? "":"" : """",
 				epf->sport);
 
 	    if (epf->type != 'D') {
 		char *msg2 = dupprintf(""%s to %s:%d"", message,
 				       epf->daddr, epf->dport);
 		sfree(message);
 		message = msg2;
 	    }
 
 	    logeventf(ssh, ""Cancelling %s"", message);
 	    sfree(message);
 
 	     
 	    if (epf->remote) {
 		struct ssh_rportfwd *rpf = epf->remote;
 		struct Packet *pktout;
 
 		 
 		if (ssh->version == 1) {
 		     
 		} else {
 		    pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);
 		    ssh2_pkt_addstring(pktout, ""cancel-tcpip-forward"");
 		    ssh2_pkt_addbool(pktout, 0); 
 		    if (epf->saddr) {
 			ssh2_pkt_addstring(pktout, epf->saddr);
 		    } else if (conf_get_int(conf, CONF_rport_acceptall)) {
 			 
 			ssh2_pkt_addstring(pktout, """");
 		    } else {
 			ssh2_pkt_addstring(pktout, ""localhost"");
 		    }
 		    ssh2_pkt_adduint32(pktout, epf->sport);
 		    ssh2_pkt_send(ssh, pktout);
 		}
 
 		del234(ssh->rportfwds, rpf);
 		free_rportfwd(rpf);
 	    } else if (epf->local) {
 		pfl_terminate(epf->local);
 	    }
 
 	    delpos234(ssh->portfwds, i);
 	    free_portfwd(epf);
 	    i--;		        
 	}
 
      
     for (i = 0; (epf = index234(ssh->portfwds, i)) != NULL; i++)
 	if (epf->status == CREATE) {
 	    char *sportdesc, *dportdesc;
 	    sportdesc = dupprintf(""%s%s%s%s%d%s"",
 				  epf->saddr ? epf->saddr : """",
 				  epf->saddr ? "":"" : """",
 				  epf->sserv ? epf->sserv : """",
 				  epf->sserv ? ""("" : """",
 				  epf->sport,
 				  epf->sserv ? "")"" : """");
 	    if (epf->type == 'D') {
 		dportdesc = NULL;
 	    } else {
 		dportdesc = dupprintf(""%s:%s%s%d%s"",
 				      epf->daddr,
 				      epf->dserv ? epf->dserv : """",
 				      epf->dserv ? ""("" : """",
 				      epf->dport,
 				      epf->dserv ? "")"" : """");
 	    }
 
 	    if (epf->type == 'L') {
                 char *err = pfl_listen(epf->daddr, epf->dport,
                                        epf->saddr, epf->sport,
                                        ssh, conf, &epf->local,
                                        epf->addressfamily);
 
 		logeventf(ssh, ""Local %sport %s forwarding to %s%s%s"",
 			  epf->addressfamily == ADDRTYPE_IPV4 ? ""IPv4 "" :
 			  epf->addressfamily == ADDRTYPE_IPV6 ? ""IPv6 "" : """",
 			  sportdesc, dportdesc,
 			  err ? "" failed: "" : """", err ? err : """");
                 if (err)
                     sfree(err);
 	    } else if (epf->type == 'D') {
 		char *err = pfl_listen(NULL, -1, epf->saddr, epf->sport,
                                        ssh, conf, &epf->local,
                                        epf->addressfamily);
 
 		logeventf(ssh, ""Local %sport %s SOCKS dynamic forwarding%s%s"",
 			  epf->addressfamily == ADDRTYPE_IPV4 ? ""IPv4 "" :
 			  epf->addressfamily == ADDRTYPE_IPV6 ? ""IPv6 "" : """",
 			  sportdesc,
 			  err ? "" failed: "" : """", err ? err : """");
 
                 if (err)
                     sfree(err);
 	    } else {
 		struct ssh_rportfwd *pf;
 
 		 
 		if (!ssh->rportfwds) {
 		    if (ssh->version == 1)
 			ssh->rportfwds = newtree234(ssh_rportcmp_ssh1);
 		    else
 			ssh->rportfwds = newtree234(ssh_rportcmp_ssh2);
 		}
 
 		pf = snew(struct ssh_rportfwd);
                 pf->share_ctx = NULL;
                 pf->dhost = dupstr(epf->daddr);
 		pf->dport = epf->dport;
                 if (epf->saddr) {
                     pf->shost = dupstr(epf->saddr);
                 } else if (conf_get_int(conf, CONF_rport_acceptall)) {
                     pf->shost = dupstr("""");
                 } else {
                     pf->shost = dupstr(""localhost"");
                 }
 		pf->sport = epf->sport;
 		if (add234(ssh->rportfwds, pf) != pf) {
 		    logeventf(ssh, ""Duplicate remote port forwarding to %s:%d"",
 			      epf->daddr, epf->dport);
 		    sfree(pf);
 		} else {
 		    logeventf(ssh, ""Requesting remote port %s""
 			      "" forward to %s"", sportdesc, dportdesc);
 
 		    pf->sportdesc = sportdesc;
 		    sportdesc = NULL;
 		    epf->remote = pf;
 		    pf->pfrec = epf;
 
 		    if (ssh->version == 1) {
 			send_packet(ssh, SSH1_CMSG_PORT_FORWARD_REQUEST,
 				    PKT_INT, epf->sport,
 				    PKT_STR, epf->daddr,
 				    PKT_INT, epf->dport,
 				    PKT_END);
 			ssh_queue_handler(ssh, SSH1_SMSG_SUCCESS,
 					  SSH1_SMSG_FAILURE,
 					  ssh_rportfwd_succfail, pf);
 		    } else {
 			struct Packet *pktout;
 			pktout = ssh2_pkt_init(SSH2_MSG_GLOBAL_REQUEST);
 			ssh2_pkt_addstring(pktout, ""tcpip-forward"");
 			ssh2_pkt_addbool(pktout, 1); 
 			ssh2_pkt_addstring(pktout, pf->shost);
 			ssh2_pkt_adduint32(pktout, pf->sport);
 			ssh2_pkt_send(ssh, pktout);
 
 			ssh_queue_handler(ssh, SSH2_MSG_REQUEST_SUCCESS,
 					  SSH2_MSG_REQUEST_FAILURE,
 					  ssh_rportfwd_succfail, pf);
 		    }
 		}
 	    }
 	    sfree(sportdesc);
 	    sfree(dportdesc);
 	}
 }
 
 static void ssh1_smsg_stdout_stderr_data(Ssh ssh, struct Packet *pktin)
 {
     char *string;
     int stringlen, bufsize;
 
     ssh_pkt_getstring(pktin, &string, &stringlen);
     if (string == NULL) {
 	bombout((""Incoming terminal data packet was badly formed""));
 	return;
     }
 
     bufsize = from_backend(ssh->frontend, pktin->type == SSH1_SMSG_STDERR_DATA,
 			   string, stringlen);
     if (!ssh->v1_stdout_throttling && bufsize > SSH1_BUFFER_LIMIT) {
 	ssh->v1_stdout_throttling = 1;
 	ssh_throttle_conn(ssh, +1);
     }
 }
 
 static void ssh1_smsg_x11_open(Ssh ssh, struct Packet *pktin)
 {
      
     struct ssh_channel *c;
     int remoteid = ssh_pkt_getuint32(pktin);
 
     logevent(""Received X11 connect request"");
      
     if (!ssh->X11_fwd_enabled) {
 	send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,
 		    PKT_INT, remoteid, PKT_END);
 	logevent(""Rejected X11 connect request"");
     } else {
 	c = snew(struct ssh_channel);
 	c->ssh = ssh;
 
 	ssh_channel_init(c);
 	c->u.x11.xconn = x11_init(ssh->x11authtree, c, NULL, -1);
         c->remoteid = remoteid;
         c->halfopen = FALSE;
         c->type = CHAN_X11;	 
         send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,
                     PKT_INT, c->remoteid, PKT_INT,
                     c->localid, PKT_END);
         logevent(""Opened X11 forward channel"");
     }
 }
 
 static void ssh1_smsg_agent_open(Ssh ssh, struct Packet *pktin)
 {
      
     struct ssh_channel *c;
     int remoteid = ssh_pkt_getuint32(pktin);
 
      
     if (!ssh->agentfwd_enabled) {
 	send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,
 		    PKT_INT, remoteid, PKT_END);
     } else {
 	c = snew(struct ssh_channel);
 	c->ssh = ssh;
 	ssh_channel_init(c);
 	c->remoteid = remoteid;
 	c->halfopen = FALSE;
 	c->type = CHAN_AGENT;	 
 	c->u.a.lensofar = 0;
 	c->u.a.message = NULL;
 	c->u.a.pending = NULL;
 	c->u.a.outstanding_requests = 0;
 	send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,
 		    PKT_INT, c->remoteid, PKT_INT, c->localid,
 		    PKT_END);
     }
 }
 
 static void ssh1_msg_port_open(Ssh ssh, struct Packet *pktin)
 {
      
     struct ssh_rportfwd pf, *pfp;
     int remoteid;
     int hostsize, port;
     char *host;
     char *err;
 
     remoteid = ssh_pkt_getuint32(pktin);
     ssh_pkt_getstring(pktin, &host, &hostsize);
     port = ssh_pkt_getuint32(pktin);
 
     pf.dhost = dupprintf(""%.*s"", hostsize, NULLTOEMPTY(host));
     pf.dport = port;
     pfp = find234(ssh->rportfwds, &pf, NULL);
 
     if (pfp == NULL) {
 	logeventf(ssh, ""Rejected remote port open request for %s:%d"",
 		  pf.dhost, port);
 	send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,
 		    PKT_INT, remoteid, PKT_END);
     } else {
         struct ssh_channel *c = snew(struct ssh_channel);
         c->ssh = ssh;
 
 	logeventf(ssh, ""Received remote port open request for %s:%d"",
 		  pf.dhost, port);
 	err = pfd_connect(&c->u.pfd.pf, pf.dhost, port,
                           c, ssh->conf, pfp->pfrec->addressfamily);
 	if (err != NULL) {
 	    logeventf(ssh, ""Port open failed: %s"", err);
             sfree(err);
 	    sfree(c);
 	    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_FAILURE,
 			PKT_INT, remoteid, PKT_END);
 	} else {
 	    ssh_channel_init(c);
 	    c->remoteid = remoteid;
 	    c->halfopen = FALSE;
 	    c->type = CHAN_SOCKDATA;	 
 	    send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,
 			PKT_INT, c->remoteid, PKT_INT,
 			c->localid, PKT_END);
 	    logevent(""Forwarded port opened successfully"");
 	}
     }
 
     sfree(pf.dhost);
 }
 
 static void ssh1_msg_channel_open_confirmation(Ssh ssh, struct Packet *pktin)
 {
     struct ssh_channel *c;
 
     c = ssh_channel_msg(ssh, pktin);
     if (c && c->type == CHAN_SOCKDATA) {
 	c->remoteid = ssh_pkt_getuint32(pktin);
 	c->halfopen = FALSE;
 	c->throttling_conn = 0;
 	pfd_confirm(c->u.pfd.pf);
     }
 
     if (c && c->pending_eof) {
 	 
         ssh_channel_try_eof(c);
     }
 }
 
         c->remoteid = remoteid;
         c->halfopen = FALSE;
         c->type = CHAN_AGENT;    
       c->u.a.lensofar = 0;
       c->u.a.message = NULL;
         c->u.a.pending = NULL;
       c->u.a.outstanding_requests = 0;
         bufchain_init(&c->u.a.inbuffer);
         send_packet(ssh, SSH1_MSG_CHANNEL_OPEN_CONFIRMATION,
                     PKT_INT, c->remoteid, PKT_INT, c->localid,
                     PKT_END);
 	del234(ssh->channels, c);
 	sfree(c);
     }
 }","[21, 22, 62, 63, 70, 71, 74, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 1644, 61, 65, 66, 68, 69, 73, 77, 78, 79, 95, 1640, 1641, 1643]","The ssh_agent_channel_data function in PuTTY before 0.68 allows remote attackers to have unspecified impact via a large length value in an agent protocol message and leveraging the ability to connect to the Unix-domain socket representing the forwarded agent connection, which trigger a buffer overflow."
9789,"static void dhcps_send_offer(struct pbuf *packet_buffer)
{
uint8_t temp_ip = 0;
dhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;
#if (!IS_USE_FIXED_IP) 	
temp_ip = check_client_request_ip(&client_request_ip, client_addr);

if(temp_ip == 0)
temp_ip = search_next_ip();
#if (debug_dhcps)	
printf(""\r\n temp_ip = %d"",temp_ip);
#endif	
if (temp_ip == 0) {
#if 0	
memset(&ip_table, 0, sizeof(struct table));
mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));
printf(""\r\n reset ip table!!\r\n"");
#endif	
printf(""\r\n No useable ip!!!!\r\n"");
}
printf(""\n\r[%d]DHCP assign ip = %d.%d.%d.%d\n"", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);
IP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),
ip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);
#endif   
dhcps_initialize_message(dhcp_message_repository);
add_offer_options(add_msg_type(&dhcp_message_repository->options[4],
DHCP_MESSAGE_TYPE_OFFER));
udp_sendto_if(dhcps_pcb, packet_buffer,
&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);
}","[4, 5, 8, 21, 24, 26, 27, 28, 29]",component/common/network/dhcp/dhcps.c in ambiot amb1_sdk (aka SDK for Ameba1) before 2022-03-11 mishandles data structures for DHCP packet data.
203209," struct bio *bio_map_user_iov(struct request_queue *q,
 			     const struct iov_iter *iter,
 			     gfp_t gfp_mask)
 {
 	int j;
 	int nr_pages = 0;
 	struct page **pages;
 	struct bio *bio;
 	int cur_page = 0;
  	int ret, offset;
  	struct iov_iter i;
  	struct iovec iov;
 	struct bio_vec *bvec;
  
  	iov_for_each(iov, i, *iter) {
  		unsigned long uaddr = (unsigned long) iov.iov_base;
 		unsigned long len = iov.iov_len;
 		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		unsigned long start = uaddr >> PAGE_SHIFT;
 
 		 
 		if (end < start)
 			return ERR_PTR(-EINVAL);
 
 		nr_pages += end - start;
 		 
 		if (uaddr & queue_dma_alignment(q))
 			return ERR_PTR(-EINVAL);
 	}
 
 	if (!nr_pages)
 		return ERR_PTR(-EINVAL);
 
 	bio = bio_kmalloc(gfp_mask, nr_pages);
 	if (!bio)
 		return ERR_PTR(-ENOMEM);
 
 	ret = -ENOMEM;
 	pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask);
 	if (!pages)
 		goto out;
 
 	iov_for_each(iov, i, *iter) {
 		unsigned long uaddr = (unsigned long) iov.iov_base;
 		unsigned long len = iov.iov_len;
 		unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;
 		unsigned long start = uaddr >> PAGE_SHIFT;
 		const int local_nr_pages = end - start;
 		const int page_limit = cur_page + local_nr_pages;
 
  		ret = get_user_pages_fast(uaddr, local_nr_pages,
  				(iter->type & WRITE) != WRITE,
  				&pages[cur_page]);
		if (ret < local_nr_pages) {
 		if (unlikely(ret < local_nr_pages)) {
 			for (j = cur_page; j < page_limit; j++) {
 				if (!pages[j])
 					break;
 				put_page(pages[j]);
 			}
  			ret = -EFAULT;
  			goto out_unmap;
  		}
 
 		offset = offset_in_page(uaddr);
 		for (j = cur_page; j < page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
 			unsigned short prev_bi_vcnt = bio->bi_vcnt;
 
 			if (len <= 0)
 				break;
 			
 			if (bytes > len)
 				bytes = len;
 
 			 
 			if (bio_add_pc_page(q, bio, pages[j], bytes, offset) <
 					    bytes)
 				break;
 
 			 
 			if (bio->bi_vcnt == prev_bi_vcnt)
 				put_page(pages[j]);
 
 			len -= bytes;
 			offset = 0;
 		}
 
 		cur_page = j;
 		 
 		while (j < page_limit)
 			put_page(pages[j++]);
 	}
 
 	kfree(pages);
 
 	bio_set_flag(bio, BIO_USER_MAPPED);
 
 	 
 	bio_get(bio);
  	return bio;
  
   out_unmap:
	for (j = 0; j < nr_pages; j++) {
		if (!pages[j])
			break;
		put_page(pages[j]);
 	bio_for_each_segment_all(bvec, bio, j) {
 		put_page(bvec->bv_page);
  	}
   out:
  	kfree(pages);
 	bio_put(bio);
 	return ERR_PTR(ret);
 }","[13, 55, 56, 57, 58, 59, 60, 108, 109, 54, 104, 105, 106, 107]","The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition."
199822," init_ctx_new(OM_uint32 *minor_status,
 	     spnego_gss_cred_id_t spcred,
 	     gss_ctx_id_t *ctx,
 	     send_token_flag *tokflag)
 {
  	OM_uint32 ret;
  	spnego_gss_ctx_id_t sc = NULL;
  
	sc = create_spnego_ctx();
 	sc = create_spnego_ctx(1);
  	if (sc == NULL)
  		return GSS_S_FAILURE;
  
 	 
 	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,
 				   &sc->mech_set);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
 	 
 	sc->internal_mech = &sc->mech_set->elements[0];
 
 	if (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {
  		ret = GSS_S_FAILURE;
  		goto cleanup;
  	}
	 
 
  	sc->ctx_handle = GSS_C_NO_CONTEXT;
  	*ctx = (gss_ctx_id_t)sc;
  	sc = NULL;
 	*tokflag = INIT_TOKEN_SEND;
 	ret = GSS_S_CONTINUE_NEEDED;
 
 cleanup:
 	release_spnego_ctx(&sc);
 	return ret;
 }","[10, 28, 9, 27]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
199767," static int get_bitmap_file(struct mddev *mddev, void __user * arg)
 {
 	mdu_bitmap_file_t *file = NULL;  
  	char *ptr;
  	int err;
  
	file = kmalloc(sizeof(*file), GFP_NOIO);
 	file = kzalloc(sizeof(*file), GFP_NOIO);
  	if (!file)
  		return -ENOMEM;
  
 	err = 0;
 	spin_lock(&mddev->lock);
 	 
 	if (!mddev->bitmap_info.file)
 		file->pathname[0] = '\0';
 	else if ((ptr = file_path(mddev->bitmap_info.file,
 			       file->pathname, sizeof(file->pathname))),
 		 IS_ERR(ptr))
 		err = PTR_ERR(ptr);
 	else
 		memmove(file->pathname, ptr,
 			sizeof(file->pathname)-(ptr-file->pathname));
 	spin_unlock(&mddev->lock);
 
 	if (err == 0 &&
 	    copy_to_user(arg, file, sizeof(*file)))
 		err = -EFAULT;
 
 	kfree(file);
 	return err;
 }","[8, 7]","The get_bitmap_file function in drivers/md/md.c in the Linux kernel before 4.1.6 does not initialize a certain bitmap data structure, which allows local users to obtain sensitive information from kernel memory via a GET_BITMAP_FILE ioctl call."
207924," void btm_sec_pin_code_request (UINT8 *p_bda)
 {
 
      tBTM_SEC_DEV_REC *p_dev_rec;
      tBTM_CB          *p_cb = &btm_cb;
  
#ifdef PORCHE_PAIRING_CONFLICT
    UINT8 default_pin_code_len = 4;
    PIN_CODE default_pin_code = {0x30, 0x30, 0x30, 0x30};
#endif
      BTM_TRACE_EVENT (""btm_sec_pin_code_request()  State: %s, BDA:%04x%08x"",
                        btm_pair_state_descr(btm_cb.pairing_state),
                        (p_bda[0]<<8)+p_bda[1], (p_bda[2]<<24)+(p_bda[3]<<16)+(p_bda[4]<<8)+p_bda[5] );
 
  if (btm_cb.pairing_state != BTM_PAIR_STATE_IDLE)
  {
 
          if ( (memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) == 0)  &&
               (btm_cb.pairing_state == BTM_PAIR_STATE_WAIT_AUTH_COMPLETE) )
          {
              
             if(! btm_cb.pin_code_len_saved)
             {
                 btsnd_hcic_pin_code_neg_reply (p_bda);
                 return;
             }
             else
             {
                 btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
      	         return;
             }
              btsnd_hcic_pin_code_neg_reply (p_bda);
              return;
          }
          else if ((btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_PIN_REQ)
                   || memcmp (p_bda, btm_cb.pairing_bda, BD_ADDR_LEN) != 0)
  {
 
              BTM_TRACE_WARNING (""btm_sec_pin_code_request() rejected - state: %s"",
                                  btm_pair_state_descr(btm_cb.pairing_state));
  
#ifdef PORCHE_PAIRING_CONFLICT
             
            BTM_TRACE_EVENT (""btm_sec_pin_code_request from remote dev. for local initiated pairing"");
            if(! btm_cb.pin_code_len_saved)
            {
                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
                btsnd_hcic_pin_code_req_reply (p_bda, default_pin_code_len, default_pin_code);
            }
            else
            {
                btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
                btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len_saved, p_cb->pin_code);
            }
#else
              btsnd_hcic_pin_code_neg_reply (p_bda);
#endif
              return;
          }
      }
 
     p_dev_rec = btm_find_or_alloc_dev (p_bda);
   
     p_dev_rec->sm4 = BTM_SM4_KNOWN;
 
  if (btm_cb.pairing_state == BTM_PAIR_STATE_IDLE)
  {
         memcpy (btm_cb.pairing_bda, p_bda, BD_ADDR_LEN);
 
         btm_cb.pairing_flags = BTM_PAIR_FLAGS_PEER_STARTED_DD;
   
         BTM_SEC_CLR_TRUSTED_DEVICE(p_dev_rec->trusted_mask);
  }
 
  if (!p_cb->pairing_disabled && (p_cb->cfg.pin_type == HCI_PIN_TYPE_FIXED))
  {
         BTM_TRACE_EVENT (""btm_sec_pin_code_request fixed pin replying"");
         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
         btsnd_hcic_pin_code_req_reply (p_bda, p_cb->cfg.pin_code_len, p_cb->cfg.pin_code);
  return;
  }
 
   
  if ( (!memcmp (p_bda, p_cb->connecting_bda, BD_ADDR_LEN))
  && (p_cb->connecting_dc[0] || p_cb->connecting_dc[1] || p_cb->connecting_dc[2]) )
         memcpy (p_dev_rec->dev_class, p_cb->connecting_dc, DEV_CLASS_LEN);
 
   
  if (btm_cb.pin_code_len != 0)
  {
 
          BTM_TRACE_EVENT (""btm_sec_pin_code_request bonding sending reply"");
          btsnd_hcic_pin_code_req_reply (p_bda, btm_cb.pin_code_len, p_cb->pin_code);
  
#ifdef PORCHE_PAIRING_CONFLICT
        btm_cb.pin_code_len_saved = btm_cb.pin_code_len;
#endif
           
          btm_cb.pin_code_len = 0;
  
   
   
 
         btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE);
  }
 
   
   
  else if (p_cb->pairing_disabled
  || (p_cb->api.p_pin_callback == NULL)
 
   
   
   
  || (!p_dev_rec->is_originator
  && ((p_dev_rec->dev_class[1] & BTM_COD_MAJOR_CLASS_MASK) == BTM_COD_MAJOR_PERIPHERAL)
  && (p_dev_rec->dev_class[2] & BTM_COD_MINOR_KEYBOARD)) )
  {
         BTM_TRACE_WARNING(""btm_sec_pin_code_request(): Pairing disabled:%d; PIN callback:%x, Dev Rec:%x!"",
                            p_cb->pairing_disabled, p_cb->api.p_pin_callback, p_dev_rec);
 
         btsnd_hcic_pin_code_neg_reply (p_bda);
  }
 
       
      else
      {
        btm_cb.pin_code_len_saved = 0;
          btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_LOCAL_PIN);
           
          memcpy (p_cb->connecting_bda, p_bda, BD_ADDR_LEN);
         memcpy (p_cb->connecting_dc,  p_dev_rec->dev_class, DEV_CLASS_LEN);
 
   
   
   
   
   
  if (p_dev_rec->sec_flags & BTM_SEC_NAME_KNOWN)
  {
             BTM_TRACE_EVENT (""btm_sec_pin_code_request going for callback"");
 
             btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
  if (p_cb->api.p_pin_callback)
  (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
  }
  else
  {
             BTM_TRACE_EVENT (""btm_sec_pin_code_request going for remote name"");
 
   
   
   
  if (!btsnd_hcic_rmt_name_req (p_dev_rec->bd_addr,
                                           HCI_PAGE_SCAN_REP_MODE_R1,
                                           HCI_MANDATARY_PAGE_SCAN_MODE, 0))
  {
                 p_dev_rec->sec_flags |= BTM_SEC_NAME_KNOWN;
                 p_dev_rec->sec_bd_name[0] = 'f';
                 p_dev_rec->sec_bd_name[1] = '0';
                 BTM_TRACE_ERROR (""can not send rmt_name_req?? fake a name and call callback"");
 
                 btm_cb.pairing_flags |= BTM_PAIR_FLAGS_PIN_REQD;
  if (p_cb->api.p_pin_callback)
  (*p_cb->api.p_pin_callback) (p_bda, p_dev_rec->dev_class, p_dev_rec->sec_bd_name);
  }
  }
  }
 
  return;
 }","[32, 33, 7, 8, 9, 10, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 95, 96, 97, 128]","The PORCHE_PAIRING_CONFLICT feature in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to bypass intended pairing restrictions via a crafted device, aka internal bug 26551752."
198028,"   t42_parse_charstrings( T42_Face    face,
                          T42_Loader  loader )
   {
     T42_Parser     parser       = &loader->parser;
     PS_Table       code_table   = &loader->charstrings;
     PS_Table       name_table   = &loader->glyph_names;
     PS_Table       swap_table   = &loader->swap_table;
     FT_Memory      memory       = parser->root.memory;
     FT_Error       error;
 
     PSAux_Service  psaux        = (PSAux_Service)face->psaux;
 
     FT_Byte*       cur;
     FT_Byte*       limit        = parser->root.limit;
     FT_UInt        n;
     FT_UInt        notdef_index = 0;
     FT_Byte        notdef_found = 0;
 
 
     T1_Skip_Spaces( parser );
 
     if ( parser->root.cursor >= limit )
     {
       FT_ERROR(( ""t42_parse_charstrings: out of bounds\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
     if ( ft_isdigit( *parser->root.cursor ) )
     {
       loader->num_glyphs = (FT_UInt)T1_ToInt( parser );
       if ( parser->root.error )
         return;
     }
     else if ( *parser->root.cursor == '<' )
     {
        
        
       FT_UInt  count = 0;
 
 
       T1_Skip_PS_Token( parser );
       if ( parser->root.error )
         return;
       T1_Skip_Spaces( parser );
       cur = parser->root.cursor;
 
       while ( parser->root.cursor < limit )
       {
         if ( *parser->root.cursor == '/' )
           count++;
         else if ( *parser->root.cursor == '>' )
         {
           loader->num_glyphs  = count;
           parser->root.cursor = cur;         
           break;
         }
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           return;
         T1_Skip_Spaces( parser );
       }
     }
     else
     {
       FT_ERROR(( ""t42_parse_charstrings: invalid token\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
     if ( parser->root.cursor >= limit )
     {
       FT_ERROR(( ""t42_parse_charstrings: out of bounds\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
      
 
     error = psaux->ps_table_funcs->init( code_table,
                                          loader->num_glyphs,
                                          memory );
     if ( error )
       goto Fail;
 
     error = psaux->ps_table_funcs->init( name_table,
                                          loader->num_glyphs,
                                          memory );
     if ( error )
       goto Fail;
 
      
      
 
     error = psaux->ps_table_funcs->init( swap_table, 4, memory );
     if ( error )
       goto Fail;
 
     n = 0;
 
     for (;;)
     {
        
        
 
       T1_Skip_Spaces( parser );
 
       cur = parser->root.cursor;
       if ( cur >= limit )
         break;
 
        
       if ( *cur   == 'e'          &&
            cur + 3 < limit        &&
            cur[1] == 'n'          &&
            cur[2] == 'd'          &&
            t42_is_space( cur[3] ) )
         break;
       if ( *cur == '>' )
         break;
 
       T1_Skip_PS_Token( parser );
       if ( parser->root.error )
         return;
 
       if ( *cur == '/' )
       {
          FT_PtrDist  len;
  
  
        if ( cur + 1 >= limit )
         if ( cur + 2 >= limit )
          {
            FT_ERROR(( ""t42_parse_charstrings: out of bounds\n"" ));
            error = FT_THROW( Invalid_File_Format );
           goto Fail;
         }
 
         cur++;                               
         len = parser->root.cursor - cur;
 
         error = T1_Add_Table( name_table, n, cur, len + 1 );
         if ( error )
           goto Fail;
 
          
         name_table->elements[n][len] = '\0';
 
          
         if ( *cur == '.'                                              &&
              ft_strcmp( "".notdef"",
                         (const char*)(name_table->elements[n]) ) == 0 )
         {
           notdef_index = n;
           notdef_found = 1;
         }
 
         T1_Skip_Spaces( parser );
 
         cur = parser->root.cursor;
 
         (void)T1_ToInt( parser );
         if ( parser->root.cursor >= limit )
         {
           FT_ERROR(( ""t42_parse_charstrings: out of bounds\n"" ));
           error = FT_THROW( Invalid_File_Format );
           goto Fail;
         }
 
         len = parser->root.cursor - cur;
 
         error = T1_Add_Table( code_table, n, cur, len + 1 );
         if ( error )
           goto Fail;
 
         code_table->elements[n][len] = '\0';
 
         n++;
         if ( n >= loader->num_glyphs )
           break;
       }
     }
 
     loader->num_glyphs = n;
 
     if ( !notdef_found )
     {
       FT_ERROR(( ""t42_parse_charstrings: no /.notdef glyph\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
      
     if ( ft_strcmp( (const char*)"".notdef"",
                     (const char*)name_table->elements[0] ) )
     {
        
        
        
        
        
 
        
       error = T1_Add_Table( swap_table, 0,
                             name_table->elements[0],
                             name_table->lengths [0] );
       if ( error )
         goto Fail;
 
        
       error = T1_Add_Table( swap_table, 1,
                             code_table->elements[0],
                             code_table->lengths [0] );
       if ( error )
         goto Fail;
 
        
       error = T1_Add_Table( swap_table, 2,
                             name_table->elements[notdef_index],
                             name_table->lengths [notdef_index] );
       if ( error )
         goto Fail;
 
        
       error = T1_Add_Table( swap_table, 3,
                             code_table->elements[notdef_index],
                             code_table->lengths [notdef_index] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( name_table, notdef_index,
                             swap_table->elements[0],
                             swap_table->lengths [0] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( code_table, notdef_index,
                             swap_table->elements[1],
                             swap_table->lengths [1] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( name_table, 0,
                             swap_table->elements[2],
                             swap_table->lengths [2] );
       if ( error )
         goto Fail;
 
       error = T1_Add_Table( code_table, 0,
                             swap_table->elements[3],
                             swap_table->lengths [3] );
       if ( error )
         goto Fail;
 
     }
 
     return;
 
   Fail:
     parser->root.error = error;
   }","[132, 131]","FreeType before 2.5.4 does not check for the end of the data during certain parsing actions, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted Type42 font, related to type42/t42parse.c and type1/t1load.c."
202593," static irqreturn_t i8042_interrupt(int irq, void *dev_id)
 {
 	struct i8042_port *port;
 	struct serio *serio;
 	unsigned long flags;
 	unsigned char str, data;
 	unsigned int dfl;
 	unsigned int port_no;
 	bool filtered;
 	int ret = 1;
 
 	spin_lock_irqsave(&i8042_lock, flags);
 
 	str = i8042_read_status();
 	if (unlikely(~str & I8042_STR_OBF)) {
 		spin_unlock_irqrestore(&i8042_lock, flags);
 		if (irq)
 			dbg(""Interrupt %d, without any data\n"", irq);
 		ret = 0;
 		goto out;
 	}
 
 	data = i8042_read_data();
 
 	if (i8042_mux_present && (str & I8042_STR_AUXDATA)) {
 		static unsigned long last_transmit;
 		static unsigned char last_str;
 
 		dfl = 0;
 		if (str & I8042_STR_MUXERR) {
 			dbg(""MUX error, status is %02x, data is %02x\n"",
 			    str, data);
  
 
 			switch (data) {
 				default:
 					if (time_before(jiffies, last_transmit + HZ/10)) {
 						str = last_str;
 						break;
 					}
 					 
 				case 0xfc:
 				case 0xfd:
 				case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break;
 				case 0xff: dfl = SERIO_PARITY;  data = 0xfe; break;
 			}
 		}
 
 		port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3);
 		last_str = str;
 		last_transmit = jiffies;
 	} else {
 
 		dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) |
 		      ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0);
 
 		port_no = (str & I8042_STR_AUXDATA) ?
 				I8042_AUX_PORT_NO : I8042_KBD_PORT_NO;
 	}
 
 	port = &i8042_ports[port_no];
 	serio = port->exists ? port->serio : NULL;
 
 	filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"",
 		   port_no, irq,
 		   dfl & SERIO_PARITY ? "", bad parity"" : """",
 		   dfl & SERIO_TIMEOUT ? "", timeout"" : """");
 
 	filtered = i8042_filter(data, str, serio);
  
  	spin_unlock_irqrestore(&i8042_lock, flags);
  
	if (likely(port->exists && !filtered))
 	if (likely(serio && !filtered))
  		serio_interrupt(serio, data, dfl);
  
   out:
 	return IRQ_RETVAL(ret);
 }","[74, 73]",drivers/input/serio/i8042.c in the Linux kernel before 4.12.4 allows attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact because the port->exists value can change after it is validated.
9280,"int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,
u32 result)
{
struct sk_buff *msg;
void *hdr;

msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
if (!msg)
return -ENOMEM;

hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
NFC_CMD_FW_DOWNLOAD);
if (!hdr)
goto free_msg;

if (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||
nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||
nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))
goto nla_put_failure;

genlmsg_end(msg, hdr);

genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);

return 0;

nla_put_failure:
free_msg:
nlmsg_free(msg);
return -EMSGSIZE;
}","[7, 23]",There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker to crash the Linux kernel by simulating a nfc device from user-space.
198032,"   T42_Face_Init( FT_Stream      stream,
                  FT_Face        t42face,        
                  FT_Int         face_index,
                  FT_Int         num_params,
                  FT_Parameter*  params )
   {
     T42_Face            face  = (T42_Face)t42face;
     FT_Error            error;
     FT_Service_PsCMaps  psnames;
     PSAux_Service       psaux;
     FT_Face             root  = (FT_Face)&face->root;
     T1_Font             type1 = &face->type1;
     PS_FontInfo         info  = &type1->font_info;
 
     FT_UNUSED( num_params );
     FT_UNUSED( params );
     FT_UNUSED( stream );
 
 
     face->ttf_face       = NULL;
     face->root.num_faces = 1;
 
     FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
     face->psnames = psnames;
 
     face->psaux = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
                                            ""psaux"" );
     psaux = (PSAux_Service)face->psaux;
     if ( !psaux )
     {
       FT_ERROR(( ""T42_Face_Init: cannot access `psaux' module\n"" ));
       error = FT_THROW( Missing_Module );
       goto Exit;
     }
 
     FT_TRACE2(( ""Type 42 driver\n"" ));
 
      
     error = T42_Open_Face( face );
     if ( error )
       goto Exit;
 
      
     if ( face_index < 0 )
       goto Exit;
 
      
     if ( face_index > 0 )
     {
       FT_ERROR(( ""T42_Face_Init: invalid face index\n"" ));
       error = FT_THROW( Invalid_Argument );
       goto Exit;
     }
 
      
 
      
      
 
     root->num_glyphs   = type1->num_glyphs;
     root->num_charmaps = 0;
     root->face_index   = 0;
 
     root->face_flags |= FT_FACE_FLAG_SCALABLE    |
                         FT_FACE_FLAG_HORIZONTAL  |
                         FT_FACE_FLAG_GLYPH_NAMES;
 
     if ( info->is_fixed_pitch )
       root->face_flags |= FT_FACE_FLAG_FIXED_WIDTH;
 
      
      
      
 #ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
     root->face_flags |= FT_FACE_FLAG_HINTER;
 #endif
 
      
 
      
      
     root->family_name = info->family_name;
      
     root->style_name = (char *)""Regular"";
     if ( root->family_name )
     {
       char*  full   = info->full_name;
       char*  family = root->family_name;
 
 
       if ( full )
       {
         while ( *full )
         {
           if ( *full == *family )
           {
             family++;
             full++;
           }
           else
           {
             if ( *full == ' ' || *full == '-' )
               full++;
             else if ( *family == ' ' || *family == '-' )
               family++;
             else
             {
               if ( !*family )
                 root->style_name = full;
               break;
             }
           }
         }
       }
     }
     else
     {
        
       if ( type1->font_name )
         root->family_name = type1->font_name;
     }
 
      
     root->num_fixed_sizes = 0;
     root->available_sizes = 0;
 
      
     {
        FT_Open_Args  args;
  
  
      args.flags       = FT_OPEN_MEMORY;
       args.flags       = FT_OPEN_MEMORY | FT_OPEN_DRIVER;
       args.driver      = FT_Get_Module( FT_FACE_LIBRARY( face ),
                                         ""truetype"" );
        args.memory_base = face->ttf_data;
        args.memory_size = face->ttf_size;
         args.flags     |= FT_OPEN_PARAMS;
         args.num_params = num_params;
         args.params     = params;
       }
 
       error = FT_Open_Face( FT_FACE_LIBRARY( face ),
                             &args, 0, &face->ttf_face );
     }","[133, 134, 135, 132]","type42/t42parse.c in FreeType before 2.5.4 does not consider that scanning can be incomplete without triggering an error, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted Type42 font."
5938,"static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,
struct iov_iter *from)
{
struct file *filp = iocb->ki_filp;
struct rpmsg_eptdev *eptdev = filp->private_data;
size_t len = iov_iter_count(from);
void *kbuf;
int ret;

kbuf = kzalloc(len, GFP_KERNEL);
if (!kbuf)
return -ENOMEM;

if (!copy_from_iter_full(kbuf, len, from))
return -EFAULT;

if (mutex_lock_interruptible(&eptdev->ept_lock)) {
ret = -ERESTARTSYS;
goto free_kbuf;
}

if (!eptdev->ept) {
ret = -EPIPE;
goto unlock_eptdev;
}

if (filp->f_flags & O_NONBLOCK)
ret = rpmsg_trysend(eptdev->ept, kbuf, len);
else
ret = rpmsg_send(eptdev->ept, kbuf, len);

unlock_eptdev:
mutex_unlock(&eptdev->ept_lock);

free_kbuf:
kfree(kbuf);
return ret < 0 ? ret : len;
}","[14, 15]","A memory leak in the rpmsg_eptdev_write_iter() function in drivers/rpmsg/rpmsg_char.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering copy_from_iter_full() failures, aka CID-bbe692e349e2."
200876," static int proc_keys_show(struct seq_file *m, void *v)
 {
 	struct rb_node *_p = v;
 	struct key *key = rb_entry(_p, struct key, serial_node);
 	struct timespec now;
  	unsigned long timo;
  	key_ref_t key_ref, skey_ref;
  	char xbuf[16];
 	short state;
  	int rc;
  
  	struct keyring_search_context ctx = {
 		.index_key.type		= key->type,
 		.index_key.description	= key->description,
 		.cred			= m->file->f_cred,
 		.match_data.cmp		= lookup_user_key_possessed,
 		.match_data.raw_data	= key,
 		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
 		.flags			= KEYRING_SEARCH_NO_STATE_CHECK,
 	};
 
 	key_ref = make_key_ref(key, 0);
 
 	 
 	if (key->perm & KEY_POS_VIEW) {
 		skey_ref = search_my_process_keyrings(&ctx);
 		if (!IS_ERR(skey_ref)) {
 			key_ref_put(skey_ref);
 			key_ref = make_key_ref(key, 1);
 		}
 	}
 
 	 
 	rc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);
 	if (rc < 0)
 		return 0;
 
 	now = current_kernel_time();
 
 	rcu_read_lock();
 
 	 
 	if (key->expiry == 0) {
 		memcpy(xbuf, ""perm"", 5);
 	} else if (now.tv_sec >= key->expiry) {
 		memcpy(xbuf, ""expd"", 5);
 	} else {
 		timo = key->expiry - now.tv_sec;
 
 		if (timo < 60)
 			sprintf(xbuf, ""%lus"", timo);
 		else if (timo < 60*60)
 			sprintf(xbuf, ""%lum"", timo / 60);
 		else if (timo < 60*60*24)
 			sprintf(xbuf, ""%luh"", timo / (60*60));
 		else if (timo < 60*60*24*7)
 			sprintf(xbuf, ""%lud"", timo / (60*60*24));
 		else
  			sprintf(xbuf, ""%luw"", timo / (60*60*24*7));
  	}
  
 	state = key_read_state(key);
 
  #define showflag(KEY, LETTER, FLAG) \
  	(test_bit(FLAG,	&(KEY)->flags) ? LETTER : '-')
  
  	seq_printf(m, ""%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s "",
  		   key->serial,
		   showflag(key, 'I', KEY_FLAG_INSTANTIATED),
 		   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',
  		   showflag(key, 'R', KEY_FLAG_REVOKED),
  		   showflag(key, 'D', KEY_FLAG_DEAD),
  		   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),
  		   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),
		   showflag(key, 'N', KEY_FLAG_NEGATIVE),
 		   state < 0 ? 'N' : '-',
  		   showflag(key, 'i', KEY_FLAG_INVALIDATED),
  		   refcount_read(&key->usage),
  		   xbuf,
 		   key->perm,
 		   from_kuid_munged(seq_user_ns(m), key->uid),
 		   from_kgid_munged(seq_user_ns(m), key->gid),
 		   key->type->name);
 
 #undef showflag
 
 	if (key->type->describe)
 		key->type->describe(key, m);
 	seq_putc(m, '\n');
 
 	rcu_read_unlock();
 	return 0;
 }","[9, 62, 63, 70, 76, 69, 75]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
197832," walk_string(fz_context *ctx, int uni, int remove, editable_str *str)
  {
         int rune;
  
       if (str->utf8 == NULL)
        if (str->utf8 == NULL || str->pos == -1)
                 return;
  
         do
 	{
 		char *s = &str->utf8[str->pos];
 		size_t len;
 		int n = fz_chartorune(&rune, s);
 		if (rune == uni)
 		{
 			 
 			str->pos += n;
 		}
 		else if (uni == 32) {
 			 
 			break;
 		}
 		else if (rune == 32) {
 			 
 		}
 		else
 		{
 			 
 			str->pos = -1;
 			break;
 		}
 		if (remove)
 		{
 			len = strlen(s+n);
 			memmove(s, s+n, len+1);
 			str->edited = 1;
 		}
 	}
 	while (rune != uni);
 }","[6, 5]",Artifex MuPDF before 1.16.0 has a heap-based buffer over-read in fz_chartorune in fitz/string.c because pdf/pdf-op-filter.c does not check for a missing string.
197824," static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)
  {
  	char tmp[256];
  	struct dpc_ctx *ctx = c;
 	if (ctx->cnt >= MAXADDRS) return -1;
  	switch (rr) {
  	case RR_A:
  		if (len != 4) return -1;
 		ctx->addrs[ctx->cnt].scopeid = 0;
 		memcpy(ctx->addrs[ctx->cnt++].addr, data, 4);
 		break;
 	case RR_AAAA:
 		if (len != 16) return -1;
 		ctx->addrs[ctx->cnt].family = AF_INET6;
 		ctx->addrs[ctx->cnt].scopeid = 0;
 		memcpy(ctx->addrs[ctx->cnt++].addr, data, 16);
 		break;
 	case RR_CNAME:
 		if (__dn_expand(packet, (const unsigned char *)packet + 512,
 		    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))
 			strcpy(ctx->canon, tmp);
 		break;
 	}
 	return 0;
 }",[5],"musl libc before 1.1.17 has a buffer overflow via crafted DNS replies because dns_parse_callback in network/lookup_name.c does not restrict the number of addresses, and thus an attacker can provide an unexpected number by sending A records in a reply to an AAAA query."
205983," void ChromeMetricsServiceClient::RegisterMetricsServiceProviders() {
   PrefService* local_state = g_browser_process->local_state();
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<SubprocessMetricsProvider>());
 
 #if BUILDFLAG(ENABLE_EXTENSIONS)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<ExtensionsMetricsProvider>(metrics_state_manager_));
 #endif
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::NetworkMetricsProvider>(
           content::CreateNetworkConnectionTrackerAsyncGetter(),
           std::make_unique<metrics::NetworkQualityEstimatorProviderImpl>()));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<OmniboxMetricsProvider>(
           base::Bind(&chrome::IsIncognitoSessionActive)));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<ChromeStabilityMetricsProvider>(local_state));
 
    metrics_service_->RegisterMetricsProvider(
        std::make_unique<metrics::GPUMetricsProvider>());
  
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::CPUMetricsProvider>());
 
    metrics_service_->RegisterMetricsProvider(
        std::make_unique<metrics::ScreenInfoMetricsProvider>());
  
   metrics_service_->RegisterMetricsProvider(CreateFileMetricsProvider(
       metrics_state_manager_->IsMetricsReportingEnabled()));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::DriveMetricsProvider>(
           chrome::FILE_LOCAL_STATE));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::CallStackProfileMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::SamplingMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<translate::TranslateRankerMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<metrics::ComponentMetricsProvider>(
           g_browser_process->component_updater()));
 
 #if defined(OS_ANDROID)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<AndroidMetricsProvider>());
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<PageLoadMetricsProvider>());
 #endif   
 
 #if defined(OS_WIN)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<GoogleUpdateMetricsProviderWin>());
 
   base::FilePath user_data_dir;
   base::FilePath crash_dir;
   if (!base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir) ||
       !base::PathService::Get(chrome::DIR_CRASH_DUMPS, &crash_dir)) {
     user_data_dir = base::FilePath();
     crash_dir = base::FilePath();
   }
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<browser_watcher::WatcherMetricsProviderWin>(
           chrome::GetBrowserExitCodesRegistryPath(), user_data_dir, crash_dir,
           base::Bind(&GetExecutableVersionDetails)));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<AntiVirusMetricsProvider>());
 #endif   
 
 #if BUILDFLAG(ENABLE_PLUGINS)
   plugin_metrics_provider_ = new PluginMetricsProvider(local_state);
   metrics_service_->RegisterMetricsProvider(
       std::unique_ptr<metrics::MetricsProvider>(plugin_metrics_provider_));
 #endif   
 
 #if defined(OS_CHROMEOS)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<ChromeOSMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<SigninStatusMetricsProviderChromeOS>());
 
   if (metrics::GetMetricsReportingDefaultState(local_state) ==
       metrics::EnableMetricsDefault::DEFAULT_UNKNOWN) {
     metrics::RecordMetricsReportingDefaultState(
         local_state, metrics::EnableMetricsDefault::OPT_OUT);
   }
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<chromeos::PrinterMetricsProvider>());
 #endif   
 
 #if !defined(OS_CHROMEOS)
   metrics_service_->RegisterMetricsProvider(
       SigninStatusMetricsProvider::CreateInstance(
           std::make_unique<ChromeSigninStatusMetricsProviderDelegate>()));
 #endif   
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<syncer::DeviceCountMetricsProvider>(
           base::Bind(&browser_sync::ChromeSyncClient::GetDeviceInfoTrackers)));
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<HttpsEngagementMetricsProvider>());
 
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<CertificateReportingMetricsProvider>());
 
 #if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<UpgradeMetricsProvider>());
 #endif   
 
 #if defined(OS_MACOSX)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<PowerMetricsProvider>());
 #endif
 
 #if BUILDFLAG(ENABLE_CROS_ASSISTANT)
   metrics_service_->RegisterMetricsProvider(
       std::make_unique<AssistantServiceMetricsProvider>());
 #endif   
 }","[27, 28, 29]",Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.
203188," static MagickBooleanType ReadPSDChannel(Image *image,
   const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info,
   const size_t channel,const PSDCompressionType compression,
   ExceptionInfo *exception)
 {
   Image
     *channel_image,
     *mask;
 
   MagickOffsetType
     offset;
 
   MagickBooleanType
     status;
 
   channel_image=image;
   mask=(Image *) NULL;
   if ((layer_info->channel_info[channel].type < -1) &&
       (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0))
     {
       const char
         *option;
 
        
       option=GetImageOption(image_info,""psd:preserve-opacity-mask"");
        if ((layer_info->channel_info[channel].type != -2) ||
            (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&
             (IsStringTrue(option) == MagickFalse)))
      {
        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
        return(MagickTrue);
      }
         {
           SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);
           return(MagickTrue);
         }
        mask=CloneImage(image,layer_info->mask.page.width,
          layer_info->mask.page.height,MagickFalse,exception);
        if (mask != (Image *) NULL)
         {
           SetImageType(mask,GrayscaleType,exception);
           channel_image=mask;
         }
     }
 
   offset=TellBlob(image);
   status=MagickFalse;
   switch(compression)
   {
     case Raw:
       status=ReadPSDChannelRaw(channel_image,psd_info->channels,
         layer_info->channel_info[channel].type,exception);
       break;
     case RLE:
       {
         MagickOffsetType
           *sizes;
 
         sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows);
         if (sizes == (MagickOffsetType *) NULL)
           ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
             image->filename);
         status=ReadPSDChannelRLE(channel_image,psd_info,
           layer_info->channel_info[channel].type,sizes,exception);
         sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);
       }
       break;
     case ZipWithPrediction:
     case ZipWithoutPrediction:
 #ifdef MAGICKCORE_ZLIB_DELEGATE
       status=ReadPSDChannelZip(channel_image,layer_info->channels,
         layer_info->channel_info[channel].type,compression,
         layer_info->channel_info[channel].size-2,exception);
 #else
       (void) ThrowMagickException(exception,GetMagickModule(),
           MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",
             ""'%s' (ZLIB)"",image->filename);
 #endif
       break;
     default:
       (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,
         ""CompressionNotSupported"",""'%.20g'"",(double) compression);
       break;
   }
 
   SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET);
   if (status == MagickFalse)
     {
       if (mask != (Image *) NULL)
         DestroyImage(mask);
       ThrowBinaryException(CoderError,""UnableToDecompressImage"",
         image->filename);
     }
   layer_info->mask.image=mask;
   return(status);
 }","[33, 34, 35, 36, 29, 30, 31, 32]","In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large *length* field in the header but does not contain sufficient backing data, is provided, the loop over *length* would consume huge CPU resources, since there is no EOF check inside the loop."
207816," OMX_ERRORTYPE  omx_video::get_parameter(OMX_IN OMX_HANDLETYPE     hComp,
         OMX_IN OMX_INDEXTYPE paramIndex,
         OMX_INOUT OMX_PTR     paramData)
 {
  (void)hComp;
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
  unsigned int height=0,width = 0;
 
     DEBUG_PRINT_LOW(""get_parameter:"");
  if (m_state == OMX_StateInvalid) {
         DEBUG_PRINT_ERROR(""ERROR: Get Param in Invalid State"");
  return OMX_ErrorInvalidState;
  }
  if (paramData == NULL) {
         DEBUG_PRINT_ERROR(""ERROR: Get Param in Invalid paramData"");
  return OMX_ErrorBadParameter;
  }
 
      switch ((int)paramIndex) {
          case OMX_IndexParamPortDefinition:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_PORTDEFINITIONTYPE);
                  OMX_PARAM_PORTDEFINITIONTYPE *portDefn;
                  portDefn = (OMX_PARAM_PORTDEFINITIONTYPE *) paramData;
  
                 DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamPortDefinition"");
  if (portDefn->nPortIndex == (OMX_U32) PORT_INDEX_IN) {
                     dev_get_buf_req (&m_sInPortDef.nBufferCountMin,
  &m_sInPortDef.nBufferCountActual,
  &m_sInPortDef.nBufferSize,
                         m_sInPortDef.nPortIndex);
                     DEBUG_PRINT_LOW(""m_sInPortDef: size = %u, min cnt = %u, actual cnt = %u"",
  (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountMin,
  (unsigned int)m_sInPortDef.nBufferCountActual);
                     memcpy(portDefn, &m_sInPortDef, sizeof(m_sInPortDef));
 #ifdef _ANDROID_ICS_
  if (meta_mode_enable) {
                         portDefn->nBufferSize = sizeof(encoder_media_buffer_type);
  }
  if (mUseProxyColorFormat) {
                         portDefn->format.video.eColorFormat =
  (OMX_COLOR_FORMATTYPE)QOMX_COLOR_FormatAndroidOpaque;
  }
 #endif
  } else if (portDefn->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {
  if (m_state != OMX_StateExecuting) {
                     dev_get_buf_req (&m_sOutPortDef.nBufferCountMin,
  &m_sOutPortDef.nBufferCountActual,
  &m_sOutPortDef.nBufferSize,
                             m_sOutPortDef.nPortIndex);
  }
                     DEBUG_PRINT_LOW(""m_sOutPortDef: size = %u, min cnt = %u, actual cnt = %u"",
  (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountMin,
  (unsigned int)m_sOutPortDef.nBufferCountActual);
                     memcpy(portDefn, &m_sOutPortDef, sizeof(m_sOutPortDef));
  } else {
                     DEBUG_PRINT_ERROR(""ERROR: GetParameter called on Bad Port Index"");
                     eRet = OMX_ErrorBadPortIndex;
  }
  break;
 
              }
          case OMX_IndexParamVideoInit:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PORT_PARAM_TYPE);
                  OMX_PORT_PARAM_TYPE *portParamType =
                      (OMX_PORT_PARAM_TYPE *) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoInit"");
 
                 memcpy(portParamType, &m_sPortParam, sizeof(m_sPortParam));
  break;
 
              }
          case OMX_IndexParamVideoPortFormat:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PORTFORMATTYPE);
                  OMX_VIDEO_PARAM_PORTFORMATTYPE *portFmt =
                      (OMX_VIDEO_PARAM_PORTFORMATTYPE *)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoPortFormat"");
 
  if (portFmt->nPortIndex == (OMX_U32) PORT_INDEX_IN) {
  unsigned index = portFmt->nIndex;
  int supportedFormats[] = {
  [0] = QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m,
  [1] = QOMX_COLOR_FormatAndroidOpaque,
  [2] = OMX_COLOR_FormatYUV420SemiPlanar,
  };
 
  if (index > (sizeof(supportedFormats)/sizeof(*supportedFormats) - 1))
                         eRet = OMX_ErrorNoMore;
  else {
                         memcpy(portFmt, &m_sInPortFormat, sizeof(m_sInPortFormat));
                         portFmt->nIndex = index;  
                         portFmt->eColorFormat = (OMX_COLOR_FORMATTYPE)supportedFormats[index];
  }
  } else if (portFmt->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {
                     memcpy(portFmt, &m_sOutPortFormat, sizeof(m_sOutPortFormat));
  } else {
                     DEBUG_PRINT_ERROR(""ERROR: GetParameter called on Bad Port Index"");
                     eRet = OMX_ErrorBadPortIndex;
  }
  break;
 
              }
          case OMX_IndexParamVideoBitrate:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_BITRATETYPE);
                  OMX_VIDEO_PARAM_BITRATETYPE* pParam = (OMX_VIDEO_PARAM_BITRATETYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoBitrate"");
  
  if (pParam->nPortIndex == (OMX_U32) PORT_INDEX_OUT) {
                     memcpy(pParam, &m_sParamBitrate, sizeof(m_sParamBitrate));
  } else {
                     DEBUG_PRINT_ERROR(""ERROR: GetParameter called on Bad Port Index"");
                     eRet = OMX_ErrorBadPortIndex;
  }
 
  break;
 
              }
          case OMX_IndexParamVideoMpeg4:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_MPEG4TYPE);
                  OMX_VIDEO_PARAM_MPEG4TYPE* pParam = (OMX_VIDEO_PARAM_MPEG4TYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoMpeg4"");
                  memcpy(pParam, &m_sParamMPEG4, sizeof(m_sParamMPEG4));
  break;
 
              }
          case OMX_IndexParamVideoH263:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_H263TYPE);
                  OMX_VIDEO_PARAM_H263TYPE* pParam = (OMX_VIDEO_PARAM_H263TYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoH263"");
                  memcpy(pParam, &m_sParamH263, sizeof(m_sParamH263));
  break;
 
              }
          case OMX_IndexParamVideoAvc:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_AVCTYPE);
                  OMX_VIDEO_PARAM_AVCTYPE* pParam = (OMX_VIDEO_PARAM_AVCTYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoAvc"");
                  memcpy(pParam, &m_sParamAVC, sizeof(m_sParamAVC));
  break;
 
              }
          case (OMX_INDEXTYPE)OMX_IndexParamVideoVp8:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_VP8TYPE);
                  OMX_VIDEO_PARAM_VP8TYPE* pParam = (OMX_VIDEO_PARAM_VP8TYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoVp8"");
                  memcpy(pParam, &m_sParamVP8, sizeof(m_sParamVP8));
  break;
 
              }
          case (OMX_INDEXTYPE)OMX_IndexParamVideoHevc:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_HEVCTYPE);
                  OMX_VIDEO_PARAM_HEVCTYPE* pParam = (OMX_VIDEO_PARAM_HEVCTYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoHevc"");
                  memcpy(pParam, &m_sParamHEVC, sizeof(m_sParamHEVC));
  break;
 
              }
          case OMX_IndexParamVideoProfileLevelQuerySupported:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PROFILELEVELTYPE);
                  OMX_VIDEO_PARAM_PROFILELEVELTYPE* pParam = (OMX_VIDEO_PARAM_PROFILELEVELTYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoProfileLevelQuerySupported"");
                  eRet = get_supported_profile_level(pParam);
  if (eRet && eRet != OMX_ErrorNoMore)
                     DEBUG_PRINT_ERROR(""Invalid entry returned from get_supported_profile_level %u, %u"",
  (unsigned int)pParam->eProfile, (unsigned int)pParam->eLevel);
  break;
 
              }
          case OMX_IndexParamVideoProfileLevelCurrent:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_PROFILELEVELTYPE);
                  OMX_VIDEO_PARAM_PROFILELEVELTYPE* pParam = (OMX_VIDEO_PARAM_PROFILELEVELTYPE*)paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoProfileLevelCurrent"");
                  memcpy(pParam, &m_sParamProfileLevel, sizeof(m_sParamProfileLevel));
  break;
  }
 
               
          case OMX_IndexParamAudioInit:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PORT_PARAM_TYPE);
                  OMX_PORT_PARAM_TYPE *audioPortParamType = (OMX_PORT_PARAM_TYPE *) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamAudioInit"");
                  memcpy(audioPortParamType, &m_sPortParam_audio, sizeof(m_sPortParam_audio));
  break;
  }
 
               
          case OMX_IndexParamImageInit:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PORT_PARAM_TYPE);
                  OMX_PORT_PARAM_TYPE *imagePortParamType = (OMX_PORT_PARAM_TYPE *) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamImageInit"");
                  memcpy(imagePortParamType, &m_sPortParam_img, sizeof(m_sPortParam_img));
  break;
 
  }
   
  case OMX_IndexParamOtherInit:
  {
                 DEBUG_PRINT_ERROR(""ERROR: get_parameter: OMX_IndexParamOtherInit %08x"", paramIndex);
                 eRet =OMX_ErrorUnsupportedIndex;
  break;
 
              }
          case OMX_IndexParamStandardComponentRole:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_COMPONENTROLETYPE);
                  OMX_PARAM_COMPONENTROLETYPE *comp_role;
                  comp_role = (OMX_PARAM_COMPONENTROLETYPE *) paramData;
                  comp_role->nVersion.nVersion = OMX_SPEC_VERSION;
                 comp_role->nSize = sizeof(*comp_role);
 
                 DEBUG_PRINT_LOW(""Getparameter: OMX_IndexParamStandardComponentRole %d"",paramIndex);
                 strlcpy((char*)comp_role->cRole,(const char*)m_cRole,OMX_MAX_STRINGNAME_SIZE);
  break;
  }
 
               
          case OMX_IndexParamPriorityMgmt:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PRIORITYMGMTTYPE);
                  OMX_PRIORITYMGMTTYPE *priorityMgmType = (OMX_PRIORITYMGMTTYPE *) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamPriorityMgmt"");
                  memcpy(priorityMgmType, &m_sPriorityMgmt, sizeof(m_sPriorityMgmt));
  break;
  }
 
               
          case OMX_IndexParamCompBufferSupplier:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_PARAM_BUFFERSUPPLIERTYPE);
                  OMX_PARAM_BUFFERSUPPLIERTYPE *bufferSupplierType = (OMX_PARAM_BUFFERSUPPLIERTYPE*) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamCompBufferSupplier"");
                  if (bufferSupplierType->nPortIndex ==(OMX_U32) PORT_INDEX_IN) {
                     memcpy(bufferSupplierType, &m_sInBufSupplier, sizeof(m_sInBufSupplier));
  } else if (bufferSupplierType->nPortIndex ==(OMX_U32) PORT_INDEX_OUT) {
                     memcpy(bufferSupplierType, &m_sOutBufSupplier, sizeof(m_sOutBufSupplier));
  } else {
                     DEBUG_PRINT_ERROR(""ERROR: GetParameter called on Bad Port Index"");
                     eRet = OMX_ErrorBadPortIndex;
  }
  break;
  }
 
  
          case OMX_IndexParamVideoQuantization:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_QUANTIZATIONTYPE);
                  OMX_VIDEO_PARAM_QUANTIZATIONTYPE *session_qp = (OMX_VIDEO_PARAM_QUANTIZATIONTYPE*) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_IndexParamVideoQuantization"");
                  memcpy(session_qp, &m_sSessionQuantization, sizeof(m_sSessionQuantization));
  break;
  }
 
  
          case OMX_QcomIndexParamVideoQPRange:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_QPRANGETYPE);
                  OMX_QCOM_VIDEO_PARAM_QPRANGETYPE *qp_range = (OMX_QCOM_VIDEO_PARAM_QPRANGETYPE*) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamVideoQPRange"");
                  memcpy(qp_range, &m_sSessionQPRange, sizeof(m_sSessionQPRange));
  break;
  }
 
  
          case OMX_IndexParamVideoErrorCorrection:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE);
                  OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE* errorresilience = (OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE*)paramData;
                  DEBUG_PRINT_LOW(""OMX_IndexParamVideoErrorCorrection"");
                  errorresilience->bEnableHEC = m_sErrorCorrection.bEnableHEC;
                 errorresilience->bEnableResync = m_sErrorCorrection.bEnableResync;
                 errorresilience->nResynchMarkerSpacing = m_sErrorCorrection.nResynchMarkerSpacing;
  break;
 
              }
          case OMX_IndexParamVideoIntraRefresh:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_VIDEO_PARAM_INTRAREFRESHTYPE);
                  OMX_VIDEO_PARAM_INTRAREFRESHTYPE* intrarefresh = (OMX_VIDEO_PARAM_INTRAREFRESHTYPE*)paramData;
                  DEBUG_PRINT_LOW(""OMX_IndexParamVideoIntraRefresh"");
                  DEBUG_PRINT_ERROR(""OMX_IndexParamVideoIntraRefresh GET"");
                 intrarefresh->eRefreshMode = m_sIntraRefresh.eRefreshMode;
                 intrarefresh->nCirMBs = m_sIntraRefresh.nCirMBs;
  break;
  }
  case OMX_QcomIndexPortDefn:
 
              break;
          case OMX_COMPONENT_CAPABILITY_TYPE_INDEX:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMXComponentCapabilityFlagsType);
                  OMXComponentCapabilityFlagsType *pParam = reinterpret_cast<OMXComponentCapabilityFlagsType*>(paramData);
                  DEBUG_PRINT_LOW(""get_parameter: OMX_COMPONENT_CAPABILITY_TYPE_INDEX"");
                  pParam->iIsOMXComponentMultiThreaded = OMX_TRUE;
                 pParam->iOMXComponentSupportsExternalOutputBufferAlloc = OMX_FALSE;
                 pParam->iOMXComponentSupportsExternalInputBufferAlloc = OMX_TRUE;
                 pParam->iOMXComponentSupportsMovableInputBuffers = OMX_TRUE;
                 pParam->iOMXComponentUsesNALStartCodes = OMX_TRUE;
                 pParam->iOMXComponentSupportsPartialFrames = OMX_FALSE;
                 pParam->iOMXComponentCanHandleIncompleteFrames = OMX_FALSE;
                 pParam->iOMXComponentUsesFullAVCFrames = OMX_FALSE;
                 m_use_input_pmem = OMX_TRUE;
                 DEBUG_PRINT_LOW(""Supporting capability index in encoder node"");
  break;
  }
 
  #if !defined(MAX_RES_720P) || defined(_MSM8974_)
          case OMX_QcomIndexParamIndexExtraDataType:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, QOMX_INDEXEXTRADATATYPE);
                  DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamIndexExtraDataType"");
                  QOMX_INDEXEXTRADATATYPE *pParam = (QOMX_INDEXEXTRADATATYPE *)paramData;
                  if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderSliceInfo) {
  if (pParam->nPortIndex == PORT_INDEX_OUT) {
                         pParam->bEnabled =
  (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_SLICEINFO);
                         DEBUG_PRINT_HIGH(""Slice Info extradata %d"", pParam->bEnabled);
  } else {
                         DEBUG_PRINT_ERROR(""get_parameter: slice information is ""
  ""valid for output port only"");
                         eRet =OMX_ErrorUnsupportedIndex;
  }
  } else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoEncoderMBInfo) {
  if (pParam->nPortIndex == PORT_INDEX_OUT) {
                         pParam->bEnabled =
  (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_MBINFO);
                         DEBUG_PRINT_HIGH(""MB Info extradata %d"", pParam->bEnabled);
  } else {
                         DEBUG_PRINT_ERROR(""get_parameter: MB information is ""
  ""valid for output port only"");
                         eRet = OMX_ErrorUnsupportedIndex;
  }
  }
 #ifndef _MSM8974_
  else if (pParam->nIndex == (OMX_INDEXTYPE)OMX_ExtraDataVideoLTRInfo) {
  if (pParam->nPortIndex == PORT_INDEX_OUT) {
                         pParam->bEnabled =
  (OMX_BOOL)(m_sExtraData & VEN_EXTRADATA_LTRINFO);
                         DEBUG_PRINT_HIGH(""LTR Info extradata %d"", pParam->bEnabled);
  } else {
                         DEBUG_PRINT_ERROR(""get_parameter: LTR information is ""
  ""valid for output port only"");
                         eRet = OMX_ErrorUnsupportedIndex;
  }
  }
 #endif
  else {
                     DEBUG_PRINT_ERROR(""get_parameter: unsupported extradata index (0x%x)"",
                             pParam->nIndex);
                     eRet = OMX_ErrorUnsupportedIndex;
  }
  break;
 
              }
          case QOMX_IndexParamVideoLTRCountRangeSupported:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_RANGETYPE);
                  DEBUG_PRINT_HIGH(""get_parameter: QOMX_IndexParamVideoLTRCountRangeSupported"");
                  QOMX_EXTNINDEX_RANGETYPE *pParam = (QOMX_EXTNINDEX_RANGETYPE *)paramData;
                  if (pParam->nPortIndex == PORT_INDEX_OUT) {
                     OMX_U32 min = 0, max = 0, step_size = 0;
  if (dev_get_capability_ltrcount(&min, &max, &step_size)) {
                         pParam->nMin = min;
                         pParam->nMax = max;
                         pParam->nStepSize = step_size;
  } else {
                         DEBUG_PRINT_ERROR(""get_parameter: get_capability_ltrcount failed"");
                         eRet = OMX_ErrorUndefined;
  }
  } else {
                     DEBUG_PRINT_ERROR(""LTR count range is valid for output port only"");
                     eRet = OMX_ErrorUnsupportedIndex;
  }
  }
 
              break;
          case OMX_QcomIndexParamVideoLTRCount:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_LTRCOUNT_TYPE);
                  DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamVideoLTRCount"");
                  OMX_QCOM_VIDEO_PARAM_LTRCOUNT_TYPE *pParam =
                          reinterpret_cast<OMX_QCOM_VIDEO_PARAM_LTRCOUNT_TYPE*>(paramData);
                 memcpy(pParam, &m_sParamLTRCount, sizeof(m_sParamLTRCount));
  break;
  }
 
  #endif
          case QOMX_IndexParamVideoSyntaxHdr:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_PARAMTYPE);
                  DEBUG_PRINT_HIGH(""QOMX_IndexParamVideoSyntaxHdr"");
                  QOMX_EXTNINDEX_PARAMTYPE* pParam =
                      reinterpret_cast<QOMX_EXTNINDEX_PARAMTYPE*>(paramData);
  if (pParam->pData == NULL) {
                     DEBUG_PRINT_ERROR(""Error: Data buffer is NULL"");
                     eRet = OMX_ErrorBadParameter;
  break;
  }
  if (get_syntaxhdr_enable == false) {
                     DEBUG_PRINT_ERROR(""ERROR: get_parameter: Get syntax header disabled"");
                     eRet = OMX_ErrorUnsupportedIndex;
  break;
  }
                 BITMASK_SET(&m_flags, OMX_COMPONENT_LOADED_START_PENDING);
  if (dev_loaded_start()) {
                     DEBUG_PRINT_LOW(""device start successful"");
  } else {
                     DEBUG_PRINT_ERROR(""device start failed"");
                     BITMASK_CLEAR(&m_flags, OMX_COMPONENT_LOADED_START_PENDING);
  return OMX_ErrorHardware;
  }
  if (dev_get_seq_hdr(pParam->pData,
  (unsigned)(pParam->nSize - sizeof(QOMX_EXTNINDEX_PARAMTYPE)),
  (unsigned *)(void *)&pParam->nDataSize)) {
                     DEBUG_PRINT_HIGH(""get syntax header successful (hdrlen = %u)"",
  (unsigned int)pParam->nDataSize);
  for (unsigned i = 0; i < pParam->nDataSize; i++) {
                         DEBUG_PRINT_LOW(""Header[%d] = %x"", i, *((char *)pParam->pData + i));
  }
  } else {
                     DEBUG_PRINT_ERROR(""Error returned from GetSyntaxHeader()"");
                     eRet = OMX_ErrorHardware;
  }
                 BITMASK_SET(&m_flags, OMX_COMPONENT_LOADED_STOP_PENDING);
  if (dev_loaded_stop()) {
                     DEBUG_PRINT_LOW(""device stop successful"");
  } else {
                     DEBUG_PRINT_ERROR(""device stop failed"");
                     BITMASK_CLEAR(&m_flags, OMX_COMPONENT_LOADED_STOP_PENDING);
                     eRet = OMX_ErrorHardware;
  }
  break;
 
              }
          case OMX_QcomIndexHierarchicalStructure:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, QOMX_VIDEO_HIERARCHICALLAYERS);
                  QOMX_VIDEO_HIERARCHICALLAYERS* hierp = (QOMX_VIDEO_HIERARCHICALLAYERS*) paramData;
                  DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexHierarchicalStructure"");
                  memcpy(hierp, &m_sHierLayers, sizeof(m_sHierLayers));
  break;
 
              }
          case OMX_QcomIndexParamPerfLevel:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_PERF_LEVEL);
                  OMX_U32 perflevel;
                  OMX_QCOM_VIDEO_PARAM_PERF_LEVEL *pParam =
                      reinterpret_cast<OMX_QCOM_VIDEO_PARAM_PERF_LEVEL*>(paramData);
                 DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamPerfLevel"");
  if (!dev_get_performance_level(&perflevel)) {
                     DEBUG_PRINT_ERROR(""Invalid entry returned from get_performance_level %d"",
                         pParam->ePerfLevel);
  } else {
                     pParam->ePerfLevel = (QOMX_VIDEO_PERF_LEVEL)perflevel;
  }
  break;
 
              }
          case OMX_QcomIndexParamH264VUITimingInfo:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO);
                  OMX_U32 enabled;
                  OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO *pParam =
                      reinterpret_cast<OMX_QCOM_VIDEO_PARAM_VUI_TIMING_INFO*>(paramData);
                 DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamH264VUITimingInfo"");
  if (!dev_get_vui_timing_info(&enabled)) {
                     DEBUG_PRINT_ERROR(""Invalid entry returned from get_vui_Timing_info %d"",
                         pParam->bEnable);
  } else {
                     pParam->bEnable = (OMX_BOOL)enabled;
  }
  break;
 
              }
          case OMX_QcomIndexParamPeakBitrate:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE);
                  OMX_U32 peakbitrate;
                  OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE *pParam =
                      reinterpret_cast<OMX_QCOM_VIDEO_PARAM_PEAK_BITRATE*>(paramData);
                 DEBUG_PRINT_LOW(""get_parameter: OMX_QcomIndexParamPeakBitrate"");
  if (!dev_get_peak_bitrate(&peakbitrate)) {
                     DEBUG_PRINT_ERROR(""Invalid entry returned from get_peak_bitrate %u"",
  (unsigned int)pParam->nPeakBitrate);
  } else {
                     pParam->nPeakBitrate = peakbitrate;
  }
  break;
 
              }
           case QOMX_IndexParamVideoInitialQp:
              {
                 VALIDATE_OMX_PARAM_DATA(paramData, QOMX_EXTNINDEX_VIDEO_INITIALQP);
                   QOMX_EXTNINDEX_VIDEO_INITIALQP* initqp =
                       reinterpret_cast<QOMX_EXTNINDEX_VIDEO_INITIALQP *>(paramData);
                       memcpy(initqp, &m_sParamInitqp, sizeof(m_sParamInitqp));
  break;
  }
  case OMX_IndexParamVideoSliceFMO:
  default:
  {
                 DEBUG_PRINT_LOW(""ERROR: get_parameter: unknown param %08x"", paramIndex);
                 eRet =OMX_ErrorUnsupportedIndex;
  break;
  }
 
  }
 
  return eRet;
 
 }","[22, 65, 76, 107, 123, 132, 141, 150, 159, 168, 180, 190, 200, 217, 231, 241, 258, 268, 278, 289, 302, 321, 368, 390, 401, 448, 457, 473, 489, 505]","The mm-video-v4l2 vidc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate certain OMX parameter data structures, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27532721."
199634," cifs_iovec_write(struct file *file, const struct iovec *iov,
  		 unsigned long nr_segs, loff_t *poffset)
  {
  	unsigned long nr_pages, i;
	size_t copied, len, cur_len;
 	size_t bytes, copied, len, cur_len;
  	ssize_t total_written = 0;
  	loff_t offset;
  	struct iov_iter it;
 	struct cifsFileInfo *open_file;
 	struct cifs_tcon *tcon;
 	struct cifs_sb_info *cifs_sb;
 	struct cifs_writedata *wdata, *tmp;
 	struct list_head wdata_list;
 	int rc;
 	pid_t pid;
 
 	len = iov_length(iov, nr_segs);
 	if (!len)
 		return 0;
 
 	rc = generic_write_checks(file, poffset, &len, 0);
 	if (rc)
 		return rc;
 
 	INIT_LIST_HEAD(&wdata_list);
 	cifs_sb = CIFS_SB(file->f_path.dentry->d_sb);
 	open_file = file->private_data;
 	tcon = tlink_tcon(open_file->tlink);
 
 	if (!tcon->ses->server->ops->async_writev)
 		return -ENOSYS;
 
 	offset = *poffset;
 
 	if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)
 		pid = open_file->pid;
 	else
 		pid = current->tgid;
 
 	iov_iter_init(&it, iov, nr_segs, len, 0);
 	do {
 		size_t save_len;
 
 		nr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);
 		wdata = cifs_writedata_alloc(nr_pages,
 					     cifs_uncached_writev_complete);
 		if (!wdata) {
 			rc = -ENOMEM;
 			break;
 		}
 
 		rc = cifs_write_allocate_pages(wdata->pages, nr_pages);
 		if (rc) {
 			kfree(wdata);
 			break;
 		}
  
  		save_len = cur_len;
  		for (i = 0; i < nr_pages; i++) {
			copied = min_t(const size_t, cur_len, PAGE_SIZE);
 			bytes = min_t(const size_t, cur_len, PAGE_SIZE);
  			copied = iov_iter_copy_from_user(wdata->pages[i], &it,
							 0, copied);
 							 0, bytes);
  			cur_len -= copied;
  			iov_iter_advance(&it, copied);
 			 
 			if (copied < bytes)
 				break;
  		}
  		cur_len = save_len - cur_len;
  
 		 
 		if (!cur_len) {
 			for (i = 0; i < nr_pages; i++)
 				put_page(wdata->pages[i]);
 			kfree(wdata);
 			rc = -EFAULT;
 			break;
 		}
 
 		 
 		for ( ; nr_pages > i + 1; nr_pages--)
 			put_page(wdata->pages[nr_pages - 1]);
 
  		wdata->sync_mode = WB_SYNC_ALL;
  		wdata->nr_pages = nr_pages;
  		wdata->offset = (__u64)offset;
 		wdata->cfile = cifsFileInfo_get(open_file);
 		wdata->pid = pid;
 		wdata->bytes = cur_len;
 		wdata->pagesz = PAGE_SIZE;
 		wdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE);
 		rc = cifs_uncached_retry_writev(wdata);
 		if (rc) {
 			kref_put(&wdata->refcount,
 				 cifs_uncached_writedata_release);
 			break;
 		}
 
 		list_add_tail(&wdata->list, &wdata_list);
 		offset += cur_len;
 		len -= cur_len;
 	} while (len > 0);
 
 	 
 	if (!list_empty(&wdata_list))
 		rc = 0;
 
 	 
 restart_loop:
 	list_for_each_entry_safe(wdata, tmp, &wdata_list, list) {
 		if (!rc) {
 			 
 			rc = wait_for_completion_killable(&wdata->done);
 			if (rc)
 				rc = -EINTR;
 			else if (wdata->result)
 				rc = wdata->result;
 			else
 				total_written += wdata->bytes;
 
 			 
 			if (rc == -EAGAIN) {
 				rc = cifs_uncached_retry_writev(wdata);
 				goto restart_loop;
 			}
 		}
 		list_del_init(&wdata->list);
 		kref_put(&wdata->refcount, cifs_uncached_writedata_release);
 	}
 
 	if (total_written > 0)
 		*poffset += total_written;
 
 	cifs_stats_bytes_written(tcon, total_written);
 	return total_written ? total_written : (ssize_t)rc;
 }","[6, 62, 65, 68, 69, 70, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 5, 61, 64]","The cifs_iovec_write function in fs/cifs/file.c in the Linux kernel through 3.13.5 does not properly handle uncached write operations that copy fewer than the requested number of bytes, which allows local users to obtain sensitive information from kernel memory, cause a denial of service (memory corruption and system crash), or possibly gain privileges via a writev system call with a crafted pointer."
198840," void mm_release(struct task_struct *tsk, struct mm_struct *mm)
  {
  	struct completion *vfork_done = tsk->vfork_done;
  
 	 
 #ifdef CONFIG_FUTEX
 	if (unlikely(tsk->robust_list))
 		exit_robust_list(tsk);
 #ifdef CONFIG_COMPAT
 	if (unlikely(tsk->compat_robust_list))
 		compat_exit_robust_list(tsk);
 #endif
 #endif
 
  	 
  	deactivate_mm(tsk, mm);
  
 	 
 	if (vfork_done) {
 		tsk->vfork_done = NULL;
 		complete(vfork_done);
 	}
 
 	 
 	if (tsk->clear_child_tid
 	    && !(tsk->flags & PF_SIGNALED)
 	    && atomic_read(&mm->mm_users) > 1) {
 		u32 __user * tidptr = tsk->clear_child_tid;
 		tsk->clear_child_tid = NULL;
 
 		 
 		put_user(0, tidptr);
 		sys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);
 	}
 }","[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]","The robust futex implementation in the Linux kernel before 2.6.28 does not properly handle processes that make exec system calls, which allows local users to cause a denial of service or possibly gain privileges by writing to a memory location in a child process."
199126," int ssl_parse_certificate( ssl_context *ssl )
 {
     int ret;
     size_t i, n;
 
     SSL_DEBUG_MSG( 2, ( ""=> parse certificate"" ) );
 
     if( ssl->endpoint == SSL_IS_SERVER &&
         ssl->authmode == SSL_VERIFY_NONE )
     {
         ssl->verify_result = BADCERT_SKIP_VERIFY;
         SSL_DEBUG_MSG( 2, ( ""<= skip parse certificate"" ) );
         ssl->state++;
         return( 0 );
     }
 
     if( ( ret = ssl_read_record( ssl ) ) != 0 )
     {
         SSL_DEBUG_RET( 1, ""ssl_read_record"", ret );
         return( ret );
     }
 
     ssl->state++;
 
      
     if( ssl->endpoint  == SSL_IS_SERVER &&
         ssl->minor_ver == SSL_MINOR_VERSION_0 )
     {
         if( ssl->in_msglen  == 2                        &&
             ssl->in_msgtype == SSL_MSG_ALERT            &&
             ssl->in_msg[0]  == SSL_ALERT_LEVEL_WARNING  &&
             ssl->in_msg[1]  == SSL_ALERT_MSG_NO_CERT )
         {
             SSL_DEBUG_MSG( 1, ( ""SSLv3 client has no certificate"" ) );
 
             ssl->verify_result = BADCERT_MISSING;
             if( ssl->authmode == SSL_VERIFY_OPTIONAL )
                 return( 0 );
             else
                 return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );
         }
     }
 
     if( ssl->endpoint  == SSL_IS_SERVER &&
         ssl->minor_ver != SSL_MINOR_VERSION_0 )
     {
         if( ssl->in_hslen   == 7                    &&
             ssl->in_msgtype == SSL_MSG_HANDSHAKE    &&
             ssl->in_msg[0]  == SSL_HS_CERTIFICATE   &&
             memcmp( ssl->in_msg + 4, ""\0\0\0"", 3 ) == 0 )
         {
             SSL_DEBUG_MSG( 1, ( ""TLSv1 client has no certificate"" ) );
 
             ssl->verify_result = BADCERT_MISSING;
             if( ssl->authmode == SSL_VERIFY_REQUIRED )
                 return( POLARSSL_ERR_SSL_NO_CLIENT_CERTIFICATE );
             else
                 return( 0 );
         }
     }
 
     if( ssl->in_msgtype != SSL_MSG_HANDSHAKE )
     {
         SSL_DEBUG_MSG( 1, ( ""bad certificate message"" ) );
         return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );
     }
 
     if( ssl->in_msg[0] != SSL_HS_CERTIFICATE || ssl->in_hslen < 10 )
     {
         SSL_DEBUG_MSG( 1, ( ""bad certificate message"" ) );
         return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );
     }
 
      
     n = ( ssl->in_msg[5] << 8 ) | ssl->in_msg[6];
 
     if( ssl->in_msg[4] != 0 || ssl->in_hslen != 7 + n )
     {
         SSL_DEBUG_MSG( 1, ( ""bad certificate message"" ) );
         return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );
     }
 
     if( ( ssl->session_negotiate->peer_cert = (x509_cert *) malloc(
                     sizeof( x509_cert ) ) ) == NULL )
     {
         SSL_DEBUG_MSG( 1, ( ""malloc(%d bytes) failed"",
                        sizeof( x509_cert ) ) );
         return( POLARSSL_ERR_SSL_MALLOC_FAILED );
     }
 
     memset( ssl->session_negotiate->peer_cert, 0, sizeof( x509_cert ) );
 
     i = 7;
 
     while( i < ssl->in_hslen )
     {
         if( ssl->in_msg[i] != 0 )
         {
             SSL_DEBUG_MSG( 1, ( ""bad certificate message"" ) );
             return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );
         }
 
         n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
             | (unsigned int) ssl->in_msg[i + 2];
         i += 3;
 
         if( n < 128 || i + n > ssl->in_hslen )
         {
             SSL_DEBUG_MSG( 1, ( ""bad certificate message"" ) );
              return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );
          }
  
        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,
                             n );
         ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,
                                  ssl->in_msg + i, n );
          if( ret != 0 )
          {
              SSL_DEBUG_RET( 1, "" x509parse_crt"", ret );
             return( ret );
         }
 
         i += n;
     }
 
     SSL_DEBUG_CRT( 3, ""peer certificate"", ssl->session_negotiate->peer_cert );
 
     if( ssl->authmode != SSL_VERIFY_NONE )
     {
         if( ssl->ca_chain == NULL )
         {
             SSL_DEBUG_MSG( 1, ( ""got no CA chain"" ) );
             return( POLARSSL_ERR_SSL_CA_CHAIN_REQUIRED );
         }
 
         ret = x509parse_verify( ssl->session_negotiate->peer_cert,
                                 ssl->ca_chain, ssl->ca_crl,
                                 ssl->peer_cn,  &ssl->verify_result,
                                 ssl->f_vrfy, ssl->p_vrfy );
 
         if( ret != 0 )
             SSL_DEBUG_RET( 1, ""x509_verify_cert"", ret );
 
         if( ssl->authmode != SSL_VERIFY_REQUIRED )
             ret = 0;
     }
 
     SSL_DEBUG_MSG( 2, ( ""<= parse certificate"" ) );
 
     return( ret );
 }","[115, 116, 113, 114]","The x509parse_crt function in x509.h in PolarSSL 1.1.x before 1.1.7 and 1.2.x before 1.2.8 does not properly parse certificate messages during the SSL/TLS handshake, which allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a certificate message that contains a PEM encoded certificate."
8627,"void Compute(OpKernelContext* const context) override {

const Tensor* node_ids_t;
OP_REQUIRES_OK(context, context->input(""node_ids"", &node_ids_t));
const auto node_ids = node_ids_t->vec<int32>();


const Tensor* gradients_t;
OP_REQUIRES_OK(context, context->input(""gradients"", &gradients_t));
const auto gradients = gradients_t->matrix<float>();


const Tensor* hessians_t;
OP_REQUIRES_OK(context, context->input(""hessians"", &hessians_t));
const auto hessians = hessians_t->matrix<float>();


const Tensor* feature_t;
OP_REQUIRES_OK(context, context->input(""feature"", &feature_t));
const auto feature = feature_t->matrix<int32>();


const int64_t batch_size = node_ids_t->dim_size(0);
const int64_t logits_dims = gradients_t->dim_size(1);
const int64_t hessians_dims = hessians_t->dim_size(1);
const int64_t stats_dims = logits_dims + hessians_dims;
const int64_t feature_dims = feature_t->dim_size(1);



Tensor temp_stats_double_t;
OP_REQUIRES_OK(
context, context->allocate_temp(
DT_DOUBLE,
{max_splits_, feature_dims, num_buckets_ + 1, stats_dims},
&temp_stats_double_t));
auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();
temp_stats_double.setZero();

for (int i = 0; i < batch_size; ++i) {
const int32_t node = node_ids(i);
for (int feature_dim = 0; feature_dim < feature_dims; ++feature_dim) {
const int32_t feature_value = feature(i, feature_dim);
const int32_t bucket =
(feature_value == -1) ? num_buckets_ : feature_value;
for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {
temp_stats_double(node, feature_dim, bucket, stat_dim) +=
gradients(i, stat_dim);
}
for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {
temp_stats_double(node, feature_dim, bucket, stat_dim) +=
hessians(i, stat_dim - logits_dims);
}
}
}


Tensor* output_stats_summary_t = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(
""stats_summary"", temp_stats_double_t.shape(),
&output_stats_summary_t));
output_stats_summary_t->tensor<float, 4>() =
temp_stats_double.template cast<float>();
}","[13, 42]","TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
207008," void HTMLCanvasElement::Dispose() {
    if (PlaceholderFrame())
      ReleasePlaceholderFrame();
  
    
   frame_dispatcher_ = nullptr;
 
    if (context_) {
      context_->DetachHost();
      context_ = nullptr;
   }
 
   if (canvas2d_bridge_) {
     canvas2d_bridge_->SetCanvasResourceHost(nullptr);
     canvas2d_bridge_ = nullptr;
   }
 
   if (gpu_memory_usage_) {
     DCHECK_GT(global_accelerated_context_count_, 0u);
     global_accelerated_context_count_--;
   }
   global_gpu_memory_usage_ -= gpu_memory_usage_;
 }","[5, 6, 7]",Use-after-garbage-collection in Blink in Google Chrome prior to 73.0.3683.75 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
203699,"  bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(
      WebKit::WebFrame* frame, WebKit::WebNode* node,
      scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {
  if (!InitPrintSettings(frame, node, false))
   if (!InitPrintSettings(frame))
      return false;
  
    DCHECK(!prepare->get());
   prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,
                                                  frame, node));
   UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),
                                        &print_pages_params_->params);
   Send(new PrintHostMsg_DidGetDocumentCookie(
         routing_id(), print_pages_params_->params.document_cookie));
   return true;
 }","[5, 4]",Use-after-free vulnerability in Google Chrome before 15.0.874.120 allows user-assisted remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to editing.
207566," WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,
                                  UWORD8 u1_nal_ref_idc,
  dec_struct_t *ps_dec  
  )
 {
  dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
  dec_pic_params_t *ps_pps;
  dec_seq_params_t *ps_seq;
  dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
  pocstruct_t s_tmp_poc;
     WORD32 i_delta_poc[2];
     WORD32 i4_poc = 0;
     UWORD16 u2_first_mb_in_slice, u2_frame_num;
     UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
     UWORD32 u4_idr_pic_id = 0;
     UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;
 
     UWORD8 u1_nal_unit_type;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     WORD8 i1_is_end_of_poc;
 
     WORD32 ret, end_of_frame;
     WORD32 prev_slice_err, num_mb_skipped;
     UWORD8 u1_mbaff;
  pocstruct_t *ps_cur_poc;
 
     UWORD32 u4_temp;
     WORD32 i_temp;
     UWORD32 u4_call_end_of_pic = 0;
 
   
     ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
     u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,
                                      pu4_bitstrm_buf);
  if(u2_first_mb_in_slice
  > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
  {
 
  return ERROR_CORRUPTED_SLICE;
  }
 
   
  if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)
  <= ps_dec->u2_cur_mb_addr) && (ps_dec->u2_cur_mb_addr != 0)
  && (ps_dec->u4_first_slice_in_pic != 0))
  {
  return ERROR_CORRUPTED_SLICE;
  }
 
     COPYTHECONTEXT(""SH: first_mb_in_slice"",u2_first_mb_in_slice);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
  if(u4_temp > 9)
  return ERROR_INV_SLC_TYPE_T;
 
     u1_slice_type = u4_temp;
     COPYTHECONTEXT(""SH: slice_type"",(u1_slice_type));
     ps_dec->u1_sl_typ_5_9 = 0;
   
   
   
  if(u1_slice_type > 4)
  {
         u1_slice_type -= 5;
         ps_dec->u1_sl_typ_5_9 = 1;
  }
 
  {
         UWORD32 skip;
 
  if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)
  || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))
  {
             UWORD32 u4_bit_stream_offset = 0;
 
  if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
  {
                 skip = 0;
 
                 ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
  }
  else if((I_SLICE == u1_slice_type)
  && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
  {
                 skip = 0;
 
                 ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
  }
  else
  {
                 skip = 1;
  }
 
   
  if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))
  {
                 skip = 0;
  }
 
  if(skip)
  {
                 ps_dec->u4_prev_nal_skipped = 1;
                 ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;
  return 0;
  }
  else
  {
   
  if(1 == ps_dec->u4_prev_nal_skipped)
  {
                     ps_dec->u4_return_to_app = 1;
  return 0;
  }
  }
  }
 
  }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if(u4_temp & MASK_ERR_PIC_SET_ID)
  return ERROR_INV_SPS_PPS_T;
   
     COPYTHECONTEXT(""SH: pic_parameter_set_id"", u4_temp);
     ps_pps = &ps_dec->ps_pps[u4_temp];
  if(FALSE == ps_pps->u1_is_valid)
  {
  return ERROR_INV_SPS_PPS_T;
  }
     ps_seq = ps_pps->ps_sps;
  if(!ps_seq)
  return ERROR_INV_SPS_PPS_T;
  if(FALSE == ps_seq->u1_is_valid)
  return ERROR_INV_SPS_PPS_T;
 
   
     u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,
                                          ps_seq->u1_bits_in_frm_num);
 
     COPYTHECONTEXT(""SH: frame_num"", u2_frame_num);
 
   
  if(!ps_seq->u1_frame_mbs_only_flag)
  {
 
         u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT(""SH: field_pic_flag"", u1_field_pic_flag);
         u1_bottom_field_flag = 0;
 
  if(u1_field_pic_flag)
  {
             ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;
             u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT(""SH: bottom_field_flag"", u1_bottom_field_flag);
 
  }
  else
  {
             ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
  }
  }
  else
  {
         u1_field_pic_flag = 0;
         u1_bottom_field_flag = 0;
 
         ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
  }
 
     u1_nal_unit_type = SLICE_NAL;
  if(u1_is_idr_slice)
  {
  if(0 == u1_field_pic_flag)
  {
             ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
  }
         u1_nal_unit_type = IDR_SLICE_NAL;
         u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,
                                    pu4_bitstrm_buf);
  if(u4_idr_pic_id > 65535)
  return ERROR_INV_SPS_PPS_T;
         COPYTHECONTEXT(""SH:  "", u4_idr_pic_id);
  }
 
   
     i_delta_poc[0] = i_delta_poc[1] = 0;
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
  if(u1_pic_order_cnt_type == 0)
  {
         i_temp = ih264d_get_bits_h264(
                         ps_bitstrm,
                         ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
  if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)
  return ERROR_INV_SPS_PPS_T;
         s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
         COPYTHECONTEXT(""SH: pic_order_cnt_lsb"", s_tmp_poc.i4_pic_order_cnt_lsb);
 
  if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
  {
             s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT(""SH: delta_pic_order_cnt_bottom"",
                             s_tmp_poc.i4_delta_pic_order_cnt_bottom);
  }
  }
 
     s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
  if(u1_pic_order_cnt_type == 1
  && (!ps_seq->u1_delta_pic_order_always_zero_flag))
  {
         s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,
                                                          pu4_bitstrm_buf);
         COPYTHECONTEXT(""SH: delta_pic_order_cnt[0]"",
                         s_tmp_poc.i4_delta_pic_order_cnt[0]);
 
  if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
  {
             s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(
                             pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT(""SH: delta_pic_order_cnt[1]"",
                             s_tmp_poc.i4_delta_pic_order_cnt[1]);
  }
  }
 
  if(ps_pps->u1_redundant_pic_cnt_present_flag)
  {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
  if(u4_temp > MAX_REDUNDANT_PIC_CNT)
  return ERROR_INV_SPS_PPS_T;
         u1_redundant_pic_cnt = u4_temp;
         COPYTHECONTEXT(""SH: redundant_pic_cnt"", u1_redundant_pic_cnt);
  }
 
   
   
   
     i1_is_end_of_poc = 0;
  if(!ps_dec->u1_first_slice_in_stream)
  {
         i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
  &s_tmp_poc, &ps_dec->s_cur_pic_poc,
                                             ps_cur_slice, u1_pic_order_cnt_type,
                                             u1_nal_unit_type, u4_idr_pic_id,
                                             u1_field_pic_flag,
                                             u1_bottom_field_flag);
 
   
  if((ps_dec->u4_first_slice_in_pic == 2) && (i1_is_end_of_poc == 0))
  {
   
             ps_dec->ps_dec_err_status->u1_err_flag |= REJECT_CUR_PIC;
             i1_is_end_of_poc = 1;
  }
  else
  {
   
             ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
  }
  }
 
   
   
   
   
     u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
     prev_slice_err = 0;
 
  if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
  {
  if(u2_frame_num != ps_dec->u2_prv_frame_num
  && ps_dec->u1_top_bottom_decoded != 0
  && ps_dec->u1_top_bottom_decoded
  != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
  {
             ps_dec->u1_dangling_field = 1;
  if(ps_dec->u4_first_slice_in_pic)
  {
                 prev_slice_err = 1;
  }
  else
  {
                 prev_slice_err = 2;
  }
 
  if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)
                 ps_cur_slice->u1_bottom_field_flag = 1;
  else
                 ps_cur_slice->u1_bottom_field_flag = 0;
 
             num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
             u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
  }
  else if(ps_dec->u4_first_slice_in_pic == 2)
  {
  if(u2_first_mb_in_slice > 0)
  {
                 prev_slice_err = 1;
                 num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
                 ps_cur_poc = &s_tmp_poc;
 
                 ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
                 ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
                 ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
                 ps_cur_slice->i4_pic_order_cnt_lsb =
                         s_tmp_poc.i4_pic_order_cnt_lsb;
                 ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
                 ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
                 ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
                 ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
  }
  }
  else
  {
 
  if(ps_dec->u4_first_slice_in_pic)
  {
   
                 prev_slice_err = 1;
                 num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
  }
  else
  {
   
                 prev_slice_err = 2;
                 num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  - ps_dec->u2_total_mbs_coded;
  }
             ps_cur_poc = &s_tmp_poc;
  }
  }
  else
  {
  if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
  {
             prev_slice_err = 2;
             num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)
  - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
  }
  else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
  {
  return ERROR_CORRUPTED_SLICE;
  }
  }
 
  if(prev_slice_err)
  {
         ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);
 
  if(ps_dec->u1_dangling_field == 1)
  {
             ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
             ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
             ps_dec->u2_prv_frame_num = u2_frame_num;
             ps_dec->u1_first_slice_in_stream = 0;
  return ERROR_DANGLING_FIELD_IN_PIC;
  }
 
  if(prev_slice_err == 2)
  {
             ps_dec->u1_first_slice_in_stream = 0;
  return ERROR_INCOMPLETE_FRAME;
  }
 
  if(ps_dec->u2_total_mbs_coded
  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
  {
   
             ps_dec->u1_first_slice_in_stream = 0;
  return ERROR_IN_LAST_SLICE_OF_PIC;
  }
 
  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
  {
             ih264d_err_pic_dispbuf_mgr(ps_dec);
  return ERROR_NEW_FRAME_EXPECTED;
  }
 
  if(ret != OK)
  return ret;
 
         i1_is_end_of_poc = 0;
 
      }
  
      if (ps_dec->u4_first_slice_in_pic == 0)
     {
          ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
     }
  
      ps_dec->u1_slice_header_done = 0;
  
   
   
   
  if(!ps_dec->u1_first_slice_in_stream)
  {
         UWORD8 uc_mbs_exceed = 0;
 
  if(ps_dec->u2_total_mbs_coded
  == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))
  {
   
  if(ps_dec->u4_first_slice_in_pic == 0)
                 uc_mbs_exceed = 1;
  }
 
  if(i1_is_end_of_poc || uc_mbs_exceed)
  {
 
  if(1 == ps_dec->u1_last_pic_not_decoded)
  {
                 ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
 
  if(ret != OK)
  return ret;
 
                 ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
  if(ret != OK)
  return ret;
 #if WIN32
                 H264_DEC_DEBUG_PRINT("" ------ PIC SKIPPED ------\n"");
 #endif
  return RET_LAST_SKIP;
  }
  else
  {
                 ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
  if(ret != OK)
  return ret;
  }
 
  }
  }
 
  if(u1_field_pic_flag)
  {
         ps_dec->u2_prv_frame_num = u2_frame_num;
  }
 
  if(ps_cur_slice->u1_mmco_equalto5)
  {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
 
  if(!ps_cur_slice->u1_field_pic_flag)  
  {
             i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
             i4_bot_field_order_poc =
                             ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
             i4_temp_poc = MIN(i4_top_field_order_poc,
                                      i4_bot_field_order_poc);
  }
  else if(!ps_cur_slice->u1_bottom_field_flag)
             i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
  else
             i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
 
         ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc
  - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc
  - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
  }
  if(ps_dec->u4_first_slice_in_pic == 2)
  {
         ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,
  &ps_dec->s_prev_pic_poc,
  &s_tmp_poc, ps_cur_slice, ps_pps,
                                           u1_nal_ref_idc,
                                           u1_bottom_field_flag,
                                           u1_field_pic_flag, &i4_poc);
  if(ret != OK)
  return ret;
   
  if(i4_poc >= ps_dec->i4_max_poc)
             ps_dec->i4_max_poc = i4_poc;
   
  if(i4_poc == 0)
  {
             ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
  + ps_dec->i4_max_poc
  + ps_dec->u1_max_dec_frame_buffering + 1;
             ps_dec->i4_max_poc = 0;
  }
  }
 
   
   
   
   
   
     ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
     ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
     ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
     ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
     ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
     ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
     ps_cur_slice->u1_slice_type = u1_slice_type;
     ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
 
     ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
     ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
     ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
     ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
 
  if(ps_seq->u1_frame_mbs_only_flag)
         ps_cur_slice->u1_direct_8x8_inference_flag =
                         ps_seq->u1_direct_8x8_inference_flag;
  else
         ps_cur_slice->u1_direct_8x8_inference_flag = 1;
 
  if(u1_slice_type == B_SLICE)
  {
         ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(
                         ps_bitstrm);
         COPYTHECONTEXT(""SH: direct_spatial_mv_pred_flag"",
                         ps_cur_slice->u1_direct_spatial_mv_pred_flag);
 
  if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
             ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
  else
             ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
  if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
  }
  else
  {
  if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
  }
 
  if(ps_dec->u4_first_slice_in_pic == 2)
  {
  if(u2_first_mb_in_slice == 0)
  {
             ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
  if(ret != OK)
  return ret;
  }
 
         ps_dec->u4_output_present = 0;
 
  {
             ih264d_get_next_display_field(ps_dec,
                                           ps_dec->ps_out_buffer,
  &(ps_dec->s_disp_op));
   
 
  if(0 != ps_dec->s_disp_op.u4_error_code)
  {
                 ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
  }
  else
                 ps_dec->u4_output_present = 1;
  }
  if(ps_dec->u1_separate_parse == 1)
  {
  if(ps_dec->u4_dec_thread_created == 0)
  {
                 ithread_create(ps_dec->pv_dec_thread_handle, NULL,
  (void *)ih264d_decode_picture_thread,
  (void *)ps_dec);
 
                 ps_dec->u4_dec_thread_created = 1;
  }
 
  if((ps_dec->u4_num_cores == 3) &&
  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
  && (ps_dec->u4_bs_deblk_thread_created == 0))
  {
                 ps_dec->u4_start_recon_deblk = 0;
                 ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
  (void *)ih264d_recon_deblk_thread,
  (void *)ps_dec);
                 ps_dec->u4_bs_deblk_thread_created = 1;
  }
  }
 
  }
 
   
  {
         UWORD8 uc_nofield_nombaff;
 
 
 
         uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)
  && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)
  && (u1_slice_type != B_SLICE)
  && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));
 
   
 
  if(uc_nofield_nombaff)
  {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
  }
  else
  {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
  }
 
 
  }
 
   
  {
  dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
  if(ps_err->u4_frm_sei_sync == u2_frame_num)
  {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
             ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
  }
         ps_err->u4_cur_frm = u2_frame_num;
  }
 
   
  {
         WORD32 i4_skip_b_pic, i4_skip_p_pic;
 
         i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)
  && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);
 
         i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)
  && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);
 
   
   
   
   
   
  if(i4_skip_b_pic)
  {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
   
   
             ps_dec->u1_last_pic_not_decoded = 1;
 
  return OK;
  }
   
   
   
   
   
  if(i4_skip_p_pic)
  {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
   
   
             ps_dec->u1_last_pic_not_decoded = 1;
 
  return OK;
  }
  }
 
  {
         UWORD16 u2_mb_x, u2_mb_y;
 
         ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice
  << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)
  - SUB_BLK_SIZE;
  if(u2_first_mb_in_slice)
  {
             UWORD8 u1_mb_aff;
             UWORD8 u1_field_pic;
             UWORD16 u2_frm_wd_in_mbs;
             u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
             u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
             u1_field_pic = ps_cur_slice->u1_field_pic_flag;
 
  {
                 UWORD32 x_offset;
                 UWORD32 y_offset;
                 UWORD32 u4_frame_stride;
  tfr_ctxt_t *ps_trns_addr;  
 
  if(ps_dec->u1_separate_parse)
  {
                     ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
  }
  else
  {
                     ps_trns_addr = &ps_dec->s_tran_addrecon;
  }
                 u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
                 u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
 
                 u2_mb_y <<= u1_mb_aff;
 
  if((u2_mb_x > u2_frm_wd_in_mbs - 1)
  || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
  {
  return ERROR_CORRUPTED_SLICE;
  }
 
                 u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
                 x_offset = u2_mb_x << 4;
                 y_offset = (u2_mb_y * u4_frame_stride) << 4;
 
                 ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset
  + y_offset;
 
                 u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
                 x_offset >>= 1;
                 y_offset = (u2_mb_y * u4_frame_stride) << 3;
 
                 x_offset *= YUV420SP_FACTOR;
 
                 ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset
  + y_offset;
                 ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset
  + y_offset;
 
                 ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
                 ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
                 ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
 
  if(ps_dec->u1_separate_parse == 1)
  {
                     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
  + (u2_first_mb_in_slice << u1_mb_aff);
  }
  else
  {
                         ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
  + (u2_first_mb_in_slice << u1_mb_aff);
  }
 
                 ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);
 
                 ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv
  + ((u2_first_mb_in_slice << u1_mb_aff) << 4);
  }
  }
  else
  {
  tfr_ctxt_t *ps_trns_addr;
 
  if(ps_dec->u1_separate_parse)
  {
                 ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
  }
  else
  {
                 ps_trns_addr = &ps_dec->s_tran_addrecon;
  }
 
             u2_mb_x = 0xffff;
             u2_mb_y = 0;
             ps_dec->u2_cur_mb_addr = 0;
             ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
             ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
             ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
             ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
             ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
             ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
             ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
             ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
  }
 
         ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
         ps_dec->u2_mbx =
  (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby =
  (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
         ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
         ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
  }
 
   
     ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;
 
     ps_dec->u1_B = (u1_slice_type == B_SLICE);
     ps_dec->u4_next_mb_skip = 0;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =
                     ps_dec->ps_cur_slice->u2_first_mb_in_slice;
     ps_dec->ps_parse_cur_slice->slice_type =
                     ps_dec->ps_cur_slice->u1_slice_type;
 
 
     ps_dec->u4_start_recon_deblk = 1;
  {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
  if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
  (0 == ps_dec->i4_display_delay))
  {
             num_entries = 1;
  }
         num_entries = ((2 * num_entries) + 1);
  if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
  {
             num_entries *= 2;
  }
 
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;
  }
 
  if(ps_dec->u1_separate_parse)
  {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
  }
  else
  {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
  }
 
  if(u1_slice_type == I_SLICE)
  {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;
 
         ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);
 
  if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
             ps_dec->i4_pic_type = I_SLICE;
 
  }
  else if(u1_slice_type == P_SLICE)
  {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
         ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
  if(ps_dec->i4_pic_type != B_SLICE)
             ps_dec->i4_pic_type = P_SLICE;
  }
  else if(u1_slice_type == B_SLICE)
  {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
         ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         ps_dec->i4_pic_type = B_SLICE;
  }
  else
  return ERROR_INV_SLC_TYPE_T;
 
  if(ps_dec->u1_slice_header_done)
  {
   
   
         ps_dec->u4_first_slice_in_pic = 0;
         ps_dec->u1_first_slice_in_stream = 0;
  }
 
 
      if(ret != OK)
          return ret;
  
    ps_dec->u2_cur_slice_num++;
       
      ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
      ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
   
 
  if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
  {
         ps_dec->u1_pic_decode_done = 1;
 
  }
 
  {
  dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
  if((ps_err->u1_err_flag & REJECT_PB_PICS)
  && (ps_err->u1_cur_pic_type == PIC_TYPE_I))
  {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
  }
  }
 
     PRINT_BIN_BIT_RATIO(ps_dec)
 
  return ret;
 }","[394, 396, 397, 875]","The ih264d decoder in mediaserver in Android 6.x before 2016-08-01 mishandles slice numbers, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28673410."
207515," UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
 {
  int n;
  int n_read = 0;
  int fd = uipc_main.ch[ch_id].fd;
  struct pollfd pfd;
     UNUSED(p_msg_evt);
 
  if (ch_id >= UIPC_CH_NUM)
  {
         BTIF_TRACE_ERROR(""UIPC_Read : invalid ch id %d"", ch_id);
  return 0;
  }
 
  if (fd == UIPC_DISCONNECTED)
  {
         BTIF_TRACE_ERROR(""UIPC_Read : channel %d closed"", ch_id);
  return 0;
  }
 
 
  while (n_read < (int)len)
  {
         pfd.fd = fd;
         pfd.events = POLLIN|POLLHUP;
 
  
           
        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
         if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)
          {
              BTIF_TRACE_EVENT(""poll timeout (%d ms)"", uipc_main.ch[ch_id].read_poll_tmo_ms);
              break;
  }
 
 
  if (pfd.revents & (POLLHUP|POLLNVAL) )
  {
             BTIF_TRACE_EVENT(""poll : channel detached remotely"");
             UIPC_LOCK();
             uipc_close_locked(ch_id);
             UIPC_UNLOCK();
 
              return 0;
          }
  
        n = recv(fd, p_buf+n_read, len-n_read, 0);
         n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));
  
  
  if (n == 0)
  {
             BTIF_TRACE_EVENT(""UIPC_Read : channel detached remotely"");
             UIPC_LOCK();
             uipc_close_locked(ch_id);
             UIPC_UNLOCK();
  return 0;
  }
 
  if (n < 0)
  {
             BTIF_TRACE_EVENT(""UIPC_Read : read failed (%s)"", strerror(errno));
  return 0;
  }
 
         n_read+=n;
 
  }
 
  return n_read;
 }","[30, 48, 29, 47]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
198533," static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)
 {
 	struct ctdb_tcp *ctcp = talloc_get_type(ctdb->private_data,
                                                 struct ctdb_tcp);
          ctdb_sock_addr sock;
         int lock_fd, i;
       const char *lock_path = ""/tmp/.ctdb_socket_lock"";
        const char *lock_path = VARDIR ""/run/ctdb/.socket_lock"";
         struct flock lock;
         int one = 1;
         int sock_size;
 	struct tevent_fd *fde;
 
 	 
 	if (ctdb->num_nodes == 0) {
 		DEBUG(DEBUG_CRIT,(""No nodes available to attempt bind to - is the nodes file empty?\n""));
 		return -1;
 	}
 
 	 
 	lock_fd = open(lock_path, O_RDWR|O_CREAT, 0666);
 	if (lock_fd == -1) {
 		DEBUG(DEBUG_CRIT,(""Unable to open %s\n"", lock_path));
 		return -1;
 	}
 
 	lock.l_type = F_WRLCK;
 	lock.l_whence = SEEK_SET;
 	lock.l_start = 0;
 	lock.l_len = 1;
 	lock.l_pid = 0;
 
 	if (fcntl(lock_fd, F_SETLKW, &lock) != 0) {
 		DEBUG(DEBUG_CRIT,(""Unable to lock %s\n"", lock_path));
 		close(lock_fd);
 		return -1;
 	}
 
 	for (i=0; i < ctdb->num_nodes; i++) {
 		if (ctdb->nodes[i]->flags & NODE_FLAGS_DELETED) {
 			continue;
 		}
 		ZERO_STRUCT(sock);
 		if (ctdb_tcp_get_address(ctdb,
 				ctdb->nodes[i]->address.address, 
 				&sock) != 0) {
 			continue;
 		}
 	
 		switch (sock.sa.sa_family) {
 		case AF_INET:
 			sock.ip.sin_port = htons(ctdb->nodes[i]->address.port);
 			sock_size = sizeof(sock.ip);
 			break;
 		case AF_INET6:
 			sock.ip6.sin6_port = htons(ctdb->nodes[i]->address.port);
 			sock_size = sizeof(sock.ip6);
 			break;
 		default:
 			DEBUG(DEBUG_ERR, (__location__ "" unknown family %u\n"",
 				sock.sa.sa_family));
 			continue;
 		}
 #ifdef HAVE_SOCK_SIN_LEN
 		sock.ip.sin_len = sock_size;
 #endif
 
 		ctcp->listen_fd = socket(sock.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
 		if (ctcp->listen_fd == -1) {
 			ctdb_set_error(ctdb, ""socket failed\n"");
 			continue;
 		}
 
 		set_close_on_exec(ctcp->listen_fd);
 
 	        setsockopt(ctcp->listen_fd,SOL_SOCKET,SO_REUSEADDR,(char *)&one,sizeof(one));
 
 		if (bind(ctcp->listen_fd, (struct sockaddr * )&sock, sock_size) == 0) {
 			break;
 		}
 
 		if (errno == EADDRNOTAVAIL) {
 			DEBUG(DEBUG_DEBUG,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
 					strerror(errno), errno));
 		} else {
 			DEBUG(DEBUG_ERR,(__location__ "" Failed to bind() to socket. %s(%d)\n"",
 					strerror(errno), errno));
 		}
 	}
 	
 	if (i == ctdb->num_nodes) {
 		DEBUG(DEBUG_CRIT,(""Unable to bind to any of the node addresses - giving up\n""));
 		goto failed;
 	}
 	ctdb->address.address = talloc_strdup(ctdb, ctdb->nodes[i]->address.address);
 	ctdb->address.port    = ctdb->nodes[i]->address.port;
 	ctdb->name = talloc_asprintf(ctdb, ""%s:%u"", 
 				     ctdb->address.address, 
 				     ctdb->address.port);
 	ctdb->pnn = ctdb->nodes[i]->pnn;
 	DEBUG(DEBUG_INFO,(""ctdb chose network address %s:%u pnn %u\n"", 
 		 ctdb->address.address, 
 		 ctdb->address.port, 
 		 ctdb->pnn));
 	
 	if (listen(ctcp->listen_fd, 10) == -1) {
 		goto failed;
 	}
 
 	fde = event_add_fd(ctdb->ev, ctcp, ctcp->listen_fd, EVENT_FD_READ,
 			   ctdb_listen_event, ctdb);
 	tevent_fd_set_auto_close(fde);
 
 	close(lock_fd);
 
 	return 0;
 	
 failed:
 	close(lock_fd);
 	close(ctcp->listen_fd);
 	ctcp->listen_fd = -1;
 	return -1;
 }","[8, 7]","ctdb before 2.3 in OpenSUSE 12.3 and 13.1 does not create temporary files securely, which has unspecified impact related to ""several temp file vulnerabilities"" in (1) tcp/tcp_connect.c, (2) server/eventscript.c, (3) tools/ctdb_diagnostics, (4) config/gdb_backtrace, and (5) include/ctdb_private.h."
7512,"send_ldap_result_ext(
Slapi_PBlock *pb,
int err,
char *matched,
char *text,
int nentries,
struct berval **urls,
BerElement *ber)
{
Slapi_Operation *operation;
passwdPolicy *pwpolicy = NULL;
Connection *conn = NULL;
Slapi_DN *sdn = NULL;
const char *dn = NULL;
ber_tag_t tag;
int flush_ber_element = 1;
ber_tag_t bind_method = 0;
int internal_op;
int i, rc, logit = 0;
char *pbtext;

slapi_pblock_get(pb, SLAPI_BIND_METHOD, &bind_method);
slapi_pblock_get(pb, SLAPI_OPERATION, &operation);
slapi_pblock_get(pb, SLAPI_CONNECTION, &conn);

if (text) {
pbtext = text;
} else {
slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &pbtext);
}

if (operation == NULL) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""No operation found: slapi_search_internal_set_pb was incomplete (invalid 'base' ?)\n"");
return;
}

if (operation->o_status == SLAPI_OP_STATUS_RESULT_SENT) {
return;
}

if (ber != NULL) {
flush_ber_element = 0;
}

if (err != LDAP_SUCCESS) {


if (err == LDAP_INVALID_CREDENTIALS || err == LDAP_INAPPROPRIATE_AUTH || err == LDAP_AUTH_METHOD_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_NOT_SUPPORTED || err == LDAP_STRONG_AUTH_REQUIRED || err == LDAP_CONFIDENTIALITY_REQUIRED || err == LDAP_INSUFFICIENT_ACCESS || err == LDAP_AUTH_UNKNOWN) {
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsSecurityErrors);
} else if (err != LDAP_REFERRAL && err != LDAP_OPT_REFERRALS && err != LDAP_PARTIAL_RESULTS) {





slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsErrors);
}
}

slapi_log_err(SLAPI_LOG_TRACE, ""send_ldap_result_ext"", ""=> %d:%s:%s\n"", err,
matched ? matched : """", text ? text : """");

switch (operation->o_tag) {
case LBER_DEFAULT:
tag = LBER_SEQUENCE;
break;

case LDAP_REQ_SEARCH:
tag = LDAP_RES_SEARCH_RESULT;
break;

case LDAP_REQ_DELETE:
tag = LDAP_RES_DELETE;
break;

case LDAP_REFERRAL:
if (conn && conn->c_ldapversion > LDAP_VERSION2) {
tag = LDAP_TAG_REFERRAL;
break;
}


default:
tag = operation->o_tag + 1;
break;
}

internal_op = operation_is_flag_set(operation, OP_FLAG_INTERNAL);
if ((conn == NULL) || (internal_op)) {
if (operation->o_result_handler != NULL) {
operation->o_result_handler(conn, operation, err,
matched, text, nentries, urls);
logit = 1;
}
goto log_and_return;
}



if ((err == LDAP_INVALID_CREDENTIALS) && (bind_method != LDAP_AUTH_SASL)) {
slapi_pblock_get(pb, SLAPI_TARGET_SDN, &sdn);
dn = slapi_sdn_get_dn(sdn);
pwpolicy = new_passwdPolicy(pb, dn);
if (pwpolicy && (pwpolicy->pw_lockout == 1)) {
if (update_pw_retry(pb) == LDAP_CONSTRAINT_VIOLATION && !pwpolicy->pw_is_legacy) {





err = LDAP_CONSTRAINT_VIOLATION;
text = ""Invalid credentials, you now have exceeded the password retry limit."";
}
}
}

if (ber == NULL) {
if ((ber = der_alloc()) == NULL) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""ber_alloc failed\n"");
goto log_and_return;
}
}


if (err == LDAP_ADMINLIMIT_EXCEEDED &&
conn->c_ldapversion < LDAP_VERSION3) {
err = LDAP_SIZELIMIT_EXCEEDED;
}

if (conn->c_ldapversion < LDAP_VERSION3 || urls == NULL) {
char *save, *buf = NULL;





if (urls != NULL) {
int len;


slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);




len = 10;
for (i = 0; urls[i] != NULL; i++) {
len += urls[i]->bv_len + 1;
}
if (text != NULL) {
len += strlen(text) + 1;
}




buf = slapi_ch_malloc(len);
*buf = '\0';
if (text != NULL) {
strcpy(buf, text);
strcat(buf, ""\n"");
}
strcat(buf, ""Referral:"");
for (i = 0; urls[i] != NULL; i++) {
strcat(buf, ""\n"");
strcat(buf, urls[i]->bv_val);
}
save = text;
text = buf;
}

if ((conn->c_ldapversion < LDAP_VERSION3 &&
err == LDAP_REFERRAL) ||
urls != NULL) {
err = LDAP_PARTIAL_RESULTS;
}
rc = ber_printf(ber, ""{it{ess"", operation->o_msgid, tag, err,
matched ? matched : """", pbtext ? pbtext : """");






if (rc != LBER_ERROR) {
rc = check_and_send_extended_result(pb, tag, ber);
}






if (rc != LBER_ERROR) {
rc = check_and_send_SASL_response(pb, tag, ber, conn);

}

if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}

if (buf != NULL) {
text = save;
slapi_ch_free((void **)&buf);
}
} else {




if (!config_check_referral_mode())
slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferrals);
rc = ber_printf(ber, ""{it{esst{s"", operation->o_msgid, tag, err,
matched ? matched : """", text ? text : """", LDAP_TAG_REFERRAL,
urls[0]->bv_val);
for (i = 1; urls[i] != NULL && rc != LBER_ERROR; i++) {
rc = ber_printf(ber, ""s"", urls[i]->bv_val);
}
if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}






if (rc != LBER_ERROR) {
rc = check_and_send_extended_result(pb, tag, ber);
}






if (rc != LBER_ERROR) {
rc = check_and_send_SASL_response(pb, tag, ber, conn);
}

if (rc != LBER_ERROR) {
rc = ber_printf(ber, ""}"");
}
}
if (err == LDAP_SUCCESS) {



if (process_read_entry_controls(pb, LDAP_CONTROL_PRE_READ_ENTRY)) {
err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;
goto log_and_return;
}
if (process_read_entry_controls(pb, LDAP_CONTROL_POST_READ_ENTRY)) {
err = LDAP_UNAVAILABLE_CRITICAL_EXTENSION;
goto log_and_return;
}
}
if (operation->o_results.result_controls != NULL && conn->c_ldapversion >= LDAP_VERSION3 && write_controls(ber, operation->o_results.result_controls) != 0) {
rc = (int)LBER_ERROR;
}

if (rc != LBER_ERROR) {
rc = ber_put_seq(ber);
}

if (rc == LBER_ERROR) {
slapi_log_err(SLAPI_LOG_ERR, ""send_ldap_result_ext"", ""ber_printf failed 1\n"");
if (flush_ber_element == 1) {

ber_free(ber, 1              );
}
goto log_and_return;
}

if (flush_ber_element) {

if (flush_ber(pb, conn, operation, ber, _LDAP_SEND_RESULT) == 0) {
logit = 1;
}
}

log_and_return:
operation->o_status = SLAPI_OP_STATUS_RESULT_SENT;

if (logit && (operation_is_flag_set(operation, OP_FLAG_ACTION_LOG_ACCESS) ||
(internal_op && config_get_plugin_logging()))) {
log_result(pb, operation, err, tag, nentries);
}

slapi_log_err(SLAPI_LOG_TRACE, ""send_ldap_result_ext"", ""<= %d\n"", err);
}",[29],"When binding against a DN during authentication, the reply from 389-ds-base will be different whether the DN exists or not. This can be used by an unauthenticated attacker to check the existence of an entry in the LDAP database."
200580," void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)
 {
 	struct snd_timer_instance *ti, *ts, *tmp;
 	unsigned long resolution, ticks;
 	struct list_head *p, *ack_list_head;
 	unsigned long flags;
 	int use_tasklet = 0;
 
 	if (timer == NULL)
 		return;
 
 	spin_lock_irqsave(&timer->lock, flags);
 
 	 
 	if (timer->hw.c_resolution)
 		resolution = timer->hw.c_resolution(timer);
 	else
 		resolution = timer->hw.resolution;
 
 	 
 	list_for_each_entry_safe(ti, tmp, &timer->active_list_head,
 				 active_list) {
 		if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING))
 			continue;
 		ti->pticks += ticks_left;
 		ti->resolution = resolution;
 		if (ti->cticks < ticks_left)
 			ti->cticks = 0;
 		else
 			ti->cticks -= ticks_left;
 		if (ti->cticks)  
 			continue;
 		if (ti->flags & SNDRV_TIMER_IFLG_AUTO) {
 			ti->cticks = ti->ticks;
  		} else {
  			ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING;
  			if (--timer->running)
				list_del(&ti->active_list);
 				list_del_init(&ti->active_list);
  		}
  		if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) ||
  		    (ti->flags & SNDRV_TIMER_IFLG_FAST))
 			ack_list_head = &timer->ack_list_head;
 		else
 			ack_list_head = &timer->sack_list_head;
 		if (list_empty(&ti->ack_list))
 			list_add_tail(&ti->ack_list, ack_list_head);
 		list_for_each_entry(ts, &ti->slave_active_head, active_list) {
 			ts->pticks = ti->pticks;
 			ts->resolution = resolution;
 			if (list_empty(&ts->ack_list))
 				list_add_tail(&ts->ack_list, ack_list_head);
 		}
 	}
 	if (timer->flags & SNDRV_TIMER_FLG_RESCHED)
 		snd_timer_reschedule(timer, timer->sticks);
 	if (timer->running) {
 		if (timer->hw.flags & SNDRV_TIMER_HW_STOP) {
 			timer->hw.stop(timer);
 			timer->flags |= SNDRV_TIMER_FLG_CHANGE;
 		}
 		if (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) ||
 		    (timer->flags & SNDRV_TIMER_FLG_CHANGE)) {
 			 
 			timer->flags &= ~SNDRV_TIMER_FLG_CHANGE;
 			timer->hw.start(timer);
 		}
 	} else {
 		timer->hw.stop(timer);
 	}
 
 	 
 	while (!list_empty(&timer->ack_list_head)) {
 		p = timer->ack_list_head.next;		 
 		ti = list_entry(p, struct snd_timer_instance, ack_list);
 
 		 
 		list_del_init(p);
 
 		ticks = ti->pticks;
 		ti->pticks = 0;
 
 		ti->flags |= SNDRV_TIMER_IFLG_CALLBACK;
 		spin_unlock(&timer->lock);
 		if (ti->callback)
 			ti->callback(ti, resolution, ticks);
 		spin_lock(&timer->lock);
 		ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK;
 	}
 
 	 
 	use_tasklet = !list_empty(&timer->sack_list_head);
 	spin_unlock_irqrestore(&timer->lock, flags);
 
 	if (use_tasklet)
 		tasklet_schedule(&timer->task_queue);
 }","[39, 38]","The snd_timer_interrupt function in sound/core/timer.c in the Linux kernel before 4.4.1 does not properly maintain a certain linked list, which allows local users to cause a denial of service (race condition and system crash) via a crafted ioctl call."
198608," XineramaXvShmPutImage(ClientPtr client)
  {
      REQUEST(xvShmPutImageReq);
      PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
     Bool send_event;
      Bool isRoot;
      int result, i, x, y;
  
      REQUEST_SIZE_MATCH(xvShmPutImageReq);
  
     send_event = stuff->send_event;
 
      result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
                                        XRC_DRAWABLE, client, DixWriteAccess);
      if (result != Success)
     result = dixLookupResourceByType((void **) &gc, stuff->gc,
                                      XRT_GC, client, DixReadAccess);
     if (result != Success)
         return result;
 
     result = dixLookupResourceByType((void **) &port, stuff->port,
                                      XvXRTPort, client, DixReadAccess);
     if (result != Success)
         return result;
 
     isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;
 
     x = stuff->drw_x;
     y = stuff->drw_y;
 
     FOR_NSCREENS_BACKWARD(i) {
         if (port->info[i].id) {
             stuff->drawable = draw->info[i].id;
             stuff->port = port->info[i].id;
             stuff->gc = gc->info[i].id;
             stuff->drw_x = x;
             stuff->drw_y = y;
             if (isRoot) {
                 stuff->drw_x -= screenInfo.screens[i]->x;
                 stuff->drw_y -= screenInfo.screens[i]->y;
             }
             stuff->send_event = (send_event && !i) ? 1 : 0;
 
             result = ProcXvShmPutImage(client);
         }
     }
     return result;
 }","[6, 12, 13, 5]",xorg-x11-server before 1.19.5 was missing length validation in RENDER extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.
31,"void gtkui_icmp_redir(void)
{
GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame;
gint response = 0;

DEBUG_MSG(""gtk_icmp_redir"");

dialog = gtk_dialog_new_with_buttons(""MITM Attack: ICMP Redirect"", GTK_WINDOW (window),
GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK,
GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL);
gtk_container_set_border_width(GTK_CONTAINER (dialog), 5);
gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE);

hbox = gtk_hbox_new (FALSE, 5);
gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0);
gtk_widget_show(hbox);

image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG);
gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1);
gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5);
gtk_widget_show(image);

frame = gtk_frame_new(""Gateway Information"");
gtk_container_set_border_width(GTK_CONTAINER (frame), 5);
gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0);
gtk_widget_show(frame);

table = gtk_table_new(2, 2, FALSE);
gtk_table_set_row_spacings(GTK_TABLE (table), 5);
gtk_table_set_col_spacings(GTK_TABLE (table), 5);
gtk_container_set_border_width(GTK_CONTAINER (table), 8);
gtk_container_add(GTK_CONTAINER (frame), table);
gtk_widget_show(table);

label = gtk_label_new(""MAC Address"");
gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);
gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0);
gtk_widget_show(label);

entry1 = gtk_entry_new();
gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN);
gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1);
gtk_widget_show(entry1);

label = gtk_label_new(""IP Address"");
gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5);
gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0);
gtk_widget_show(label);

entry2 = gtk_entry_new();
gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN);
gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2);
gtk_widget_show(entry2);

response = gtk_dialog_run(GTK_DIALOG(dialog));
if(response == GTK_RESPONSE_OK) {
gtk_widget_hide(dialog);

snprintf(params, 6, ""icmp:"");

strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN);
strncat(params, ""/"", PARAMS_LEN);
strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN);

gtkui_start_mitm();
}

gtk_widget_destroy(dialog);




}","[61, 62, 63]",An unchecked sscanf() call in ettercap before 0.7.5 allows an insecure temporary settings file to overflow a static-sized buffer on the stack.
208612,"    virtual void SetUp() {
    const tuple<int, int, SubpelVarianceFunctionType>& params =
        this->GetParam();
     const tuple<int, int, MseFunctionType>& params = this->GetParam();
      log2width_  = get<0>(params);
      width_ = 1 << log2width_;
      log2height_ = get<1>(params);
      height_ = 1 << log2height_;
    subpel_variance_ = get<2>(params);
     mse_ = get<2>(params);
  
      rnd(ACMRandom::DeterministicSeed());
      block_size_ = width_ * height_;
      src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];
     ref_ = new uint8_t[block_size_];
      ASSERT_TRUE(src_ != NULL);
    ASSERT_TRUE(sec_ != NULL);
      ASSERT_TRUE(ref_ != NULL);
    }","[4, 10, 17, 2, 3, 9, 15, 16, 19]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
202933," static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
 {
 	struct f_midi *midi = func_to_midi(f);
 	unsigned i;
 	int err;
 
 	 
 	if (intf != midi->ms_id)
 		return 0;
 
 	err = f_midi_start_ep(midi, f, midi->in_ep);
 	if (err)
 		return err;
 
 	err = f_midi_start_ep(midi, f, midi->out_ep);
 	if (err)
 		return err;
 
 	 
 	while (kfifo_avail(&midi->in_req_fifo)) {
 		struct usb_request *req =
 			midi_alloc_ep_req(midi->in_ep, midi->buflen);
 
 		if (req == NULL)
 			return -ENOMEM;
 
 		req->length = 0;
 		req->complete = f_midi_complete;
 
 		kfifo_put(&midi->in_req_fifo, req);
 	}
 
 	 
 	for (i = 0; i < midi->qlen && err == 0; i++) {
 		struct usb_request *req =
 			midi_alloc_ep_req(midi->out_ep, midi->buflen);
 
 		if (req == NULL)
 			return -ENOMEM;
 
 		req->complete = f_midi_complete;
 		err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);
  		if (err) {
  			ERROR(midi, ""%s: couldn't enqueue request: %d\n"",
  				    midi->out_ep->name, err);
			free_ep_req(midi->out_ep, req);
 			if (req->buf != NULL)
 				free_ep_req(midi->out_ep, req);
  			return err;
  		}
  	}
 
 	return 0;
 }","[47, 48, 46]","In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact."
203112," void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
 {
 	uint8_t *argb;
 	int x, y;
 	uint8_t *p;
 	uint8_t *out;
 	size_t out_size;
 
 	if (im == NULL) {
 		return;
 	}
 
 	if (!gdImageTrueColor(im)) {
 		zend_error(E_ERROR, ""Paletter image not supported by webp"");
 		return;
 	}
 
 	if (quantization == -1) {
  		quantization = 80;
  	}
  
 	if (overflow2(gdImageSX(im), 4)) {
 		return;
 	}
 
 	if (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {
 		return;
 	}
 
  	argb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));
  	if (!argb) {
  		return;
 	}
 	p = argb;
 	for (y = 0; y < gdImageSY(im); y++) {
 		for (x = 0; x < gdImageSX(im); x++) {
 			register int c;
 			register char a;
 			c = im->tpixels[y][x];
 			a = gdTrueColorGetAlpha(c);
 			if (a == 127) {
 				a = 0;
 			} else {
 				a = 255 - ((a << 1) + (a >> 6));
 			}
 			*(p++) = gdTrueColorGetRed(c);
 			*(p++) = gdTrueColorGetGreen(c);
 			*(p++) = gdTrueColorGetBlue(c); 
 			*(p++) = a;
 		}
 	}
 	out_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quantization, &out);
 	if (out_size == 0) {
 		zend_error(E_ERROR, ""gd-webp encoding failed"");
 		goto freeargb;
 	}
 	gdPutBuf(out, out_size, outfile);
 	free(out);
 
 freeargb:
 	gdFree(argb);
 }","[22, 23, 24, 25, 26, 27, 28, 29]","Integer overflow in the gdImageWebpCtx function in gd_webp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP through 7.0.11, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted imagewebp and imagedestroy calls."
202429," static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
 {
 	int ret;
 
 	if (pid > 0) {
 		rcu_read_lock();
 		ret = kill_pid_info(sig, info, find_vpid(pid));
 		rcu_read_unlock();
  		return ret;
  	}
  
 	 
 	if (pid == INT_MIN)
 		return -ESRCH;
 
  	read_lock(&tasklist_lock);
  	if (pid != -1) {
  		ret = __kill_pgrp_info(sig, info,
 				pid ? find_vpid(-pid) : task_pgrp(current));
 	} else {
 		int retval = 0, count = 0;
 		struct task_struct * p;
 
 		for_each_process(p) {
 			if (task_pid_vnr(p) > 1 &&
 					!same_thread_group(p, current)) {
 				int err = group_send_sig_info(sig, info, p);
 				++count;
 				if (err != -EPERM)
 					retval = err;
 			}
 		}
 		ret = count ? retval : -ESRCH;
 	}
 	read_unlock(&tasklist_lock);
 
 	return ret;
 }","[12, 13, 14, 15]","The kill_something_info function in kernel/signal.c in the Linux kernel before 4.13, when an unspecified architecture and compiler is used, might allow local users to cause a denial of service via an INT_MIN argument."
203033," static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)
 {
 	struct platform_device *pdev = cqspi->pdev;
 	struct device *dev = &pdev->dev;
 	struct cqspi_flash_pdata *f_pdata;
 	struct spi_nor *nor;
 	struct mtd_info *mtd;
 	unsigned int cs;
 	int i, ret;
 
 	 
 	for_each_available_child_of_node(dev->of_node, np) {
 		if (of_property_read_u32(np, ""reg"", &cs)) {
 			dev_err(dev, ""Couldn't determine chip select.\n"");
  			goto err;
  		}
  
		if (cs > CQSPI_MAX_CHIPSELECT) {
 		if (cs >= CQSPI_MAX_CHIPSELECT) {
  			dev_err(dev, ""Chip select %d out of range.\n"", cs);
  			goto err;
  		}
 
 		f_pdata = &cqspi->f_pdata[cs];
 		f_pdata->cqspi = cqspi;
 		f_pdata->cs = cs;
 
 		ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);
 		if (ret)
 			goto err;
 
 		nor = &f_pdata->nor;
 		mtd = &nor->mtd;
 
 		mtd->priv = nor;
 
 		nor->dev = dev;
 		spi_nor_set_flash_node(nor, np);
 		nor->priv = f_pdata;
 
 		nor->read_reg = cqspi_read_reg;
 		nor->write_reg = cqspi_write_reg;
 		nor->read = cqspi_read;
 		nor->write = cqspi_write;
 		nor->erase = cqspi_erase;
 		nor->prepare = cqspi_prep;
 		nor->unprepare = cqspi_unprep;
 
 		mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"",
 					   dev_name(dev), cs);
 		if (!mtd->name) {
 			ret = -ENOMEM;
 			goto err;
 		}
 
 		ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);
 		if (ret)
 			goto err;
 
 		ret = mtd_device_register(mtd, NULL, 0);
 		if (ret)
 			goto err;
 
 		f_pdata->registered = true;
 	}
 
 	return 0;
 
 err:
 	for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)
 		if (cqspi->f_pdata[i].registered)
 			mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
 	return ret;
 }","[19, 18]","In the Linux kernel before 4.9.6, there is an off by one in the drivers/mtd/spi-nor/cadence-quadspi.c cqspi_setup_flash() function. There are CQSPI_MAX_CHIPSELECT elements in the ->f_pdata array so the *>* should be *>=* instead."
202798,"  int fpga_reset(void)
  {
	if (!check_boco2()) {
		 
		return 0;
	}
	printf(""PCIe reset through GPIO7: "");
 	 
	kw_gpio_set_valid(KM_PEX_RST_GPIO_PIN, 1);
	kw_gpio_direction_output(KM_PEX_RST_GPIO_PIN, 1);
	kw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 0);
	udelay(1000*10);
	kw_gpio_set_value(KM_PEX_RST_GPIO_PIN, 1);
	printf("" done\n"");
  	return 0;
  }","[3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14]","Das U-Boot versions 2016.09 through 2019.07-rc4 can memset() too much data while reading a crafted ext4 filesystem, which results in a stack buffer overflow and likely code execution."
207542," OMX_ERRORTYPE  omx_video::allocate_output_buffer(
         OMX_IN OMX_HANDLETYPE            hComp,
         OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,
         OMX_IN OMX_U32                   port,
         OMX_IN OMX_PTR                   appData,
         OMX_IN OMX_U32                   bytes)
 {
  (void)hComp, (void)port;
     OMX_ERRORTYPE eRet = OMX_ErrorNone;
     OMX_BUFFERHEADERTYPE       *bufHdr= NULL;  
  unsigned                         i= 0;  
 #ifdef _MSM8974_
  int align_size;
 #endif
     DEBUG_PRINT_HIGH(""allocate_output_buffer()for %u bytes"", (unsigned int)bytes);
  if (!m_out_mem_ptr) {
  int nBufHdrSize        = 0;
         DEBUG_PRINT_HIGH(""%s: size = %u, actual cnt %u"", __FUNCTION__,
  (unsigned int)m_sOutPortDef.nBufferSize, (unsigned int)m_sOutPortDef.nBufferCountActual);
         nBufHdrSize        = m_sOutPortDef.nBufferCountActual * sizeof(OMX_BUFFERHEADERTYPE);
 
   
         m_out_mem_ptr = (OMX_BUFFERHEADERTYPE  *)calloc(nBufHdrSize,1);
 
 #ifdef USE_ION
         m_pOutput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sOutPortDef.nBufferCountActual);
  if (m_pOutput_ion == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pOutput_ion"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
         m_pOutput_pmem = (struct pmem *) calloc(sizeof(struct pmem), m_sOutPortDef.nBufferCountActual);
  if (m_pOutput_pmem == NULL) {
             DEBUG_PRINT_ERROR(""ERROR: calloc() Failed for m_pOutput_pmem"");
  return OMX_ErrorInsufficientResources;
  }
  if (m_out_mem_ptr && m_pOutput_pmem) {
             bufHdr          =  m_out_mem_ptr;
 
  for (i=0; i < m_sOutPortDef.nBufferCountActual ; i++) {
                 bufHdr->nSize              = sizeof(OMX_BUFFERHEADERTYPE);
                 bufHdr->nVersion.nVersion  = OMX_SPEC_VERSION;
                 bufHdr->nAllocLen          = bytes;
                 bufHdr->nFilledLen         = 0;
                 bufHdr->pAppPrivate        = appData;
                 bufHdr->nOutputPortIndex   = PORT_INDEX_OUT;
                 bufHdr->pOutputPortPrivate = (OMX_PTR)&m_pOutput_pmem[i];
                 bufHdr->pBuffer            = NULL;
                 bufHdr++;
                 m_pOutput_pmem[i].fd = -1;
 #ifdef USE_ION
                 m_pOutput_ion[i].ion_device_fd =-1;
                 m_pOutput_ion[i].fd_ion_data.fd=-1;
                 m_pOutput_ion[i].ion_alloc_data.handle = 0;
 #endif
  }
  } else {
             DEBUG_PRINT_ERROR(""ERROR: calloc() failed for m_out_mem_ptr/m_pOutput_pmem"");
             eRet = OMX_ErrorInsufficientResources;
  }
  }
 
     DEBUG_PRINT_HIGH(""actual cnt = %u"", (unsigned int)m_sOutPortDef.nBufferCountActual);
  for (i=0; i< m_sOutPortDef.nBufferCountActual; i++) {
  if (BITMASK_ABSENT(&m_out_bm_count,i)) {
             DEBUG_PRINT_LOW(""Found a Free Output Buffer %d"",i);
  break;
  }
  }
  if (eRet == OMX_ErrorNone) {
  if (i < m_sOutPortDef.nBufferCountActual) {
 #ifdef USE_ION
 #ifdef _MSM8974_
             align_size = ((m_sOutPortDef.nBufferSize + 4095)/4096) * 4096;
             m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(align_size,
  &m_pOutput_ion[i].ion_alloc_data,
  &m_pOutput_ion[i].fd_ion_data, ION_FLAG_CACHED);
 #else
             m_pOutput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sOutPortDef.nBufferSize,
  &m_pOutput_ion[i].ion_alloc_data,
  &m_pOutput_ion[i].fd_ion_data,ION_FLAG_CACHED);
 #endif
  if (m_pOutput_ion[i].ion_device_fd < 0) {
                 DEBUG_PRINT_ERROR(""ERROR:ION device open() Failed"");
  return OMX_ErrorInsufficientResources;
  }
 
             m_pOutput_pmem[i].fd = m_pOutput_ion[i].fd_ion_data.fd;
 #else
             m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
  if (m_pOutput_pmem[i].fd == 0) {
                 m_pOutput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);
  }
 
  if (m_pOutput_pmem[i].fd < 0) {
                 DEBUG_PRINT_ERROR(""ERROR: /dev/pmem_adsp open() failed"");
  return OMX_ErrorInsufficientResources;
  }
 #endif
             m_pOutput_pmem[i].size = m_sOutPortDef.nBufferSize;
             m_pOutput_pmem[i].offset = 0;
 
             m_pOutput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;
  if(!secure_session) {
 #ifdef _MSM8974_
                 m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                     align_size,PROT_READ|PROT_WRITE,
                     MAP_SHARED,m_pOutput_pmem[i].fd,0);
 #else
                 m_pOutput_pmem[i].buffer = (unsigned char *)mmap(NULL,
                     m_pOutput_pmem[i].size,PROT_READ|PROT_WRITE,
                     MAP_SHARED,m_pOutput_pmem[i].fd,0);
 #endif
  if (m_pOutput_pmem[i].buffer == MAP_FAILED) {
                     DEBUG_PRINT_ERROR(""ERROR: MMAP_FAILED in o/p alloc buffer"");
                 close (m_pOutput_pmem[i].fd);
 #ifdef USE_ION
                 free_ion_memory(&m_pOutput_ion[i]);
 #endif
  return OMX_ErrorInsufficientResources;
  }
  }
  else {
 
                  m_pOutput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));
                 (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);
                  native_handle_t *handle = native_handle_create(1, 0);
                  handle->data[0] = m_pOutput_pmem[i].fd;
                  char *data = (char*) m_pOutput_pmem[i].buffer;
                 OMX_U32 type = 1;
                 memcpy(data, &type, sizeof(OMX_U32));
                 memcpy(data + sizeof(OMX_U32), &handle, sizeof(native_handle_t*));
  }
 
  *bufferHdr = (m_out_mem_ptr + i );
  (*bufferHdr)->pBuffer = (OMX_U8 *)m_pOutput_pmem[i].buffer;
  (*bufferHdr)->pAppPrivate = appData;
 
             BITMASK_SET(&m_out_bm_count,i);
 
  if (dev_use_buf(&m_pOutput_pmem[i],PORT_INDEX_OUT,i) != true) {
                 DEBUG_PRINT_ERROR(""ERROR: dev_use_buf FAILED for o/p buf"");
  return OMX_ErrorInsufficientResources;
  }
  } else {
             DEBUG_PRINT_ERROR(""ERROR: All o/p buffers are allocated, invalid allocate buf call""
  ""for index [%d] actual: %u"", i, (unsigned int)m_sOutPortDef.nBufferCountActual);
  }
  }
 
  return eRet;
 }",[126],"mm-video-v4l2/vidc/venc/src/omx_video_base.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allocates an incorrect amount of memory, which allows attackers to gain privileges via a crafted application, aka internal bug 28816964."
206464," UserInitiatedInfo CreateUserInitiatedInfo(
     content::NavigationHandle* navigation_handle,
     PageLoadTracker* committed_load) {
   if (!navigation_handle->IsRendererInitiated())
      return UserInitiatedInfo::BrowserInitiated();
  
    return UserInitiatedInfo::RenderInitiated(
      navigation_handle->HasUserGesture());
       navigation_handle->HasUserGesture(),
       !navigation_handle->NavigationInputStart().is_null());
  }","[9, 10, 8]","Leaking of an SVG shadow tree leading to corruption of the DOM tree in Blink in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via a crafted HTML page."
5507,"Variant HHVM_FUNCTION(apc_store,
const Variant& key_or_array,
const Variant& var             ,
int64_t ttl          ) {
if (!apcExtension::Enable) return Variant(false);

if (key_or_array.isArray()) {
Array valuesArr = key_or_array.toArray();

for (ArrayIter iter(valuesArr); iter; ++iter) {
Variant key = iter.first();
if (!key.isString()) {
throw_invalid_argument(""apc key: (not a string)"");
return Variant(false);
}
Variant v = iter.second();
apc_store().set(key.toString(), v, ttl);
}

return Variant(ArrayData::Create());
}

if (!key_or_array.isString()) {
throw_invalid_argument(""apc key: (not a string)"");
return Variant(false);
}
String strKey = key_or_array.toString();
apc_store().set(strKey, var, ttl);
return Variant(true);
}","[17, 20, 28]","Various APC functions accept keys containing null bytes as input, leading to premature truncation of input. This issue affects HHVM versions prior to 3.30.12, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.23.1, as well as 4.24.0, 4.25.0, 4.26.0, 4.27.0, 4.28.0, and 4.28.1."
199879," static int cg_opendir(const char *path, struct fuse_file_info *fi)
 {
 	struct fuse_context *fc = fuse_get_context();
 	const char *cgroup;
 	struct file_info *dir_info;
 	char *controller = NULL;
 
 	if (!fc)
 		return -EIO;
 
 	if (strcmp(path, ""/cgroup"") == 0) {
 		cgroup = NULL;
 		controller = NULL;
 	} else {
 		controller = pick_controller_from_path(fc, path);
 		if (!controller)
 			return -EIO;
 
 		cgroup = find_cgroup_in_path(path);
 		if (!cgroup) {
 			 
 			cgroup = ""/"";
  		}
  	}
  
	if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
		return -EACCES;
 	if (cgroup) {
 		if (!caller_may_see_dir(fc->pid, controller, cgroup))
 			return -ENOENT;
 		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))
 			return -EACCES;
  	}
  
  	 
 	dir_info = malloc(sizeof(*dir_info));
 	if (!dir_info)
 		return -ENOMEM;
 	dir_info->controller = must_copy_string(controller);
 	dir_info->cgroup = must_copy_string(cgroup);
 	dir_info->type = LXC_TYPE_CGDIR;
 	dir_info->buf = NULL;
 	dir_info->file = NULL;
 	dir_info->buflen = 0;
 
 	fi->fh = (unsigned long)dir_info;
 	return 0;
 }","[28, 29, 30, 31, 32, 26, 27]","LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup."
205321," void AwContents::UpdateScrollState(gfx::Vector2d max_scroll_offset,
                                   gfx::SizeF contents_size_dip,
 void AwContents::UpdateScrollState(const gfx::Vector2d& max_scroll_offset,
                                    const gfx::SizeF& contents_size_dip,
                                     float page_scale_factor,
                                     float min_page_scale_factor,
                                     float max_page_scale_factor) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   JNIEnv* env = AttachCurrentThread();
   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
   if (obj.is_null())
     return;
   Java_AwContents_updateScrollState(env,
                                     obj.obj(),
                                     max_scroll_offset.x(),
                                     max_scroll_offset.y(),
                                     contents_size_dip.width(),
                                     contents_size_dip.height(),
                                     page_scale_factor,
                                     min_page_scale_factor,
                                      max_page_scale_factor);
  }","[3, 4, 2]","Use-after-free vulnerability in the StyleElement::removedFromDocument function in core/dom/StyleElement.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted JavaScript code that triggers tree mutation."
2773,"static void php_array_merge_recursive(PointerSet &seen, bool check,
Array &arr1, const Array& arr2) {
if (check) {
if (seen.find((void*)arr1.get()) != seen.end()) {
raise_warning(""array_merge_recursive(): recursion detected"");
return;
}
seen.insert((void*)arr1.get());
}

for (ArrayIter iter(arr2); iter; ++iter) {
Variant key(iter.first());
const Variant& value(iter.secondRef());
if (key.isNumeric()) {
arr1.appendWithRef(value);
} else if (arr1.exists(key, true)) {


Variant &v = arr1.lvalAt(key, AccessFlags::Key);
auto subarr1 = v.toArray().copy();
php_array_merge_recursive(seen, v.isReferenced(), subarr1,
value.toArray());
v.unset();
v = subarr1;
} else {
arr1.setWithRef(key, value, true);
}
}

if (check) {
seen.erase((void*)arr1.get());
}
}","[3, 4, 5, 6, 8, 21]","The array_*_recursive functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, related to recursion."
201125," llc_print(netdissect_options *ndo, const u_char *p, u_int length, u_int caplen,
 	  const struct lladdr_info *src, const struct lladdr_info *dst)
 {
 	uint8_t dsap_field, dsap, ssap_field, ssap;
 	uint16_t control;
 	int hdrlen;
 	int is_u;
 
 	if (caplen < 3) {
 		ND_PRINT((ndo, ""[|llc]""));
 		ND_DEFAULTPRINT((const u_char *)p, caplen);
 		return (caplen);
 	}
 	if (length < 3) {
 		ND_PRINT((ndo, ""[|llc]""));
 		ND_DEFAULTPRINT((const u_char *)p, caplen);
 		return (length);
 	}
 
 	dsap_field = *p;
 	ssap_field = *(p + 1);
 
 	 
 	control = *(p + 2);
 	if ((control & LLC_U_FMT) == LLC_U_FMT) {
 		 
 		is_u = 1;
 		hdrlen = 3;	 
 	} else {
 		 
 		if (caplen < 4) {
 			ND_PRINT((ndo, ""[|llc]""));
 			ND_DEFAULTPRINT((const u_char *)p, caplen);
 			return (caplen);
 		}
 		if (length < 4) {
 			ND_PRINT((ndo, ""[|llc]""));
 			ND_DEFAULTPRINT((const u_char *)p, caplen);
 			return (length);
 		}
 
 		 
 		control = EXTRACT_LE_16BITS(p + 2);
 		is_u = 0;
 		hdrlen = 4;	 
 	}
 
 	if (ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL) {
 		 
 
             if (ndo->ndo_eflag)
 		ND_PRINT((ndo, ""IPX 802.3: ""));
 
             ipx_print(ndo, p, length);
             return (0);		 
 	}
 
 	dsap = dsap_field & ~LLC_IG;
 	ssap = ssap_field & ~LLC_GSAP;
 
 	if (ndo->ndo_eflag) {
                 ND_PRINT((ndo, ""LLC, dsap %s (0x%02x) %s, ssap %s (0x%02x) %s"",
                        tok2str(llc_values, ""Unknown"", dsap),
                        dsap,
                        tok2str(llc_ig_flag_values, ""Unknown"", dsap_field & LLC_IG),
                        tok2str(llc_values, ""Unknown"", ssap),
                        ssap,
                        tok2str(llc_flag_values, ""Unknown"", ssap_field & LLC_GSAP)));
 
 		if (is_u) {
 			ND_PRINT((ndo, "", ctrl 0x%02x: "", control));
 		} else {
 			ND_PRINT((ndo, "", ctrl 0x%04x: "", control));
 		}
 	}
 
 	 
 	p += hdrlen;
 	length -= hdrlen;
 	caplen -= hdrlen;
 
 	if (ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP
 	    && control == LLC_UI) {
 		 
 		if (!snap_print(ndo, p, length, caplen, src, dst, 2)) {
 			 
 			return (-(hdrlen + 5));	 
 		} else
 			return (hdrlen + 5);	 
 	}
 
 	if (ssap == LLCSAP_8021D && dsap == LLCSAP_8021D &&
 	    control == LLC_UI) {
 		stp_print(ndo, p, length);
 		return (hdrlen);
 	}
 
 	if (ssap == LLCSAP_IP && dsap == LLCSAP_IP &&
 	    control == LLC_UI) {
 		 
 		ip_print(ndo, p, length);
 		return (hdrlen);
 	}
 
 	if (ssap == LLCSAP_IPX && dsap == LLCSAP_IPX &&
 	    control == LLC_UI) {
 		 
                 if (ndo->ndo_eflag)
                         ND_PRINT((ndo, ""IPX 802.2: ""));
 
 		ipx_print(ndo, p, length);
 		return (hdrlen);
 	}
 
 #ifdef ENABLE_SMB
 	if (ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI
 	    && (!(control & LLC_S_FMT) || control == LLC_U_FMT)) {
 		 
 		netbeui_print(ndo, control, p, length);
 		return (hdrlen);
 	}
  #endif
  	if (ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS
  	    && control == LLC_UI) {
		isoclns_print(ndo, p, length, caplen);
 		isoclns_print(ndo, p, length);
  		return (hdrlen);
  	}
  
 	if (!ndo->ndo_eflag) {
 		if (ssap == dsap) {
 			if (src == NULL || dst == NULL)
 				ND_PRINT((ndo, ""%s "", tok2str(llc_values, ""Unknown DSAP 0x%02x"", dsap)));
 			else
 				ND_PRINT((ndo, ""%s > %s %s "",
 						(src->addr_string)(ndo, src->addr),
 						(dst->addr_string)(ndo, dst->addr),
 						tok2str(llc_values, ""Unknown DSAP 0x%02x"", dsap)));
 		} else {
 			if (src == NULL || dst == NULL)
 				ND_PRINT((ndo, ""%s > %s "",
                                         tok2str(llc_values, ""Unknown SSAP 0x%02x"", ssap),
 					tok2str(llc_values, ""Unknown DSAP 0x%02x"", dsap)));
 			else
 				ND_PRINT((ndo, ""%s %s > %s %s "",
 					(src->addr_string)(ndo, src->addr),
                                         tok2str(llc_values, ""Unknown SSAP 0x%02x"", ssap),
 					(dst->addr_string)(ndo, dst->addr),
 					tok2str(llc_values, ""Unknown DSAP 0x%02x"", dsap)));
 		}
 	}
 
 	if (is_u) {
 		ND_PRINT((ndo, ""Unnumbered, %s, Flags [%s], length %u"",
                        tok2str(llc_cmd_values, ""%02x"", LLC_U_CMD(control)),
                        tok2str(llc_flag_values,""?"",(ssap_field & LLC_GSAP) | (control & LLC_U_POLL)),
                        length + hdrlen));
 
 		if ((control & ~LLC_U_POLL) == LLC_XID) {
 			if (length == 0) {
 				 
 				return (hdrlen);
 			}
 			if (caplen < 1) {
 				ND_PRINT((ndo, ""[|llc]""));
 				if (caplen > 0)
 					ND_DEFAULTPRINT((const u_char *)p, caplen);
 				return (hdrlen);
 			}
 			if (*p == LLC_XID_FI) {
 				if (caplen < 3 || length < 3) {
 					ND_PRINT((ndo, ""[|llc]""));
 					if (caplen > 0)
 						ND_DEFAULTPRINT((const u_char *)p, caplen);
 				} else
 					ND_PRINT((ndo, "": %02x %02x"", p[1], p[2]));
 				return (hdrlen);
 			}
 		}
 	} else {
 		if ((control & LLC_S_FMT) == LLC_S_FMT) {
 			ND_PRINT((ndo, ""Supervisory, %s, rcv seq %u, Flags [%s], length %u"",
 				tok2str(llc_supervisory_values,""?"",LLC_S_CMD(control)),
 				LLC_IS_NR(control),
 				tok2str(llc_flag_values,""?"",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),
                                 length + hdrlen));
 			return (hdrlen);	 
 		} else {
 			ND_PRINT((ndo, ""Information, send seq %u, rcv seq %u, Flags [%s], length %u"",
 				LLC_I_NS(control),
 				LLC_IS_NR(control),
 				tok2str(llc_flag_values,""?"",(ssap_field & LLC_GSAP) | (control & LLC_IS_POLL)),
                                 length + hdrlen));
 		}
 	}
 	return (-hdrlen);
 }","[126, 125]",The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().
8438,"static int DecodeBasicOcspResponse(byte* source, word32* ioIndex,
OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify)
{
int    length;
word32 idx = *ioIndex;
word32 end_index;
int    ret;
int    sigLength;

WOLFSSL_ENTER(""DecodeBasicOcspResponse"");
(void)heap;

if (GetSequence(source, &idx, &length, size) < 0)
return ASN_PARSE_E;

if (idx + length > size)
return ASN_INPUT_E;
end_index = idx + length;

if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0)
return ret;


if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0)
return ASN_PARSE_E;

ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL);
if (ret != 0)
return ret;

resp->sigSz = sigLength;
resp->sig = source + idx;
idx += sigLength;





#ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS
if (idx < end_index)
{
DecodedCert cert;

if (DecodeCerts(source, &idx, resp, size) < 0)
return ASN_PARSE_E;

InitDecodedCert(&cert, resp->cert, resp->certSz, heap);


ret = ParseCertRelative(&cert, CERT_TYPE,
noVerify ? NO_VERIFY : VERIFY_OCSP, cm);
if (ret < 0) {
WOLFSSL_MSG(""\tOCSP Responder certificate parsing failed"");
FreeDecodedCert(&cert);
return ret;
}

#ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK
if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) {
if (XMEMCMP(cert.subjectHash,
resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) {
WOLFSSL_MSG(""\tOCSP Response signed by issuer"");
}
else {
WOLFSSL_MSG(""\tOCSP Responder key usage check failed"");
#ifdef OPENSSL_EXTRA
resp->verifyError = OCSP_BAD_ISSUER;
#else
FreeDecodedCert(&cert);
return BAD_OCSP_RESPONDER;
#endif
}
}
#endif


ret = ConfirmSignature(&cert.sigCtx,
resp->response, resp->responseSz,
cert.publicKey, cert.pubKeySize, cert.keyOID,
resp->sig, resp->sigSz, resp->sigOID, NULL);

FreeDecodedCert(&cert);

if (ret != 0) {
WOLFSSL_MSG(""\tOCSP Confirm signature failed"");
return ASN_OCSP_CONFIRM_E;
}
}
else
#endif /* WOLFSSL_NO_OCSP_OPTIONAL_CERTS */
{
Signer* ca;
int sigValid = -1;

#ifndef NO_SKID
ca = GetCA(cm, resp->single->issuerKeyHash);
#else
ca = GetCA(cm, resp->single->issuerHash);
#endif

if (ca) {
SignatureCtx sigCtx;
InitSignatureCtx(&sigCtx, heap, INVALID_DEVID);


sigValid = ConfirmSignature(&sigCtx, resp->response,
resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID,
resp->sig, resp->sigSz, resp->sigOID, NULL);
}
if (ca == NULL || sigValid != 0) {
WOLFSSL_MSG(""\tOCSP Confirm signature failed"");
return ASN_OCSP_CONFIRM_E;
}

(void)noVerify;
}

*ioIndex = idx;
return 0;
}",[51],wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.
206252," bool ExtensionViewGuest::NavigateGuest(const std::string& src,
                                        bool force_navigation) {
   GURL url = extension_url_.Resolve(src);
  
  bool url_not_allowed = (url != GURL(url::kAboutBlankURL)) &&
      (url.GetOrigin() != extension_url_.GetOrigin());
   bool url_not_allowed = url != GURL(url::kAboutBlankURL) &&
                          !url::IsSameOriginWith(url, extension_url_);
    if (!url.is_valid() || url_not_allowed)
      return NavigateGuest(url::kAboutBlankURL, true  );
  
   if (!force_navigation && (url_ == url))
     return false;
 
   web_contents()->GetRenderProcessHost()->FilterURL(false, &url);
   web_contents()->GetController().LoadURL(url, content::Referrer(),
                                           ui::PAGE_TRANSITION_AUTO_TOPLEVEL,
                                           std::string());
 
   url_ = url;
   return true;
 }","[7, 8, 5, 6]","The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension."
208558," void Encoder::EncodeFrameInternal(const VideoSource &video,
  const unsigned long frame_flags) {
 
    vpx_codec_err_t res;
    const vpx_image_t *img = video.img();
  
  if (!encoder_.priv) {
    cfg_.g_w = img->d_w;
    cfg_.g_h = img->d_h;
    cfg_.g_timebase = video.timebase();
    cfg_.rc_twopass_stats_in = stats_->buf();
    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,
                             init_flags_);
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
  }
    if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {
      cfg_.g_w = img->d_w;
     cfg_.g_h = img->d_h;
     res = vpx_codec_enc_config_set(&encoder_, &cfg_);
     ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
 
    }
  
  REGISTER_STATE_CHECK(
      res = vpx_codec_encode(&encoder_,
                             video.img(), video.pts(), video.duration(),
   API_REGISTER_STATE_CHECK(
       res = vpx_codec_encode(&encoder_, img, video.pts(), video.duration(),
                               frame_flags, deadline_));
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
  }","[27, 28, 7, 8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
206530," base::string16 GetRelyingPartyIdString(
     AuthenticatorRequestDialogModel* dialog_model) {
   static constexpr char kRpIdUrlPrefix[] = ""https:"";
   static constexpr int kDialogWidth = 300;
    const auto& rp_id = dialog_model->relying_party_id();
    DCHECK(!rp_id.empty());
    GURL rp_id_url(kRpIdUrlPrefix + rp_id);
  auto max_static_string_length = gfx::GetStringWidthF(
      l10n_util::GetStringUTF16(IDS_WEBAUTHN_GENERIC_TITLE), gfx::FontList(),
      gfx::Typesetter::DEFAULT);
  return url_formatter::ElideHost(rp_id_url, gfx::FontList(),
                                  kDialogWidth - max_static_string_length);
   return url_formatter::ElideHost(rp_id_url, gfx::FontList(), kDialogWidth);
  }","[13, 8, 9, 10, 11, 12]","V8 in Google Chrome prior to 54.0.2840.98 for Mac, and 54.0.2840.99 for Windows, and 54.0.2840.100 for Linux, and 55.0.2883.84 for Android incorrectly applied type rules, which allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
198340," check_mountpoint(const char *progname, char *mountpoint)
 {
 	int err;
         struct stat statbuf;
  
          
       err = stat(mountpoint, &statbuf);
        err = stat(""."", &statbuf);
         if (err) {
                 fprintf(stderr, ""%s: failed to stat %s: %s\n"", progname,
                                 mountpoint, strerror(errno));
 		return EX_USAGE;
 	}
 
 	if (!S_ISDIR(statbuf.st_mode)) {
 		fprintf(stderr, ""%s: %s is not a directory!"", progname,
 				mountpoint);
 		return EX_USAGE;
 	}
 
 #if CIFS_LEGACY_SETUID_CHECK
 	 
 	if (!getuid() || geteuid())
 		return 0;
 
 	if (statbuf.st_uid != getuid()) {
 		fprintf(stderr, ""%s: %s is not owned by user\n"", progname,
 			mountpoint);
 		return EX_USAGE;
 	}
 
 	if ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {
 		fprintf(stderr, ""%s: invalid permissions on %s\n"", progname,
 			mountpoint);
 		return EX_USAGE;
 	}
 #endif  
 
 	return 0;
 }","[8, 7]","client/mount.cifs.c in mount.cifs in smbfs in Samba 3.0.22, 3.0.28a, 3.2.3, 3.3.2, 3.4.0, and 3.4.5 allows local users to mount a CIFS share on an arbitrary mountpoint, and gain privileges, via a symlink attack on the mountpoint directory file."
200956," rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)
 {
 	register const struct ip6_rthdr *dp;
 	register const struct ip6_rthdr0 *dp0;
 	register const u_char *ep;
 	int i, len;
  	register const struct in6_addr *addr;
  
  	dp = (const struct ip6_rthdr *)bp;
	len = dp->ip6r_len;
  
  	 
  	ep = ndo->ndo_snapend;
  
  	ND_TCHECK(dp->ip6r_segleft);
  
 	len = dp->ip6r_len;
  	ND_PRINT((ndo, ""srcrt (len=%d"", dp->ip6r_len));	 
  	ND_PRINT((ndo, "", type=%d"", dp->ip6r_type));
  	ND_PRINT((ndo, "", segleft=%d"", dp->ip6r_segleft));
 
 	switch (dp->ip6r_type) {
 	case IPV6_RTHDR_TYPE_0:
 	case IPV6_RTHDR_TYPE_2:			 
 		dp0 = (const struct ip6_rthdr0 *)dp;
 
 		ND_TCHECK(dp0->ip6r0_reserved);
 		if (dp0->ip6r0_reserved || ndo->ndo_vflag) {
 			ND_PRINT((ndo, "", rsv=0x%0x"",
 			    EXTRACT_32BITS(&dp0->ip6r0_reserved)));
 		}
 
 		if (len % 2 == 1)
 			goto trunc;
 		len >>= 1;
 		addr = &dp0->ip6r0_addr[0];
 		for (i = 0; i < len; i++) {
 			if ((const u_char *)(addr + 1) > ep)
 				goto trunc;
 
 			ND_PRINT((ndo, "", [%d]%s"", i, ip6addr_string(ndo, addr)));
 			addr++;
 		}
 		 
 		ND_PRINT((ndo, "") ""));
 		return((dp0->ip6r0_len + 1) << 3);
 		break;
 	default:
 		goto trunc;
 		break;
 	}
 
  trunc:
 	ND_PRINT((ndo, ""[|srcrt]""));
 	return -1;
 }","[17, 10]",The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().
207005," void DownloadResourceHandler::OnRequestRedirected(
     const net::RedirectInfo& redirect_info,
     network::ResourceResponse* response,
     std::unique_ptr<ResourceController> controller) {
   url::Origin new_origin(url::Origin::Create(redirect_info.new_url));
   if (!follow_cross_origin_redirects_ &&
       !first_origin_.IsSameOriginWith(new_origin)) {
     base::PostTaskWithTraits(
         FROM_HERE, {BrowserThread::UI},
         base::BindOnce(
             &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),
             Referrer(GURL(redirect_info.new_referrer),
                       Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                           redirect_info.new_referrer_policy)),
              GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
             GetRequestInfo()->GetWebContentsGetterForRequest(),
             GetRequestInfo()->frame_tree_node_id()));
      controller->Cancel();
      return;
    }
   if (core_.OnRequestRedirected()) {
     controller->Resume();
   } else {
     controller->Cancel();
   }
 }","[17, 18, 16]",Inappropriate implementation in Blink in Google Chrome prior to 74.0.3729.108 allowed a remote attacker to bypass same origin policy via a crafted HTML page.
201526," alloc_limit_assert (char *fn_name, size_t size)
  {
      if (alloc_limit && size > alloc_limit)
      {
	alloc_limit_failure (fn_name, size);
	exit (-1);
         alloc_limit_failure (fn_name, size);
         exit (-1);
      }
  }","[7, 8, 5, 6]","An issue was discovered in tnef before 1.4.13. Several Integer Overflows, which can lead to Heap Overflows, have been identified in the functions that wrap memory allocation."
198732," static int ip_options_get_finish(struct net *net, struct ip_options **optp,
				 struct ip_options *opt, int optlen)
 static int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,
 				 struct ip_options_rcu *opt, int optlen)
  {
  	while (optlen & 3)
		opt->__data[optlen++] = IPOPT_END;
	opt->optlen = optlen;
	if (optlen && ip_options_compile(net, opt, NULL)) {
 		opt->opt.__data[optlen++] = IPOPT_END;
 	opt->opt.optlen = optlen;
 	if (optlen && ip_options_compile(net, &opt->opt, NULL)) {
  		kfree(opt);
  		return -EINVAL;
  	}
 	kfree(*optp);
 	*optp = opt;
  	return 0;
  }","[3, 4, 10, 11, 12, 2, 7, 8, 9]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
7468,"bool PackLinuxElf32::canPack()
{
union {
unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];

} u;
COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)

fi->seek(0, SEEK_SET);
fi->readx(u.buf, sizeof(u.buf));
fi->seek(0, SEEK_SET);
Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;


if (checkEhdr(ehdr) != 0)
return false;


if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {
throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'"");
return false;
}
if (e_phoff != sizeof(*ehdr)) {
throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'"");
return false;
}

unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];

Elf32_Phdr const *phdr = phdri;
note_size = 0;
for (unsigned j=0; j < e_phnum; ++phdr, ++j) {
if (j >= 14) {
throwCantPack(""too many ElfXX_Phdr; try '--force-execve'"");
return false;
}
unsigned const p_type = get_te32(&phdr->p_type);
unsigned const p_offset = get_te32(&phdr->p_offset);
if (1!=exetype && PT_LOAD32 == p_type) {
exetype = 1;
load_va = get_te32(&phdr->p_vaddr);




unsigned const off = ~page_mask & (unsigned)load_va;

if (off && off == p_offset) {
throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'"");

return false;
}
if (0 != p_offset) {
throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'"");
return false;
}
hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));
}
if (PT_NOTE32 == p_type) {
unsigned const x = get_te32(&phdr->p_memsz);
if ( sizeof(elfout.notes) < x
||  (sizeof(elfout.notes) < (note_size += x)) ) {
throwCantPack(""PT_NOTEs too big; try '--force-execve'"");
return false;
}
if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) {
struct {
struct Elf32_Nhdr nhdr;
char name[8];
unsigned body;
} note;
memset(&note, 0, sizeof(note));
fi->seek(p_offset, SEEK_SET);
fi->readx(&note, sizeof(note));
fi->seek(0, SEEK_SET);
if (4==get_te32(&note.nhdr.descsz)
&&  1==get_te32(&note.nhdr.type)

&&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)
&&  0==strcmp(osabi_note, (char const *)&note.name[0])
) {
osabi0 = ei_osabi;
}
}
}
}
if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0
||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) {
unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);
if (Elf32_Ehdr::EM_ARM==e_machine
&&   (EF_ARM_EABI_VER5==arm_eabi
||  EF_ARM_EABI_VER4==arm_eabi ) ) {

ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;
}
else {
osabi0 = opt->o_unix.osabi0;
}
}
if (osabi0!=ei_osabi) {
return false;
}















if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {

alloc_file_image(file_image, file_size);
fi->seek(0, SEEK_SET);
fi->readx(file_image, file_size);
memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));
phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);
shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);

sec_strndx = NULL;
shstrtab = NULL;
if (e_shnum) {
unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx);
if (e_shstrndx) {
if (e_shnum <= e_shstrndx) {
char msg[40]; snprintf(msg, sizeof(msg),
""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum);
throwCantPack(msg);
}
sec_strndx = &shdri[e_shstrndx];
unsigned const sh_offset = get_te32(&sec_strndx->sh_offset);
if ((u32_t)file_size <= sh_offset) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad .e_shstrndx->sh_offset %#x"", sh_offset);
throwCantPack(msg);
}
shstrtab = (char const *)(sh_offset + file_image);
}
sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);
if (sec_dynsym) {
unsigned const sh_link = get_te32(&sec_dynsym->sh_link);
if (e_shnum <= sh_link) {
char msg[50]; snprintf(msg, sizeof(msg),
""bad SHT_DYNSYM.sh_link %#x"", sh_link);
}
sec_dynstr = &shdri[sh_link];
}

if (sec_strndx) {
unsigned const sh_name = get_te32(&sec_strndx->sh_name);
if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)
|| (u32_t)file_size <= sh_name
|| (sh_name
&& 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name]))
) {
throwCantPack(""bad e_shstrndx"");
}
}
}

Elf32_Phdr const *pload_x0(0);
phdr= phdri;
for (int j= e_phnum; --j>=0; ++phdr)
if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {
dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);
invert_pt_dynamic(dynseg);
}
else if (PT_LOAD32==get_te32(&phdr->p_type)) {
if (!pload_x0
&&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags)
) {
pload_x0 = phdr;
}
check_pt_load(phdr);
}

dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);
dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);

if (opt->o_unix.force_pie
||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)
||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),
(int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))
||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),
(int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {
is_pie = true;
goto proceed;
}


















if (                      elf_find_dynamic(upx_dt_init)) {
if (this->e_machine!=Elf32_Ehdr::EM_386
&&  this->e_machine!=Elf32_Ehdr::EM_MIPS
&&  this->e_machine!=Elf32_Ehdr::EM_ARM)
goto abandon;
if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {
throwCantPack(""DT_TEXTREL found; re-compile with -fPIC"");
goto abandon;
}
if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) {

if (Elf32_Ehdr::EM_ARM == e_machine
&&  !opt->o_unix.android_shlib
) {
opt->info_mode++;
info(""note: use --android-shlib if appropriate"");
opt->info_mode--;
}
}
Elf32_Shdr const *shdr = shdri;
xct_va = ~0u;
if (e_shnum) {
for (int j= e_shnum; --j>=0; ++shdr) {
unsigned const sh_type = get_te32(&shdr->sh_type);
if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {
xct_va = umin(xct_va, get_te32(&shdr->sh_addr));
}

if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init
&&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)
||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init
&&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {
unsigned user_init_ava = get_te32(&shdr->sh_addr);
user_init_off = get_te32(&shdr->sh_offset);
if ((u32_t)file_size <= user_init_off) {
char msg[70]; snprintf(msg, sizeof(msg),
""bad Elf32_Shdr[%d].sh_offset %#x"",
-1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}



int z_rel = dt_table[Elf32_Dyn::DT_REL];
int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ];
if (z_rel && z_rsz) {
unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val);
Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off];
unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val);
Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp);
for (; rp < last; ++rp) {
unsigned r_va = get_te32(&rp->r_offset);
if (r_va == user_init_ava) {
unsigned r_info = get_te32(&rp->r_info);
unsigned r_type = ELF32_R_TYPE(r_info);
if (Elf32_Ehdr::EM_ARM == e_machine
&&  R_ARM_RELATIVE == r_type) {
user_init_va = get_te32(&file_image[user_init_off]);
}
else {
char msg[50]; snprintf(msg, sizeof(msg),
""bad relocation %#x DT_INIT_ARRAY[0]"",
r_info);
throwCantPack(msg);
}
break;
}
}
}
unsigned const p_filesz = get_te32(&pload_x0->p_filesz);
if (!((user_init_va - xct_va) < p_filesz)) {

if (0==user_init_va && opt->o_unix.android_shlib) {

upx_dt_init = 0;

}
else {
char msg[70]; snprintf(msg, sizeof(msg),
""bad init address %#x in Elf32_Shdr[%d].%#x\n"",
(unsigned)user_init_va, -1+ e_shnum - j, user_init_off);
throwCantPack(msg);
}
}
}


if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)
&&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {
unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);
Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];
for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {
if (upx_dt_init == get_te32(&dynp->d_tag)) {
break;
}
}
if ((1+ dynp) < (n+ dynseg)) {
user_init_va = get_te32(&dynp->d_val);
set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);
user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];
}
}
}
}
else {
unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);
unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);
unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);
unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);
unsigned const init   = elf_unsigned_dynamic(upx_dt_init);
if ((init == (relsz + rel   ) && rel    == (strsz + strtab))
||  (init == (strsz + strtab) && strtab == (relsz + rel   ))
) {
xct_va = init;
user_init_va = init;
user_init_off = elf_get_offset_from_address(init);
}
}

unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);
unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);
unsigned y = 0;
if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))
||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))
||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))
||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))
||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))
||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))
||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))
||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))
||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {
static char const *which[] = {
""unknown"",
""DT_GNU_HASH"",
""DT_HASH"",
""DT_STRTAB"",
""DT_SYMTAB"",
""DT_REL"",
""DT_RELA"",
""DT_JMPREL"",
""DT_VERDEF"",
""DT_VERSYM"",
""DT_VERNEEDED"",
};
char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]);
throwCantPack(buf);
goto abandon;
}
if (!opt->o_unix.android_shlib) {
phdr = phdri;
for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {
unsigned const vaddr = get_te32(&phdr->p_vaddr);
if (PT_NOTE32 == get_te32(&phdr->p_type)
&& xct_va < vaddr) {
char buf[40]; snprintf(buf, sizeof(buf),
""PT_NOTE %#x above stub"", vaddr);
throwCantPack(buf);
goto abandon;
}
}
}
xct_off = elf_get_offset_from_address(xct_va);
if (opt->debug.debug_level) {
fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"",
(long)xct_va, (long)xct_off);
}
goto proceed;
}
else
throwCantPack(""need DT_INIT; try \""void _init(void){}\"""");
abandon:
return false;
proceed: ;
}


if (!super::canPack())
return false;
assert(exetype == 1);
exetype = 0;


opt->o_unix.blocksize = blocksize = file_size;
return true;
}","[159, 163]",An out-of-bounds read access vulnerability was discovered in UPX in PackLinuxElf64::canPack() function of p_lx_elf.cpp file. An attacker with a crafted input file could trigger this issue that could cause a crash leading to a denial of service.
202009," static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,
 			     u64 param3, u64 param4)
 {
  	int rc;
  	u64 base_addr, size;
  
 	if (get_securelevel() > 0)
 		return -EPERM;
 
  	 
  	if (flags && (flags &
  		~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))
 		return -EINVAL;
 
 	 
 
 	 
 	if (!(param_extension || acpi5))
 		goto inject;
 
 	 
 	if (type & ACPI5_VENDOR_BIT) {
 		if (vendor_flags != SETWA_FLAGS_MEM)
 			goto inject;
 	} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))
 		goto inject;
 
 	 
 	base_addr = param1 & param2;
 	size = ~param2 + 1;
 
 	if (((param2 & PAGE_MASK) != PAGE_MASK) ||
 	    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)
 				!= REGION_INTERSECTS) &&
 	     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)
 				!= REGION_INTERSECTS)))
 		return -EINVAL;
 
 inject:
 	mutex_lock(&einj_mutex);
 	rc = __einj_error_inject(type, flags, param1, param2, param3, param4);
 	mutex_unlock(&einj_mutex);
 
 	return rc;
 }","[7, 8, 9]",The einj_error_inject function in drivers/acpi/apei/einj.c in the Linux kernel allows local users to simulate hardware errors and consequently cause a denial of service by leveraging failure to disable APEI error injection through EINJ when securelevel is set.
8803,"hb_set_intersect (hb_set_t       *set,
const hb_set_t *other)
{
if (unlikely (hb_object_is_immutable (set)))
return;

set->intersect (*other);
}","[4, 5]",HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).
206572,"  PaintImage AcceleratedStaticBitmapImage::PaintImageForCurrentFrame() {
  CheckThread();
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
    if (!IsValid())
      return PaintImage();
  
    sk_sp<SkImage> image;
    if (original_skia_image_ &&
      original_skia_image_thread_id_ ==
          Platform::Current()->CurrentThread()->ThreadId()) {
       original_skia_image_task_runner_->BelongsToCurrentThread()) {
     image = original_skia_image_;
   } else {
     CreateImageFromMailboxIfNeeded();
     image = texture_holder_->GetSkImage();
   }
 
   return CreatePaintImageBuilder()
       .set_image(image, paint_image_content_id_)
       .set_completion_state(PaintImage::CompletionState::DONE)
       .TakePaintImage();
 }","[3, 11, 2, 9, 10]","Incorrect, thread-unsafe use of SkImage in Canvas in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
200619," static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,
 		struct nfsd3_setaclargs *argp,
 		struct nfsd_attrstat *resp)
 {
 	struct inode *inode;
 	svc_fh *fh;
 	__be32 nfserr = 0;
 	int error;
 
 	dprintk(""nfsd: SETACL(2acl)   %s\n"", SVCFH_fmt(&argp->fh));
 
 	fh = fh_copy(&resp->fh, &argp->fh);
 	nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);
 	if (nfserr)
  		goto out;
  
  	inode = d_inode(fh->fh_dentry);
	if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
		error = -EOPNOTSUPP;
		goto out_errno;
	}
  
  	error = fh_want_write(fh);
  	if (error)
  		goto out_errno;
  
	error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
 	fh_lock(fh);
 
 	error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
  	if (error)
		goto out_drop_write;
	error = inode->i_op->set_acl(inode, argp->acl_default,
				     ACL_TYPE_DEFAULT);
 		goto out_drop_lock;
 	error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
  	if (error)
		goto out_drop_write;
 		goto out_drop_lock;
 
 	fh_unlock(fh);
  
  	fh_drop_write(fh);
  
 	nfserr = fh_getattr(fh, &resp->stat);
 
 out:
 	 
  	posix_acl_release(argp->acl_access);
  	posix_acl_release(argp->acl_default);
  	return nfserr;
out_drop_write:
 out_drop_lock:
 	fh_unlock(fh);
  	fh_drop_write(fh);
  out_errno:
  	nfserr = nfserrno(error);
 	goto out;
 }","[28, 29, 30, 35, 36, 39, 40, 41, 53, 54, 18, 19, 20, 21, 27, 32, 33, 34, 38, 52]","nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c."
206718," DevToolsSession::DevToolsSession(DevToolsAgentHostImpl* agent_host,
                                  DevToolsAgentHostClient* client)
      : binding_(this),
        agent_host_(agent_host),
        client_(client),
      process_(nullptr),
       process_host_id_(ChildProcessHost::kInvalidUniqueID),
        host_(nullptr),
        dispatcher_(new protocol::UberDispatcher(this)),
        weak_factory_(this) {
   dispatcher_->setFallThroughForNotFound(true);
 }","[7, 6]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
204809," v8::Handle<v8::Value> V8DirectoryEntry::getFileCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.DirectoryEntry.getFile"");
      DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());
  
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
  
      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);
      if (args.Length() <= 1) {
         imp->getFile(path);
         return v8::Handle<v8::Value>();
     }
     RefPtr<WebKitFlags> flags;
     if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {
         EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));
         flags = WebKitFlags::create();
         v8::Local<v8::Value> v8Create = object->Get(v8::String::New(""create""));
         if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {
             EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());
             flags->setCreate(isCreate);
         }
         v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New(""exclusive""));
         if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {
             EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());
             flags->setExclusive(isExclusive);
         }
     }
     RefPtr<EntryCallback> successCallback;
     if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
         if (!args[2]->IsObject())
             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
         successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());
     }
     RefPtr<ErrorCallback> errorCallback;
     if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {
         if (!args[3]->IsObject())
             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
         errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());
     }
     imp->getFile(path, flags, successCallback, errorCallback);
     return v8::Handle<v8::Value>();
 }","[8, 7]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
205864,"    MockAudioRendererHost(base::RunLoop* auth_run_loop,
                          int render_process_id,
                          media::AudioManager* audio_manager,
                         media::AudioSystem* audio_system,
                          AudioMirroringManager* mirroring_manager,
                          MediaStreamManager* media_stream_manager,
                          const std::string& salt)
        : AudioRendererHost(render_process_id,
                            audio_manager,
                           audio_system,
                            mirroring_manager,
                            media_stream_manager,
                            salt),
         shared_memory_length_(0),
         auth_run_loop_(auth_run_loop) {
     set_render_frame_id_validate_function_for_testing(&ValidateRenderFrameId);
   }","[4, 10]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
201730," static Image *ReadOneDJVUImage(LoadContext* lc,const int pagenum,
   const ImageInfo *image_info,ExceptionInfo *exception)
 {
   ddjvu_page_type_t
      type;
 
   ddjvu_pageinfo_t info;
   ddjvu_message_t *message;
    Image *image;
    int logging;
    int tag;
   MagickBooleanType status;
  
           
  
          
         image = lc->image;
 
          
 
         logging=LogMagickEvent(CoderEvent,GetMagickModule(), ""  enter ReadOneDJVUImage()"");
         (void) logging;
 
 #if DEBUG
         printf(""====  Loading the page %d\n"", pagenum);
 #endif
         lc->page = ddjvu_page_create_by_pageno(lc->document, pagenum);  
 
          
         tag=(-1);
         do {
                 while ((message = ddjvu_message_peek(lc->context)))
                         {
                                 tag=process_message(message);
                                 if (tag == 0) break;
                                 ddjvu_message_pop(lc->context);
                         }
                  
                  
 
                 message = pump_data_until_message(lc,image);
                 if (message)
                         do {
                                 tag=process_message(message);
                                 if (tag == 0) break;
                                 ddjvu_message_pop(lc->context);
                         } while ((message = ddjvu_message_peek(lc->context)));
         } while (!ddjvu_page_decoding_done(lc->page));
 
         ddjvu_document_get_pageinfo(lc->document, pagenum, &info);
 
         image->x_resolution = (float) info.dpi;
         image->y_resolution =(float) info.dpi;
         if (image_info->density != (char *) NULL)
           {
             int
               flags;
 
             GeometryInfo
               geometry_info;
 
              
             flags=ParseGeometry(image_info->density,&geometry_info);
             image->x_resolution=geometry_info.rho;
             image->y_resolution=geometry_info.sigma;
             if ((flags & SigmaValue) == 0)
               image->y_resolution=image->x_resolution;
             info.width=(int) (info.width*image->x_resolution/info.dpi);
             info.height=(int) (info.height*image->y_resolution/info.dpi);
             info.dpi=(int) MagickMax(image->x_resolution,image->y_resolution);
           }
         type = ddjvu_page_get_type(lc->page);
 
          
          
 
          
          
 
         image->columns=(size_t) info.width;
         image->rows=(size_t) info.height;
 
          
         if (type == DDJVU_PAGETYPE_BITONAL){
                 image->colorspace = GRAYColorspace;
                 image->storage_class = PseudoClass;
                 image->depth =  8UL;     
                 image->colors= 2;
                 if (AcquireImageColormap(image,image->colors) == MagickFalse)
                   ThrowReaderException(ResourceLimitError,
                    ""MemoryAllocationFailed"");
         } else {
                 image->colorspace = RGBColorspace;
                 image->storage_class = DirectClass;
                  
                 image->depth =  8UL;     
 
                  image->matte = MagickTrue;
                   
          }
         status=SetImageExtent(image,image->columns,image->rows);
         if (status == MagickFalse)
           {
             InheritException(exception,&image->exception);
             return(DestroyImageList(image));
           }
  #if DEBUG
          printf(""now filling %.20g x %.20g\n"",(double) image->columns,(double)
            image->rows);
 #endif
 
 
 #if 1                            
 
          
         get_page_image(lc, lc->page, 0, 0, info.width, info.height, image_info);
 #else
         int i;
         for (i = 0;i< image->rows; i++)
                 {
                         printf(""%d\n"",i);
                         q = QueueAuthenticPixels(image,0,i,image->columns,1);
                         get_page_line(lc, i, quantum_info);
                         SyncAuthenticPixels(image);
                 }
 
 #endif  
 
 
 #if DEBUG
         printf(""END: finished filling %.20g x %.20g\n"",(double) image->columns,
           (double) image->rows);
 #endif
 
         if (!image->ping)
           SyncImage(image);
          
          
          
 
          
 
         if (lc->page) {
                 ddjvu_page_release(lc->page);
                 lc->page = NULL;
         }
 
          
         if (tag == 0)
           image=DestroyImage(image);
         return image;
          
 }","[12, 101, 102, 103, 104, 105, 106]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
202216," static Image *ReadOneJNGImage(MngInfo *mng_info,
     const ImageInfo *image_info, ExceptionInfo *exception)
 {
   Image
     *alpha_image,
     *color_image,
     *image,
     *jng_image;
 
   ImageInfo
     *alpha_image_info,
     *color_image_info;
 
   MagickBooleanType
     logging;
 
   ssize_t
     y;
 
   MagickBooleanType
     status;
 
   png_uint_32
     jng_height,
     jng_width;
 
   png_byte
     jng_color_type,
     jng_image_sample_depth,
     jng_image_compression_method,
     jng_image_interlace_method,
     jng_alpha_sample_depth,
     jng_alpha_compression_method,
     jng_alpha_filter_method,
     jng_alpha_interlace_method;
 
   register const Quantum
     *s;
 
   register ssize_t
     i,
     x;
 
   register Quantum
     *q;
 
   register unsigned char
     *p;
 
   unsigned int
     read_JSEP,
     reading_idat;
 
   size_t
     length;
 
   jng_alpha_compression_method=0;
   jng_alpha_sample_depth=8;
   jng_color_type=0;
   jng_height=0;
   jng_width=0;
   alpha_image=(Image *) NULL;
   color_image=(Image *) NULL;
   alpha_image_info=(ImageInfo *) NULL;
   color_image_info=(ImageInfo *) NULL;
 
   logging=LogMagickEvent(CoderEvent,GetMagickModule(),
     ""  Enter ReadOneJNGImage()"");
 
   image=mng_info->image;
 
   if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)
     {
        
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  AcquireNextImage()"");
 
       AcquireNextImage(image_info,image,exception);
 
       if (GetNextImageInList(image) == (Image *) NULL)
         return(DestroyImageList(image));
 
       image=SyncNextImageInList(image);
     }
   mng_info->image=image;
 
    
 
   read_JSEP=MagickFalse;
   reading_idat=MagickFalse;
   for (;;)
   {
     char
       type[MagickPathExtent];
 
     unsigned char
       *chunk;
 
     unsigned int
       count;
 
      
     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
       2*GetBlobSize(image));
 
     if (status == MagickFalse)
       break;
 
     type[0]='\0';
     (void) ConcatenateMagickString(type,""errr"",MagickPathExtent);
     length=(size_t) ReadBlobMSBLong(image);
     count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);
 
     if (logging != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""  Reading JNG chunk type %c%c%c%c, length: %.20g"",
         type[0],type[1],type[2],type[3],(double) length);
 
     if (length > PNG_UINT_31_MAX || count == 0)
       {
         DestroyJNG(NULL,&color_image,&color_image_info,
           &alpha_image,&alpha_image_info);
         ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
       }
     if (length > GetBlobSize(image))
       {
         DestroyJNG(NULL,&color_image,&color_image_info,
           &alpha_image,&alpha_image_info);
         ThrowReaderException(CorruptImageError,
           ""InsufficientImageDataInFile"");
       }
 
     p=NULL;
     chunk=(unsigned char *) NULL;
 
     if (length != 0)
       {
          chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));
  
          if (chunk == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           {
             DestroyJNG(NULL,&color_image,&color_image_info,
               &alpha_image,&alpha_image_info);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
  
          for (i=0; i < (ssize_t) length; i++)
          {
           int
             c;
 
           c=ReadBlobByte(image);
           if (c == EOF)
             break;
           chunk[i]=(unsigned char) c;
         }
         for ( ; i < (ssize_t) length; i++)
           chunk[i]='\0';
 
         p=chunk;
       }
 
     (void) ReadBlobMSBLong(image);   
 
     if (memcmp(type,mng_JHDR,4) == 0)
       {
         if (length == 16)
           {
              jng_width=(png_uint_32)mng_get_long(p);
              jng_height=(png_uint_32)mng_get_long(&p[4]);
              if ((jng_width == 0) || (jng_height == 0))
            {
              DestroyJNG(chunk,&color_image,&color_image_info,
                &alpha_image,&alpha_image_info);
              ThrowReaderException(CorruptImageError,
                ""NegativeOrZeroImageSize"");
            }
               {
                 DestroyJNG(chunk,&color_image,&color_image_info,
                   &alpha_image,&alpha_image_info);
                 ThrowReaderException(CorruptImageError,
                   ""NegativeOrZeroImageSize"");
               }
              jng_color_type=p[8];
              jng_image_sample_depth=p[9];
              jng_image_compression_method=p[10];
             jng_image_interlace_method=p[11];
 
             image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :
               NoInterlace;
 
             jng_alpha_sample_depth=p[12];
             jng_alpha_compression_method=p[13];
             jng_alpha_filter_method=p[14];
             jng_alpha_interlace_method=p[15];
 
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    jng_width:      %16lu,    jng_height:     %16lu\n""
                   ""    jng_color_type: %16d,     jng_image_sample_depth: %3d\n""
                   ""    jng_image_compression_method:%3d"",
                   (unsigned long) jng_width, (unsigned long) jng_height,
                   jng_color_type, jng_image_sample_depth,
                   jng_image_compression_method);
 
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    jng_image_interlace_method:  %3d""
                   ""    jng_alpha_sample_depth:      %3d"",
                   jng_image_interlace_method,
                   jng_alpha_sample_depth);
 
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    jng_alpha_compression_method:%3d\n""
                   ""    jng_alpha_filter_method:     %3d\n""
                   ""    jng_alpha_interlace_method:  %3d"",
                   jng_alpha_compression_method,
                   jng_alpha_filter_method,
                   jng_alpha_interlace_method);
               }
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         if (jng_width > 65535 || jng_height > 65535 ||
              (long) jng_width > GetMagickResourceLimit(WidthResource) ||
              (long) jng_height > GetMagickResourceLimit(HeightResource))
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    JNG width or height too large: (%lu x %lu)"",
                 (long) jng_width, (long) jng_height);
             DestroyJNG(chunk,&color_image,&color_image_info,
               &alpha_image,&alpha_image_info);
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
           }
 
         continue;
       }
 
 
     if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&
         ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||
          (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))
       {
          
 
         color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));
 
         if (color_image_info == (ImageInfo *) NULL)
         {
           DestroyJNG(chunk,&color_image,&color_image_info,
               &alpha_image,&alpha_image_info);
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         }
 
         GetImageInfo(color_image_info);
         color_image=AcquireImage(color_image_info,exception);
 
         if (color_image == (Image *) NULL)
         {
           DestroyJNG(chunk,&color_image,&color_image_info,
               &alpha_image,&alpha_image_info);
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         }
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Creating color_blob."");
 
         (void) AcquireUniqueFilename(color_image->filename);
         status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,
           exception);
 
         if (status == MagickFalse)
           {
             DestroyJNG(chunk,&color_image,&color_image_info,
               &alpha_image,&alpha_image_info);
             return(DestroyImageList(image));
           }
 
         if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))
           {
             alpha_image_info=(ImageInfo *)
               AcquireMagickMemory(sizeof(ImageInfo));
 
             if (alpha_image_info == (ImageInfo *) NULL)
               {
                 DestroyJNG(chunk,&color_image,&color_image_info,
                   &alpha_image,&alpha_image_info);
                 ThrowReaderException(ResourceLimitError,
                   ""MemoryAllocationFailed"");
               }
 
             GetImageInfo(alpha_image_info);
             alpha_image=AcquireImage(alpha_image_info,exception);
 
             if (alpha_image == (Image *) NULL)
               {
                 DestroyJNG(chunk,&color_image,&color_image_info,
                   &alpha_image,&alpha_image_info);
                 ThrowReaderException(ResourceLimitError,
                   ""MemoryAllocationFailed"");
               }
 
             if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Creating alpha_blob."");
 
             (void) AcquireUniqueFilename(alpha_image->filename);
             status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,
               exception);
 
             if (status == MagickFalse)
               {
                 DestroyJNG(chunk,&color_image,&color_image_info,
                   &alpha_image,&alpha_image_info);
                 return(DestroyImageList(image));
               }
 
             if (jng_alpha_compression_method == 0)
               {
                 unsigned char
                   data[18];
 
                 if (logging != MagickFalse)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""    Writing IHDR chunk to alpha_blob."");
 
                 (void) WriteBlob(alpha_image,8,(const unsigned char *)
                   ""\211PNG\r\n\032\n"");
 
                 (void) WriteBlobMSBULong(alpha_image,13L);
                 PNGType(data,mng_IHDR);
                 LogPNGChunk(logging,mng_IHDR,13L);
                 PNGLong(data+4,jng_width);
                 PNGLong(data+8,jng_height);
                 data[12]=jng_alpha_sample_depth;
                 data[13]=0;  
                 data[14]=0;  
                 data[15]=0;  
                 data[16]=0;  
                 (void) WriteBlob(alpha_image,17,data);
                 (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));
               }
           }
         reading_idat=MagickTrue;
       }
 
     if (memcmp(type,mng_JDAT,4) == 0)
       {
          
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Copying JDAT chunk data to color_blob."");
 
         if ((length != 0) && (color_image != (Image *) NULL))
           (void) WriteBlob(color_image,length,chunk);
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
     if (memcmp(type,mng_IDAT,4) == 0)
       {
         png_byte
            data[5];
 
          
 
         if (alpha_image != NULL && image_info->ping == MagickFalse)
           {
             if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Copying IDAT chunk data to alpha_blob."");
 
             (void) WriteBlobMSBULong(alpha_image,(size_t) length);
             PNGType(data,mng_IDAT);
             LogPNGChunk(logging,mng_IDAT,length);
             (void) WriteBlob(alpha_image,4,data);
             (void) WriteBlob(alpha_image,length,chunk);
             (void) WriteBlobMSBULong(alpha_image,
               crc32(crc32(0,data,4),chunk,(uInt) length));
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         continue;
       }
 
     if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))
       {
          
 
         if ((alpha_image != NULL) && (image_info->ping == MagickFalse) &&
             (length != 0))
           {
             if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Copying JDAA chunk data to alpha_blob."");
 
             (void) WriteBlob(alpha_image,length,chunk);
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         continue;
       }
 
     if (memcmp(type,mng_JSEP,4) == 0)
       {
         read_JSEP=MagickTrue;
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         continue;
       }
 
     if (memcmp(type,mng_bKGD,4) == 0)
       {
         if (length == 2)
           {
             image->background_color.red=ScaleCharToQuantum(p[1]);
             image->background_color.green=image->background_color.red;
             image->background_color.blue=image->background_color.red;
           }
 
         if (length == 6)
           {
             image->background_color.red=ScaleCharToQuantum(p[1]);
             image->background_color.green=ScaleCharToQuantum(p[3]);
             image->background_color.blue=ScaleCharToQuantum(p[5]);
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
     if (memcmp(type,mng_gAMA,4) == 0)
       {
         if (length == 4)
           image->gamma=((float) mng_get_long(p))*0.00001;
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
     if (memcmp(type,mng_cHRM,4) == 0)
       {
         if (length == 32)
           {
             image->chromaticity.white_point.x=0.00001*mng_get_long(p);
             image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);
             image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);
             image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);
             image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);
             image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);
             image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);
             image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
     if (memcmp(type,mng_sRGB,4) == 0)
       {
         if (length == 1)
           {
             image->rendering_intent=
               Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);
             image->gamma=1.000f/2.200f;
             image->chromaticity.red_primary.x=0.6400f;
             image->chromaticity.red_primary.y=0.3300f;
             image->chromaticity.green_primary.x=0.3000f;
             image->chromaticity.green_primary.y=0.6000f;
             image->chromaticity.blue_primary.x=0.1500f;
             image->chromaticity.blue_primary.y=0.0600f;
             image->chromaticity.white_point.x=0.3127f;
             image->chromaticity.white_point.y=0.3290f;
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
     if (memcmp(type,mng_oFFs,4) == 0)
       {
         if (length > 8)
           {
             image->page.x=(ssize_t) mng_get_long(p);
             image->page.y=(ssize_t) mng_get_long(&p[4]);
 
             if ((int) p[8] != 0)
               {
                 image->page.x/=10000;
                 image->page.y/=10000;
               }
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         continue;
       }
 
     if (memcmp(type,mng_pHYs,4) == 0)
       {
         if (length > 8)
           {
             image->resolution.x=(double) mng_get_long(p);
             image->resolution.y=(double) mng_get_long(&p[4]);
             if ((int) p[8] == PNG_RESOLUTION_METER)
               {
                 image->units=PixelsPerCentimeterResolution;
                 image->resolution.x=image->resolution.x/100.0f;
                 image->resolution.y=image->resolution.y/100.0f;
               }
           }
 
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
         continue;
       }
 
 #if 0
     if (memcmp(type,mng_iCCP,4) == 0)
       {
          
         chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
         continue;
       }
 #endif
 
     chunk=(unsigned char *) RelinquishMagickMemory(chunk);
 
     if (memcmp(type,mng_IEND,4))
       continue;
 
     break;
   }
 
 
    
 
    
 
   if (color_image_info == (ImageInfo *) NULL)
     {
       assert(color_image == (Image *) NULL);
       assert(alpha_image == (Image *) NULL);
       if (color_image != (Image *) NULL)
         color_image=DestroyImageList(color_image);
       return(DestroyImageList(image));
     }
 
   if (color_image == (Image *) NULL)
     {
       assert(alpha_image == (Image *) NULL);
       ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
     }
 
   (void) SeekBlob(color_image,0,SEEK_SET);
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""    Reading jng_image from color_blob."");
 
   assert(color_image_info != (ImageInfo *) NULL);
   (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,
     ""jpeg:%s"",color_image->filename);
 
   color_image_info->ping=MagickFalse;    
   jng_image=ReadImage(color_image_info,exception);
 
   (void) RelinquishUniqueFileResource(color_image->filename);
   color_image=DestroyImage(color_image);
   color_image_info=DestroyImageInfo(color_image_info);
 
   if (jng_image == (Image *) NULL)
   {
     DestroyJNG(NULL,NULL,NULL,&alpha_image,&alpha_image_info);
     return(DestroyImageList(image));
   }
 
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""    Copying jng_image pixels to main image."");
 
   image->rows=jng_height;
   image->columns=jng_width;
 
   status=SetImageExtent(image,image->columns,image->rows,exception);
   if (status == MagickFalse)
     {
       DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,
         &alpha_image_info);
       jng_image=DestroyImageList(jng_image);
       return(DestroyImageList(image));
     }
   if ((image->columns != jng_image->columns) ||
       (image->rows != jng_image->rows))
     {
       DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,
         &alpha_image_info);
       jng_image=DestroyImageList(jng_image);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);
     q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
     if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))
       break;
     for (x=(ssize_t) image->columns; x != 0; x--)
     {
       SetPixelRed(image,GetPixelRed(jng_image,s),q);
       SetPixelGreen(image,GetPixelGreen(jng_image,s),q);
       SetPixelBlue(image,GetPixelBlue(jng_image,s),q);
       q+=GetPixelChannels(image);
       s+=GetPixelChannels(jng_image);
     }
 
     if (SyncAuthenticPixels(image,exception) == MagickFalse)
       break;
   }
 
   jng_image=DestroyImage(jng_image);
 
   if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))
     {
       if (jng_alpha_compression_method == 0)
         {
           png_byte
             data[5];
           (void) WriteBlobMSBULong(alpha_image,0x00000000L);
           PNGType(data,mng_IEND);
           LogPNGChunk(logging,mng_IEND,0L);
           (void) WriteBlob(alpha_image,4,data);
           (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));
         }
 
       (void) CloseBlob(alpha_image);
 
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    Reading alpha from alpha_blob."");
 
       (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,
         ""%s"",alpha_image->filename);
 
       jng_image=ReadImage(alpha_image_info,exception);
 
       if (jng_image != (Image *) NULL)
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);
           q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
           if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))
             break;
 
           if (image->alpha_trait != UndefinedPixelTrait)
             for (x=(ssize_t) image->columns; x != 0; x--)
             {
               SetPixelAlpha(image,GetPixelRed(jng_image,s),q);
               q+=GetPixelChannels(image);
               s+=GetPixelChannels(jng_image);
             }
 
           else
             for (x=(ssize_t) image->columns; x != 0; x--)
             {
               SetPixelAlpha(image,GetPixelRed(jng_image,s),q);
               if (GetPixelAlpha(image,q) != OpaqueAlpha)
                 image->alpha_trait=BlendPixelTrait;
               q+=GetPixelChannels(image);
               s+=GetPixelChannels(jng_image);
             }
 
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
         }
       (void) RelinquishUniqueFileResource(alpha_image->filename);
       alpha_image=DestroyImage(alpha_image);
       alpha_image_info=DestroyImageInfo(alpha_image_info);
       if (jng_image != (Image *) NULL)
         jng_image=DestroyImage(jng_image);
     }
 
    
 
   if (mng_info->mng_type == 0)
     {
       mng_info->mng_width=jng_width;
       mng_info->mng_height=jng_height;
     }
 
   if (image->page.width == 0 && image->page.height == 0)
     {
       image->page.width=jng_width;
       image->page.height=jng_height;
     }
 
   if (image->page.x == 0 && image->page.y == 0)
     {
       image->page.x=mng_info->x_off[mng_info->object_id];
       image->page.y=mng_info->y_off[mng_info->object_id];
     }
 
   else
     {
       image->page.y=mng_info->y_off[mng_info->object_id];
     }
 
   mng_info->image_found++;
   status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),
     2*GetBlobSize(image));
 
   if (status == MagickFalse)
     return(DestroyImageList(image));
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  exit ReadOneJNGImage()"");
 
   return(image);
 }","[143, 144, 145, 146, 147, 180, 181, 182, 183, 184, 185, 142, 174, 175, 176, 177, 178, 179]",ImageMagick 7.0.8-5 has a memory leak vulnerability in the function ReadOneJNGImage in coders/png.c.
208187," WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,
                          WORD32 i4_poc,
  pocstruct_t *ps_temp_poc,
                          UWORD16 u2_frame_num,
  dec_pic_params_t *ps_pps)
 {
  pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;
  pocstruct_t *ps_cur_poc = ps_temp_poc;
 
  pic_buffer_t *pic_buf;
 
  ivd_video_decode_op_t * ps_dec_output =
  (ivd_video_decode_op_t *)ps_dec->pv_dec_out;
  dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
  dec_seq_params_t *ps_seq = ps_pps->ps_sps;
     UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
   
  high_profile_tools_t s_high_profile;
     WORD32 ret;
 
     H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);
 
     ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
     ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
     ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                     ps_cur_poc->i4_delta_pic_order_cnt_bottom;
     ps_prev_poc->i4_delta_pic_order_cnt[0] =
                     ps_cur_poc->i4_delta_pic_order_cnt[0];
     ps_prev_poc->i4_delta_pic_order_cnt[1] =
                     ps_cur_poc->i4_delta_pic_order_cnt[1];
     ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;
     ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
     ps_prev_poc->u2_frame_num = u2_frame_num;
     ps_dec->i1_prev_mb_qp_delta = 0;
     ps_dec->i1_next_ctxt_idx = 0;
 
 
     ps_dec->u4_nmb_deblk = 0;
  if(ps_dec->u4_num_cores == 1)
        ps_dec->u4_nmb_deblk = 1;
 
 
 
  if(ps_seq->u1_mb_aff_flag == 1)
  {
         ps_dec->u4_nmb_deblk = 0;
  if(ps_dec->u4_num_cores > 2)
             ps_dec->u4_num_cores = 2;
  }
 
         ps_dec->u4_use_intrapred_line_copy = 0;
 
 
 
  if (ps_seq->u1_mb_aff_flag == 0)
  {
         ps_dec->u4_use_intrapred_line_copy = 1;
  }
 
     ps_dec->u4_app_disable_deblk_frm = 0;
   
  if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)
  {
         WORD32 degrade_pic;
         ps_dec->i4_degrade_pic_cnt++;
         degrade_pic = 0;
 
   
  switch(ps_dec->i4_degrade_pics)
  {
  case 4:
  {
                 degrade_pic = 1;
  break;
  }
  case 3:
  {
  if(ps_cur_slice->u1_slice_type != I_SLICE)
                     degrade_pic = 1;
 
  break;
  }
  case 2:
  {
 
   
  if((ps_cur_slice->u1_slice_type != I_SLICE)
  && (ps_dec->i4_degrade_pic_cnt
  != ps_dec->i4_nondegrade_interval))
                     degrade_pic = 1;
 
  break;
  }
  case 1:
  {
   
  if(0 == ps_cur_slice->u1_nal_ref_idc)
  {
                     degrade_pic = 1;
  }
  break;
  }
 
  }
  if(degrade_pic)
  {
  if(ps_dec->i4_degrade_type & 0x2)
                 ps_dec->u4_app_disable_deblk_frm = 1;
 
   
  if(0 == ps_cur_slice->u1_nal_ref_idc)
  {
  if(ps_dec->i4_degrade_type & 0x4)
                     ps_dec->i4_mv_frac_mask = 0;
 
  if(ps_dec->i4_degrade_type & 0x8)
                     ps_dec->i4_mv_frac_mask = 0;
  }
  }
  else
             ps_dec->i4_degrade_pic_cnt = 0;
  }
 
  {
  dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
  if(ps_dec->u1_sl_typ_5_9
  && ((ps_cur_slice->u1_slice_type == I_SLICE)
  || (ps_cur_slice->u1_slice_type
  == SI_SLICE)))
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
  else
             ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;
 
  if(ps_err->u1_pic_aud_i == PIC_TYPE_I)
  {
             ps_err->u1_cur_pic_type = PIC_TYPE_I;
             ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;
  }
 
  if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
  {
  if(ps_err->u1_err_flag)
                 ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
  }
  }
 
  if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)
  {
   
         WORD32 j;
  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
  {
 
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                   ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                   BUF_MGR_REF);
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                   j,
                                   BUF_MGR_IO);
  }
 
   
         ps_dec->u1_second_field = 0;
         ps_dec->i4_cur_display_seq = 0;
 
   
   
   
   
 
         ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;
  }
     ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);
  if(ret != OK)
  return ret;
 
     ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;
     ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;
  if(ps_dec->u1_separate_parse)
  {
         UWORD16 pic_wd;
         UWORD16 pic_ht;
         UWORD32 num_mbs;
 
         pic_wd = ps_dec->u2_pic_wd;
         pic_ht = ps_dec->u2_pic_ht;
         num_mbs = (pic_wd * pic_ht) >> 8;
 
  if(ps_dec->pu1_dec_mb_map)
  {
             memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);
  }
 
  if(ps_dec->pu1_recon_mb_map)
  {
 
             memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);
  }
 
  if(ps_dec->pu2_slice_num_map)
  {
             memset((void *)ps_dec->pu2_slice_num_map, 0,
  (num_mbs * sizeof(UWORD16)));
  }
 
  }
 
     ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
     ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);
 
   
     ps_dec->s_high_profile.u1_scaling_present = 0;
     ps_dec->s_high_profile.u1_transform8x8_present = 0;
 
   
  if(1 == ps_dec->u4_share_disp_buf)
  {
         UWORD32 i;
   
  for(i = 0; i < MAX_DISP_BUFS_NEW; i++)
  {
  if(0 == ps_dec->u4_disp_buf_to_be_freed[i])
  continue;
             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,
             BUF_MGR_IO);
             ps_dec->u4_disp_buf_to_be_freed[i] = 0;
             ps_dec->u4_disp_buf_mapping[i] = 0;
 
  }
  }
  if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))  
  {
  pic_buffer_t *ps_cur_pic;
         WORD32 cur_pic_buf_id, cur_mv_buf_id;
  col_mv_buf_t *ps_col_mv;
  while(1)
  {
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
  &cur_pic_buf_id);
  if(ps_cur_pic == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
  return ERROR_UNAVAIL_PICBUF_T;
  }
  if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])
  {
  break;
  }
 
  }
         ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
  &cur_mv_buf_id);
  if(ps_col_mv == NULL)
  {
             ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
  return ERROR_UNAVAIL_MVBUF_T;
  }
 
         ps_dec->ps_cur_pic = ps_cur_pic;
         ps_dec->u1_pic_buf_id = cur_pic_buf_id;
         ps_cur_pic->u4_ts = ps_dec->u4_ts;
 
 
         ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
         ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
  if(ps_dec->u1_first_slice_in_stream)
  {
   
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
  *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;
  }
 
  if(!ps_dec->ps_cur_pic)
  {
             WORD32 j;
             H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n"");
  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)
  {
 
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
                                       ps_dec->au1_pic_buf_id_mv_buf_id_map[j],
                                       BUF_MGR_REF);
                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
                                       j,
                                       BUF_MGR_IO);
  }
 
             ps_dec->i4_cur_display_seq = 0;
             ps_dec->i4_prev_max_display_seq = 0;
             ps_dec->i4_max_poc = 0;
 
             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(
  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,
  &cur_pic_buf_id);
  if(ps_cur_pic == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;
  return ERROR_UNAVAIL_PICBUF_T;
  }
 
             ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,
  &cur_mv_buf_id);
  if(ps_col_mv == NULL)
  {
                 ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;
  return ERROR_UNAVAIL_MVBUF_T;
  }
 
             ps_dec->ps_cur_pic = ps_cur_pic;
             ps_dec->u1_pic_buf_id = cur_pic_buf_id;
             ps_cur_pic->u4_ts = ps_dec->u4_ts;
             ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;
 
             ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;
             ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;
 
             ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;
             ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;
             ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;
 
  }
 
         ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;
         ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;
         H264_DEC_DEBUG_PRINT(""got a buffer\n"");
  }
  else
  {
         H264_DEC_DEBUG_PRINT(""did not get a buffer\n"");
  }
 
     ps_dec->u4_pic_buf_got = 1;
 
     ps_dec->ps_cur_pic->i4_poc = i4_poc;
     ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;
     ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;
     ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =
                     ps_pps->i4_bottom_field_order_cnt;
     ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;
     ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;
 
     ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);
  if(u1_field_pic_flag && u1_bottom_field_flag)
  {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
   
         ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;
         ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;
         ps_dec->s_cur_pic.ps_mv +=
  ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);
         ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht
  * ps_dec->u2_pic_wd) >> 5);
         ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;
         i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         i4_temp_poc = MIN(i4_top_field_order_poc,
                                  i4_bot_field_order_poc);
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
  }
 
     ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
  && (!u1_field_pic_flag);
 
     ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag
  << 2);
 
     ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;  
     ps_dec->ps_cur_mb_row += 2;
     ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row;
     ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));
     ps_dec->ps_top_mb_row += 2;
 
   
     ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];
   
     ps_dec->u1_mv_top_p = 0;
     ps_dec->u1_mb_idx = 0;
   
     ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;
     ps_dec->u2_total_mbs_coded = 0;
     ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);
     ps_dec->u4_pred_info_idx = 0;
     ps_dec->u4_pred_info_pkd_idx = 0;
     ps_dec->u4_dma_buf_idx = 0;
     ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;
     ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;
     ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;
     ps_dec->ps_part = ps_dec->ps_parse_part_params;
     ps_dec->i2_prev_slice_mbx = -1;
     ps_dec->i2_prev_slice_mby = 0;
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
     ps_dec->u1_last_pic_not_decoded = 0;
 
     ps_dec->u2_cur_slice_num = 0;
     ps_dec->u2_cur_slice_num_dec_thread = 0;
     ps_dec->u2_cur_slice_num_bs = 0;
     ps_dec->u4_intra_pred_line_ofst = 0;
     ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;
 
     ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;
     ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;
     ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;
 
 
 
 
 
     ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line
  + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);
 
     ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line
  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;
     ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line
  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;
 
     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
   
  {
  if(ps_cur_slice->u1_mbaff_frame_flag)
  {
             ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;
             ps_dec->pf_mvpred = ih264d_mvpred_mbaff;
  }
  else
  {
             ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;
             ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;
  }
  }
   
  {
         UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
         UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;
 
         UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)
  % (ps_dec->u1_recon_mb_grp >> u1_mbaff));
         UWORD16 ui16_lastmbs_widthY =
  (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) << 4));
         UWORD16 ui16_lastmbs_widthUV =
                         uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) << 3);
 
         ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
         ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
         ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
         ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y
  << u1_field_pic_flag;
         ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv
  << u1_field_pic_flag;
 
  if(u1_field_pic_flag)
  {
             ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;
             ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;
  }
 
   
         ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)
  >> u1_mbaff);
         ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)
  >> u1_mbaff);
 
   
         ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY
  + (PAD_LEN_Y_H << 1)
  + ps_dec->s_tran_addrecon.u2_frm_wd_y
  * ((15 << u1_mbaff) + u1_mbaff));
         ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV
  + (PAD_LEN_UV_H << 2)
  + ps_dec->s_tran_addrecon.u2_frm_wd_uv
  * ((15 << u1_mbaff) + u1_mbaff));
 
   
   
         ih264d_assign_pic_num(ps_dec);
         ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp
  << 2) - 1 - (u1_mbaff << 2);
         ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp
  >> u1_mbaff) - 1) << (4 + u1_mbaff);
  }
   
   
   
  if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)
  {
  if((ps_seq->i4_seq_scaling_matrix_present_flag)
  || (ps_pps->i4_pic_scaling_matrix_present_flag))
  {
             ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);
             ps_dec->s_high_profile.u1_scaling_present = 1;
  }
  else
  {
             ih264d_form_default_scaling_matrix(ps_dec);
  }
 
  if(ps_pps->i4_transform_8x8_mode_flag)
  {
             ps_dec->s_high_profile.u1_transform8x8_present = 1;
  }
  }
  else
  {
         ih264d_form_default_scaling_matrix(ps_dec);
  }
 
   
     ps_dec->s_high_profile.u1_direct_8x8_inference_flag =
                     ps_seq->u1_direct_8x8_inference_flag;
     ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;
 
     ps_dec->i1_recon_in_thread3_flag = 1;
     ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;
  if(ps_dec->u1_separate_parse)
  {
         memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,
  sizeof(tfr_ctxt_t));
  if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)
  {
             memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,
  sizeof(tfr_ctxt_t));
             ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;
  }
  }
 
 
     ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),
                                ps_dec->u2_frm_wd_in_mbs, 0);
 
     ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;
     ps_dec->u4_cur_deblk_mb_num = 0;
 
  
      ps_dec->u4_deblk_mb_x = 0;
      ps_dec->u4_deblk_mb_y = 0;
     ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
  
      H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
      return OK;
 }",[561],"The H.264 decoder in mediaserver in Android 6.x before 2016-07-01 does not initialize certain slice data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 28165661."
198072," static inline void *host_from_stream_offset(QEMUFile *f,
                                             ram_addr_t offset,
                                             int flags)
 {
     static RAMBlock *block = NULL;
     char id[256];
      uint8_t len;
  
      if (flags & RAM_SAVE_FLAG_CONTINUE) {
        if (!block) {
         if (!block || block->length <= offset) {
              error_report(""Ack, bad migration stream!"");
              return NULL;
          }
 
         return memory_region_get_ram_ptr(block->mr) + offset;
     }
 
     len = qemu_get_byte(f);
     qemu_get_buffer(f, (uint8_t *)id, len);
      id[len] = 0;
  
      QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (!strncmp(id, block->idstr, sizeof(id)))
         if (!strncmp(id, block->idstr, sizeof(id)) && block->length > offset) {
              return memory_region_get_ram_ptr(block->mr) + offset;
         }
      }
  
      error_report(""Can't find block %s!"", id);
 }","[11, 25, 27, 10, 24]","The host_from_stream_offset function in arch_init.c in QEMU, when loading RAM during migration, allows remote attackers to execute arbitrary code via a crafted (1) offset or (2) length value in savevm data."
202491," int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
 {
     uint32_t chan_chunk = 0, channel_layout = 0, bcount;
     unsigned char *channel_identities = NULL;
     unsigned char *channel_reorder = NULL;
     int64_t total_samples = 0, infilesize;
     CAFFileHeader caf_file_header;
     CAFChunkHeader caf_chunk_header;
     CAFAudioFormat caf_audio_format;
     int i;
 
     infilesize = DoGetFileSize (infile);
     memcpy (&caf_file_header, fourcc, 4);
 
     if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
         bcount != sizeof (CAFFileHeader) - 4)) {
             error_line (""%s is not a valid .CAF file!"", infilename);
             return WAVPACK_SOFT_ERROR;
     }
     else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
         !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
             error_line (""%s"", WavpackGetErrorMessage (wpc));
             return WAVPACK_SOFT_ERROR;
     }
 
     WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);
 
     if (caf_file_header.mFileVersion != 1) {
         error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
         return WAVPACK_SOFT_ERROR;
     }
 
 
     while (1) {
         if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
             bcount != sizeof (CAFChunkHeader)) {
                 error_line (""%s is not a valid .CAF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
         }
         else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
             !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                 error_line (""%s"", WavpackGetErrorMessage (wpc));
                 return WAVPACK_SOFT_ERROR;
         }
 
         WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);
 
 
         if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
             int supported = TRUE;
 
             if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                 !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                 bcount != caf_chunk_header.mChunkSize) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
 
             if (debug_logging_mode) {
                 char formatstr [5];
 
                 memcpy (formatstr, caf_audio_format.mFormatID, 4);
                 formatstr [4] = 0;
                 error_line (""format = %s, flags = %x, sampling rate = %g"",
                     formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                 error_line (""packet = %d bytes and %d frames"",
                     caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                 error_line (""channels per frame = %d, bits per channel = %d"",
                     caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
             }
 
             if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                 supported = FALSE;
             else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                 caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                     supported = FALSE;
             else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                 supported = FALSE;
             else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                 ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                     supported = FALSE;
             else if (caf_audio_format.mFramesPerPacket != 1 ||
                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                 caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                     supported = FALSE;
 
             if (!supported) {
                 error_line (""%s is an unsupported .CAF format!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
             config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
             config->bits_per_sample = caf_audio_format.mBitsPerChannel;
             config->num_channels = caf_audio_format.mChannelsPerFrame;
             config->sample_rate = (int) caf_audio_format.mSampleRate;
 
             if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                 config->qmode |= QMODE_BIG_ENDIAN;
 
             if (config->bytes_per_sample == 1)
                 config->qmode |= QMODE_SIGNED_BYTES;
 
             if (debug_logging_mode) {
                 if (config->float_norm_exp == 127)
                     error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                 else
                     error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                         config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
              }
          }
          else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);
             CAFChannelLayout *caf_channel_layout;
  
            if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) ||
                !DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
             if (caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout) || caf_chunk_header.mChunkSize > 1024) {
                 error_line (""this .CAF file has an invalid 'chan' chunk!"");
                 return WAVPACK_SOFT_ERROR;
             }
 
             if (debug_logging_mode)
                 error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);
 
             caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);
 
             if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                  bcount != caf_chunk_header.mChunkSize) {
                      error_line (""%s is not a valid .CAF file!"", infilename);
                      free (caf_channel_layout);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     free (caf_channel_layout);
                     return WAVPACK_SOFT_ERROR;
             }
 
             WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
             chan_chunk = 1;
 
             if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                 error_line (""this CAF file already has channel order information!"");
                 free (caf_channel_layout);
                 return WAVPACK_SOFT_ERROR;
             }
 
             switch (caf_channel_layout->mChannelLayoutTag) {
                 case kCAFChannelLayoutTag_UseChannelDescriptions:
                     {
                         CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                         int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                         int label, cindex = 0, idents = 0;
 
                         if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                             num_descriptions != config->num_channels) {
                                 error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                 free (caf_channel_layout);
                                 return WAVPACK_SOFT_ERROR;
                         }
 
                         if (num_descriptions >= 256) {
                             error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                             break;
                         }
 
 
                         channel_reorder = malloc (num_descriptions);
                         memset (channel_reorder, -1, num_descriptions);
                         channel_identities = malloc (num_descriptions+1);
 
 
                         for (i = 0; i < num_descriptions; ++i) {
                             WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);
 
                             if (debug_logging_mode)
                                 error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                         }
 
 
                         for (label = 1; label <= 18; ++label)
                             for (i = 0; i < num_descriptions; ++i)
                                 if (descriptions [i].mChannelLabel == label) {
                                     config->channel_mask |= 1 << (label - 1);
                                     channel_reorder [i] = cindex++;
                                     break;
                                 }
 
 
                         for (i = 0; i < num_descriptions; ++i)
                             if (channel_reorder [i] == (unsigned char) -1) {
                                 uint32_t clabel = descriptions [i].mChannelLabel;
 
                                 if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                     channel_identities [idents++] = 0xff;
                                 else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                     channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                 else {
                                     error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                     channel_identities [idents++] = 0xff;
                                 }
 
                                 channel_reorder [i] = cindex++;
                             }
 
 
                         for (i = 0; i < num_descriptions; ++i)
                             if (channel_reorder [i] != i)
                                 break;
 
                         if (i == num_descriptions) {
                             free (channel_reorder);                  
                             channel_reorder = NULL;
                         }
                         else {
                             config->qmode |= QMODE_REORDERED_CHANS;  
                             channel_layout = num_descriptions;
                         }
 
                         if (!idents) {                               
                             free (channel_identities);
                             channel_identities = NULL;
                         }
                         else
                             channel_identities [idents] = 0;         
 
                         if (debug_logging_mode) {
                             error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                 caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                 caf_channel_layout->mNumberChannelDescriptions, idents);
 
 
                             if (channel_reorder && num_descriptions <= 8) {
                                 char reorder_string [] = ""12345678"";
 
                                 for (i = 0; i < num_descriptions; ++i)
                                     reorder_string [i] = channel_reorder [i] + '1';
 
                                 reorder_string [i] = 0;
                                 error_line (""reordering string = \""%s\""\n"", reorder_string);
                             }
                         }
                     }
 
                     break;
 
                 case kCAFChannelLayoutTag_UseChannelBitmap:
                     config->channel_mask = caf_channel_layout->mChannelBitmap;
 
                     if (debug_logging_mode)
                         error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                             caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);
 
                     break;
 
                 default:
                     for (i = 0; i < NUM_LAYOUTS; ++i)
                         if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                             config->channel_mask = layouts [i].mChannelBitmap;
                             channel_layout = layouts [i].mChannelLayoutTag;
 
                             if (layouts [i].mChannelReorder) {
                                 channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                 config->qmode |= QMODE_REORDERED_CHANS;
                             }
 
                             if (layouts [i].mChannelIdentities)
                                 channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);
 
                             if (debug_logging_mode)
                                 error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                     channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");
 
                             break;
                         }
 
                     if (i == NUM_LAYOUTS && debug_logging_mode)
                         error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                             caf_channel_layout->mChannelLayoutTag);
 
                     break;
             }
 
             free (caf_channel_layout);
         }
         else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {      
             uint32_t mEditCount;
 
             if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                 bcount != sizeof (mEditCount)) {
                     error_line (""%s is not a valid .CAF file!"", infilename);
                     return WAVPACK_SOFT_ERROR;
             }
             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     return WAVPACK_SOFT_ERROR;
             }
 
             if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                 config->qmode |= QMODE_IGNORE_LENGTH;
 
                 if (infilesize && DoGetFilePosition (infile) != -1)
                     total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                 else
                     total_samples = -1;
             }
             else {
                 if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                     error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                     error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;
 
                 if (!total_samples) {
                     error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                     return WAVPACK_SOFT_ERROR;
                 }
 
                 if (total_samples > MAX_WAVPACK_SAMPLES) {
                     error_line (""%s has too many samples for WavPack!"", infilename);
                     return WAVPACK_SOFT_ERROR;
                 }
             }
 
             break;
          }
          else {           
  
            int bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff = malloc (bytes_to_copy);
             uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
             char *buff;
 
             if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                 error_line (""%s is not a valid .CAF file!"", infilename);
                 return WAVPACK_SOFT_ERROR;
             }
 
             buff = malloc (bytes_to_copy);
  
              if (debug_logging_mode)
                  error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                     caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                     caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);
 
             if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                 bcount != bytes_to_copy ||
                 (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                 !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                     error_line (""%s"", WavpackGetErrorMessage (wpc));
                     free (buff);
                     return WAVPACK_SOFT_ERROR;
             }
 
             free (buff);
         }
     }
 
     if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
         config->channel_mask = 0x5 - config->num_channels;
 
     if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
         error_line (""%s"", WavpackGetErrorMessage (wpc));
         return WAVPACK_SOFT_ERROR;
     }
 
     if (channel_identities)
         free (channel_identities);
 
     if (channel_layout || channel_reorder) {
         if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
             error_line (""problem with setting channel layout (should not happen)"");
             return WAVPACK_SOFT_ERROR;
         }
 
         if (channel_reorder)
             free (channel_reorder);
     }
 
     return WAVPACK_NO_ERROR;
 }","[122, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 348, 349, 350, 351, 352, 353, 354, 355, 356, 121, 124, 125, 346, 347]","The ParseCaffHeaderConfig function of the cli/caff.c file of WavPack 5.1.0 allows a remote attacker to cause a denial-of-service (global buffer over-read), or possibly trigger a buffer overflow or incorrect memory allocation, via a maliciously crafted CAF file."
207387,"  virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {
  Parcel data, reply;
         data.writeInterfaceToken(
  IMediaHTTPConnection::getInterfaceDescriptor());
 
         data.writeInt64(offset);
         data.writeInt32(size);
 
  status_t err = remote()->transact(READ_AT, data, &reply);
  if (err != OK) {
             ALOGE(""remote readAt failed"");
  return UNKNOWN_ERROR;
  }
 
  int32_t exceptionCode = reply.readExceptionCode();
 
  if (exceptionCode) {
 
              return UNKNOWN_ERROR;
          }
  
        int32_t len = reply.readInt32();
         size_t len = reply.readInt32();
  
        if (len > 0) {
            memcpy(buffer, mMemory->pointer(), len);
         if (len > size) {
             ALOGE(""requested %zu, got %zu"", size, len);
             return ERROR_OUT_OF_RANGE;
          }
         if (len > mMemory->size()) {
             ALOGE(""got %zu, but memory has %zu"", len, mMemory->size());
             return ERROR_OUT_OF_RANGE;
         }
 
         memcpy(buffer, mMemory->pointer(), len);
  
          return len;
      }","[23, 27, 28, 29, 31, 32, 33, 34, 35, 36, 22, 25, 26]","Buffer overflow in the readAt function in BpMediaHTTPConnection in media/libmedia/IMediaHTTPConnection.cpp in the mediaserver service in Android before 5.1.1 LMY48I allows attackers to execute arbitrary code via a crafted application, aka internal bug 19400722."
7906,"void Compute(OpKernelContext* context) override {







typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
ConstEigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>>
EigenMatrixMap;
typedef Eigen::Map<Eigen::Matrix<int64, Eigen::Dynamic, Eigen::Dynamic>>
EigenIndexMatrixMap;

const Tensor& tensor_in = context->input(0);
const Tensor& tensor_out = context->input(1);
const Tensor& out_backprop = context->input(2);
const Tensor& height_seq_tensor = context->input(3);
const Tensor& width_seq_tensor = context->input(4);


constexpr int tensor_in_and_out_dims = 4;
std::vector<int64> input_size(tensor_in_and_out_dims);
std::vector<int64> output_size(tensor_in_and_out_dims);
for (int i = 0; i < tensor_in_and_out_dims; ++i) {
input_size[i] = tensor_in.dim_size(i);
}
for (int i = 0; i < tensor_in_and_out_dims; ++i) {
output_size[i] = tensor_out.dim_size(i);
}




Tensor tensor_out_dup;
OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp(
{1}, DataTypeToEnum<T>::v(), tensor_out.shape(),
&tensor_out_dup));
Tensor tensor_out_arg_max;
OP_REQUIRES_OK(context, context->allocate_temp(DataTypeToEnum<int64>::v(),
tensor_out.shape(),
&tensor_out_arg_max));

ConstEigenMatrixMap tensor_in_mat(
tensor_in.flat<T>().data(), input_size[3],
input_size[2] * input_size[1] * input_size[0]);
EigenMatrixMap tensor_out_dup_mat(
tensor_out_dup.flat<T>().data(), output_size[3],
output_size[2] * output_size[1] * output_size[0]);
EigenIndexMatrixMap tensor_out_arg_max_mat(
tensor_out_arg_max.flat<int64>().data(), output_size[3],
output_size[2] * output_size[1] * output_size[0]);

tensor_out_arg_max.flat<int64>().setConstant(kInvalidMaxPoolingIndex);

tensor_out_dup.flat<T>().setConstant(Eigen::NumTraits<T>::lowest());

auto height_seq_tensor_flat = height_seq_tensor.flat<int64>();
auto width_seq_tensor_flat = width_seq_tensor.flat<int64>();







const int64 height_max = input_size[1] - 1;
const int64 width_max = input_size[2] - 1;
for (int64 b = 0; b < input_size[0]; ++b) {

for (int64 hs = 0; hs < height_seq_tensor.dim_size(0) - 1; ++hs) {

const int64 height_start = height_seq_tensor_flat(hs);
int64 height_end = overlapping_ ? height_seq_tensor_flat(hs + 1)
: height_seq_tensor_flat(hs + 1) - 1;
height_end = std::min(height_end, height_max);


for (int64 ws = 0; ws < width_seq_tensor.dim_size(0) - 1; ++ws) {
const int64 out_index =
(b * output_size[1] + hs) * output_size[2] + ws;

const int64 width_start = width_seq_tensor_flat(ws);
int64 width_end = overlapping_ ? width_seq_tensor_flat(ws + 1)
: width_seq_tensor_flat(ws + 1) - 1;
width_end = std::min(width_end, width_max);
for (int64 h = height_start; h <= height_end; ++h) {
for (int64 w = width_start; w <= width_end; ++w) {
const int64 in_index =
(b * input_size[1] + h) * input_size[2] + w;

for (int64 d = 0; d < input_size[3]; ++d) {
const T& input_ref = tensor_in_mat.coeffRef(d, in_index);
T& output_ref = tensor_out_dup_mat.coeffRef(d, out_index);
int64& out_arg_max_ref =
tensor_out_arg_max_mat.coeffRef(d, out_index);
if (output_ref < input_ref ||
out_arg_max_ref == kInvalidMaxPoolingIndex) {
output_ref = input_ref;
int input_offset = in_index * input_size[3] + d;
out_arg_max_ref = input_offset;
}
}
}
}
}
}
}


ConstEigenMatrixMap tensor_out_mat(
tensor_out.flat<T>().data(), output_size[3],
output_size[2] * output_size[1] * output_size[0]);
const int64 num_reshaped_cols =
output_size[2] * output_size[1] * output_size[0];
for (int64 i = 0; i < num_reshaped_cols; ++i) {
for (int64 j = 0; j < output_size[3]; ++j) {
DCHECK_EQ(tensor_out_dup_mat(j, i), tensor_out_mat(j, i));
}
}

Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(
{0}, 0, tensor_in.shape(), &output));
output->flat<T>().setZero();

auto out_backprop_flat = out_backprop.flat<T>();
auto input_backprop_flat = output->flat<T>();
auto out_arg_max_flat = tensor_out_arg_max.flat<int64>();
int num_total_outputs = out_backprop_flat.size();
int num_total_inputs = input_backprop_flat.size();

for (int index = 0; index < num_total_outputs; ++index) {
int input_backprop_index = out_arg_max_flat(index);

CHECK(input_backprop_index >= 0 &&
input_backprop_index < num_total_inputs)
<< ""Invalid input backprop index: "" << input_backprop_index << "", ""
<< num_total_inputs;
input_backprop_flat(input_backprop_index) += out_backprop_flat(index);
}
}",[24],"TensorFlow is an end-to-end open source platform for machine learning. The implementation of `tf.raw_ops.FractionalMaxPoolGrad` triggers an undefined behavior if one of the input tensors is empty. The code is also vulnerable to a denial of service attack as a `CHECK` condition becomes false and aborts the process. The implementation(https://github.com/tensorflow/tensorflow/blob/169054888d50ce488dfde9ca55d91d6325efbd5b/tensorflow/core/kernels/fractional_max_pool_op.cc#L215) fails to validate that input and output tensors are not empty and are of the same rank. Each of these unchecked assumptions is responsible for the above issues. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
207649," image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,
 image_transform_png_set_expand_16_mod(const image_transform *this,
      image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
     const transform_display *display)
  {
      
  if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
 
        image_pixel_convert_PLTE(that);
  
     if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
       image_pixel_add_alpha(that, &display->this, 0 );
  
     if (that->bit_depth < 16)
        that->sample_depth = that->bit_depth = 16;
 
  this->next->mod(this->next, that, pp, display);
 }","[2, 5, 14, 4, 13]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
9395,"void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,
const int c, const int kx, const int ky,
const int sx, const int sy,
const string& data_format,
const string& padding) {
OpContext op_context;
int ho;
int wo;
if (data_format == ""NHWC"") {
op_context = DescribePoolingOp(""MaxPool"", {n, h, w, c}, {1, kx, ky, 1},
{1, sx, sy, 1}, ""NHWC"", padding);
ho = op_context.op_info.outputs(0).shape().dim(1).size();
wo = op_context.op_info.outputs(0).shape().dim(2).size();
} else {
op_context = DescribePoolingOp(""MaxPool"", {n, c, h, w}, {1, 1, kx, ky},
{1, 1, sx, sy}, ""NCHW"", padding);
ho = op_context.op_info.outputs(0).shape().dim(2).size();
wo = op_context.op_info.outputs(0).shape().dim(3).size();
}

bool found_unknown_shapes;
auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(
op_context.op_info.inputs(0).shape(), op_context.op_info,
&found_unknown_shapes);
Padding padding_enum;
if (padding == ""VALID"") {
padding_enum = Padding::VALID;
} else {
padding_enum = Padding::SAME;
}
EXPECT_EQ(n, dims.batch);
EXPECT_EQ(h, dims.ix);
EXPECT_EQ(w, dims.iy);
EXPECT_EQ(c, dims.iz);
EXPECT_EQ(kx, dims.kx);
EXPECT_EQ(ky, dims.ky);
EXPECT_EQ(sx, dims.sx);
EXPECT_EQ(sy, dims.sy);
EXPECT_EQ(ho, dims.ox);
EXPECT_EQ(wo, dims.oy);
EXPECT_EQ(c, dims.oz);
EXPECT_EQ(padding_enum, dims.padding);
}","[22, 23, 24]","Tensorflow is an Open Source Machine Learning Framework. The estimator for the cost of some convolution operations can be made to execute a division by 0. The function fails to check that the stride argument is strictly positive. Hence, the fix is to add a check for the stride argument to ensure it is valid. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
202555," int sas_discover_sata(struct domain_device *dev)
 {
 	int res;
 
 	if (dev->dev_type == SAS_SATA_PM)
 		return -ENODEV;
 
 	dev->sata_dev.class = sas_get_ata_command_set(dev);
 	sas_fill_in_rphy(dev, dev->rphy);
 
 	res = sas_notify_lldd_dev_found(dev);
  	if (res)
  		return res;
  
	sas_discover_event(dev->port, DISCE_PROBE);
  	return 0;
  }",[15],"The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code."
203631," WebGLObject::WebGLObject(WebGLRenderingContext* context)
 WebGLObject::WebGLObject(WebGLRenderingContext*)
      : m_object(0)
      , m_attachmentCount(0)
      , m_deleted(false)
 {
 }",[2],"Google Chrome before 16.0.912.63 does not properly handle PDF cross references, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
198959," asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long write,
 			      unsigned long address)
 {
 	struct vm_area_struct * vma = NULL;
 	struct task_struct *tsk = current;
 	struct mm_struct *mm = tsk->mm;
 	const int field = sizeof(unsigned long) * 2;
 	siginfo_t info;
 	int fault;
 
 #if 0
 	printk(""Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n"", raw_smp_processor_id(),
 	       current->comm, current->pid, field, address, write,
 	       field, regs->cp0_epc);
 #endif
 
 #ifdef CONFIG_KPROBES
 	 
 	if (notify_die(DIE_PAGE_FAULT, ""page fault"", regs, -1,
 		       (regs->cp0_cause >> 2) & 0x1f, SIGSEGV) == NOTIFY_STOP)
 		return;
 #endif
 
 	info.si_code = SEGV_MAPERR;
 
 	 
 #ifdef CONFIG_64BIT
 # define VMALLOC_FAULT_TARGET no_context
 #else
 # define VMALLOC_FAULT_TARGET vmalloc_fault
 #endif
 
 	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))
 		goto VMALLOC_FAULT_TARGET;
 #ifdef MODULE_START
 	if (unlikely(address >= MODULE_START && address < MODULE_END))
 		goto VMALLOC_FAULT_TARGET;
 #endif
 
 	 
 	if (in_atomic() || !mm)
 		goto bad_area_nosemaphore;
 
 	down_read(&mm->mmap_sem);
 	vma = find_vma(mm, address);
 	if (!vma)
 		goto bad_area;
 	if (vma->vm_start <= address)
 		goto good_area;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		goto bad_area;
 	if (expand_stack(vma, address))
 		goto bad_area;
  
 good_area:
 	info.si_code = SEGV_ACCERR;
 
 	if (write) {
 		if (!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
 		if (kernel_uses_smartmips_rixi) {
 			if (address == regs->cp0_epc && !(vma->vm_flags & VM_EXEC)) {
 #if 0
 				pr_notice(""Cpu%d[%s:%d:%0*lx:%ld:%0*lx] XI violation\n"",
 					  raw_smp_processor_id(),
 					  current->comm, current->pid,
 					  field, address, write,
 					  field, regs->cp0_epc);
 #endif
 				goto bad_area;
 			}
 			if (!(vma->vm_flags & VM_READ)) {
 #if 0
 				pr_notice(""Cpu%d[%s:%d:%0*lx:%ld:%0*lx] RI violation\n"",
 					  raw_smp_processor_id(),
 					  current->comm, current->pid,
 					  field, address, write,
 					  field, regs->cp0_epc);
 #endif
 				goto bad_area;
 			}
 		} else {
 			if (!(vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)))
 				goto bad_area;
 		}
 	}
 
 	 
  	fault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);
	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);
 	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
  	if (unlikely(fault & VM_FAULT_ERROR)) {
  		if (fault & VM_FAULT_OOM)
  			goto out_of_memory;
 		else if (fault & VM_FAULT_SIGBUS)
 			goto do_sigbus;
  		BUG();
  	}
  	if (fault & VM_FAULT_MAJOR) {
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,
				1, 0, regs, address);
 		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);
  		tsk->maj_flt++;
  	} else {
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,
				1, 0, regs, address);
 		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);
  		tsk->min_flt++;
  	}
  
 	up_read(&mm->mmap_sem);
 	return;
 
  
 bad_area:
 	up_read(&mm->mmap_sem);
 
 bad_area_nosemaphore:
 	 
 	if (user_mode(regs)) {
 		tsk->thread.cp0_badvaddr = address;
 		tsk->thread.error_code = write;
 #if 0
 		printk(""do_page_fault() #2: sending SIGSEGV to %s for ""
 		       ""invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n"",
 		       tsk->comm,
 		       write ? ""write access to"" : ""read access from"",
 		       field, address,
 		       field, (unsigned long) regs->cp0_epc,
 		       field, (unsigned long) regs->regs[31]);
 #endif
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		 
 		info.si_addr = (void __user *) address;
 		force_sig_info(SIGSEGV, &info, tsk);
 		return;
 	}
 
 no_context:
 	 
 	if (fixup_exception(regs)) {
 		current->thread.cp0_baduaddr = address;
 		return;
 	}
 
 	 
 	bust_spinlocks(1);
 
 	printk(KERN_ALERT ""CPU %d Unable to handle kernel paging request at ""
 	       ""virtual address %0*lx, epc == %0*lx, ra == %0*lx\n"",
 	       raw_smp_processor_id(), field, address, field, regs->cp0_epc,
 	       field,  regs->regs[31]);
 	die(""Oops"", regs);
 
 out_of_memory:
 	 
 	up_read(&mm->mmap_sem);
 	pagefault_out_of_memory();
 	return;
 
 do_sigbus:
 	up_read(&mm->mmap_sem);
 
 	 
 	if (!user_mode(regs))
 		goto no_context;
 	else
 	 
 #if 0
 		printk(""do_page_fault() #3: sending SIGBUS to %s for ""
 		       ""invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n"",
 		       tsk->comm,
 		       write ? ""write access to"" : ""read access from"",
 		       field, address,
 		       field, (unsigned long) regs->cp0_epc,
 		       field, (unsigned long) regs->regs[31]);
 #endif
 	tsk->thread.cp0_badvaddr = address;
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
 	info.si_code = BUS_ADRERR;
 	info.si_addr = (void __user *) address;
 	force_sig_info(SIGBUS, &info, tsk);
 
 	return;
 #ifndef CONFIG_64BIT
 vmalloc_fault:
 	{
 		 
 		int offset = __pgd_offset(address);
 		pgd_t *pgd, *pgd_k;
 		pud_t *pud, *pud_k;
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
 		pgd = (pgd_t *) pgd_current[raw_smp_processor_id()] + offset;
 		pgd_k = init_mm.pgd + offset;
 
 		if (!pgd_present(*pgd_k))
 			goto no_context;
 		set_pgd(pgd, *pgd_k);
 
 		pud = pud_offset(pgd, address);
 		pud_k = pud_offset(pgd_k, address);
 		if (!pud_present(*pud_k))
 			goto no_context;
 
 		pmd = pmd_offset(pud, address);
 		pmd_k = pmd_offset(pud_k, address);
 		if (!pmd_present(*pmd_k))
 			goto no_context;
 		set_pmd(pmd, *pmd_k);
 
 		pte_k = pte_offset_kernel(pmd_k, address);
 		if (!pte_present(*pte_k))
 			goto no_context;
 		return;
 	}
 #endif
 }","[92, 103, 108, 91, 101, 102, 106, 107]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
199663," int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
 				struct msghdr *msg, size_t len, int flags)
 {
 	int noblock = flags & MSG_DONTWAIT;
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
 	size_t copied;
 	int err;
 
 	BT_DBG(""sock %p sk %p len %zu"", sock, sk, len);
 
 	if (flags & (MSG_OOB))
 		return -EOPNOTSUPP;
  
  	skb = skb_recv_datagram(sk, flags, noblock, &err);
  	if (!skb) {
		if (sk->sk_shutdown & RCV_SHUTDOWN) {
			msg->msg_namelen = 0;
 		if (sk->sk_shutdown & RCV_SHUTDOWN)
  			return 0;
		}
 
  		return err;
  	}
  
 	copied = skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
 		copied = len;
 	}
 
 	skb_reset_transport_header(skb);
 	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (err == 0) {
 		sock_recv_ts_and_drops(msg, sk, skb);
 
  		if (bt_sk(sk)->skb_msg_name)
  			bt_sk(sk)->skb_msg_name(skb, msg->msg_name,
  						&msg->msg_namelen);
		else
			msg->msg_namelen = 0;
  	}
  
  	skb_free_datagram(sk, skb);
 
 	return err ? : copied;
 }","[19, 22, 17, 18, 21, 40, 41]","The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
208041," static void copyMultiCh24(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels)
 static void copyMultiCh24(short *dst, const int * src[FLACParser::kMaxChannels], unsigned nSamples, unsigned nChannels)
  {
      for (unsigned i = 0; i < nSamples; ++i) {
          for (unsigned c = 0; c < nChannels; ++c) {
  *dst++ = src[c][i] >> 8;
  }
  }
 }",[2],"A remote code execution vulnerability in FLACExtractor.cpp in libstagefright in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-34970788."
207505," bool semaphore_try_wait(semaphore_t *semaphore) {
 
    assert(semaphore != NULL);
    assert(semaphore->fd != INVALID_FD);
  
  int flags = fcntl(semaphore->fd, F_GETFL);
   int flags = TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_GETFL));
    if (flags == -1) {
      LOG_ERROR(""%s unable to get flags for semaphore fd: %s"", __func__, strerror(errno));
      return false;
    }
  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
   if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK)) == -1) {
      LOG_ERROR(""%s unable to set O_NONBLOCK for semaphore fd: %s"", __func__, strerror(errno));
      return false;
    }
 
  eventfd_t value;
 
    if (eventfd_read(semaphore->fd, &value) == -1)
      return false;
  
  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
   if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags)) == -1)
      LOG_ERROR(""%s unable to resetore flags for semaphore fd: %s"", __func__, strerror(errno));
    return true;
  }","[7, 13, 24, 6, 12, 23]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
201601," static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)
 {
     unsigned int length, type, size;
     int tlsext_servername = 0;
     int renegotiate_seen = 0;
 
 #ifndef OPENSSL_NO_NEXTPROTONEG
     s->s3->next_proto_neg_seen = 0;
 #endif
     s->tlsext_ticket_expected = 0;
 
     OPENSSL_free(s->s3->alpn_selected);
     s->s3->alpn_selected = NULL;
 #ifndef OPENSSL_NO_HEARTBEATS
     s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED |
                               SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);
  #endif
  
    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;
     s->tlsext_use_etm = 0;
  
      s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;
  
     if (!PACKET_get_net_2(pkt, &length))
         goto ri_check;
 
     if (PACKET_remaining(pkt) != length) {
         *al = SSL_AD_DECODE_ERROR;
         return 0;
     }
 
     if (!tls1_check_duplicate_extensions(pkt)) {
         *al = SSL_AD_DECODE_ERROR;
         return 0;
     }
 
     while (PACKET_get_net_2(pkt, &type) && PACKET_get_net_2(pkt, &size)) {
         const unsigned char *data;
         PACKET spkt;
 
         if (!PACKET_get_sub_packet(pkt, &spkt, size)
             || !PACKET_peek_bytes(&spkt, &data, size))
             goto ri_check;
 
         if (s->tlsext_debug_cb)
             s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg);
 
         if (type == TLSEXT_TYPE_renegotiate) {
             if (!ssl_parse_serverhello_renegotiate_ext(s, &spkt, al))
                 return 0;
             renegotiate_seen = 1;
         } else if (s->version == SSL3_VERSION) {
         } else if (type == TLSEXT_TYPE_server_name) {
             if (s->tlsext_hostname == NULL || size > 0) {
                 *al = TLS1_AD_UNRECOGNIZED_NAME;
                 return 0;
             }
             tlsext_servername = 1;
         }
 #ifndef OPENSSL_NO_EC
         else if (type == TLSEXT_TYPE_ec_point_formats) {
             unsigned int ecpointformatlist_length;
             if (!PACKET_get_1(&spkt, &ecpointformatlist_length)
                 || ecpointformatlist_length != size - 1) {
                 *al = TLS1_AD_DECODE_ERROR;
                 return 0;
             }
             if (!s->hit) {
                 s->session->tlsext_ecpointformatlist_length = 0;
                 OPENSSL_free(s->session->tlsext_ecpointformatlist);
                 if ((s->session->tlsext_ecpointformatlist =
                      OPENSSL_malloc(ecpointformatlist_length)) == NULL) {
                     *al = TLS1_AD_INTERNAL_ERROR;
                     return 0;
                 }
                 s->session->tlsext_ecpointformatlist_length =
                     ecpointformatlist_length;
                 if (!PACKET_copy_bytes(&spkt,
                                        s->session->tlsext_ecpointformatlist,
                                        ecpointformatlist_length)) {
                     *al = TLS1_AD_DECODE_ERROR;
                     return 0;
                 }
 
             }
         }
 #endif                           
 
         else if (type == TLSEXT_TYPE_session_ticket) {
             if (s->tls_session_ticket_ext_cb &&
                 !s->tls_session_ticket_ext_cb(s, data, size,
                                               s->tls_session_ticket_ext_cb_arg))
             {
                 *al = TLS1_AD_INTERNAL_ERROR;
                 return 0;
             }
             if (!tls_use_ticket(s) || (size > 0)) {
                 *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                 return 0;
             }
             s->tlsext_ticket_expected = 1;
         } else if (type == TLSEXT_TYPE_status_request) {
              
             if ((s->tlsext_status_type == -1) || (size > 0)) {
                 *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                 return 0;
             }
              
             s->tlsext_status_expected = 1;
         }
 #ifndef OPENSSL_NO_CT
          
         else if (type == TLSEXT_TYPE_signed_certificate_timestamp &&
                  s->ct_validation_callback != NULL) {
              
             if (s->tlsext_scts != NULL) {
                 OPENSSL_free(s->tlsext_scts);
                 s->tlsext_scts = NULL;
             }
             s->tlsext_scts_len = size;
             if (size > 0) {
                 s->tlsext_scts = OPENSSL_malloc(size);
                 if (s->tlsext_scts == NULL) {
                     *al = TLS1_AD_INTERNAL_ERROR;
                     return 0;
                 }
                 memcpy(s->tlsext_scts, data, size);
             }
         }
 #endif
 #ifndef OPENSSL_NO_NEXTPROTONEG
         else if (type == TLSEXT_TYPE_next_proto_neg &&
                  s->s3->tmp.finish_md_len == 0) {
             unsigned char *selected;
             unsigned char selected_len;
              
             if (s->ctx->next_proto_select_cb == NULL) {
                 *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                 return 0;
             }
              
             if (!ssl_next_proto_validate(&spkt)) {
                 *al = TLS1_AD_DECODE_ERROR;
                 return 0;
             }
             if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data,
                                              size,
                                              s->
                                              ctx->next_proto_select_cb_arg) !=
                 SSL_TLSEXT_ERR_OK) {
                 *al = TLS1_AD_INTERNAL_ERROR;
                 return 0;
             }
              
             OPENSSL_free(s->next_proto_negotiated);
             s->next_proto_negotiated = OPENSSL_malloc(selected_len);
             if (s->next_proto_negotiated == NULL) {
                 *al = TLS1_AD_INTERNAL_ERROR;
                 return 0;
             }
             memcpy(s->next_proto_negotiated, selected, selected_len);
             s->next_proto_negotiated_len = selected_len;
             s->s3->next_proto_neg_seen = 1;
         }
 #endif
 
         else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) {
             unsigned len;
              
             if (!s->s3->alpn_sent) {
                 *al = TLS1_AD_UNSUPPORTED_EXTENSION;
                 return 0;
             }
              
             if (!PACKET_get_net_2(&spkt, &len)
                 || PACKET_remaining(&spkt) != len || !PACKET_get_1(&spkt, &len)
                 || PACKET_remaining(&spkt) != len) {
                 *al = TLS1_AD_DECODE_ERROR;
                 return 0;
             }
             OPENSSL_free(s->s3->alpn_selected);
             s->s3->alpn_selected = OPENSSL_malloc(len);
             if (s->s3->alpn_selected == NULL) {
                 *al = TLS1_AD_INTERNAL_ERROR;
                 return 0;
             }
             if (!PACKET_copy_bytes(&spkt, s->s3->alpn_selected, len)) {
                 *al = TLS1_AD_DECODE_ERROR;
                 return 0;
             }
             s->s3->alpn_selected_len = len;
         }
 #ifndef OPENSSL_NO_HEARTBEATS
         else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) {
             unsigned int hbtype;
             if (!PACKET_get_1(&spkt, &hbtype)) {
                 *al = SSL_AD_DECODE_ERROR;
                 return 0;
             }
             switch (hbtype) {
             case 0x01:          
                 s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;
                 break;
             case 0x02:          
                 s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED;
                 s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS;
                 break;
             default:
                 *al = SSL_AD_ILLEGAL_PARAMETER;
                 return 0;
             }
         }
 #endif
 #ifndef OPENSSL_NO_SRTP
         else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) {
             if (ssl_parse_serverhello_use_srtp_ext(s, &spkt, al))
                 return 0;
         }
 #endif
         else if (type == TLSEXT_TYPE_encrypt_then_mac) {
               
              if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD
                  && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)
                s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;
                 s->tlsext_use_etm = 1;
          } else if (type == TLSEXT_TYPE_extended_master_secret) {
              s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;
              if (!s->hit)
                 s->session->flags |= SSL_SESS_FLAG_EXTMS;
         }
          
         else if (custom_ext_parse(s, 0, type, data, size, al) <= 0)
             return 0;
     }
 
     if (PACKET_remaining(pkt) != 0) {
         *al = SSL_AD_DECODE_ERROR;
         return 0;
     }
 
     if (!s->hit && tlsext_servername == 1) {
         if (s->tlsext_hostname) {
             if (s->session->tlsext_hostname == NULL) {
                 s->session->tlsext_hostname =
                     OPENSSL_strdup(s->tlsext_hostname);
                 if (!s->session->tlsext_hostname) {
                     *al = SSL_AD_UNRECOGNIZED_NAME;
                     return 0;
                 }
             } else {
                 *al = SSL_AD_DECODE_ERROR;
                 return 0;
             }
         }
     }
 
  ri_check:
 
      
     if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)
         && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {
         *al = SSL_AD_HANDSHAKE_FAILURE;
         SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,
                SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);
         return 0;
     }
 
     if (s->hit) {
          
         if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) !=
             !(s->session->flags & SSL_SESS_FLAG_EXTMS)) {
             *al = SSL_AD_HANDSHAKE_FAILURE;
             SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_INCONSISTENT_EXTMS);
             return 0;
         }
     }
 
     return 1;
 }","[20, 225, 19, 224]",During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected.
198908," void vlan_setup(struct net_device *dev)
 {
  	ether_setup(dev);
  
  	dev->priv_flags		|= IFF_802_1Q_VLAN;
	dev->priv_flags		&= ~IFF_XMIT_DST_RELEASE;
 	dev->priv_flags		&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);
  	dev->tx_queue_len	= 0;
  
  	dev->netdev_ops		= &vlan_netdev_ops;
 	dev->destructor		= free_netdev;
 	dev->ethtool_ops	= &vlan_ethtool_ops;
 
 	memset(dev->broadcast, 0, ETH_ALEN);
 }","[7, 6]","The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface."
205068," RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(
     RenderWidgetHostImpl* widget_host,
     ContentViewCoreImpl* content_view_core)
     : host_(widget_host),
       is_layer_attached_(true),
        content_view_core_(NULL),
        ime_adapter_android_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
        cached_background_color_(SK_ColorWHITE),
      texture_id_in_layer_(0) {
       texture_id_in_layer_(0),
       current_buffer_id_(0) {
    if (CompositorImpl::UsesDirectGL()) {
      surface_texture_transport_.reset(new SurfaceTextureTransportClient());
      layer_ = surface_texture_transport_->Initialize();
   } else {
     texture_layer_ = cc::TextureLayer::create(0);
     layer_ = texture_layer_;
   }
 
   layer_->setContentsOpaque(true);
   layer_->setIsDrawable(true);
 
   host_->SetView(this);
   SetContentViewCore(content_view_core);
 }","[10, 11, 9]","Google Chrome before 25.0.1364.99 on Mac OS X does not properly implement signal handling for Native Client (aka NaCl) code, which has unspecified impact and attack vectors."
208521," void usage_exit() {
 void usage_exit(void) {
    fprintf(stderr, ""Usage: %s <width> <height> <infile> <outfile> <frame>\n"",
            exec_name);
    exit(EXIT_FAILURE);
  }",[2],"libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
200760," void __detach_mounts(struct dentry *dentry)
 {
 	struct mountpoint *mp;
 	struct mount *mnt;
 
 	namespace_lock();
 	mp = lookup_mountpoint(dentry);
 	if (!mp)
 		goto out_unlock;
 
  	lock_mount_hash();
  	while (!hlist_empty(&mp->m_list)) {
  		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		umount_tree(mnt, 0);
 		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
 			struct mount *p, *tmp;
 			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
 				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
 		else umount_tree(mnt, 0);
  	}
  	unlock_mount_hash();
  	put_mountpoint(mp);
 out_unlock:
 	namespace_unlock();
 }","[15, 16, 17, 18, 19, 20, 21, 22, 14]","fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace."
198579," static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,
                       Error **errp)
 {
     BDRVQcowState *s = bs->opaque;
     unsigned int len, i;
     int ret = 0;
     QCowHeader header;
     QemuOpts *opts;
     Error *local_err = NULL;
     uint64_t ext_end;
     uint64_t l1_vm_state_index;
     const char *opt_overlap_check;
     int overlap_check_template = 0;
 
     ret = bdrv_pread(bs->file, 0, &header, sizeof(header));
     if (ret < 0) {
         error_setg_errno(errp, -ret, ""Could not read qcow2 header"");
         goto fail;
     }
     be32_to_cpus(&header.magic);
     be32_to_cpus(&header.version);
     be64_to_cpus(&header.backing_file_offset);
     be32_to_cpus(&header.backing_file_size);
     be64_to_cpus(&header.size);
     be32_to_cpus(&header.cluster_bits);
     be32_to_cpus(&header.crypt_method);
     be64_to_cpus(&header.l1_table_offset);
     be32_to_cpus(&header.l1_size);
     be64_to_cpus(&header.refcount_table_offset);
     be32_to_cpus(&header.refcount_table_clusters);
     be64_to_cpus(&header.snapshots_offset);
     be32_to_cpus(&header.nb_snapshots);
 
     if (header.magic != QCOW_MAGIC) {
         error_setg(errp, ""Image is not in qcow2 format"");
         ret = -EINVAL;
         goto fail;
     }
     if (header.version < 2 || header.version > 3) {
         report_unsupported(bs, errp, ""QCOW version %d"", header.version);
         ret = -ENOTSUP;
         goto fail;
     }
 
     s->qcow_version = header.version;
 
      
     if (header.cluster_bits < MIN_CLUSTER_BITS ||
         header.cluster_bits > MAX_CLUSTER_BITS) {
         error_setg(errp, ""Unsupported cluster size: 2^%i"", header.cluster_bits);
         ret = -EINVAL;
         goto fail;
     }
 
     s->cluster_bits = header.cluster_bits;
     s->cluster_size = 1 << s->cluster_bits;
     s->cluster_sectors = 1 << (s->cluster_bits - 9);
 
      
     if (header.version == 2) {
         header.incompatible_features    = 0;
         header.compatible_features      = 0;
         header.autoclear_features       = 0;
         header.refcount_order           = 4;
         header.header_length            = 72;
     } else {
         be64_to_cpus(&header.incompatible_features);
         be64_to_cpus(&header.compatible_features);
         be64_to_cpus(&header.autoclear_features);
         be32_to_cpus(&header.refcount_order);
         be32_to_cpus(&header.header_length);
 
         if (header.header_length < 104) {
             error_setg(errp, ""qcow2 header too short"");
             ret = -EINVAL;
             goto fail;
         }
     }
 
     if (header.header_length > s->cluster_size) {
         error_setg(errp, ""qcow2 header exceeds cluster size"");
         ret = -EINVAL;
         goto fail;
     }
 
     if (header.header_length > sizeof(header)) {
         s->unknown_header_fields_size = header.header_length - sizeof(header);
         s->unknown_header_fields = g_malloc(s->unknown_header_fields_size);
         ret = bdrv_pread(bs->file, sizeof(header), s->unknown_header_fields,
                          s->unknown_header_fields_size);
         if (ret < 0) {
             error_setg_errno(errp, -ret, ""Could not read unknown qcow2 header ""
                              ""fields"");
             goto fail;
         }
     }
 
     if (header.backing_file_offset > s->cluster_size) {
         error_setg(errp, ""Invalid backing file offset"");
         ret = -EINVAL;
         goto fail;
     }
 
     if (header.backing_file_offset) {
         ext_end = header.backing_file_offset;
     } else {
         ext_end = 1 << header.cluster_bits;
     }
 
      
     s->incompatible_features    = header.incompatible_features;
     s->compatible_features      = header.compatible_features;
     s->autoclear_features       = header.autoclear_features;
 
     if (s->incompatible_features & ~QCOW2_INCOMPAT_MASK) {
         void *feature_table = NULL;
         qcow2_read_extensions(bs, header.header_length, ext_end,
                               &feature_table, NULL);
         report_unsupported_feature(bs, errp, feature_table,
                                    s->incompatible_features &
                                    ~QCOW2_INCOMPAT_MASK);
         ret = -ENOTSUP;
         g_free(feature_table);
         goto fail;
     }
 
     if (s->incompatible_features & QCOW2_INCOMPAT_CORRUPT) {
          
         if ((flags & BDRV_O_RDWR) && !(flags & BDRV_O_CHECK)) {
             error_setg(errp, ""qcow2: Image is corrupt; cannot be opened ""
                        ""read/write"");
             ret = -EACCES;
             goto fail;
         }
     }
 
      
     if (header.refcount_order != 4) {
         report_unsupported(bs, errp, ""%d bit reference counts"",
                            1 << header.refcount_order);
         ret = -ENOTSUP;
         goto fail;
     }
     s->refcount_order = header.refcount_order;
 
     if (header.crypt_method > QCOW_CRYPT_AES) {
         error_setg(errp, ""Unsupported encryption method: %i"",
                    header.crypt_method);
         ret = -EINVAL;
         goto fail;
     }
     s->crypt_method_header = header.crypt_method;
     if (s->crypt_method_header) {
         bs->encrypted = 1;
     }
 
     s->l2_bits = s->cluster_bits - 3;  
     s->l2_size = 1 << s->l2_bits;
     bs->total_sectors = header.size / 512;
     s->csize_shift = (62 - (s->cluster_bits - 8));
     s->csize_mask = (1 << (s->cluster_bits - 8)) - 1;
     s->cluster_offset_mask = (1LL << s->csize_shift) - 1;
 
     s->refcount_table_offset = header.refcount_table_offset;
     s->refcount_table_size =
         header.refcount_table_clusters << (s->cluster_bits - 3);
 
     if (header.refcount_table_clusters > qcow2_max_refcount_clusters(s)) {
         error_setg(errp, ""Reference count table too large"");
         ret = -EINVAL;
         goto fail;
     }
 
     ret = validate_table_offset(bs, s->refcount_table_offset,
                                 s->refcount_table_size, sizeof(uint64_t));
     if (ret < 0) {
         error_setg(errp, ""Invalid reference count table offset"");
         goto fail;
     }
 
      
     if (header.nb_snapshots > QCOW_MAX_SNAPSHOTS) {
         error_setg(errp, ""Too many snapshots"");
         ret = -EINVAL;
         goto fail;
     }
 
     ret = validate_table_offset(bs, header.snapshots_offset,
                                 header.nb_snapshots,
                                 sizeof(QCowSnapshotHeader));
     if (ret < 0) {
         error_setg(errp, ""Invalid snapshot table offset"");
         goto fail;
      }
  
       
    if (header.l1_size > 0x2000000) {
         
     if (header.l1_size > QCOW_MAX_L1_SIZE) {
          error_setg(errp, ""Active L1 table too large"");
          ret = -EFBIG;
          goto fail;
         ret = -EFBIG;
         goto fail;
     }
     s->l1_size = header.l1_size;
 
     l1_vm_state_index = size_to_l1(s, header.size);
     if (l1_vm_state_index > INT_MAX) {
         error_setg(errp, ""Image is too big"");
         ret = -EFBIG;
         goto fail;
     }
     s->l1_vm_state_index = l1_vm_state_index;
 
      
     if (s->l1_size < s->l1_vm_state_index) {
         error_setg(errp, ""L1 table is too small"");
         ret = -EINVAL;
         goto fail;
     }
 
     ret = validate_table_offset(bs, header.l1_table_offset,
                                 header.l1_size, sizeof(uint64_t));
     if (ret < 0) {
         error_setg(errp, ""Invalid L1 table offset"");
         goto fail;
     }
     s->l1_table_offset = header.l1_table_offset;
 
 
     if (s->l1_size > 0) {
         s->l1_table = g_malloc0(
             align_offset(s->l1_size * sizeof(uint64_t), 512));
         ret = bdrv_pread(bs->file, s->l1_table_offset, s->l1_table,
                          s->l1_size * sizeof(uint64_t));
         if (ret < 0) {
             error_setg_errno(errp, -ret, ""Could not read L1 table"");
             goto fail;
         }
         for(i = 0;i < s->l1_size; i++) {
             be64_to_cpus(&s->l1_table[i]);
         }
     }
 
      
     s->l2_table_cache = qcow2_cache_create(bs, L2_CACHE_SIZE);
     s->refcount_block_cache = qcow2_cache_create(bs, REFCOUNT_CACHE_SIZE);
 
     s->cluster_cache = g_malloc(s->cluster_size);
      
     s->cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size
                                   + 512);
     s->cluster_cache_offset = -1;
     s->flags = flags;
 
     ret = qcow2_refcount_init(bs);
     if (ret != 0) {
         error_setg_errno(errp, -ret, ""Could not initialize refcount handling"");
         goto fail;
     }
 
     QLIST_INIT(&s->cluster_allocs);
     QTAILQ_INIT(&s->discards);
 
      
     if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,
         &local_err)) {
         error_propagate(errp, local_err);
         ret = -EINVAL;
         goto fail;
     }
 
      
     if (header.backing_file_offset != 0) {
         len = header.backing_file_size;
         if (len > MIN(1023, s->cluster_size - header.backing_file_offset)) {
             error_setg(errp, ""Backing file name too long"");
             ret = -EINVAL;
             goto fail;
         }
         ret = bdrv_pread(bs->file, header.backing_file_offset,
                          bs->backing_file, len);
         if (ret < 0) {
             error_setg_errno(errp, -ret, ""Could not read backing file name"");
             goto fail;
         }
         bs->backing_file[len] = '\0';
     }
 
      
     s->snapshots_offset = header.snapshots_offset;
     s->nb_snapshots = header.nb_snapshots;
 
     ret = qcow2_read_snapshots(bs);
     if (ret < 0) {
         error_setg_errno(errp, -ret, ""Could not read snapshots"");
         goto fail;
     }
 
      
     if (!bs->read_only && !(flags & BDRV_O_INCOMING) && s->autoclear_features) {
         s->autoclear_features = 0;
         ret = qcow2_update_header(bs);
         if (ret < 0) {
             error_setg_errno(errp, -ret, ""Could not update qcow2 header"");
             goto fail;
         }
     }
 
      
     qemu_co_mutex_init(&s->lock);
 
      
     if (!(flags & (BDRV_O_CHECK | BDRV_O_INCOMING)) && !bs->read_only &&
         (s->incompatible_features & QCOW2_INCOMPAT_DIRTY)) {
         BdrvCheckResult result = {0};
 
         ret = qcow2_check(bs, &result, BDRV_FIX_ERRORS);
         if (ret < 0) {
             error_setg_errno(errp, -ret, ""Could not repair dirty image"");
             goto fail;
         }
     }
 
      
     opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);
     qemu_opts_absorb_qdict(opts, options, &local_err);
     if (local_err) {
         error_propagate(errp, local_err);
         ret = -EINVAL;
         goto fail;
     }
 
     s->use_lazy_refcounts = qemu_opt_get_bool(opts, QCOW2_OPT_LAZY_REFCOUNTS,
         (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS));
 
     s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;
     s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;
     s->discard_passthrough[QCOW2_DISCARD_REQUEST] =
         qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,
                           flags & BDRV_O_UNMAP);
     s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =
         qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);
     s->discard_passthrough[QCOW2_DISCARD_OTHER] =
         qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);
 
     opt_overlap_check = qemu_opt_get(opts, ""overlap-check"") ?: ""cached"";
     if (!strcmp(opt_overlap_check, ""none"")) {
         overlap_check_template = 0;
     } else if (!strcmp(opt_overlap_check, ""constant"")) {
         overlap_check_template = QCOW2_OL_CONSTANT;
     } else if (!strcmp(opt_overlap_check, ""cached"")) {
         overlap_check_template = QCOW2_OL_CACHED;
     } else if (!strcmp(opt_overlap_check, ""all"")) {
         overlap_check_template = QCOW2_OL_ALL;
     } else {
         error_setg(errp, ""Unsupported value '%s' for qcow2 option ""
                    ""'overlap-check'. Allowed are either of the following: ""
                    ""none, constant, cached, all"", opt_overlap_check);
         qemu_opts_del(opts);
         ret = -EINVAL;
         goto fail;
     }
 
     s->overlap_check = 0;
     for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {
          
         s->overlap_check |=
             qemu_opt_get_bool(opts, overlap_bool_option_names[i],
                               overlap_check_template & (1 << i)) << i;
     }
 
     qemu_opts_del(opts);
 
     if (s->use_lazy_refcounts && s->qcow_version < 3) {
         error_setg(errp, ""Lazy refcounts require a qcow2 image with at least ""
                    ""qemu 1.1 compatibility level"");
         ret = -EINVAL;
         goto fail;
     }
 
 #ifdef DEBUG_ALLOC
     {
         BdrvCheckResult result = {0};
         qcow2_check_refcounts(bs, &result, 0);
     }
 #endif
     return ret;
 
  fail:
     g_free(s->unknown_header_fields);
     cleanup_unknown_header_ext(bs);
     qcow2_free_snapshots(bs);
     qcow2_refcount_close(bs);
     g_free(s->l1_table);
      
     s->l1_table = NULL;
     if (s->l2_table_cache) {
         qcow2_cache_destroy(bs, s->l2_table_cache);
     }
     if (s->refcount_block_cache) {
         qcow2_cache_destroy(bs, s->refcount_block_cache);
     }
     g_free(s->cluster_cache);
     qemu_vfree(s->cluster_data);
     return ret;
 }","[199, 197, 198]","Multiple integer overflows in the block drivers in QEMU, possibly before 2.0.0, allow local users to cause a denial of service (crash) via a crafted catalog size in (1) the parallels_open function in block/parallels.c or (2) bochs_open function in bochs.c, a large L1 table in the (3) qcow2_snapshot_load_tmp in qcow2-snapshot.c or (4) qcow2_grow_l1_table function in qcow2-cluster.c, (5) a large request in the bdrv_check_byte_request function in block.c and other block drivers, (6) crafted cluster indexes in the get_refcount function in qcow2-refcount.c, or (7) a large number of blocks in the cloop_open function in cloop.c, which trigger buffer overflows, memory corruption, large memory allocations and out-of-bounds read and writes."
202954,"  static void smp_task_done(struct sas_task *task)
  {
	if (!del_timer(&task->slow_task->timer))
		return;
 	del_timer(&task->slow_task->timer);
  	complete(&task->slow_task->completion);
  }","[5, 3, 4]","An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free."
198418," static HB_Error  Lookup_MarkMarkPos( GPOS_Instance*    gpi,
 				     HB_GPOS_SubTable* st,
 				     HB_Buffer        buffer,
 				     HB_UShort         flags,
 				     HB_UShort         context_length,
 				     int               nesting_level )
 {
   HB_UShort        i, j, mark1_index, mark2_index, property, class;
   HB_Fixed           x_mark1_value, y_mark1_value,
 		   x_mark2_value, y_mark2_value;
   HB_Error         error;
   HB_GPOSHeader*  gpos = gpi->gpos;
   HB_MarkMarkPos* mmp = &st->markmark;
 
   HB_MarkArray*    ma1;
   HB_Mark2Array*   ma2;
   HB_Mark2Record*  m2r;
   HB_Anchor*       mark1_anchor;
   HB_Anchor*       mark2_anchor;
 
   HB_Position    o;
 
   HB_UNUSED(nesting_level);
 
   if ( context_length != 0xFFFF && context_length < 1 )
     return HB_Err_Not_Covered;
 
   if ( flags & HB_LOOKUP_FLAG_IGNORE_MARKS )
     return HB_Err_Not_Covered;
 
   if ( CHECK_Property( gpos->gdef, IN_CURITEM(),
 		       flags, &property ) )
     return error;
 
   error = _HB_OPEN_Coverage_Index( &mmp->Mark1Coverage, IN_CURGLYPH(),
 			  &mark1_index );
   if ( error )
     return error;
 
    
 
   if ( buffer->in_pos == 0 )
     return HB_Err_Not_Covered;
 
   i = 1;
   j = buffer->in_pos - 1;
   while ( i <= buffer->in_pos )
   {
     error = HB_GDEF_Get_Glyph_Property( gpos->gdef, IN_GLYPH( j ),
 					&property );
     if ( error )
       return error;
 
     if ( !( property == HB_GDEF_MARK || property & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS ) )
       return HB_Err_Not_Covered;
 
     if ( flags & HB_LOOKUP_FLAG_IGNORE_SPECIAL_MARKS )
     {
       if ( property == (flags & 0xFF00) )
         break;
     }
     else
       break;
 
     i++;
      j--;
    }
  
   if ( i > buffer->in_pos )
     return HB_Err_Not_Covered;
 
    error = _HB_OPEN_Coverage_Index( &mmp->Mark2Coverage, IN_GLYPH( j ),
  			  &mark2_index );
    if ( error )
 
   if ( mark1_index >= ma1->MarkCount )
     return ERR(HB_Err_Invalid_SubTable);
 
   class        = ma1->MarkRecord[mark1_index].Class;
   mark1_anchor = &ma1->MarkRecord[mark1_index].MarkAnchor;
 
   if ( class >= mmp->ClassCount )
     return ERR(HB_Err_Invalid_SubTable);
 
   ma2 = &mmp->Mark2Array;
 
   if ( mark2_index >= ma2->Mark2Count )
     return ERR(HB_Err_Invalid_SubTable);
 
   m2r          = &ma2->Mark2Record[mark2_index];
   mark2_anchor = &m2r->Mark2Anchor[class];
 
   error = Get_Anchor( gpi, mark1_anchor, IN_CURGLYPH(),
 		      &x_mark1_value, &y_mark1_value );
   if ( error )
     return error;
   error = Get_Anchor( gpi, mark2_anchor, IN_GLYPH( j ),
 		      &x_mark2_value, &y_mark2_value );
   if ( error )
     return error;
 
    
 
   o = POSITION( buffer->in_pos );
 
   o->x_pos     = x_mark2_value - x_mark1_value;
   o->y_pos     = y_mark2_value - y_mark1_value;
   o->x_advance = 0;
   o->y_advance = 0;
   o->back      = 1;
 
   (buffer->in_pos)++;
 
   return HB_Err_Ok;
 }","[69, 70, 71]","Heap-based buffer overflow in the Lookup_MarkMarkPos function in the HarfBuzz module (harfbuzz-gpos.c), as used by Qt before 4.7.4 and Pango, allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted font file."
200865," void big_key_revoke(struct key *key)
 {
 	struct path *path = (struct path *)&key->payload.data[big_key_path];
  
  	 
  	key_payload_reserve(key, 0);
	if (key_is_instantiated(key) &&
 	if (key_is_positive(key) &&
  	    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)
  		vfs_truncate(path, 0);
  }","[8, 7]","The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the *negative* state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."
202901," static size_t WritePSDChannel(const PSDInfo *psd_info,
   const ImageInfo *image_info,Image *image,Image *next_image,
   const QuantumType quantum_type, unsigned char *compact_pixels,
   MagickOffsetType size_offset,const MagickBooleanType separate,
   const CompressionType compression,ExceptionInfo *exception)
 {
   MagickBooleanType
     monochrome;
 
   QuantumInfo
     *quantum_info;
 
   register const Quantum
     *p;
 
   register ssize_t
     i;
 
   size_t
     count,
     length;
 
   ssize_t
     y;
 
   unsigned char
     *pixels;
 
 #ifdef MAGICKCORE_ZLIB_DELEGATE
 
 #define CHUNK 16384
 
   int
     flush,
     level;
 
   unsigned char
     *compressed_pixels;
 
   z_stream
     stream;
 
   compressed_pixels=(unsigned char *) NULL;
   flush=Z_NO_FLUSH;
 #endif
   count=0;
   if (separate != MagickFalse)
     {
       size_offset=TellBlob(image)+2;
       count+=WriteCompressionStart(psd_info,image,next_image,compression,1);
     }
   if (next_image->depth > 8)
     next_image->depth=16;
   monochrome=IsImageMonochrome(image) && (image->depth == 1) ?
     MagickTrue : MagickFalse;
   quantum_info=AcquireQuantumInfo(image_info,next_image);
   if (quantum_info == (QuantumInfo *) NULL)
     return(0);
   pixels=(unsigned char *) GetQuantumPixels(quantum_info);
 #ifdef MAGICKCORE_ZLIB_DELEGATE
   if (compression == ZipCompression)
     {
       compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
         sizeof(*compressed_pixels));
       if (compressed_pixels == (unsigned char *) NULL)
         {
           quantum_info=DestroyQuantumInfo(quantum_info);
           return(0);
         }
       memset(&stream,0,sizeof(stream));
       stream.data_type=Z_BINARY;
       level=Z_DEFAULT_COMPRESSION;
       if ((image_info->quality > 0 && image_info->quality < 10))
         level=(int) image_info->quality;
        if (deflateInit(&stream,level) != Z_OK)
          {
            quantum_info=DestroyQuantumInfo(quantum_info);
           compressed_pixels=(unsigned char *) RelinquishMagickMemory(
             compressed_pixels);
            return(0);
          }
      }
 #endif
   for (y=0; y < (ssize_t) next_image->rows; y++)
   {
     p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);
     if (p == (const Quantum *) NULL)
       break;
     length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
       quantum_type,pixels,exception);
     if (monochrome != MagickFalse)
       for (i=0; i < (ssize_t) length; i++)
         pixels[i]=(~pixels[i]);
     if (compression == RLECompression)
       {
         length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,
           exception);
         count+=WriteBlob(image,length,compact_pixels);
         size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
       }
 #ifdef MAGICKCORE_ZLIB_DELEGATE
     else if (compression == ZipCompression)
       {
         stream.avail_in=(uInt) length;
         stream.next_in=(Bytef *) pixels;
         if (y == (ssize_t) next_image->rows-1)
           flush=Z_FINISH;
         do {
             stream.avail_out=(uInt) CHUNK;
             stream.next_out=(Bytef *) compressed_pixels;
             if (deflate(&stream,flush) == Z_STREAM_ERROR)
               break;
             length=(size_t) CHUNK-stream.avail_out;
             if (length > 0)
               count+=WriteBlob(image,length,compressed_pixels);
         } while (stream.avail_out == 0);
       }
 #endif
     else
       count+=WriteBlob(image,length,pixels);
   }
 #ifdef MAGICKCORE_ZLIB_DELEGATE
   if (compression == ZipCompression)
     {
       (void) deflateEnd(&stream);
       compressed_pixels=(unsigned char *) RelinquishMagickMemory(
         compressed_pixels);
     }
 #endif
   quantum_info=DestroyQuantumInfo(quantum_info);
   return(count);
 }","[78, 79]","In ImageMagick before 7.0.8-25, a memory leak exists in WritePSDChannel in coders/psd.c."
6158,"static void tw5864_handle_frame(struct tw5864_h264_frame *frame)
{
#define SKIP_VLCBUF_BYTES 3
struct tw5864_input *input = frame->input;
struct tw5864_dev *dev = input->root;
struct tw5864_buf *vb;
struct vb2_v4l2_buffer *v4l2_buf;
int frame_len = frame->vlc_len - SKIP_VLCBUF_BYTES;
u8 *dst = input->buf_cur_ptr;
u8 tail_mask, vlc_mask = 0;
int i;
u8 vlc_first_byte = ((u8 *)(frame->vlc.addr + SKIP_VLCBUF_BYTES))[0];
unsigned long flags;
int zero_run;
u8 *src;
u8 *src_end;

#ifdef DEBUG
if (frame->checksum !=
tw5864_vlc_checksum((u32 *)frame->vlc.addr, frame_len))
dev_err(&dev->pci->dev,
""Checksum of encoded frame doesn't match!\n"");
#endif

spin_lock_irqsave(&input->slock, flags);
vb = input->vb;
input->vb = NULL;
spin_unlock_irqrestore(&input->slock, flags);

v4l2_buf = to_vb2_v4l2_buffer(&vb->vb.vb2_buf);

if (!vb) {
dev_dbg(&dev->pci->dev, ""vb is empty, dropping frame\n"");
return;
}





if (input->buf_cur_space_left < frame_len * 5 / 4) {
dev_err_once(&dev->pci->dev,
""Left space in vb2 buffer, %d bytes, is less than considered safely enough to put frame of length %d. Dropping this frame.\n"",
input->buf_cur_space_left, frame_len);
return;
}

for (i = 0; i < 8 - input->tail_nb_bits; i++)
vlc_mask |= 1 << i;
tail_mask = (~vlc_mask) & 0xff;

dst[0] = (input->tail & tail_mask) | (vlc_first_byte & vlc_mask);
frame_len--;
dst++;


src = frame->vlc.addr + SKIP_VLCBUF_BYTES + 1;
src_end = src + frame_len;
zero_run = 0;
for (; src < src_end; src++) {
if (zero_run < 2) {
if (*src == 0)
++zero_run;
else
zero_run = 0;
} else {
if ((*src & ~0x03) == 0)
*dst++ = 0x03;
zero_run = *src == 0;
}
*dst++ = *src;
}

vb2_set_plane_payload(&vb->vb.vb2_buf, 0,
dst - (u8 *)vb2_plane_vaddr(&vb->vb.vb2_buf, 0));

vb->vb.vb2_buf.timestamp = frame->timestamp;
v4l2_buf->field = V4L2_FIELD_INTERLACED;
v4l2_buf->sequence = frame->seqno;


if (frame->gop_seqno               &&
tw5864_is_motion_triggered(frame)) {
struct v4l2_event ev = {
.type = V4L2_EVENT_MOTION_DET,
.u.motion_det = {
.flags = V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ,
.frame_sequence = v4l2_buf->sequence,
},
};

v4l2_event_queue(&input->vdev, &ev);
}

vb2_buffer_done(&vb->vb.vb2_buf, VB2_BUF_STATE_DONE);
}","[30, 41]","An issue was discovered in the Linux kernel before 5.2. There is a NULL pointer dereference in tw5864_handle_frame() in drivers/media/pci/tw5864/tw5864-video.c, which may cause denial of service, aka CID-2e7682ebfc75."
201217," int yr_object_array_set_item(
     YR_OBJECT* object,
     YR_OBJECT* item,
     int index)
 {
   YR_OBJECT_ARRAY* array;
 
   int i;
   int count;
 
   assert(index >= 0);
   assert(object->type == OBJECT_TYPE_ARRAY);
 
   array = object_as_array(object);
  
    if (array->items == NULL)
    {
    count = yr_max(64, (index + 1) * 2);
     count = 64;
 
     while (count <= index)
       count *= 2;
  
      array->items = (YR_ARRAY_ITEMS*) yr_malloc(
          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
 
     if (array->items == NULL)
       return ERROR_INSUFFICIENT_MEMORY;
 
     memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));
 
     array->items->count = count;
   }
    else if (index >= array->items->count)
    {
      count = array->items->count * 2;
 
     while (count <= index)
       count *= 2;
 
      array->items = (YR_ARRAY_ITEMS*) yr_realloc(
          array->items,
          sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));
 
     if (array->items == NULL)
       return ERROR_INSUFFICIENT_MEMORY;
 
     for (i = array->items->count; i < count; i++)
       array->items->objects[i] = NULL;
 
     array->items->count = count;
   }
 
   item->parent = object;
   array->items->objects[index] = item;
 
   return ERROR_SUCCESS;
 }","[19, 20, 21, 22, 37, 38, 39, 40, 18]",Heap buffer overflow in the yr_object_array_set_item() function in object.c in YARA 3.x allows a denial-of-service attack by scanning a crafted .NET file.
207940," void WT_InterpolateMono (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
 {
     EAS_I32 *pMixBuffer;
  const EAS_I8 *pLoopEnd;
  const EAS_I8 *pCurrentPhaseInt;
     EAS_I32 numSamples;
     EAS_I32 gain;
     EAS_I32 gainIncrement;
     EAS_I32 currentPhaseFrac;
     EAS_I32 phaseInc;
     EAS_I32 tmp0;
     EAS_I32 tmp1;
     EAS_I32 tmp2;
 
      EAS_I8 *pLoopStart;
  
      numSamples = pWTIntFrame->numSamples;
     if (numSamples <= 0) {
         ALOGE(""b/26366256"");
         return;
     }
      pMixBuffer = pWTIntFrame->pMixBuffer;
  
       
     gainIncrement = (pWTIntFrame->gainTarget - pWTIntFrame->prevGain) << (16 - SYNTH_UPDATE_PERIOD_IN_BITS);
  if (gainIncrement < 0)
         gainIncrement++;
     gain = pWTIntFrame->prevGain << 16;
 
     pCurrentPhaseInt = pWTVoice->pPhaseAccum;
     currentPhaseFrac = pWTVoice->phaseFrac;
     phaseInc = pWTIntFrame->phaseIncrement;
 
     pLoopStart = pWTVoice->pLoopStart;
     pLoopEnd = pWTVoice->pLoopEnd + 1;
 
 InterpolationLoop:
     tmp0 = (EAS_I32)(pCurrentPhaseInt - pLoopEnd);
  if (tmp0 >= 0)
         pCurrentPhaseInt = pLoopStart + tmp0;
 
     tmp0 = *pCurrentPhaseInt;
     tmp1 = *(pCurrentPhaseInt + 1);
 
     tmp2 = phaseInc + currentPhaseFrac;
 
     tmp1 = tmp1 - tmp0;
     tmp1 = tmp1 * currentPhaseFrac;
 
     tmp1 = tmp0 + (tmp1 >> NUM_EG1_FRAC_BITS);
 
     pCurrentPhaseInt += (tmp2 >> NUM_PHASE_FRAC_BITS);
     currentPhaseFrac = tmp2 & PHASE_FRAC_MASK;
 
     gain += gainIncrement;
     tmp2 = (gain >> SYNTH_UPDATE_PERIOD_IN_BITS);
 
     tmp0 = *pMixBuffer;
     tmp2 = tmp1 * tmp2;
     tmp2 = (tmp2 >> 9);
     tmp0 = tmp2 + tmp0;
  *pMixBuffer++ = tmp0;
 
     numSamples--;
  if (numSamples > 0)
  goto InterpolationLoop;
 
     pWTVoice->pPhaseAccum = pCurrentPhaseInt;
     pWTVoice->phaseFrac = currentPhaseFrac;
   
     pWTVoice->gain = (EAS_I16)(gain >> SYNTH_UPDATE_PERIOD_IN_BITS);
 }","[18, 19, 20, 21]","Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
205118,"  EntrySync* EntrySync::copyTo(DirectoryEntrySync* parent, const String& name, ExceptionState& exceptionState) const
  {
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     EntrySyncCallbackHelper* helper = EntrySyncCallbackHelper::create();
      m_fileSystem->copy(this, parent, name, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
      return helper->getResult(exceptionState);
  }","[4, 3]",The URL loader in Google Chrome before 26.0.1410.43 allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors.
10036,"void Compute(OpKernelContext* context) override {
const Tensor& images = context->input(0);
const Tensor& boxes = context->input(1);
const int64_t depth = images.dim_size(3);

OP_REQUIRES(context, images.dims() == 4,
errors::InvalidArgument(""The rank of the images should be 4""));
OP_REQUIRES(
context, boxes.dims() == 3,
errors::InvalidArgument(""The rank of the boxes tensor should be 3""));
OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0),
errors::InvalidArgument(""The batch sizes should be the same""));

OP_REQUIRES(
context, depth == 4 || depth == 1 || depth == 3,
errors::InvalidArgument(""Channel depth should be either 1 (GRY), ""
""3 (RGB), or 4 (RGBA)""));

OP_REQUIRES(
context, boxes.dim_size(2) == 4,
errors::InvalidArgument(
""The size of the third dimension of the box must be 4. Received: "",
boxes.dim_size(2)));

const int64_t batch_size = images.dim_size(0);
const int64_t height = images.dim_size(1);
const int64_t width = images.dim_size(2);
std::vector<std::vector<float>> color_table;
if (context->num_inputs() == 3) {
const Tensor& colors_tensor = context->input(2);
OP_REQUIRES(context, colors_tensor.shape().dims() == 2,
errors::InvalidArgument(""colors must be a 2-D matrix"",
colors_tensor.shape().DebugString()));
OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth,
errors::InvalidArgument(""colors must have equal or more "",
""channels than the image provided: "",
colors_tensor.shape().DebugString()));
if (colors_tensor.NumElements() != 0) {
color_table.clear();

auto colors = colors_tensor.matrix<float>();
for (int64_t i = 0; i < colors.dimension(0); i++) {
std::vector<float> color_value(depth);
for (int64_t j = 0; j < depth; j++) {
color_value[j] = colors(i, j);
}
color_table.emplace_back(color_value);
}
}
}
if (color_table.empty()) {
color_table = DefaultColorTable(depth);
}
Tensor* output;
OP_REQUIRES_OK(
context,
context->allocate_output(
0, TensorShape({batch_size, height, width, depth}), &output));

output->tensor<T, 4>() = images.tensor<T, 4>();
auto canvas = output->tensor<T, 4>();

for (int64_t b = 0; b < batch_size; ++b) {
const int64_t num_boxes = boxes.dim_size(1);
const auto tboxes = boxes.tensor<T, 3>();
for (int64_t bb = 0; bb < num_boxes; ++bb) {
int64_t color_index = bb % color_table.size();
const int64_t min_box_row =
static_cast<float>(tboxes(b, bb, 0)) * (height - 1);
const int64_t min_box_row_clamp =
std::max<int64_t>(min_box_row, int64_t{0});
const int64_t max_box_row =
static_cast<float>(tboxes(b, bb, 2)) * (height - 1);
const int64_t max_box_row_clamp =
std::min<int64_t>(max_box_row, height - 1);
const int64_t min_box_col =
static_cast<float>(tboxes(b, bb, 1)) * (width - 1);
const int64_t min_box_col_clamp =
std::max<int64_t>(min_box_col, int64_t{0});
const int64_t max_box_col =
static_cast<float>(tboxes(b, bb, 3)) * (width - 1);
const int64_t max_box_col_clamp =
std::min<int64_t>(max_box_col, width - 1);

if (min_box_row > max_box_row || min_box_col > max_box_col) {
LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col
<< "","" << max_box_row << "","" << max_box_col
<< "") is inverted and will not be drawn."";
continue;
}
if (min_box_row >= height || max_box_row < 0 || min_box_col >= width ||
max_box_col < 0) {
LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col
<< "","" << max_box_row << "","" << max_box_col
<< "") is completely outside the image""
<< "" and will not be drawn."";
continue;
}



OP_REQUIRES(
context, min_box_row_clamp >= 0,
errors::InvalidArgument(""Min box row clamp is less than 0.""));
OP_REQUIRES(
context, max_box_row_clamp >= 0,
errors::InvalidArgument(""Max box row clamp is less than 0.""));
OP_REQUIRES(context, min_box_row_clamp <= height,
errors::InvalidArgument(
""Min box row clamp is greater than height.""));
OP_REQUIRES(context, max_box_row_clamp <= height,
errors::InvalidArgument(
""Max box row clamp is greater than height.""));

OP_REQUIRES(
context, min_box_col_clamp >= 0,
errors::InvalidArgument(""Min box col clamp is less than 0.""));
OP_REQUIRES(
context, max_box_col_clamp >= 0,
errors::InvalidArgument(""Max box col clamp is less than 0.""));
OP_REQUIRES(context, min_box_col_clamp <= width,
errors::InvalidArgument(
""Min box col clamp is greater than width.""));
OP_REQUIRES(context, max_box_col_clamp <= width,
errors::InvalidArgument(
""Max box col clamp is greater than width.""));





OP_REQUIRES(
context, min_box_row <= height,
errors::InvalidArgument(""Min box row is greater than height.""));
OP_REQUIRES(context, max_box_row >= 0,
errors::InvalidArgument(""Max box row is less than 0.""));
OP_REQUIRES(
context, min_box_col <= width,
errors::InvalidArgument(""Min box col is greater than width.""));
OP_REQUIRES(context, max_box_col >= 0,
errors::InvalidArgument(""Max box col is less than 0.""));


if (min_box_row >= 0) {
for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)
for (int64_t c = 0; c < depth; c++) {
canvas(b, min_box_row, j, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (max_box_row < height) {
for (int64_t j = min_box_col_clamp; j <= max_box_col_clamp; ++j)
for (int64_t c = 0; c < depth; c++) {
canvas(b, max_box_row, j, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (min_box_col >= 0) {
for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)
for (int64_t c = 0; c < depth; c++) {
canvas(b, i, min_box_col, c) =
static_cast<T>(color_table[color_index][c]);
}
}

if (max_box_col < width) {
for (int64_t i = min_box_row_clamp; i <= max_box_row_clamp; ++i)
for (int64_t c = 0; c < depth; c++) {
canvas(b, i, max_box_col, c) =
static_cast<T>(color_table[color_index][c]);
}
}
}
}
}",[65],"TensorFlow is an open source platform for machine learning. When `DrawBoundingBoxes` receives an input `boxes` that is not of dtype `float`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit da0d65cdc1270038e72157ba35bf74b85d9bda11. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
203345," crypto_retrieve_X509_sans(krb5_context context,
                           pkinit_plg_crypto_context plgctx,
                           pkinit_req_crypto_context reqctx,
                           X509 *cert,
                           krb5_principal **princs_ret,
                           krb5_principal **upn_ret,
                           unsigned char ***dns_ret)
 {
     krb5_error_code retval = EINVAL;
     char buf[DN_BUF_LEN];
     int p = 0, u = 0, d = 0, ret = 0, l;
     krb5_principal *princs = NULL;
     krb5_principal *upns = NULL;
     unsigned char **dnss = NULL;
     unsigned int i, num_found = 0, num_sans = 0;
     X509_EXTENSION *ext = NULL;
     GENERAL_NAMES *ialt = NULL;
     GENERAL_NAME *gen = NULL;
 
     if (princs_ret != NULL)
         *princs_ret = NULL;
     if (upn_ret != NULL)
         *upn_ret = NULL;
     if (dns_ret != NULL)
         *dns_ret = NULL;
 
     if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {
         pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__);
         return retval;
     }
 
     if (cert == NULL) {
         pkiDebug(""%s: no certificate!\n"", __FUNCTION__);
         return retval;
     }
 
     X509_NAME_oneline(X509_get_subject_name(cert),
                       buf, sizeof(buf));
     pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf);
 
     l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
     if (l < 0)
         return 0;
  
      if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {
          pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__);
        retval = ENOENT;
          goto cleanup;
      }
      num_sans = sk_GENERAL_NAME_num(ialt);
 
     pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__,
              num_sans);
 
      
     if (princs_ret != NULL) {
         princs = calloc(num_sans + 1, sizeof(krb5_principal));
         if (princs == NULL) {
             retval = ENOMEM;
             goto cleanup;
         }
     }
     if (upn_ret != NULL) {
         upns = calloc(num_sans + 1, sizeof(krb5_principal));
         if (upns == NULL) {
             retval = ENOMEM;
             goto cleanup;
         }
     }
     if (dns_ret != NULL) {
         dnss = calloc(num_sans + 1, sizeof(*dnss));
         if (dnss == NULL) {
             retval = ENOMEM;
             goto cleanup;
         }
     }
 
     for (i = 0; i < num_sans; i++) {
         krb5_data name = { 0, 0, NULL };
 
         gen = sk_GENERAL_NAME_value(ialt, i);
         switch (gen->type) {
         case GEN_OTHERNAME:
             name.length = gen->d.otherName->value->value.sequence->length;
             name.data = (char *)gen->d.otherName->value->value.sequence->data;
             if (princs != NULL &&
                 OBJ_cmp(plgctx->id_pkinit_san,
                         gen->d.otherName->type_id) == 0) {
 #ifdef DEBUG_ASN1
                 print_buffer_bin((unsigned char *)name.data, name.length,
                                  ""/tmp/pkinit_san"");
 #endif
                 ret = k5int_decode_krb5_principal_name(&name, &princs[p]);
                 if (ret) {
                     pkiDebug(""%s: failed decoding pkinit san value\n"",
                              __FUNCTION__);
                 } else {
                     p++;
                     num_found++;
                 }
             } else if (upns != NULL &&
                        OBJ_cmp(plgctx->id_ms_san_upn,
                                gen->d.otherName->type_id) == 0) {
                  
                 if (memchr(name.data, '\0', name.length))
                     break;
                 ret = krb5_parse_name_flags(context, name.data,
                                             KRB5_PRINCIPAL_PARSE_ENTERPRISE,
                                             &upns[u]);
                 if (ret) {
                     pkiDebug(""%s: failed parsing ms-upn san value\n"",
                              __FUNCTION__);
                 } else {
                     u++;
                     num_found++;
                 }
             } else {
                 pkiDebug(""%s: unrecognized othername oid in SAN\n"",
                          __FUNCTION__);
                 continue;
             }
 
             break;
         case GEN_DNS:
             if (dnss != NULL) {
                  
                 if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length))
                     break;
                 pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__,
                          gen->d.dNSName->data);
                 dnss[d] = (unsigned char *)
                     strdup((char *)gen->d.dNSName->data);
                 if (dnss[d] == NULL) {
                     pkiDebug(""%s: failed to duplicate dns name\n"",
                              __FUNCTION__);
                 } else {
                     d++;
                     num_found++;
                 }
             }
             break;
         default:
             pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__,
                      gen->type, GEN_OTHERNAME);
         }
     }
      sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);
  
      retval = 0;
    if (princs)
     if (princs != NULL && *princs != NULL) {
          *princs_ret = princs;
    if (upns)
         princs = NULL;
     }
     if (upns != NULL && *upns != NULL) {
          *upn_ret = upns;
    if (dnss)
         upns = NULL;
     }
     if (dnss != NULL && *dnss != NULL) {
          *dns_ret = dnss;
         dnss = NULL;
     }
  
  cleanup:
    if (retval) {
        if (princs != NULL) {
            for (i = 0; princs[i] != NULL; i++)
                krb5_free_principal(context, princs[i]);
            free(princs);
        }
        if (upns != NULL) {
            for (i = 0; upns[i] != NULL; i++)
                krb5_free_principal(context, upns[i]);
            free(upns);
        }
        if (dnss != NULL) {
            for (i = 0; dnss[i] != NULL; i++)
                free(dnss[i]);
            free(dnss);
        }
    }
     for (i = 0; princs != NULL && princs[i] != NULL; i++)
         krb5_free_principal(context, princs[i]);
     free(princs);
     for (i = 0; upns != NULL && upns[i] != NULL; i++)
         krb5_free_principal(context, upns[i]);
     free(upns);
     for (i = 0; dnss != NULL && dnss[i] != NULL; i++)
         free(dnss[i]);
     free(dnss);
      return retval;
  }","[151, 154, 155, 156, 159, 160, 161, 163, 164, 184, 185, 186, 187, 188, 189, 190, 191, 192, 47, 150, 153, 158, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183]",An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.
198600,"   T1_Get_Private_Dict( T1_Parser      parser,
                        PSAux_Service  psaux )
   {
     FT_Stream  stream = parser->stream;
     FT_Memory  memory = parser->root.memory;
     FT_Error   error  = FT_Err_Ok;
     FT_ULong   size;
 
 
     if ( parser->in_pfb )
     {
        
        
        
        
       FT_ULong   start_pos = FT_STREAM_POS();
       FT_UShort  tag;
 
 
       parser->private_len = 0;
       for (;;)
       {
         error = read_pfb_tag( stream, &tag, &size );
         if ( error )
           goto Fail;
 
         if ( tag != 0x8002U )
           break;
 
         parser->private_len += size;
 
         if ( FT_STREAM_SKIP( size ) )
           goto Fail;
       }
 
        
        
       if ( parser->private_len == 0 )
       {
         FT_ERROR(( ""T1_Get_Private_Dict:""
                    "" invalid private dictionary section\n"" ));
         error = FT_THROW( Invalid_File_Format );
         goto Fail;
       }
 
       if ( FT_STREAM_SEEK( start_pos )                           ||
            FT_ALLOC( parser->private_dict, parser->private_len ) )
         goto Fail;
 
       parser->private_len = 0;
       for (;;)
       {
         error = read_pfb_tag( stream, &tag, &size );
         if ( error || tag != 0x8002U )
         {
           error = FT_Err_Ok;
           break;
         }
 
         if ( FT_STREAM_READ( parser->private_dict + parser->private_len,
                              size ) )
           goto Fail;
 
         parser->private_len += size;
       }
     }
     else
     {
        
        
        
        
 
        
       FT_Byte*    cur   = parser->base_dict;
       FT_Byte*    limit = cur + parser->base_len;
       FT_Byte     c;
       FT_Pointer  pos_lf;
       FT_Bool     test_cr;
 
 
     Again:
       for (;;)
       {
         c = cur[0];
         if ( c == 'e' && cur + 9 < limit )   
                                              
         {
           if ( cur[1] == 'e' &&
                cur[2] == 'x' &&
                cur[3] == 'e' &&
                cur[4] == 'c' )
             break;
         }
         cur++;
         if ( cur >= limit )
         {
           FT_ERROR(( ""T1_Get_Private_Dict:""
                      "" could not find `eexec' keyword\n"" ));
           error = FT_THROW( Invalid_File_Format );
           goto Exit;
         }
       }
 
        
        
 
       parser->root.cursor = parser->base_dict;
        
       parser->root.limit  = cur + 10;
 
       cur   = parser->root.cursor;
       limit = parser->root.limit;
 
       while ( cur < limit )
       {
         if ( *cur == 'e' && ft_strncmp( (char*)cur, ""eexec"", 5 ) == 0 )
           goto Found;
 
         T1_Skip_PS_Token( parser );
         if ( parser->root.error )
           break;
         T1_Skip_Spaces  ( parser );
         cur = parser->root.cursor;
       }
 
        
        
  
        cur   = limit;
        limit = parser->base_dict + parser->base_len;
 
       if ( cur >= limit )
       {
         FT_ERROR(( ""T1_Get_Private_Dict:""
                    "" premature end in private dictionary\n"" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
        goto Again;
  
         
 
        
        
        
        
        
        
        
        
 
       pos_lf  = ft_memchr( cur, '\n', (size_t)( limit - cur ) );
       test_cr = FT_BOOL( !pos_lf                                       ||
                          pos_lf > ft_memchr( cur,
                                              '\r',
                                              (size_t)( limit - cur ) ) );
 
       while ( cur < limit                    &&
               ( *cur == ' '                ||
                 *cur == '\t'               ||
                 (test_cr && *cur == '\r' ) ||
                 *cur == '\n'               ) )
         ++cur;
       if ( cur >= limit )
       {
         FT_ERROR(( ""T1_Get_Private_Dict:""
                    "" `eexec' not properly terminated\n"" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       size = parser->base_len - (FT_ULong)( cur - parser->base_dict );
 
       if ( parser->in_memory )
       {
          
         if ( FT_ALLOC( parser->private_dict, size + 1 ) )
           goto Fail;
         parser->private_len = size;
       }
       else
       {
         parser->single_block = 1;
         parser->private_dict = parser->base_dict;
         parser->private_len  = size;
         parser->base_dict    = NULL;
         parser->base_len     = 0;
       }
 
        
        
 
        
        
        
 
       if ( cur + 3 < limit                                &&
            ft_isxdigit( cur[0] ) && ft_isxdigit( cur[1] ) &&
            ft_isxdigit( cur[2] ) && ft_isxdigit( cur[3] ) )
       {
          
         FT_ULong  len;
 
 
         parser->root.cursor = cur;
         (void)psaux->ps_parser_funcs->to_bytes( &parser->root,
                                                 parser->private_dict,
                                                 parser->private_len,
                                                 &len,
                                                 0 );
         parser->private_len = len;
 
          
         parser->private_dict[len] = '\0';
       }
       else
          
         FT_MEM_MOVE( parser->private_dict, cur, size );
     }
 
      
     psaux->t1_decrypt( parser->private_dict, parser->private_len, 55665U );
 
     if ( parser->private_len < 4 )
     {
       FT_ERROR(( ""T1_Get_Private_Dict:""
                  "" invalid private dictionary section\n"" ));
       error = FT_THROW( Invalid_File_Format );
       goto Fail;
     }
 
      
     parser->private_dict[0] = ' ';
     parser->private_dict[1] = ' ';
     parser->private_dict[2] = ' ';
     parser->private_dict[3] = ' ';
 
     parser->root.base   = parser->private_dict;
     parser->root.cursor = parser->private_dict;
     parser->root.limit  = parser->root.cursor + parser->private_len;
 
   Fail:
   Exit:
     return error;
   }","[132, 133, 134, 135, 136, 137, 138, 139, 140]","In FreeType before 2.6.1, a buffer over-read occurs in type1/t1parse.c on function T1_Get_Private_Dict where there is no check that the new values of cur and limit are sensible before going to Again."
202058," int main(int argc, char** argv)
 {
      
     int fd = xopen(""/dev/null"", O_RDWR);
     while (fd < 2)
 	fd = xdup(fd);
     if (fd > 2)
 	close(fd);
 
     if (argc < 8)
     {
          
          
         error_msg_and_die(""Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME [HOSTNAME]"", argv[0]);
     }
 
      
     if (strchr(argv[1], ' '))
     {
         int i;
         for (i = 1; argv[i]; i++)
         {
             strchrnul(argv[i], ' ')[0] = '\0';
         }
     }
 
     logmode = LOGMODE_JOURNAL;
 
      
     load_abrt_conf();
      
     bool setting_MakeCompatCore;
     bool setting_SaveBinaryImage;
     {
         map_string_t *settings = new_map_string();
         load_abrt_plugin_conf_file(""CCpp.conf"", settings);
         const char *value;
         value = get_map_string_item_or_NULL(settings, ""MakeCompatCore"");
         setting_MakeCompatCore = value && string_to_bool(value);
         value = get_map_string_item_or_NULL(settings, ""SaveBinaryImage"");
         setting_SaveBinaryImage = value && string_to_bool(value);
         value = get_map_string_item_or_NULL(settings, ""VerboseLog"");
         if (value)
             g_verbose = xatoi_positive(value);
         free_map_string(settings);
     }
 
     errno = 0;
     const char* signal_str = argv[1];
     int signal_no = xatoi_positive(signal_str);
     off_t ulimit_c = strtoull(argv[2], NULL, 10);
     if (ulimit_c < 0)  
     {
          
         ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));
     }
     const char *pid_str = argv[3];
     pid_t pid = xatoi_positive(argv[3]);
     uid_t uid = xatoi_positive(argv[4]);
     if (errno || pid <= 0)
     {
         perror_msg_and_die(""PID '%s' or limit '%s' is bogus"", argv[3], argv[2]);
     }
 
     {
         char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN""/abrt/saved_core_pattern"");
          
         if (s && s[0] != '|')
             core_basename = s;
         else
             free(s);
     }
 
     struct utsname uts;
     if (!argv[8])  
     {
         uname(&uts);
         argv[8] = uts.nodename;
     }
 
     char path[PATH_MAX];
 
     int src_fd_binary = -1;
     char *executable = get_executable(pid, setting_SaveBinaryImage ? &src_fd_binary : NULL);
     if (executable && strstr(executable, ""/abrt-hook-ccpp""))
     {
         error_msg_and_die(""PID %lu is '%s', not dumping it to avoid recursion"",
                         (long)pid, executable);
     }
 
     user_pwd = get_cwd(pid);  
     log_notice(""user_pwd:'%s'"", user_pwd);
 
     sprintf(path, ""/proc/%lu/status"", (long)pid);
     proc_pid_status = xmalloc_xopen_read_close(path,   NULL);
 
     uid_t fsuid = uid;
     uid_t tmp_fsuid = get_fsuid();
     int suid_policy = dump_suid_policy();
     if (tmp_fsuid != uid)
     {
          
         fsuid = 0;
         if (suid_policy == DUMP_SUID_UNSAFE)
         {
             fsuid = tmp_fsuid;
         }
     }
 
      
     if (setting_MakeCompatCore && ulimit_c != 0)
          
         user_core_fd = open_user_core(uid, fsuid, pid, &argv[1]);
 
     if (executable == NULL)
     {
          
         error_msg(""Can't read /proc/%lu/exe link"", (long)pid);
         goto create_user_core;
     }
 
     const char *signame = NULL;
     switch (signal_no)
     {
         case SIGILL : signame = ""ILL"" ; break;
         case SIGFPE : signame = ""FPE"" ; break;
         case SIGSEGV: signame = ""SEGV""; break;
         case SIGBUS : signame = ""BUS"" ; break;  
         case SIGABRT: signame = ""ABRT""; break;  
         case SIGTRAP: signame = ""TRAP""; break;  
         default: goto create_user_core;  
     }
 
     if (!daemon_is_ok())
     {
          
         log(""abrtd is not running. If it crashed, ""
             ""/proc/sys/kernel/core_pattern contains a stale value, ""
             ""consider resetting it to 'core'""
         );
         goto create_user_core;
     }
 
     if (g_settings_nMaxCrashReportsSize > 0)
     {
          
         if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))
             goto create_user_core;
     }
 
      
     snprintf(path, sizeof(path), ""%s/last-ccpp"", g_settings_dump_location);
     if (check_recent_crash_file(path, executable))
     {
          
         goto create_user_core;
     }
 
     const char *last_slash = strrchr(executable, '/');
     if (last_slash && strncmp(++last_slash, ""abrt"", 4) == 0)
     {
          
         snprintf(path, sizeof(path), ""%s/%s-coredump"", g_settings_dump_location, last_slash);
         int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);
         if (core_size < 0 || fsync(abrt_core_fd) != 0)
         {
             unlink(path);
              
             error_msg_and_die(""Error saving '%s'"", path);
         }
         log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
         return 0;
     }
 
     unsigned path_len = snprintf(path, sizeof(path), ""%s/ccpp-%s-%lu.new"",
             g_settings_dump_location, iso_date_string(NULL), (long)pid);
     if (path_len >= (sizeof(path) - sizeof(""/""FILENAME_COREDUMP)))
     {
         goto create_user_core;
     }
 
      
     dd = dd_create(path, fsuid, DEFAULT_DUMP_DIR_MODE);
     if (dd)
     {
         char *rootdir = get_rootdir(pid);
 
         dd_create_basic_files(dd, fsuid, (rootdir && strcmp(rootdir, ""/"") != 0) ? rootdir : NULL);
 
         char source_filename[sizeof(""/proc/%lu/somewhat_long_name"") + sizeof(long)*3];
         int source_base_ofs = sprintf(source_filename, ""/proc/%lu/smaps"", (long)pid);
         source_base_ofs -= strlen(""smaps"");
         char *dest_filename = concat_path_file(dd->dd_dirname, ""also_somewhat_longish_name"");
         char *dest_base = strrchr(dest_filename, '/') + 1;
 
 
         strcpy(source_filename + source_base_ofs, ""maps"");
         strcpy(dest_base, FILENAME_MAPS);
         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""limits"");
         strcpy(dest_base, FILENAME_LIMITS);
         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(source_filename + source_base_ofs, ""cgroup"");
         strcpy(dest_base, FILENAME_CGROUP);
         copy_file_ext(source_filename, dest_filename, 0640, dd->dd_uid, dd->dd_gid, O_RDONLY, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL);
 
         strcpy(dest_base, FILENAME_OPEN_FDS);
         dump_fd_info(dest_filename, source_filename, source_base_ofs, dd->dd_uid, dd->dd_gid);
 
         free(dest_filename);
 
         dd_save_text(dd, FILENAME_ANALYZER, ""CCpp"");
         dd_save_text(dd, FILENAME_TYPE, ""CCpp"");
         dd_save_text(dd, FILENAME_EXECUTABLE, executable);
         dd_save_text(dd, FILENAME_PID, pid_str);
         dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);
         if (user_pwd)
             dd_save_text(dd, FILENAME_PWD, user_pwd);
         if (rootdir)
         {
             if (strcmp(rootdir, ""/"") != 0)
                 dd_save_text(dd, FILENAME_ROOTDIR, rootdir);
         }
 
         char *reason = xasprintf(""%s killed by SIG%s"",
                                  last_slash, signame ? signame : signal_str);
         dd_save_text(dd, FILENAME_REASON, reason);
         free(reason);
 
         char *cmdline = get_cmdline(pid);
         dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : """");
         free(cmdline);
 
         char *environ = get_environ(pid);
         dd_save_text(dd, FILENAME_ENVIRON, environ ? : """");
         free(environ);
 
         char *fips_enabled = xmalloc_fopen_fgetline_fclose(""/proc/sys/crypto/fips_enabled"");
         if (fips_enabled)
         {
             if (strcmp(fips_enabled, ""0"") != 0)
                 dd_save_text(dd, ""fips_enabled"", fips_enabled);
             free(fips_enabled);
         }
 
         dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);
 
         if (src_fd_binary > 0)
         {
             strcpy(path + path_len, ""/""FILENAME_BINARY);
             int dst_fd = create_or_die(path);
             off_t sz = copyfd_eof(src_fd_binary, dst_fd, COPYFD_SPARSE);
             if (fsync(dst_fd) != 0 || close(dst_fd) != 0 || sz < 0)
             {
                 dd_delete(dd);
                 error_msg_and_die(""Error saving '%s'"", path);
             }
             close(src_fd_binary);
         }
 
         strcpy(path + path_len, ""/""FILENAME_COREDUMP);
         int abrt_core_fd = create_or_die(path);
 
          
         off_t core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);
         if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)
         {
             unlink(path);
             dd_delete(dd);
             if (user_core_fd >= 0)
             {
                 xchdir(user_pwd);
                 unlink(core_basename);
             }
              
             error_msg_and_die(""Error writing '%s'"", path);
         }
         if (user_core_fd >= 0
              
          && (fsync(user_core_fd) != 0 || close(user_core_fd) != 0
              
             || (ulimit_c == 0   || core_size > ulimit_c)
             )
         ) {
              
             xchdir(user_pwd);
              unlink(core_basename);
          }
  
  
 #if 0
           
         {
             char *java_log = xasprintf(""/tmp/jvm-%lu/hs_error.log"", (long)pid);
             int src_fd = open(java_log, O_RDONLY);
             free(java_log);
 
              
             if (src_fd < 0)
             {
                 java_log = xasprintf(""%s/hs_err_pid%lu.log"", user_pwd, (long)pid);
                 src_fd = open(java_log, O_RDONLY);
                 free(java_log);
             }
 
             if (src_fd >= 0)
             {
                 strcpy(path + path_len, ""/hs_err.log"");
                 int dst_fd = create_or_die(path);
                 off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);
                 if (close(dst_fd) != 0 || sz < 0)
                 {
                     dd_delete(dd);
                     error_msg_and_die(""Error saving '%s'"", path);
                 }
                  close(src_fd);
              }
          }
 #endif
  
           
         dd_close(dd);
         path[path_len] = '\0';  
         char *newpath = xstrndup(path, path_len - (sizeof("".new"")-1));
         if (rename(path, newpath) == 0)
             strcpy(path, newpath);
         free(newpath);
 
         log(""Saved core dump of pid %lu (%s) to %s (%llu bytes)"", (long)pid, executable, path, (long long)core_size);
 
         notify_new_path(path);
 
          
         if (g_settings_nMaxCrashReportsSize > 0)
         {
              
             unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;
             maxsize |= 63;
             trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);
         }
 
         free(rootdir);
         return 0;
     }
 
      
  create_user_core:
     if (user_core_fd >= 0)
     {
         off_t core_size = copyfd_size(STDIN_FILENO, user_core_fd, ulimit_c, COPYFD_SPARSE);
         if (fsync(user_core_fd) != 0 || close(user_core_fd) != 0 || core_size < 0)
         {
              
             perror_msg(""Error writing '%s'"", full_core_basename);
             xchdir(user_pwd);
             unlink(core_basename);
             return 1;
         }
         if (ulimit_c == 0 || core_size > ulimit_c)
         {
             xchdir(user_pwd);
             unlink(core_basename);
             return 1;
         }
         log(""Saved core dump of pid %lu to %s (%llu bytes)"", (long)pid, full_core_basename, (long long)core_size);
     }
 
     return 0;
 }","[293, 294, 322]","Automatic Bug Reporting Tool (ABRT) allows local users to read, change the ownership of, or have other unspecified impact on arbitrary files via a symlink attack on (1) /var/tmp/abrt/*/maps, (2) /tmp/jvm-*/hs_error.log, (3) /proc/*/exe, (4) /etc/os-release in a chroot, or (5) an unspecified root directory related to librpm."
198893," static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,
 				struct nfs_getaclargs *args)
 {
 	struct compound_hdr hdr = {
 		.minorversion = nfs4_xdr_minorversion(&args->seq_args),
 	};
 	uint32_t replen;
 
  	encode_compound_hdr(xdr, req, &hdr);
  	encode_sequence(xdr, &args->seq_args, &hdr);
  	encode_putfh(xdr, args->fh, &hdr);
	replen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;
 	replen = hdr.replen + op_decode_hdr_maxsz + 1;
  	encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);
  
  	xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
  		args->acl_pages, args->acl_pgbase, args->acl_len);
 	xdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);
 
  	encode_nops(&hdr);
  }","[13, 18, 19, 12]","The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words."
7337,"const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {
StkId base = ci->func + 1;
const char *name = NULL;
if (isLua(ci)) {
if (n < 0)
return findvararg(ci, -n, pos);
else
name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
}
if (name == NULL) {
StkId limit = (ci == L->ci) ? L->top : ci->next->func;
if (limit - base >= n && n > 0) {

name = isLua(ci) ? ""(temporary)"" : ""(C temporary)"";
}
else
return NULL;
}
if (pos)
*pos = base + (n - 1);
return name;
}",[6],"ldebug.c in Lua 5.4.0 allows a negation overflow and segmentation fault in getlocal and setlocal, as demonstrated by getlocal(3,2^31)."
198168," void TIFF_MetaHandler::ProcessXMP()
 {
 
 	this->processedXMP = true;	 
 
 
 
 	bool found;
 	bool readOnly = ((this->parent->openFlags & kXMPFiles_OpenForUpdate) == 0);
 
 	if ( readOnly ) {
 		this->psirMgr = new PSIR_MemoryReader();
 		this->iptcMgr = new IPTC_Reader();
 	} else {
 		this->psirMgr = new PSIR_FileWriter();
 		this->iptcMgr = new IPTC_Writer();	 
 	}
 
 	TIFF_Manager & tiff = this->tiffMgr;	 
 	PSIR_Manager & psir = *this->psirMgr;
 	IPTC_Manager & iptc = *this->iptcMgr;
 
 	TIFF_Manager::TagInfo psirInfo;
 	bool havePSIR = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_PSIR, &psirInfo );
 
 	if ( havePSIR ) {	 
 		psir.ParseMemoryResources ( psirInfo.dataPtr, psirInfo.dataLen );
 		PSIR_Manager::ImgRsrcInfo buriedExif;
 		found = psir.GetImgRsrc ( kPSIR_Exif, &buriedExif );
 		if ( found ) {
 			tiff.IntegrateFromPShop6 ( buriedExif.dataPtr, buriedExif.dataLen );
 			if ( ! readOnly ) psir.DeleteImgRsrc ( kPSIR_Exif );
 		}
 	}
 
 	TIFF_Manager::TagInfo iptcInfo;
 	bool haveIPTC = tiff.GetTag ( kTIFF_PrimaryIFD, kTIFF_IPTC, &iptcInfo );	 
 	int iptcDigestState = kDigestMatches;
 
 	if ( haveIPTC ) {
 
 		bool haveDigest = false;
 		PSIR_Manager::ImgRsrcInfo digestInfo;
 		if ( havePSIR ) haveDigest = psir.GetImgRsrc ( kPSIR_IPTCDigest, &digestInfo );
 		if ( digestInfo.dataLen != 16 ) haveDigest = false;
 
 		if ( ! haveDigest ) {
 
 			iptcDigestState = kDigestMissing;
 
 		} else {
 
  
  			iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );
			if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {
 			 
 			 
 			if ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) && iptcInfo.dataLen > 0 ) {
  				XMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;
  				XMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;
  				while ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;
 				iptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, unpaddedLen, digestInfo.dataPtr );
 			}
 
 		}
 
 	}
 
 	XMP_OptionBits options = k2XMP_FileHadExif;	 
 	if ( haveIPTC ) options |= k2XMP_FileHadIPTC;
 	if ( this->containsXMP ) options |= k2XMP_FileHadXMP;
 
 
 	bool haveXMP = false;
 
 	if ( ! this->xmpPacket.empty() ) {
 		XMP_Assert ( this->containsXMP );
 		XMP_StringPtr packetStr = this->xmpPacket.c_str();
 		XMP_StringLen packetLen = (XMP_StringLen)this->xmpPacket.size();
 		try {
 			this->xmpObj.ParseFromBuffer ( packetStr, packetLen );
 		} catch ( ... ) {   }
 		haveXMP = true;
 	}
 
 
 	if ( haveIPTC && (! haveXMP) && (iptcDigestState == kDigestMatches) ) iptcDigestState = kDigestMissing;
 	bool parseIPTC = (iptcDigestState != kDigestMatches) || (! readOnly);
 	if ( parseIPTC ) iptc.ParseMemoryDataSets ( iptcInfo.dataPtr, iptcInfo.dataLen );
 	ImportPhotoData ( tiff, iptc, psir, iptcDigestState, &this->xmpObj, options );
 
 	this->containsXMP = true;	 
 
 }	 ","[56, 57, 58, 55]","An issue was discovered in Exempi through 2.4.4. XMPFiles/source/FileHandlers/TIFF_Handler.cpp mishandles a case of a zero length, leading to a heap-based buffer over-read in the MD5Update() function in third-party/zuid/interfaces/MD5.cpp."
201799," static Image *ReadGROUP4Image(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   char
     filename[MagickPathExtent];
 
   FILE
     *file;
 
   Image
     *image;
 
   ImageInfo
     *read_info;
 
   int
     c,
     unique_file;
 
   MagickBooleanType
     status;
 
   size_t
     length;
 
   ssize_t
     offset,
     strip_offset;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   file=(FILE *) NULL;
   unique_file=AcquireUniqueFileResource(filename);
   if (unique_file != -1)
     file=fdopen(unique_file,""wb"");
   if ((unique_file == -1) || (file == (FILE *) NULL))
     ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
   length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file);
   length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file);
   length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,image->columns);
   length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,image->rows);
   length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
   length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file);
   length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file);
   length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file);
   strip_offset=10+(12*14)+4+8;
   length=WriteLSBLong(file,(size_t) strip_offset);
   length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,(size_t) image_info->orientation);
   length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file);
   length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,image->rows);
   length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file);
   offset=(ssize_t) ftell(file)-4;
   length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,(size_t) (strip_offset-8));
   length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file);
   length=WriteLSBLong(file,(size_t) (strip_offset-8));
   length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file);
    length=fwrite(""\000\000\000\000"",1,4,file);
    length=WriteLSBLong(file,(long) image->resolution.x);
    length=WriteLSBLong(file,1);
   status=MagickTrue;
    for (length=0; (c=ReadBlobByte(image)) != EOF; length++)
    (void) fputc(c,file);
     if (fputc(c,file) != c)
       status=MagickFalse;
    offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);
    length=WriteLSBLong(file,(unsigned int) length);
    (void) fclose(file);
   (void) CloseBlob(image);
   image=DestroyImage(image);
    
   read_info=CloneImageInfo((ImageInfo *) NULL);
   (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename);
   image=ReadTIFFImage(read_info,exception);
   read_info=DestroyImageInfo(read_info);
   if (image != (Image *) NULL)
     {
       (void) CopyMagickString(image->filename,image_info->filename,
         MagickPathExtent);
       (void) CopyMagickString(image->magick_filename,image_info->filename,
         MagickPathExtent);
        (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent);
      }
    (void) RelinquishUniqueFileResource(filename);
   if (status == MagickFalse)
     image=DestroyImage(image);
    return(image);
  }","[79, 82, 83, 103, 104, 81]","The ReadGROUP4Image function in coders/tiff.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (crash) via a crafted image file."
198448," static void vmxnet3_process_tx_queue(VMXNET3State *s, int qidx)
 {
     struct Vmxnet3_TxDesc txd;
     uint32_t txd_idx;
     uint32_t data_len;
     hwaddr data_pa;
 
     for (;;) {
         if (!vmxnet3_pop_next_tx_descr(s, qidx, &txd, &txd_idx)) {
             break;
         }
 
         vmxnet3_dump_tx_descr(&txd);
 
         if (!s->skip_current_tx_pkt) {
             data_len = (txd.len > 0) ? txd.len : VMXNET3_MAX_TX_BUF_SIZE;
             data_pa = le64_to_cpu(txd.addr);
 
             if (!vmxnet_tx_pkt_add_raw_fragment(s->tx_pkt,
                                                 data_pa,
                                                 data_len)) {
                 s->skip_current_tx_pkt = true;
             }
         }
 
         if (s->tx_sop) {
             vmxnet3_tx_retrieve_metadata(s, &txd);
             s->tx_sop = false;
          }
  
          if (txd.eop) {
            if (!s->skip_current_tx_pkt) {
                vmxnet_tx_pkt_parse(s->tx_pkt);
             if (!s->skip_current_tx_pkt && vmxnet_tx_pkt_parse(s->tx_pkt)) {
                  if (s->needs_vlan) {
                      vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);
                  }
                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);
                 }
 
                 vmxnet3_send_packet(s, qidx);
             } else {
                 vmxnet3_on_tx_done_update_stats(s, qidx,
                                                 VMXNET3_PKT_STATUS_ERROR);
             }
 
             vmxnet3_complete_packet(s, qidx, txd_idx);
             s->tx_sop = true;
             s->skip_current_tx_pkt = false;
             vmxnet_tx_pkt_reset(s->tx_pkt);
         }
     }","[34, 32, 33]",QEMU (aka Quick Emulator) built with a VMWARE VMXNET3 paravirtual NIC emulator support is vulnerable to crash issue. It occurs when a guest sends a Layer-2 packet smaller than 22 bytes. A privileged (CAP_SYS_RAWIO) guest user could use this flaw to crash the QEMU process instance resulting in DoS.
206702," static Frame* ReuseExistingWindow(LocalFrame& active_frame,
                                   LocalFrame& lookup_frame,
                                   const AtomicString& frame_name,
                                   NavigationPolicy policy,
                                   const KURL& destination_url) {
   if (!frame_name.IsEmpty() && !EqualIgnoringASCIICase(frame_name, ""_blank"") &&
       policy == kNavigationPolicyIgnore) {
     if (Frame* frame = lookup_frame.FindFrameForNavigation(
             frame_name, active_frame, destination_url)) {
       if (!EqualIgnoringASCIICase(frame_name, ""_self"")) {
         if (Page* page = frame->GetPage()) {
            if (page == active_frame.GetPage())
              page->GetFocusController().SetFocusedFrame(frame);
            else
            page->GetChromeClient().Focus();
             page->GetChromeClient().Focus(&active_frame);
          }
        }
        return frame;
     }
   }
   return nullptr;
 }","[16, 15]",A JavaScript focused window could overlap the fullscreen notification in Fullscreen in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to obscure the full screen warning via a crafted HTML page.
199320,"  cib_remote_listen(gpointer data)
  {
    int lpc = 0;
      int csock = 0;
      unsigned laddr;
    time_t now = 0;
    time_t start = time(NULL);
      struct sockaddr_in addr;
      int ssock = *(int *)data;
     int flag;
  
  #ifdef HAVE_GNUTLS_GNUTLS_H
      gnutls_session *session = NULL;
  #endif
      cib_client_t *new_client = NULL;
  
    xmlNode *login = NULL;
    const char *user = NULL;
    const char *pass = NULL;
    const char *tmp = NULL;
#ifdef HAVE_DECL_NANOSLEEP
    const struct timespec sleepfast = { 0, 10000000 };   
#endif
      static struct mainloop_fd_callbacks remote_client_fd_callbacks = 
          {
              .dispatch = cib_remote_msg,
              .destroy = cib_remote_connection_destroy,
        };    
         };
 
       
      laddr = sizeof(addr);
      csock = accept(ssock, (struct sockaddr *)&addr, &laddr);
     crm_debug(""New %s connection from %s"",
               ssock == remote_tls_fd ? ""secure"" : ""clear-text"", inet_ntoa(addr.sin_addr));
 
     if (csock == -1) {
         crm_err(""accept socket failed"");
          return TRUE;
      }
  
     if ((flag = fcntl(csock, F_GETFL)) >= 0) {
         if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {
             crm_err( ""fcntl() write failed"");
             close(csock);
             return TRUE;
         }
     } else {
         crm_err( ""fcntl() read failed"");
         close(csock);
         return TRUE;
     }
 
      if (ssock == remote_tls_fd) {
  #ifdef HAVE_GNUTLS_GNUTLS_H
           
        session = create_tls_session(csock, GNUTLS_SERVER);
         session = crm_create_anon_tls_session(csock, GNUTLS_SERVER, anon_cred_s);
          if (session == NULL) {
              crm_err(""TLS session creation failed"");
              close(csock);
             return TRUE;
         }
  #endif
      }
  
    do {
        crm_trace(""Iter: %d"", lpc++);
        if (ssock == remote_tls_fd) {
#ifdef HAVE_GNUTLS_GNUTLS_H
            login = crm_recv_remote_msg(session, TRUE);
#endif
        } else {
            login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);
        }
        if (login != NULL) {
            break;
        }
#ifdef HAVE_DECL_NANOSLEEP
        nanosleep(&sleepfast, NULL);
#else
        sleep(1);
#endif
        now = time(NULL);
         
    } while (login == NULL && (start - now) < 4);
    crm_log_xml_info(login, ""Login: "");
    if (login == NULL) {
        goto bail;
    }
    tmp = crm_element_name(login);
    if (safe_str_neq(tmp, ""cib_command"")) {
        crm_err(""Wrong tag: %s"", tmp);
        goto bail;
    }
    tmp = crm_element_value(login, ""op"");
    if (safe_str_neq(tmp, ""authenticate"")) {
        crm_err(""Wrong operation: %s"", tmp);
        goto bail;
    }
    user = crm_element_value(login, ""user"");
    pass = crm_element_value(login, ""password"");
     
    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {
        crm_err(""User is not a member of the required group"");
        goto bail;
    } else if (authenticate_user(user, pass) == FALSE) {
        crm_err(""PAM auth failed"");
        goto bail;
    }
     
      num_clients++;
      new_client = calloc(1, sizeof(cib_client_t));
    new_client->name = crm_element_value_copy(login, ""name"");
    CRM_CHECK(new_client->id == NULL, free(new_client->id));
      new_client->id = crm_generate_uuid();
#if ENABLE_ACL
    new_client->user = strdup(user);
#endif
      new_client->callback_id = NULL;
      
     new_client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, new_client);
 
      if (ssock == remote_tls_fd) {
  #ifdef HAVE_GNUTLS_GNUTLS_H
          new_client->encrypted = TRUE;
         new_client->session = session;
 #endif
     } else {
          new_client->session = GINT_TO_POINTER(csock);
      }
  
    free_xml(login);
    login = create_xml_node(NULL, ""cib_result"");
    crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);
    crm_xml_add(login, F_CIB_CLIENTID, new_client->id);
    crm_send_remote_msg(new_client->session, login, new_client->encrypted);
    free_xml(login);
      new_client->remote = mainloop_add_fd(
          ""cib-remote-client"", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);
  
      g_hash_table_insert(client_list, new_client->id, new_client);
  
      return TRUE;
  bail:
    if (ssock == remote_tls_fd) {
#ifdef HAVE_GNUTLS_GNUTLS_H
        gnutls_bye(*session, GNUTLS_SHUT_RDWR);
        gnutls_deinit(*session);
        gnutls_free(session);
#endif
    }
    close(csock);
    free_xml(login);
    return TRUE;
  }","[10, 29, 30, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 58, 121, 122, 123, 3, 6, 7, 17, 18, 19, 20, 21, 22, 23, 28, 57, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 114, 115, 117, 118, 119, 133, 134, 135, 136, 137, 138, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]","Pacemaker 1.1.10, when remote Cluster Information Base (CIB) configuration or resource management is enabled, does not limit the duration of connections to the blocking sockets, which allows remote attackers to cause a denial of service (connection blocking)."
200980," static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   Image *image, *image2=NULL,
    *rotated_image;
   PixelPacket *q;
 
   unsigned int status;
   MATHeader MATLAB_HDR;
   size_t size;
   size_t CellType;
   QuantumInfo *quantum_info;
   ImageInfo *clone_info;
   int i;
   ssize_t ldblk;
   unsigned char *BImgBuff = NULL;
   double MinVal, MaxVal;
   size_t Unknown6;
   unsigned z, z2;
   unsigned Frames;
   int logging;
   int sample_size;
   MagickOffsetType filepos=0x80;
   BlobInfo *blob;
   size_t one;
 
   unsigned int (*ReadBlobXXXLong)(Image *image);
   unsigned short (*ReadBlobXXXShort)(Image *image);
   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);
 
 
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");
 
     
   quantum_info=(QuantumInfo *) NULL;
    image = AcquireImage(image_info);
  
    status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   clone_info=CloneImageInfo(image_info);
   if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
     {
       image2=ReadMATImageV4(image_info,image,exception);
       if (image2  == NULL)
         goto MATLAB_KO;
       image=image2;
       goto END_OF_READING;
     }
   MATLAB_HDR.Version = ReadBlobLSBShort(image);
   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
         MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
   if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
   {
     ReadBlobXXXLong = ReadBlobLSBLong;
     ReadBlobXXXShort = ReadBlobLSBShort;
     ReadBlobDoublesXXX = ReadBlobDoublesLSB;
     ReadBlobFloatsXXX = ReadBlobFloatsLSB;
     image->endian = LSBEndian;
   }
   else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
   {
     ReadBlobXXXLong = ReadBlobMSBLong;
     ReadBlobXXXShort = ReadBlobMSBShort;
     ReadBlobDoublesXXX = ReadBlobDoublesMSB;
     ReadBlobFloatsXXX = ReadBlobFloatsMSB;
     image->endian = MSBEndian;
   }
   else
     goto MATLAB_KO;     
 
   if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
 MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
 
   filepos = TellBlob(image);
   while(!EOFBlob(image))  
   {
     Frames = 1;
     (void) SeekBlob(image,filepos,SEEK_SET);
      
 
     MATLAB_HDR.DataType = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
     if(EOFBlob(image)) break;
     filepos += MATLAB_HDR.ObjectSize + 4 + 4;
 
     image2 = image;
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
     if(MATLAB_HDR.DataType == miCOMPRESSED)
     {
       image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
       if(image2==NULL) continue;
       MATLAB_HDR.DataType = ReadBlobXXXLong(image2);  
     }
 #endif
 
     if(MATLAB_HDR.DataType!=miMATRIX) continue;   
 
     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);
 
     MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;
 
     MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
     if(image!=image2)
       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);   
     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);
 
 
     switch(MATLAB_HDR.DimFlag)
     {
       case  8: z2=z=1; break;       
       case 12: z2=z = ReadBlobXXXLong(image2);   
            Unknown6 = ReadBlobXXXLong(image2);
            (void) Unknown6;
          if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
          break;
       case 16: z2=z = ReadBlobXXXLong(image2);   
          if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
          Frames = ReadBlobXXXLong(image2);
          if (Frames == 0)
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          break;
       default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
     }
 
     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);
 
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
           ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&     
         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT8_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT16_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT32_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&     
         MATLAB_HDR.StructureClass != mxINT64_CLASS &&
         MATLAB_HDR.StructureClass != mxUINT64_CLASS)     
       ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");
 
     switch (MATLAB_HDR.NameFlag)
     {
       case 0:
         size = ReadBlobXXXLong(image2);   
         size = 4 * (ssize_t) ((size + 3 + 1) / 4);
         (void) SeekBlob(image2, size, SEEK_CUR);
         break;
       case 1:
       case 2:
       case 3:
       case 4:
         (void) ReadBlob(image2, 4, (unsigned char *) &size);  
         break;
       default:
         goto MATLAB_KO;
     }
 
     CellType = ReadBlobXXXLong(image2);     
     if (logging)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""MATLAB_HDR.CellType: %.20g"",(double) CellType);
 
     (void) ReadBlob(image2, 4, (unsigned char *) &size);      
 
 NEXT_FRAME:
     switch (CellType)
     {
       case miINT8:
       case miUINT8:
         sample_size = 8;
         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
           image->depth = 1;
         else
           image->depth = 8;          
         ldblk = (ssize_t) MATLAB_HDR.SizeX;
         break;
       case miINT16:
       case miUINT16:
         sample_size = 16;
         image->depth = 16;         
         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
         break;
       case miINT32:
       case miUINT32:
         sample_size = 32;
         image->depth = 32;         
         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
         break;
       case miINT64:
       case miUINT64:
         sample_size = 64;
         image->depth = 64;         
         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
         break;
       case miSINGLE:
         sample_size = 32;
         image->depth = 32;         
         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
   {               
   }
         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
         break;
       case miDOUBLE:
         sample_size = 64;
         image->depth = 64;         
         (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
 DisableMSCWarning(4127)
         if (sizeof(double) != 8)
 RestoreMSCWarning
           ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
   {                          
   }
         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
         break;
       default:
         ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
     }
     (void) sample_size;
     image->columns = MATLAB_HDR.SizeX;
     image->rows = MATLAB_HDR.SizeY;
     quantum_info=AcquireQuantumInfo(clone_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     one=1;
     image->colors = one << image->depth;
     if (image->columns == 0 || image->rows == 0)
       goto MATLAB_KO;
        
     if ((MATLAB_HDR.DimFlag == 8) &&
         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
       {
         SetImageColorspace(image,GRAYColorspace);
         image->type=GrayscaleType;
       }
 
 
      
     if (image_info->ping)
     {
       size_t temp = image->columns;
       image->columns = image->rows;
       image->rows = temp;
       goto done_reading;  
     }
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
 
    
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));     
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
     if (CellType==miDOUBLE || CellType==miSINGLE)         
     {
       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
     }
 
      
     if(z==1) z=0;  
      
     do
     {
       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
       {
         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
         if (q == (PixelPacket *) NULL)
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto done_reading;     
   }
         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto ExitLoop;
   }
         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
         {
           FixLogical((unsigned char *)BImgBuff,ldblk);
           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
     {
 ImportQuantumPixelsFailed:
       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
       break;
     }
         }
         else
         {
           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
       goto ImportQuantumPixelsFailed;
 
 
           if (z<=1 &&        
           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
       FixSignedValues(q,MATLAB_HDR.SizeX);
         }
 
         if (!SyncAuthenticPixels(image,exception))
   {
     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
     goto ExitLoop;
   }
       }
     } while(z-- >= 2);
 ExitLoop:
 
 
      
     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
     {         
       CellType = ReadBlobXXXLong(image2);     
       i = ReadBlobXXXLong(image2);            
 
       if (CellType==miDOUBLE || CellType==miSINGLE)
       {
         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
       }
 
       if (CellType==miDOUBLE)
         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
   {
           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
           InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
   }
 
       if (CellType==miSINGLE)
         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
   {
           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
           InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
   }
     }
 
        
     if ((MATLAB_HDR.DimFlag == 8) &&
         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
       image->type=GrayscaleType;
     if (image->depth == 1)
       image->type=BilevelType;
 
     if(image2==image)
         image2 = NULL;     
 
        
     rotated_image = RotateImage(image, 90.0, exception);
     if (rotated_image != (Image *) NULL)
     {
          
       rotated_image->page.x=0;
       rotated_image->page.y=0;
 
       blob = rotated_image->blob;
       rotated_image->blob = image->blob;
       rotated_image->colors = image->colors;
       image->blob = blob;
       AppendImageToList(&image,rotated_image);
       DeleteImageFromList(&image);
     }
 
 done_reading:
 
     if(image2!=NULL)
       if(image2!=image)
       {
         DeleteImageFromList(&image2);
   if(clone_info)
   {
           if(clone_info->file)
     {
             fclose(clone_info->file);
             clone_info->file = NULL;
             (void) remove_utf8(clone_info->filename);
     }
         }
       }
 
        
     AcquireNextImage(image_info,image);
     if (image->next == (Image *) NULL) break;
     image=SyncNextImageInList(image);
     image->columns=image->rows=0;
     image->colors=0;
 
        
     RelinquishMagickMemory(BImgBuff);
     BImgBuff = NULL;
 
     if(--Frames>0)
     {
       z = z2;
       if(image2==NULL) image2 = image;
       goto NEXT_FRAME;
     }
 
     if(image2!=NULL)
       if(image2!=image)    
       {
  
         DeleteImageFromList(&image2);
         if(clone_info)
         {
           if(clone_info->file)
           {
             fclose(clone_info->file);
             clone_info->file = NULL;
             (void) unlink(clone_info->filename);
           }
          }
        }
    }
  
    RelinquishMagickMemory(BImgBuff);
  quantum_info=DestroyQuantumInfo(quantum_info);
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
  END_OF_READING:
    clone_info=DestroyImageInfo(clone_info);
    CloseBlob(image);
 
 
   {
     Image *p;
     ssize_t scene=0;
 
      
     p=image;
     image=NULL;
     while (p != (Image *) NULL)
       {
         Image *tmp=p;
         if ((p->rows == 0) || (p->columns == 0)) {
           p=p->previous;
           DeleteImageFromList(&tmp);
         } else {
           image=p;
           p=p->previous;
         }
       }
 
      
     for (p=image; p != (Image *) NULL; p=p->next)
       p->scene=scene++;
   }
 
   if(clone_info != NULL)   
   {
     if(clone_info->file)
     {
       fclose(clone_info->file);
       clone_info->file = NULL;
       (void) remove_utf8(clone_info->filename);
     }
     DestroyImageInfo(clone_info);
     clone_info = NULL;
   }
   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
   if(image==NULL)
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   return (image);
 }","[39, 450, 451, 449]","In ImageMagick before 6.9.8-5 and 7.x before 7.0.5-6, there is a memory leak in the ReadMATImage function in coders/mat.c."
198057," ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,
                         void *value, size_t vsize)
 {
     ssize_t size = 0;
     void *ovalue = value;
     XattrOperations *xops;
     char *orig_value, *orig_value_start;
     ssize_t xattr_len, parsed_len = 0, attr_len;
     char *dirpath, *name;
     int dirfd;
 
      
     dirpath = g_path_get_dirname(path);
     dirfd = local_opendir_nofollow(ctx, dirpath);
     g_free(dirpath);
     if (dirfd == -1) {
         return -1;
     }
 
     name = g_path_get_basename(path);
     xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);
     if (xattr_len <= 0) {
         g_free(name);
         close_preserve_errno(dirfd);
         return xattr_len;
     }
 
      
     orig_value = g_malloc(xattr_len);
     xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);
      g_free(name);
      close_preserve_errno(dirfd);
      if (xattr_len < 0) {
         g_free(orig_value);
          return -1;
      }
     orig_value_start = orig_value;
     while (xattr_len > parsed_len) {
         xops = get_xattr_operations(ctx->xops, orig_value);
         if (!xops) {
             goto next_entry;
         }
 
         if (!value) {
             size += xops->listxattr(ctx, path, orig_value, value, vsize);
         } else {
             size = xops->listxattr(ctx, path, orig_value, value, vsize);
             if (size < 0) {
                 goto err_out;
             }
             value += size;
             vsize -= size;
         }
 next_entry:
          
         attr_len = strlen(orig_value) + 1;
         parsed_len += attr_len;
         orig_value += attr_len;
     }
     if (value) {
         size = value - ovalue;
     }
 
 err_out:
     g_free(orig_value_start);
     return size;
 }",[34],Memory leak in the v9fs_list_xattr function in hw/9pfs/9p-xattr.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (memory consumption) via vectors involving the orig_value variable.
5496,"std::string decodeBase64(
const std::string& encoded) {

if (encoded.size() == 0) {

return """";
}

using namespace boost::archive::iterators;
using b64it =
transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;

std::string decoded = std::string(b64it(std::begin(encoded)),
b64it(std::end(encoded)));

uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');
decoded.erase(decoded.end() - numPadding, decoded.end());

return decoded;
}","[6, 9, 10, 11, 13, 14, 16, 17, 19]",An out of bounds write is possible via a specially crafted packet in certain configurations of Proxygen due to improper handling of Base64 when parsing malformed binary content in Structured HTTP Headers. This issue affects versions of proxygen prior to v2019.07.22.00.
205318,"  void BrowserViewRenderer::SetTotalRootLayerScrollOffset(
    gfx::Vector2dF scroll_offset_dip) {
     const gfx::Vector2dF& scroll_offset_dip) {
    if (scroll_offset_dip_ == scroll_offset_dip)
      return;
    scroll_offset_dip_ = scroll_offset_dip;
 
   gfx::Vector2d max_offset = max_scroll_offset();
   gfx::Vector2d scroll_offset;
   if (max_scroll_offset_dip_.x()) {
     scroll_offset.set_x((scroll_offset_dip.x() * max_offset.x()) /
                         max_scroll_offset_dip_.x());
   }
 
   if (max_scroll_offset_dip_.y()) {
     scroll_offset.set_y((scroll_offset_dip.y() * max_offset.y()) /
                         max_scroll_offset_dip_.y());
   }
 
   DCHECK_LE(0, scroll_offset.x());
   DCHECK_LE(0, scroll_offset.y());
   DCHECK_LE(scroll_offset.x(), max_offset.x());
   DCHECK_LE(scroll_offset.y(), max_offset.y());
 
   client_->ScrollContainerViewTo(scroll_offset);
 }","[3, 2]","Use-after-free vulnerability in the StyleElement::removedFromDocument function in core/dom/StyleElement.cpp in Blink, as used in Google Chrome before 35.0.1916.114, allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted JavaScript code that triggers tree mutation."
204784," static v8::Handle<v8::Value> methodWithSequenceArgCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestObj.methodWithSequenceArg"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestObj* imp = V8TestObj::toNative(args.Holder());
      EXCEPTION_BLOCK(sequence<ScriptProfile>*, sequenceArg, toNativeArray<ScriptProfile>(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
      imp->methodWithSequenceArg(sequenceArg);
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
199819," acc_ctx_hints(OM_uint32 *minor_status,
 	      gss_ctx_id_t *ctx,
 	      spnego_gss_cred_id_t spcred,
 	      gss_buffer_t *mechListMIC,
 	      OM_uint32 *negState,
 	      send_token_flag *return_token)
 {
 	OM_uint32 tmpmin, ret;
 	gss_OID_set supported_mechSet;
 	spnego_gss_ctx_id_t sc = NULL;
 
 	*mechListMIC = GSS_C_NO_BUFFER;
 	supported_mechSet = GSS_C_NO_OID_SET;
 	*return_token = NO_TOKEN_SEND;
 	*negState = REJECT;
 	*minor_status = 0;
 
 	 
 	if (*ctx != GSS_C_NO_CONTEXT)
 	    return GSS_S_DEFECTIVE_TOKEN;
 
 	ret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,
 				   &supported_mechSet);
 	if (ret != GSS_S_COMPLETE)
 		goto cleanup;
 
 	ret = make_NegHints(minor_status, mechListMIC);
  	if (ret != GSS_S_COMPLETE)
  		goto cleanup;
  
	sc = create_spnego_ctx();
 	sc = create_spnego_ctx(0);
  	if (sc == NULL) {
  		ret = GSS_S_FAILURE;
  		goto cleanup;
 	}
 	if (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {
 		ret = GSS_S_FAILURE;
 		goto cleanup;
 	}
 	sc->internal_mech = GSS_C_NO_OID;
 
 	*negState = ACCEPT_INCOMPLETE;
 	*return_token = INIT_TOKEN_SEND;
 	sc->firstpass = 1;
 	*ctx = (gss_ctx_id_t)sc;
 	sc = NULL;
 	ret = GSS_S_COMPLETE;
 
 cleanup:
 	release_spnego_ctx(&sc);
 	gss_release_oid_set(&tmpmin, &supported_mechSet);
 
 	return ret;
 }","[32, 31]","lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted SPNEGO packet that is mishandled during a gss_inquire_context call."
200159," int perf_event_refresh(struct perf_event *event, int refresh)
 static int _perf_event_refresh(struct perf_event *event, int refresh)
  {
  	 
 	if (event->attr.inherit || !is_sampling_event(event))
  		return -EINVAL;
  
  	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);
 	_perf_event_enable(event);
  
  	return 0;
  }","[2, 10, 9]","kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224."
205810,"  bool AXTableCell::isColumnHeaderCell() const {
    const AtomicString& scope = getAttribute(scopeAttr);
  return equalIgnoringCase(scope, ""col"") ||
         equalIgnoringCase(scope, ""colgroup"");
   return equalIgnoringASCIICase(scope, ""col"") ||
          equalIgnoringASCIICase(scope, ""colgroup"");
  }","[5, 6, 3, 4]","Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous *Always open files of this type* choice, related to download_commands.cc and download_prefs.cc."
204758," static v8::Handle<v8::Value> excitingFunctionCallback(const v8::Arguments& args)
  {
      INC_STATS(""DOM.TestActiveDOMObject.excitingFunction"");
      if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
      TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());
      if (!V8BindingSecurity::canAccessFrame(V8BindingState::Only(), imp->frame(), true))
          return v8::Handle<v8::Value>();
     EXCEPTION_BLOCK(Node*, nextChild, V8Node::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->excitingFunction(nextChild);
     return v8::Handle<v8::Value>();
 }","[6, 5]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
9521,"void initialize() override {
use_lds_ = false;
test_skipped_ = false;




setUpstreamCount(1);
setUpstreamProtocol(Http::CodecType::HTTP2);










defer_listener_finalization_ = true;
HttpIntegrationTest::initialize();




addFakeUpstream(Http::CodecType::HTTP2);
addFakeUpstream(Http::CodecType::HTTP2);
cluster1_ = ConfigHelper::buildStaticCluster(
ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),
Network::Test::getLoopbackAddressString(ipVersion()));
cluster2_ = ConfigHelper::buildStaticCluster(
ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),
Network::Test::getLoopbackAddressString(ipVersion()));


acceptXdsConnection();


EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, """", {}, {}, {}, true));
sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,
{cluster1_}, {cluster1_}, {}, ""55"");




test_server_->waitForGaugeGe(""cluster_manager.active_clusters"", 2);



test_server_->waitUntilListenersReady();
registerTestServerPorts({""http""});
}","[26, 27, 28, 30, 31, 33]","Envoy is an open source edge and service proxy, designed for cloud-native applications. When a cluster is deleted via Cluster Discovery Service (CDS) all idle connections established to endpoints in that cluster are disconnected. A recursion was introduced in the procedure of disconnecting idle connections that can lead to stack exhaustion and abnormal process termination when a cluster has a large number of idle connections. This infinite recursion causes Envoy to crash. Users are advised to upgrade."
205712," std::unique_ptr<JSONObject> EffectPaintPropertyNode::ToJSON() const {
   auto json = JSONObject::Create();
    if (Parent())
      json->SetString(""parent"", String::Format(""%p"", Parent()));
    json->SetString(""localTransformSpace"",
                  String::Format(""%p"", state_.local_transform_space.get()));
  json->SetString(""outputClip"", String::Format(""%p"", state_.output_clip.get()));
                   String::Format(""%p"", state_.local_transform_space));
   json->SetString(""outputClip"", String::Format(""%p"", state_.output_clip));
    if (state_.color_filter != kColorFilterNone)
      json->SetInteger(""colorFilter"", state_.color_filter);
    if (!state_.filter.IsEmpty())
     json->SetString(""filter"", state_.filter.ToString());
   if (state_.opacity != 1.0f)
     json->SetDouble(""opacity"", state_.opacity);
   if (state_.blend_mode != SkBlendMode::kSrcOver)
     json->SetString(""blendMode"", SkBlendMode_Name(state_.blend_mode));
   if (state_.direct_compositing_reasons != CompositingReason::kNone) {
     json->SetString(
         ""directCompositingReasons"",
         CompositingReason::ToString(state_.direct_compositing_reasons));
   }
   if (state_.compositor_element_id) {
     json->SetString(""compositorElementId"",
                     state_.compositor_element_id.ToString().c_str());
   }
   if (state_.paint_offset != FloatPoint())
     json->SetString(""paintOffset"", state_.paint_offset.ToString());
   return json;
 }","[8, 9, 6, 7]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
201607,"  void ping_unhash(struct sock *sk)
  {
  	struct inet_sock *isk = inet_sk(sk);
 
  	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
 	write_lock_bh(&ping_table.lock);
  	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
  		hlist_nulls_del(&sk->sk_nulls_node);
  		sk_nulls_node_init(&sk->sk_nulls_node);
  		sock_put(sk);
  		isk->inet_num = 0;
  		isk->inet_sport = 0;
  		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
  	}
 	write_unlock_bh(&ping_table.lock);
  }","[4, 6, 17, 8, 15]","The ping_unhash function in net/ipv4/ping.c in the Linux kernel through 4.10.8 is too late in obtaining a certain lock and consequently cannot ensure that disconnect function calls are safe, which allows local users to cause a denial of service (panic) by leveraging access to the protocol value of IPPROTO_ICMP in a socket system call."
203125," static inline signed short ReadPropertyMSBShort(const unsigned char **p,
   size_t *length)
 {
   union
   {
     unsigned short
       unsigned_value;
 
     signed short
       signed_value;
   } quantum;
 
   int
     c;
 
   register ssize_t
     i;
 
   unsigned char
     buffer[2];
 
   unsigned short
     value;
 
   if (*length < 2)
     return((unsigned short) ~0);
   for (i=0; i < 2; i++)
   {
     c=(int) (*(*p)++);
      (*length)--;
      buffer[i]=(unsigned char) c;
    }
  value=(unsigned short) (buffer[0] << 8);
  value|=buffer[1];
  quantum.unsigned_value=(value & 0xffff);
   value=(unsigned short) buffer[0] << 8;
   value|=(unsigned short) buffer[1];
   quantum.unsigned_value=value & 0xffff;
    return(quantum.signed_value);
  }","[36, 37, 38, 33, 34, 35]","MagickCore/property.c in ImageMagick before 7.0.2-1 allows remote attackers to obtain sensitive memory information via vectors involving the q variable, which triggers an out-of-bounds read."
5008,"bool read_ujpg( void )
{
using namespace IOUtil;
using namespace Sirikata;

unsigned char ujpg_mrk[ 64 ];

write_byte_bill(Billing::HEADER, true, 24);

str_out->call_size_callback(max_file_size);
uint32_t compressed_header_size = 0;
if (ReadFull(str_in, ujpg_mrk, 4) != 4) {
custom_exit(ExitCode::SHORT_READ);
}
write_byte_bill(Billing::HEADER, true, 4);

compressed_header_size = LEtoUint32(ujpg_mrk);
if (compressed_header_size > 128 * 1024 * 1024 || max_file_size > 128 * 1024 * 1024) {
always_assert(false && ""Only support images < 128 megs"");
return false;
}
bool pending_header_reads = false;
if (header_reader == NULL) {
std::vector<uint8_t, JpegAllocator<uint8_t> > compressed_header_buffer(compressed_header_size);
IOUtil::ReadFull(str_in, compressed_header_buffer.data(), compressed_header_buffer.size());
header_reader = new MemReadWriter((JpegAllocator<uint8_t>()));
{
if (ujgversion == 1) {
JpegAllocator<uint8_t> no_free_allocator;
#if !defined(USE_STANDARD_MEMORY_ALLOCATORS) && !defined(_WIN32) && !defined(EMSCRIPTEN)
no_free_allocator.setup_memory_subsystem(32 * 1024 * 1024,
16,
&mem_init_nop,
&MemMgrAllocatorMalloc,
&mem_nop,
&mem_realloc_nop,
&MemMgrAllocatorMsize);
#endif
std::pair<std::vector<uint8_t,
Sirikata::JpegAllocator<uint8_t> >,
JpegError> uncompressed_header_buffer(
ZlibDecoderDecompressionReader::Decompress(compressed_header_buffer.data(),
compressed_header_buffer.size(),
no_free_allocator,
max_file_size + 2048));
if (uncompressed_header_buffer.second) {
always_assert(false && ""Data not properly zlib coded"");
return false;
}
zlib_hdrs = compressed_header_buffer.size();
header_reader->SwapIn(uncompressed_header_buffer.first, 0);
} else {
std::pair<std::vector<uint8_t,
Sirikata::JpegAllocator<uint8_t> >,
JpegError> uncompressed_header_buffer(
Sirikata::BrotliCodec::Decompress(compressed_header_buffer.data(),
compressed_header_buffer.size(),
JpegAllocator<uint8_t>(),
max_file_size * 2 + 128 * 1024 * 1024));
if (uncompressed_header_buffer.second) {
always_assert(false && ""Data not properly zlib coded"");
return false;
}
zlib_hdrs = compressed_header_buffer.size();
header_reader->SwapIn(uncompressed_header_buffer.first, 0);
}
}
write_byte_bill(Billing::HEADER,
true,
compressed_header_buffer.size());
} else {
always_assert(compressed_header_size == 0 && ""Special concatenation requires 0 size header"");
}
grbs = sizeof(EOI);
grbgdata = EOI;

ReadFull(header_reader, ujpg_mrk, 3 ) ;

if ( memcmp( ujpg_mrk, ""HDR"", 3 ) == 0 ) {

ReadFull(header_reader, ujpg_mrk, 4 );
hdrs = LEtoUint32(ujpg_mrk);
hdrdata = (unsigned char*) aligned_alloc(hdrs);
memset(hdrdata, 0, hdrs);
if ( hdrdata == NULL ) {
fprintf( stderr, MEM_ERRMSG );
errorlevel.store(2);
return false;
}

ReadFull(header_reader, hdrdata, hdrs );
}
else {
fprintf( stderr, ""HDR marker not found"" );
errorlevel.store(2);
return false;
}
bool memory_optimized_image = (filetype != UJG) && !g_allow_progressive;

if ( !setup_imginfo_jpg(memory_optimized_image) )
return false;




ReadFull(header_reader, ujpg_mrk, 3 );

if ( memcmp( ujpg_mrk, ""P0D"", 3 ) == 0 ) {

header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );
}
else if ( memcmp( ujpg_mrk, ""PAD"", 3 ) == 0 ) {

header_reader->Read( reinterpret_cast<unsigned char*>(&padbit), 1 );
if (!(padbit == 0 || padbit == 1 ||padbit == -1)) {
while (write(2,
""Legacy Padbit must be 0, 1 or -1\n"",
strlen(""Legacy Padbit must be 0, 1 or -1\n"")) < 0
&& errno == EINTR) {
}
custom_exit(ExitCode::STREAM_INCONSISTENT);
}
if (padbit == 1) {
padbit = 0x7f;
}
}
else {
fprintf( stderr, ""PAD marker not found"" );
errorlevel.store(2);
return false;
}
std::vector<ThreadHandoff> thread_handoff;

while ( ReadFull(header_reader, ujpg_mrk, 3 ) == 3 ) {

if ( memcmp( ujpg_mrk, ""CRS"", 3 ) == 0 ) {
rst_cnt_set = true;
ReadFull(header_reader, ujpg_mrk, 4);
rst_cnt.resize(LEtoUint32(ujpg_mrk));
for (size_t i = 0; i < rst_cnt.size(); ++i) {
ReadFull(header_reader, ujpg_mrk, 4);
rst_cnt.at(i) = LEtoUint32(ujpg_mrk);
}
} else if ( memcmp( ujpg_mrk, ""HHX"", 2 ) == 0 ) {
size_t to_alloc = ThreadHandoff::get_remaining_data_size_from_two_bytes(ujpg_mrk + 1) + 2;
if(to_alloc) {
std::vector<unsigned char> data(to_alloc);
data[0] = ujpg_mrk[1];
data[1] = ujpg_mrk[2];
ReadFull(header_reader, &data[2], to_alloc - 2);
thread_handoff = ThreadHandoff::deserialize(&data[0], to_alloc);
}
} else if ( memcmp( ujpg_mrk, ""FRS"", 3 ) == 0 ) {

ReadFull(header_reader, ujpg_mrk, 4);
scnc = LEtoUint32(ujpg_mrk);

rst_err.insert(rst_err.end(), scnc - rst_err.size(), 0);

ReadFull(header_reader, rst_err.data(), scnc );
}
else if ( memcmp( ujpg_mrk, ""GRB"", 3 ) == 0 ) {

ReadFull(header_reader, ujpg_mrk, 4);
grbs = LEtoUint32(ujpg_mrk);
grbgdata = aligned_alloc(grbs);
memset(grbgdata, 0, sizeof(grbs));
if ( grbgdata == NULL ) {
fprintf( stderr, MEM_ERRMSG );
errorlevel.store(2);
return false;
}

ReadFull(header_reader, grbgdata, grbs );
}
else if ( memcmp( ujpg_mrk, ""PGR"", 3 ) == 0 || memcmp( ujpg_mrk, ""PGE"", 3 ) == 0 ) {

if (ujpg_mrk[2] == 'E') {

embedded_jpeg = true;
}
ReadFull(header_reader, ujpg_mrk, 4);
prefix_grbs = LEtoUint32(ujpg_mrk);
prefix_grbgdata = aligned_alloc(prefix_grbs);
memset(prefix_grbgdata, 0, sizeof(prefix_grbs));
if ( prefix_grbgdata == NULL ) {
fprintf( stderr, MEM_ERRMSG );
errorlevel.store(2);
return false;
}

ReadFull(header_reader, prefix_grbgdata, prefix_grbs );
}
else if ( memcmp( ujpg_mrk, ""SIZ"", 3 ) == 0 ) {

ReadFull(header_reader, ujpg_mrk, 4);
max_file_size = LEtoUint32(ujpg_mrk);
}
else if ( memcmp( ujpg_mrk, ""EEE"", 3) == 0) {
ReadFull(header_reader, ujpg_mrk, 28);
max_cmp = LEtoUint32(ujpg_mrk);
max_bpos = LEtoUint32(ujpg_mrk + 4);
max_sah = LEtoUint32(ujpg_mrk + 8);
max_dpos[0] = LEtoUint32(ujpg_mrk + 12);
max_dpos[1] = LEtoUint32(ujpg_mrk + 16);
max_dpos[2] = LEtoUint32(ujpg_mrk + 20);
max_dpos[3] = LEtoUint32(ujpg_mrk + 24);
early_eof_encountered = true;
colldata.set_truncation_bounds(max_cmp, max_bpos, max_dpos, max_sah);
}
else {
if (memcmp(ujpg_mrk, ""CNT"", 3) == 0 ) {
pending_header_reads = true;
break;
} else if (memcmp(ujpg_mrk, ""CMP"", 3) == 0 ) {
break;
} else {
fprintf( stderr, ""unknown data found"" );
errorlevel.store(2);
}
return false;
}
}
if (!pending_header_reads) {
delete header_reader;
header_reader = NULL;
}
write_byte_bill(Billing::HEADER,
false,
2 + hdrs + prefix_grbs + grbs);

ReadFull(str_in, ujpg_mrk, 3 ) ;
write_byte_bill(Billing::HEADER, true, 3);

write_byte_bill(Billing::DELIMITERS, true, 4 * NUM_THREADS);
write_byte_bill(Billing::HEADER, true, 4);

if (memcmp(ujpg_mrk, ""CMP"", 3) != 0) {
always_assert(false && ""CMP must be present (uncompressed) in the file or CNT continue marker"");
return false;
}
colldata.signal_worker_should_begin();
g_decoder->initialize(str_in, thread_handoff);
colldata.start_decoder(g_decoder);
return true;
}",[59],read_ujpg in jpgcoder.cc in Dropbox Lepton 1.2.1 allows attackers to cause a denial-of-service (application runtime crash because of an integer overflow) via a crafted file.
204964," xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
     const xmlChar *elemName;
     const xmlChar *attrName;
     xmlEnumerationPtr tree;
 
     if (CMP9(CUR_PTR, '<', '!', 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
 	xmlParserInputPtr input = ctxt->input;
 
 	SKIP(9);
 	if (!IS_BLANK_CH(CUR)) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		                 ""Space required after '<!ATTLIST'\n"");
 	}
         SKIP_BLANKS;
         elemName = xmlParseName(ctxt);
 	if (elemName == NULL) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 			   ""ATTLIST: no name for Element\n"");
 	    return;
  	}
  	SKIP_BLANKS;
  	GROW;
	while (RAW != '>') {
 	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
  	    const xmlChar *check = CUR_PTR;
  	    int type;
  	    int def;
 	    xmlChar *defaultValue = NULL;
 
 	    GROW;
             tree = NULL;
 	    attrName = xmlParseName(ctxt);
 	    if (attrName == NULL) {
 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 			       ""ATTLIST: no name for Attribute\n"");
 		break;
 	    }
 	    GROW;
 	    if (!IS_BLANK_CH(CUR)) {
 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		        ""Space required after the attribute name\n"");
 		break;
 	    }
 	    SKIP_BLANKS;
 
 	    type = xmlParseAttributeType(ctxt, &tree);
 	    if (type <= 0) {
 	        break;
 	    }
 
 	    GROW;
 	    if (!IS_BLANK_CH(CUR)) {
 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			       ""Space required after the attribute type\n"");
 	        if (tree != NULL)
 		    xmlFreeEnumeration(tree);
 		break;
 	    }
 	    SKIP_BLANKS;
 
 	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
 	    if (def <= 0) {
                 if (defaultValue != NULL)
 		    xmlFree(defaultValue);
 	        if (tree != NULL)
 		    xmlFreeEnumeration(tree);
 	        break;
 	    }
 	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
 	        xmlAttrNormalizeSpace(defaultValue, defaultValue);
 
 	    GROW;
             if (RAW != '>') {
 		if (!IS_BLANK_CH(CUR)) {
 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			""Space required after the attribute default value\n"");
 		    if (defaultValue != NULL)
 			xmlFree(defaultValue);
 		    if (tree != NULL)
 			xmlFreeEnumeration(tree);
 		    break;
 		}
 		SKIP_BLANKS;
 	    }
 	    if (check == CUR_PTR) {
 		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 		            ""in xmlParseAttributeListDecl\n"");
 		if (defaultValue != NULL)
 		    xmlFree(defaultValue);
 	        if (tree != NULL)
 		    xmlFreeEnumeration(tree);
 		break;
 	    }
 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
 		(ctxt->sax->attributeDecl != NULL))
 		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
 	                        type, def, defaultValue, tree);
 	    else if (tree != NULL)
 		xmlFreeEnumeration(tree);
 
 	    if ((ctxt->sax2) && (defaultValue != NULL) &&
 	        (def != XML_ATTRIBUTE_IMPLIED) && 
 		(def != XML_ATTRIBUTE_REQUIRED)) {
 		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
 	    }
 	    if (ctxt->sax2) {
 		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
 	    }
 	    if (defaultValue != NULL)
 	        xmlFree(defaultValue);
 	    GROW;
 	}
 	if (RAW == '>') {
 	    if (input != ctxt->input) {
 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
     ""Attribute list declaration doesn't start and stop in the same entity\n"",
                                  NULL, NULL);
 	    }
 	    NEXT;
 	}
     }
 }","[24, 23]","parser.c in libxml2 before 2.9.0, as used in Google Chrome before 28.0.1500.71 and other products, allows remote attackers to cause a denial of service (out-of-bounds read) via a document that ends abruptly, related to the lack of certain checks for the XML_PARSER_EOF state."
205713," GeometryMapper::SourceToDestinationProjectionInternal(
     const TransformPaintPropertyNode* source,
     const TransformPaintPropertyNode* destination,
     bool& success) {
   DCHECK(source && destination);
   DEFINE_STATIC_LOCAL(TransformationMatrix, identity, (TransformationMatrix()));
   DEFINE_STATIC_LOCAL(TransformationMatrix, temp, (TransformationMatrix()));
 
   if (source == destination) {
     success = true;
     return identity;
   }
 
   const GeometryMapperTransformCache& source_cache =
       source->GetTransformCache();
   const GeometryMapperTransformCache& destination_cache =
       destination->GetTransformCache();
 
   if (source_cache.plane_root() == destination_cache.plane_root()) {
     success = true;
     if (source == destination_cache.plane_root())
       return destination_cache.from_plane_root();
     if (destination == source_cache.plane_root())
       return source_cache.to_plane_root();
     temp = destination_cache.from_plane_root();
     temp.Multiply(source_cache.to_plane_root());
     return temp;
   }
 
   if (!destination_cache.projection_from_screen_is_valid()) {
     success = false;
     return identity;
   }
  
  const auto* root = TransformPaintPropertyNode::Root();
   const auto* root = &TransformPaintPropertyNode::Root();
    success = true;
    if (source == root)
      return destination_cache.projection_from_screen();
   if (destination == root) {
     temp = source_cache.to_screen();
   } else {
     temp = destination_cache.projection_from_screen();
     temp.Multiply(source_cache.to_screen());
   }
   temp.FlattenTo2d();
   return temp;
 }","[36, 35]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
207597," static void rpng2_x_redisplay_image(ulg startcol, ulg startrow,
                                     ulg width, ulg height)
 {
     uch bg_red   = rpng2_info.bg_red;
     uch bg_green = rpng2_info.bg_green;
     uch bg_blue  = rpng2_info.bg_blue;
     uch *src, *src2=NULL;
  char *dest;
     uch r, g, b, a;
     ulg i, row, lastrow = 0;
     ulg pixel;
  int ximage_rowbytes = ximage->bytes_per_line;
 
 
  Trace((stderr, ""beginning display loop (image_channels == %d)\n"",
       rpng2_info.channels))
  Trace((stderr, ""   (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\n"",
       rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes))
  Trace((stderr, ""   (bpp = %d)\n"", ximage->bits_per_pixel))
  Trace((stderr, ""   (byte_order = %s)\n"", ximage->byte_order == MSBFirst?
  ""MSBFirst"" : (ximage->byte_order == LSBFirst? ""LSBFirst"" : ""unknown"")))
 
  
 
  if (depth == 24 || depth == 32) {
         ulg red, green, blue;
  int bpp = ximage->bits_per_pixel;
 
  for (lastrow = row = startrow;  row < startrow+height; ++row) {
             src = rpng2_info.image_data + row*rpng2_info.rowbytes;
  if (bg_image)
                 src2 = bg_data + row*bg_rowbytes;
             dest = ximage->data + row*ximage_rowbytes;
  if (rpng2_info.channels == 3) {
  for (i = rpng2_info.width;  i > 0; --i) {
                     red   = *src++;
                     green = *src++;
                     blue  = *src++;
 #ifdef NO_24BIT_MASKS
                     pixel = (red   << RShift) |
  (green << GShift) |
  (blue  << BShift);
   
  if (bpp == 32) {
  *dest++ = (char)((pixel >> 24) & 0xff);
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  } else {
   
   
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
 #else
                     red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;
                     green = (GShift < 0)? green << (-GShift) : green >> GShift;
                     blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;
                     pixel = (red & RMask) | (green & GMask) | (blue & BMask);
   
  if (bpp == 32) {
  *dest++ = (char)((pixel >> 24) & 0xff);
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  } else {
   
   
   
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
 #endif
  }
 
  } else   {
  for (i = rpng2_info.width;  i > 0; --i) {
                     r = *src++;
                     g = *src++;
                     b = *src++;
                     a = *src++;
  if (bg_image) {
                         bg_red   = *src2++;
                         bg_green = *src2++;
                         bg_blue  = *src2++;
  }
  if (a == 255) {
                         red   = r;
                         green = g;
                         blue  = b;
  } else if (a == 0) {
                         red   = bg_red;
                         green = bg_green;
                         blue  = bg_blue;
  } else {
   
                         alpha_composite(red,   r, a, bg_red);
                         alpha_composite(green, g, a, bg_green);
                         alpha_composite(blue,  b, a, bg_blue);
  }
 #ifdef NO_24BIT_MASKS
                     pixel = (red   << RShift) |
  (green << GShift) |
  (blue  << BShift);
   
  if (bpp == 32) {
  *dest++ = (char)((pixel >> 24) & 0xff);
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  } else {
   
   
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
 #else
                     red   = (RShift < 0)? red   << (-RShift) : red   >> RShift;
                     green = (GShift < 0)? green << (-GShift) : green >> GShift;
                     blue  = (BShift < 0)? blue  << (-BShift) : blue  >> BShift;
                     pixel = (red & RMask) | (green & GMask) | (blue & BMask);
   
  if (bpp == 32) {
  *dest++ = (char)((pixel >> 24) & 0xff);
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  } else {
   
   
   
  *dest++ = (char)((pixel >> 16) & 0xff);
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
 #endif
  }
  }
   
  if (((row+1) & 0xf) == 0) {
  XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
  (int)lastrow, rpng2_info.width, 16);
  XFlush(display);
                 lastrow = row + 1;
  }
  }
 
  } else if (depth == 16) {
         ush red, green, blue;
 
  for (lastrow = row = startrow;  row < startrow+height; ++row) {
             src = rpng2_info.row_pointers[row];
  if (bg_image)
                 src2 = bg_data + row*bg_rowbytes;
             dest = ximage->data + row*ximage_rowbytes;
  if (rpng2_info.channels == 3) {
  for (i = rpng2_info.width;  i > 0; --i) {
                     red   = ((ush)(*src) << 8);
  ++src;
                     green = ((ush)(*src) << 8);
  ++src;
                     blue  = ((ush)(*src) << 8);
  ++src;
                     pixel = ((red   >> RShift) & RMask) |
  ((green >> GShift) & GMask) |
  ((blue  >> BShift) & BMask);
   
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
  } else   {
  for (i = rpng2_info.width;  i > 0; --i) {
                     r = *src++;
                     g = *src++;
                     b = *src++;
                     a = *src++;
  if (bg_image) {
                         bg_red   = *src2++;
                         bg_green = *src2++;
                         bg_blue  = *src2++;
  }
  if (a == 255) {
                         red   = ((ush)r << 8);
                         green = ((ush)g << 8);
                         blue  = ((ush)b << 8);
  } else if (a == 0) {
                         red   = ((ush)bg_red   << 8);
                         green = ((ush)bg_green << 8);
                         blue  = ((ush)bg_blue  << 8);
  } else {
   
                         alpha_composite(r, r, a, bg_red);
                         alpha_composite(g, g, a, bg_green);
                         alpha_composite(b, b, a, bg_blue);
                         red   = ((ush)r << 8);
                         green = ((ush)g << 8);
                         blue  = ((ush)b << 8);
  }
                     pixel = ((red   >> RShift) & RMask) |
  ((green >> GShift) & GMask) |
  ((blue  >> BShift) & BMask);
   
  *dest++ = (char)((pixel >> 8) & 0xff);
  *dest++ = (char)( pixel        & 0xff);
  }
  }
   
  if (((row+1) & 0xf) == 0) {
  XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
  (int)lastrow, rpng2_info.width, 16);
  XFlush(display);
                 lastrow = row + 1;
  }
  }
 
  } else   {
 
   
 
  }
 
  Trace((stderr, ""calling final XPutImage()\n""))
  if (lastrow < startrow+height) {
  XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
  (int)lastrow, rpng2_info.width, rpng2_info.height-lastrow);
 
          XFlush(display);
      }
  
     (void)startcol;
     (void)width;
 
  }  ","[233, 234, 235]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
201673," static int http_read_stream(URLContext *h, uint8_t *buf, int size)
 {
     HTTPContext *s = h->priv_data;
     int err, new_location, read_ret;
     int64_t seek_ret;
 
     if (!s->hd)
         return AVERROR_EOF;
 
     if (s->end_chunked_post && !s->end_header) {
         err = http_read_header(h, &new_location);
         if (err < 0)
              return err;
      }
  
    if (s->chunksize >= 0) {
     if (s->chunksize != UINT64_MAX) {
          if (!s->chunksize) {
              char line[32];
  
                 do {
                     if ((err = http_get_line(s, line, sizeof(line))) < 0)
                          return err;
                  } while (!*line);     
  
                s->chunksize = strtoll(line, NULL, 16);
                 s->chunksize = strtoull(line, NULL, 16);
  
                av_log(NULL, AV_LOG_TRACE, ""Chunked encoding data size: %""PRId64""'\n"",
                 av_log(h, AV_LOG_TRACE,
                        ""Chunked encoding data size: %""PRIu64""'\n"",
                          s->chunksize);
  
                  if (!s->chunksize)
                      return 0;
                 else if (s->chunksize == UINT64_MAX) {
                     av_log(h, AV_LOG_ERROR, ""Invalid chunk size %""PRIu64""\n"",
                            s->chunksize);
                     return AVERROR(EINVAL);
                 }
          }
          size = FFMIN(size, s->chunksize);
      }
 #if CONFIG_ZLIB
     if (s->compressed)
         return http_buf_read_compressed(h, buf, size);
 #endif  
      read_ret = http_buf_read(h, buf, size);
      if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)
          || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {
        int64_t target = h->is_streamed ? 0 : s->off;
         uint64_t target = h->is_streamed ? 0 : s->off;
  
          if (s->reconnect_delay > s->reconnect_delay_max)
              return AVERROR(EIO);
  
        av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRId64"" error=%s.\n"", s->off, av_err2str(read_ret));
         av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRIu64"" error=%s.\n"", s->off, av_err2str(read_ret));
          av_usleep(1000U*1000*s->reconnect_delay);
          s->reconnect_delay = 1 + 2*s->reconnect_delay;
          seek_ret = http_seek_internal(h, target, SEEK_SET, 1);
          if (seek_ret != target) {
            av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRId64"".\n"", target);
             av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRIu64"".\n"", target);
              return read_ret;
          }
  
         read_ret = http_buf_read(h, buf, size);
     } else
         s->reconnect_delay = 0;
 
     return read_ret;
 }","[17, 27, 30, 31, 36, 37, 38, 39, 40, 52, 58, 64, 16, 26, 29, 51, 57, 63]","Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response."
207263," void BrowserDevToolsAgentHost::AttachSession(DevToolsSession* session) {
 bool BrowserDevToolsAgentHost::AttachSession(DevToolsSession* session) {
   if (session->restricted())
     return false;
 
    session->SetBrowserOnly(true);
    session->AddHandler(
        base::WrapUnique(new protocol::TargetHandler(true  )));
    if (only_discovery_)
    return;
     return true;
  
    session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
    session->AddHandler(base::WrapUnique(new protocol::IOHandler(
       GetIOContext())));
   session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
   session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
   session->AddHandler(base::WrapUnique(new protocol::SystemInfoHandler()));
   session->AddHandler(base::WrapUnique(new protocol::TetheringHandler(
       socket_callback_, tethering_task_runner_)));
   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(
        protocol::TracingHandler::Browser,
        FrameTreeNode::kFrameTreeNodeInvalidId,
        GetIOContext())));
   return true;
  }","[2, 3, 4, 5, 11, 25, 10]",Allowing the chrome.debugger API to attach to Web UI pages in DevTools in Google Chrome prior to 67.0.3396.62 allowed an attacker who convinced a user to install a malicious extension to execute arbitrary code via a crafted Chrome Extension.
207562," MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)
 
  {
      ALOGV(""constructor"");
  
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     const sp<IMediaPlayerService> service(getMediaPlayerService());
      if (service != NULL) {
          mMediaRecorder = service->createMediaRecorder(opPackageName);
      }
  if (mMediaRecorder != NULL) {
         mCurrentState = MEDIA_RECORDER_IDLE;
  }
 
 
     doCleanUp();
 }","[7, 6]","libmedia in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 has certain incorrect declarations, which allows remote attackers to execute arbitrary code or cause a denial of service (NULL pointer dereference or memory corruption) via a crafted media file, aka internal bug 28166152."
201130," le64addr_string(netdissect_options *ndo, const u_char *ep)
 {
  	const unsigned int len = 8;
  	register u_int i;
  	register char *cp;
	register struct enamemem *tp;
 	register struct bsnamemem *tp;
  	char buf[BUFSIZE];
  
  	tp = lookup_bytestring(ndo, ep, len);
	if (tp->e_name)
		return (tp->e_name);
 	if (tp->bs_name)
 		return (tp->bs_name);
  
  	cp = buf;
  	for (i = len; i > 0 ; --i) {
 		*cp++ = hex[*(ep + i - 1) >> 4];
 		*cp++ = hex[*(ep + i - 1) & 0xf];
 		*cp++ = ':';
 	}
 	cp --;
  
  	*cp = '\0';
  
	tp->e_name = strdup(buf);
	if (tp->e_name == NULL)
 	tp->bs_name = strdup(buf);
 	if (tp->bs_name == NULL)
  		(*ndo->ndo_error)(ndo, ""le64addr_string: strdup(buf)"");
  
	return (tp->e_name);
 	return (tp->bs_name);
  }","[7, 13, 14, 28, 29, 33, 6, 11, 12, 26, 27, 32]",Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().
207046,"  std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                             const std::wstring& switch_name) {
   static constexpr wchar_t kSwitchTerminator[] = L""--"";
    assert(!command_line.empty());
    assert(!switch_name.empty());
  
    std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
    std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
   auto end = std::find(as_array.cbegin(), as_array.cend(), kSwitchTerminator);
   for (auto scan = as_array.cbegin(); scan != end; ++scan) {
     const std::wstring& arg = *scan;
      if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
        return arg.substr(switch_with_equal.size());
    }
 
   return std::wstring();
 }","[3, 11, 12, 13, 9, 10]",Incorrect command line processing in Chrome in Google Chrome prior to 73.0.3683.75 allowed a local attacker to perform domain spoofing via a crafted domain name.
201823," newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)
 {
 	struct sshbuf *b;
 	struct sshcipher_ctx *cc;
 	struct sshcomp *comp;
 	struct sshenc *enc;
 	struct sshmac *mac;
 	struct newkeys *newkey;
 	int r;
 
 	if ((newkey = ssh->state->newkeys[mode]) == NULL)
 		return SSH_ERR_INTERNAL_ERROR;
 	enc = &newkey->enc;
 	mac = &newkey->mac;
 	comp = &newkey->comp;
 	cc = (mode == MODE_OUT) ? ssh->state->send_context :
 	    ssh->state->receive_context;
 	if ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)
 		return r;
 	if ((b = sshbuf_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
 	 
 	if ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||
 	    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||
 	    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||
 	    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||
 	    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||
 	    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)
 		goto out;
 	if (cipher_authlen(enc->cipher) == 0) {
 		if ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||
 		    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||
 		    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)
  			goto out;
  	}
  	if ((r = sshbuf_put_u32(b, comp->type)) != 0 ||
	    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||
  	    (r = sshbuf_put_cstring(b, comp->name)) != 0)
  		goto out;
  	r = sshbuf_put_stringb(m, b);
  out:
 	sshbuf_free(b);
 	return r;
 }",[37],"The shared memory manager (associated with pre-authentication compression) in sshd in OpenSSH before 7.4 does not ensure that a bounds check is enforced by all compilers, which might allows local users to gain privileges by leveraging access to a sandboxed privilege-separation process, related to the m_zback and m_zlib data structures."
198924," static int sgi_timer_set(struct k_itimer *timr, int flags,
 	struct itimerspec * new_setting,
 	struct itimerspec * old_setting)
 {
 	unsigned long when, period, irqflags;
 	int err = 0;
 	cnodeid_t nodeid;
 	struct mmtimer *base;
 	struct rb_node *n;
 
 	if (old_setting)
  		sgi_timer_get(timr, old_setting);
  
  	sgi_timer_del(timr);
	when = timespec_to_ns(new_setting->it_value);
	period = timespec_to_ns(new_setting->it_interval);
 	when = timespec_to_ns(&new_setting->it_value);
 	period = timespec_to_ns(&new_setting->it_interval);
  
  	if (when == 0)
  		 
 		return 0;
 
 	base = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);
 	if (base == NULL)
 		return -ENOMEM;
 
 	if (flags & TIMER_ABSTIME) {
 		struct timespec n;
  		unsigned long now;
  
  		getnstimeofday(&n);
		now = timespec_to_ns(n);
 		now = timespec_to_ns(&n);
  		if (when > now)
  			when -= now;
  		else
 			 
 			when = 0;
 	}
 
 	 
 	when = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();
 	period = (period + sgi_clock_period - 1)  / sgi_clock_period;
 
 	 
 	preempt_disable();
 
 	nodeid =  cpu_to_node(smp_processor_id());
 
 	 
 	spin_lock_irqsave(&timers[nodeid].lock, irqflags);
 
 	base->timer = timr;
 	base->cpu = smp_processor_id();
 
 	timr->it.mmtimer.clock = TIMER_SET;
 	timr->it.mmtimer.node = nodeid;
 	timr->it.mmtimer.incr = period;
 	timr->it.mmtimer.expires = when;
 
 	n = timers[nodeid].next;
 
 	 
 	mmtimer_add_list(base);
 
 	if (timers[nodeid].next == n) {
 		 
 		spin_unlock_irqrestore(&timers[nodeid].lock, irqflags);
 		preempt_enable();
 		return err;
 	}
 
 	 
 	if (n)
 		mmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);
 
 	mmtimer_set_next_timer(nodeid);
 
 	 
 	spin_unlock_irqrestore(&timers[nodeid].lock, irqflags);
 
 	preempt_enable();
 
 	return err;
 }","[17, 18, 34, 15, 16, 33]",The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.
199023," int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	int offset, int len, int odd, struct sk_buff *skb),
 	void *from, int length, int transhdrlen,
 	int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,
 	struct rt6_info *rt, unsigned int flags, int dontfrag)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct inet_cork *cork;
 	struct sk_buff *skb;
 	unsigned int maxfraglen, fragheaderlen;
 	int exthdrlen;
 	int hh_len;
 	int mtu;
 	int copy;
 	int err;
 	int offset = 0;
 	int csummode = CHECKSUM_NONE;
 	__u8 tx_flags = 0;
 
 	if (flags&MSG_PROBE)
 		return 0;
 	cork = &inet->cork.base;
 	if (skb_queue_empty(&sk->sk_write_queue)) {
 		 
 		if (opt) {
 			if (WARN_ON(np->cork.opt))
 				return -EINVAL;
 
 			np->cork.opt = kmalloc(opt->tot_len, sk->sk_allocation);
 			if (unlikely(np->cork.opt == NULL))
 				return -ENOBUFS;
 
 			np->cork.opt->tot_len = opt->tot_len;
 			np->cork.opt->opt_flen = opt->opt_flen;
 			np->cork.opt->opt_nflen = opt->opt_nflen;
 
 			np->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,
 							    sk->sk_allocation);
 			if (opt->dst0opt && !np->cork.opt->dst0opt)
 				return -ENOBUFS;
 
 			np->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,
 							    sk->sk_allocation);
 			if (opt->dst1opt && !np->cork.opt->dst1opt)
 				return -ENOBUFS;
 
 			np->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,
 							   sk->sk_allocation);
 			if (opt->hopopt && !np->cork.opt->hopopt)
 				return -ENOBUFS;
 
 			np->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,
 							    sk->sk_allocation);
 			if (opt->srcrt && !np->cork.opt->srcrt)
 				return -ENOBUFS;
 
 			 
 		}
 		dst_hold(&rt->dst);
 		cork->dst = &rt->dst;
 		inet->cork.fl.u.ip6 = *fl6;
 		np->cork.hop_limit = hlimit;
 		np->cork.tclass = tclass;
 		mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?
 		      rt->dst.dev->mtu : dst_mtu(rt->dst.path);
 		if (np->frag_size < mtu) {
 			if (np->frag_size)
 				mtu = np->frag_size;
 		}
 		cork->fragsize = mtu;
 		if (dst_allfrag(rt->dst.path))
 			cork->flags |= IPCORK_ALLFRAG;
 		cork->length = 0;
 		sk->sk_sndmsg_page = NULL;
 		sk->sk_sndmsg_off = 0;
 		exthdrlen = rt->dst.header_len + (opt ? opt->opt_flen : 0) -
 			    rt->rt6i_nfheader_len;
 		length += exthdrlen;
 		transhdrlen += exthdrlen;
 	} else {
 		rt = (struct rt6_info *)cork->dst;
 		fl6 = &inet->cork.fl.u.ip6;
 		opt = np->cork.opt;
 		transhdrlen = 0;
 		exthdrlen = 0;
 		mtu = cork->fragsize;
 	}
 
 	hh_len = LL_RESERVED_SPACE(rt->dst.dev);
 
 	fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +
 			(opt ? opt->opt_nflen : 0);
 	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
 
 	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
 		if (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {
 			ipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);
 			return -EMSGSIZE;
 		}
 	}
 
 	 
 	if (sk->sk_type == SOCK_DGRAM) {
 		err = sock_tx_timestamp(sk, &tx_flags);
 		if (err)
 			goto error;
 	}
 
 	 
 
 	cork->length += length;
 	if (length > mtu) {
 		int proto = sk->sk_protocol;
 		if (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){
 			ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);
 			return -EMSGSIZE;
 		}
 
 		if (proto == IPPROTO_UDP &&
 		    (rt->dst.dev->features & NETIF_F_UFO)) {
  
  			err = ip6_ufo_append_data(sk, getfrag, from, length,
  						  hh_len, fragheaderlen,
						  transhdrlen, mtu, flags);
 						  transhdrlen, mtu, flags, rt);
  			if (err)
  				goto error;
  			return 0;
 		}
 	}
 
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
 		goto alloc_new_skb;
 
 	while (length > 0) {
 		 
 		copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;
 		if (copy < length)
 			copy = maxfraglen - skb->len;
 
 		if (copy <= 0) {
 			char *data;
 			unsigned int datalen;
 			unsigned int fraglen;
 			unsigned int fraggap;
 			unsigned int alloclen;
 			struct sk_buff *skb_prev;
 alloc_new_skb:
 			skb_prev = skb;
 
 			 
 			if (skb_prev)
 				fraggap = skb_prev->len - maxfraglen;
 			else
 				fraggap = 0;
 
 			 
 			datalen = length + fraggap;
 			if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)
 				datalen = maxfraglen - fragheaderlen;
 
 			fraglen = datalen + fragheaderlen;
 			if ((flags & MSG_MORE) &&
 			    !(rt->dst.dev->features&NETIF_F_SG))
 				alloclen = mtu;
 			else
 				alloclen = datalen + fragheaderlen;
 
 			 
 			if (datalen == length + fraggap)
 				alloclen += rt->dst.trailer_len;
 
 			 
 			alloclen += sizeof(struct frag_hdr);
 
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
 						alloclen + hh_len,
 						(flags & MSG_DONTWAIT), &err);
 			} else {
 				skb = NULL;
 				if (atomic_read(&sk->sk_wmem_alloc) <=
 				    2 * sk->sk_sndbuf)
 					skb = sock_wmalloc(sk,
 							   alloclen + hh_len, 1,
 							   sk->sk_allocation);
 				if (unlikely(skb == NULL))
 					err = -ENOBUFS;
 				else {
 					 
 					tx_flags = 0;
 				}
 			}
 			if (skb == NULL)
 				goto error;
 			 
 			skb->ip_summed = csummode;
 			skb->csum = 0;
 			 
 			skb_reserve(skb, hh_len+sizeof(struct frag_hdr));
 
 			if (sk->sk_type == SOCK_DGRAM)
 				skb_shinfo(skb)->tx_flags = tx_flags;
 
 			 
 			data = skb_put(skb, fraglen);
 			skb_set_network_header(skb, exthdrlen);
 			data += fragheaderlen;
 			skb->transport_header = (skb->network_header +
 						 fragheaderlen);
 			if (fraggap) {
 				skb->csum = skb_copy_and_csum_bits(
 					skb_prev, maxfraglen,
 					data + transhdrlen, fraggap, 0);
 				skb_prev->csum = csum_sub(skb_prev->csum,
 							  skb->csum);
 				data += fraggap;
 				pskb_trim_unique(skb_prev, maxfraglen);
 			}
 			copy = datalen - transhdrlen - fraggap;
 			if (copy < 0) {
 				err = -EINVAL;
 				kfree_skb(skb);
 				goto error;
 			} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {
 				err = -EFAULT;
 				kfree_skb(skb);
 				goto error;
 			}
 
 			offset += copy;
 			length -= datalen - fraggap;
 			transhdrlen = 0;
 			exthdrlen = 0;
 			csummode = CHECKSUM_NONE;
 
 			 
 			__skb_queue_tail(&sk->sk_write_queue, skb);
 			continue;
 		}
 
 		if (copy > length)
 			copy = length;
 
 		if (!(rt->dst.dev->features&NETIF_F_SG)) {
 			unsigned int off;
 
 			off = skb->len;
 			if (getfrag(from, skb_put(skb, copy),
 						offset, copy, off, skb) < 0) {
 				__skb_trim(skb, off);
 				err = -EFAULT;
 				goto error;
 			}
 		} else {
 			int i = skb_shinfo(skb)->nr_frags;
 			skb_frag_t *frag = &skb_shinfo(skb)->frags[i-1];
 			struct page *page = sk->sk_sndmsg_page;
 			int off = sk->sk_sndmsg_off;
 			unsigned int left;
 
 			if (page && (left = PAGE_SIZE - off) > 0) {
 				if (copy >= left)
 					copy = left;
 				if (page != frag->page) {
 					if (i == MAX_SKB_FRAGS) {
 						err = -EMSGSIZE;
 						goto error;
 					}
 					get_page(page);
 					skb_fill_page_desc(skb, i, page, sk->sk_sndmsg_off, 0);
 					frag = &skb_shinfo(skb)->frags[i];
 				}
 			} else if(i < MAX_SKB_FRAGS) {
 				if (copy > PAGE_SIZE)
 					copy = PAGE_SIZE;
 				page = alloc_pages(sk->sk_allocation, 0);
 				if (page == NULL) {
 					err = -ENOMEM;
 					goto error;
 				}
 				sk->sk_sndmsg_page = page;
 				sk->sk_sndmsg_off = 0;
 
 				skb_fill_page_desc(skb, i, page, 0, 0);
 				frag = &skb_shinfo(skb)->frags[i];
 			} else {
 				err = -EMSGSIZE;
 				goto error;
 			}
 			if (getfrag(from, page_address(frag->page)+frag->page_offset+frag->size, offset, copy, skb->len, skb) < 0) {
 				err = -EFAULT;
 				goto error;
 			}
 			sk->sk_sndmsg_off += copy;
 			frag->size += copy;
 			skb->len += copy;
 			skb->data_len += copy;
 			skb->truesize += copy;
 			atomic_add(copy, &sk->sk_wmem_alloc);
 		}
 		offset += copy;
 		length -= copy;
 	}
 	return 0;
 error:
 	cork->length -= length;
 	IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
 	return err;
 }","[126, 125]","The IPv6 implementation in the Linux kernel before 3.1 does not generate Fragment Identification values separately for each destination, which makes it easier for remote attackers to cause a denial of service (disrupted networking) by predicting these values and sending crafted packets."
200571," static int snd_hrtimer_stop(struct snd_timer *t)
  {
  	struct snd_hrtimer *stime = t->private_data;
  	atomic_set(&stime->running, 0);
 	hrtimer_try_to_cancel(&stime->hrt);
  	return 0;
  }",[5],"sound/core/hrtimer.c in the Linux kernel before 4.4.1 does not prevent recursive callback access, which allows local users to cause a denial of service (deadlock) via a crafted ioctl call."
208240," OMX_ERRORTYPE SoftRaw::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamAudioPcm:
  {
 
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
             pcmParams->eNumData = OMX_NumericalDataSigned;
             pcmParams->eEndian = OMX_EndianBig;
             pcmParams->bInterleaved = OMX_TRUE;
             pcmParams->nBitPerSample = 16;
             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
             pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
 
             pcmParams->nChannels = mChannelCount;
             pcmParams->nSamplingRate = mSampleRate;
 
  return OMX_ErrorNone;
  }
 
  default:
  return SimpleSoftOMXComponent::internalGetParameter(index, params);
  }
 }","[10, 11, 12, 13]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
200814," static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,
 		    struct idpair *idmap)
 {
 	if (!(rold->live & REG_LIVE_READ))
 		 
 		return true;
 
 	if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)
 		return true;
 
 	if (rold->type == NOT_INIT)
 		 
 		return true;
 	if (rcur->type == NOT_INIT)
 		return false;
 	switch (rold->type) {
 	case SCALAR_VALUE:
 		if (rcur->type == SCALAR_VALUE) {
 			 
  			return range_within(rold, rcur) &&
  			       tnum_in(rold->var_off, rcur->var_off);
  		} else {
 			 
			return rold->umin_value == 0 &&
			       rold->umax_value == U64_MAX &&
			       rold->smin_value == S64_MIN &&
			       rold->smax_value == S64_MAX &&
			       tnum_is_unknown(rold->var_off);
 			return false;
  		}
  	case PTR_TO_MAP_VALUE:
  		 
 		return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&
 		       range_within(rold, rcur) &&
 		       tnum_in(rold->var_off, rcur->var_off);
 	case PTR_TO_MAP_VALUE_OR_NULL:
 		 
 		if (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)
 			return false;
 		if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))
 			return false;
 		 
 		return check_ids(rold->id, rcur->id, idmap);
 	case PTR_TO_PACKET_META:
 	case PTR_TO_PACKET:
 		if (rcur->type != rold->type)
 			return false;
 		 
 		if (rold->range > rcur->range)
 			return false;
 		 
 		if (rold->off != rcur->off)
 			return false;
 		 
 		if (rold->id && !check_ids(rold->id, rcur->id, idmap))
 			return false;
 		 
 		return range_within(rold, rcur) &&
 		       tnum_in(rold->var_off, rcur->var_off);
 	case PTR_TO_CTX:
 	case CONST_PTR_TO_MAP:
 	case PTR_TO_STACK:
 	case PTR_TO_PACKET_END:
 		 
 	default:
 		 
 		return false;
 	}
 
 	 
 	WARN_ON_ONCE(1);
 	return false;
 }","[29, 24, 25, 26, 27, 28]",kernel/bpf/verifier.c in the Linux kernel through 4.14.8 allows local users to cause a denial of service (memory corruption) or possibly have unspecified other impact by leveraging improper use of pointers in place of scalars.
202541," WM_SYMBOL midi *WildMidi_Open(const char *midifile) {
     uint8_t *mididata = NULL;
     uint32_t midisize = 0;
     uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };
     uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };
     midi * ret = NULL;
 
     if (!WM_Initialized) {
         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);
         return (NULL);
     }
     if (midifile == NULL) {
         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, ""(NULL filename)"", 0);
         return (NULL);
     }
 
      if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {
          return (NULL);
      }
     if (midisize < 18) {
         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, ""(too short)"", 0);
         return (NULL);
     }
      if (memcmp(mididata,""HMIMIDIP"", 8) == 0) {
          ret = (void *) _WM_ParseNewHmp(mididata, midisize);
      } else if (memcmp(mididata, ""HMI-MIDISONG061595"", 18) == 0) {
         ret = (void *) _WM_ParseNewHmi(mididata, midisize);
     } else if (memcmp(mididata, mus_hdr, 4) == 0) {
         ret = (void *) _WM_ParseNewMus(mididata, midisize);
     } else if (memcmp(mididata, xmi_hdr, 4) == 0) {
         ret = (void *) _WM_ParseNewXmi(mididata, midisize);
     } else {
         ret = (void *) _WM_ParseNewMidi(mididata, midisize);
     }
     free(mididata);
 
     if (ret) {
         if (add_handle(ret) != 0) {
             WildMidi_Close(ret);
             ret = NULL;
         }
     }
 
     return (ret);
 }","[20, 21, 22, 23]",The WildMidi_Open function in WildMIDI since commit d8a466829c67cacbb1700beded25c448d99514e5 allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.
205672," void FragmentPaintPropertyTreeBuilder::UpdateEffect() {
   DCHECK(properties_);
   const ComputedStyle& style = object_.StyleRef();
 
   if (NeedsPaintPropertyUpdate()) {
     const auto* output_clip =
         object_.IsSVGChild() ? context_.current.clip : nullptr;
     if (NeedsEffect(object_)) {
       base::Optional<IntRect> mask_clip = CSSMaskPainter::MaskBoundingBox(
           object_, context_.current.paint_offset);
       bool has_clip_path =
           style.ClipPath() && fragment_data_.ClipPathBoundingBox();
       bool has_spv1_composited_clip_path =
           has_clip_path && object_.HasLayer() &&
           ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();
       bool has_mask_based_clip_path =
           has_clip_path && !fragment_data_.ClipPathPath();
       base::Optional<IntRect> clip_path_clip;
       if (has_spv1_composited_clip_path || has_mask_based_clip_path) {
         clip_path_clip = fragment_data_.ClipPathBoundingBox();
       }
       if ((mask_clip || clip_path_clip) &&
           RuntimeEnabledFeatures::SlimmingPaintV175Enabled()) {
         IntRect combined_clip = mask_clip ? *mask_clip : *clip_path_clip;
         if (mask_clip && clip_path_clip)
            combined_clip.Intersect(*clip_path_clip);
  
          OnUpdateClip(properties_->UpdateMaskClip(
            context_.current.clip,
             *context_.current.clip,
              ClipPaintPropertyNode::State{context_.current.transform,
                                           FloatRoundedRect(combined_clip)}));
          output_clip = properties_->MaskClip();
       } else {
         OnClearClip(properties_->ClearMaskClip());
       }
 
       EffectPaintPropertyNode::State state;
       state.local_transform_space = context_.current.transform;
       state.output_clip = output_clip;
       state.opacity = style.Opacity();
       if (object_.IsBlendingAllowed()) {
         state.blend_mode = WebCoreCompositeToSkiaComposite(
             kCompositeSourceOver, style.GetBlendMode());
       }
       if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
           RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
         if (CompositingReasonFinder::RequiresCompositingForOpacityAnimation(
                 style)) {
           state.direct_compositing_reasons =
               CompositingReason::kActiveOpacityAnimation;
         }
          state.compositor_element_id = CompositorElementIdFromUniqueObjectId(
              object_.UniqueId(), CompositorElementIdNamespace::kPrimary);
        }
      OnUpdate(
          properties_->UpdateEffect(context_.current_effect, std::move(state)));
       OnUpdate(properties_->UpdateEffect(*context_.current_effect,
                                          std::move(state)));
  
        if (mask_clip || has_spv1_composited_clip_path) {
          EffectPaintPropertyNode::State mask_state;
         mask_state.local_transform_space = context_.current.transform;
         mask_state.output_clip = output_clip;
         mask_state.color_filter = CSSMaskPainter::MaskColorFilter(object_);
         mask_state.blend_mode = SkBlendMode::kDstIn;
         if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
             RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
           mask_state.compositor_element_id =
               CompositorElementIdFromUniqueObjectId(
                    object_.UniqueId(),
                    CompositorElementIdNamespace::kEffectMask);
          }
        OnUpdate(properties_->UpdateMask(properties_->Effect(),
         OnUpdate(properties_->UpdateMask(*properties_->Effect(),
                                           std::move(mask_state)));
        } else {
          OnClear(properties_->ClearMask());
        }
  
        if (has_mask_based_clip_path) {
        const EffectPaintPropertyNode* parent = has_spv1_composited_clip_path
                                                    ? properties_->Mask()
                                                    : properties_->Effect();
         const EffectPaintPropertyNode& parent = has_spv1_composited_clip_path
                                                     ? *properties_->Mask()
                                                     : *properties_->Effect();
          EffectPaintPropertyNode::State clip_path_state;
          clip_path_state.local_transform_space = context_.current.transform;
          clip_path_state.output_clip = output_clip;
         clip_path_state.blend_mode = SkBlendMode::kDstIn;
         if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||
             RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
           clip_path_state.compositor_element_id =
               CompositorElementIdFromUniqueObjectId(
                   object_.UniqueId(),
                   CompositorElementIdNamespace::kEffectClipPath);
         }
         OnUpdate(
             properties_->UpdateClipPath(parent, std::move(clip_path_state)));
       } else {
         OnClear(properties_->ClearClipPath());
       }
     } else {
       OnClear(properties_->ClearEffect());
       OnClear(properties_->ClearMask());
       OnClear(properties_->ClearClipPath());
       OnClearClip(properties_->ClearMaskClip());
     }
   }
 
   if (properties_->Effect()) {
     context_.current_effect = properties_->Effect();
     if (properties_->MaskClip()) {
       context_.current.clip = context_.absolute_position.clip =
           context_.fixed_position.clip = properties_->MaskClip();
     }
   }
 }","[30, 58, 59, 75, 85, 86, 87, 29, 56, 57, 74, 82, 83, 84]",Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
9781,"int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)
{
struct pipe_buffer *bufs;
unsigned int head, tail, mask, n;







mask = pipe->ring_size - 1;
head = pipe->head;
tail = pipe->tail;
n = pipe_occupancy(pipe->head, pipe->tail);
if (nr_slots < n)
return -EBUSY;

bufs = kcalloc(nr_slots, sizeof(*bufs),
GFP_KERNEL_ACCOUNT | __GFP_NOWARN);
if (unlikely(!bufs))
return -ENOMEM;





if (n > 0) {
unsigned int h = head & mask;
unsigned int t = tail & mask;
if (h > t) {
memcpy(bufs, pipe->bufs + t,
n * sizeof(struct pipe_buffer));
} else {
unsigned int tsize = pipe->ring_size - t;
if (h > 0)
memcpy(bufs + tsize, pipe->bufs,
h * sizeof(struct pipe_buffer));
memcpy(bufs, pipe->bufs + t,
tsize * sizeof(struct pipe_buffer));
}
}

head = n;
tail = 0;

kfree(pipe->bufs);
pipe->bufs = bufs;
pipe->ring_size = nr_slots;
if (pipe->max_usage > nr_slots)
pipe->max_usage = nr_slots;
pipe->tail = tail;
pipe->head = head;


wake_up_interruptible(&pipe->wr_wait);
return 0;
}","[12, 13, 14, 15, 16, 17, 28, 56]",A race condition was found in the Linux kernel's watch queue due to a missing lock in pipe_resize_ring(). The specific flaw exists within the handling of pipe buffers. The issue results from the lack of proper locking when performing operations on an object. This flaw allows a local user to crash the system or escalate their privileges on the system.
206235,"   void Initialize(bool can_respond_to_crypto_handshake = true) {
     clock_.AdvanceTime(quic::QuicTime::Delta::FromMilliseconds(1000));
     runner_ = new net::test::TestTaskRunner(&clock_);
     net::QuicChromiumAlarmFactory* alarm_factory =
         new net::QuicChromiumAlarmFactory(runner_.get(), &clock_);
     quic_transport_factory_ = std::make_unique<P2PQuicTransportFactoryImpl>(
         &clock_, std::unique_ptr<net::QuicChromiumAlarmFactory>(alarm_factory));
 
     auto client_packet_transport =
         std::make_unique<FakePacketTransport>(alarm_factory, &clock_);
     auto server_packet_transport =
         std::make_unique<FakePacketTransport>(alarm_factory, &clock_);
     client_packet_transport->ConnectPeerTransport(
         server_packet_transport.get());
     server_packet_transport->ConnectPeerTransport(
         client_packet_transport.get());
     rtc::scoped_refptr<rtc::RTCCertificate> client_cert =
         CreateTestCertificate();
 
     auto client_quic_transport_delegate =
         std::make_unique<MockP2PQuicTransportDelegate>();
     std::vector<rtc::scoped_refptr<rtc::RTCCertificate>> client_certificates;
      client_certificates.push_back(client_cert);
      P2PQuicTransportConfig client_config(client_quic_transport_delegate.get(),
                                           client_packet_transport.get(),
                                         client_certificates);
                                          client_certificates, kWriteBufferSize);
      client_config.is_server = false;
      client_config.can_respond_to_crypto_handshake =
          can_respond_to_crypto_handshake;
     P2PQuicTransportImpl* client_quic_transport_ptr =
         static_cast<P2PQuicTransportImpl*>(
             quic_transport_factory_
                 ->CreateQuicTransport(std::move(client_config))
                 .release());
     std::unique_ptr<P2PQuicTransportImpl> client_quic_transport =
         std::unique_ptr<P2PQuicTransportImpl>(client_quic_transport_ptr);
     client_peer_ = std::make_unique<QuicPeerForTest>(
         std::move(client_packet_transport),
         std::move(client_quic_transport_delegate),
         std::move(client_quic_transport), client_cert);
 
     auto server_quic_transport_delegate =
         std::make_unique<MockP2PQuicTransportDelegate>();
 
     rtc::scoped_refptr<rtc::RTCCertificate> server_cert =
         CreateTestCertificate();
     std::vector<rtc::scoped_refptr<rtc::RTCCertificate>> server_certificates;
      server_certificates.push_back(server_cert);
      P2PQuicTransportConfig server_config(server_quic_transport_delegate.get(),
                                           server_packet_transport.get(),
                                         server_certificates);
                                          server_certificates, kWriteBufferSize);
      server_config.is_server = true;
      server_config.can_respond_to_crypto_handshake =
          can_respond_to_crypto_handshake;
     P2PQuicTransportImpl* server_quic_transport_ptr =
         static_cast<P2PQuicTransportImpl*>(
             quic_transport_factory_
                 ->CreateQuicTransport(std::move(server_config))
                 .release());
     std::unique_ptr<P2PQuicTransportImpl> server_quic_transport =
         std::unique_ptr<P2PQuicTransportImpl>(server_quic_transport_ptr);
     server_peer_ = std::make_unique<QuicPeerForTest>(
         std::move(server_packet_transport),
         std::move(server_quic_transport_delegate),
         std::move(server_quic_transport), server_cert);
   }","[27, 53, 26, 52]","The TreeScope::adoptIfNeeded function in WebKit/Source/core/dom/TreeScope.cpp in the DOM implementation in Blink, as used in Google Chrome before 50.0.2661.102, does not prevent script execution during node-adoption operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site."
200849," static int usbhid_parse(struct hid_device *hid)
 {
 	struct usb_interface *intf = to_usb_interface(hid->dev.parent);
 	struct usb_host_interface *interface = intf->cur_altsetting;
 	struct usb_device *dev = interface_to_usbdev (intf);
 	struct hid_descriptor *hdesc;
 	u32 quirks = 0;
  	unsigned int rsize = 0;
  	char *rdesc;
  	int ret, n;
 	int num_descriptors;
 	size_t offset = offsetof(struct hid_descriptor, desc);
  
  	quirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),
  			le16_to_cpu(dev->descriptor.idProduct));
 
 	if (quirks & HID_QUIRK_IGNORE)
 		return -ENODEV;
 
 	 
 	if (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
 		if (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||
 			interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)
 				quirks |= HID_QUIRK_NOGET;
 	}
 
 	if (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&
 	    (!interface->desc.bNumEndpoints ||
 	     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {
 		dbg_hid(""class descriptor not present\n"");
  		return -ENODEV;
  	}
  
 	if (hdesc->bLength < sizeof(struct hid_descriptor)) {
 		dbg_hid(""hid descriptor is too short\n"");
 		return -EINVAL;
 	}
 
  	hid->version = le16_to_cpu(hdesc->bcdHID);
  	hid->country = hdesc->bCountryCode;
  
	for (n = 0; n < hdesc->bNumDescriptors; n++)
 	num_descriptors = min_t(int, hdesc->bNumDescriptors,
 	       (hdesc->bLength - offset) / sizeof(struct hid_class_descriptor));
 
 	for (n = 0; n < num_descriptors; n++)
  		if (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)
  			rsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);
  
 	if (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {
 		dbg_hid(""weird size of report descriptor (%u)\n"", rsize);
 		return -EINVAL;
 	}
 
 	rdesc = kmalloc(rsize, GFP_KERNEL);
 	if (!rdesc)
 		return -ENOMEM;
 
 	hid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);
 
 	ret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,
 			HID_DT_REPORT, rdesc, rsize);
 	if (ret < 0) {
 		dbg_hid(""reading report descriptor failed\n"");
 		kfree(rdesc);
 		goto err;
 	}
 
 	ret = hid_parse_report(hid, rdesc, rsize);
 	kfree(rdesc);
 	if (ret) {
 		dbg_hid(""parsing report descriptor failed\n"");
 		goto err;
 	}
 
 	hid->quirks |= quirks;
 
 	return 0;
 err:
 	return ret;
 }","[11, 12, 34, 35, 36, 37, 38, 43, 44, 45, 46, 42]",The usbhid_parse function in drivers/hid/usbhid/hid-core.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device.
206135,"  png_get_mmx_rowbytes_threshold (png_structp png_ptr)
  {
       
    return (png_ptr? 0L: 0L);
     PNG_UNUSED(png_ptr)
     return 0L;
  }","[5, 6, 4]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
199691," static void unix_copy_addr(struct msghdr *msg, struct sock *sk)
  {
  	struct unix_sock *u = unix_sk(sk);
  
	msg->msg_namelen = 0;
  	if (u->addr) {
  		msg->msg_namelen = u->addr->len;
  		memcpy(msg->msg_name, u->addr->name, u->addr->len);
 	}
 }",[5],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
8143,"SubstituteFile(
const char *substitutions,
const char *filename)
{
size_t cbBuffer = 1024;
static char szBuffer[1024], szCopy[1024];
char *szResult = NULL;
list_item_t *substPtr = NULL;
FILE *fp, *sp;

fp = fopen(filename, ""rt"");
if (fp != NULL) {





sp = fopen(substitutions, ""rt"");
if (sp != NULL) {
while (fgets(szBuffer, cbBuffer, sp) != NULL) {
unsigned char *ks, *ke, *vs, *ve;
ks = (unsigned char*)szBuffer;
while (ks && *ks && isspace(*ks)) ++ks;
ke = ks;
while (ke && *ke && !isspace(*ke)) ++ke;
vs = ke;
while (vs && *vs && isspace(*vs)) ++vs;
ve = vs;
while (ve && *ve && !(*ve == '\r' || *ve == '\n')) ++ve;
*ke = 0, *ve = 0;
list_insert(&substPtr, (char*)ks, (char*)vs);
}
fclose(sp);
}


#ifndef NDEBUG
{
int n = 0;
list_item_t *p = NULL;
for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {
fprintf(stderr, ""% 3d '%s' => '%s'\n"", n, p->key, p->value);
}
}
#endif





while (fgets(szBuffer, cbBuffer, fp) != NULL) {
list_item_t *p = NULL;
for (p = substPtr; p != NULL; p = p->nextPtr) {
char *m = strstr(szBuffer, p->key);
if (m) {
char *cp, *op, *sp;
cp = szCopy;
op = szBuffer;
while (op != m) *cp++ = *op++;
sp = p->value;
while (sp && *sp) *cp++ = *sp++;
op += strlen(p->key);
while (*op) *cp++ = *op++;
*cp = 0;
memcpy(szBuffer, szCopy, sizeof(szCopy));
}
}
printf(szBuffer);
}

list_free(&substPtr);
}
fclose(fp);
return 0;
}",[68],"** DISPUTED ** In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding."
205827," V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context,
                                                Dispatcher* dispatcher)
     : ObjectBackedNativeHandler(context),
       context_(context),
       dispatcher_(dispatcher) {
   RouteFunction(""GetAvailability"",
                 base::Bind(&V8ContextNativeHandler::GetAvailability,
                            base::Unretained(this)));
   RouteFunction(""GetModuleSystem"",
                  base::Bind(&V8ContextNativeHandler::GetModuleSystem,
                             base::Unretained(this)));
    RouteFunction(
      ""RunWithNativesEnabledModuleSystem"",
      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabledModuleSystem,
       ""RunWithNativesEnabled"",
       base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,
                   base::Unretained(this)));
  }","[15, 16, 13, 14]","Cross-site scripting (XSS) vulnerability in the V8ContextNativeHandler::GetModuleSystem function in extensions/renderer/v8_context_native_handler.cc in Google Chrome before 44.0.2403.89 allows remote attackers to inject arbitrary web script or HTML by leveraging the lack of a certain V8 context restriction, aka a Blink *Universal XSS (UXSS).*"
201194," gss_get_mic (minor_status,
 	     context_handle,
 	     qop_req,
 	     message_buffer,
 	     msg_token)
 
 OM_uint32 *		minor_status;
 gss_ctx_id_t		context_handle;
 gss_qop_t		qop_req;
 gss_buffer_t		message_buffer;
 gss_buffer_t		msg_token;
 
 {
     OM_uint32		status;
     gss_union_ctx_id_t	ctx;
     gss_mechanism	mech;
 
     status = val_get_mic_args(minor_status, context_handle,
 			      qop_req, message_buffer, msg_token);
     if (status != GSS_S_COMPLETE)
 	return (status);
 
      
  
      ctx = (gss_union_ctx_id_t) context_handle;
     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
 	return (GSS_S_NO_CONTEXT);
      mech = gssint_get_mechanism (ctx->mech_type);
  
      if (mech) {
 	if (mech->gss_get_mic) {
 	    status = mech->gss_get_mic(
 				    minor_status,
 				    ctx->internal_ctx_id,
 				    qop_req,
 				    message_buffer,
 				    msg_token);
 	    if (status != GSS_S_COMPLETE)
 		map_error(minor_status, mech);
 	} else
 	    status = GSS_S_UNAVAILABLE;
 
 	return(status);
     }
 
     return (GSS_S_BAD_MECH);
 }","[26, 27]",Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
202006,"  php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
  {
	size_t maxlen = 3 * len;
 	size_t maxlen = 3 * len + 8  ;
  	struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);
  
  	state->end = str + len;
 	state->ptr = str;
 	state->flags = flags;
 	state->maxlen = maxlen;
 	TSRMLS_SET_CTX(state->ts);
 
 	if (!parse_scheme(state)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
 		efree(state);
 		return NULL;
 	}
 
 	if (!parse_hier(state)) {
 		efree(state);
 		return NULL;
 	}
 
 	if (!parse_query(state)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
 		efree(state);
 		return NULL;
 	}
 
 	if (!parse_fragment(state)) {
 		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
 		efree(state);
 		return NULL;
 	}
 
 	return (php_http_url_t *) state;
 }","[4, 3]",Buffer overflow in the HTTP URL parsing functions in pecl_http before 3.0.1 might allow remote attackers to execute arbitrary code via non-printable characters in a URL.
198559," ReadUserLogState::SetState( const ReadUserLog::FileState &state )
 {
 	const ReadUserLogFileState::FileState *istate;
 	if ( !convertState(state, istate) ) {
 		return false;
 	}
 
 	if ( strcmp( istate->m_signature, FileStateSignature ) ) {
 		m_init_error = true;
 		return false;
 	}
 	if ( istate->m_version != FILESTATE_VERSION ) {
 		m_init_error = true;
 		return false;
 	}
 
 	m_base_path = istate->m_base_path;
 
 	m_max_rotations = istate->m_max_rotations;
 	Rotation( istate->m_rotation, false, true );
 
 	m_log_type = istate->m_log_type;
 	m_uniq_id  = istate->m_uniq_id;
 	m_sequence = istate->m_sequence;
 
 	m_stat_buf.st_ino   = istate->m_inode;
 	m_stat_buf.st_ctime = istate->m_ctime;
 	m_stat_buf.st_size  = istate->m_size.asint;
 	m_stat_valid = true;
 
 	m_offset = istate->m_offset.asint;
 	m_event_num = istate->m_event_num.asint;
 
 	m_log_position = istate->m_log_position.asint;
 	m_log_record   = istate->m_log_record.asint;
 
 	m_update_time  = istate->m_update_time;
 
 	m_initialized  = true;
  
         MyString        str;
         GetStateString( str, ""Restored reader state"" );
       dprintf( D_FULLDEBUG, str.Value() );
        dprintf( D_FULLDEBUG, ""%s"", str.Value() );
  
         return true;
  }","[44, 43]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
205556,"  void AppResult::Open(int event_flags) {
    RecordHistogram(APP_SEARCH_RESULT);
    const extensions::Extension* extension =
      extensions::ExtensionSystem::Get(profile_)->extension_service()
          ->GetInstalledExtension(app_id_);
       extensions::ExtensionRegistry::Get(profile_)->GetInstalledExtension(
           app_id_);
    if (!extension)
      return;
  
   if (!extensions::util::IsAppLaunchable(app_id_, profile_))
     return;
 
   if (RunExtensionEnableFlow())
     return;
 
   if (display_type() != DISPLAY_RECOMMENDATION) {
     extensions::RecordAppListSearchLaunch(extension);
     content::RecordAction(
         base::UserMetricsAction(""AppList_ClickOnAppFromSearch""));
   }
 
   controller_->ActivateApp(
       profile_,
       extension,
       AppListControllerDelegate::LAUNCH_FROM_APP_LIST_SEARCH,
       event_flags);
 }","[6, 7, 4, 5]",Multiple unspecified vulnerabilities in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
208512," void usage_exit() {
 void usage_exit(void) {
    fprintf(stderr,
            ""Usage: %s <codec> <width> <height> <infile> <outfile> ""
                ""<keyframe-interval> [<error-resilient>]\nSee comments in ""
  ""simple_encoder.c for more information.\n"",
           exec_name);
 
    exit(EXIT_FAILURE);
  }",[2],"libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
198748," static void _out_result(conn_t out, nad_t nad) {
     int attr;
     jid_t from, to;
     char *rkey;
     int rkeylen;
 
     attr = nad_find_attr(nad, 0, -1, ""from"", NULL);
     if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
         log_debug(ZONE, ""missing or invalid from on db result packet"");
         nad_free(nad);
         return;
     }
 
     attr = nad_find_attr(nad, 0, -1, ""to"", NULL);
     if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
         log_debug(ZONE, ""missing or invalid to on db result packet"");
         jid_free(from);
         nad_free(nad);
         return;
     }
 
     rkey = s2s_route_key(NULL, to->domain, from->domain);
      rkeylen = strlen(rkey);
  
       
    if(nad_find_attr(nad, 0, -1, ""type"", ""valid"") >= 0) {
     if(nad_find_attr(nad, 0, -1, ""type"", ""valid"") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {
          log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s"", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? "", TLS negotiated"" : """", out->s->compressed ? "", ZLIB compression enabled"" : """");
  
          xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);     
 
         log_debug(ZONE, ""%s valid, flushing queue"", rkey);
 
          
         out_flush_route_queue(out->s2s, rkey, rkeylen);
 
         free(rkey);
 
         jid_free(from);
         jid_free(to);
 
         nad_free(nad);
 
         return;
     }
 
      
     log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] outgoing route '%s' is now invalid"", out->fd->fd, out->ip, out->port, rkey);
 
      
     log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] closing connection"", out->fd->fd, out->ip, out->port);
 
      
     sx_error(out->s, stream_err_INVALID_ID, ""dialback negotiation failed"");
 
      
     sx_close(out->s);
 
      
     out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);
 
     free(rkey);
 
     jid_free(from);
     jid_free(to);
 
     nad_free(nad);
 }","[27, 26]","s2s/out.c in jabberd2 2.2.16 and earlier does not verify that a request was made for an XMPP Server Dialback response, which allows remote XMPP servers to spoof domains via a (1) Verify Response or (2) Authorization Response."
204939,"   void HandleCompleteLogin(const base::ListValue* args) {
 #if defined(OS_CHROMEOS)
     oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
     oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
         oauth2_delegate_.get(), profile_->GetRequestContext()));
     oauth2_token_fetcher_->StartExchangeFromCookies();
 #elif !defined(OS_ANDROID)
     const base::DictionaryValue* dict = NULL;
     string16 email;
     string16 password;
     if (!args->GetDictionary(0, &dict) || !dict ||
         !dict->GetString(""email"", &email) ||
         !dict->GetString(""password"", &password)) {
       NOTREACHED();
       return;
     }
 
     new OneClickSigninSyncStarter(
         profile_, NULL, ""0""  ,
          UTF16ToASCII(email), UTF16ToASCII(password),
          OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
          true  ,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
         OneClickSigninSyncStarter::NO_CONFIRMATION,
         SyncPromoUI::SOURCE_UNKNOWN);
      web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
  #endif
    }","[24, 25, 23]","Google Chrome before 28.0.1500.71 does not properly determine the circumstances in which a renderer process can be considered a trusted process for sign-in and subsequent sync operations, which makes it easier for remote attackers to conduct phishing attacks via a crafted web site."
199621," static int futex_wait(u32 __user *uaddr, int fshared,
 		      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)
 {
 	struct hrtimer_sleeper timeout, *to = NULL;
 	struct restart_block *restart;
 	struct futex_hash_bucket *hb;
 	struct futex_q q;
 	int ret;
 
 	if (!bitset)
 		return -EINVAL;
 
 	q.pi_state = NULL;
 	q.bitset = bitset;
 	q.rt_waiter = NULL;
 	q.requeue_pi_key = NULL;
 
 	if (abs_time) {
 		to = &timeout;
 
 		hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :
 				      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 		hrtimer_init_sleeper(to, current);
 		hrtimer_set_expires_range_ns(&to->timer, *abs_time,
 					     current->timer_slack_ns);
  	}
  
  retry:
 	 
  	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
  	if (ret)
  		goto out;
 
 	 
 	futex_wait_queue_me(hb, &q, to);
  
  	 
  	ret = 0;
 	 
  	if (!unqueue_me(&q))
		goto out_put_key;
 		goto out;
  	ret = -ETIMEDOUT;
  	if (to && !to->task)
		goto out_put_key;
 		goto out;
  
  	 
	if (!signal_pending(current)) {
		put_futex_key(fshared, &q.key);
 	if (!signal_pending(current))
  		goto retry;
	}
  
  	ret = -ERESTARTSYS;
  	if (!abs_time)
		goto out_put_key;
 		goto out;
  
  	restart = &current_thread_info()->restart_block;
  	restart->fn = futex_wait_restart;
 	restart->futex.uaddr = (u32 *)uaddr;
 	restart->futex.val = val;
 	restart->futex.time = abs_time->tv64;
 	restart->futex.bitset = bitset;
 	restart->futex.flags = FLAGS_HAS_TIMEOUT;
 
 	if (fshared)
 		restart->futex.flags |= FLAGS_SHARED;
 	if (clockrt)
 		restart->futex.flags |= FLAGS_CLOCKRT;
  
  	ret = -ERESTART_RESTARTBLOCK;
  
out_put_key:
	put_futex_key(fshared, &q.key);
  out:
  	if (to) {
  		hrtimer_cancel(&to->timer);
 		destroy_hrtimer_on_stack(&to->timer);
 	}
 	return ret;
 }","[39, 42, 46, 51, 58, 41, 45, 49, 50, 53, 57, 75, 76]","The futex_wait function in kernel/futex.c in the Linux kernel before 2.6.37 does not properly maintain a certain reference count during requeue operations, which allows local users to cause a denial of service (use-after-free and system crash) or possibly gain privileges via a crafted application that triggers a zero count."
199186," int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,
 	int offset, int len, int odd, struct sk_buff *skb),
 	void *from, int length, int transhdrlen,
 	int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,
 	struct rt6_info *rt, unsigned int flags, int dontfrag)
 {
 	struct inet_sock *inet = inet_sk(sk);
  	struct ipv6_pinfo *np = inet6_sk(sk);
  	struct inet_cork *cork;
  	struct sk_buff *skb, *skb_prev = NULL;
	unsigned int maxfraglen, fragheaderlen;
 	unsigned int maxfraglen, fragheaderlen, mtu;
  	int exthdrlen;
  	int dst_exthdrlen;
  	int hh_len;
	int mtu;
  	int copy;
  	int err;
  	int offset = 0;
 	__u8 tx_flags = 0;
 
 	if (flags&MSG_PROBE)
 		return 0;
 	cork = &inet->cork.base;
 	if (skb_queue_empty(&sk->sk_write_queue)) {
 		 
 		if (opt) {
 			if (WARN_ON(np->cork.opt))
 				return -EINVAL;
 
 			np->cork.opt = kzalloc(opt->tot_len, sk->sk_allocation);
 			if (unlikely(np->cork.opt == NULL))
 				return -ENOBUFS;
 
 			np->cork.opt->tot_len = opt->tot_len;
 			np->cork.opt->opt_flen = opt->opt_flen;
 			np->cork.opt->opt_nflen = opt->opt_nflen;
 
 			np->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt,
 							    sk->sk_allocation);
 			if (opt->dst0opt && !np->cork.opt->dst0opt)
 				return -ENOBUFS;
 
 			np->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt,
 							    sk->sk_allocation);
 			if (opt->dst1opt && !np->cork.opt->dst1opt)
 				return -ENOBUFS;
 
 			np->cork.opt->hopopt = ip6_opt_dup(opt->hopopt,
 							   sk->sk_allocation);
 			if (opt->hopopt && !np->cork.opt->hopopt)
 				return -ENOBUFS;
 
 			np->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt,
 							    sk->sk_allocation);
 			if (opt->srcrt && !np->cork.opt->srcrt)
 				return -ENOBUFS;
 
 			 
 		}
 		dst_hold(&rt->dst);
 		cork->dst = &rt->dst;
 		inet->cork.fl.u.ip6 = *fl6;
 		np->cork.hop_limit = hlimit;
 		np->cork.tclass = tclass;
 		if (rt->dst.flags & DST_XFRM_TUNNEL)
 			mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?
 			      rt->dst.dev->mtu : dst_mtu(&rt->dst);
 		else
 			mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ?
 			      rt->dst.dev->mtu : dst_mtu(rt->dst.path);
 		if (np->frag_size < mtu) {
 			if (np->frag_size)
 				mtu = np->frag_size;
 		}
 		cork->fragsize = mtu;
 		if (dst_allfrag(rt->dst.path))
 			cork->flags |= IPCORK_ALLFRAG;
 		cork->length = 0;
 		exthdrlen = (opt ? opt->opt_flen : 0);
 		length += exthdrlen;
 		transhdrlen += exthdrlen;
 		dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;
 	} else {
 		rt = (struct rt6_info *)cork->dst;
 		fl6 = &inet->cork.fl.u.ip6;
 		opt = np->cork.opt;
 		transhdrlen = 0;
 		exthdrlen = 0;
 		dst_exthdrlen = 0;
 		mtu = cork->fragsize;
 	}
 
 	hh_len = LL_RESERVED_SPACE(rt->dst.dev);
 
 	fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +
 			(opt ? opt->opt_nflen : 0);
 	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr);
 
 	if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) {
 		if (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) {
 			ipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen);
 			return -EMSGSIZE;
 		}
 	}
 
 	 
 	if (sk->sk_type == SOCK_DGRAM)
 		sock_tx_timestamp(sk, &tx_flags);
 
 	 
 
 	cork->length += length;
 	if (length > mtu) {
 		int proto = sk->sk_protocol;
 		if (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){
 			ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);
 			return -EMSGSIZE;
 		}
 
 		if (proto == IPPROTO_UDP &&
 		    (rt->dst.dev->features & NETIF_F_UFO)) {
 
 			err = ip6_ufo_append_data(sk, getfrag, from, length,
 						  hh_len, fragheaderlen,
 						  transhdrlen, mtu, flags, rt);
 			if (err)
 				goto error;
 			return 0;
 		}
 	}
 
 	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)
 		goto alloc_new_skb;
 
 	while (length > 0) {
 		 
 		copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;
 		if (copy < length)
 			copy = maxfraglen - skb->len;
 
 		if (copy <= 0) {
 			char *data;
 			unsigned int datalen;
 			unsigned int fraglen;
 			unsigned int fraggap;
 			unsigned int alloclen;
 alloc_new_skb:
 			 
 			if (skb)
 				fraggap = skb->len - maxfraglen;
 			else
 				fraggap = 0;
  			 
  			if (skb == NULL || skb_prev == NULL)
  				ip6_append_data_mtu(&mtu, &maxfraglen,
						    fragheaderlen, skb, rt);
 						    fragheaderlen, skb, rt,
 						    np->pmtudisc ==
 						    IPV6_PMTUDISC_PROBE);
  
  			skb_prev = skb;
  
 			 
 			datalen = length + fraggap;
 
 			if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)
 				datalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;
 			if ((flags & MSG_MORE) &&
 			    !(rt->dst.dev->features&NETIF_F_SG))
 				alloclen = mtu;
 			else
 				alloclen = datalen + fragheaderlen;
 
 			alloclen += dst_exthdrlen;
 
 			if (datalen != length + fraggap) {
 				 
 				datalen += rt->dst.trailer_len;
 			}
 
 			alloclen += rt->dst.trailer_len;
 			fraglen = datalen + fragheaderlen;
 
 			 
 			alloclen += sizeof(struct frag_hdr);
 
 			if (transhdrlen) {
 				skb = sock_alloc_send_skb(sk,
 						alloclen + hh_len,
 						(flags & MSG_DONTWAIT), &err);
 			} else {
 				skb = NULL;
 				if (atomic_read(&sk->sk_wmem_alloc) <=
 				    2 * sk->sk_sndbuf)
 					skb = sock_wmalloc(sk,
 							   alloclen + hh_len, 1,
 							   sk->sk_allocation);
 				if (unlikely(skb == NULL))
 					err = -ENOBUFS;
 				else {
 					 
 					tx_flags = 0;
 				}
 			}
 			if (skb == NULL)
 				goto error;
 			 
 			skb->ip_summed = CHECKSUM_NONE;
 			skb->csum = 0;
 			 
 			skb_reserve(skb, hh_len + sizeof(struct frag_hdr) +
 				    dst_exthdrlen);
 
 			if (sk->sk_type == SOCK_DGRAM)
 				skb_shinfo(skb)->tx_flags = tx_flags;
 
 			 
 			data = skb_put(skb, fraglen);
 			skb_set_network_header(skb, exthdrlen);
 			data += fragheaderlen;
 			skb->transport_header = (skb->network_header +
 						 fragheaderlen);
 			if (fraggap) {
 				skb->csum = skb_copy_and_csum_bits(
 					skb_prev, maxfraglen,
 					data + transhdrlen, fraggap, 0);
 				skb_prev->csum = csum_sub(skb_prev->csum,
 							  skb->csum);
 				data += fraggap;
 				pskb_trim_unique(skb_prev, maxfraglen);
 			}
 			copy = datalen - transhdrlen - fraggap;
 
 			if (copy < 0) {
 				err = -EINVAL;
 				kfree_skb(skb);
 				goto error;
 			} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {
 				err = -EFAULT;
 				kfree_skb(skb);
 				goto error;
 			}
 
 			offset += copy;
 			length -= datalen - fraggap;
 			transhdrlen = 0;
 			exthdrlen = 0;
 			dst_exthdrlen = 0;
 
 			 
 			__skb_queue_tail(&sk->sk_write_queue, skb);
 			continue;
 		}
 
 		if (copy > length)
 			copy = length;
 
 		if (!(rt->dst.dev->features&NETIF_F_SG)) {
 			unsigned int off;
 
 			off = skb->len;
 			if (getfrag(from, skb_put(skb, copy),
 						offset, copy, off, skb) < 0) {
 				__skb_trim(skb, off);
 				err = -EFAULT;
 				goto error;
 			}
 		} else {
 			int i = skb_shinfo(skb)->nr_frags;
 			struct page_frag *pfrag = sk_page_frag(sk);
 
 			err = -ENOMEM;
 			if (!sk_page_frag_refill(sk, pfrag))
 				goto error;
 
 			if (!skb_can_coalesce(skb, i, pfrag->page,
 					      pfrag->offset)) {
 				err = -EMSGSIZE;
 				if (i == MAX_SKB_FRAGS)
 					goto error;
 
 				__skb_fill_page_desc(skb, i, pfrag->page,
 						     pfrag->offset, 0);
 				skb_shinfo(skb)->nr_frags = ++i;
 				get_page(pfrag->page);
 			}
 			copy = min_t(int, copy, pfrag->size - pfrag->offset);
 			if (getfrag(from,
 				    page_address(pfrag->page) + pfrag->offset,
 				    offset, copy, skb->len, skb) < 0)
 				goto error_efault;
 
 			pfrag->offset += copy;
 			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
 			skb->len += copy;
 			skb->data_len += copy;
 			skb->truesize += copy;
 			atomic_add(copy, &sk->sk_wmem_alloc);
 		}
 		offset += copy;
 		length -= copy;
 	}
 
 	return 0;
 
 error_efault:
 	err = -EFAULT;
 error:
 	cork->length -= length;
 	IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
 	return err;
 }","[12, 158, 159, 160, 11, 16, 157]","The ip6_append_data_mtu function in net/ipv6/ip6_output.c in the IPv6 implementation in the Linux kernel through 3.10.3 does not properly maintain information about whether the IPV6_MTU setsockopt option had been specified, which allows local users to cause a denial of service (BUG and system crash) via a crafted application that uses the UDP_CORK option in a setsockopt system call."
6343,"static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)
{
struct bfq_data *bfqd = container_of(timer, struct bfq_data,
idle_slice_timer);
struct bfq_queue *bfqq = bfqd->in_service_queue;









if (bfqq)
bfq_idle_slice_timer_body(bfqq);

return HRTIMER_NORESTART;
}",[16],An issue was discovered in the Linux kernel before 5.6.5. There is a use-after-free in block/bfq-iosched.c related to bfq_idle_slice_timer_body.
204283,"  void ShellWindowFrameView::ButtonPressed(views::Button* sender,
                                           const views::Event& event) {
   DCHECK(!is_frameless_);
    if (sender == close_button_)
      frame_->Close();
  }",[3],"Cross-site scripting (XSS) vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to inject arbitrary web script or HTML via vectors involving frames, aka *Universal XSS (UXSS).*"
202441," int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,
     const char *name, size_t namelen)
  {
  	char *copy;
  
 	if (name != NULL && namelen == 0)
 		namelen = strlen(name);
  	 
 	if (name && memchr(name, '\0', namelen))
 		return 0;
 
 	if (mode == SET_HOST && id->hosts) {
 		string_stack_free(id->hosts);
 		id->hosts = NULL;
 	}
 	if (name == NULL || namelen == 0)
 		return 1;
 	copy = strndup(name, namelen);
 	if (copy == NULL)
 		return 0;
 
 	if (id->hosts == NULL &&
 	    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {
 		free(copy);
 		return 0;
 	}
 
 	if (!sk_OPENSSL_STRING_push(id->hosts, copy)) {
 		free(copy);
 		if (sk_OPENSSL_STRING_num(id->hosts) == 0) {
 			sk_OPENSSL_STRING_free(id->hosts);
 			id->hosts = NULL;
 		}
 		return 0;
 	}
 
 	return 1;
 }","[6, 7]","The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not."
200070," static int ion_handle_put(struct ion_handle *handle)
 static int ion_handle_put_nolock(struct ion_handle *handle)
 {
 	int ret;
 
 	ret = kref_put(&handle->ref, ion_handle_destroy);
 
 	return ret;
 }
 
 int ion_handle_put(struct ion_handle *handle)
  {
  	struct ion_client *client = handle->client;
  	int ret;
  
  	mutex_lock(&client->lock);
	ret = kref_put(&handle->ref, ion_handle_destroy);
 	ret = ion_handle_put_nolock(handle);
  	mutex_unlock(&client->lock);
  
  	return ret;
 }","[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 18, 17]",Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.
199914," static int em_sysenter(struct x86_emulate_ctxt *ctxt)
 {
 	const struct x86_emulate_ops *ops = ctxt->ops;
 	struct desc_struct cs, ss;
 	u64 msr_data;
 	u16 cs_sel, ss_sel;
 	u64 efer = 0;
 
 	ops->get_msr(ctxt, MSR_EFER, &efer);
 	 
 	if (ctxt->mode == X86EMUL_MODE_REAL)
 		return emulate_gp(ctxt, 0);
 
 	 
	if ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)
 	if ((ctxt->mode != X86EMUL_MODE_PROT64) && (efer & EFER_LMA)
  	    && !vendor_intel(ctxt))
  		return emulate_ud(ctxt);
  
 	 
 	if (ctxt->mode == X86EMUL_MODE_PROT64)
 		return X86EMUL_UNHANDLEABLE;
 
  	setup_syscalls_segments(ctxt, &cs, &ss);
  
  	ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
	switch (ctxt->mode) {
	case X86EMUL_MODE_PROT32:
		if ((msr_data & 0xfffc) == 0x0)
			return emulate_gp(ctxt, 0);
		break;
	case X86EMUL_MODE_PROT64:
		if (msr_data == 0x0)
			return emulate_gp(ctxt, 0);
		break;
	default:
		break;
	}
 	if ((msr_data & 0xfffc) == 0x0)
 		return emulate_gp(ctxt, 0);
  
  	ctxt->eflags &= ~(EFLG_VM | EFLG_IF);
	cs_sel = (u16)msr_data;
	cs_sel &= ~SELECTOR_RPL_MASK;
 	cs_sel = (u16)msr_data & ~SELECTOR_RPL_MASK;
  	ss_sel = cs_sel + 8;
	ss_sel &= ~SELECTOR_RPL_MASK;
	if (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {
 	if (efer & EFER_LMA) {
  		cs.d = 0;
  		cs.l = 1;
  	}
 
 	ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);
  	ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);
  
  	ops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);
	ctxt->_eip = msr_data;
 	ctxt->_eip = (efer & EFER_LMA) ? msr_data : (u32)msr_data;
  
  	ops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);
	*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;
 	*reg_write(ctxt, VCPU_REGS_RSP) = (efer & EFER_LMA) ? msr_data :
 							      (u32)msr_data;
  
  	return X86EMUL_CONTINUE;
  }","[16, 39, 40, 45, 49, 59, 63, 64, 15, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 43, 44, 47, 48, 58, 62]","The em_sysenter function in arch/x86/kvm/emulate.c in the Linux kernel before 3.18.5, when the guest OS lacks SYSENTER MSR initialization, allows guest OS users to gain guest OS privileges or cause a denial of service (guest OS crash) by triggering use of a 16-bit code segment for emulation of a SYSENTER instruction."
205367," void CorePageLoadMetricsObserver::RecordTimingHistograms(
     const page_load_metrics::PageLoadTiming& timing,
     const page_load_metrics::PageLoadExtraInfo& info) {
   if (info.started_in_foreground && info.first_background_time) {
     const base::TimeDelta first_background_time =
         info.first_background_time.value();
 
     if (!info.time_to_commit) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramBackgroundBeforeCommit,
                           first_background_time);
     } else if (!timing.first_paint ||
                timing.first_paint > first_background_time) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramBackgroundBeforePaint,
                           first_background_time);
     }
     if (timing.parse_start && first_background_time >= timing.parse_start &&
         (!timing.parse_stop || timing.parse_stop > first_background_time)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramBackgroundDuringParse,
                           first_background_time);
     }
   }
 
   if (failed_provisional_load_info_.error != net::OK) {
     DCHECK(failed_provisional_load_info_.interval);
 
     if (WasStartedInForegroundOptionalEventInForeground(
             failed_provisional_load_info_.interval, info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFailedProvisionalLoad,
                           failed_provisional_load_info_.interval.value());
     }
   }
 
   if (!info.time_to_commit || timing.IsEmpty())
     return;
 
   const base::TimeDelta time_to_commit = info.time_to_commit.value();
   if (WasStartedInForegroundOptionalEventInForeground(info.time_to_commit,
                                                       info)) {
     PAGE_LOAD_HISTOGRAM(internal::kHistogramCommit, time_to_commit);
   } else {
     PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramCommit, time_to_commit);
   }
   if (timing.dom_content_loaded_event_start) {
     if (WasStartedInForegroundOptionalEventInForeground(
             timing.dom_content_loaded_event_start, info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramDomContentLoaded,
                           timing.dom_content_loaded_event_start.value());
       PAGE_LOAD_HISTOGRAM(internal::kHistogramDomLoadingToDomContentLoaded,
                           timing.dom_content_loaded_event_start.value() -
                               timing.dom_loading.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramDomContentLoaded,
                           timing.dom_content_loaded_event_start.value());
     }
   }
   if (timing.load_event_start) {
     if (WasStartedInForegroundOptionalEventInForeground(timing.load_event_start,
                                                         info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramLoad,
                           timing.load_event_start.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramLoad,
                           timing.load_event_start.value());
     }
   }
   if (timing.first_layout) {
     if (WasStartedInForegroundOptionalEventInForeground(timing.first_layout,
                                                         info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstLayout,
                           timing.first_layout.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramFirstLayout,
                           timing.first_layout.value());
     }
   }
   if (timing.first_paint) {
     if (WasStartedInForegroundOptionalEventInForeground(timing.first_paint,
                                                         info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstPaint,
                           timing.first_paint.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramFirstPaint,
                           timing.first_paint.value());
     }
 
     if (!info.started_in_foreground && info.first_foreground_time &&
         timing.first_paint > info.first_foreground_time.value() &&
         (!info.first_background_time ||
          timing.first_paint < info.first_background_time.value())) {
       PAGE_LOAD_HISTOGRAM(
           internal::kHistogramForegroundToFirstPaint,
           timing.first_paint.value() - info.first_foreground_time.value());
     }
   }
   if (timing.first_text_paint) {
     if (WasStartedInForegroundOptionalEventInForeground(timing.first_text_paint,
                                                         info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstTextPaint,
                           timing.first_text_paint.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramFirstTextPaint,
                           timing.first_text_paint.value());
     }
   }
   if (timing.first_image_paint) {
     if (WasStartedInForegroundOptionalEventInForeground(
             timing.first_image_paint, info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstImagePaint,
                           timing.first_image_paint.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramFirstImagePaint,
                           timing.first_image_paint.value());
     }
   }
   if (timing.first_contentful_paint) {
     if (WasStartedInForegroundOptionalEventInForeground(
              timing.first_contentful_paint, info)) {
        PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstContentfulPaint,
                            timing.first_contentful_paint.value());
      if (base::TimeTicks::IsHighResolution()) {
        PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstContentfulPaintHigh,
                            timing.first_contentful_paint.value());
      } else {
        PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstContentfulPaintLow,
                            timing.first_contentful_paint.value());
      }
        PAGE_LOAD_HISTOGRAM(
            internal::kHistogramParseStartToFirstContentfulPaint,
            timing.first_contentful_paint.value() - timing.parse_start.value());
       PAGE_LOAD_HISTOGRAM(
           internal::kHistogramDomLoadingToFirstContentfulPaint,
           timing.first_contentful_paint.value() - timing.dom_loading.value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramFirstContentfulPaint,
                           timing.first_contentful_paint.value());
     }
   }
   if (timing.parse_start) {
     if (WasParseInForeground(timing.parse_start, timing.parse_stop, info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramParseBlockedOnScriptLoad,
                           timing.parse_blocked_on_script_load_duration.value());
       PAGE_LOAD_HISTOGRAM(
           internal::kHistogramParseBlockedOnScriptLoadDocumentWrite,
           timing.parse_blocked_on_script_load_from_document_write_duration
               .value());
     } else {
       PAGE_LOAD_HISTOGRAM(
           internal::kBackgroundHistogramParseBlockedOnScriptLoad,
           timing.parse_blocked_on_script_load_duration.value());
       PAGE_LOAD_HISTOGRAM(
           internal::kBackgroundHistogramParseBlockedOnScriptLoadDocumentWrite,
           timing.parse_blocked_on_script_load_from_document_write_duration
               .value());
     }
   }
 
   if (timing.parse_stop) {
     base::TimeDelta parse_duration =
         timing.parse_stop.value() - timing.parse_start.value();
     if (WasStartedInForegroundOptionalEventInForeground(timing.parse_stop,
                                                         info)) {
       PAGE_LOAD_HISTOGRAM(internal::kHistogramParseDuration, parse_duration);
       PAGE_LOAD_HISTOGRAM(
           internal::kHistogramParseBlockedOnScriptLoadParseComplete,
           timing.parse_blocked_on_script_load_duration.value());
       PAGE_LOAD_HISTOGRAM(
           internal::
               kHistogramParseBlockedOnScriptLoadDocumentWriteParseComplete,
           timing.parse_blocked_on_script_load_from_document_write_duration
               .value());
     } else {
       PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramParseDuration,
                           parse_duration);
       PAGE_LOAD_HISTOGRAM(
           internal::kBackgroundHistogramParseBlockedOnScriptLoadParseComplete,
           timing.parse_blocked_on_script_load_duration.value());
       PAGE_LOAD_HISTOGRAM(
           internal::
               kBackgroundHistogramParseBlockedOnScriptLoadDocumentWriteParseComplete,
           timing.parse_blocked_on_script_load_from_document_write_duration
               .value());
     }
   }
 
   if (info.started_in_foreground) {
     if (info.first_background_time)
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstBackground,
                           info.first_background_time.value());
   } else {
     if (info.first_foreground_time)
       PAGE_LOAD_HISTOGRAM(internal::kHistogramFirstForeground,
                           info.first_foreground_time.value());
   }
 }","[120, 121, 122, 123, 124, 125, 126]","Multiple unspecified vulnerabilities in Google Chrome before 37.0.2062.94 allow attackers to cause a denial of service or possibly have other impact via unknown vectors, related to the load_truetype_glyph function in truetype/ttgload.c in FreeType and other functions in other components."
197755,"  bool asn1_read_BOOLEAN(struct asn1_data *data, bool *v)
  {
         uint8_t tmp = 0;
       asn1_start_tag(data, ASN1_BOOLEAN);
       asn1_read_uint8(data, &tmp);
        if (!asn1_start_tag(data, ASN1_BOOLEAN)) return false;
        *v = false;
        if (!asn1_read_uint8(data, &tmp)) return false;
         if (tmp == 0xFF) {
                 *v = true;
       } else {
               *v = false;
         }
       asn1_end_tag(data);
       return !data->has_error;
        return asn1_end_tag(data);
  }","[6, 7, 8, 16, 4, 5, 11, 12, 14, 15]","The LDAP server in the AD domain controller in Samba 4.x before 4.1.22 does not check return values to ensure successful ASN.1 memory allocation, which allows remote attackers to cause a denial of service (memory consumption and daemon crash) via crafted packets."
204119," void AutoFillManager::LogMetricsAboutSubmittedForm(
     const FormData& form,
     const FormStructure* submitted_form) {
   FormStructure* cached_submitted_form;
   if (!FindCachedForm(form, &cached_submitted_form)) {
     NOTREACHED();
     return;
   }
 
   std::map<std::string, const AutoFillField*> cached_fields;
   for (size_t i = 0; i < cached_submitted_form->field_count(); ++i) {
     const AutoFillField* field = cached_submitted_form->field(i);
      cached_fields[field->FieldSignature()] = field;
    }
  
   std::string experiment_id = cached_submitted_form->server_experiment_id();
    for (size_t i = 0; i < submitted_form->field_count(); ++i) {
      const AutoFillField* field = submitted_form->field(i);
      FieldTypeSet field_types;
     personal_data_->GetPossibleFieldTypes(field->value(), &field_types);
     DCHECK(!field_types.empty());
 
     if (field->form_control_type() == ASCIIToUTF16(""select-one"")) {
       continue;
      }
  
    metric_logger_->Log(AutoFillMetrics::FIELD_SUBMITTED);
     metric_logger_->Log(AutoFillMetrics::FIELD_SUBMITTED, experiment_id);
      if (field_types.find(EMPTY_TYPE) == field_types.end() &&
          field_types.find(UNKNOWN_TYPE) == field_types.end()) {
        if (field->is_autofilled()) {
        metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILLED);
         metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILLED, experiment_id);
        } else {
        metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILL_FAILED);
         metric_logger_->Log(AutoFillMetrics::FIELD_AUTOFILL_FAILED,
                             experiment_id);
  
          AutoFillFieldType heuristic_type = UNKNOWN_TYPE;
          AutoFillFieldType server_type = NO_SERVER_DATA;
         std::map<std::string, const AutoFillField*>::const_iterator
             cached_field = cached_fields.find(field->FieldSignature());
         if (cached_field != cached_fields.end()) {
           heuristic_type = cached_field->second->heuristic_type();
            server_type = cached_field->second->server_type();
          }
  
        if (heuristic_type == UNKNOWN_TYPE)
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_UNKNOWN);
        else if (field_types.count(heuristic_type))
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MATCH);
        else
          metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MISMATCH);
        if (server_type == NO_SERVER_DATA)
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_UNKNOWN);
        else if (field_types.count(server_type))
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MATCH);
        else
          metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MISMATCH);
         if (heuristic_type == UNKNOWN_TYPE) {
           metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_UNKNOWN,
                               experiment_id);
         } else if (field_types.count(heuristic_type)) {
           metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MATCH,
                               experiment_id);
         } else {
           metric_logger_->Log(AutoFillMetrics::FIELD_HEURISTIC_TYPE_MISMATCH,
                               experiment_id);
         }
 
         if (server_type == NO_SERVER_DATA) {
           metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_UNKNOWN,
                               experiment_id);
         } else if (field_types.count(server_type)) {
           metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MATCH,
                               experiment_id);
         } else {
           metric_logger_->Log(AutoFillMetrics::FIELD_SERVER_TYPE_MISMATCH,
                               experiment_id);
         }
        }
  
     }
   }
 }","[16, 28, 33, 36, 37, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 27, 32, 35, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59]",Use-after-free vulnerability in the frame-loader implementation in Google Chrome before 10.0.648.204 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
199803," static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
 			      struct sctp_association *assoc,
 			      sctp_socket_type_t type)
 {
 	struct sctp_sock *oldsp = sctp_sk(oldsk);
 	struct sctp_sock *newsp = sctp_sk(newsk);
 	struct sctp_bind_bucket *pp;  
 	struct sctp_endpoint *newep = newsp->ep;
  	struct sk_buff *skb, *tmp;
  	struct sctp_ulpevent *event;
  	struct sctp_bind_hashbucket *head;
	struct list_head tmplist;
  
  	 
  	newsk->sk_sndbuf = oldsk->sk_sndbuf;
  	newsk->sk_rcvbuf = oldsk->sk_rcvbuf;
  	 
	if (oldsp->do_auto_asconf) {
		memcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));
		inet_sk_copy_descendant(newsk, oldsk);
		memcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));
	} else
		inet_sk_copy_descendant(newsk, oldsk);
 	sctp_copy_descendant(newsk, oldsk);
  
  	 
 	newsp->ep = newep;
 	newsp->hmac = NULL;
 
 	 
 	head = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),
 						 inet_sk(oldsk)->inet_num)];
 	local_bh_disable();
 	spin_lock(&head->lock);
 	pp = sctp_sk(oldsk)->bind_hash;
 	sk_add_bind_node(newsk, &pp->owner);
 	sctp_sk(newsk)->bind_hash = pp;
 	inet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;
 	spin_unlock(&head->lock);
 	local_bh_enable();
 
 	 
 	sctp_bind_addr_dup(&newsp->ep->base.bind_addr,
 				&oldsp->ep->base.bind_addr, GFP_KERNEL);
 
 	 
 	sctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {
 		event = sctp_skb2event(skb);
 		if (event->asoc == assoc) {
 			__skb_unlink(skb, &oldsk->sk_receive_queue);
 			__skb_queue_tail(&newsk->sk_receive_queue, skb);
 			sctp_skb_set_owner_r_frag(skb, newsk);
 		}
 	}
 
 	 
 	skb_queue_head_init(&newsp->pd_lobby);
 	atomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);
 
 	if (atomic_read(&sctp_sk(oldsk)->pd_mode)) {
 		struct sk_buff_head *queue;
 
 		 
 		if (assoc->ulpq.pd_mode) {
 			queue = &newsp->pd_lobby;
 		} else
 			queue = &newsk->sk_receive_queue;
 
 		 
 		sctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {
 			event = sctp_skb2event(skb);
 			if (event->asoc == assoc) {
 				__skb_unlink(skb, &oldsp->pd_lobby);
 				__skb_queue_tail(queue, skb);
 				sctp_skb_set_owner_r_frag(skb, newsk);
 			}
 		}
 
 		 
 		if (assoc->ulpq.pd_mode)
 			sctp_clear_pd(oldsk, NULL);
 
 	}
 
 	sctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)
 		sctp_skb_set_owner_r_frag(skb, newsk);
 
 	sctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)
 		sctp_skb_set_owner_r_frag(skb, newsk);
 
 	 
 	newsp->type = type;
 
 	 
 	lock_sock_nested(newsk, SINGLE_DEPTH_NESTING);
 	sctp_assoc_migrate(assoc, newsk);
 
 	 
 	if (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))
 		newsk->sk_shutdown |= RCV_SHUTDOWN;
 
 	newsk->sk_state = SCTP_SS_ESTABLISHED;
 	release_sock(newsk);
 }","[24, 12, 18, 19, 20, 21, 22, 23]","Race condition in net/sctp/socket.c in the Linux kernel before 4.1.2 allows local users to cause a denial of service (list corruption and panic) via a rapid series of system calls related to sockets, as demonstrated by setsockopt calls."
9061,"static int io_register_personality(struct io_ring_ctx *ctx)
{
const struct cred *creds;
u32 id;
int ret;

creds = get_current_cred();

ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,
XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);
if (!ret)
return id;
put_cred(creds);
return ret;
}","[11, 12, 13, 14]","A flaw was found in the Linux kernel&#8217;s io_uring implementation. This flaw allows an attacker with a local account to corrupt system memory, crash the system or escalate privileges."
208098," void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  uint8_t* p = p_data->p_data;
 
    tBTM_LE_PENC_KEYS le_key;
  
    SMP_TRACE_DEBUG(""%s"", __func__);
 
   if (p_cb->rcvd_cmd_len < 11) {   
     android_errorWriteLog(0x534e4554, ""111937027"");
     SMP_TRACE_ERROR(""%s: Invalid command length: %d, should be at least 11"",
                     __func__, p_cb->rcvd_cmd_len);
     return;
   }
 
    smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);
  
    STREAM_TO_UINT16(le_key.ediv, p);
   STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);
 
   
   memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);
   le_key.sec_level = p_cb->sec_level;
   le_key.key_size = p_cb->loc_enc_size;
 
  if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&
  (p_cb->loc_auth_req & SMP_AUTH_BOND))
     btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,
  (tBTM_LE_KEY_VALUE*)&le_key, true);
 
   smp_key_distribution(p_cb, NULL);
 }","[7, 8, 9, 10, 11, 12, 13, 14]","In smp_proc_master_id of smp_act.cc, there is a possible out of bounds read due to a missing bounds check. This could lead to remote information disclosure over Bluetooth with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111937027"
201450,"  static int get_default_root(pool *p, int allow_symlinks, const char **root) {
    config_rec *c = NULL;
   const char *dir = NULL;
   int res;
 
   c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
   while (c != NULL) {
     pr_signals_handle();
 
      
     if (c->argc < 2) {
       dir = c->argv[0];
       break;
     }
 
     res = pr_expr_eval_group_and(((char **) c->argv)+1);
     if (res) {
       dir = c->argv[0];
       break;
     }
 
     c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
   }
 
   if (dir != NULL) {
     const char *new_dir;
 
      
     new_dir = path_subst_uservar(p, &dir);
     if (new_dir != NULL) {
       dir = new_dir;
     }
 
     if (strncmp(dir, ""/"", 2) == 0) {
       dir = NULL;
 
     } else {
       char *realdir;
       int xerrno = 0;
  
        if (allow_symlinks == FALSE) {
          char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
          size_t pathlen;
  
           
 
         path = pstrdup(p, dir);
         if (*path != '/') {
           if (*path == '~') {
             if (pr_fs_interpolate(dir, target_path,
                 sizeof(target_path)-1) < 0) {
               return -1;
             }
 
             path = target_path;
           }
         }
 
          
         pathlen = strlen(path);
         if (pathlen > 1 &&
             path[pathlen-1] == '/') {
            path[pathlen-1] = '\0';
          }
  
        pr_fs_clear_cache2(path);
        res = pr_fsio_lstat(path, &st);
         res = is_symlink_path(p, path, pathlen);
          if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }
           if (errno == EPERM) {
             pr_log_pri(PR_LOG_WARNING, ""error: DefaultRoot %s is a symlink ""
               ""(denied by AllowChrootSymlinks config)"", path);
           }
  
        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
            errno = EPERM;
            return -1;
          }
       }
 
        
 
       pr_fs_clear_cache2(dir);
 
       PRIVS_USER
       realdir = dir_realpath(p, dir);
       xerrno = errno;
       PRIVS_RELINQUISH
 
       if (realdir) {
         dir = realdir;
 
       } else {
          
         char interp_dir[PR_TUNABLE_PATH_MAX + 1];
 
         memset(interp_dir, '\0', sizeof(interp_dir));
         (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); 
 
         pr_log_pri(PR_LOG_NOTICE,
           ""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
           dir, interp_dir, strerror(xerrno));
 
         errno = xerrno;
       }
     }
   }
 
   *root = dir;
   return 0;
 }","[69, 77, 78, 79, 80, 43, 67, 68, 71, 72, 73, 74, 75, 76, 82, 83, 84, 85]","ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."
200376," static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
 static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
  {
  	const char* loc_name        	= NULL;
  	int         loc_name_len    	= 0;
 
 	const char* disp_loc_name       = NULL;
 	int         disp_loc_name_len   = 0;
 	int         free_loc_name       = 0;
 
 	UChar*      disp_name      	= NULL;
 	int32_t     disp_name_len  	= 0;
 
 	char*       mod_loc_name        = NULL;
 
 	int32_t     buflen          	= 512;
 	UErrorCode  status          	= U_ZERO_ERROR;
 
 	char*       utf8value		= NULL;
 	int         utf8value_len   	= 0;
 
   	char*       msg             	= NULL;
 	int         grOffset    	= 0;
 
  	intl_error_reset( NULL TSRMLS_CC );
  
  	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"",
		&loc_name, &loc_name_len , 
 		&loc_name, &loc_name_len ,
  		&disp_loc_name ,&disp_loc_name_len ) == FAILURE)
  	{
  		spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name );
 		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
 		efree(msg);
 		RETURN_FALSE;
 	}
 
     if(loc_name_len > ULOC_FULLNAME_CAPACITY) {
          
 		spprintf(&msg , 0, ""locale_get_display_%s : name too long"", tag_name );
 		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
 		efree(msg);
 		RETURN_FALSE;
     }
 
 	if(loc_name_len == 0) {
 		loc_name = intl_locale_get_default(TSRMLS_C);
 	}
 
 	if( strcmp(tag_name, DISP_NAME) != 0 ){
 		 
 		grOffset = findOffset( LOC_GRANDFATHERED , loc_name );
 		if( grOffset >= 0 ){
 			if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
 				mod_loc_name = getPreferredTag( loc_name );
 			} else {
 				 
 				RETURN_FALSE;
 			}
 		}
 	}  
 
  	if( mod_loc_name==NULL ){
  		mod_loc_name = estrdup( loc_name );
  	}
 
  	 
  	if( !disp_loc_name){
  		disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));
 		free_loc_name = 1;
 	}
 
      
     do{
         disp_name = erealloc( disp_name , buflen * sizeof(UChar)  );
         disp_name_len = buflen;
 
 		if( strcmp(tag_name , LOC_LANG_TAG)==0 ){
 			buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
 		} else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){
 			buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
 		} else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){
 			buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
 		} else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){
 			buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
 		} else if( strcmp(tag_name , DISP_NAME)==0 ){
 			buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status);
 		}
 
 		 
 		if( U_FAILURE( status ) )
 		{
 			if( status == U_BUFFER_OVERFLOW_ERROR )
 			{
 				status = U_ZERO_ERROR;
 				continue;
 			}
 
 			spprintf(&msg, 0, ""locale_get_display_%s : unable to get locale %s"", tag_name , tag_name );
 			intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
 			efree(msg);
 			if( disp_name){
 				efree( disp_name );
 			}
 			if( mod_loc_name){
 				efree( mod_loc_name );
 			}
 			if (free_loc_name) {
 				efree((void *)disp_loc_name);
 				disp_loc_name = NULL;
 			}
 			RETURN_FALSE;
 		}
 	} while( buflen > disp_name_len );
 
 	if( mod_loc_name){
 		efree( mod_loc_name );
 	}
 	if (free_loc_name) {
 		efree((void *)disp_loc_name);
 		disp_loc_name = NULL;
 	}
 	 
 	intl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status );
 	efree( disp_name );
 	if( U_FAILURE( status ) )
 	{
 		spprintf(&msg, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", tag_name , tag_name );
 		intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
 		efree(msg);
 		RETURN_FALSE;
 	}
 
 	RETVAL_STRINGL( utf8value, utf8value_len , FALSE);
 
 }","[2, 29, 66, 28]","The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
7936,"void Compute(OpKernelContext *ctx) override {
const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t,
*b_values_t, *b_shape_t;
OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t));
OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t));


OP_REQUIRES(
ctx,
TensorShapeUtils::IsMatrix(a_indices_t->shape()) &&
TensorShapeUtils::IsMatrix(b_indices_t->shape()),
errors::InvalidArgument(""Inputs a_indices and b_indices should be ""
""matrices but received shapes: "",
a_indices_t->shape().DebugString(), "", "",
b_indices_t->shape().DebugString()));
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_values_t->shape()) &&
TensorShapeUtils::IsVector(b_values_t->shape()),
errors::InvalidArgument(
""Inputs a_values and b_values should be vectors ""
""but received shapes: "",
a_values_t->shape().DebugString(), "" and "",
b_values_t->shape().DebugString()));

const int64 a_nnz = a_indices_t->dim_size(0);
const int64 b_nnz = b_indices_t->dim_size(0);
const auto a_values = a_values_t->vec<T>();
const auto b_values = b_values_t->vec<T>();

OP_REQUIRES(
ctx, a_values.size() == a_nnz && b_values.size() == b_nnz,
errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz,
"" non-empty input values, got "",
a_values.size(), "" and "", b_values.size()));

OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(a_shape_t->shape()) &&
TensorShapeUtils::IsVector(b_shape_t->shape()),
errors::InvalidArgument(
""Input shapes should be a vector but received shapes "",
a_shape_t->shape().DebugString(), "" and "",
b_shape_t->shape().DebugString()));
OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t),
errors::InvalidArgument(
""Operands do not have the same ranks; got shapes: "",
a_shape_t->SummarizeValue(10), "" and "",
b_shape_t->SummarizeValue(10)));
const auto a_shape = a_shape_t->flat<int64>();
const auto b_shape = b_shape_t->flat<int64>();
for (int i = 0; i < a_shape_t->NumElements(); ++i) {
OP_REQUIRES(ctx, a_shape(i) == b_shape(i),
errors::InvalidArgument(""Operands' shapes do not match: got "",
a_shape(i), "" and "", b_shape(i),
"" for dimension "", i));
}

OP_REQUIRES(
ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1),
errors::InvalidArgument(
""Indices' dimensions do not match: got "", a_indices_t->dim_size(1),
"" and "", b_indices_t->dim_size(1), "" for the second dimension.""));
const int num_dims = a_indices_t->dim_size(1);
const auto a_indices_mat = a_indices_t->matrix<int64>();
const auto b_indices_mat = b_indices_t->matrix<int64>();
std::vector<T> a_augmented_values, b_augmented_values;
std::vector<std::pair<bool, int64>> entries_to_copy;
UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat,
b_values, b_nnz, num_dims, &a_augmented_values,
&b_augmented_values, &entries_to_copy);


const int64 sum_nnz = a_augmented_values.size();
Tensor *output_indices_t, *output_values_t;
OP_REQUIRES_OK(ctx,
ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}),
&output_indices_t));
OP_REQUIRES_OK(
ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t));
auto output_indices_mat = output_indices_t->matrix<int64>();

for (int64 i = 0; i < sum_nnz; ++i) {
const bool from_a = entries_to_copy[i].first;
const int64 idx = entries_to_copy[i].second;
output_indices_mat.chip<0>(i) =
from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx);
}








using UnalignedTensorMap =
Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>,
Eigen::Unaligned>;
auto a_augmented_values_t =
UnalignedTensorMap(a_augmented_values.data(), sum_nnz);
auto b_augmented_values_t =
UnalignedTensorMap(b_augmented_values.data(), sum_nnz);
output_values_t->flat<T>().device(ctx->eigen_device<Device>()) =
a_augmented_values_t.binaryExpr(b_augmented_values_t,
typename Functor::func());
}","[31, 47, 61, 62, 63, 64, 65, 66]","TensorFlow is an end-to-end open source platform for machine learning. Incomplete validation in `SparseAdd` results in allowing attackers to exploit undefined behavior (dereferencing null pointers) as well as write outside of bounds of heap allocated data. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/sparse_sparse_binary_op_shared.cc) has a large set of validation for the two sparse tensor inputs (6 tensors in total), but does not validate that the tensors are not empty or that the second dimension of `*_indices` matches the size of corresponding `*_shape`. This allows attackers to send tensor triples that represent invalid sparse tensors to abuse code assumptions that are not protected by validation. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."
7399,"rndr_quote(struct buf *ob, const struct buf *text, void *opaque)
{
if (!text || !text->size)
return 0;

BUFPUTSL(ob, ""<q>"");
bufput(ob, text->data, text->size);
BUFPUTSL(ob, ""</q>"");

return 1;
}","[6, 7]","Redcarpet is a Ruby library for Markdown processing. In Redcarpet before version 3.5.1, there is an injection vulnerability which can enable a cross-site scripting attack. In affected versions no HTML escaping was being performed when processing quotes. This applies even when the `:escape_html` option was being used. This is fixed in version 3.5.1 by the referenced commit."
201857,"  static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)
  {
	ulonglong tmp;
 	jas_ulonglong tmp;
  	if (jas_iccgetuint(in, 2, &tmp))
  		return -1;
  	*val = tmp;
 	return 0;
 }","[4, 3]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
207343," xsltChoose(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
 	   xmlNodePtr inst, xsltStylePreCompPtr comp ATTRIBUTE_UNUSED)
 {
     xmlNodePtr cur;
 
     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))
 	return;
 
      
     cur = inst->children;
     if (cur == NULL) {
 	xsltTransformError(ctxt, NULL, inst,
 	    ""xsl:choose: The instruction has no content.\n"");
 	return;
     }
 
 #ifdef XSLT_REFACTORED
      
 #else
     if ((! IS_XSLT_ELEM(cur)) || (! IS_XSLT_NAME(cur, ""when""))) {
 	xsltTransformError(ctxt, NULL, inst,
 	     ""xsl:choose: xsl:when expected first\n"");
 	return;
     }
 #endif
  
      {
  	int testRes = 0, res = 0;
	xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;
	xmlDocPtr oldXPContextDoc = xpctxt->doc;
	int oldXPProximityPosition = xpctxt->proximityPosition;
	int oldXPContextSize = xpctxt->contextSize;
	xmlNsPtr *oldXPNamespaces = xpctxt->namespaces;
	int oldXPNsNr = xpctxt->nsNr;
  
  #ifdef XSLT_REFACTORED
  	xsltStyleItemWhenPtr wcomp = NULL;
 #else
 	xsltStylePreCompPtr wcomp = NULL;
 #endif
 
 	 
 	while (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, ""when"")) {
 	    wcomp = cur->psvi;
 
 	    if ((wcomp == NULL) || (wcomp->test == NULL) ||
 		(wcomp->comp == NULL))
 	    {
 		xsltTransformError(ctxt, NULL, cur,
 		    ""Internal error in xsltChoose(): ""
 		    ""The XSLT 'when' instruction was not compiled.\n"");
 		goto error;
 	    }
 
 
 #ifdef WITH_DEBUGGER
 	    if (xslDebugStatus != XSLT_DEBUG_NONE) {
 		 
 		xslHandleDebugger(cur, contextNode, NULL, ctxt);
 	    }
 #endif
 #ifdef WITH_XSLT_DEBUG_PROCESS
 	    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
  		""xsltChoose: test %s\n"", wcomp->test));
  #endif
  
	    xpctxt->node = contextNode;
	    xpctxt->doc = oldXPContextDoc;
	    xpctxt->proximityPosition = oldXPProximityPosition;
	    xpctxt->contextSize = oldXPContextSize;
#ifdef XSLT_REFACTORED
	    if (wcomp->inScopeNs != NULL) {
		xpctxt->namespaces = wcomp->inScopeNs->list;
		xpctxt->nsNr = wcomp->inScopeNs->xpathNumber;
	    } else {
		xpctxt->namespaces = NULL;
		xpctxt->nsNr = 0;
	    }
#else
	    xpctxt->namespaces = wcomp->nsList;
	    xpctxt->nsNr = wcomp->nsNr;
#endif
  #ifdef XSLT_FAST_IF
	    res = xmlXPathCompiledEvalToBoolean(wcomp->comp, xpctxt);
 	    res = xsltPreCompEvalToBoolean(ctxt, contextNode, wcomp);
  
  	    if (res == -1) {
  		ctxt->state = XSLT_STATE_STOPPED;
 		goto error;
 	    }
 	    testRes = (res == 1) ? 1 : 0;
  
  #else  
  
	    res = xmlXPathCompiledEval(wcomp->comp, xpctxt);
 	    res = xsltPreCompEval(ctxt, cotextNode, wcomp);
  
  	    if (res != NULL) {
  		if (res->type != XPATH_BOOLEAN)
 		    res = xmlXPathConvertBoolean(res);
 		if (res->type == XPATH_BOOLEAN)
 		    testRes = res->boolval;
 		else {
 #ifdef WITH_XSLT_DEBUG_PROCESS
 		    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
 			""xsltChoose: test didn't evaluate to a boolean\n""));
 #endif
 		    goto error;
 		}
 		xmlXPathFreeObject(res);
 		res = NULL;
 	    } else {
 		ctxt->state = XSLT_STATE_STOPPED;
 		goto error;
 	    }
 
 #endif  
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
 	    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
 		""xsltChoose: test evaluate to %d\n"", testRes));
 #endif
 	    if (testRes)
 		goto test_is_true;
 
 	    cur = cur->next;
 	}
 
 	 
 	if (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, ""otherwise"")) {
 
 #ifdef WITH_DEBUGGER
 	    if (xslDebugStatus != XSLT_DEBUG_NONE)
 		xslHandleDebugger(cur, contextNode, NULL, ctxt);
 #endif
 
 #ifdef WITH_XSLT_DEBUG_PROCESS
 	    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,
 		""evaluating xsl:otherwise\n""));
  #endif
  	    goto test_is_true;
  	}
	xpctxt->node = contextNode;
	xpctxt->doc = oldXPContextDoc;
	xpctxt->proximityPosition = oldXPProximityPosition;
	xpctxt->contextSize = oldXPContextSize;
	xpctxt->namespaces = oldXPNamespaces;
	xpctxt->nsNr = oldXPNsNr;
  	goto exit;
  
  test_is_true:
  
	xpctxt->node = contextNode;
	xpctxt->doc = oldXPContextDoc;
	xpctxt->proximityPosition = oldXPProximityPosition;
	xpctxt->contextSize = oldXPContextSize;
	xpctxt->namespaces = oldXPNamespaces;
	xpctxt->nsNr = oldXPNsNr;
  	goto process_sequence;
      }
  
 process_sequence:
 
      
     xsltApplySequenceConstructor(ctxt, ctxt->node, cur->children,
 	NULL);
 
 exit:
 error:
     return;
 }","[85, 96, 29, 30, 31, 32, 33, 34, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 84, 95, 143, 144, 145, 146, 147, 148, 153, 154, 155, 156, 157, 158]","numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles namespace nodes, which allows remote attackers to cause a denial of service (out-of-bounds heap memory access) or possibly have unspecified other impact via a crafted document."
197863,"  z2grestore(i_ctx_t *i_ctx_p)
  {
    if (!restore_page_device(igs, gs_gstate_saved(igs)))
     int code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));
     if (code < 0) return code;
 
     if (code == 0)
          return gs_grestore(igs);
      return push_callout(i_ctx_p, ""%grestorepagedevice"");
  }","[4, 5, 6, 7, 3]","An issue was discovered in Artifex Ghostscript before 9.25. Incorrect ""restoration of privilege"" checking when running out of stack during exception handling could be used by attackers able to supply crafted PostScript to execute code using the ""pipe"" instruction. This is due to an incomplete fix for CVE-2018-16509."
206384," void DataReductionProxyConfig::InitializeOnIOThread(
     scoped_refptr<network::SharedURLLoaderFactory> url_loader_factory,
     WarmupURLFetcher::CreateCustomProxyConfigCallback
         create_custom_proxy_config_callback,
     NetworkPropertiesManager* manager,
     const std::string& user_agent) {
   DCHECK(thread_checker_.CalledOnValidThread());
    network_properties_manager_ = manager;
    network_properties_manager_->ResetWarmupURLFetchMetrics();
  
  secure_proxy_checker_.reset(new SecureProxyChecker(url_loader_factory));
  warmup_url_fetcher_.reset(new WarmupURLFetcher(
      create_custom_proxy_config_callback,
      base::BindRepeating(
          &DataReductionProxyConfig::HandleWarmupFetcherResponse,
          base::Unretained(this)),
      base::BindRepeating(&DataReductionProxyConfig::GetHttpRttEstimate,
                          base::Unretained(this)),
      ui_task_runner_, user_agent));
   if (!params::IsIncludedInHoldbackFieldTrial()) {
     secure_proxy_checker_.reset(new SecureProxyChecker(url_loader_factory));
     warmup_url_fetcher_.reset(new WarmupURLFetcher(
         create_custom_proxy_config_callback,
         base::BindRepeating(
             &DataReductionProxyConfig::HandleWarmupFetcherResponse,
             base::Unretained(this)),
         base::BindRepeating(&DataReductionProxyConfig::GetHttpRttEstimate,
                             base::Unretained(this)),
         ui_task_runner_, user_agent));
   }
  
    AddDefaultProxyBypassRules();
  
   network_connection_tracker_->AddNetworkConnectionObserver(this);
   network_connection_tracker_->GetConnectionType(
       &connection_type_,
       base::BindOnce(&DataReductionProxyConfig::OnConnectionChanged,
                      weak_factory_.GetWeakPtr()));
 }","[20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 11, 12, 13, 14, 15, 16, 17, 18, 19]","A use after free in PDFium in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
206865," bool ImageResource::IsAccessAllowed(
      const SecurityOrigin* security_origin,
      ImageResourceInfo::DoesCurrentFrameHaveSingleSecurityOrigin
          does_current_frame_has_single_security_origin) const {
  if (GetCORSStatus() == CORSStatus::kServiceWorkerOpaque)
    return false;
   if (GetResponse().WasFetchedViaServiceWorker())
     return GetCORSStatus() != CORSStatus::kServiceWorkerOpaque;
  
    if (does_current_frame_has_single_security_origin !=
        ImageResourceInfo::kHasSingleSecurityOrigin)
      return false;
  
  if (IsSameOriginOrCORSSuccessful())
   DCHECK(security_origin);
   if (PassesAccessControlCheck(*security_origin))
      return true;
  
    return !security_origin->TaintsCanvas(GetResponse().Url());
 }","[7, 8, 15, 16, 5, 6, 14]",Lack of CORS checking by ResourceFetcher/ResourceLoader in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to leak cross-origin data via a crafted HTML page.
8371,"TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {
auto* params =
reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);
TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);
TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);

const TfLiteTensor* hash;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));
TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);

TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);

const TfLiteTensor* input;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));
TF_LITE_ENSURE(context, NumDimensions(input) >= 1);

if (NumInputs(node) == 3) {
const TfLiteTensor* weight;
TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));
TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);
TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),
SizeOfDimension(input, 0));
}

TfLiteTensor* output;
TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);
switch (params->type) {
case kTfLiteLshProjectionSparse:
outputSize->data[0] = SizeOfDimension(hash, 0);
break;
case kTfLiteLshProjectionDense:
outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);
break;
default:
return kTfLiteError;
}
return context->ResizeTensor(context, output, outputSize);
}",[17],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a division by zero error in LSH [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/lsh_projection.cc#L118). We have patched the issue in GitHub commit 0575b640091680cfb70f4dd93e70658de43b94f9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick thiscommit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
206811,"  void PlatformSensorProviderAndroid::CreateAbsoluteOrientationEulerAnglesSensor(
      JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
     SensorReadingSharedBuffer* reading_buffer,
      const CreateSensorCallback& callback) {
    if (static_cast<bool>(Java_PlatformSensorProvider_hasSensorType(
            env, j_object_,
           static_cast<jint>(
               mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION)))) {
     auto sensor_fusion_algorithm =
         std::make_unique<OrientationEulerAnglesFusionAlgorithmUsingQuaternion>(
             true  );
  
    PlatformSensorFusion::Create(std::move(mapping), this,
     PlatformSensorFusion::Create(reading_buffer, this,
                                   std::move(sensor_fusion_algorithm), callback);
    } else {
      auto sensor_fusion_algorithm = std::make_unique<
          AbsoluteOrientationEulerAnglesFusionAlgorithmUsingAccelerometerAndMagnetometer>();
  
    PlatformSensorFusion::Create(std::move(mapping), this,
     PlatformSensorFusion::Create(reading_buffer, this,
                                   std::move(sensor_fusion_algorithm), callback);
    }
  }","[4, 15, 22, 3, 14, 21]",Lack of special casing of Android ashmem in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to bypass inter-process read only guarantees via a crafted HTML page.
206763," void ServiceWorkerDevToolsAgentHost::WorkerRestarted(int worker_process_id,
                                                      int worker_route_id) {
   DCHECK_EQ(WORKER_TERMINATED, state_);
    state_ = WORKER_NOT_READY;
    worker_process_id_ = worker_process_id;
    worker_route_id_ = worker_route_id;
  RenderProcessHost* host = RenderProcessHost::FromID(worker_process_id_);
    for (DevToolsSession* session : sessions())
    session->SetRenderer(host, nullptr);
     session->SetRenderer(worker_process_id_, nullptr);
  }","[10, 7, 9]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
207462,"  static inline int btif_hl_select_close_connected(void){
      char sig_on = btif_hl_signal_select_close_connected;
      BTIF_TRACE_DEBUG(""btif_hl_select_close_connected"");
    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
     return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));
  }","[5, 4]","Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210."
198001," zstatus(i_ctx_t *i_ctx_p)
 {
     os_ptr op = osp;
 
     switch (r_type(op)) {
         case t_file:
             {
                 stream *s;
 
                 make_bool(op, (file_is_valid(s, op) ? 1 : 0));
             }
             return 0;
         case t_string:
             {
                 gs_parsed_file_name_t pname;
                 struct stat fstat;
                 int code = parse_file_name(op, &pname,
                                            i_ctx_p->LockFilePermissions, imemory);
                 if (code < 0) {
                     if (code == gs_error_undefinedfilename) {
                         make_bool(op, 0);
                         code = 0;
                     }
                     return code;
                 }
                 code = gs_terminate_file_name(&pname, imemory, ""status"");
                 if (code < 0)
                     return code;
                  code = gs_terminate_file_name(&pname, imemory, ""status"");
                  if (code < 0)
                      return code;
                code = (*pname.iodev->procs.file_status)(pname.iodev,
                 if ((code = check_file_permissions(i_ctx_p, pname.fname, pname.len,
                                        ""PermitFileReading"")) >= 0) {
                     code = (*pname.iodev->procs.file_status)(pname.iodev,
                                                         pname.fname, &fstat);
                 }
                  switch (code) {
                      case 0:
                          check_ostack(4);
                         make_int(op - 4, stat_blocks(&fstat));
                         make_int(op - 3, fstat.st_size);
                          
                         if ((double)op[-4].value.intval !=
                               (double)stat_blocks(&fstat) ||
                             (double)op[-3].value.intval !=
                               (double)fstat.st_size
                             )
                             return_error(gs_error_limitcheck);
                         make_int(op - 2, fstat.st_mtime);
                         make_int(op - 1, fstat.st_ctime);
                         make_bool(op, 1);
                         break;
                     case gs_error_undefinedfilename:
                         make_bool(op, 0);
                         code = 0;
                 }
                 gs_free_file_name(&pname, ""status"");
                 return code;
             }
         default:
             return_op_typecheck(op);
     }
 }","[33, 34, 35, 37, 32]","psi/zfile.c in Artifex Ghostscript before 9.21rc1 permits the status command even if -dSAFER is used, which might allow remote attackers to determine the existence and size of arbitrary files, a similar issue to CVE-2016-7977."
204350,"   void SaveTestFileSystem() {
     GDataRootDirectoryProto root;
     GDataDirectoryProto* root_dir = root.mutable_gdata_directory();
      GDataEntryProto* file_base = root_dir->mutable_gdata_entry();
      PlatformFileInfoProto* platform_info = file_base->mutable_file_info();
      file_base->set_title(""drive"");
     file_base->set_resource_id(kGDataRootDirectoryResourceId);
      platform_info->set_is_directory(true);
  
     GDataFileProto* file = root_dir->add_child_files();
     file_base = file->mutable_gdata_entry();
     platform_info = file_base->mutable_file_info();
     file_base->set_title(""File1"");
     platform_info->set_is_directory(false);
     platform_info->set_size(1048576);
 
     GDataDirectoryProto* dir1 = root_dir->add_child_directories();
     file_base = dir1->mutable_gdata_entry();
     platform_info = file_base->mutable_file_info();
     file_base->set_title(""Dir1"");
     platform_info->set_is_directory(true);
 
     file = dir1->add_child_files();
     file_base = file->mutable_gdata_entry();
     platform_info = file_base->mutable_file_info();
     file_base->set_title(""File2"");
     platform_info->set_is_directory(false);
     platform_info->set_size(555);
 
     GDataDirectoryProto* dir2 = dir1->add_child_directories();
     file_base = dir2->mutable_gdata_entry();
     platform_info = file_base->mutable_file_info();
     file_base->set_title(""SubDir2"");
     platform_info->set_is_directory(true);
 
     file = dir2->add_child_files();
     file_base = file->mutable_gdata_entry();
     platform_info = file_base->mutable_file_info();
     file_base->set_title(""File3"");
     platform_info->set_is_directory(false);
     platform_info->set_size(12345);
 
     std::string serialized_proto;
     ASSERT_TRUE(root.SerializeToString(&serialized_proto));
     ASSERT_TRUE(!serialized_proto.empty());
 
     FilePath cache_dir_path = profile_->GetPath().Append(
         FILE_PATH_LITERAL(""GCache/v1/meta/""));
     ASSERT_TRUE(file_util::CreateDirectory(cache_dir_path));
     const int file_size = static_cast<int>(serialized_proto.length());
     ASSERT_EQ(file_util::WriteFile(cache_dir_path.Append(""file_system.pb""),
         serialized_proto.data(), file_size), file_size);
   }",[7],Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
197964," int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
 	     void *asn, EVP_PKEY *pkey)
 	{
 	EVP_MD_CTX ctx;
 	const EVP_MD *type;
         unsigned char *buf_in=NULL;
         int ret= -1,i,inl;
  
        if (!pkey)
                {
                ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
                return -1;
                }
 
         EVP_MD_CTX_init(&ctx);
         i=OBJ_obj2nid(a->algorithm);
         type=EVP_get_digestbyname(OBJ_nid2sn(i));
 	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		ret=0;
 		goto err;
 		}
 
 	inl = ASN1_item_i2d(asn, &buf_in, it);
 	
 	if (buf_in == NULL)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
 		goto err;
 		}
 
 	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);
 
 	OPENSSL_cleanse(buf_in,(unsigned int)inl);
 	OPENSSL_free(buf_in);
 
 	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
 			(unsigned int)signature->length,pkey) <= 0)
 		{
 		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
 		ret=0;
 		goto err;
 		}
 	 
 	 
 	ret=1;
 err:
 	EVP_MD_CTX_cleanup(&ctx);
 	return(ret);
 	}","[9, 10, 11, 12, 13, 14]","OpenSSL before 0.9.8y, 1.0.0 before 1.0.0k, and 1.0.1 before 1.0.1d does not properly perform signature verification for OCSP responses, which allows remote OCSP servers to cause a denial of service (NULL pointer dereference and application crash) via an invalid key."
201257," AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,
                                                       void *dummy,
                                                       const char *arg)
 {
     const char *endp = ap_strrchr_c(arg, '>');
     const char *limited_methods;
     void *tog = cmd->cmd->cmd_data;
     apr_int64_t limited = 0;
     apr_int64_t old_limited = cmd->limited;
     const char *errmsg;
 
     if (endp == NULL) {
         return unclosed_directive(cmd);
     }
 
     limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);
 
     if (!limited_methods[0]) {
         return missing_container_arg(cmd);
     }
 
     while (limited_methods[0]) {
         char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);
         int methnum;
 
          
         methnum = ap_method_number_of(method);
 
         if (methnum == M_TRACE && !tog) {
             return ""TRACE cannot be controlled by <Limit>, see TraceEnable"";
         }
         else if (methnum == M_INVALID) {
               
             if (cmd->pool == cmd->temp_pool) {
                  
                 return apr_psprintf(cmd->pool, ""Could not register method '%s' ""
                                    ""for %s from .htaccess configuration"",
                                     method, cmd->cmd->name);
             }
              methnum = ap_method_register(cmd->pool,
                                           apr_pstrdup(cmd->pool, method));
          }
 
         limited |= (AP_METHOD_BIT << methnum);
     }
 
      
     limited = tog ? ~limited : limited;
 
     if (!(old_limited & limited)) {
         return apr_pstrcat(cmd->pool, cmd->cmd->name,
                            ""> directive excludes all methods"", NULL);
     }
     else if ((old_limited & limited) == old_limited) {
         return apr_pstrcat(cmd->pool, cmd->cmd->name,
                            ""> directive specifies methods already excluded"",
                            NULL);
     }
 
     cmd->limited &= limited;
 
     errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);
 
     cmd->limited = old_limited;
 
     return errmsg;
 }","[34, 35, 36, 37, 38, 39]","Apache httpd allows remote attackers to read secret data from process memory if the Limit directive can be set in a user's .htaccess file, or if httpd.conf has certain misconfigurations, aka Optionsbleed. This affects the Apache HTTP Server through 2.2.34 and 2.4.x through 2.4.27. The attacker sends an unauthenticated OPTIONS HTTP request when attempting to read secret data. This is a use-after-free issue and thus secret data is not always sent, and the specific data depends on many factors including configuration. Exploitation with .htaccess can be blocked with a patch to the ap_limit_section function in server/core.c."
7020,"static void async_polkit_query_free(AsyncPolkitQuery *q) {

if (!q)
return;

sd_bus_slot_unref(q->slot);

if (q->registry && q->request)
hashmap_remove(q->registry, q->request);

sd_bus_message_unref(q->request);
sd_bus_message_unref(q->reply);

free(q);
}",[14],"A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages."
201709," static void MSLStartElement(void *context,const xmlChar *tag,
   const xmlChar **attributes)
 {
   AffineMatrix
     affine,
     current;
 
   ChannelType
     channel;
 
   char
     key[MaxTextExtent],
     *value;
 
   const char
     *attribute,
     *keyword;
 
   double
     angle;
 
   DrawInfo
     *draw_info;
 
   ExceptionInfo
     *exception;
 
   GeometryInfo
     geometry_info;
 
   Image
     *image;
 
   int
     flags;
 
   ssize_t
     option,
     j,
     n,
     x,
     y;
 
   MSLInfo
     *msl_info;
 
   RectangleInfo
     geometry;
 
   register ssize_t
     i;
 
   size_t
     height,
     width;
 
    
   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
     ""  SAX.startElement(%s"",tag);
   exception=AcquireExceptionInfo();
   msl_info=(MSLInfo *) context;
   n=msl_info->n;
   keyword=(const char *) NULL;
   value=(char *) NULL;
   SetGeometryInfo(&geometry_info);
   (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
   channel=DefaultChannels;
   switch (*tag)
   {
     case 'A':
     case 'a':
     {
       if (LocaleCompare((const char *) tag,""add-noise"") == 0)
         {
           Image
             *noise_image;
 
           NoiseType
             noise;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           noise=UniformNoise;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'N':
                 case 'n':
                 {
                   if (LocaleCompare(keyword,""noise"") == 0)
                     {
                       option=ParseCommandOption(MagickNoiseOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedNoiseType"",
                           value);
                       noise=(NoiseType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           noise_image=AddNoiseImageChannel(msl_info->image[n],channel,noise,
             &msl_info->image[n]->exception);
           if (noise_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=noise_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""annotate"") == 0)
         {
           char
             text[MaxTextExtent];
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           draw_info=CloneDrawInfo(msl_info->image_info[n],
             msl_info->draw_info[n]);
           angle=0.0;
           current=draw_info->affine;
           GetAffineMatrix(&affine);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'A':
                 case 'a':
                 {
                   if (LocaleCompare(keyword,""affine"") == 0)
                     {
                       char
                         *p;
 
                       p=value;
                       draw_info->affine.sx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.rx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ry=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.sy=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.tx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ty=StringToDouble(p,&p);
                       break;
                     }
                   if (LocaleCompare(keyword,""align"") == 0)
                     {
                       option=ParseCommandOption(MagickAlignOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedAlignType"",
                           value);
                       draw_info->align=(AlignType) option;
                       break;
                     }
                   if (LocaleCompare(keyword,""antialias"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       draw_info->stroke_antialias=(MagickBooleanType) option;
                       draw_info->text_antialias=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""density"") == 0)
                     {
                       CloneString(&draw_info->density,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'E':
                 case 'e':
                 {
                   if (LocaleCompare(keyword,""encoding"") == 0)
                     {
                       CloneString(&draw_info->encoding,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->fill,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""family"") == 0)
                     {
                       CloneString(&draw_info->family,value);
                       break;
                     }
                   if (LocaleCompare(keyword,""font"") == 0)
                     {
                       CloneString(&draw_info->font,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   if (LocaleCompare(keyword,""gravity"") == 0)
                     {
                       option=ParseCommandOption(MagickGravityOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedGravityType"",
                           value);
                       draw_info->gravity=(GravityType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'P':
                 case 'p':
                 {
                   if (LocaleCompare(keyword,""pointsize"") == 0)
                     {
                       draw_info->pointsize=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""rotate"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));
                       affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));
                       affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));
                       affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""scale"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.sx=geometry_info.rho;
                       affine.sy=geometry_info.sigma;
                       break;
                     }
                   if (LocaleCompare(keyword,""skewX"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.ry=tan(DegreesToRadians(fmod((double) angle,
                         360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""skewY"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.rx=tan(DegreesToRadians(fmod((double) angle,
                         360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""stretch"") == 0)
                     {
                       option=ParseCommandOption(MagickStretchOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStretchType"",
                           value);
                       draw_info->stretch=(StretchType) option;
                       break;
                     }
                   if (LocaleCompare(keyword, ""stroke"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->stroke,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""strokewidth"") == 0)
                     {
                       draw_info->stroke_width=StringToLong(value);
                       break;
                     }
                   if (LocaleCompare(keyword,""style"") == 0)
                     {
                       option=ParseCommandOption(MagickStyleOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStyleType"",
                           value);
                       draw_info->style=(StyleType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""text"") == 0)
                     {
                       CloneString(&draw_info->text,value);
                       break;
                     }
                   if (LocaleCompare(keyword,""translate"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.tx=geometry_info.rho;
                       affine.ty=geometry_info.sigma;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'U':
                 case 'u':
                 {
                   if (LocaleCompare(keyword, ""undercolor"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->undercolor,
                         exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""weight"") == 0)
                     {
                       draw_info->weight=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) FormatLocaleString(text,MaxTextExtent,
             ""%.20gx%.20g%+.20g%+.20g"",(double) geometry.width,(double)
             geometry.height,(double) geometry.x,(double) geometry.y);
           CloneString(&draw_info->geometry,text);
           draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;
           draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;
           draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;
           draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;
           draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+
             affine.tx;
           draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+
             affine.ty;
           (void) AnnotateImage(msl_info->image[n],draw_info);
           draw_info=DestroyDrawInfo(draw_info);
           break;
         }
       if (LocaleCompare((const char *) tag,""append"") == 0)
         {
           Image
             *append_image;
 
           MagickBooleanType
             stack;
 
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           stack=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""stack"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       stack=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           append_image=AppendImages(msl_info->image[n],stack,
             &msl_info->image[n]->exception);
           if (append_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=append_image;
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
       break;
     }
     case 'B':
     case 'b':
     {
       if (LocaleCompare((const char *) tag,""blur"") == 0)
         {
           Image
             *blur_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""sigma"") == 0)
                     {
                       geometry_info.sigma=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           blur_image=BlurImageChannel(msl_info->image[n],channel,
             geometry_info.rho,geometry_info.sigma,
             &msl_info->image[n]->exception);
           if (blur_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=blur_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""border"") == 0)
         {
           Image
             *border_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""compose"") == 0)
                     {
                       option=ParseCommandOption(MagickComposeOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedComposeType"",
                           value);
                       msl_info->image[n]->compose=(CompositeOperator) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,
                         &msl_info->image[n]->border_color,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           border_image=BorderImage(msl_info->image[n],&geometry,
             &msl_info->image[n]->exception);
           if (border_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=border_image;
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'C':
     case 'c':
     {
       if (LocaleCompare((const char *) tag,""colorize"") == 0)
         {
           char
             opacity[MaxTextExtent];
 
           Image
             *colorize_image;
 
           PixelPacket
             target;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           target=msl_info->image[n]->background_color;
           (void) CopyMagickString(opacity,""100"",MaxTextExtent);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,&target,
                         &msl_info->image[n]->exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'O':
                 case 'o':
                 {
                   if (LocaleCompare(keyword,""opacity"") == 0)
                     {
                       (void) CopyMagickString(opacity,value,MaxTextExtent);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           colorize_image=ColorizeImage(msl_info->image[n],opacity,target,
             &msl_info->image[n]->exception);
           if (colorize_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=colorize_image;
           break;
         }
       if (LocaleCompare((const char *) tag, ""charcoal"") == 0)
       {
         double  radius = 0.0,
             sigma = 1.0;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
          
         if (attributes != (const xmlChar **) NULL)
         {
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
           keyword=(const char *) attributes[i++];
           CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
             msl_info->attributes[n],(const char *) attributes[i]));
           switch (*keyword)
           {
             case 'R':
             case 'r':
             {
               if (LocaleCompare(keyword,""radius"") == 0)
                 {
                   radius=StringToDouble(value,(char **) NULL);
                   break;
                 }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             case 'S':
             case 's':
             {
               if (LocaleCompare(keyword,""sigma"") == 0)
               {
                 sigma = StringToLong( value );
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             default:
             {
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
           }
           }
         }
 
          
         {
         Image
           *newImage;
 
         newImage=CharcoalImage(msl_info->image[n],radius,sigma,
           &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         break;
         }
       }
       if (LocaleCompare((const char *) tag,""chop"") == 0)
         {
           Image
             *chop_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           chop_image=ChopImage(msl_info->image[n],&geometry,
             &msl_info->image[n]->exception);
           if (chop_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=chop_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""color-floodfill"") == 0)
         {
           PaintMethod
             paint_method;
 
           MagickPixelPacket
             target;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           draw_info=CloneDrawInfo(msl_info->image_info[n],
             msl_info->draw_info[n]);
           SetGeometry(msl_info->image[n],&geometry);
           paint_method=FloodfillMethod;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'B':
                 case 'b':
                 {
                   if (LocaleCompare(keyword,""bordercolor"") == 0)
                     {
                       (void) QueryMagickColor(value,&target,exception);
                       paint_method=FillToBorderMethod;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->fill,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""fuzz"") == 0)
                     {
                       msl_info->image[n]->fuzz=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) FloodfillPaintImage(msl_info->image[n],DefaultChannels,
             draw_info,&target,geometry.x,geometry.y,
             paint_method == FloodfillMethod ? MagickFalse : MagickTrue);
           draw_info=DestroyDrawInfo(draw_info);
           break;
         }
       if (LocaleCompare((const char *) tag,""comment"") == 0)
         break;
       if (LocaleCompare((const char *) tag,""composite"") == 0)
         {
           char
             composite_geometry[MaxTextExtent];
 
           CompositeOperator
             compose;
 
           Image
             *composite_image,
             *rotate_image;
 
           PixelPacket
             target;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           composite_image=NewImageList();
           compose=OverCompositeOp;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""compose"") == 0)
                     {
                       option=ParseCommandOption(MagickComposeOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedComposeType"",
                           value);
                       compose=(CompositeOperator) option;
                       break;
                     }
                   break;
                 }
                 case 'I':
                 case 'i':
                 {
                   if (LocaleCompare(keyword,""image"") == 0)
                     for (j=0; j < msl_info->n; j++)
                     {
                       const char
                         *attribute;
 
                       attribute=GetImageProperty(msl_info->attributes[j],""id"");
                       if ((attribute != (const char *) NULL)  &&
                           (LocaleCompare(attribute,value) == 0))
                         {
                           composite_image=CloneImage(msl_info->image[j],0,0,
                             MagickFalse,exception);
                           break;
                         }
                     }
                   break;
                 }
                 default:
                   break;
               }
             }
           if (composite_image == (Image *) NULL)
             break;
           rotate_image=NewImageList();
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'B':
                 case 'b':
                 {
                   if (LocaleCompare(keyword,""blend"") == 0)
                     {
                       (void) SetImageArtifact(composite_image,
                                             ""compose:args"",value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   if (LocaleCompare(keyword, ""color"") == 0)
                     {
                       (void) QueryColorDatabase(value,
                         &composite_image->background_color,exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""compose"") == 0)
                     break;
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       (void) GetOneVirtualPixel(msl_info->image[n],geometry.x,
                         geometry.y,&target,exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""gravity"") == 0)
                     {
                       option=ParseCommandOption(MagickGravityOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedGravityType"",
                           value);
                       msl_info->image[n]->gravity=(GravityType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'I':
                 case 'i':
                 {
                   if (LocaleCompare(keyword,""image"") == 0)
                     break;
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'M':
                 case 'm':
                 {
                   if (LocaleCompare(keyword,""mask"") == 0)
                     for (j=0; j < msl_info->n; j++)
                     {
                       const char
                         *attribute;
 
                       attribute=GetImageProperty(msl_info->attributes[j],""id"");
                       if ((attribute != (const char *) NULL)  &&
                           (LocaleCompare(value,value) == 0))
                         {
                           SetImageType(composite_image,TrueColorMatteType);
                           (void) CompositeImage(composite_image,
                             CopyOpacityCompositeOp,msl_info->image[j],0,0);
                           break;
                         }
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'O':
                 case 'o':
                 {
                   if (LocaleCompare(keyword,""opacity"") == 0)
                     {
                       ssize_t
                         opacity,
                         y;
 
                       register ssize_t
                         x;
 
                       register PixelPacket
                         *q;
 
                       CacheView
                         *composite_view;
 
                       opacity=QuantumRange-StringToLong(value);
                       if (compose != DissolveCompositeOp)
                         {
                           (void) SetImageOpacity(composite_image,(Quantum)
                             opacity);
                           break;
                         }
                       (void) SetImageArtifact(msl_info->image[n],
                                             ""compose:args"",value);
                       if (composite_image->matte != MagickTrue)
                         (void) SetImageOpacity(composite_image,OpaqueOpacity);
                       composite_view=AcquireAuthenticCacheView(composite_image,
                         exception);
                       for (y=0; y < (ssize_t) composite_image->rows ; y++)
                       {
                         q=GetCacheViewAuthenticPixels(composite_view,0,y,
                           (ssize_t) composite_image->columns,1,exception);
                         for (x=0; x < (ssize_t) composite_image->columns; x++)
                         {
                           if (q->opacity == OpaqueOpacity)
                             q->opacity=ClampToQuantum(opacity);
                           q++;
                         }
                         if (SyncCacheViewAuthenticPixels(composite_view,exception) == MagickFalse)
                           break;
                       }
                       composite_view=DestroyCacheView(composite_view);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""rotate"") == 0)
                     {
                       rotate_image=RotateImage(composite_image,
                         StringToDouble(value,(char **) NULL),exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""tile"") == 0)
                     {
                       MagickBooleanType
                         tile;
 
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       tile=(MagickBooleanType) option;
                       (void) tile;
                       if (rotate_image != (Image *) NULL)
                         (void) SetImageArtifact(rotate_image,
                           ""compose:outside-overlay"",""false"");
                       else
                         (void) SetImageArtifact(composite_image,
                           ""compose:outside-overlay"",""false"");
                        image=msl_info->image[n];
                        height=composite_image->rows;
                        width=composite_image->columns;
                        for (y=0; y < (ssize_t) image->rows; y+=(ssize_t) height)
                          for (x=0; x < (ssize_t) image->columns; x+=(ssize_t) width)
                          {
                            if (rotate_image != (Image *) NULL)
                              (void) CompositeImage(image,compose,rotate_image,
                                x,y);
                            else
                              (void) CompositeImage(image,compose,
                                composite_image,x,y);
                          }
                       if (rotate_image != (Image *) NULL)
                         rotate_image=DestroyImage(rotate_image);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       (void) GetOneVirtualPixel(msl_info->image[n],geometry.x,
                         geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       (void) GetOneVirtualPixel(msl_info->image[n],geometry.x,
                         geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           image=msl_info->image[n];
           (void) FormatLocaleString(composite_geometry,MaxTextExtent,
             ""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,
             (double) composite_image->rows,(double) geometry.x,(double)
             geometry.y);
           flags=ParseGravityGeometry(image,composite_geometry,&geometry,
             exception);
           if (rotate_image == (Image *) NULL)
             CompositeImageChannel(image,channel,compose,composite_image,
               geometry.x,geometry.y);
           else
             {
                
               geometry.x-=(ssize_t) (rotate_image->columns-
                 composite_image->columns)/2;
               geometry.y-=(ssize_t) (rotate_image->rows-composite_image->rows)/2;
               CompositeImageChannel(image,channel,compose,rotate_image,
                 geometry.x,geometry.y);
               rotate_image=DestroyImage(rotate_image);
             }
           composite_image=DestroyImage(composite_image);
           break;
         }
       if (LocaleCompare((const char *) tag,""contrast"") == 0)
         {
           MagickBooleanType
             sharpen;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           sharpen=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""sharpen"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       sharpen=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) ContrastImage(msl_info->image[n],sharpen);
           break;
         }
       if (LocaleCompare((const char *) tag,""crop"") == 0)
         {
           Image
             *crop_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGravityGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           crop_image=CropImage(msl_info->image[n],&geometry,
             &msl_info->image[n]->exception);
           if (crop_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=crop_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""cycle-colormap"") == 0)
         {
           ssize_t
             display;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           display=0;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""display"") == 0)
                     {
                       display=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) CycleColormapImage(msl_info->image[n],display);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'D':
     case 'd':
     {
       if (LocaleCompare((const char *) tag,""despeckle"") == 0)
         {
           Image
             *despeckle_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           despeckle_image=DespeckleImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (despeckle_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=despeckle_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""display"") == 0)
         {
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) DisplayImages(msl_info->image_info[n],msl_info->image[n]);
           break;
         }
       if (LocaleCompare((const char *) tag,""draw"") == 0)
         {
           char
             text[MaxTextExtent];
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           draw_info=CloneDrawInfo(msl_info->image_info[n],
             msl_info->draw_info[n]);
           angle=0.0;
           current=draw_info->affine;
           GetAffineMatrix(&affine);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'A':
                 case 'a':
                 {
                   if (LocaleCompare(keyword,""affine"") == 0)
                     {
                       char
                         *p;
 
                       p=value;
                       draw_info->affine.sx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.rx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ry=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.sy=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.tx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ty=StringToDouble(p,&p);
                       break;
                     }
                   if (LocaleCompare(keyword,""align"") == 0)
                     {
                       option=ParseCommandOption(MagickAlignOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedAlignType"",
                           value);
                       draw_info->align=(AlignType) option;
                       break;
                     }
                   if (LocaleCompare(keyword,""antialias"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       draw_info->stroke_antialias=(MagickBooleanType) option;
                       draw_info->text_antialias=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""density"") == 0)
                     {
                       CloneString(&draw_info->density,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'E':
                 case 'e':
                 {
                   if (LocaleCompare(keyword,""encoding"") == 0)
                     {
                       CloneString(&draw_info->encoding,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->fill,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""family"") == 0)
                     {
                       CloneString(&draw_info->family,value);
                       break;
                     }
                   if (LocaleCompare(keyword,""font"") == 0)
                     {
                       CloneString(&draw_info->font,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   if (LocaleCompare(keyword,""gravity"") == 0)
                     {
                       option=ParseCommandOption(MagickGravityOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedGravityType"",
                           value);
                       draw_info->gravity=(GravityType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'P':
                 case 'p':
                 {
                   if (LocaleCompare(keyword,""points"") == 0)
                     {
                       if (LocaleCompare(draw_info->primitive,""path"") == 0)
                         {
                           (void) ConcatenateString(&draw_info->primitive,"" '"");
                           ConcatenateString(&draw_info->primitive,value);
                           (void) ConcatenateString(&draw_info->primitive,""'"");
                         }
                       else
                         {
                           (void) ConcatenateString(&draw_info->primitive,"" "");
                           ConcatenateString(&draw_info->primitive,value);
                         }
                       break;
                     }
                   if (LocaleCompare(keyword,""pointsize"") == 0)
                     {
                       draw_info->pointsize=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   if (LocaleCompare(keyword,""primitive"") == 0)
                     {
                       CloneString(&draw_info->primitive,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""rotate"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));
                       affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));
                       affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));
                       affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""scale"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.sx=geometry_info.rho;
                       affine.sy=geometry_info.sigma;
                       break;
                     }
                   if (LocaleCompare(keyword,""skewX"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""skewY"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""stretch"") == 0)
                     {
                       option=ParseCommandOption(MagickStretchOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStretchType"",
                           value);
                       draw_info->stretch=(StretchType) option;
                       break;
                     }
                   if (LocaleCompare(keyword, ""stroke"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->stroke,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""strokewidth"") == 0)
                     {
                       draw_info->stroke_width=StringToLong(value);
                       break;
                     }
                   if (LocaleCompare(keyword,""style"") == 0)
                     {
                       option=ParseCommandOption(MagickStyleOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStyleType"",
                           value);
                       draw_info->style=(StyleType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""text"") == 0)
                     {
                       (void) ConcatenateString(&draw_info->primitive,"" '"");
                       (void) ConcatenateString(&draw_info->primitive,value);
                       (void) ConcatenateString(&draw_info->primitive,""'"");
                       break;
                     }
                   if (LocaleCompare(keyword,""translate"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.tx=geometry_info.rho;
                       affine.ty=geometry_info.sigma;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'U':
                 case 'u':
                 {
                   if (LocaleCompare(keyword, ""undercolor"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->undercolor,
                         exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""weight"") == 0)
                     {
                       draw_info->weight=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) FormatLocaleString(text,MaxTextExtent,
             ""%.20gx%.20g%+.20g%+.20g"",(double) geometry.width,(double)
             geometry.height,(double) geometry.x,(double) geometry.y);
           CloneString(&draw_info->geometry,text);
           draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;
           draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;
           draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;
           draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;
           draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+
             affine.tx;
           draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+
             affine.ty;
           (void) DrawImage(msl_info->image[n],draw_info);
           draw_info=DestroyDrawInfo(draw_info);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'E':
     case 'e':
     {
       if (LocaleCompare((const char *) tag,""edge"") == 0)
         {
           Image
             *edge_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           edge_image=EdgeImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (edge_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=edge_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""emboss"") == 0)
         {
           Image
             *emboss_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""sigma"") == 0)
                     {
                       geometry_info.sigma=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           emboss_image=EmbossImage(msl_info->image[n],geometry_info.rho,
             geometry_info.sigma,&msl_info->image[n]->exception);
           if (emboss_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=emboss_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""enhance"") == 0)
         {
           Image
             *enhance_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           enhance_image=EnhanceImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (enhance_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=enhance_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""equalize"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) EqualizeImage(msl_info->image[n]);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'F':
     case 'f':
     {
       if (LocaleCompare((const char *) tag, ""flatten"") == 0)
       {
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
 
          
 
          
         {
           Image
             *newImage;
 
           newImage=MergeImageLayers(msl_info->image[n],FlattenLayer,
             &msl_info->image[n]->exception);
           if (newImage == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=newImage;
           break;
         }
       }
       if (LocaleCompare((const char *) tag,""flip"") == 0)
         {
           Image
             *flip_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           flip_image=FlipImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (flip_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=flip_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""flop"") == 0)
         {
           Image
             *flop_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           flop_image=FlopImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (flop_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=flop_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""frame"") == 0)
         {
           FrameInfo
             frame_info;
 
           Image
             *frame_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           (void) ResetMagickMemory(&frame_info,0,sizeof(frame_info));
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""compose"") == 0)
                     {
                       option=ParseCommandOption(MagickComposeOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedComposeType"",
                           value);
                       msl_info->image[n]->compose=(CompositeOperator) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,
                         &msl_info->image[n]->matte_color,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       frame_info.width=geometry.width;
                       frame_info.height=geometry.height;
                       frame_info.outer_bevel=geometry.x;
                       frame_info.inner_bevel=geometry.y;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       frame_info.height=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'I':
                 case 'i':
                 {
                   if (LocaleCompare(keyword,""inner"") == 0)
                     {
                       frame_info.inner_bevel=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'O':
                 case 'o':
                 {
                   if (LocaleCompare(keyword,""outer"") == 0)
                     {
                       frame_info.outer_bevel=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       frame_info.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           frame_info.x=(ssize_t) frame_info.width;
           frame_info.y=(ssize_t) frame_info.height;
           frame_info.width=msl_info->image[n]->columns+2*frame_info.x;
           frame_info.height=msl_info->image[n]->rows+2*frame_info.y;
           frame_image=FrameImage(msl_info->image[n],&frame_info,
             &msl_info->image[n]->exception);
           if (frame_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=frame_image;
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'G':
     case 'g':
     {
       if (LocaleCompare((const char *) tag,""gamma"") == 0)
         {
           char
             gamma[MaxTextExtent];
 
           MagickPixelPacket
             pixel;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           channel=UndefinedChannel;
           pixel.red=0.0;
           pixel.green=0.0;
           pixel.blue=0.0;
           *gamma='\0';
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'B':
                 case 'b':
                 {
                   if (LocaleCompare(keyword,""blue"") == 0)
                     {
                       pixel.blue=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""gamma"") == 0)
                     {
                       (void) CopyMagickString(gamma,value,MaxTextExtent);
                       break;
                     }
                   if (LocaleCompare(keyword,""green"") == 0)
                     {
                       pixel.green=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""red"") == 0)
                     {
                       pixel.red=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           if (*gamma == '\0')
             (void) FormatLocaleString(gamma,MaxTextExtent,""%g,%g,%g"",
               (double) pixel.red,(double) pixel.green,(double) pixel.blue);
           switch (channel)
           {
             default:
             {
               (void) GammaImage(msl_info->image[n],gamma);
               break;
             }
             case RedChannel:
             {
               (void) GammaImageChannel(msl_info->image[n],RedChannel,pixel.red);
               break;
             }
             case GreenChannel:
             {
               (void) GammaImageChannel(msl_info->image[n],GreenChannel,
                 pixel.green);
               break;
             }
             case BlueChannel:
             {
               (void) GammaImageChannel(msl_info->image[n],BlueChannel,
                 pixel.blue);
               break;
             }
           }
           break;
         }
       else if (LocaleCompare((const char *) tag,""get"") == 0)
         {
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes == (const xmlChar **) NULL)
             break;
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
             keyword=(const char *) attributes[i++];
             CloneString(&value,(const char *) attributes[i]);
             (void) CopyMagickString(key,value,MaxTextExtent);
             switch (*keyword)
             {
               case 'H':
               case 'h':
               {
                 if (LocaleCompare(keyword,""height"") == 0)
                   {
                     (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",
                       (double) msl_info->image[n]->rows);
                     (void) SetImageProperty(msl_info->attributes[n],key,value);
                     break;
                   }
                 ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               }
               case 'W':
               case 'w':
               {
                 if (LocaleCompare(keyword,""width"") == 0)
                   {
                     (void) FormatLocaleString(value,MaxTextExtent,""%.20g"",
                       (double) msl_info->image[n]->columns);
                     (void) SetImageProperty(msl_info->attributes[n],key,value);
                     break;
                   }
                 ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               }
               default:
               {
                 ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
                 break;
               }
             }
           }
           break;
         }
     else if (LocaleCompare((const char *) tag, ""group"") == 0)
     {
       msl_info->number_groups++;
       msl_info->group_info=(MSLGroupInfo *) ResizeQuantumMemory(
         msl_info->group_info,msl_info->number_groups+1UL,
         sizeof(*msl_info->group_info));
       break;
     }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'I':
     case 'i':
     {
       if (LocaleCompare((const char *) tag,""image"") == 0)
         {
           MSLPushImage(msl_info,(Image *) NULL);
           if (attributes == (const xmlChar **) NULL)
             break;
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
             keyword=(const char *) attributes[i++];
             CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
               msl_info->attributes[n],(const char *) attributes[i]));
             switch (*keyword)
             {
               case 'C':
               case 'c':
               {
                 if (LocaleCompare(keyword,""color"") == 0)
                   {
                     Image
                       *next_image;
 
                     (void) CopyMagickString(msl_info->image_info[n]->filename,
                       ""xc:"",MaxTextExtent);
                     (void) ConcatenateMagickString(msl_info->image_info[n]->
                       filename,value,MaxTextExtent);
                     next_image=ReadImage(msl_info->image_info[n],exception);
                     CatchException(exception);
                     if (next_image == (Image *) NULL)
                       continue;
                     if (msl_info->image[n] == (Image *) NULL)
                       msl_info->image[n]=next_image;
                     else
                       {
                         register Image
                           *p;
 
                          
                         p=msl_info->image[n];
                         while (p->next != (Image *) NULL)
                           p=GetNextImageInList(p);
                         next_image->previous=p;
                         p->next=next_image;
                       }
                     break;
                   }
                 (void) SetMSLAttributes(msl_info,keyword,value);
                 break;
               }
               default:
               {
                 (void) SetMSLAttributes(msl_info,keyword,value);
                 break;
               }
             }
           }
           break;
         }
       if (LocaleCompare((const char *) tag,""implode"") == 0)
         {
           Image
             *implode_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'A':
                 case 'a':
                 {
                   if (LocaleCompare(keyword,""amount"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           implode_image=ImplodeImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (implode_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=implode_image;
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'L':
     case 'l':
     {
       if (LocaleCompare((const char *) tag,""label"") == 0)
         break;
       if (LocaleCompare((const char *) tag, ""level"") == 0)
       {
         double
           levelBlack = 0, levelGamma = 1, levelWhite = QuantumRange;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
         if (attributes == (const xmlChar **) NULL)
           break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
           keyword=(const char *) attributes[i++];
           CloneString(&value,(const char *) attributes[i]);
           (void) CopyMagickString(key,value,MaxTextExtent);
           switch (*keyword)
           {
             case 'B':
             case 'b':
             {
               if (LocaleCompare(keyword,""black"") == 0)
               {
                 levelBlack = StringToDouble(value,(char **) NULL);
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             case 'G':
             case 'g':
             {
               if (LocaleCompare(keyword,""gamma"") == 0)
               {
                 levelGamma = StringToDouble(value,(char **) NULL);
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             case 'W':
             case 'w':
             {
               if (LocaleCompare(keyword,""white"") == 0)
               {
                 levelWhite = StringToDouble(value,(char **) NULL);
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             default:
             {
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
           }
         }
 
          
         {
           char level[MaxTextExtent + 1];
           (void) FormatLocaleString(level,MaxTextExtent,""%3.6f/%3.6f/%3.6f/"",
             levelBlack,levelGamma,levelWhite);
           LevelImage ( msl_info->image[n], level );
           break;
         }
       }
     }
     case 'M':
     case 'm':
     {
       if (LocaleCompare((const char *) tag,""magnify"") == 0)
         {
           Image
             *magnify_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           magnify_image=MagnifyImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (magnify_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=magnify_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""map"") == 0)
         {
           Image
             *affinity_image;
 
           MagickBooleanType
             dither;
 
           QuantizeInfo
             *quantize_info;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           affinity_image=NewImageList();
           dither=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""dither"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       dither=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'I':
                 case 'i':
                 {
                   if (LocaleCompare(keyword,""image"") == 0)
                     for (j=0; j < msl_info->n; j++)
                     {
                       const char
                         *attribute;
 
                       attribute=GetImageProperty(msl_info->attributes[j],""id"");
                       if ((attribute != (const char *) NULL)  &&
                           (LocaleCompare(attribute,value) == 0))
                         {
                           affinity_image=CloneImage(msl_info->image[j],0,0,
                             MagickFalse,exception);
                           break;
                         }
                     }
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           quantize_info=AcquireQuantizeInfo(msl_info->image_info[n]);
           quantize_info->dither=dither;
           (void) RemapImages(quantize_info,msl_info->image[n],
             affinity_image);
           quantize_info=DestroyQuantizeInfo(quantize_info);
           affinity_image=DestroyImage(affinity_image);
           break;
         }
       if (LocaleCompare((const char *) tag,""matte-floodfill"") == 0)
         {
           double
             opacity;
 
           MagickPixelPacket
             target;
 
           PaintMethod
             paint_method;
 
            
           opacity=0.0;
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           SetGeometry(msl_info->image[n],&geometry);
           paint_method=FloodfillMethod;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'B':
                 case 'b':
                 {
                   if (LocaleCompare(keyword,""bordercolor"") == 0)
                     {
                       (void) QueryMagickColor(value,&target,exception);
                       paint_method=FillToBorderMethod;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""fuzz"") == 0)
                     {
                       msl_info->image[n]->fuzz=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'O':
                 case 'o':
                 {
                   if (LocaleCompare(keyword,""opacity"") == 0)
                     {
                       opacity=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       (void) GetOneVirtualMagickPixel(msl_info->image[n],
                         geometry.x,geometry.y,&target,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           draw_info=CloneDrawInfo(msl_info->image_info[n],
             msl_info->draw_info[n]);
           draw_info->fill.opacity=ClampToQuantum(opacity);
           (void) FloodfillPaintImage(msl_info->image[n],OpacityChannel,
             draw_info,&target,geometry.x,geometry.y,
             paint_method == FloodfillMethod ? MagickFalse : MagickTrue);
           draw_info=DestroyDrawInfo(draw_info);
           break;
         }
       if (LocaleCompare((const char *) tag,""median-filter"") == 0)
         {
           Image
             *median_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           median_image=StatisticImage(msl_info->image[n],MedianStatistic,
             (size_t) geometry_info.rho,(size_t) geometry_info.sigma,
             &msl_info->image[n]->exception);
           if (median_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=median_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""minify"") == 0)
         {
           Image
             *minify_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           minify_image=MinifyImage(msl_info->image[n],
             &msl_info->image[n]->exception);
           if (minify_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=minify_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""msl"") == 0 )
         break;
       if (LocaleCompare((const char *) tag,""modulate"") == 0)
         {
           char
             modulate[MaxTextExtent];
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           geometry_info.rho=100.0;
           geometry_info.sigma=100.0;
           geometry_info.xi=100.0;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'B':
                 case 'b':
                 {
                   if (LocaleCompare(keyword,""blackness"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   if (LocaleCompare(keyword,""brightness"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""factor"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""hue"") == 0)
                     {
                       geometry_info.xi=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'L':
                 case 'l':
                 {
                   if (LocaleCompare(keyword,""lightness"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""saturation"") == 0)
                     {
                       geometry_info.sigma=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""whiteness"") == 0)
                     {
                       geometry_info.sigma=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) FormatLocaleString(modulate,MaxTextExtent,""%g,%g,%g"",
             geometry_info.rho,geometry_info.sigma,geometry_info.xi);
           (void) ModulateImage(msl_info->image[n],modulate);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'N':
     case 'n':
     {
       if (LocaleCompare((const char *) tag,""negate"") == 0)
         {
           MagickBooleanType
             gray;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           gray=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""gray"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       gray=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) NegateImageChannel(msl_info->image[n],channel,gray);
           break;
         }
       if (LocaleCompare((const char *) tag,""normalize"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) NormalizeImageChannel(msl_info->image[n],channel);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'O':
     case 'o':
     {
       if (LocaleCompare((const char *) tag,""oil-paint"") == 0)
         {
           Image
             *paint_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           paint_image=OilPaintImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (paint_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=paint_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""opaque"") == 0)
         {
           MagickPixelPacket
             fill_color,
             target;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           (void) QueryMagickColor(""none"",&target,exception);
           (void) QueryMagickColor(""none"",&fill_color,exception);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""channel"") == 0)
                     {
                       option=ParseChannelOption(value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedChannelType"",
                           value);
                       channel=(ChannelType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""fill"") == 0)
                     {
                       (void) QueryMagickColor(value,&fill_color,exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""fuzz"") == 0)
                     {
                       msl_info->image[n]->fuzz=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) OpaquePaintImageChannel(msl_info->image[n],channel,
             &target,&fill_color,MagickFalse);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'P':
     case 'p':
     {
       if (LocaleCompare((const char *) tag,""print"") == 0)
         {
           if (attributes == (const xmlChar **) NULL)
             break;
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
             keyword=(const char *) attributes[i++];
             attribute=InterpretImageProperties(msl_info->image_info[n],
               msl_info->attributes[n],(const char *) attributes[i]);
             CloneString(&value,attribute);
             switch (*keyword)
             {
               case 'O':
               case 'o':
               {
                 if (LocaleCompare(keyword,""output"") == 0)
                   {
                     (void) FormatLocaleFile(stdout,""%s"",value);
                     break;
                   }
                 ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
                 break;
               }
               default:
               {
                 ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
                 break;
               }
             }
           }
           break;
         }
         if (LocaleCompare((const char *) tag, ""profile"") == 0)
           {
             if (msl_info->image[n] == (Image *) NULL)
               {
                 ThrowMSLException(OptionError,""NoImagesDefined"",
                   (const char *) tag);
                 break;
               }
             if (attributes == (const xmlChar **) NULL)
               break;
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               const char
                 *name;
 
               const StringInfo
                 *profile;
 
               Image
                 *profile_image;
 
               ImageInfo
                 *profile_info;
 
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               if (*keyword == '!')
                 {
                    
                   (void) ProfileImage(msl_info->image[n],keyword,
                     (const unsigned char *) NULL,0,MagickTrue);
                   continue;
                 }
                
               profile_info=CloneImageInfo(msl_info->image_info[n]);
               profile=GetImageProfile(msl_info->image[n],""iptc"");
               if (profile != (StringInfo *) NULL)
                 profile_info->profile=(void *) CloneStringInfo(profile);
               profile_image=GetImageCache(profile_info,keyword,exception);
               profile_info=DestroyImageInfo(profile_info);
               if (profile_image == (Image *) NULL)
                 {
                   char
                     name[MaxTextExtent],
                     filename[MaxTextExtent];
 
                   register char
                     *p;
 
                   StringInfo
                     *profile;
 
                   (void) CopyMagickString(filename,keyword,MaxTextExtent);
                   (void) CopyMagickString(name,keyword,MaxTextExtent);
                   for (p=filename; *p != '\0'; p++)
                     if ((*p == ':') && (IsPathDirectory(keyword) < 0) &&
                         (IsPathAccessible(keyword) == MagickFalse))
                       {
                         register char
                           *q;
 
                          
                         (void) CopyMagickString(name,filename,(size_t)
                           (p-filename+1));
                         for (q=filename; *q != '\0'; q++)
                           *q=(*++p);
                         break;
                       }
                   profile=FileToStringInfo(filename,~0UL,exception);
                   if (profile != (StringInfo *) NULL)
                     {
                       (void) ProfileImage(msl_info->image[n],name,
                         GetStringInfoDatum(profile),(size_t)
                         GetStringInfoLength(profile),MagickFalse);
                       profile=DestroyStringInfo(profile);
                     }
                   continue;
                 }
               ResetImageProfileIterator(profile_image);
               name=GetNextImageProfile(profile_image);
               while (name != (const char *) NULL)
               {
                 profile=GetImageProfile(profile_image,name);
                 if (profile != (StringInfo *) NULL)
                   (void) ProfileImage(msl_info->image[n],name,
                     GetStringInfoDatum(profile),(size_t)
                     GetStringInfoLength(profile),MagickFalse);
                 name=GetNextImageProfile(profile_image);
               }
               profile_image=DestroyImage(profile_image);
             }
             break;
           }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'Q':
     case 'q':
     {
       if (LocaleCompare((const char *) tag,""quantize"") == 0)
         {
           QuantizeInfo
             quantize_info;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           GetQuantizeInfo(&quantize_info);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""colors"") == 0)
                     {
                       quantize_info.number_colors=StringToLong(value);
                       break;
                     }
                   if (LocaleCompare(keyword,""colorspace"") == 0)
                     {
                       option=ParseCommandOption(MagickColorspaceOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,
                           ""UnrecognizedColorspaceType"",value);
                       quantize_info.colorspace=(ColorspaceType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""dither"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       quantize_info.dither=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'M':
                 case 'm':
                 {
                   if (LocaleCompare(keyword,""measure"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       quantize_info.measure_error=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""treedepth"") == 0)
                     {
                       quantize_info.tree_depth=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) QuantizeImage(&quantize_info,msl_info->image[n]);
           break;
         }
       if (LocaleCompare((const char *) tag,""query-font-metrics"") == 0)
         {
           char
             text[MaxTextExtent];
 
           MagickBooleanType
             status;
 
           TypeMetric
             metrics;
 
            
           draw_info=CloneDrawInfo(msl_info->image_info[n],
             msl_info->draw_info[n]);
           angle=0.0;
           current=draw_info->affine;
           GetAffineMatrix(&affine);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'A':
                 case 'a':
                 {
                   if (LocaleCompare(keyword,""affine"") == 0)
                     {
                       char
                         *p;
 
                       p=value;
                       draw_info->affine.sx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.rx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ry=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.sy=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.tx=StringToDouble(p,&p);
                       if (*p ==',')
                         p++;
                       draw_info->affine.ty=StringToDouble(p,&p);
                       break;
                     }
                   if (LocaleCompare(keyword,""align"") == 0)
                     {
                       option=ParseCommandOption(MagickAlignOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedAlignType"",
                           value);
                       draw_info->align=(AlignType) option;
                       break;
                     }
                   if (LocaleCompare(keyword,""antialias"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedBooleanType"",
                           value);
                       draw_info->stroke_antialias=(MagickBooleanType) option;
                       draw_info->text_antialias=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""density"") == 0)
                     {
                       CloneString(&draw_info->density,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'E':
                 case 'e':
                 {
                   if (LocaleCompare(keyword,""encoding"") == 0)
                     {
                       CloneString(&draw_info->encoding,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->fill,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""family"") == 0)
                     {
                       CloneString(&draw_info->family,value);
                       break;
                     }
                   if (LocaleCompare(keyword,""font"") == 0)
                     {
                       CloneString(&draw_info->font,value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   if (LocaleCompare(keyword,""gravity"") == 0)
                     {
                       option=ParseCommandOption(MagickGravityOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedGravityType"",
                           value);
                       draw_info->gravity=(GravityType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'P':
                 case 'p':
                 {
                   if (LocaleCompare(keyword,""pointsize"") == 0)
                     {
                       draw_info->pointsize=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""rotate"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.sx=cos(DegreesToRadians(fmod(angle,360.0)));
                       affine.rx=sin(DegreesToRadians(fmod(angle,360.0)));
                       affine.ry=(-sin(DegreesToRadians(fmod(angle,360.0))));
                       affine.sy=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""scale"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.sx=geometry_info.rho;
                       affine.sy=geometry_info.sigma;
                       break;
                     }
                   if (LocaleCompare(keyword,""skewX"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.ry=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""skewY"") == 0)
                     {
                       angle=StringToDouble(value,(char **) NULL);
                       affine.rx=cos(DegreesToRadians(fmod(angle,360.0)));
                       break;
                     }
                   if (LocaleCompare(keyword,""stretch"") == 0)
                     {
                       option=ParseCommandOption(MagickStretchOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStretchType"",
                           value);
                       draw_info->stretch=(StretchType) option;
                       break;
                     }
                   if (LocaleCompare(keyword, ""stroke"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->stroke,
                         exception);
                       break;
                     }
                   if (LocaleCompare(keyword,""strokewidth"") == 0)
                     {
                       draw_info->stroke_width=StringToLong(value);
                       break;
                     }
                   if (LocaleCompare(keyword,""style"") == 0)
                     {
                       option=ParseCommandOption(MagickStyleOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedStyleType"",
                           value);
                       draw_info->style=(StyleType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""text"") == 0)
                     {
                       CloneString(&draw_info->text,value);
                       break;
                     }
                   if (LocaleCompare(keyword,""translate"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       affine.tx=geometry_info.rho;
                       affine.ty=geometry_info.sigma;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'U':
                 case 'u':
                 {
                   if (LocaleCompare(keyword, ""undercolor"") == 0)
                     {
                       (void) QueryColorDatabase(value,&draw_info->undercolor,
                         exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""weight"") == 0)
                     {
                       draw_info->weight=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) FormatLocaleString(text,MaxTextExtent,
             ""%.20gx%.20g%+.20g%+.20g"",(double) geometry.width,(double)
             geometry.height,(double) geometry.x,(double) geometry.y);
           CloneString(&draw_info->geometry,text);
           draw_info->affine.sx=affine.sx*current.sx+affine.ry*current.rx;
           draw_info->affine.rx=affine.rx*current.sx+affine.sy*current.rx;
           draw_info->affine.ry=affine.sx*current.ry+affine.ry*current.sy;
           draw_info->affine.sy=affine.rx*current.ry+affine.sy*current.sy;
           draw_info->affine.tx=affine.sx*current.tx+affine.ry*current.ty+
             affine.tx;
           draw_info->affine.ty=affine.rx*current.tx+affine.sy*current.ty+
             affine.ty;
           status=GetTypeMetrics(msl_info->attributes[n],draw_info,&metrics);
           if (status != MagickFalse)
             {
               Image
                 *image;
 
               image=msl_info->attributes[n];
               FormatImageProperty(image,""msl:font-metrics.pixels_per_em.x"",
                 ""%g"",metrics.pixels_per_em.x);
               FormatImageProperty(image,""msl:font-metrics.pixels_per_em.y"",
                 ""%g"",metrics.pixels_per_em.y);
               FormatImageProperty(image,""msl:font-metrics.ascent"",""%g"",
                 metrics.ascent);
               FormatImageProperty(image,""msl:font-metrics.descent"",""%g"",
                 metrics.descent);
               FormatImageProperty(image,""msl:font-metrics.width"",""%g"",
                 metrics.width);
               FormatImageProperty(image,""msl:font-metrics.height"",""%g"",
                 metrics.height);
               FormatImageProperty(image,""msl:font-metrics.max_advance"",""%g"",
                 metrics.max_advance);
               FormatImageProperty(image,""msl:font-metrics.bounds.x1"",""%g"",
                 metrics.bounds.x1);
               FormatImageProperty(image,""msl:font-metrics.bounds.y1"",""%g"",
                 metrics.bounds.y1);
               FormatImageProperty(image,""msl:font-metrics.bounds.x2"",""%g"",
                 metrics.bounds.x2);
               FormatImageProperty(image,""msl:font-metrics.bounds.y2"",""%g"",
                 metrics.bounds.y2);
               FormatImageProperty(image,""msl:font-metrics.origin.x"",""%g"",
                 metrics.origin.x);
               FormatImageProperty(image,""msl:font-metrics.origin.y"",""%g"",
                 metrics.origin.y);
             }
           draw_info=DestroyDrawInfo(draw_info);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'R':
     case 'r':
     {
       if (LocaleCompare((const char *) tag,""raise"") == 0)
         {
           MagickBooleanType
             raise;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           raise=MagickFalse;
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""raise"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedNoiseType"",
                           value);
                       raise=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) RaiseImage(msl_info->image[n],&geometry,raise);
           break;
         }
       if (LocaleCompare((const char *) tag,""read"") == 0)
         {
           if (attributes == (const xmlChar **) NULL)
             break;
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
             keyword=(const char *) attributes[i++];
             CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
               msl_info->attributes[n],(const char *) attributes[i]));
             switch (*keyword)
             {
               case 'F':
               case 'f':
               {
                 if (LocaleCompare(keyword,""filename"") == 0)
                   {
                      Image
                        *image;
  
                     if (value == (char *) NULL)
                       break;
                      (void) CopyMagickString(msl_info->image_info[n]->filename,
                        value,MaxTextExtent);
                      image=ReadImage(msl_info->image_info[n],exception);
                     CatchException(exception);
                     if (image == (Image *) NULL)
                       continue;
                     AppendImageToList(&msl_info->image[n],image);
                     break;
                   }
                 (void) SetMSLAttributes(msl_info,keyword,value);
                 break;
               }
               default:
               {
                 (void) SetMSLAttributes(msl_info,keyword,value);
                 break;
               }
             }
           }
           break;
         }
       if (LocaleCompare((const char *) tag,""reduce-noise"") == 0)
         {
           Image
             *paint_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           paint_image=StatisticImage(msl_info->image[n],NonpeakStatistic,
             (size_t) geometry_info.rho,(size_t) geometry_info.sigma,
             &msl_info->image[n]->exception);
           if (paint_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=paint_image;
           break;
         }
       else if (LocaleCompare((const char *) tag,""repage"") == 0)
       {
          
         width=msl_info->image[n]->page.width;
         height=msl_info->image[n]->page.height;
         x=msl_info->image[n]->page.x;
         y=msl_info->image[n]->page.y;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'G':
           case 'g':
           {
           if (LocaleCompare(keyword,""geometry"") == 0)
             {
               int
                 flags;
 
               RectangleInfo
                 geometry;
 
             flags=ParseAbsoluteGeometry(value,&geometry);
             if ((flags & WidthValue) != 0)
               {
                 if ((flags & HeightValue) == 0)
                   geometry.height=geometry.width;
                 width=geometry.width;
                 height=geometry.height;
               }
             if ((flags & AspectValue) != 0)
               {
                 if ((flags & XValue) != 0)
                   x+=geometry.x;
                 if ((flags & YValue) != 0)
                   y+=geometry.y;
               }
             else
               {
                 if ((flags & XValue) != 0)
                   {
                     x=geometry.x;
                     if ((width == 0) && (geometry.x > 0))
                       width=msl_info->image[n]->columns+geometry.x;
                   }
                 if ((flags & YValue) != 0)
                   {
                     y=geometry.y;
                     if ((height == 0) && (geometry.y > 0))
                       height=msl_info->image[n]->rows+geometry.y;
                   }
               }
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'H':
           case 'h':
           {
           if (LocaleCompare(keyword,""height"") == 0)
             {
             height = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'W':
           case 'w':
           {
           if (LocaleCompare(keyword,""width"") == 0)
             {
             width = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'X':
           case 'x':
           {
           if (LocaleCompare(keyword,""x"") == 0)
             {
             x = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'Y':
           case 'y':
           {
           if (LocaleCompare(keyword,""y"") == 0)
             {
             y = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          msl_info->image[n]->page.width=width;
          msl_info->image[n]->page.height=height;
          msl_info->image[n]->page.x=x;
          msl_info->image[n]->page.y=y;
         break;
       }
     else if (LocaleCompare((const char *) tag,""resample"") == 0)
     {
       double
         x_resolution,
         y_resolution;
 
       if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
       if (attributes == (const xmlChar **) NULL)
         break;
       x_resolution=DefaultResolution;
       y_resolution=DefaultResolution;
       for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
       {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'b':
           {
             if (LocaleCompare(keyword,""blur"") == 0)
               {
                 msl_info->image[n]->blur=StringToDouble(value,
                         (char **) NULL);
                 break;
               }
             ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
           }
           case 'G':
           case 'g':
           {
             if (LocaleCompare(keyword,""geometry"") == 0)
               {
                 ssize_t
                   flags;
 
                 flags=ParseGeometry(value,&geometry_info);
                 if ((flags & SigmaValue) == 0)
                   geometry_info.sigma*=geometry_info.rho;
                 x_resolution=geometry_info.rho;
                 y_resolution=geometry_info.sigma;
                 break;
               }
             ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
           }
           case 'X':
           case 'x':
           {
             if (LocaleCompare(keyword,""x-resolution"") == 0)
               {
                 x_resolution=StringToDouble(value,(char **) NULL);
                 break;
               }
             ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
           }
           case 'Y':
           case 'y':
           {
             if (LocaleCompare(keyword,""y-resolution"") == 0)
               {
                 y_resolution=StringToDouble(value,(char **) NULL);
                 break;
               }
             ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
           }
           default:
           {
             ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
           }
         }
       }
        
       {
         double
           factor;
 
         Image
           *resample_image;
 
         factor=1.0;
         if (msl_info->image[n]->units == PixelsPerCentimeterResolution)
           factor=2.54;
         width=(size_t) (x_resolution*msl_info->image[n]->columns/
           (factor*(msl_info->image[n]->x_resolution == 0.0 ? DefaultResolution :
           msl_info->image[n]->x_resolution))+0.5);
         height=(size_t) (y_resolution*msl_info->image[n]->rows/
           (factor*(msl_info->image[n]->y_resolution == 0.0 ? DefaultResolution :
           msl_info->image[n]->y_resolution))+0.5);
         resample_image=ResizeImage(msl_info->image[n],width,height,
           msl_info->image[n]->filter,msl_info->image[n]->blur,
           &msl_info->image[n]->exception);
         if (resample_image == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=resample_image;
       }
       break;
     }
       if (LocaleCompare((const char *) tag,""resize"") == 0)
         {
           double
             blur;
 
           FilterTypes
             filter;
 
           Image
             *resize_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           filter=UndefinedFilter;
           blur=1.0;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword,""filter"") == 0)
                     {
                       option=ParseCommandOption(MagickFilterOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedNoiseType"",
                           value);
                       filter=(FilterTypes) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseRegionGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToUnsignedLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""support"") == 0)
                     {
                       blur=StringToDouble(value,(char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           resize_image=ResizeImage(msl_info->image[n],geometry.width,
             geometry.height,filter,blur,&msl_info->image[n]->exception);
           if (resize_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=resize_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""roll"") == 0)
         {
           Image
             *roll_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           SetGeometry(msl_info->image[n],&geometry);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParsePageGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       if ((flags & HeightValue) == 0)
                         geometry.height=geometry.width;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry.x=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry.y=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           roll_image=RollImage(msl_info->image[n],geometry.x,geometry.y,
             &msl_info->image[n]->exception);
           if (roll_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=roll_image;
           break;
         }
       else if (LocaleCompare((const char *) tag,""roll"") == 0)
       {
          
         width=msl_info->image[n]->columns;
         height=msl_info->image[n]->rows;
         x = y = 0;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'G':
           case 'g':
           {
           if (LocaleCompare(keyword,""geometry"") == 0)
             {
             (void) ParseMetaGeometry(value,&x,&y,&width,&height);
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'X':
           case 'x':
           {
           if (LocaleCompare(keyword,""x"") == 0)
             {
             x = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'Y':
           case 'y':
           {
           if (LocaleCompare(keyword,""y"") == 0)
             {
             y = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         {
         Image
           *newImage;
 
         newImage=RollImage(msl_info->image[n], x, y, &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         }
 
         break;
       }
       if (LocaleCompare((const char *) tag,""rotate"") == 0)
         {
           Image
             *rotate_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""degrees"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           rotate_image=RotateImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (rotate_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=rotate_image;
           break;
         }
       else if (LocaleCompare((const char *) tag,""rotate"") == 0)
       {
          
         double  degrees = 0;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
         if (attributes == (const xmlChar **) NULL)
           break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'D':
           case 'd':
           {
           if (LocaleCompare(keyword,""degrees"") == 0)
             {
             degrees = StringToDouble(value,(char **) NULL);
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         {
         Image
           *newImage;
 
         newImage=RotateImage(msl_info->image[n], degrees, &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         }
 
         break;
       }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'S':
     case 's':
     {
       if (LocaleCompare((const char *) tag,""sample"") == 0)
         {
           Image
             *sample_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseRegionGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToUnsignedLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           sample_image=SampleImage(msl_info->image[n],geometry.width,
             geometry.height,&msl_info->image[n]->exception);
           if (sample_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=sample_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""scale"") == 0)
         {
           Image
             *scale_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseRegionGeometry(msl_info->image[n],value,
                         &geometry,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'H':
                 case 'h':
                 {
                   if (LocaleCompare(keyword,""height"") == 0)
                     {
                       geometry.height=StringToUnsignedLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'W':
                 case 'w':
                 {
                   if (LocaleCompare(keyword,""width"") == 0)
                     {
                       geometry.width=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           scale_image=ScaleImage(msl_info->image[n],geometry.width,
             geometry.height,&msl_info->image[n]->exception);
           if (scale_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=scale_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""segment"") == 0)
         {
           ColorspaceType
             colorspace;
 
           MagickBooleanType
             verbose;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           geometry_info.rho=1.0;
           geometry_info.sigma=1.5;
           colorspace=sRGBColorspace;
           verbose=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'C':
                 case 'c':
                 {
                   if (LocaleCompare(keyword,""cluster-threshold"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   if (LocaleCompare(keyword,""colorspace"") == 0)
                     {
                       option=ParseCommandOption(MagickColorspaceOptions,
                         MagickFalse,value);
                       if (option < 0)
                         ThrowMSLException(OptionError,
                           ""UnrecognizedColorspaceType"",value);
                       colorspace=(ColorspaceType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.5;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""smoothing-threshold"") == 0)
                     {
                       geometry_info.sigma=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) SegmentImage(msl_info->image[n],colorspace,verbose,
             geometry_info.rho,geometry_info.sigma);
           break;
         }
       else if (LocaleCompare((const char *) tag, ""set"") == 0)
       {
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",(const char *) tag);
           break;
         }
 
         if (attributes == (const xmlChar **) NULL)
           break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
           keyword=(const char *) attributes[i++];
           CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
             msl_info->attributes[n],(const char *) attributes[i]));
           switch (*keyword)
           {
             case 'C':
             case 'c':
             {
               if (LocaleCompare(keyword,""clip-mask"") == 0)
                 {
                   for (j=0; j < msl_info->n; j++)
                   {
                     const char
                       *property;
 
                     property=GetImageProperty(msl_info->attributes[j],""id"");
                     if (LocaleCompare(property,value) == 0)
                       {
                         SetImageMask(msl_info->image[n],msl_info->image[j]);
                         break;
                       }
                   }
                   break;
                 }
               if (LocaleCompare(keyword,""clip-path"") == 0)
                 {
                   for (j=0; j < msl_info->n; j++)
                   {
                     const char
                       *property;
 
                     property=GetImageProperty(msl_info->attributes[j],""id"");
                     if (LocaleCompare(property,value) == 0)
                       {
                         SetImageClipMask(msl_info->image[n],msl_info->image[j]);
                         break;
                       }
                   }
                   break;
                 }
               if (LocaleCompare(keyword,""colorspace"") == 0)
                 {
                   ssize_t
                     colorspace;
 
                   colorspace=(ColorspaceType) ParseCommandOption(
                     MagickColorspaceOptions,MagickFalse,value);
                   if (colorspace < 0)
                     ThrowMSLException(OptionError,""UnrecognizedColorspace"",
                       value);
                   (void) TransformImageColorspace(msl_info->image[n],
                     (ColorspaceType) colorspace);
                   break;
                 }
               (void) SetMSLAttributes(msl_info,keyword,value);
               (void) SetImageProperty(msl_info->image[n],keyword,value);
               break;
             }
             case 'D':
             case 'd':
             {
               if (LocaleCompare(keyword,""density"") == 0)
                 {
                   flags=ParseGeometry(value,&geometry_info);
                   msl_info->image[n]->x_resolution=geometry_info.rho;
                   msl_info->image[n]->y_resolution=geometry_info.sigma;
                   if ((flags & SigmaValue) == 0)
                     msl_info->image[n]->y_resolution=
                       msl_info->image[n]->x_resolution;
                   break;
                 }
               (void) SetMSLAttributes(msl_info,keyword,value);
               (void) SetImageProperty(msl_info->image[n],keyword,value);
               break;
             }
             case 'O':
             case 'o':
             {
               if (LocaleCompare(keyword, ""opacity"") == 0)
                 {
                   ssize_t  opac = OpaqueOpacity,
                   len = (ssize_t) strlen( value );
 
                   if (value[len-1] == '%') {
                     char  tmp[100];
                     (void) CopyMagickString(tmp,value,len);
                     opac = StringToLong( tmp );
                     opac = (int)(QuantumRange * ((float)opac/100));
                   } else
                     opac = StringToLong( value );
                   (void) SetImageOpacity( msl_info->image[n], (Quantum) opac );
                   break;
               }
               (void) SetMSLAttributes(msl_info,keyword,value);
               (void) SetImageProperty(msl_info->image[n],keyword,value);
               break;
             }
             case 'P':
             case 'p':
             {
               if (LocaleCompare(keyword, ""page"") == 0)
               {
                 char
                   page[MaxTextExtent];
 
                 const char
                   *image_option;
 
                 MagickStatusType
                   flags;
 
                 RectangleInfo
                   geometry;
 
                 (void) ResetMagickMemory(&geometry,0,sizeof(geometry));
                 image_option=GetImageArtifact(msl_info->image[n],""page"");
                 if (image_option != (const char *) NULL)
                   flags=ParseAbsoluteGeometry(image_option,&geometry);
                 flags=ParseAbsoluteGeometry(value,&geometry);
                 (void) FormatLocaleString(page,MaxTextExtent,""%.20gx%.20g"",
                   (double) geometry.width,(double) geometry.height);
                 if (((flags & XValue) != 0) || ((flags & YValue) != 0))
                   (void) FormatLocaleString(page,MaxTextExtent,
                     ""%.20gx%.20g%+.20g%+.20g"",(double) geometry.width,
                     (double) geometry.height,(double) geometry.x,(double)
                     geometry.y);
                 (void) SetImageOption(msl_info->image_info[n],keyword,page);
                 msl_info->image_info[n]->page=GetPageGeometry(page);
                 break;
               }
               (void) SetMSLAttributes(msl_info,keyword,value);
               (void) SetImageProperty(msl_info->image[n],keyword,value);
               break;
             }
             default:
             {
               (void) SetMSLAttributes(msl_info,keyword,value);
               (void) SetImageProperty(msl_info->image[n],keyword,value);
               break;
             }
           }
         }
         break;
       }
       if (LocaleCompare((const char *) tag,""shade"") == 0)
         {
           Image
             *shade_image;
 
           MagickBooleanType
             gray;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           gray=MagickFalse;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'A':
                 case 'a':
                 {
                   if (LocaleCompare(keyword,""azimuth"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'E':
                 case 'e':
                 {
                   if (LocaleCompare(keyword,""elevation"") == 0)
                     {
                       geometry_info.sigma=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   if (LocaleCompare(keyword,""gray"") == 0)
                     {
                       option=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                         value);
                       if (option < 0)
                         ThrowMSLException(OptionError,""UnrecognizedNoiseType"",
                           value);
                       gray=(MagickBooleanType) option;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           shade_image=ShadeImage(msl_info->image[n],gray,geometry_info.rho,
             geometry_info.sigma,&msl_info->image[n]->exception);
           if (shade_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=shade_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""shadow"") == 0)
         {
           Image
             *shadow_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'O':
                 case 'o':
                 {
                   if (LocaleCompare(keyword,""opacity"") == 0)
                     {
                       geometry_info.rho=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'S':
                 case 's':
                 {
                   if (LocaleCompare(keyword,""sigma"") == 0)
                     {
                       geometry_info.sigma=StringToLong(value);
                       break;
                     }
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry_info.xi=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry_info.psi=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           shadow_image=ShadowImage(msl_info->image[n],geometry_info.rho,
             geometry_info.sigma,(ssize_t) ceil(geometry_info.xi-0.5),(ssize_t)
             ceil(geometry_info.psi-0.5),&msl_info->image[n]->exception);
           if (shadow_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=shadow_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""sharpen"") == 0)
       {
         double  radius = 0.0,
             sigma = 1.0;
 
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",
               (const char *) tag);
             break;
           }
          
         if (attributes != (const xmlChar **) NULL)
         {
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
           keyword=(const char *) attributes[i++];
           CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
             msl_info->attributes[n],(const char *) attributes[i]));
           switch (*keyword)
           {
             case 'R':
             case 'r':
             {
               if (LocaleCompare(keyword, ""radius"") == 0)
               {
                 radius = StringToDouble(value,(char **) NULL);
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             case 'S':
             case 's':
             {
               if (LocaleCompare(keyword,""sigma"") == 0)
               {
                 sigma = StringToLong( value );
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             default:
             {
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
           }
           }
         }
 
          
         {
         Image
           *newImage;
 
         newImage=SharpenImage(msl_info->image[n],radius,sigma,&msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         break;
         }
       }
       else if (LocaleCompare((const char *) tag,""shave"") == 0)
       {
          
         width = height = 0;
         x = y = 0;
 
         if (msl_info->image[n] == (Image *) NULL)
         {
           ThrowMSLException(OptionError,""NoImagesDefined"",
             (const char *) tag);
           break;
         }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'G':
           case 'g':
           {
           if (LocaleCompare(keyword,""geometry"") == 0)
             {
             (void) ParseMetaGeometry(value,&x,&y,&width,&height);
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'H':
           case 'h':
           {
           if (LocaleCompare(keyword,""height"") == 0)
             {
             height = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           case 'W':
           case 'w':
           {
           if (LocaleCompare(keyword,""width"") == 0)
             {
             width = StringToLong( value );
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         {
         Image
           *newImage;
         RectangleInfo
           rectInfo;
 
         rectInfo.height = height;
         rectInfo.width = width;
         rectInfo.x = x;
         rectInfo.y = y;
 
 
         newImage=ShaveImage(msl_info->image[n], &rectInfo,
           &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         }
 
         break;
       }
       if (LocaleCompare((const char *) tag,""shear"") == 0)
         {
           Image
             *shear_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'F':
                 case 'f':
                 {
                   if (LocaleCompare(keyword, ""fill"") == 0)
                     {
                       (void) QueryColorDatabase(value,
                         &msl_info->image[n]->background_color,exception);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'X':
                 case 'x':
                 {
                   if (LocaleCompare(keyword,""x"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'Y':
                 case 'y':
                 {
                   if (LocaleCompare(keyword,""y"") == 0)
                     {
                       geometry_info.sigma=StringToLong(value);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           shear_image=ShearImage(msl_info->image[n],geometry_info.rho,
             geometry_info.sigma,&msl_info->image[n]->exception);
           if (shear_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=shear_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""signature"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) SignatureImage(msl_info->image[n]);
           break;
         }
       if (LocaleCompare((const char *) tag,""solarize"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           geometry_info.rho=QuantumRange/2.0;
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'T':
                 case 't':
                 {
                   if (LocaleCompare(keyword,""threshold"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) SolarizeImage(msl_info->image[n],geometry_info.rho);
           break;
         }
       if (LocaleCompare((const char *) tag,""spread"") == 0)
         {
           Image
             *spread_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'R':
                 case 'r':
                 {
                   if (LocaleCompare(keyword,""radius"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           spread_image=SpreadImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (spread_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=spread_image;
           break;
         }
       else if (LocaleCompare((const char *) tag,""stegano"") == 0)
       {
         Image *
           watermark = (Image*) NULL;
 
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",
               (const char *) tag);
             break;
           }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'I':
           case 'i':
           {
           if (LocaleCompare(keyword,""image"") == 0)
             {
             for (j=0; j<msl_info->n;j++)
             {
               const char *
                 theAttr = GetImageProperty(msl_info->attributes[j], ""id"");
               if (theAttr && LocaleCompare(theAttr, value) == 0)
               {
                 watermark = msl_info->image[j];
                 break;
               }
             }
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         if ( watermark != (Image*) NULL )
         {
         Image
           *newImage;
 
         newImage=SteganoImage(msl_info->image[n], watermark, &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         break;
         } else
           ThrowMSLException(OptionError,""MissingWatermarkImage"",keyword);
       }
       else if (LocaleCompare((const char *) tag,""stereo"") == 0)
       {
         Image *
           stereoImage = (Image*) NULL;
 
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",(const char *) tag);
             break;
           }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'I':
           case 'i':
           {
           if (LocaleCompare(keyword,""image"") == 0)
             {
             for (j=0; j<msl_info->n;j++)
             {
               const char *
                 theAttr = GetImageProperty(msl_info->attributes[j], ""id"");
               if (theAttr && LocaleCompare(theAttr, value) == 0)
               {
                 stereoImage = msl_info->image[j];
                 break;
               }
             }
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         if ( stereoImage != (Image*) NULL )
         {
         Image
           *newImage;
 
         newImage=StereoImage(msl_info->image[n], stereoImage, &msl_info->image[n]->exception);
         if (newImage == (Image *) NULL)
           break;
         msl_info->image[n]=DestroyImage(msl_info->image[n]);
         msl_info->image[n]=newImage;
         break;
         } else
           ThrowMSLException(OptionError,""Missing stereo image"",keyword);
       }
       if (LocaleCompare((const char *) tag,""strip"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             }
           (void) StripImage(msl_info->image[n]);
           break;
         }
       if (LocaleCompare((const char *) tag,""swap"") == 0)
         {
           Image
             *p,
             *q,
             *swap;
 
           ssize_t
             index,
             swap_index;
 
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           index=(-1);
           swap_index=(-2);
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""indexes"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       index=(ssize_t) geometry_info.rho;
                       if ((flags & SigmaValue) == 0)
                         swap_index=(ssize_t) geometry_info.sigma;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
            
           p=GetImageFromList(msl_info->image[n],index);
           q=GetImageFromList(msl_info->image[n],swap_index);
           if ((p == (Image *) NULL) || (q == (Image *) NULL))
             {
               ThrowMSLException(OptionError,""NoSuchImage"",(const char *) tag);
               break;
             }
           swap=CloneImage(p,0,0,MagickTrue,&p->exception);
           ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,&q->exception));
           ReplaceImageInList(&q,swap);
           msl_info->image[n]=GetFirstImageInList(q);
           break;
         }
       if (LocaleCompare((const char *) tag,""swirl"") == 0)
         {
           Image
             *swirl_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'D':
                 case 'd':
                 {
                   if (LocaleCompare(keyword,""degrees"") == 0)
                     {
                       geometry_info.rho=StringToDouble(value,
                         (char **) NULL);
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 case 'G':
                 case 'g':
                 {
                   if (LocaleCompare(keyword,""geometry"") == 0)
                     {
                       flags=ParseGeometry(value,&geometry_info);
                       if ((flags & SigmaValue) == 0)
                         geometry_info.sigma=1.0;
                       break;
                     }
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           swirl_image=SwirlImage(msl_info->image[n],geometry_info.rho,
             &msl_info->image[n]->exception);
           if (swirl_image == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=swirl_image;
           break;
         }
       if (LocaleCompare((const char *) tag,""sync"") == 0)
         {
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) SyncImage(msl_info->image[n]);
           break;
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'T':
     case 't':
     {
       if (LocaleCompare((const char *) tag,""map"") == 0)
         {
           Image
             *texture_image;
 
            
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           texture_image=NewImageList();
           if (attributes != (const xmlChar **) NULL)
             for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
             {
               keyword=(const char *) attributes[i++];
               attribute=InterpretImageProperties(msl_info->image_info[n],
                 msl_info->attributes[n],(const char *) attributes[i]);
               CloneString(&value,attribute);
               switch (*keyword)
               {
                 case 'I':
                 case 'i':
                 {
                   if (LocaleCompare(keyword,""image"") == 0)
                     for (j=0; j < msl_info->n; j++)
                     {
                       const char
                         *attribute;
 
                       attribute=GetImageProperty(msl_info->attributes[j],""id"");
                       if ((attribute != (const char *) NULL)  &&
                           (LocaleCompare(attribute,value) == 0))
                         {
                           texture_image=CloneImage(msl_info->image[j],0,0,
                             MagickFalse,exception);
                           break;
                         }
                     }
                   break;
                 }
                 default:
                 {
                   ThrowMSLException(OptionError,""UnrecognizedAttribute"",
                     keyword);
                   break;
                 }
               }
             }
           (void) TextureImage(msl_info->image[n],texture_image);
           texture_image=DestroyImage(texture_image);
           break;
         }
       else if (LocaleCompare((const char *) tag,""threshold"") == 0)
       {
          
         double  threshold = 0;
 
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",(const char *) tag);
             break;
           }
         if (attributes == (const xmlChar **) NULL)
         break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
         keyword=(const char *) attributes[i++];
         CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
           msl_info->attributes[n],(const char *) attributes[i]));
         switch (*keyword)
         {
           case 'T':
           case 't':
           {
           if (LocaleCompare(keyword,""threshold"") == 0)
             {
             threshold = StringToDouble(value,(char **) NULL);
             break;
             }
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
           default:
           {
           ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
           break;
           }
         }
         }
 
          
         {
         BilevelImageChannel(msl_info->image[n],
           (ChannelType) ((ssize_t) (CompositeChannels &~ (ssize_t) OpacityChannel)),
           threshold);
         break;
         }
       }
       else if (LocaleCompare((const char *) tag, ""transparent"") == 0)
       {
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",(const char *) tag);
             break;
           }
         if (attributes == (const xmlChar **) NULL)
           break;
         for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
         {
           keyword=(const char *) attributes[i++];
           CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
             msl_info->attributes[n],(const char *) attributes[i]));
           switch (*keyword)
           {
             case 'C':
             case 'c':
             {
               if (LocaleCompare(keyword,""color"") == 0)
               {
                 MagickPixelPacket
                   target;
 
                 (void) QueryMagickColor(value,&target,exception);
                 (void) TransparentPaintImage(msl_info->image[n],&target,
                   TransparentOpacity,MagickFalse);
                 break;
               }
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
               break;
             }
             default:
             {
               ThrowMSLException(OptionError,""UnrecognizedAttribute"",keyword);
             break;
             }
           }
         }
         break;
       }
       else if (LocaleCompare((const char *) tag, ""trim"") == 0)
       {
         if (msl_info->image[n] == (Image *) NULL)
           {
             ThrowMSLException(OptionError,""NoImagesDefined"",(const char *) tag);
             break;
           }
 
          
 
          
         {
           Image
             *newImage;
           RectangleInfo
             rectInfo;
 
            
           rectInfo.height = rectInfo.width = 0;
           rectInfo.x =  rectInfo.y = 0;
 
           newImage=CropImage(msl_info->image[n],&rectInfo, &msl_info->image[n]->exception);
           if (newImage == (Image *) NULL)
             break;
           msl_info->image[n]=DestroyImage(msl_info->image[n]);
           msl_info->image[n]=newImage;
           break;
         }
       }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     case 'W':
     case 'w':
     {
       if (LocaleCompare((const char *) tag,""write"") == 0)
         {
           if (msl_info->image[n] == (Image *) NULL)
             {
               ThrowMSLException(OptionError,""NoImagesDefined"",
                 (const char *) tag);
               break;
             }
           if (attributes == (const xmlChar **) NULL)
             break;
           for (i=0; (attributes[i] != (const xmlChar *) NULL); i++)
           {
             keyword=(const char *) attributes[i++];
             CloneString(&value,InterpretImageProperties(msl_info->image_info[n],
               msl_info->attributes[n],(const char *) attributes[i]));
             switch (*keyword)
             {
               case 'F':
               case 'f':
               {
                 if (LocaleCompare(keyword,""filename"") == 0)
                   {
                     (void) CopyMagickString(msl_info->image[n]->filename,value,
                       MaxTextExtent);
                     break;
                   }
                 (void) SetMSLAttributes(msl_info,keyword,value);
               }
               default:
               {
                 (void) SetMSLAttributes(msl_info,keyword,value);
                 break;
               }
             }
           }
 
            
           {
             *msl_info->image_info[n]->magick='\0';
             (void) WriteImage(msl_info->image_info[n], msl_info->image[n]);
             break;
           }
         }
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
     }
     default:
     {
       ThrowMSLException(OptionError,""UnrecognizedElement"",(const char *) tag);
       break;
     }
   }
   if ( value != NULL )
     value=DestroyString(value);
   exception=DestroyExceptionInfo(exception);
   (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  )"");
 }","[4317, 4318]",The MSL interpreter in ImageMagick before 6.9.6-4 allows remote attackers to cause a denial of service (segmentation fault and application crash) via a crafted XML file.
202193," static void t1_check_unusual_charstring(void)
 {
     char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);
     int i;
      
      if (sscanf(p, ""%i"", &i) != 1) {
          strcpy(t1_buf_array, t1_line_array);
          t1_getline();
         alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);
          strcat(t1_buf_array, t1_line_array);
         alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);
          strcpy(t1_line_array, t1_buf_array);
          t1_line_ptr = eol(t1_line_array);
      }
 }","[9, 11]","An issue was discovered in t1_check_unusual_charstring functions in writet1.c files in TeX Live before 2018-09-21. A buffer overflow in the handling of Type 1 fonts allows arbitrary code execution when a malicious font is loaded by one of the vulnerable tools: pdflatex, pdftex, dvips, or luatex."
202547," struct key *find_keyring_by_name(const char *name, bool skip_perm_check)
 struct key *find_keyring_by_name(const char *name, bool uid_keyring)
  {
  	struct key *keyring;
  	int bucket;
 
 	if (!name)
 		return ERR_PTR(-EINVAL);
 
 	bucket = keyring_hash(name);
 
 	read_lock(&keyring_name_lock);
 
 	if (keyring_name_hash[bucket].next) {
 		 
 		list_for_each_entry(keyring,
 				    &keyring_name_hash[bucket],
 				    name_link
 				    ) {
 			if (!kuid_has_mapping(current_user_ns(), keyring->user->uid))
 				continue;
 
 			if (test_bit(KEY_FLAG_REVOKED, &keyring->flags))
 				continue;
 
  			if (strcmp(keyring->description, name) != 0)
  				continue;
  
			if (!skip_perm_check &&
			    key_permission(make_key_ref(keyring, 0),
					   KEY_NEED_SEARCH) < 0)
				continue;
 			if (uid_keyring) {
 				if (!test_bit(KEY_FLAG_UID_KEYRING,
 					      &keyring->flags))
 					continue;
 			} else {
 				if (key_permission(make_key_ref(keyring, 0),
 						   KEY_NEED_SEARCH) < 0)
 					continue;
 			}
  
  			 
 			if (!refcount_inc_not_zero(&keyring->usage))
 				continue;
 			keyring->last_used_at = current_kernel_time().tv_sec;
 			goto out;
 		}
 	}
 
 	keyring = ERR_PTR(-ENOKEY);
 out:
 	read_unlock(&keyring_name_lock);
 	return keyring;
 }","[2, 33, 34, 35, 36, 37, 38, 39, 40, 41, 29, 30, 31, 32]","In the Linux kernel before 4.13.5, a local user could create keyrings for other users via keyctl commands, setting unwanted defaults or causing a denial of service."
199533," mprint(struct magic_set *ms, struct magic *m)
 {
 	uint64_t v;
 	float vf;
 	double vd;
 	int64_t t = 0;
  	char buf[128], tbuf[26];
 	union VALUETYPE *p = &ms->ms_value;
 
   	switch (m->type) {
   	case FILE_BYTE:
 		v = file_signextend(ms, m, (uint64_t)p->b);
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%d"",
 			    (unsigned char)v);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%d""),
 			    (unsigned char) v) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(char);
 		break;
 
   	case FILE_SHORT:
   	case FILE_BESHORT:
   	case FILE_LESHORT:
 		v = file_signextend(ms, m, (uint64_t)p->h);
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%u"",
 			    (unsigned short)v);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%u""),
 			    (unsigned short) v) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(short);
 		break;
 
   	case FILE_LONG:
   	case FILE_BELONG:
   	case FILE_LELONG:
   	case FILE_MELONG:
 		v = file_signextend(ms, m, (uint64_t)p->l);
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%u"", (uint32_t) v);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%u""), (uint32_t) v) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(int32_t);
   		break;
 
   	case FILE_QUAD:
   	case FILE_BEQUAD:
   	case FILE_LEQUAD:
 		v = file_signextend(ms, m, p->q);
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%"" INT64_T_FORMAT ""u"",
 			    (unsigned long long)v);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%"" INT64_T_FORMAT ""u""),
 			    (unsigned long long) v) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(int64_t);
   		break;
 
   	case FILE_STRING:
   	case FILE_PSTRING:
   	case FILE_BESTRING16:
   	case FILE_LESTRING16:
 		if (m->reln == '=' || m->reln == '!') {
 			if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1)
 				return -1;
 			t = ms->offset + m->vallen;
 		}
 		else {
 			char *str = p->s;
 
 			 
 			t = ms->offset + strlen(str);
 
 			if (*m->value.s == '\0')
 				str[strcspn(str, ""\n"")] = '\0';
 
 			if (m->str_flags & STRING_TRIM) {
 				char *last;
 				while (isspace((unsigned char)*str))
 					str++;
 				last = str;
 				while (*last)
 					last++;
 				--last;
 				while (isspace((unsigned char)*last))
 					last--;
 				*++last = '\0';
 			}
 
 			if (file_printf(ms, F(ms, m, ""%s""), str) == -1)
 				return -1;
 
 			if (m->type == FILE_PSTRING)
 				t += file_pstring_length_size(m);
 		}
 		break;
 
 	case FILE_DATE:
 	case FILE_BEDATE:
  	case FILE_LEDATE:
  	case FILE_MEDATE:
  		if (file_printf(ms, F(ms, m, ""%s""),
		    file_fmttime(p->l, FILE_T_LOCAL, tbuf)) == -1)
 		    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)
  			return -1;
  		t = ms->offset + sizeof(uint32_t);
  		break;
 
 	case FILE_LDATE:
 	case FILE_BELDATE:
  	case FILE_LELDATE:
  	case FILE_MELDATE:
  		if (file_printf(ms, F(ms, m, ""%s""),
		    file_fmttime(p->l, 0, tbuf)) == -1)
 		    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)
  			return -1;
  		t = ms->offset + sizeof(uint32_t);
  		break;
 
 	case FILE_QDATE:
  	case FILE_BEQDATE:
  	case FILE_LEQDATE:
  		if (file_printf(ms, F(ms, m, ""%s""),
		    file_fmttime(p->q, FILE_T_LOCAL, tbuf)) == -1)
 		    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)
  			return -1;
  		t = ms->offset + sizeof(uint64_t);
  		break;
 
 	case FILE_QLDATE:
  	case FILE_BEQLDATE:
  	case FILE_LEQLDATE:
  		if (file_printf(ms, F(ms, m, ""%s""),
		    file_fmttime(p->q, 0, tbuf)) == -1)
 		    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)
  			return -1;
  		t = ms->offset + sizeof(uint64_t);
  		break;
 
 	case FILE_QWDATE:
  	case FILE_BEQWDATE:
  	case FILE_LEQWDATE:
  		if (file_printf(ms, F(ms, m, ""%s""),
		    file_fmttime(p->q, FILE_T_WINDOWS, tbuf)) == -1)
 		    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)
  			return -1;
  		t = ms->offset + sizeof(uint64_t);
  		break;
 
   	case FILE_FLOAT:
   	case FILE_BEFLOAT:
   	case FILE_LEFLOAT:
 		vf = p->f;
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%g"", vf);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%g""), vf) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(float);
   		break;
 
   	case FILE_DOUBLE:
   	case FILE_BEDOUBLE:
   	case FILE_LEDOUBLE:
 		vd = p->d;
 		switch (check_fmt(ms, m)) {
 		case -1:
 			return -1;
 		case 1:
 			(void)snprintf(buf, sizeof(buf), ""%g"", vd);
 			if (file_printf(ms, F(ms, m, ""%s""), buf) == -1)
 				return -1;
 			break;
 		default:
 			if (file_printf(ms, F(ms, m, ""%g""), vd) == -1)
 				return -1;
 			break;
 		}
 		t = ms->offset + sizeof(double);
   		break;
 
 	case FILE_REGEX: {
 		char *cp;
 		int rval;
 
 		cp = strndup((const char *)ms->search.s, ms->search.rm_len);
 		if (cp == NULL) {
 			file_oomem(ms, ms->search.rm_len);
 			return -1;
 		}
 		rval = file_printf(ms, F(ms, m, ""%s""), cp);
 		free(cp);
 
 		if (rval == -1)
 			return -1;
 
 		if ((m->str_flags & REGEX_OFFSET_START))
 			t = ms->search.offset;
 		else
 			t = ms->search.offset + ms->search.rm_len;
 		break;
 	}
 
 	case FILE_SEARCH:
 	  	if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1)
 			return -1;
 		if ((m->str_flags & REGEX_OFFSET_START))
 			t = ms->search.offset;
 		else
 			t = ms->search.offset + m->vallen;
 		break;
 
 	case FILE_DEFAULT:
 	case FILE_CLEAR:
 	  	if (file_printf(ms, ""%s"", m->desc) == -1)
 			return -1;
 		t = ms->offset;
 		break;
 
 	case FILE_INDIRECT:
 	case FILE_USE:
 	case FILE_NAME:
 		t = ms->offset;
 		break;
 
 	default:
 		file_magerror(ms, ""invalid m->type (%d) in mprint()"", m->type);
 		return -1;
 	}
 	return (int32_t)t;
 }","[141, 152, 162, 172, 182, 140, 151, 161, 171, 181]","file before 5.19 does not properly restrict the amount of data read during a regex search, which allows remote attackers to cause a denial of service (CPU consumption) via a crafted file that triggers backtracking during processing of an awk rule.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2013-7345."
198737," static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,
  			 struct ipcm_cookie *ipc, struct rtable **rtp)
  {
  	struct inet_sock *inet = inet_sk(sk);
	struct ip_options *opt;
 	struct ip_options_rcu *opt;
  	struct rtable *rt;
  
  	 
 	opt = ipc->opt;
 	if (opt) {
 		if (cork->opt == NULL) {
 			cork->opt = kmalloc(sizeof(struct ip_options) + 40,
 					    sk->sk_allocation);
  			if (unlikely(cork->opt == NULL))
  				return -ENOBUFS;
  		}
		memcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);
 		memcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);
  		cork->flags |= IPCORK_OPT;
  		cork->addr = ipc->addr;
  	}
 	rt = *rtp;
 	if (unlikely(!rt))
 		return -EFAULT;
 	 
 	*rtp = NULL;
 	cork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?
 			 rt->dst.dev->mtu : dst_mtu(rt->dst.path);
 	cork->dst = &rt->dst;
 	cork->length = 0;
 	cork->tx_flags = ipc->tx_flags;
 	cork->page = NULL;
 	cork->off = 0;
 
 	return 0;
 }","[6, 19, 5, 18]",Race condition in the IP implementation in the Linux kernel before 3.0 might allow remote attackers to cause a denial of service (slab corruption and system crash) by sending packets to an application that sets socket options during the handling of network traffic.
206403," void PageInfo::GetSafeBrowsingStatusByMaliciousContentStatus(
 void PageInfo::GetSiteIdentityByMaliciousContentStatus(
      security_state::MaliciousContentStatus malicious_content_status,
    PageInfo::SafeBrowsingStatus* status,
     PageInfo::SiteIdentityStatus* status,
      base::string16* details) {
    switch (malicious_content_status) {
      case security_state::MALICIOUS_CONTENT_STATUS_NONE:
        NOTREACHED();
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_MALWARE:
      *status = PageInfo::SAFE_BROWSING_STATUS_MALWARE;
       *status = PageInfo::SITE_IDENTITY_STATUS_MALWARE;
        *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_MALWARE_DETAILS);
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_SOCIAL_ENGINEERING:
      *status = PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING;
       *status = PageInfo::SITE_IDENTITY_STATUS_SOCIAL_ENGINEERING;
        *details =
            l10n_util::GetStringUTF16(IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_UNWANTED_SOFTWARE:
      *status = PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE;
       *status = PageInfo::SITE_IDENTITY_STATUS_UNWANTED_SOFTWARE;
        *details =
            l10n_util::GetStringUTF16(IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_SIGN_IN_PASSWORD_REUSE:
  #if defined(FULL_SAFE_BROWSING)
      *status = PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE;
       *status = PageInfo::SITE_IDENTITY_STATUS_SIGN_IN_PASSWORD_REUSE;
        *details = password_protection_service_
                       ? password_protection_service_->GetWarningDetailText(
                            PasswordReuseEvent::SIGN_IN_PASSWORD)
                      : base::string16();
 #endif
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_ENTERPRISE_PASSWORD_REUSE:
  #if defined(FULL_SAFE_BROWSING)
      *status = PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE;
       *status = PageInfo::SITE_IDENTITY_STATUS_ENTERPRISE_PASSWORD_REUSE;
        *details = password_protection_service_
                       ? password_protection_service_->GetWarningDetailText(
                            PasswordReuseEvent::ENTERPRISE_PASSWORD)
                      : base::string16();
  #endif
        break;
      case security_state::MALICIOUS_CONTENT_STATUS_BILLING:
      *status = PageInfo::SAFE_BROWSING_STATUS_BILLING;
       *status = PageInfo::SITE_IDENTITY_STATUS_BILLING;
        *details = l10n_util::GetStringUTF16(IDS_PAGE_INFO_BILLING_DETAILS);
        break;
    }
 }","[2, 5, 13, 18, 24, 31, 41, 50, 4, 12, 17, 23, 30, 40, 49]","Cast in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android sent cookies to sites discovered via SSDP, which allowed an attacker on the local network segment to initiate connections to arbitrary URLs and observe any plaintext cookies sent."
204264," void ThreadableBlobRegistry::unregisterBlobURL(const KURL& url)
 void BlobRegistry::unregisterBlobURL(const KURL& url)
  {
      if (BlobURL::getOrigin(url) == ""null"")
          originMap()->remove(url.string());
  
    if (isMainThread())
        blobRegistry().unregisterBlobURL(url);
    else {
     if (isMainThread()) {
         if (WebBlobRegistry* registry = blobRegistry())
             registry->unregisterBlobURL(url);
     } else {
          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url));
          callOnMainThread(&unregisterBlobURLTask, context.leakPtr());
      }
 }","[2, 10, 11, 12, 13, 7, 8, 9]","Google Chrome before 23.0.1271.91 on Mac OS X does not properly mitigate improper rendering behavior in the Intel GPU driver, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
2740,"int perf_event_task_disable(void)
{
struct perf_event *event;

mutex_lock(&current->perf_event_mutex);
list_for_each_entry(event, &current->perf_event_list, owner_entry)
perf_event_for_each_child(event, perf_event_disable);
mutex_unlock(&current->perf_event_mutex);

return 0;
}","[3, 6, 7]","kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 30955111."
202486," SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
 {
     SQLWCHAR *chr;
     int len = 0;
  
      if ( !in )
      {
        return in;
         return NULL;
      }
      
      while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
     {
         len ++;
     }
 
     chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));
 
     len = 0;
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
     {
         chr[ len ] = in[ len ];
         len ++;
     }
     chr[ len ++ ] = 0;
     chr[ len ++ ] = 0;
 
     return chr;
 }","[9, 8]","The SQLWriteFileDSN function in odbcinst/SQLWriteFileDSN.c in unixODBC 2.3.5 has strncpy arguments in the wrong order, which allows attackers to cause a denial of service or possibly have unspecified other impact."
200109," php_mysqlnd_rowp_read_text_protocol_aux(MYSQLND_MEMORY_POOL_CHUNK * row_buffer, zval ** fields,
 									unsigned int field_count, const MYSQLND_FIELD * fields_metadata,
 									zend_bool as_int_or_float, zend_bool copy_data, MYSQLND_STATS * stats TSRMLS_DC)
 {
 	
 	unsigned int i;
 	zend_bool last_field_was_string = FALSE;
 	zval **current_field, **end_field, **start_field;
  	zend_uchar * p = row_buffer->ptr;
  	size_t data_size = row_buffer->app;
  	zend_uchar * bit_area = (zend_uchar*) row_buffer->ptr + data_size + 1;  
 	const zend_uchar * const packet_end = (zend_uchar*) row_buffer->ptr + data_size;
  
  	DBG_ENTER(""php_mysqlnd_rowp_read_text_protocol_aux"");
  
 	if (!fields) {
 		DBG_RETURN(FAIL);
 	}
 
 	end_field = (start_field = fields) + field_count;
 
 	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
 		DBG_INF(""Directly creating zval"");
 		MAKE_STD_ZVAL(*current_field);
 		if (!*current_field) {
 			DBG_RETURN(FAIL);
 		}
 	}
 
 	for (i = 0, current_field = start_field; current_field < end_field; current_field++, i++) {
  		 
  		zend_uchar *this_field_len_pos = p;
  		 
		unsigned long len = php_mysqlnd_net_field_length(&p);
 		const unsigned long len = php_mysqlnd_net_field_length(&p);
  
 		if (len != MYSQLND_NULL_LENGTH && ((p + len) > packet_end)) {
 			php_error_docref(NULL, E_WARNING, ""Malformed server packet. Field length pointing ""MYSQLND_SZ_T_SPEC
 											  "" bytes after end of packet"", (p + len) - packet_end - 1);
 			DBG_RETURN(FAIL);
 		}
  		if (copy_data == FALSE && current_field > start_field && last_field_was_string) {
  			 
 
 			*this_field_len_pos = '\0';
 		}
 
 		 
 		if (len == MYSQLND_NULL_LENGTH) {
 			ZVAL_NULL(*current_field);
 			last_field_was_string = FALSE;
 		} else {
 #if defined(MYSQLND_STRING_TO_INT_CONVERSION)
 			struct st_mysqlnd_perm_bind perm_bind =
 					mysqlnd_ps_fetch_functions[fields_metadata[i].type];
 #endif
 			if (MYSQLND_G(collect_statistics)) {
 				enum_mysqlnd_collected_stats statistic;
 				switch (fields_metadata[i].type) {
 					case MYSQL_TYPE_DECIMAL:	statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;
 					case MYSQL_TYPE_TINY:		statistic = STAT_TEXT_TYPE_FETCHED_INT8; break;
 					case MYSQL_TYPE_SHORT:		statistic = STAT_TEXT_TYPE_FETCHED_INT16; break;
 					case MYSQL_TYPE_LONG:		statistic = STAT_TEXT_TYPE_FETCHED_INT32; break;
 					case MYSQL_TYPE_FLOAT:		statistic = STAT_TEXT_TYPE_FETCHED_FLOAT; break;
 					case MYSQL_TYPE_DOUBLE:		statistic = STAT_TEXT_TYPE_FETCHED_DOUBLE; break;
 					case MYSQL_TYPE_NULL:		statistic = STAT_TEXT_TYPE_FETCHED_NULL; break;
 					case MYSQL_TYPE_TIMESTAMP:	statistic = STAT_TEXT_TYPE_FETCHED_TIMESTAMP; break;
 					case MYSQL_TYPE_LONGLONG:	statistic = STAT_TEXT_TYPE_FETCHED_INT64; break;
 					case MYSQL_TYPE_INT24:		statistic = STAT_TEXT_TYPE_FETCHED_INT24; break;
 					case MYSQL_TYPE_DATE:		statistic = STAT_TEXT_TYPE_FETCHED_DATE; break;
 					case MYSQL_TYPE_TIME:		statistic = STAT_TEXT_TYPE_FETCHED_TIME; break;
 					case MYSQL_TYPE_DATETIME:	statistic = STAT_TEXT_TYPE_FETCHED_DATETIME; break;
 					case MYSQL_TYPE_YEAR:		statistic = STAT_TEXT_TYPE_FETCHED_YEAR; break;
 					case MYSQL_TYPE_NEWDATE:	statistic = STAT_TEXT_TYPE_FETCHED_DATE; break;
 					case MYSQL_TYPE_VARCHAR:	statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
 					case MYSQL_TYPE_BIT:		statistic = STAT_TEXT_TYPE_FETCHED_BIT; break;
 					case MYSQL_TYPE_NEWDECIMAL:	statistic = STAT_TEXT_TYPE_FETCHED_DECIMAL; break;
 					case MYSQL_TYPE_ENUM:		statistic = STAT_TEXT_TYPE_FETCHED_ENUM; break;
 					case MYSQL_TYPE_SET:		statistic = STAT_TEXT_TYPE_FETCHED_SET; break;
 					case MYSQL_TYPE_JSON:		statistic = STAT_TEXT_TYPE_FETCHED_JSON; break;
 					case MYSQL_TYPE_TINY_BLOB:	statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
 					case MYSQL_TYPE_MEDIUM_BLOB:statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
 					case MYSQL_TYPE_LONG_BLOB:	statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
 					case MYSQL_TYPE_BLOB:		statistic = STAT_TEXT_TYPE_FETCHED_BLOB; break;
 					case MYSQL_TYPE_VAR_STRING:	statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
 					case MYSQL_TYPE_STRING:		statistic = STAT_TEXT_TYPE_FETCHED_STRING; break;
 					case MYSQL_TYPE_GEOMETRY:	statistic = STAT_TEXT_TYPE_FETCHED_GEOMETRY; break;
 					default: statistic = STAT_TEXT_TYPE_FETCHED_OTHER; break;
 				}
 				MYSQLND_INC_CONN_STATISTIC_W_VALUE2(stats, statistic, 1, STAT_BYTES_RECEIVED_PURE_DATA_TEXT, len);
 			}
 #ifdef MYSQLND_STRING_TO_INT_CONVERSION
 			if (as_int_or_float && perm_bind.php_type == IS_LONG) {
 				zend_uchar save = *(p + len);
 				 
 				*(p + len) = '\0';
 				if (perm_bind.pack_len < SIZEOF_LONG) {
 					 
 					int64_t v =
 #ifndef PHP_WIN32
 						atoll((char *) p);
 #else
 						_atoi64((char *) p);
 #endif
 					ZVAL_LONG(*current_field, (long) v);  
 				} else {
 					uint64_t v =
 #ifndef PHP_WIN32
 						(uint64_t) atoll((char *) p);
 #else
 						(uint64_t) _atoi64((char *) p);
 #endif
 					zend_bool uns = fields_metadata[i].flags & UNSIGNED_FLAG? TRUE:FALSE;
 					 
 #if SIZEOF_LONG==8
 					if (uns == TRUE && v > 9223372036854775807L)
 #elif SIZEOF_LONG==4
 					if ((uns == TRUE && v > L64(2147483647)) ||
 						(uns == FALSE && (( L64(2147483647) < (int64_t) v) ||
 						(L64(-2147483648) > (int64_t) v))))
 #else
 #error Need fix for this architecture
 #endif  
 					{
 						ZVAL_STRINGL(*current_field, (char *)p, len, 0);
 					} else {
 						ZVAL_LONG(*current_field, (long) v);  
 					}
 				}
 				*(p + len) = save;
 			} else if (as_int_or_float && perm_bind.php_type == IS_DOUBLE) {
 				zend_uchar save = *(p + len);
 				 
 				*(p + len) = '\0';
 				ZVAL_DOUBLE(*current_field, atof((char *) p));
 				*(p + len) = save;
 			} else
 #endif  
 			if (fields_metadata[i].type == MYSQL_TYPE_BIT) {
 				 
 				zend_uchar *start = bit_area;
 				ps_fetch_from_1_to_8_bytes(*current_field, &(fields_metadata[i]), 0, &p, len TSRMLS_CC);
 				 
 				p -= len;
 				if (Z_TYPE_PP(current_field) == IS_LONG) {
 					bit_area += 1 + sprintf((char *)start, ""%ld"", Z_LVAL_PP(current_field));
 					ZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);
 				} else if (Z_TYPE_PP(current_field) == IS_STRING){
 					memcpy(bit_area, Z_STRVAL_PP(current_field), Z_STRLEN_PP(current_field));
 					bit_area += Z_STRLEN_PP(current_field);
 					*bit_area++ = '\0';
 					zval_dtor(*current_field);
 					ZVAL_STRINGL(*current_field, (char *) start, bit_area - start - 1, copy_data);
 				}
 			} else {
 				ZVAL_STRINGL(*current_field, (char *)p, len, copy_data);
 			}
 			p += len;
 			last_field_was_string = TRUE;
 		}
 	}
 	if (copy_data == FALSE && last_field_was_string) {
 		 
 		row_buffer->ptr[data_size] = '\0';
 	}
 
 	DBG_RETURN(PASS);
 }","[12, 35, 37, 38, 39, 40, 41, 34]","ext/mysqlnd/mysqlnd_wireprotocol.c in PHP before 5.6.26 and 7.x before 7.0.11 does not verify that a BIT field has the UNSIGNED_FLAG flag, which allows remote MySQL servers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted field metadata."
201181," static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,
   const ImageInfo *IMimage_info,Image *IMimage,ExceptionInfo *exception)
 {
   char
     im_vers[32],
     libpng_runv[32],
     libpng_vers[32],
     zlib_runv[32],
     zlib_vers[32];
 
   Image
     *image;
 
   ImageInfo
     *image_info;
 
   char
     s[2];
 
   const char
     *name,
     *property,
     *value;
 
   const StringInfo
     *profile;
 
   int
     num_passes,
     pass,
     ping_wrote_caNv;
 
   png_byte
      ping_trans_alpha[256];
 
   png_color
      palette[257];
 
   png_color_16
     ping_background,
     ping_trans_color;
 
   png_info
     *ping_info;
 
   png_struct
     *ping;
 
   png_uint_32
     ping_height,
     ping_width;
 
   ssize_t
     y;
 
   MagickBooleanType
     image_matte,
     logging,
     matte,
 
     ping_have_blob,
     ping_have_cheap_transparency,
     ping_have_color,
     ping_have_non_bw,
     ping_have_PLTE,
     ping_have_bKGD,
     ping_have_eXIf,
     ping_have_iCCP,
     ping_have_pHYs,
     ping_have_sRGB,
     ping_have_tRNS,
 
     ping_exclude_bKGD,
     ping_exclude_cHRM,
     ping_exclude_date,
      
     ping_exclude_eXIf,
     ping_exclude_gAMA,
     ping_exclude_iCCP,
      
     ping_exclude_oFFs,
     ping_exclude_pHYs,
     ping_exclude_sRGB,
     ping_exclude_tEXt,
     ping_exclude_tIME,
      
     ping_exclude_vpAg,
     ping_exclude_caNv,
     ping_exclude_zCCP,  
     ping_exclude_zTXt,
 
     ping_preserve_colormap,
     ping_preserve_iCCP,
     ping_need_colortype_warning,
 
     status,
     tried_332,
     tried_333,
     tried_444;
 
   MemoryInfo
     *volatile pixel_info;
 
   QuantumInfo
     *quantum_info;
 
   PNGErrorInfo
     error_info;
 
   register ssize_t
     i,
     x;
 
   unsigned char
     *ping_pixels;
 
   volatile int
     image_colors,
     ping_bit_depth,
     ping_color_type,
     ping_interlace_method,
     ping_compression_method,
     ping_filter_method,
     ping_num_trans;
 
   volatile size_t
     image_depth,
     old_bit_depth;
 
   size_t
     quality,
     rowbytes,
     save_image_depth;
 
   int
     j,
     number_colors,
     number_opaque,
     number_semitransparent,
     number_transparent,
     ping_pHYs_unit_type;
 
   png_uint_32
     ping_pHYs_x_resolution,
     ping_pHYs_y_resolution;
 
   logging=LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Enter WriteOnePNGImage()"");
  
    image = CloneImage(IMimage,0,0,MagickFalse,exception);
   if (image == (Image *) NULL)
     return(MagickFalse);
    image_info=(ImageInfo *) CloneImageInfo(IMimage_info);
    if (image_info == (ImageInfo *) NULL)
     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
     ThrowWriterException(ResourceLimitError, ""MemoryAllocationFailed"");
  
     
   *im_vers='\0';
   (void) ConcatenateMagickString(im_vers,
          MagickLibVersionText,MagickPathExtent);
   (void) ConcatenateMagickString(im_vers,
          MagickLibAddendum,MagickPathExtent);
 
   *libpng_vers='\0';
   (void) ConcatenateMagickString(libpng_vers,
          PNG_LIBPNG_VER_STRING,32);
   *libpng_runv='\0';
   (void) ConcatenateMagickString(libpng_runv,
          png_get_libpng_ver(NULL),32);
 
   *zlib_vers='\0';
   (void) ConcatenateMagickString(zlib_vers,
          ZLIB_VERSION,32);
   *zlib_runv='\0';
   (void) ConcatenateMagickString(zlib_runv,
          zlib_version,32);
 
   if (logging != MagickFalse)
     {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    IM version     = %s"",
            im_vers);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Libpng version = %s"",
            libpng_vers);
        if (LocaleCompare(libpng_vers,libpng_runv) != 0)
        {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
            libpng_runv);
        }
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""    Zlib version   = %s"",
            zlib_vers);
        if (LocaleCompare(zlib_vers,zlib_runv) != 0)
        {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""      running with   %s"",
            zlib_runv);
        }
     }
 
    
   ping_bit_depth=0,
   ping_color_type=0,
   ping_interlace_method=0,
   ping_compression_method=0,
   ping_filter_method=0,
   ping_num_trans = 0;
 
   ping_background.red = 0;
   ping_background.green = 0;
   ping_background.blue = 0;
   ping_background.gray = 0;
   ping_background.index = 0;
 
   ping_trans_color.red=0;
   ping_trans_color.green=0;
   ping_trans_color.blue=0;
   ping_trans_color.gray=0;
 
   ping_pHYs_unit_type = 0;
   ping_pHYs_x_resolution = 0;
   ping_pHYs_y_resolution = 0;
 
   ping_have_blob=MagickFalse;
   ping_have_cheap_transparency=MagickFalse;
   ping_have_color=MagickTrue;
   ping_have_non_bw=MagickTrue;
   ping_have_PLTE=MagickFalse;
   ping_have_bKGD=MagickFalse;
   ping_have_eXIf=MagickTrue;
   ping_have_iCCP=MagickFalse;
   ping_have_pHYs=MagickFalse;
   ping_have_sRGB=MagickFalse;
   ping_have_tRNS=MagickFalse;
 
   ping_exclude_bKGD=mng_info->ping_exclude_bKGD;
   ping_exclude_caNv=mng_info->ping_exclude_caNv;
   ping_exclude_cHRM=mng_info->ping_exclude_cHRM;
   ping_exclude_date=mng_info->ping_exclude_date;
   ping_exclude_eXIf=mng_info->ping_exclude_eXIf;
   ping_exclude_gAMA=mng_info->ping_exclude_gAMA;
   ping_exclude_iCCP=mng_info->ping_exclude_iCCP;
    
   ping_exclude_oFFs=mng_info->ping_exclude_oFFs;
   ping_exclude_pHYs=mng_info->ping_exclude_pHYs;
   ping_exclude_sRGB=mng_info->ping_exclude_sRGB;
   ping_exclude_tEXt=mng_info->ping_exclude_tEXt;
   ping_exclude_tIME=mng_info->ping_exclude_tIME;
    
   ping_exclude_vpAg=mng_info->ping_exclude_vpAg;
   ping_exclude_zCCP=mng_info->ping_exclude_zCCP;  
   ping_exclude_zTXt=mng_info->ping_exclude_zTXt;
 
   ping_preserve_colormap = mng_info->ping_preserve_colormap;
   ping_preserve_iCCP = mng_info->ping_preserve_iCCP;
   ping_need_colortype_warning = MagickFalse;
 
    
    if (ping_exclude_sRGB == MagickFalse && ping_preserve_iCCP == MagickFalse)
    {
       char
         *name;
 
       const StringInfo
         *profile;
 
       ResetImageProfileIterator(image);
       for (name=GetNextImageProfile(image); name != (const char *) NULL; )
       {
         profile=GetImageProfile(image,name);
 
         if (profile != (StringInfo *) NULL)
           {
             if ((LocaleCompare(name,""ICC"") == 0) ||
                 (LocaleCompare(name,""ICM"") == 0))
 
              {
                  int
                    icheck,
                    got_crc=0;
 
 
                  png_uint_32
                    length,
                    profile_crc=0;
 
                  unsigned char
                    *data;
 
                  length=(png_uint_32) GetStringInfoLength(profile);
 
                  for (icheck=0; sRGB_info[icheck].len > 0; icheck++)
                  {
                    if (length == sRGB_info[icheck].len)
                    {
                      if (got_crc == 0)
                      {
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""    Got a %lu-byte ICC profile (potentially sRGB)"",
                          (unsigned long) length);
 
                        data=GetStringInfoDatum(profile);
                        profile_crc=crc32(0,data,length);
 
                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""      with crc=%8x"",(unsigned int) profile_crc);
                        got_crc++;
                      }
 
                      if (profile_crc == sRGB_info[icheck].crc)
                      {
                         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                             ""      It is sRGB with rendering intent = %s"",
                         Magick_RenderingIntentString_from_PNG_RenderingIntent(
                              sRGB_info[icheck].intent));
                         if (image->rendering_intent==UndefinedIntent)
                         {
                           image->rendering_intent=
                           Magick_RenderingIntent_from_PNG_RenderingIntent(
                              sRGB_info[icheck].intent);
                         }
                         ping_exclude_iCCP = MagickTrue;
                         ping_exclude_zCCP = MagickTrue;
                         ping_have_sRGB = MagickTrue;
                         break;
                      }
                    }
                  }
                  if (sRGB_info[icheck].len == 0)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""    Got %lu-byte ICC profile not recognized as sRGB"",
                         (unsigned long) length);
               }
           }
         name=GetNextImageProfile(image);
       }
   }
 
   number_opaque = 0;
   number_semitransparent = 0;
   number_transparent = 0;
 
   if (logging != MagickFalse)
     {
       if (image->storage_class == UndefinedClass)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    image->storage_class=UndefinedClass"");
       if (image->storage_class == DirectClass)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    image->storage_class=DirectClass"");
       if (image->storage_class == PseudoClass)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    image->storage_class=PseudoClass"");
       (void) LogMagickEvent(CoderEvent,GetMagickModule(), image->taint ?
           ""    image->taint=MagickTrue"":
           ""    image->taint=MagickFalse"");
     }
 
   if (image->storage_class == PseudoClass &&
      (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32 ||
      mng_info->write_png48 || mng_info->write_png64 ||
      (mng_info->write_png_colortype != 1 &&
      mng_info->write_png_colortype != 5)))
     {
       (void) SyncImage(image,exception);
       image->storage_class = DirectClass;
     }
 
   if (ping_preserve_colormap == MagickFalse)
     {
       if (image->storage_class != PseudoClass && image->colormap != NULL)
         {
            
            if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Freeing bogus colormap"");
            (void) RelinquishMagickMemory(image->colormap);
            image->colormap=NULL;
         }
     }
 
   if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
     (void) TransformImageColorspace(image,sRGBColorspace,exception);
 
    
   if (image->depth <= 8 && image->taint && image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
 
 #if (MAGICKCORE_QUANTUM_DEPTH == 8)
   if (image->depth > 8)
     {
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    Reducing PNG bit depth to 8 since this is a Q8 build."");
 
       image->depth=8;
     }
 #endif
 
    
   if (image->depth < 4)
     {
        register Quantum
          *r;
 
        if (image->depth > 2)
          {
             
            LBR04PacketRGBO(image->background_color);
 
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
              if (r == (Quantum *) NULL)
                break;
 
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                 LBR04PixelRGBA(r);
                 r+=GetPixelChannels(image);
              }
 
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
 
            if (image->storage_class == PseudoClass && image->colormap != NULL)
            {
              for (i=0; i < (ssize_t) image->colors; i++)
              {
                LBR04PacketRGBO(image->colormap[i]);
              }
            }
          }
        else if (image->depth > 1)
          {
             
            LBR02PacketRGBO(image->background_color);
 
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
              if (r == (Quantum *) NULL)
                break;
 
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                 LBR02PixelRGBA(r);
                 r+=GetPixelChannels(image);
              }
 
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
 
            if (image->storage_class == PseudoClass && image->colormap != NULL)
            {
              for (i=0; i < (ssize_t) image->colors; i++)
              {
                LBR02PacketRGBO(image->colormap[i]);
              }
            }
          }
        else
          {
             
            LBR01PacketRGBO(image->background_color);
 
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
              if (r == (Quantum *) NULL)
                break;
 
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                 LBR01PixelRGBA(r);
                 r+=GetPixelChannels(image);
              }
 
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
            }
 
            if (image->storage_class == PseudoClass && image->colormap != NULL)
            {
              for (i=0; i < (ssize_t) image->colors; i++)
              {
                LBR01PacketRGBO(image->colormap[i]);
              }
            }
          }
     }
 
    
   if (image->depth < 8)
      image->depth=8;
 
 #if (MAGICKCORE_QUANTUM_DEPTH > 16)
    
   if (image->depth > 8)
       image->depth=16;
 #endif
 
 #if (MAGICKCORE_QUANTUM_DEPTH > 8)
   if (image->depth > 8)
     {
        
       image->depth=16;
     }
 
   if (image->depth == 16 && mng_info->write_png_depth != 16)
     if (mng_info->write_png8 ||
         LosslessReduceDepthOK(image,exception) != MagickFalse)
       image->depth = 8;
 #endif
 
   image_colors = (int) image->colors;
   number_opaque = (int) image->colors;
   number_transparent = 0;
   number_semitransparent = 0;
 
   if (mng_info->write_png_colortype &&
      (mng_info->write_png_colortype > 4 || (mng_info->write_png_depth >= 8 &&
      mng_info->write_png_colortype < 4 &&
      image->alpha_trait == UndefinedPixelTrait)))
   {
       
      if (mng_info->write_png_colortype == 1 ||
         mng_info->write_png_colortype == 5)
        ping_have_color=MagickFalse;
 
      if (image->alpha_trait != UndefinedPixelTrait)
        {
          number_transparent = 2;
          number_semitransparent = 1;
        }
   }
 
   if (mng_info->write_png_colortype < 7)
   {
    
 
   tried_332 = MagickFalse;
   tried_333 = MagickFalse;
   tried_444 = MagickFalse;
 
   for (j=0; j<6; j++)
   {
      
 
    int
      n;
 
    PixelInfo
      opaque[260],
      semitransparent[260],
      transparent[260];
 
    register const Quantum
      *s;
 
    register Quantum
      *q,
      *r;
 
    if (logging != MagickFalse)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Enter BUILD_PALETTE:"");
 
    if (logging != MagickFalse)
      {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      image->columns=%.20g"",(double) image->columns);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      image->rows=%.20g"",(double) image->rows);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      image->alpha_trait=%.20g"",(double) image->alpha_trait);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      image->depth=%.20g"",(double) image->depth);
 
        if (image->storage_class == PseudoClass && image->colormap != NULL)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      Original colormap:"");
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""        i    (red,green,blue,alpha)"");
 
          for (i=0; i < 256; i++)
          {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""        %d    (%d,%d,%d,%d)"",
                     (int) i,
                     (int) image->colormap[i].red,
                     (int) image->colormap[i].green,
                     (int) image->colormap[i].blue,
                     (int) image->colormap[i].alpha);
          }
 
          for (i=image->colors - 10; i < (ssize_t) image->colors; i++)
          {
            if (i > 255)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""        %d    (%d,%d,%d,%d)"",
                     (int) i,
                     (int) image->colormap[i].red,
                     (int) image->colormap[i].green,
                     (int) image->colormap[i].blue,
                     (int) image->colormap[i].alpha);
              }
          }
        }
 
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""      image->colors=%d"",(int) image->colors);
 
        if (image->colors == 0)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""        (zero means unknown)"");
 
        if (ping_preserve_colormap == MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""      Regenerate the colormap"");
      }
 
      image_colors=0;
      number_opaque = 0;
      number_semitransparent = 0;
      number_transparent = 0;
 
      for (y=0; y < (ssize_t) image->rows; y++)
      {
        q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
        if (q == (Quantum *) NULL)
          break;
 
        for (x=0; x < (ssize_t) image->columns; x++)
        {
            if (image->alpha_trait == UndefinedPixelTrait ||
               GetPixelAlpha(image,q) == OpaqueAlpha)
              {
                if (number_opaque < 259)
                  {
                    if (number_opaque == 0)
                      {
                        GetPixelInfoPixel(image, q, opaque);
                        opaque[0].alpha=OpaqueAlpha;
                        number_opaque=1;
                      }
 
                    for (i=0; i< (ssize_t) number_opaque; i++)
                      {
                        if (Magick_png_color_equal(image,q,opaque+i))
                          break;
                      }
 
                    if (i ==  (ssize_t) number_opaque && number_opaque < 259)
                      {
                        number_opaque++;
                        GetPixelInfoPixel(image, q, opaque+i);
                        opaque[i].alpha=OpaqueAlpha;
                      }
                  }
              }
            else if (GetPixelAlpha(image,q) == TransparentAlpha)
              {
                if (number_transparent < 259)
                  {
                    if (number_transparent == 0)
                      {
                        GetPixelInfoPixel(image, q, transparent);
                        ping_trans_color.red=(unsigned short)
                          GetPixelRed(image,q);
                        ping_trans_color.green=(unsigned short)
                          GetPixelGreen(image,q);
                        ping_trans_color.blue=(unsigned short)
                          GetPixelBlue(image,q);
                        ping_trans_color.gray=(unsigned short)
                          GetPixelGray(image,q);
                        number_transparent = 1;
                      }
 
                    for (i=0; i< (ssize_t) number_transparent; i++)
                      {
                        if (Magick_png_color_equal(image,q,transparent+i))
                          break;
                      }
 
                    if (i ==  (ssize_t) number_transparent &&
                        number_transparent < 259)
                      {
                        number_transparent++;
                        GetPixelInfoPixel(image,q,transparent+i);
                      }
                  }
              }
            else
              {
                if (number_semitransparent < 259)
                  {
                    if (number_semitransparent == 0)
                      {
                        GetPixelInfoPixel(image,q,semitransparent);
                        number_semitransparent = 1;
                      }
 
                    for (i=0; i< (ssize_t) number_semitransparent; i++)
                      {
                        if (Magick_png_color_equal(image,q,semitransparent+i)
                            && GetPixelAlpha(image,q) ==
                            semitransparent[i].alpha)
                          break;
                      }
 
                    if (i ==  (ssize_t) number_semitransparent &&
                        number_semitransparent < 259)
                      {
                        number_semitransparent++;
                        GetPixelInfoPixel(image, q, semitransparent+i);
                      }
                  }
              }
            q+=GetPixelChannels(image);
         }
      }
 
      if (mng_info->write_png8 == MagickFalse &&
          ping_exclude_bKGD == MagickFalse)
        {
           
           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      Check colormap for background (%d,%d,%d)"",
                   (int) image->background_color.red,
                   (int) image->background_color.green,
                   (int) image->background_color.blue);
             }
           for (i=0; i<number_opaque; i++)
           {
              if (opaque[i].red == image->background_color.red &&
                  opaque[i].green == image->background_color.green &&
                  opaque[i].blue == image->background_color.blue)
                break;
           }
           if (number_opaque < 259 && i == number_opaque)
             {
                opaque[i] = image->background_color;
                ping_background.index = i;
                number_opaque++;
                if (logging != MagickFalse)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""      background_color index is %d"",(int) i);
                  }
 
             }
           else if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      No room in the colormap to add background color"");
        }
 
      image_colors=number_opaque+number_transparent+number_semitransparent;
 
      if (logging != MagickFalse)
        {
          if (image_colors > 256)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      image has more than 256 colors"");
 
          else
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      image has %d colors"",image_colors);
        }
 
      if (ping_preserve_colormap != MagickFalse)
        break;
 
      if (mng_info->write_png_colortype != 7)  
        {
          ping_have_color=MagickFalse;
          ping_have_non_bw=MagickFalse;
 
          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""incompatible colorspace"");
            ping_have_color=MagickTrue;
            ping_have_non_bw=MagickTrue;
          }
 
          if(image_colors > 256)
            {
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
                if (q == (Quantum *) NULL)
                  break;
 
                s=q;
                for (x=0; x < (ssize_t) image->columns; x++)
                {
                  if (GetPixelRed(image,s) != GetPixelGreen(image,s) ||
                      GetPixelRed(image,s) != GetPixelBlue(image,s))
                    {
                       ping_have_color=MagickTrue;
                       ping_have_non_bw=MagickTrue;
                       break;
                    }
                  s+=GetPixelChannels(image);
                }
 
                if (ping_have_color != MagickFalse)
                  break;
 
                 
 
                if (ping_have_non_bw == MagickFalse)
                  {
                    s=q;
                    for (x=0; x < (ssize_t) image->columns; x++)
                    {
                      if (GetPixelRed(image,s) != 0 &&
                          GetPixelRed(image,s) != QuantumRange)
                        {
                          ping_have_non_bw=MagickTrue;
                          break;
                        }
                      s+=GetPixelChannels(image);
                    }
                }
              }
            }
        }
 
      if (image_colors < 257)
        {
          PixelInfo
            colormap[260];
 
           
 
          if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      Sort the new colormap"");
 
          ;
 
          n = 0;
 
          for (i=0; i<number_transparent; i++)
             colormap[n++] = transparent[i];
 
          for (i=0; i<number_semitransparent; i++)
             colormap[n++] = semitransparent[i];
 
          for (i=0; i<number_opaque; i++)
             colormap[n++] = opaque[i];
 
          ping_background.index +=
            (number_transparent + number_semitransparent);
 
           
          for (i=0; i<n; i++)
          {
            if (ping_have_color == MagickFalse)
              {
                 if (colormap[i].red != colormap[i].green ||
                     colormap[i].red != colormap[i].blue)
                   {
                      ping_have_color=MagickTrue;
                      ping_have_non_bw=MagickTrue;
                      break;
                   }
               }
 
            if (ping_have_non_bw == MagickFalse)
              {
                if (colormap[i].red != 0 && colormap[i].red != QuantumRange)
                    ping_have_non_bw=MagickTrue;
              }
           }
 
         if ((mng_info->ping_exclude_tRNS == MagickFalse ||
             (number_transparent == 0 && number_semitransparent == 0)) &&
             (((mng_info->write_png_colortype-1) ==
             PNG_COLOR_TYPE_PALETTE) ||
             (mng_info->write_png_colortype == 0)))
           {
             if (logging != MagickFalse)
               {
                 if (n !=  (ssize_t) image_colors)
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""   image_colors (%d) and n (%d)  don't match"",
                    image_colors, n);
 
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      AcquireImageColormap"");
               }
 
             image->colors = image_colors;
 
             if (AcquireImageColormap(image,image_colors,exception) ==
                 MagickFalse)
                ThrowWriterException(ResourceLimitError,
                    ""MemoryAllocationFailed"");
 
             for (i=0; i< (ssize_t) image_colors; i++)
                image->colormap[i] = colormap[i];
 
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""      image->colors=%d (%d)"",
                       (int) image->colors, image_colors);
 
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""      Update the pixel indexes"");
               }
 
              
 
             for (y=0; y < (ssize_t) image->rows; y++)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
               if (q == (Quantum *) NULL)
                 break;
 
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 for (i=0; i< (ssize_t) image_colors; i++)
                 {
                   if ((image->alpha_trait == UndefinedPixelTrait ||
                       image->colormap[i].alpha == GetPixelAlpha(image,q)) &&
                       image->colormap[i].red == GetPixelRed(image,q) &&
                       image->colormap[i].green == GetPixelGreen(image,q) &&
                       image->colormap[i].blue == GetPixelBlue(image,q))
                   {
                     SetPixelIndex(image,i,q);
                     break;
                   }
                 }
                 q+=GetPixelChannels(image);
               }
 
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                  break;
             }
           }
        }
 
      if (logging != MagickFalse)
        {
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""      image->colors=%d"", (int) image->colors);
 
          if (image->colormap != NULL)
            {
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""       i     (red,green,blue,alpha)"");
 
              for (i=0; i < (ssize_t) image->colors; i++)
              {
                if (i < 300 || i >= (ssize_t) image->colors - 10)
                  {
                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""       %d     (%d,%d,%d,%d)"",
                         (int) i,
                         (int) image->colormap[i].red,
                         (int) image->colormap[i].green,
                         (int) image->colormap[i].blue,
                         (int) image->colormap[i].alpha);
                  }
              }
            }
 
            if (number_transparent < 257)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_transparent     = %d"",
                    number_transparent);
            else
 
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_transparent     > 256"");
 
            if (number_opaque < 257)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_opaque          = %d"",
                    number_opaque);
 
            else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_opaque          > 256"");
 
            if (number_semitransparent < 257)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_semitransparent = %d"",
                    number_semitransparent);
 
            else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      number_semitransparent > 256"");
 
            if (ping_have_non_bw == MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      All pixels and the background are black or white"");
 
            else if (ping_have_color == MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      All pixels and the background are gray"");
 
            else
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""      At least one pixel or the background is non-gray"");
 
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Exit BUILD_PALETTE:"");
        }
 
    if (mng_info->write_png8 == MagickFalse)
       break;
 
     
     if (image_colors <= 256 &&
         image_colors != 0 && image->colormap != NULL &&
         number_semitransparent == 0 &&
         number_transparent <= 1)
       break;
 
      
     if (number_semitransparent != 0 || number_transparent > 1)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Thresholding the alpha channel to binary"");
 
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
           if (r == (Quantum *) NULL)
             break;
 
           for (x=0; x < (ssize_t) image->columns; x++)
           {
               if (GetPixelAlpha(image,r) < OpaqueAlpha/2)
                 {
                   SetPixelViaPixelInfo(image,&image->background_color,r);
                   SetPixelAlpha(image,TransparentAlpha,r);
                 }
               else
                   SetPixelAlpha(image,OpaqueAlpha,r);
               r+=GetPixelChannels(image);
           }
 
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
 
           if (image_colors != 0 && image_colors <= 256 &&
              image->colormap != NULL)
             for (i=0; i<image_colors; i++)
                 image->colormap[i].alpha =
                     (image->colormap[i].alpha > TransparentAlpha/2 ?
                     TransparentAlpha : OpaqueAlpha);
         }
       continue;
     }
 
      
     if (tried_444 == MagickFalse && (image_colors == 0 || image_colors > 256))
       {
         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Quantizing the background color to 4-4-4"");
 
         tried_444 = MagickTrue;
 
         LBR04PacketRGB(image->background_color);
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the pixel colors to 4-4-4"");
 
         if (image->colormap == NULL)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
             if (r == (Quantum *) NULL)
               break;
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelAlpha(image,r) == OpaqueAlpha)
                   LBR04PixelRGB(r);
               r+=GetPixelChannels(image);
             }
 
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }
         }
 
         else  
         {
           if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the colormap to 4-4-4"");
 
           for (i=0; i<image_colors; i++)
           {
             LBR04PacketRGB(image->colormap[i]);
           }
         }
         continue;
       }
 
     if (tried_333 == MagickFalse && (image_colors == 0 || image_colors > 256))
       {
         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Quantizing the background color to 3-3-3"");
 
         tried_333 = MagickTrue;
 
         LBR03PacketRGB(image->background_color);
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the pixel colors to 3-3-3-1"");
 
         if (image->colormap == NULL)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
             if (r == (Quantum *) NULL)
               break;
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelAlpha(image,r) == OpaqueAlpha)
                   LBR03RGB(r);
               r+=GetPixelChannels(image);
             }
 
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }
         }
 
         else  
         {
           if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the colormap to 3-3-3-1"");
           for (i=0; i<image_colors; i++)
           {
               LBR03PacketRGB(image->colormap[i]);
           }
         }
         continue;
       }
 
     if (tried_332 == MagickFalse && (image_colors == 0 || image_colors > 256))
       {
         if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    Quantizing the background color to 3-3-2"");
 
         tried_332 = MagickTrue;
 
          
 
         LBR02PacketBlue(image->background_color);
 
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the pixel colors to 3-3-2-1"");
 
         if (image->colormap == NULL)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
             if (r == (Quantum *) NULL)
               break;
 
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (GetPixelAlpha(image,r) == OpaqueAlpha)
                   LBR02PixelBlue(r);
               r+=GetPixelChannels(image);
             }
 
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
           }
         }
 
         else  
         {
           if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""    Quantizing the colormap to 3-3-2-1"");
           for (i=0; i<image_colors; i++)
           {
               LBR02PacketBlue(image->colormap[i]);
           }
       }
       continue;
     }
 
     if (image_colors == 0 || image_colors > 256)
     {
        
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Merging two dark red background colors to 3-3-2-1"");
 
       if (ScaleQuantumToChar(image->background_color.red) == 0x49 &&
           ScaleQuantumToChar(image->background_color.green) == 0x00 &&
           ScaleQuantumToChar(image->background_color.blue) == 0x00)
       {
          image->background_color.red=ScaleCharToQuantum(0x24);
       }
 
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Merging two dark red pixel colors to 3-3-2-1"");
 
       if (image->colormap == NULL)
       {
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           r=GetAuthenticPixels(image,0,y,image->columns,1,exception);
 
           if (r == (Quantum *) NULL)
             break;
 
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (ScaleQuantumToChar(GetPixelRed(image,r)) == 0x49 &&
                 ScaleQuantumToChar(GetPixelGreen(image,r)) == 0x00 &&
                 ScaleQuantumToChar(GetPixelBlue(image,r)) == 0x00 &&
                 GetPixelAlpha(image,r) == OpaqueAlpha)
               {
                 SetPixelRed(image,ScaleCharToQuantum(0x24),r);
               }
             r+=GetPixelChannels(image);
           }
 
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
 
         }
       }
 
       else
       {
          for (i=0; i<image_colors; i++)
          {
             if (ScaleQuantumToChar(image->colormap[i].red) == 0x49 &&
                 ScaleQuantumToChar(image->colormap[i].green) == 0x00 &&
                 ScaleQuantumToChar(image->colormap[i].blue) == 0x00)
             {
                image->colormap[i].red=ScaleCharToQuantum(0x24);
             }
          }
       }
     }
   }
   }
    
 
    
   if (mng_info->ping_exclude_tRNS != MagickFalse &&
      (number_transparent != 0 || number_semitransparent != 0))
     {
       unsigned int colortype=mng_info->write_png_colortype;
 
       if (ping_have_color == MagickFalse)
         mng_info->write_png_colortype = 5;
 
       else
         mng_info->write_png_colortype = 7;
 
       if (colortype != 0 &&
          mng_info->write_png_colortype != colortype)
         ping_need_colortype_warning=MagickTrue;
 
     }
 
    
   if (number_transparent == 1 &&
       mng_info->write_png_colortype < 4)
     {
        ping_have_cheap_transparency = MagickTrue;
 
        if (number_semitransparent != 0)
          ping_have_cheap_transparency = MagickFalse;
 
        else if (image_colors == 0 || image_colors > 256 ||
            image->colormap == NULL)
          {
            register const Quantum
              *q;
 
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=GetVirtualPixels(image,0,y,image->columns,1, exception);
 
              if (q == (Quantum *) NULL)
                break;
 
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                  if (GetPixelAlpha(image,q) != TransparentAlpha &&
                      (unsigned short) GetPixelRed(image,q) ==
                                      ping_trans_color.red &&
                      (unsigned short) GetPixelGreen(image,q) ==
                                      ping_trans_color.green &&
                      (unsigned short) GetPixelBlue(image,q) ==
                                      ping_trans_color.blue)
                    {
                      ping_have_cheap_transparency = MagickFalse;
                      break;
                    }
 
                  q+=GetPixelChannels(image);
              }
 
              if (ping_have_cheap_transparency == MagickFalse)
                 break;
            }
          }
        else
          {
              
             if (image_colors > 1)
               for (i=1; i<image_colors; i++)
                 if (image->colormap[i].red == image->colormap[0].red &&
                     image->colormap[i].green == image->colormap[0].green &&
                     image->colormap[i].blue == image->colormap[0].blue)
                   {
                      ping_have_cheap_transparency = MagickFalse;
                      break;
                   }
          }
 
        if (logging != MagickFalse)
          {
            if (ping_have_cheap_transparency == MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""   Cheap transparency is not possible."");
 
            else
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""   Cheap transparency is possible."");
          }
      }
   else
     ping_have_cheap_transparency = MagickFalse;
 
   image_depth=image->depth;
 
   quantum_info = (QuantumInfo *) NULL;
   number_colors=0;
   image_colors=(int) image->colors;
   image_matte=image->alpha_trait !=
         UndefinedPixelTrait ? MagickTrue : MagickFalse;
 
   if (mng_info->write_png_colortype < 5)
     mng_info->IsPalette=image->storage_class == PseudoClass &&
       image_colors <= 256 && image->colormap != NULL;
   else
     mng_info->IsPalette = MagickFalse;
 
   if ((mng_info->write_png_colortype == 4 || mng_info->write_png8) &&
      (image->colors == 0 || image->colormap == NULL))
     {
       image_info=DestroyImageInfo(image_info);
       image=DestroyImage(image);
       (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
           ""Cannot write PNG8 or color-type 3; colormap is NULL"",
           ""`%s'"",IMimage->filename);
       return(MagickFalse);
     }
 
    
 #ifdef PNG_USER_MEM_SUPPORTED
  error_info.image=image;
  error_info.exception=exception;
   ping=png_create_write_struct_2(PNG_LIBPNG_VER_STRING,&error_info,
     MagickPNGErrorHandler,MagickPNGWarningHandler,(void *) NULL,
     (png_malloc_ptr) Magick_png_malloc,(png_free_ptr) Magick_png_free);
 
 #else
   ping=png_create_write_struct(PNG_LIBPNG_VER_STRING,&error_info,
     MagickPNGErrorHandler,MagickPNGWarningHandler);
 
 #endif
   if (ping == (png_struct *) NULL)
     ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
 
   ping_info=png_create_info_struct(ping);
 
   if (ping_info == (png_info *) NULL)
     {
       png_destroy_write_struct(&ping,(png_info **) NULL);
       ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
     }
 
   png_set_write_fn(ping,image,png_put_data,png_flush_data);
   pixel_info=(MemoryInfo *) NULL;
 
   if (setjmp(png_jmpbuf(ping)))
     {
        
 #ifdef PNG_DEBUG
      if (image_info->verbose)
         (void) printf(""PNG write has failed.\n"");
 #endif
       png_destroy_write_struct(&ping,&ping_info);
 #ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
       UnlockSemaphoreInfo(ping_semaphore);
 #endif
 
       if (pixel_info != (MemoryInfo *) NULL)
         pixel_info=RelinquishVirtualMemory(pixel_info);
 
       if (quantum_info != (QuantumInfo *) NULL)
         quantum_info=DestroyQuantumInfo(quantum_info);
 
       if (ping_have_blob != MagickFalse)
           (void) CloseBlob(image);
       image_info=DestroyImageInfo(image_info);
       image=DestroyImage(image);
       return(MagickFalse);
     }
 
    
 
 #ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
   LockSemaphoreInfo(ping_semaphore);
 #endif
 
 #ifdef PNG_BENIGN_ERRORS_SUPPORTED
    
   png_set_benign_errors(ping, 1);
 #endif
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
    
   png_set_user_limits(ping,
     (png_uint_32) MagickMin(0x7fffffffL,
         GetMagickResourceLimit(WidthResource)),
     (png_uint_32) MagickMin(0x7fffffffL,
         GetMagickResourceLimit(HeightResource)));
 #endif  
 
    
 
 #if defined(PNG_MNG_FEATURES_SUPPORTED)
   if (mng_info->write_mng)
   {
      (void) png_permit_mng_features(ping,PNG_ALL_MNG_FEATURES);
 # ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
       
      png_set_check_for_invalid_index (ping, 0);
 # endif
   }
 
 #else
 # ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
   if (mng_info->write_mng)
      png_permit_empty_plte(ping,MagickTrue);
 
 # endif
 #endif
 
   x=0;
 
   ping_width=(png_uint_32) image->columns;
   ping_height=(png_uint_32) image->rows;
 
   if (mng_info->write_png8 || mng_info->write_png24 || mng_info->write_png32)
      image_depth=8;
 
   if (mng_info->write_png48 || mng_info->write_png64)
      image_depth=16;
 
   if (mng_info->write_png_depth != 0)
      image_depth=mng_info->write_png_depth;
 
    
   if (image_depth > 8)
      image_depth=16;
 
   if ((image_depth > 4) && (image_depth < 8))
      image_depth=8;
 
   if (image_depth == 3)
      image_depth=4;
 
   if (logging != MagickFalse)
     {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    width=%.20g"",(double) ping_width);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    height=%.20g"",(double) ping_height);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    image_matte=%.20g"",(double) image->alpha_trait);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    image->depth=%.20g"",(double) image->depth);
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Tentative ping_bit_depth=%.20g"",(double) image_depth);
     }
 
   save_image_depth=image_depth;
   ping_bit_depth=(png_byte) save_image_depth;
 
 
 #if defined(PNG_pHYs_SUPPORTED)
   if (ping_exclude_pHYs == MagickFalse)
   {
   if ((image->resolution.x != 0) && (image->resolution.y != 0) &&
       (!mng_info->write_mng || !mng_info->equal_physs))
     {
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Setting up pHYs chunk"");
 
       if (image->units == PixelsPerInchResolution)
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_METER;
           ping_pHYs_x_resolution=
              (png_uint_32) ((100.0*image->resolution.x+0.5)/2.54);
           ping_pHYs_y_resolution=
              (png_uint_32) ((100.0*image->resolution.y+0.5)/2.54);
         }
 
       else if (image->units == PixelsPerCentimeterResolution)
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_METER;
           ping_pHYs_x_resolution=(png_uint_32) (100.0*image->resolution.x+0.5);
           ping_pHYs_y_resolution=(png_uint_32) (100.0*image->resolution.y+0.5);
         }
 
       else
         {
           ping_pHYs_unit_type=PNG_RESOLUTION_UNKNOWN;
           ping_pHYs_x_resolution=(png_uint_32) image->resolution.x;
           ping_pHYs_y_resolution=(png_uint_32) image->resolution.y;
         }
 
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    Set up PNG pHYs chunk: xres: %.20g, yres: %.20g, units: %d."",
           (double) ping_pHYs_x_resolution,(double) ping_pHYs_y_resolution,
           (int) ping_pHYs_unit_type);
        ping_have_pHYs = MagickTrue;
     }
   }
 #endif
 
   if (ping_exclude_bKGD == MagickFalse)
   {
   if ((!mng_info->adjoin || !mng_info->equal_backgrounds))
     {
        unsigned int
          mask;
 
        mask=0xffff;
        if (ping_bit_depth == 8)
           mask=0x00ff;
 
        if (ping_bit_depth == 4)
           mask=0x000f;
 
        if (ping_bit_depth == 2)
           mask=0x0003;
 
        if (ping_bit_depth == 1)
           mask=0x0001;
 
        ping_background.red=(png_uint_16)
          (ScaleQuantumToShort(image->background_color.red) & mask);
 
        ping_background.green=(png_uint_16)
          (ScaleQuantumToShort(image->background_color.green) & mask);
 
        ping_background.blue=(png_uint_16)
          (ScaleQuantumToShort(image->background_color.blue) & mask);
 
        ping_background.gray=(png_uint_16) ping_background.green;
     }
 
   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    Setting up bKGD chunk (1)"");
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""      background_color index is %d"",
           (int) ping_background.index);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""    ping_bit_depth=%d"",ping_bit_depth);
     }
 
   ping_have_bKGD = MagickTrue;
   }
 
    
   matte=image_matte;
   old_bit_depth=0;
 
   if (mng_info->IsPalette && mng_info->write_png8)
     {
        
 
       number_colors=image_colors;
 
       ping_have_tRNS=MagickFalse;
 
        
       ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;
 
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  Setting up PLTE chunk with %d colors (%d)"",
             number_colors, image_colors);
 
       for (i=0; i < (ssize_t) number_colors; i++)
       {
         palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
         palette[i].green=ScaleQuantumToChar(image->colormap[i].green);
         palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
         if (logging != MagickFalse)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
 #if MAGICKCORE_QUANTUM_DEPTH == 8
             ""    %3ld (%3d,%3d,%3d)"",
 #else
             ""    %5ld (%5d,%5d,%5d)"",
 #endif
             (long) i,palette[i].red,palette[i].green,palette[i].blue);
 
       }
 
       ping_have_PLTE=MagickTrue;
       image_depth=ping_bit_depth;
       ping_num_trans=0;
 
       if (matte != MagickFalse)
       {
            
           assert(number_colors <= 256);
           assert(image->colormap != NULL);
 
           for (i=0; i < (ssize_t) number_transparent; i++)
              ping_trans_alpha[i]=0;
 
 
           ping_num_trans=(unsigned short) (number_transparent +
              number_semitransparent);
 
           if (ping_num_trans == 0)
              ping_have_tRNS=MagickFalse;
 
           else
              ping_have_tRNS=MagickTrue;
       }
 
       if (ping_exclude_bKGD == MagickFalse)
       {
         
 
         for (i=0; i < (ssize_t) MagickMax(1L*number_colors-1L,1L); i++)
           if (IsPNGColorEqual(ping_background,image->colormap[i]))
             break;
 
         ping_background.index=(png_byte) i;
 
         if (logging != MagickFalse)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""      background_color index is %d"",
                  (int) ping_background.index);
           }
       }
     }  
 
   else if (mng_info->write_png_colortype == 1)
     {
       image_matte=MagickFalse;
       ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
     }
 
   else if (mng_info->write_png24 || mng_info->write_png48 ||
       mng_info->write_png_colortype == 3)
     {
       image_matte=MagickFalse;
       ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
     }
 
   else if (mng_info->write_png32 || mng_info->write_png64 ||
       mng_info->write_png_colortype == 7)
     {
       image_matte=MagickTrue;
       ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
     }
 
   else  
     {
       image_depth=ping_bit_depth;
 
       if (mng_info->write_png_colortype != 0)
         {
           ping_color_type=(png_byte) mng_info->write_png_colortype-1;
 
           if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
               ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
             image_matte=MagickTrue;
 
           else
             image_matte=MagickFalse;
 
           if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""   PNG colortype %d was specified:"",(int) ping_color_type);
         }
 
       else  
         {
           if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Selecting PNG colortype:"");
 
           ping_color_type=(png_byte) ((matte != MagickFalse)?
             PNG_COLOR_TYPE_RGB_ALPHA:PNG_COLOR_TYPE_RGB);
 
           if (image_info->type == TrueColorType)
             {
               ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
               image_matte=MagickFalse;
             }
 
           if (image_info->type == TrueColorAlphaType)
             {
               ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB_ALPHA;
               image_matte=MagickTrue;
             }
 
           if (image_info->type == PaletteType ||
               image_info->type == PaletteAlphaType)
             ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;
 
           if (mng_info->write_png_colortype == 0 &&
              image_info->type == UndefinedType)
             {
               if (ping_have_color == MagickFalse)
                 {
                   if (image_matte == MagickFalse)
                     {
                       ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY;
                       image_matte=MagickFalse;
                     }
 
                   else
                     {
                       ping_color_type=(png_byte) PNG_COLOR_TYPE_GRAY_ALPHA;
                       image_matte=MagickTrue;
                     }
                 }
               else
                 {
                   if (image_matte == MagickFalse)
                     {
                       ping_color_type=(png_byte) PNG_COLOR_TYPE_RGB;
                       image_matte=MagickFalse;
                     }
 
                   else
                     {
                       ping_color_type=(png_byte) PNG_COLOR_TYPE_RGBA;
                       image_matte=MagickTrue;
                     }
                  }
             }
 
         }
 
       if (logging != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    Selected PNG colortype=%d"",ping_color_type);
 
       if (ping_bit_depth < 8)
         {
           if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
               ping_color_type == PNG_COLOR_TYPE_RGB ||
               ping_color_type == PNG_COLOR_TYPE_RGB_ALPHA)
             ping_bit_depth=8;
         }
 
       old_bit_depth=ping_bit_depth;
 
       if (ping_color_type == PNG_COLOR_TYPE_GRAY)
         {
           if (image->alpha_trait == UndefinedPixelTrait &&
                ping_have_non_bw == MagickFalse)
              ping_bit_depth=1;
         }
 
       if (ping_color_type == PNG_COLOR_TYPE_PALETTE)
         {
            size_t one = 1;
            ping_bit_depth=1;
 
            if (image->colors == 0)
            {
                
                 png_error(ping,""image has 0 colors"");
            }
 
            while ((int) (one << ping_bit_depth) < (ssize_t) image_colors)
              ping_bit_depth <<= 1;
         }
 
       if (logging != MagickFalse)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Number of colors: %.20g"",(double) image_colors);
 
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Tentative PNG bit depth: %d"",ping_bit_depth);
          }
 
       if (ping_bit_depth < (int) mng_info->write_png_depth)
          ping_bit_depth = mng_info->write_png_depth;
     }
 
   image_depth=ping_bit_depth;
 
   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Tentative PNG color type: %s (%.20g)"",
         PngColorTypeToString(ping_color_type),
         (double) ping_color_type);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    image_info->type: %.20g"",(double) image_info->type);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    image_depth: %.20g"",(double) image_depth);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
 
         ""    image->depth: %.20g"",(double) image->depth);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    ping_bit_depth: %.20g"",(double) ping_bit_depth);
     }
 
   if (matte != MagickFalse)
     {
       if (mng_info->IsPalette)
         {
           if (mng_info->write_png_colortype == 0)
             {
               ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;
 
               if (ping_have_color != MagickFalse)
                  ping_color_type=PNG_COLOR_TYPE_RGBA;
             }
 
            
           if (number_transparent + number_semitransparent == 0)
             {
                
 
               image_matte=MagickFalse;
 
               if (mng_info->write_png_colortype == 0)
                 ping_color_type&=0x03;
             }
 
           else
             {
               unsigned int
                 mask;
 
               mask=0xffff;
 
               if (ping_bit_depth == 8)
                  mask=0x00ff;
 
               if (ping_bit_depth == 4)
                  mask=0x000f;
 
               if (ping_bit_depth == 2)
                  mask=0x0003;
 
               if (ping_bit_depth == 1)
                  mask=0x0001;
 
               ping_trans_color.red=(png_uint_16)
                 (ScaleQuantumToShort(image->colormap[0].red) & mask);
 
               ping_trans_color.green=(png_uint_16)
                 (ScaleQuantumToShort(image->colormap[0].green) & mask);
 
               ping_trans_color.blue=(png_uint_16)
                 (ScaleQuantumToShort(image->colormap[0].blue) & mask);
 
               ping_trans_color.gray=(png_uint_16)
                 (ScaleQuantumToShort(GetPixelInfoIntensity(image,
                    image->colormap)) & mask);
 
               ping_trans_color.index=(png_byte) 0;
 
               ping_have_tRNS=MagickTrue;
             }
 
           if (ping_have_tRNS != MagickFalse)
             {
                
               if (ping_have_cheap_transparency == MagickFalse)
                 ping_have_tRNS=MagickFalse;
             }
 
           if (ping_have_tRNS != MagickFalse)
             {
               if (mng_info->write_png_colortype == 0)
                 ping_color_type &= 0x03;   
 
               if (image_depth == 8)
                 {
                   ping_trans_color.red&=0xff;
                   ping_trans_color.green&=0xff;
                   ping_trans_color.blue&=0xff;
                   ping_trans_color.gray&=0xff;
                 }
             }
         }
       else
         {
           if (image_depth == 8)
             {
               ping_trans_color.red&=0xff;
               ping_trans_color.green&=0xff;
               ping_trans_color.blue&=0xff;
               ping_trans_color.gray&=0xff;
             }
         }
     }
 
     matte=image_matte;
 
     if (ping_have_tRNS != MagickFalse)
       image_matte=MagickFalse;
 
     if ((mng_info->IsPalette) &&
         mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE &&
         ping_have_color == MagickFalse &&
         (image_matte == MagickFalse || image_depth >= 8))
       {
         size_t one=1;
 
         if (image_matte != MagickFalse)
           ping_color_type=PNG_COLOR_TYPE_GRAY_ALPHA;
 
         else if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_GRAY_ALPHA)
           {
             ping_color_type=PNG_COLOR_TYPE_GRAY;
 
             if (save_image_depth == 16 && image_depth == 8)
               {
                 if (logging != MagickFalse)
                   {
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""  Scaling ping_trans_color (0)"");
                   }
                     ping_trans_color.gray*=0x0101;
               }
           }
 
         if (image_depth > MAGICKCORE_QUANTUM_DEPTH)
           image_depth=MAGICKCORE_QUANTUM_DEPTH;
 
         if ((image_colors == 0) ||
              ((ssize_t) (image_colors-1) > (ssize_t) MaxColormapSize))
           image_colors=(int) (one << image_depth);
 
         if (image_depth > 8)
           ping_bit_depth=16;
 
         else
           {
             ping_bit_depth=8;
             if ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
               {
                 if(!mng_info->write_png_depth)
                   {
                     ping_bit_depth=1;
 
                     while ((int) (one << ping_bit_depth)
                         < (ssize_t) image_colors)
                       ping_bit_depth <<= 1;
                   }
               }
 
             else if (ping_color_type ==
                 PNG_COLOR_TYPE_GRAY && image_colors < 17 &&
                 mng_info->IsPalette)
               {
                
 
                 int
                   depth_4_ok=MagickTrue,
                   depth_2_ok=MagickTrue,
                   depth_1_ok=MagickTrue;
 
                 for (i=0; i < (ssize_t) image_colors; i++)
                 {
                    unsigned char
                      intensity;
 
                    intensity=ScaleQuantumToChar(image->colormap[i].red);
 
                    if ((intensity & 0x0f) != ((intensity & 0xf0) >> 4))
                      depth_4_ok=depth_2_ok=depth_1_ok=MagickFalse;
                    else if ((intensity & 0x03) != ((intensity & 0x0c) >> 2))
                      depth_2_ok=depth_1_ok=MagickFalse;
                    else if ((intensity & 0x01) != ((intensity & 0x02) >> 1))
                      depth_1_ok=MagickFalse;
                 }
 
                 if (depth_1_ok && mng_info->write_png_depth <= 1)
                   ping_bit_depth=1;
 
                 else if (depth_2_ok && mng_info->write_png_depth <= 2)
                   ping_bit_depth=2;
 
                 else if (depth_4_ok && mng_info->write_png_depth <= 4)
                   ping_bit_depth=4;
               }
           }
 
           image_depth=ping_bit_depth;
       }
 
     else
 
       if (mng_info->IsPalette)
       {
         number_colors=image_colors;
 
         if (image_depth <= 8)
           {
              
             ping_color_type=(png_byte) PNG_COLOR_TYPE_PALETTE;
 
             if (!(mng_info->have_write_global_plte && matte == MagickFalse))
               {
                 for (i=0; i < (ssize_t) number_colors; i++)
                 {
                   palette[i].red=ScaleQuantumToChar(image->colormap[i].red);
                   palette[i].green=
                     ScaleQuantumToChar(image->colormap[i].green);
                   palette[i].blue=ScaleQuantumToChar(image->colormap[i].blue);
                 }
 
                 if (logging != MagickFalse)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""  Setting up PLTE chunk with %d colors"",
                     number_colors);
 
                 ping_have_PLTE=MagickTrue;
               }
 
              
             if (mng_info->write_png_depth == 0)
               {
                 size_t
                   one;
 
                 ping_bit_depth=1;
                 one=1;
 
                 while ((one << ping_bit_depth) < (size_t) number_colors)
                   ping_bit_depth <<= 1;
               }
 
             ping_num_trans=0;
 
             if (matte != MagickFalse)
               {
                  
                 assert(number_colors <= 256);
 
                 ping_num_trans=(unsigned short) (number_transparent +
                   number_semitransparent);
 
                 if (ping_num_trans == 0)
                   ping_have_tRNS=MagickFalse;
 
                 else
                   {
                     if (logging != MagickFalse)
                       {
                         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  Scaling ping_trans_color (1)"");
                       }
                     ping_have_tRNS=MagickTrue;
 
                     for (i=0; i < ping_num_trans; i++)
                     {
                        ping_trans_alpha[i]= (png_byte)
                          ScaleQuantumToChar(image->colormap[i].alpha);
                     }
                   }
               }
           }
       }
 
     else
       {
 
         if (image_depth < 8)
           image_depth=8;
 
         if ((save_image_depth == 16) && (image_depth == 8))
           {
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Scaling ping_trans_color from (%d,%d,%d)"",
                   (int) ping_trans_color.red,
                   (int) ping_trans_color.green,
                   (int) ping_trans_color.blue);
               }
 
             ping_trans_color.red*=0x0101;
             ping_trans_color.green*=0x0101;
             ping_trans_color.blue*=0x0101;
             ping_trans_color.gray*=0x0101;
 
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    to (%d,%d,%d)"",
                   (int) ping_trans_color.red,
                   (int) ping_trans_color.green,
                   (int) ping_trans_color.blue);
               }
           }
       }
 
     if (ping_bit_depth <  (ssize_t) mng_info->write_png_depth)
          ping_bit_depth =  (ssize_t) mng_info->write_png_depth;
 
      
     if (ping_bit_depth < 8 && ping_color_type ==
         PNG_COLOR_TYPE_GRAY)
       {
          png_uint_16
            maxval;
 
          size_t
            one=1;
 
          maxval=(png_uint_16) ((one << ping_bit_depth)-1);
 
          if (ping_exclude_bKGD == MagickFalse)
          {
 
          ping_background.gray=(png_uint_16) ((maxval/65535.)*
            (ScaleQuantumToShort(((GetPixelInfoIntensity(image,
            &image->background_color))) +.5)));
 
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Setting up bKGD chunk (2)"");
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      background_color index is %d"",
              (int) ping_background.index);
 
          ping_have_bKGD = MagickTrue;
          }
 
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Scaling ping_trans_color.gray from %d"",
              (int)ping_trans_color.gray);
 
          ping_trans_color.gray=(png_uint_16) ((maxval/255.)*(
            ping_trans_color.gray)+.5);
 
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""      to %d"", (int)ping_trans_color.gray);
       }
 
   if (ping_exclude_bKGD == MagickFalse)
   {
     if (mng_info->IsPalette && (int) ping_color_type == PNG_COLOR_TYPE_PALETTE)
       {
          
 
         number_colors=image_colors;
 
         for (i=0; i < (ssize_t) MagickMax(1L*number_colors,1L); i++)
           if (IsPNGColorEqual(image->background_color,image->colormap[i]))
             break;
 
         ping_background.index=(png_byte) i;
 
         if (logging != MagickFalse)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Setting up bKGD chunk with index=%d"",(int) i);
           }
 
         if (i < (ssize_t) number_colors)
           {
             ping_have_bKGD = MagickTrue;
 
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""     background   =(%d,%d,%d)"",
                         (int) ping_background.red,
                         (int) ping_background.green,
                         (int) ping_background.blue);
               }
           }
 
         else   
           {
             if (logging != MagickFalse)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      No room in PLTE to add bKGD color"");
             ping_have_bKGD = MagickFalse;
           }
       }
   }
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""    PNG color type: %s (%d)"", PngColorTypeToString(ping_color_type),
       ping_color_type);
    
   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""  Setting up deflate compression"");
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Compression buffer size: 32768"");
     }
 
   png_set_compression_buffer_size(ping,32768L);
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""    Compression mem level: 9"");
 
   png_set_compression_mem_level(ping, 9);
 
    
 
   quality=image_info->quality == UndefinedCompressionQuality ? 75UL :
      image_info->quality;
 
   if (quality <= 9)
     {
       if (mng_info->write_png_compression_strategy == 0)
         mng_info->write_png_compression_strategy = Z_HUFFMAN_ONLY+1;
     }
 
   else if (mng_info->write_png_compression_level == 0)
     {
       int
         level;
 
       level=(int) MagickMin((ssize_t) quality/10,9);
 
       mng_info->write_png_compression_level = level+1;
     }
 
   if (mng_info->write_png_compression_strategy == 0)
     {
         if ((quality %10) == 8 || (quality %10) == 9)
 #ifdef Z_RLE   
           mng_info->write_png_compression_strategy=Z_RLE+1;
 #else
           mng_info->write_png_compression_strategy = Z_DEFAULT_STRATEGY+1;
 #endif
     }
 
   if (mng_info->write_png_compression_filter == 0)
         mng_info->write_png_compression_filter=((int) quality % 10) + 1;
 
   if (logging != MagickFalse)
     {
         if (mng_info->write_png_compression_level)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Compression level:    %d"",
             (int) mng_info->write_png_compression_level-1);
 
         if (mng_info->write_png_compression_strategy)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Compression strategy: %d"",
             (int) mng_info->write_png_compression_strategy-1);
 
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  Setting up filtering"");
 
         if (mng_info->write_png_compression_filter == 6)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Base filter method: ADAPTIVE"");
         else if (mng_info->write_png_compression_filter == 0 ||
                  mng_info->write_png_compression_filter == 1)
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Base filter method: NONE"");
         else
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Base filter method: %d"",
             (int) mng_info->write_png_compression_filter-1);
     }
 
   if (mng_info->write_png_compression_level != 0)
     png_set_compression_level(ping,mng_info->write_png_compression_level-1);
 
   if (mng_info->write_png_compression_filter == 6)
     {
       if (((int) ping_color_type == PNG_COLOR_TYPE_GRAY) ||
          ((int) ping_color_type == PNG_COLOR_TYPE_PALETTE) ||
          (quality < 50))
         png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
       else
         png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);
      }
   else if (mng_info->write_png_compression_filter == 7 ||
       mng_info->write_png_compression_filter == 10)
     png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_ALL_FILTERS);
 
   else if (mng_info->write_png_compression_filter == 8)
     {
 #if defined(PNG_MNG_FEATURES_SUPPORTED) && defined(PNG_INTRAPIXEL_DIFFERENCING)
       if (mng_info->write_mng)
       {
          if (((int) ping_color_type == PNG_COLOR_TYPE_RGB) ||
              ((int) ping_color_type == PNG_COLOR_TYPE_RGBA))
         ping_filter_method=PNG_INTRAPIXEL_DIFFERENCING;
       }
 #endif
       png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
     }
 
   else if (mng_info->write_png_compression_filter == 9)
     png_set_filter(ping,PNG_FILTER_TYPE_BASE,PNG_NO_FILTERS);
 
   else if (mng_info->write_png_compression_filter != 0)
     png_set_filter(ping,PNG_FILTER_TYPE_BASE,
        mng_info->write_png_compression_filter-1);
 
   if (mng_info->write_png_compression_strategy != 0)
     png_set_compression_strategy(ping,
        mng_info->write_png_compression_strategy-1);
 
   ping_interlace_method=image_info->interlace != NoInterlace;
 
   if (mng_info->write_mng)
     png_set_sig_bytes(ping,8);
 
    
 
   if (mng_info->write_png_colortype != 0)
     {
      if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY)
        if (ping_have_color != MagickFalse)
          {
            ping_color_type = PNG_COLOR_TYPE_RGB;
 
            if (ping_bit_depth < 8)
              ping_bit_depth=8;
          }
 
      if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_GRAY_ALPHA)
        if (ping_have_color != MagickFalse)
          ping_color_type = PNG_COLOR_TYPE_RGB_ALPHA;
     }
 
   if (ping_need_colortype_warning != MagickFalse ||
      ((mng_info->write_png_depth &&
      (int) mng_info->write_png_depth != ping_bit_depth) ||
      (mng_info->write_png_colortype &&
      ((int) mng_info->write_png_colortype-1 != ping_color_type &&
       mng_info->write_png_colortype != 7 &&
       !(mng_info->write_png_colortype == 5 && ping_color_type == 0)))))
     {
       if (logging != MagickFalse)
         {
           if (ping_need_colortype_warning != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Image has transparency but tRNS chunk was excluded"");
             }
 
           if (mng_info->write_png_depth)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Defined png:bit-depth=%u, Computed depth=%u"",
                   mng_info->write_png_depth,
                   ping_bit_depth);
             }
 
           if (mng_info->write_png_colortype)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Defined png:color-type=%u, Computed color type=%u"",
                   mng_info->write_png_colortype-1,
                   ping_color_type);
             }
         }
 
       png_warning(ping,
         ""Cannot write image with defined png:bit-depth or png:color-type."");
     }
 
   if (image_matte != MagickFalse && image->alpha_trait == UndefinedPixelTrait)
     {
        
       image->alpha_trait = BlendPixelTrait;
       (void) SetImageAlpha(image,OpaqueAlpha,exception);
 
       if (logging != MagickFalse)
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           ""  Added an opaque matte channel"");
     }
 
   if (number_transparent != 0 || number_semitransparent != 0)
     {
       if (ping_color_type < 4)
         {
            ping_have_tRNS=MagickTrue;
            if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  Setting ping_have_tRNS=MagickTrue."");
         }
     }
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  Writing PNG header chunks"");
 
   png_set_IHDR(ping,ping_info,ping_width,ping_height,
                ping_bit_depth,ping_color_type,
                ping_interlace_method,ping_compression_method,
                ping_filter_method);
 
   if (ping_color_type == 3 && ping_have_PLTE != MagickFalse)
     {
       png_set_PLTE(ping,ping_info,palette,number_colors);
 
       if (logging != MagickFalse)
         {
           for (i=0; i< (ssize_t) number_colors; i++)
           {
             if (i < ping_num_trans)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""     PLTE[%d] = (%d,%d,%d), tRNS[%d] = (%d)"",
                       (int) i,
                       (int) palette[i].red,
                       (int) palette[i].green,
                       (int) palette[i].blue,
                       (int) i,
                       (int) ping_trans_alpha[i]);
              else
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""     PLTE[%d] = (%d,%d,%d)"",
                       (int) i,
                       (int) palette[i].red,
                       (int) palette[i].green,
                       (int) palette[i].blue);
            }
          }
     }
 
    
   if (ping_exclude_sRGB != MagickFalse ||
      (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
   {
     if ((ping_exclude_tEXt == MagickFalse ||
        ping_exclude_zTXt == MagickFalse) &&
        (ping_exclude_iCCP == MagickFalse || ping_exclude_zCCP == MagickFalse))
     {
       ResetImageProfileIterator(image);
       for (name=GetNextImageProfile(image); name != (const char *) NULL; )
       {
         profile=GetImageProfile(image,name);
 
         if (profile != (StringInfo *) NULL)
           {
 #ifdef PNG_WRITE_iCCP_SUPPORTED
             if ((LocaleCompare(name,""ICC"") == 0) ||
                 (LocaleCompare(name,""ICM"") == 0))
               {
                 ping_have_iCCP = MagickTrue;
                 if (ping_exclude_iCCP == MagickFalse)
                   {
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                         ""  Setting up iCCP chunk"");
 
                     png_set_iCCP(ping,ping_info,(png_charp) name,0,
 #if (PNG_LIBPNG_VER < 10500)
                     (png_charp) GetStringInfoDatum(profile),
 #else
                     (const png_byte *) GetStringInfoDatum(profile),
 #endif
                     (png_uint_32) GetStringInfoLength(profile));
                   }
                 else
                   {
                      
                        name=GetNextImageProfile(image);
                        continue;
                   }
               }
 #endif  
 
             if (LocaleCompare(name,""exif"") == 0)
               {
                     
                    name=GetNextImageProfile(image);
                    continue;
               }
 
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""  Setting up zTXt chunk with uuencoded %s profile"",
                  name);
               Magick_png_write_raw_profile(image_info,ping,ping_info,
                 (unsigned char *) name,(unsigned char *) name,
                 GetStringInfoDatum(profile),
                 (png_uint_32) GetStringInfoLength(profile));
           }
         name=GetNextImageProfile(image);
       }
     }
   }
 
 #if defined(PNG_WRITE_sRGB_SUPPORTED)
   if ((mng_info->have_write_global_srgb == 0) &&
       ping_have_iCCP != MagickTrue &&
       (ping_have_sRGB != MagickFalse ||
       png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
     {
       if (ping_exclude_sRGB == MagickFalse)
         {
            
           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""  Setting up sRGB chunk"");
 
           (void) png_set_sRGB(ping,ping_info,(
             Magick_RenderingIntent_to_PNG_RenderingIntent(
               image->rendering_intent)));
 
           ping_have_sRGB = MagickTrue;
         }
     }
 
   if ((!mng_info->write_mng) || (!png_get_valid(ping,ping_info,PNG_INFO_sRGB)))
 #endif
     {
       if (ping_exclude_gAMA == MagickFalse &&
           ping_have_iCCP == MagickFalse &&
           ping_have_sRGB == MagickFalse &&
           (ping_exclude_sRGB == MagickFalse ||
           (image->gamma < .45 || image->gamma > .46)))
       {
       if ((mng_info->have_write_global_gama == 0) && (image->gamma != 0.0))
         {
            
           if (logging != MagickFalse)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Setting up gAMA chunk"");
 
           png_set_gAMA(ping,ping_info,image->gamma);
         }
       }
 
       if (ping_exclude_cHRM == MagickFalse && ping_have_sRGB == MagickFalse)
         {
           if ((mng_info->have_write_global_chrm == 0) &&
               (image->chromaticity.red_primary.x != 0.0))
             {
                
                PrimaryInfo
                  bp,
                  gp,
                  rp,
                  wp;
 
                wp=image->chromaticity.white_point;
                rp=image->chromaticity.red_primary;
                gp=image->chromaticity.green_primary;
                bp=image->chromaticity.blue_primary;
 
                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  Setting up cHRM chunk"");
 
                png_set_cHRM(ping,ping_info,wp.x,wp.y,rp.x,rp.y,gp.x,gp.y,
                    bp.x,bp.y);
            }
         }
     }
 
   if (ping_exclude_bKGD == MagickFalse)
     {
       if (ping_have_bKGD != MagickFalse)
         {
           png_set_bKGD(ping,ping_info,&ping_background);
           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""    Setting up bKGD chunk"");
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      background color = (%d,%d,%d)"",
                         (int) ping_background.red,
                         (int) ping_background.green,
                         (int) ping_background.blue);
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      index = %d, gray=%d"",
                         (int) ping_background.index,
                         (int) ping_background.gray);
             }
          }
     }
 
   if (ping_exclude_pHYs == MagickFalse)
     {
       if (ping_have_pHYs != MagickFalse)
         {
           png_set_pHYs(ping,ping_info,
              ping_pHYs_x_resolution,
              ping_pHYs_y_resolution,
              ping_pHYs_unit_type);
 
           if (logging != MagickFalse)
             {
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""    Setting up pHYs chunk"");
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      x_resolution=%lu"",
                    (unsigned long) ping_pHYs_x_resolution);
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      y_resolution=%lu"",
                    (unsigned long) ping_pHYs_y_resolution);
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      unit_type=%lu"",
                    (unsigned long) ping_pHYs_unit_type);
             }
         }
     }
 
 #if defined(PNG_tIME_SUPPORTED)
   if (ping_exclude_tIME == MagickFalse)
     {
       const char
         *timestamp;
 
       if (image->taint == MagickFalse)
         {
           timestamp=GetImageOption(image_info,""png:tIME"");
 
           if (timestamp == (const char *) NULL)
             timestamp=GetImageProperty(image,""png:tIME"",exception);
         }
 
       else
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Reset tIME in tainted image"");
 
           timestamp=GetImageProperty(image,""date:modify"",exception);
         }
 
       if (timestamp != (const char *) NULL)
           write_tIME_chunk(image,ping,ping_info,timestamp,exception);
     }
 #endif
 
   if (mng_info->need_blob != MagickFalse)
   {
     if (OpenBlob(image_info,image,WriteBinaryBlobMode,exception) ==
        MagickFalse)
        png_error(ping,""WriteBlob Failed"");
 
      ping_have_blob=MagickTrue;
   }
 
   png_write_info_before_PLTE(ping, ping_info);
 
   if (ping_have_tRNS != MagickFalse && ping_color_type < 4)
     {
       if (logging != MagickFalse)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""  Calling png_set_tRNS with num_trans=%d"",ping_num_trans);
         }
 
       if (ping_color_type == 3)
          (void) png_set_tRNS(ping, ping_info,
                 ping_trans_alpha,
                 ping_num_trans,
                 NULL);
 
       else
         {
            (void) png_set_tRNS(ping, ping_info,
                   NULL,
                   0,
                   &ping_trans_color);
 
            if (logging != MagickFalse)
              {
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""     tRNS color   =(%d,%d,%d)"",
                        (int) ping_trans_color.red,
                        (int) ping_trans_color.green,
                        (int) ping_trans_color.blue);
              }
          }
     }
 
    
   (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-b"",logging);
 
   png_write_info(ping,ping_info);
 
    
   (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-m"",logging);
 
   ping_wrote_caNv = MagickFalse;
 
    
   if (ping_exclude_caNv == MagickFalse)
     {
       if ((image->page.width != 0 && image->page.width != image->columns) ||
           (image->page.height != 0 && image->page.height != image->rows) ||
           image->page.x != 0 || image->page.y != 0)
         {
           unsigned char
             chunk[20];
 
           (void) WriteBlobMSBULong(image,16L);   
           PNGType(chunk,mng_caNv);
           LogPNGChunk(logging,mng_caNv,16L);
           PNGLong(chunk+4,(png_uint_32) image->page.width);
           PNGLong(chunk+8,(png_uint_32) image->page.height);
           PNGsLong(chunk+12,(png_int_32) image->page.x);
           PNGsLong(chunk+16,(png_int_32) image->page.y);
           (void) WriteBlob(image,20,chunk);
           (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
           ping_wrote_caNv = MagickTrue;
         }
     }
 
 #if defined(PNG_oFFs_SUPPORTED)
   if (ping_exclude_oFFs == MagickFalse && ping_wrote_caNv == MagickFalse)
     {
       if (image->page.x || image->page.y)
         {
            png_set_oFFs(ping,ping_info,(png_int_32) image->page.x,
               (png_int_32) image->page.y, 0);
 
            if (logging != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Setting up oFFs chunk with x=%d, y=%d, units=0"",
                  (int) image->page.x, (int) image->page.y);
         }
     }
 #endif
 
    
   if (ping_exclude_vpAg == MagickFalse && ping_wrote_caNv == MagickFalse)
     {
       if ((image->page.width != 0 && image->page.width != image->columns) ||
           (image->page.height != 0 && image->page.height != image->rows))
         {
           unsigned char
             chunk[14];
 
           (void) WriteBlobMSBULong(image,9L);   
           PNGType(chunk,mng_vpAg);
           LogPNGChunk(logging,mng_vpAg,9L);
           PNGLong(chunk+4,(png_uint_32) image->page.width);
           PNGLong(chunk+8,(png_uint_32) image->page.height);
           chunk[12]=0;    
           (void) WriteBlob(image,13,chunk);
           (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
         }
     }
 
 #if (PNG_LIBPNG_VER == 10206)
      
 #define PNG_HAVE_IDAT               0x04
     ping->mode |= PNG_HAVE_IDAT;
 #undef PNG_HAVE_IDAT
 #endif
 
   png_set_packing(ping);
    
   rowbytes=image->columns;
   if (image_depth > 8)
     rowbytes*=2;
   switch (ping_color_type)
     {
       case PNG_COLOR_TYPE_RGB:
         rowbytes*=3;
         break;
 
       case PNG_COLOR_TYPE_GRAY_ALPHA:
         rowbytes*=2;
         break;
 
       case PNG_COLOR_TYPE_RGBA:
         rowbytes*=4;
         break;
 
       default:
         break;
     }
 
   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""  Writing PNG image data"");
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Allocating %.20g bytes of memory for pixels"",(double) rowbytes);
     }
   pixel_info=AcquireVirtualMemory(rowbytes,sizeof(*ping_pixels));
   if (pixel_info == (MemoryInfo *) NULL)
     png_error(ping,""Allocation of memory for pixels failed"");
   ping_pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
 
    
   quantum_info=AcquireQuantumInfo(image_info,image);
   if (quantum_info == (QuantumInfo *) NULL)
     png_error(ping,""Memory allocation for quantum_info failed"");
   quantum_info->format=UndefinedQuantumFormat;
   SetQuantumDepth(image,quantum_info,image_depth);
   (void) SetQuantumEndian(image,quantum_info,MSBEndian);
   num_passes=png_set_interlace_handling(ping);
 
   if ((!mng_info->write_png8 && !mng_info->write_png24 &&
        !mng_info->write_png48 && !mng_info->write_png64 &&
        !mng_info->write_png32) &&
        (mng_info->IsPalette ||
        (image_info->type == BilevelType)) &&
        image_matte == MagickFalse &&
        ping_have_non_bw == MagickFalse)
     {
        
       register const Quantum
         *p;
 
       SetQuantumDepth(image,quantum_info,8);
       for (pass=0; pass < num_passes; pass++)
       {
          
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           if (logging != MagickFalse && y == 0)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  ""    Writing row of pixels (0)"");
 
           p=GetVirtualPixels(image,0,y,image->columns,1,exception);
 
           if (p == (const Quantum *) NULL)
             break;
 
           if (mng_info->IsPalette)
             {
               (void) ExportQuantumPixels(image,(CacheView *) NULL,
                 quantum_info,GrayQuantum,ping_pixels,exception);
               if (mng_info->write_png_colortype-1 == PNG_COLOR_TYPE_PALETTE &&
                   mng_info->write_png_depth &&
                   mng_info->write_png_depth != old_bit_depth)
                 {
                    
                   for (i=0; i < (ssize_t) image->columns; i++)
                      *(ping_pixels+i)=(unsigned char) (*(ping_pixels+i)
                      >> (8-old_bit_depth));
                 }
             }
 
           else
             {
               (void) ExportQuantumPixels(image,(CacheView *) NULL,
                 quantum_info,RedQuantum,ping_pixels,exception);
             }
 
           if (mng_info->write_png_colortype-1 != PNG_COLOR_TYPE_PALETTE)
             for (i=0; i < (ssize_t) image->columns; i++)
                *(ping_pixels+i)=(unsigned char) ((*(ping_pixels+i) > 127) ?
                       255 : 0);
 
           if (logging != MagickFalse && y == 0)
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                 ""    Writing row of pixels (1)"");
 
           png_write_row(ping,ping_pixels);
 
           status=SetImageProgress(image,SaveImageTag,
               (MagickOffsetType) (pass * image->rows + y),
               num_passes * image->rows);
 
           if (status == MagickFalse)
             break;
         }
       }
     }
 
   else    
     {
       if ((!mng_info->write_png8 && !mng_info->write_png24 &&
           !mng_info->write_png48 && !mng_info->write_png64 &&
           !mng_info->write_png32) && (image_matte != MagickFalse ||
           (ping_bit_depth >= MAGICKCORE_QUANTUM_DEPTH)) &&
           (mng_info->IsPalette) && ping_have_color == MagickFalse)
         {
           register const Quantum
             *p;
 
           for (pass=0; pass < num_passes; pass++)
           {
 
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             p=GetVirtualPixels(image,0,y,image->columns,1,exception);
 
             if (p == (const Quantum *) NULL)
               break;
 
             if (ping_color_type == PNG_COLOR_TYPE_GRAY)
               {
                 if (mng_info->IsPalette)
                   (void) ExportQuantumPixels(image,(CacheView *) NULL,
                     quantum_info,GrayQuantum,ping_pixels,exception);
 
                 else
                   (void) ExportQuantumPixels(image,(CacheView *) NULL,
                     quantum_info,RedQuantum,ping_pixels,exception);
 
                 if (logging != MagickFalse && y == 0)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                        ""    Writing GRAY PNG pixels (2)"");
               }
 
             else  
               {
                 if (logging != MagickFalse && y == 0)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                          ""    Writing GRAY_ALPHA PNG pixels (2)"");
 
                 (void) ExportQuantumPixels(image,(CacheView *) NULL,
                   quantum_info,GrayAlphaQuantum,ping_pixels,exception);
               }
 
             if (logging != MagickFalse && y == 0)
               (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Writing row of pixels (2)"");
 
             png_write_row(ping,ping_pixels);
 
             status=SetImageProgress(image,SaveImageTag,
               (MagickOffsetType) (pass * image->rows + y),
               num_passes * image->rows);
 
             if (status == MagickFalse)
               break;
             }
           }
         }
 
       else
         {
           register const Quantum
             *p;
 
           for (pass=0; pass < num_passes; pass++)
           {
             if ((image_depth > 8) ||
                 mng_info->write_png24 ||
                 mng_info->write_png32 ||
                 mng_info->write_png48 ||
                 mng_info->write_png64 ||
                 (!mng_info->write_png8 && !mng_info->IsPalette))
             {
               for (y=0; y < (ssize_t) image->rows; y++)
               {
                 p=GetVirtualPixels(image,0,y,image->columns,1, exception);
 
                 if (p == (const Quantum *) NULL)
                   break;
 
                 if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                   {
                     if (image->storage_class == DirectClass)
                       (void) ExportQuantumPixels(image,(CacheView *) NULL,
                         quantum_info,RedQuantum,ping_pixels,exception);
 
                     else
                       (void) ExportQuantumPixels(image,(CacheView *) NULL,
                         quantum_info,GrayQuantum,ping_pixels,exception);
                   }
 
                 else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                   {
                     (void) ExportQuantumPixels(image,(CacheView *) NULL,
                       quantum_info,GrayAlphaQuantum,ping_pixels,
                       exception);
 
                     if (logging != MagickFalse && y == 0)
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""    Writing GRAY_ALPHA PNG pixels (3)"");
                   }
 
                 else if (image_matte != MagickFalse)
                   (void) ExportQuantumPixels(image,(CacheView *) NULL,
                     quantum_info,RGBAQuantum,ping_pixels,exception);
 
                 else
                   (void) ExportQuantumPixels(image,(CacheView *) NULL,
                     quantum_info,RGBQuantum,ping_pixels,exception);
 
                 if (logging != MagickFalse && y == 0)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""    Writing row of pixels (3)"");
 
                 png_write_row(ping,ping_pixels);
 
                 status=SetImageProgress(image,SaveImageTag,
                   (MagickOffsetType) (pass * image->rows + y),
                   num_passes * image->rows);
 
                 if (status == MagickFalse)
                   break;
               }
             }
 
           else
              
             {
               if ((ping_color_type != PNG_COLOR_TYPE_GRAY) &&
                   (ping_color_type != PNG_COLOR_TYPE_GRAY_ALPHA))
                 {
                   if (logging != MagickFalse)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""  pass %d, Image Is not GRAY or GRAY_ALPHA"",pass);
 
                   SetQuantumDepth(image,quantum_info,8);
                   image_depth=8;
                 }
 
               for (y=0; y < (ssize_t) image->rows; y++)
               {
                 if (logging != MagickFalse && y == 0)
                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                     ""  pass %d, Image Is RGB, 16-bit GRAY, or GRAY_ALPHA"",
                     pass);
 
                 p=GetVirtualPixels(image,0,y,image->columns,1, exception);
 
                 if (p == (const Quantum *) NULL)
                   break;
 
                 if (ping_color_type == PNG_COLOR_TYPE_GRAY)
                   {
                     SetQuantumDepth(image,quantum_info,image->depth);
 
                     (void) ExportQuantumPixels(image,(CacheView *) NULL,
                        quantum_info,GrayQuantum,ping_pixels,exception);
                   }
 
                 else if (ping_color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
                   {
                     if (logging != MagickFalse && y == 0)
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                            ""  Writing GRAY_ALPHA PNG pixels (4)"");
 
                     (void) ExportQuantumPixels(image,(CacheView *) NULL,
                          quantum_info,GrayAlphaQuantum,ping_pixels,
                          exception);
                   }
 
                 else
                   {
                     (void) ExportQuantumPixels(image,(CacheView *) NULL,
                       quantum_info,IndexQuantum,ping_pixels,exception);
 
                     if (logging != MagickFalse && y <= 2)
                     {
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  Writing row of non-gray pixels (4)"");
 
                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                           ""  ping_pixels[0]=%d,ping_pixels[1]=%d"",
                           (int)ping_pixels[0],(int)ping_pixels[1]);
                     }
                   }
                 png_write_row(ping,ping_pixels);
 
                 status=SetImageProgress(image,SaveImageTag,
                   (MagickOffsetType) (pass * image->rows + y),
                   num_passes * image->rows);
 
                 if (status == MagickFalse)
                   break;
               }
             }
           }
         }
     }
 
   if (quantum_info != (QuantumInfo *) NULL)
     quantum_info=DestroyQuantumInfo(quantum_info);
 
   if (logging != MagickFalse)
     {
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""  Wrote PNG image data"");
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Width: %.20g"",(double) ping_width);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    Height: %.20g"",(double) ping_height);
 
       if (mng_info->write_png_depth)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Defined png:bit-depth: %d"",mng_info->write_png_depth);
         }
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    PNG bit-depth written: %d"",ping_bit_depth);
 
       if (mng_info->write_png_colortype)
         {
           (void) LogMagickEvent(CoderEvent,GetMagickModule(),
             ""    Defined png:color-type: %d"",mng_info->write_png_colortype-1);
         }
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    PNG color-type written: %d"",ping_color_type);
 
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),
         ""    PNG Interlace method: %d"",ping_interlace_method);
     }
    
   if (ping_exclude_tEXt == MagickFalse || ping_exclude_zTXt == MagickFalse)
   {
     ResetImagePropertyIterator(image);
     property=GetNextImageProperty(image);
     while (property != (const char *) NULL)
     {
       png_textp
         text;
 
       value=GetImageProperty(image,property,exception);
 
        
       if ((LocaleNCompare(property,""png:"",4) != 0 &&
            LocaleNCompare(property,""jpeg:"",5) != 0) &&
 
 
            
           (ping_exclude_pHYs != MagickFalse      ||
           LocaleCompare(property,""density"") != 0 ||
           LocaleCompare(property,""units"") != 0) &&
 
            
           (ping_exclude_date == MagickFalse      ||
           LocaleNCompare(property, ""Date:"",5) != 0))
         {
         if (value != (const char *) NULL)
           {
 
 #if PNG_LIBPNG_VER >= 10400
             text=(png_textp) png_malloc(ping,
                  (png_alloc_size_t) sizeof(png_text));
 #else
             text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));
 #endif
             text[0].key=(char *) property;
             text[0].text=(char *) value;
             text[0].text_length=strlen(value);
 
             if (ping_exclude_tEXt != MagickFalse)
                text[0].compression=PNG_TEXT_COMPRESSION_zTXt;
 
             else if (ping_exclude_zTXt != MagickFalse)
                text[0].compression=PNG_TEXT_COMPRESSION_NONE;
 
             else
             {
                text[0].compression=image_info->compression == NoCompression ||
                  (image_info->compression == UndefinedCompression &&
                  text[0].text_length < 128) ? PNG_TEXT_COMPRESSION_NONE :
                  PNG_TEXT_COMPRESSION_zTXt ;
             }
 
             if (logging != MagickFalse)
               {
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Setting up text chunk"");
 
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    keyword: '%s'"",text[0].key);
               }
 
             png_set_text(ping,ping_info,text,1);
             png_free(ping,text);
           }
         }
       property=GetNextImageProperty(image);
     }
   }
 
    
   (void) Magick_png_write_chunk_from_profile(image,""PNG-chunk-e"",logging);
 
    
   if (ping_have_eXIf != MagickFalse && ping_exclude_eXIf == MagickFalse)
     {
       char
         *name;
 
       ResetImageProfileIterator(image);
 
       for (name=GetNextImageProfile(image); name != (const char *) NULL; )
       {
         if (LocaleCompare(name,""exif"") == 0)
           {
             const StringInfo
               *profile;
 
             profile=GetImageProfile(image,name);
 
             if (profile != (StringInfo *) NULL)
               {
                 png_uint_32
                   length;
 
                 unsigned char
                   chunk[4],
                   *data;
 
                StringInfo
                  *ping_profile;
 
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""  Have eXIf profile"");
 
                ping_profile=CloneStringInfo(profile);
                data=GetStringInfoDatum(ping_profile),
                length=(png_uint_32) GetStringInfoLength(ping_profile);
 
                PNGType(chunk,mng_eXIf);
                if (length < 7)
                  {
                    ping_profile=DestroyStringInfo(ping_profile);
                    break;   
                  }
 
                 
                length -= 6;
 
                LogPNGChunk(logging,chunk,length);
                (void) WriteBlobMSBULong(image,length);
                (void) WriteBlob(image,4,chunk);
                (void) WriteBlob(image,length,data+6);
                (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),
                  data+6, (uInt) length));
                ping_profile=DestroyStringInfo(ping_profile);
                break;
              }
          }
        name=GetNextImageProfile(image);
      }
   }
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  Writing PNG end info"");
 
   png_write_end(ping,ping_info);
 
   if (mng_info->need_fram && (int) image->dispose == BackgroundDispose)
     {
       if (mng_info->page.x || mng_info->page.y ||
           (ping_width != mng_info->page.width) ||
           (ping_height != mng_info->page.height))
         {
           unsigned char
             chunk[32];
 
            
           (void) WriteBlobMSBULong(image,27L);   
           PNGType(chunk,mng_FRAM);
           LogPNGChunk(logging,mng_FRAM,27L);
           chunk[4]=4;
           chunk[5]=0;   
           chunk[6]=1;   
           chunk[7]=0;   
           chunk[8]=1;   
           chunk[9]=0;   
           PNGLong(chunk+10,(png_uint_32) (0L));  
           chunk[14]=0;  
           PNGLong(chunk+15,(png_uint_32) (mng_info->page.x));  
           PNGLong(chunk+19,
              (png_uint_32) (mng_info->page.x + ping_width));
           PNGLong(chunk+23,(png_uint_32) (mng_info->page.y));  
           PNGLong(chunk+27,
              (png_uint_32) (mng_info->page.y + ping_height));
           (void) WriteBlob(image,31,chunk);
           (void) WriteBlobMSBULong(image,crc32(0,chunk,31));
           mng_info->old_framing_mode=4;
           mng_info->framing_mode=1;
         }
 
       else
         mng_info->framing_mode=3;
     }
   if (mng_info->write_mng && !mng_info->need_fram &&
       ((int) image->dispose == 3))
      png_error(ping, ""Cannot convert GIF with disposal method 3 to MNG-LC"");
 
    
 
   png_destroy_write_struct(&ping,&ping_info);
 
   pixel_info=RelinquishVirtualMemory(pixel_info);
 
   if (ping_have_blob != MagickFalse)
      (void) CloseBlob(image);
 
   image_info=DestroyImageInfo(image_info);
   image=DestroyImage(image);
 
    
   s[0]=(char) ping_bit_depth;
   s[1]='\0';
 
   (void) SetImageProperty(IMimage,""png:bit-depth-written"",s,exception);
 
   if (logging != MagickFalse)
     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
       ""  exit WriteOnePNGImage()"");
 
 #ifdef IMPNG_SETJMP_NOT_THREAD_SAFE
   UnlockSemaphoreInfo(ping_semaphore);
 #endif
 
     
 
   return(MagickTrue);
  
 
 }","[151, 152, 156, 155]",The WriteOnePNGImage function in coders/png.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted file.
205032," void UpdateContentLengthPrefs(int received_content_length,
                              int original_content_length,
                              bool via_data_reduction_proxy) {
 void UpdateContentLengthPrefs(
     int received_content_length,
     int original_content_length,
     chrome_browser_net::DataReductionRequestType data_reduction_type) {
    DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
    DCHECK_GE(received_content_length, 0);
    DCHECK_GE(original_content_length, 0);
 
   if (!g_browser_process)
     return;
 
   PrefService* prefs = g_browser_process->local_state();
   if (!prefs)
     return;
 
 #if defined(OS_ANDROID)
   bool with_data_reduction_proxy_enabled =
       g_browser_process->profile_manager()->GetDefaultProfile()->
       GetPrefs()->GetBoolean(prefs::kSpdyProxyAuthEnabled);
 #else
   bool with_data_reduction_proxy_enabled = false;
 #endif
 
   chrome_browser_net::UpdateContentLengthPrefs(
        received_content_length,
        original_content_length,
        with_data_reduction_proxy_enabled,
      via_data_reduction_proxy, prefs);
       data_reduction_type, prefs);
  }","[4, 5, 6, 7, 32, 2, 3, 31]",Use-after-free vulnerability in the HTML5 Audio implementation in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
203412," static int check_cond_jmp_op(struct bpf_verifier_env *env,
 			     struct bpf_insn *insn, int *insn_idx)
 {
 	struct bpf_verifier_state *this_branch = env->cur_state;
 	struct bpf_verifier_state *other_branch;
 	struct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs;
 	struct bpf_reg_state *dst_reg, *other_branch_regs;
 	u8 opcode = BPF_OP(insn->code);
 	int err;
 
 	if (opcode > BPF_JSLE) {
 		verbose(env, ""invalid BPF_JMP opcode %x\n"", opcode);
 		return -EINVAL;
 	}
 
 	if (BPF_SRC(insn->code) == BPF_X) {
 		if (insn->imm != 0) {
 			verbose(env, ""BPF_JMP uses reserved fields\n"");
 			return -EINVAL;
 		}
 
 		 
 		err = check_reg_arg(env, insn->src_reg, SRC_OP);
 		if (err)
 			return err;
 
 		if (is_pointer_value(env, insn->src_reg)) {
 			verbose(env, ""R%d pointer comparison prohibited\n"",
 				insn->src_reg);
 			return -EACCES;
 		}
 	} else {
 		if (insn->src_reg != BPF_REG_0) {
 			verbose(env, ""BPF_JMP uses reserved fields\n"");
 			return -EINVAL;
 		}
 	}
 
 	 
 	err = check_reg_arg(env, insn->dst_reg, SRC_OP);
 	if (err)
 		return err;
 
 	dst_reg = &regs[insn->dst_reg];
 
 	if (BPF_SRC(insn->code) == BPF_K) {
 		int pred = is_branch_taken(dst_reg, insn->imm, opcode);
 
 		if (pred == 1) {
 			  
 			*insn_idx += insn->off;
 			return 0;
 		} else if (pred == 0) {
 			 
 			return 0;
  		}
  	}
  
	other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);
 	other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,
 				  false);
  	if (!other_branch)
  		return -EFAULT;
  	other_branch_regs = other_branch->frame[other_branch->curframe]->regs;
 
 	 
 	if (BPF_SRC(insn->code) == BPF_X) {
 		if (dst_reg->type == SCALAR_VALUE &&
 		    regs[insn->src_reg].type == SCALAR_VALUE) {
 			if (tnum_is_const(regs[insn->src_reg].var_off))
 				reg_set_min_max(&other_branch_regs[insn->dst_reg],
 						dst_reg, regs[insn->src_reg].var_off.value,
 						opcode);
 			else if (tnum_is_const(dst_reg->var_off))
 				reg_set_min_max_inv(&other_branch_regs[insn->src_reg],
 						    &regs[insn->src_reg],
 						    dst_reg->var_off.value, opcode);
 			else if (opcode == BPF_JEQ || opcode == BPF_JNE)
 				 
 				reg_combine_min_max(&other_branch_regs[insn->src_reg],
 						    &other_branch_regs[insn->dst_reg],
 						    &regs[insn->src_reg],
 						    &regs[insn->dst_reg], opcode);
 		}
 	} else if (dst_reg->type == SCALAR_VALUE) {
 		reg_set_min_max(&other_branch_regs[insn->dst_reg],
 					dst_reg, insn->imm, opcode);
 	}
 
 	 
 	if (BPF_SRC(insn->code) == BPF_K &&
 	    insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) &&
 	    reg_type_may_be_null(dst_reg->type)) {
 		 
 		mark_ptr_or_null_regs(this_branch, insn->dst_reg,
 				      opcode == BPF_JNE);
 		mark_ptr_or_null_regs(other_branch, insn->dst_reg,
 				      opcode == BPF_JEQ);
 	} else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg],
 					   this_branch, other_branch) &&
 		   is_pointer_value(env, insn->dst_reg)) {
 		verbose(env, ""R%d pointer comparison prohibited\n"",
 			insn->dst_reg);
 		return -EACCES;
 	}
 	if (env->log.level)
 		print_verifier_state(env, this_branch->frame[this_branch->curframe]);
 	return 0;
 }","[60, 61, 59]","kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks."
199038," const char *string_of_NPPVariable(int variable)
 {
   const char *str;
 
   switch (variable) {
 #define _(VAL) case VAL: str = #VAL; break;
 	_(NPPVpluginNameString);
 	_(NPPVpluginDescriptionString);
 	_(NPPVpluginWindowBool);
 	_(NPPVpluginTransparentBool);
 	_(NPPVjavaClass);
 	_(NPPVpluginWindowSize);
 	_(NPPVpluginTimerInterval);
 	_(NPPVpluginScriptableInstance);
 	_(NPPVpluginScriptableIID);
 	_(NPPVjavascriptPushCallerBool);
 	_(NPPVpluginKeepLibraryInMemory);
  	_(NPPVpluginNeedsXEmbed);
  	_(NPPVpluginScriptableNPObject);
  	_(NPPVformValue);
 	_(NPPVpluginUrlRequestsDisplayedBool);
 	_(NPPVpluginWantsAllNetworkStreams);
 	_(NPPVpluginNativeAccessibleAtkPlugId);
 	_(NPPVpluginCancelSrcStream);
 	_(NPPVSupportsAdvancedKeyHandling);
  #undef _
    default:
  	switch (variable & 0xff) {
 #define _(VAL, VAR) case VAL: str = #VAR; break
 	  _(10, NPPVpluginScriptableInstance);
 #undef _
 	default:
 	  str = ""<unknown variable>"";
 	  break;
 	}
 	break;
   }
 
   return str;
 }","[21, 22, 23, 24, 25]","nspluginwrapper before 1.4.4 does not properly provide access to NPNVprivateModeBool variable settings, which could prevent Firefox plugins from determining if they should run in Private Browsing mode and allow remote attackers to bypass intended access restrictions, as demonstrated using Flash."
8624,"void Compute(OpKernelContext* const context) override {

const Tensor* node_id_range_t;
OP_REQUIRES_OK(context, context->input(""node_id_range"", &node_id_range_t));
const auto node_id_range = node_id_range_t->vec<int32>();
OP_REQUIRES(
context, node_id_range_t->dims() == 1,
errors::InvalidArgument(""node_id_range must be a rank 1 tensor, but ""
""given node_id_range has dims of "",
node_id_range_t->dims()));
OP_REQUIRES(context, node_id_range_t->dim_size(0) == 2,
errors::InvalidArgument(
""node_id_range must be a rank 1 tensor with shape=[2], but ""
""given node_id_range has shape "",
node_id_range_t->dim_size(0), "" on its first dim""));
const int32_t node_id_first = node_id_range(0);
const int32_t node_id_last = node_id_range(1);


OpInputList stats_summaries_list;
OP_REQUIRES_OK(context, context->input_list(""stats_summaries_list"",
&stats_summaries_list));


DCHECK_GT(stats_summaries_list.size(), 0);
const int32_t feature_dims = stats_summaries_list[0].dim_size(1);

const int32_t num_buckets = stats_summaries_list[0].dim_size(2) - 1;
const int32_t logits_dim = logits_dim_;
const int32_t hessian_dim =
stats_summaries_list[0].dim_size(3) - logits_dim;
DCHECK_GT(hessian_dim, 0);
DCHECK_LE(hessian_dim, logits_dim * logits_dim);



std::vector<TTypes<float, 4>::ConstTensor> stats_summaries;
DCHECK_EQ(stats_summaries_list.size(), num_features_);
stats_summaries.reserve(num_features_);
for (const auto& tensor : stats_summaries_list) {
stats_summaries.emplace_back(tensor.tensor<float, 4>());
}


const Tensor* split_types_t;
OP_REQUIRES_OK(context, context->input(""split_types"", &split_types_t));
const auto split_types = split_types_t->vec<tstring>();
DCHECK_EQ(split_types.size(), num_features_);

for (int i = 0; i < num_features_; ++i) {
if (!(split_types(i) == kInequalitySplit ||
split_types(i) == kEqualitySplit)) {
OP_REQUIRES_OK(
context,
errors::Aborted(
""Operation received an exception: Incorrect split type""));
}
}

const Tensor* candidate_feature_ids_t;
OP_REQUIRES_OK(context, context->input(""candidate_feature_ids"",
&candidate_feature_ids_t));
const auto candidate_feature_ids = candidate_feature_ids_t->vec<int32>();
DCHECK_EQ(candidate_feature_ids.size(), num_features_);


const Tensor* l1_t;
OP_REQUIRES_OK(context, context->input(""l1"", &l1_t));
const auto l1 = l1_t->scalar<float>()();
DCHECK_GE(l1, 0);
if (logits_dim_ > 1) {

DCHECK_EQ(l1, 0);
}
const Tensor* l2_t;
OP_REQUIRES_OK(context, context->input(""l2"", &l2_t));
const auto l2 = l2_t->scalar<float>()();
DCHECK_GE(l2, 0);
const Tensor* tree_complexity_t;
OP_REQUIRES_OK(context,
context->input(""tree_complexity"", &tree_complexity_t));
const auto tree_complexity = tree_complexity_t->scalar<float>()();
const Tensor* min_node_weight_t;
OP_REQUIRES_OK(context,
context->input(""min_node_weight"", &min_node_weight_t));
const auto min_node_weight = min_node_weight_t->scalar<float>()();

std::vector<int32> output_node_ids;
std::vector<float> output_gains;
std::vector<int32> output_feature_ids;
std::vector<int32> output_feature_dimensions;
std::vector<int32> output_thresholds;
std::vector<Eigen::VectorXf> output_left_node_contribs;
std::vector<Eigen::VectorXf> output_right_node_contribs;
std::vector<string> output_split_types;



float parent_gain;
for (int32_t node_id = node_id_first; node_id < node_id_last; ++node_id) {
float best_gain = std::numeric_limits<float>::lowest();
int32_t best_bucket;
int32_t best_f_id;
int32_t best_f_dim;
string best_split_type;
Eigen::VectorXf best_contrib_for_left(logits_dim);
Eigen::VectorXf best_contrib_for_right(logits_dim);


ConstMatrixMap stats_mat(&stats_summaries[0](node_id, 0, 0, 0),
num_buckets + 1,
logits_dim + hessian_dim);
const Eigen::VectorXf total_grad =
stats_mat.leftCols(logits_dim).colwise().sum();
const Eigen::VectorXf total_hess =
stats_mat.rightCols(hessian_dim).colwise().sum();
if (total_hess.norm() < min_node_weight) {
continue;
}
Eigen::VectorXf unused(logits_dim);
CalculateWeightsAndGains(total_grad, total_hess, l1, l2, &unused,
&parent_gain);
for (int f_idx = 0; f_idx < num_features_; ++f_idx) {
const string split_type = split_types(f_idx);
TTypes<float, 4>::ConstTensor stats_summary = stats_summaries[f_idx];
float f_best_gain = std::numeric_limits<float>::lowest();
int32_t f_best_bucket;
int32_t f_best_f_dim;
string f_best_split_type;
Eigen::VectorXf f_best_contrib_for_left(logits_dim);
Eigen::VectorXf f_best_contrib_for_right(logits_dim);

if (split_type == kInequalitySplit) {
CalculateBestInequalitySplit(
stats_summary, node_id, feature_dims, logits_dim, hessian_dim,
num_buckets, min_node_weight, l1, l2, &f_best_gain,
&f_best_bucket, &f_best_f_dim, &f_best_split_type,
&f_best_contrib_for_left, &f_best_contrib_for_right);
} else {
CalculateBestEqualitySplit(
stats_summary, total_grad, total_hess, node_id, feature_dims,
logits_dim, hessian_dim, num_buckets, l1, l2, &f_best_gain,
&f_best_bucket, &f_best_f_dim, &f_best_split_type,
&f_best_contrib_for_left, &f_best_contrib_for_right);
}
if (f_best_gain > best_gain) {
best_gain = f_best_gain;
best_f_id = candidate_feature_ids(f_idx);
best_f_dim = f_best_f_dim;
best_split_type = f_best_split_type;
best_bucket = f_best_bucket;
best_contrib_for_left = f_best_contrib_for_left;
best_contrib_for_right = f_best_contrib_for_right;
}
}
if (best_gain == std::numeric_limits<float>::lowest()) {

continue;
}
output_node_ids.push_back(node_id);

output_gains.push_back(best_gain - parent_gain);
output_feature_ids.push_back(best_f_id);
output_feature_dimensions.push_back(best_f_dim);


output_split_types.push_back(best_split_type);
output_thresholds.push_back(best_bucket);
output_left_node_contribs.push_back(best_contrib_for_left);
output_right_node_contribs.push_back(best_contrib_for_right);
}
const int num_nodes = output_node_ids.size();

Tensor* output_node_ids_t = nullptr;
OP_REQUIRES_OK(context, context->allocate_output(""node_ids"", {num_nodes},
&output_node_ids_t));
auto output_node_ids_vec = output_node_ids_t->vec<int32>();


Tensor* output_gains_t;
OP_REQUIRES_OK(context, context->allocate_output(""gains"", {num_nodes},
&output_gains_t));
auto output_gains_vec = output_gains_t->vec<float>();


Tensor* output_features_ids_t;
OP_REQUIRES_OK(context, context->allocate_output(""feature_ids"", {num_nodes},
&output_features_ids_t));
auto output_features_vec = output_features_ids_t->vec<int32>();


Tensor* output_feature_dimension_t;
OP_REQUIRES_OK(context,
context->allocate_output(""feature_dimensions"", {num_nodes},
&output_feature_dimension_t));
auto output_feature_dimensions_vec =
output_feature_dimension_t->vec<int32>();


Tensor* output_thresholds_t;
OP_REQUIRES_OK(context, context->allocate_output(""thresholds"", {num_nodes},
&output_thresholds_t));
auto output_thresholds_vec = output_thresholds_t->vec<int32>();


Tensor* output_left_node_contribs_t;
OP_REQUIRES_OK(context, context->allocate_output(
""left_node_contribs"", {num_nodes, logits_dim},
&output_left_node_contribs_t));
auto output_left_node_contribs_matrix =
output_left_node_contribs_t->matrix<float>();


Tensor* output_right_node_contribs_t;
OP_REQUIRES_OK(context, context->allocate_output(
""right_node_contribs"", {num_nodes, logits_dim},
&output_right_node_contribs_t));
auto output_right_node_contribs_matrix =
output_right_node_contribs_t->matrix<float>();


Tensor* output_split_types_t;
OP_REQUIRES_OK(
context, context->allocate_output(""split_with_default_directions"",
{num_nodes}, &output_split_types_t));
auto output_split_types_vec = output_split_types_t->vec<tstring>();


for (int i = 0; i < num_nodes; ++i) {
output_node_ids_vec(i) = output_node_ids[i];
output_features_vec(i) = output_feature_ids[i];

output_gains_vec(i) = output_gains[i] - tree_complexity;
output_feature_dimensions_vec(i) = output_feature_dimensions[i];
output_thresholds_vec(i) = output_thresholds[i];
for (int j = 0; j < logits_dim; ++j) {
output_left_node_contribs_matrix(i, j) =
output_left_node_contribs[i][j];
output_right_node_contribs_matrix(i, j) =
output_right_node_contribs[i][j];
}
output_split_types_vec(i) = output_split_types[i];
}
}","[32, 33]","TensorFlow is an open source platform for machine learning. In affected versions the code for boosted trees in TensorFlow is still missing validation. As a result, attackers can trigger denial of service (via dereferencing `nullptr`s or via `CHECK`-failures) as well as abuse undefined behavior (binding references to `nullptr`s). An attacker can also read and write from heap buffers, depending on the API that gets used and the arguments that are passed to the call. Given that the boosted trees implementation in TensorFlow is unmaintained, it is recommend to no longer use these APIs. We will deprecate TensorFlow's boosted trees APIs in subsequent releases. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range."
1887,"void CoreUserInputHandler::doMode(const BufferInfo &bufferInfo, const QChar& addOrRemove, const QChar& mode, const QString &nicks)
{
QString m;
bool isNumber;
int maxModes = network()->support(""MODES"").toInt(&isNumber);
if (!isNumber || maxModes == 0) maxModes = 1;

QStringList nickList;
if (nicks == ""*"") {
const QList<IrcUser*> users = network()->ircChannel(bufferInfo.bufferName())->ircUsers();
foreach(IrcUser *user, users) {
if ((addOrRemove == '+' && !network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode))
|| (addOrRemove == '-' && network()->ircChannel(bufferInfo.bufferName())->userModes(user).contains(mode)))
nickList.append(user->nick());
}
} else {
nickList = nicks.split(' ', QString::SkipEmptyParts);
}

if (nickList.count() == 0) return;

while (!nickList.isEmpty()) {
int amount = qMin(nickList.count(), maxModes);
QString m = addOrRemove; for(int i = 0; i < amount; i++) m += mode;
QStringList params;
params << bufferInfo.bufferName() << m;
for(int i = 0; i < amount; i++) params << nickList.takeFirst();
emit putCmd(""MODE"", serverEncode(params));
}
}",[9],"The CoreUserInputHandler::doMode function in core/coreuserinputhandler.cpp in Quassel 0.10.0 allows remote attackers to cause a denial of service (application crash) via the ""/op *"" command in a query."
7816,"GF_Err flac_dmx_process(GF_Filter *filter)
{
GF_FLACDmxCtx *ctx = gf_filter_get_udta(filter);
GF_FilterPacket *pck, *dst_pck;
u8 *output;
u8 *start;
Bool final_flush=GF_FALSE;
u32 pck_size, remain, prev_pck_size;
u64 cts = GF_FILTER_NO_TS;
FLACHeader hdr;


if (!ctx->duration.num)
flac_dmx_check_dur(filter, ctx);

if (ctx->opid && !ctx->is_playing)
return GF_OK;

pck = gf_filter_pid_get_packet(ctx->ipid);
if (!pck) {
if (gf_filter_pid_is_eos(ctx->ipid)) {
if (!ctx->flac_buffer_size) {
if (ctx->opid)
gf_filter_pid_set_eos(ctx->opid);
if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
ctx->src_pck = NULL;
return GF_EOS;
}
final_flush = GF_TRUE;
} else {
return GF_OK;
}
}

prev_pck_size = ctx->flac_buffer_size;
if (pck && !ctx->resume_from) {
u8 *data = (u8 *) gf_filter_pck_get_data(pck, &pck_size);

if (ctx->byte_offset != GF_FILTER_NO_BO) {
u64 byte_offset = gf_filter_pck_get_byte_offset(pck);
if (!ctx->flac_buffer_size) {
ctx->byte_offset = byte_offset;
} else if (ctx->byte_offset + ctx->flac_buffer_size != byte_offset) {
ctx->byte_offset = GF_FILTER_NO_BO;
if ((byte_offset != GF_FILTER_NO_BO) && (byte_offset>ctx->flac_buffer_size) ) {
ctx->byte_offset = byte_offset - ctx->flac_buffer_size;
}
}
}

if (ctx->flac_buffer_size + pck_size > ctx->flac_buffer_alloc) {
ctx->flac_buffer_alloc = ctx->flac_buffer_size + pck_size;
ctx->flac_buffer = gf_realloc(ctx->flac_buffer, ctx->flac_buffer_alloc);
}
memcpy(ctx->flac_buffer + ctx->flac_buffer_size, data, pck_size);
ctx->flac_buffer_size += pck_size;
}


if (ctx->timescale && pck) {
cts = gf_filter_pck_get_cts(pck);
}

if (cts == GF_FILTER_NO_TS) {

prev_pck_size = 0;
}

remain = ctx->flac_buffer_size;
start = ctx->flac_buffer;

if (ctx->resume_from) {
start += ctx->resume_from - 1;
remain -= ctx->resume_from - 1;
ctx->resume_from = 0;
}

while (remain>2) {
u32 next_frame=0, nb_samp;
u32 cur_size = remain-2;
u8 *cur_buf = start+2;
u8 *hdr_start = NULL;

if (final_flush) {
next_frame = remain;
} else {
while (cur_size) {

hdr_start = memchr(cur_buf, 0xFF, cur_size);
if (!hdr_start) break;
next_frame = (u32) (hdr_start-start);
if (next_frame == remain)
break;

if ((hdr_start[1]&0xFC) == 0xF8) {
if (flac_parse_header(ctx, hdr_start, (u32) remain - next_frame, &hdr))
break;
}
cur_buf = hdr_start+1;
cur_size = (u32) (cur_buf - start);
assert(cur_size<=remain);
cur_size = remain - cur_size;
hdr_start = NULL;
}
if (!hdr_start) break;
if (next_frame == remain)
break;
}


if (!ctx->initialized) {
u32 size = next_frame;
u32 dsi_end = 0;

gf_bs_reassign_buffer(ctx->bs, ctx->flac_buffer, size);
u32 magic = gf_bs_read_u32(ctx->bs);
if (magic != GF_4CC('f','L','a','C')) {

}
while (gf_bs_available(ctx->bs)) {
Bool last = gf_bs_read_int(ctx->bs, 1);
u32 type = gf_bs_read_int(ctx->bs, 7);
u32 len = gf_bs_read_int(ctx->bs, 24);

if (type==0) {
u16 min_block_size = gf_bs_read_u16(ctx->bs);
u16 max_block_size = gf_bs_read_u16(ctx->bs);
gf_bs_read_u24(ctx->bs);
gf_bs_read_u24(ctx->bs);
ctx->sample_rate = gf_bs_read_int(ctx->bs, 20);
ctx->nb_channels = 1 + gf_bs_read_int(ctx->bs, 3);
ctx->bits_per_sample = 1 + gf_bs_read_int(ctx->bs, 5);
if (min_block_size==max_block_size) ctx->block_size = min_block_size;
else ctx->block_size = 0;

ctx->duration.num = gf_bs_read_long_int(ctx->bs, 36);
ctx->duration.den = ctx->sample_rate;

gf_bs_skip_bytes(ctx->bs, 16);
dsi_end = (u32) gf_bs_get_position(ctx->bs);

} else {


gf_bs_skip_bytes(ctx->bs, len);
}
if (last) break;
}
flac_dmx_check_pid(filter, ctx, ctx->flac_buffer+4, dsi_end-4);
remain -= size;
start += size;
ctx->initialized = GF_TRUE;
if (!ctx->is_playing) break;
continue;
}


if ((start[0] != 0xFF) && ((start[1]&0xFC) != 0xF8)) {
GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[FLACDmx] invalid frame, droping %d bytes and resyncing\n"", next_frame));
start += next_frame;
remain -= next_frame;
continue;
}

flac_parse_header(ctx,start, next_frame, &hdr);
if (hdr.sample_rate != ctx->sample_rate) {
ctx->sample_rate = hdr.sample_rate;
gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));
}

nb_samp = hdr.block_size;

if (ctx->in_seek) {
u64 nb_samples_at_seek = (u64) (ctx->start_range * ctx->sample_rate);
if (ctx->cts + nb_samp >= nb_samples_at_seek) {

ctx->in_seek = GF_FALSE;
}
}

if (ctx->timescale && !prev_pck_size && (cts != GF_FILTER_NO_TS) ) {
ctx->cts = cts;
cts = GF_FILTER_NO_TS;
}

if (!ctx->in_seek) {
dst_pck = gf_filter_pck_new_alloc(ctx->opid, next_frame, &output);
memcpy(output, start, next_frame);

gf_filter_pck_set_cts(dst_pck, ctx->cts);
if (!ctx->timescale || (ctx->timescale==ctx->sample_rate) )
gf_filter_pck_set_duration(dst_pck, nb_samp);
else {
gf_filter_pck_set_duration(dst_pck, (nb_samp * ctx->timescale) / ctx->sample_rate);
}
gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);

if (ctx->byte_offset != GF_FILTER_NO_BO) {
gf_filter_pck_set_byte_offset(dst_pck, ctx->byte_offset);
}
gf_filter_pck_send(dst_pck);
}
flac_dmx_update_cts(ctx, nb_samp);

assert (start[0] == 0xFF);
assert((start[1]&0xFC) == 0xF8);

start += next_frame;
assert(remain >= next_frame);
remain -= next_frame;

}

if (!pck) {
ctx->flac_buffer_size = 0;
return flac_dmx_process(filter);
} else {
if (remain < ctx->flac_buffer_size) {
memmove(ctx->flac_buffer, start, remain);
}
ctx->flac_buffer_size = remain;
gf_filter_pid_drop_packet(ctx->ipid);
}
return GF_OK;
}","[13, 149]","There is a integer overflow in function filter_core/filter_props.c:gf_props_assign_value in GPAC 1.0.1. In which, the arg const GF_PropertyValue *value,maybe value->value.data.size is a negative number. In result, memcpy in gf_props_assign_value failed."
198929,"  int do_adjtimex(struct timex *txc)
  {
	long mtemp, save_adjust, rem;
 	long mtemp, save_adjust;
  	s64 freq_adj;
  	int result;
  
 	 
 	if (txc->modes && !capable(CAP_SYS_TIME))
 		return -EPERM;
 
 	 
 
 	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {
 	   
 		if (txc->modes != ADJ_OFFSET_SINGLESHOT &&
 					txc->modes != ADJ_OFFSET_SS_READ)
 			return -EINVAL;
 	}
 
 	if (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))
 	   
 		if (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )
 			return -EINVAL;
 
 	 
 	if (txc->modes & ADJ_TICK)
 		if (txc->tick <  900000/USER_HZ ||
 		    txc->tick > 1100000/USER_HZ)
 			return -EINVAL;
 
 	write_seqlock_irq(&xtime_lock);
 	result = time_state;	 
 
 	 
 	save_adjust = time_adjust;
 
 #if 0	 
 	time_status &= ~STA_CLOCKERR;		 
 #endif
 	 
 	if (txc->modes)
 	{
 	    if (txc->modes & ADJ_STATUS)	 
 		time_status =  (txc->status & ~STA_RONLY) |
 			      (time_status & STA_RONLY);
 
 	    if (txc->modes & ADJ_FREQUENCY) {	 
 		if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {
 		    result = -EINVAL;
 		    goto leave;
 		}
 		time_freq = ((s64)txc->freq * NSEC_PER_USEC)
 				>> (SHIFT_USEC - SHIFT_NSEC);
 	    }
 
 	    if (txc->modes & ADJ_MAXERROR) {
 		if (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {
 		    result = -EINVAL;
 		    goto leave;
 		}
 		time_maxerror = txc->maxerror;
 	    }
 
 	    if (txc->modes & ADJ_ESTERROR) {
 		if (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {
 		    result = -EINVAL;
 		    goto leave;
 		}
 		time_esterror = txc->esterror;
 	    }
 
 	    if (txc->modes & ADJ_TIMECONST) {	 
 		if (txc->constant < 0) {	 
 		    result = -EINVAL;
 		    goto leave;
 		}
 		time_constant = min(txc->constant + 4, (long)MAXTC);
 	    }
 
 	    if (txc->modes & ADJ_OFFSET) {	 
 		if (txc->modes == ADJ_OFFSET_SINGLESHOT) {
 		     
 		    time_adjust = txc->offset;
 		}
 		else if (time_status & STA_PLL) {
 		    time_offset = txc->offset * NSEC_PER_USEC;
 
 		     
 		    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);
 		    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);
 
 		     
 
 		    if (time_status & STA_FREQHOLD || time_reftime == 0)
 		        time_reftime = xtime.tv_sec;
 		    mtemp = xtime.tv_sec - time_reftime;
 		    time_reftime = xtime.tv_sec;
 
 		    freq_adj = time_offset * mtemp;
 		    freq_adj = shift_right(freq_adj, time_constant * 2 +
 					   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);
 		    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))
 			freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);
  		    freq_adj += time_freq;
  		    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);
  		    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);
		    time_offset = div_long_long_rem_signed(time_offset,
							   NTP_INTERVAL_FREQ,
							   &rem);
 		    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);
  		    time_offset <<= SHIFT_UPDATE;
  		}  
  	    }  
 	    if (txc->modes & ADJ_TICK)
 		tick_usec = txc->tick;
 
 	    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))
 		    ntp_update_frequency();
 	}  
 leave:	if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)
 		result = TIME_ERROR;
 
 	if ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||
 			(txc->modes == ADJ_OFFSET_SS_READ))
 		txc->offset = save_adjust;
 	else
 		txc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *
 	    			NTP_INTERVAL_FREQ / 1000;
 	txc->freq	   = (time_freq / NSEC_PER_USEC) <<
 				(SHIFT_USEC - SHIFT_NSEC);
 	txc->maxerror	   = time_maxerror;
 	txc->esterror	   = time_esterror;
 	txc->status	   = time_status;
 	txc->constant	   = time_constant;
 	txc->precision	   = 1;
 	txc->tolerance	   = MAXFREQ;
 	txc->tick	   = tick_usec;
 
 	 
 	txc->ppsfreq	   = 0;
 	txc->jitter	   = 0;
 	txc->shift	   = 0;
 	txc->stabil	   = 0;
 	txc->jitcnt	   = 0;
 	txc->calcnt	   = 0;
 	txc->errcnt	   = 0;
 	txc->stbcnt	   = 0;
 	write_sequnlock_irq(&xtime_lock);
 	do_gettimeofday(&txc->time);
 	notify_cmos_timer();
 	return(result);
 }","[4, 111, 3, 108, 109, 110]",The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.
202714," daemon_AuthUserPwd(char *username, char *password, char *errbuf)
 {
 #ifdef _WIN32
 	 
 	DWORD error;
  	HANDLE Token;
 	char errmsgbuf[PCAP_ERRBUF_SIZE];	 
 
  	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
  	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		error = GetLastError();
 		if (error != ERROR_LOGON_FAILURE)
 		{
 			 
 			 
 			pcap_fmt_errmsg_for_win32_err(errmsgbuf,
 			    PCAP_ERRBUF_SIZE, error, ""LogonUser() failed"");
 			rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
 		}			    
  		return -1;
  	}
  
  	if (ImpersonateLoggedOnUser(Token) == 0)
  	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		pcap_fmt_errmsg_for_win32_err(errmsgbuf, PCAP_ERRBUF_SIZE,
  		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
 		rpcapd_log(LOGPRIO_ERROR, ""%s"", errmsgbuf);
  		CloseHandle(Token);
  		return -1;
  	}
 
 	CloseHandle(Token);
 	return 0;
 
 #else
 	 
 	int error;
  	struct passwd *user;
  	char *user_password;
  #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
 	char *crypt_password;
 
  	if ((user = getpwnam(username)) == NULL)
  	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
  		return -1;
  	}
  
  #ifdef HAVE_GETSPNAM
  	if ((usersp = getspnam(username)) == NULL)
  	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
  		return -1;
  	}
  	user_password = usersp->sp_pwdp;
 #else
 	 
  	user_password = user->pw_passwd;
  #endif
  
 	 
 	 
 	 
 	 
 	 
 	errno = 0;
  	crypt_password = crypt(password, user_password);
  	if (crypt_password == NULL)
  	{
 		error = errno;
  		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
 		if (error == 0)
 		{
 			 
 			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed"");
 		}
 		else
 		{
 			rpcapd_log(LOGPRIO_ERROR, ""crypt() failed: %s"",
 			    strerror(error));
 		}
  		return -1;
  	}
  	if (strcmp(user_password, crypt_password) != 0)
  	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
  		return -1;
  	}
  
  	if (setuid(user->pw_uid))
  	{
 		error = errno;
  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
 		    error, ""setuid"");
 		rpcapd_log(LOGPRIO_ERROR, ""setuid() failed: %s"",
 		    strerror(error));
  		return -1;
  	}
  
   
 	return 0;
 
 #endif
 
 }","[5, 7, 8, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 29, 30, 32, 42, 53, 61, 70, 71, 72, 73, 74, 75, 79, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 96, 102, 105, 106, 107, 11, 12, 28, 52, 60, 95, 104]","rpcapd/daemon.c in libpcap before 1.9.1 on non-Windows platforms provides details about why authentication failed, which might make it easier for attackers to enumerate valid usernames."
204300," void NaClProcessHost::OnPpapiChannelCreated(
    const IPC::ChannelHandle& channel_handle) {
  DCHECK(enable_ipc_proxy_);
  ReplyToRenderer(channel_handle);
   return ReplyToRenderer() && StartNaClExecution();
  }","[5, 2, 3, 4]",Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.
9853,"void SFS_ObjectMemberAccess(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
SFS_AddString(parser, ""."");
SFS_Identifier(parser);
}",[5],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.
206200," void ExpectCanDiscardFalseTrivial(const LifecycleUnit* lifecycle_unit,
                                   DiscardReason discard_reason) {
    DecisionDetails decision_details;
    EXPECT_FALSE(lifecycle_unit->CanDiscard(discard_reason, &decision_details));
    EXPECT_FALSE(decision_details.IsPositive());
  EXPECT_TRUE(decision_details.reasons().empty());
    
    
   EXPECT_TRUE(decision_details.reasons().empty() ||
               (decision_details.reasons().size() == 4));
  }","[7, 8, 9, 10, 6]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
201023," print_attr_string(netdissect_options *ndo,
                   register const u_char *data, u_int length, u_short attr_code)
 {
    register u_int i;
 
    ND_TCHECK2(data[0],length);
 
    switch(attr_code)
     {
        case TUNNEL_PASS:
             if (length < 3)
           {
              ND_PRINT((ndo, ""%s"", tstr));
              return;
           }
               goto trunc;
             if (*data && (*data <=0x1F) )
                ND_PRINT((ndo, ""Tag[%u] "", *data));
             else
               ND_PRINT((ndo, ""Tag[Unused] ""));
            data++;
            length--;
            ND_PRINT((ndo, ""Salt %u "", EXTRACT_16BITS(data)));
            data+=2;
            length-=2;
         break;
       case TUNNEL_CLIENT_END:
       case TUNNEL_SERVER_END:
       case TUNNEL_PRIV_GROUP:
       case TUNNEL_ASSIGN_ID:
       case TUNNEL_CLIENT_AUTH:
       case TUNNEL_SERVER_AUTH:
             if (*data <= 0x1F)
             {
                if (length < 1)
              {
                 ND_PRINT((ndo, ""%s"", tstr));
                 return;
              }
                  goto trunc;
                if (*data)
                  ND_PRINT((ndo, ""Tag[%u] "", *data));
                else
                 ND_PRINT((ndo, ""Tag[Unused] ""));
               data++;
               length--;
             }
          break;
        case EGRESS_VLAN_NAME:
            if (length < 1)
               goto trunc;
             ND_PRINT((ndo, ""%s (0x%02x) "",
                    tok2str(rfc4675_tagged,""Unknown tag"",*data),
                    *data));
            data++;
            length--;
          break;
     }
  
   for (i=0; *data && i < length ; i++, data++)
    for (i=0; i < length && *data; i++, data++)
         ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));
  
     return;
 
    trunc:
       ND_PRINT((ndo, ""%s"", tstr));
 }","[16, 40, 50, 51, 61, 12, 13, 14, 15, 36, 37, 38, 39, 60]",The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().
198324," static bool on_accept(private_stroke_socket_t *this, stream_t *stream)
 {
 	stroke_msg_t *msg;
 	uint16_t len;
 	FILE *out;
 
 	 
 	if (!stream->read_all(stream, &len, sizeof(len)))
 	{
 		if (errno != EWOULDBLOCK)
 		{
 			DBG1(DBG_CFG, ""reading length of stroke message failed: %s"",
 				 strerror(errno));
                 }
                 return FALSE;
         }
        if (len < offsetof(stroke_msg_t, buffer))
        {
                DBG1(DBG_CFG, ""invalid stroke message length %d"", len);
                return FALSE;
        }
  
          
         msg = malloc(len + 1);
 			DBG1(DBG_CFG, ""reading stroke message failed: %s"", strerror(errno));
 		}","[17, 18, 19, 20, 21]","In stroke_socket.c in strongSwan before 5.6.3, a missing packet length check could allow a buffer underflow, which may lead to resource exhaustion and denial of service while reading from the socket."
202916," static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,
 				  struct stream *s, struct attr *attr,
 				  uint8_t attrtype)
 {
 	unsigned int attrlenfield = 0;
 	unsigned int attrhdrlen = 0;
 	struct bgp_attr_encap_subtlv *subtlvs;
 	struct bgp_attr_encap_subtlv *st;
 	const char *attrname;
 
 	if (!attr || (attrtype == BGP_ATTR_ENCAP
 		      && (!attr->encap_tunneltype
 			  || attr->encap_tunneltype == BGP_ENCAP_TYPE_MPLS)))
 		return;
 
 	switch (attrtype) {
 	case BGP_ATTR_ENCAP:
 		attrname = ""Tunnel Encap"";
 		subtlvs = attr->encap_subtlvs;
 		if (subtlvs == NULL)  
 			return;
 		 
 		attrlenfield = 2 + 2;  
  		attrhdrlen = 1 + 1;    
  		break;
  
#if ENABLE_BGP_VNC
 #if ENABLE_BGP_VNC_ATTR
  	case BGP_ATTR_VNC:
  		attrname = ""VNC"";
  		subtlvs = attr->vnc_subtlvs;
 		if (subtlvs == NULL)  
 			return;
 		attrlenfield = 0;    
 		attrhdrlen = 2 + 2;  
 		break;
 #endif
 
 	default:
 		assert(0);
 	}
 
 	 
 	for (st = subtlvs; st; st = st->next) {
 		attrlenfield += (attrhdrlen + st->length);
 	}
 
 	if (attrlenfield > 0xffff) {
 		zlog_info(""%s attribute is too long (length=%d), can't send it"",
 			  attrname, attrlenfield);
 		return;
 	}
 
 	if (attrlenfield > 0xff) {
 		 
 		stream_putc(s,
 			    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL
 				    | BGP_ATTR_FLAG_EXTLEN);
 		stream_putc(s, attrtype);
 		stream_putw(s, attrlenfield & 0xffff);
 	} else {
 		 
 		stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL);
 		stream_putc(s, attrtype);
 		stream_putc(s, attrlenfield & 0xff);
 	}
 
 	if (attrtype == BGP_ATTR_ENCAP) {
 		 
 		stream_putw(s, attr->encap_tunneltype);
 		stream_putw(s, attrlenfield - 4);
 	}
 
 	 
 	for (st = subtlvs; st; st = st->next) {
 		if (attrtype == BGP_ATTR_ENCAP) {
 			stream_putc(s, st->type);
 			stream_putc(s, st->length);
 #if ENABLE_BGP_VNC
 		} else {
 			stream_putw(s, st->type);
 			stream_putw(s, st->length);
 #endif
 		}
 		stream_put(s, st->value, st->length);
 	}
 }","[28, 27]","bgpd in FRRouting FRR (aka Free Range Routing) 2.x and 3.x before 3.0.4, 4.x before 4.0.1, 5.x before 5.0.2, and 6.x before 6.0.2 (not affecting Cumulus Linux or VyOS), when ENABLE_BGP_VNC is used for Virtual Network Control, allows remote attackers to cause a denial of service (peering session flap) via attribute 255 in a BGP UPDATE packet. This occurred during Disco in January 2019 because FRR does not implement RFC 7606, and therefore the packets with 255 were considered invalid VNC data and the BGP session was closed."
8786,"static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data)
{
int len;
ssize_t size;
char buf[OGS_ADDRSTRLEN];

upf_sess_t *sess = NULL;

ogs_pkbuf_t *pkbuf = NULL;
ogs_sockaddr_t from;

ogs_gtp_header_t *gtp_h = NULL;
ogs_pfcp_user_plane_report_t report;

uint32_t teid;
uint8_t qfi;

ogs_assert(fd != INVALID_SOCKET);

pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_PKT_LEN);
ogs_assert(pkbuf);
ogs_pkbuf_reserve(pkbuf, OGS_TUN_MAX_HEADROOM);
ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN-OGS_TUN_MAX_HEADROOM);

size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from);
if (size <= 0) {
ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,
""ogs_recv() failed"");
goto cleanup;
}

ogs_pkbuf_trim(pkbuf, size);

ogs_assert(pkbuf);
ogs_assert(pkbuf->len);

gtp_h = (ogs_gtp_header_t *)pkbuf->data;
if (gtp_h->version != OGS_GTP_VERSION_1) {
ogs_error(""[DROP] Invalid GTPU version [%d]"", gtp_h->version);
ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
goto cleanup;
}

if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) {
ogs_pkbuf_t *echo_rsp;

ogs_debug(""[RECV] Echo Request from [%s]"", OGS_ADDR(&from, buf));
echo_rsp = ogs_gtp_handle_echo_req(pkbuf);
ogs_expect(echo_rsp);
if (echo_rsp) {
ssize_t sent;


ogs_debug(""[SEND] Echo Response to [%s]"", OGS_ADDR(&from, buf));

sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from);
if (sent < 0 || sent != echo_rsp->len) {
ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno,
""ogs_sendto() failed"");
}
ogs_pkbuf_free(echo_rsp);
}
goto cleanup;
}

teid = be32toh(gtp_h->teid);

ogs_debug(""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]"",
gtp_h->type, OGS_ADDR(&from, buf), teid);

qfi = 0;
if (gtp_h->flags & OGS_GTPU_FLAGS_E) {








ogs_gtp_extension_header_t *extension_header =
(ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN);
ogs_assert(extension_header);
if (extension_header->type ==
OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) {
if (extension_header->pdu_type ==
OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) {
ogs_debug(""   QFI [0x%x]"",
extension_header->qos_flow_identifier);
qfi = extension_header->qos_flow_identifier;
}
}
}


len = ogs_gtpu_header_len(pkbuf);
if (len < 0) {
ogs_error(""[DROP] Cannot decode GTPU packet"");
ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
goto cleanup;
}
ogs_assert(ogs_pkbuf_pull(pkbuf, len));

if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) {


} else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) {
ogs_pfcp_far_t *far = NULL;

far = ogs_pfcp_far_find_by_error_indication(pkbuf);
if (far) {
ogs_assert(true ==
ogs_pfcp_up_handle_error_indication(far, &report));

if (report.type.error_indication_report) {
ogs_assert(far->sess);
sess = UPF_SESS(far->sess);
ogs_assert(sess);

ogs_assert(OGS_OK ==
upf_pfcp_send_session_report_request(sess, &report));
}

} else {
ogs_error(""[DROP] Cannot find FAR by Error-Indication"");
ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
}

} else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) {
struct ip *ip_h = NULL;
ogs_pfcp_object_t *pfcp_object = NULL;
ogs_pfcp_sess_t *pfcp_sess = NULL;
ogs_pfcp_pdr_t *pdr = NULL;
ogs_pfcp_far_t *far = NULL;

ogs_pfcp_subnet_t *subnet = NULL;
ogs_pfcp_dev_t *dev = NULL;

ip_h = (struct ip *)pkbuf->data;
ogs_assert(ip_h);

pfcp_object = ogs_pfcp_object_find_by_teid(teid);
if (!pfcp_object) {

goto cleanup;
}

switch(pfcp_object->type) {
case OGS_PFCP_OBJ_PDR_TYPE:
pdr = (ogs_pfcp_pdr_t *)pfcp_object;
ogs_assert(pdr);
break;
case OGS_PFCP_OBJ_SESS_TYPE:
pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object;
ogs_assert(pfcp_sess);

ogs_list_for_each(&pfcp_sess->pdr_list, pdr) {


if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS &&
pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION)
continue;


if (teid != pdr->f_teid.teid)
continue;


if (qfi && pdr->qfi != qfi)
continue;


if (ogs_list_first(&pdr->rule_list) &&
ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL)
continue;

break;
}

if (!pdr) {

goto cleanup;
}

break;
default:
ogs_fatal(""Unknown type [%d]"", pfcp_object->type);
ogs_assert_if_reached();
}

ogs_assert(pdr);
ogs_assert(pdr->sess);
ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE);

sess = UPF_SESS(pdr->sess);
ogs_assert(sess);

far = pdr->far;
ogs_assert(far);

if (far->dst_if == OGS_PFCP_INTERFACE_CORE) {
uint16_t eth_type = 0;

if (ip_h->ip_v == 4 && sess->ipv4) {
subnet = sess->ipv4->subnet;
eth_type = ETHERTYPE_IP;
} else if (ip_h->ip_v == 6 && sess->ipv6) {
subnet = sess->ipv6->subnet;
eth_type = ETHERTYPE_IPV6;
}

if (!subnet) {
#if 0 /* It's redundant log message */
ogs_error(""[DROP] Cannot find subnet V:%d, IPv4:%p, IPv6:%p"",
ip_h->ip_v, sess->ipv4, sess->ipv6);
ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
#endif
goto cleanup;
}

dev = subnet->dev;
ogs_assert(dev);

if (dev->is_tap) {
ogs_assert(eth_type);
eth_type = htobe16(eth_type);
ogs_pkbuf_push(pkbuf, sizeof(eth_type));
memcpy(pkbuf->data, &eth_type, sizeof(eth_type));
ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);
memcpy(pkbuf->data, proxy_mac_addr, ETHER_ADDR_LEN);
ogs_pkbuf_push(pkbuf, ETHER_ADDR_LEN);
memcpy(pkbuf->data, dev->mac_addr, ETHER_ADDR_LEN);
}


if (ogs_tun_write(dev->fd, pkbuf) != OGS_OK)
ogs_warn(""ogs_tun_write() failed"");

} else if (far->dst_if == OGS_PFCP_INTERFACE_ACCESS) {
ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));

if (report.type.downlink_data_report) {
ogs_error(""Indirect Data Fowarding Buffered"");

report.downlink_data.pdr_id = pdr->id;
if (pdr->qer && pdr->qer->qfi)
report.downlink_data.qfi = pdr->qer->qfi;

ogs_assert(OGS_OK ==
upf_pfcp_send_session_report_request(sess, &report));
}

} else if (far->dst_if == OGS_PFCP_INTERFACE_CP_FUNCTION) {

if (!far->gnode) {
ogs_error(""No Outer Header Creation in FAR"");
goto cleanup;
}

if ((far->apply_action & OGS_PFCP_APPLY_ACTION_FORW) == 0) {
ogs_error(""Not supported Apply Action [0x%x]"",
far->apply_action);
goto cleanup;
}

ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report));

ogs_assert(report.type.downlink_data_report == 0);

} else {
ogs_fatal(""Not implemented : FAR-DST_IF[%d]"", far->dst_if);
ogs_assert_if_reached();
}
} else {
ogs_error(""[DROP] Invalid GTPU Type [%d]"", gtp_h->type);
ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len);
}

cleanup:
ogs_pkbuf_free(pkbuf);
}",[102],"In Open5GS 2.4.0, a crafted packet from UE can crash SGW-U/UPF."
202415," static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,
 		unsigned long arg)
 {
 	struct cdrom_changer_info *info;
 	int ret;
 
 	cd_dbg(CD_DO_IOCTL, ""entering CDROM_MEDIA_CHANGED\n"");
 
 	if (!CDROM_CAN(CDC_MEDIA_CHANGED))
 		return -ENOSYS;
 
 	 
  	if (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)
  		return media_changed(cdi, 1);
  
	if ((unsigned int)arg >= cdi->capacity)
 	if (arg >= cdi->capacity)
  		return -EINVAL;
  
  	info = kmalloc(sizeof(*info), GFP_KERNEL);
 	if (!info)
 		return -ENOMEM;
 
 	ret = cdrom_read_mech_status(cdi, info);
 	if (!ret)
 		ret = info->slots[arg].change;
 	kfree(info);
 	return ret;
 }","[17, 16]",The cdrom_ioctl_media_changed function in drivers/cdrom/cdrom.c in the Linux kernel before 4.16.6 allows local attackers to use a incorrect bounds check in the CDROM driver CDROM_MEDIA_CHANGED ioctl to read out kernel memory.
202703," internalEntityProcessor(XML_Parser parser, const char *s, const char *end,
                         const char **nextPtr) {
   ENTITY *entity;
   const char *textStart, *textEnd;
   const char *next;
   enum XML_Error result;
   OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;
   if (! openEntity)
     return XML_ERROR_UNEXPECTED_STATE;
 
   entity = openEntity->entity;
   textStart = ((char *)entity->textPtr) + entity->processed;
   textEnd = (char *)(entity->textPtr + entity->textLen);
    
   next = textStart;
 
 #ifdef XML_DTD
   if (entity->is_param) {
      int tok
          = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);
      result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,
                      tok, next, &next, XML_FALSE);
                       tok, next, &next, XML_FALSE, XML_TRUE);
    } else
  #endif  
      result = doContent(parser, openEntity->startTagLevel,
                        parser->m_internalEncoding, textStart, textEnd, &next,
                        XML_FALSE);
 
   if (result != XML_ERROR_NONE)
     return result;
   else if (textEnd != next
            && parser->m_parsingStatus.parsing == XML_SUSPENDED) {
     entity->processed = (int)(next - (char *)entity->textPtr);
     return result;
   } else {
     entity->open = XML_FALSE;
     parser->m_openInternalEntities = openEntity->next;
      
     openEntity->next = parser->m_freeInternalEntities;
     parser->m_freeInternalEntities = openEntity;
   }
 
 #ifdef XML_DTD
   if (entity->is_param) {
     int tok;
      parser->m_processor = prologProcessor;
      tok = XmlPrologTok(parser->m_encoding, s, end, &next);
      return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,
                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);
                     (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);
    } else
  #endif  
    {
     parser->m_processor = contentProcessor;
      
     return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,
                      s, end, nextPtr,
                      (XML_Bool)! parser->m_parsingStatus.finalBuffer);
   }
 }","[23, 51, 22, 50]","In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read."
1579,"bool Greeter::start() {

if (m_started)
return false;

if (daemonApp->testing()) {

m_process = new QProcess(this);


connect(m_process, SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(finished()));

connect(m_process, SIGNAL(readyReadStandardOutput()), SLOT(onReadyReadStandardOutput()));
connect(m_process, SIGNAL(readyReadStandardError()), SLOT(onReadyReadStandardError()));


qDebug() << ""Greeter starting..."";


QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
env.insert(QStringLiteral(""DISPLAY""), m_display->name());
env.insert(QStringLiteral(""XAUTHORITY""), m_authPath);
env.insert(QStringLiteral(""XCURSOR_THEME""), mainConfig.Theme.CursorTheme.get());
m_process->setProcessEnvironment(env);


QStringList args;
if (daemonApp->testing())
args << QStringLiteral(""--test-mode"");
args << QStringLiteral(""--socket"") << m_socket
<< QStringLiteral(""--theme"") << m_theme;
m_process->start(QStringLiteral(""%1/sddm-greeter"").arg(QStringLiteral(BIN_INSTALL_DIR)), args);


if (m_process->state() == QProcess::NotRunning) {
qCritical() << ""Greeter failed to launch."";
return false;
}

if (!m_process->waitForStarted()) {

qCritical() << ""Failed to start greeter."";


return false;
}


qDebug() << ""Greeter started."";


m_started = true;
} else {

m_auth = new Auth(this);
m_auth->setVerbose(true);
connect(m_auth, SIGNAL(requestChanged()), this, SLOT(onRequestChanged()));
connect(m_auth, SIGNAL(session(bool)), this, SLOT(onSessionStarted(bool)));
connect(m_auth, SIGNAL(finished(Auth::HelperExitStatus)), this, SLOT(onHelperFinished(Auth::HelperExitStatus)));
connect(m_auth, SIGNAL(info(QString,Auth::Info)), this, SLOT(authInfo(QString,Auth::Info)));
connect(m_auth, SIGNAL(error(QString,Auth::Error)), this, SLOT(authError(QString,Auth::Error)));


QStringList args;
args << QStringLiteral(""%1/sddm-greeter"").arg(QStringLiteral(BIN_INSTALL_DIR));
args << QStringLiteral(""--socket"") << m_socket
<< QStringLiteral(""--theme"") << m_theme;


QProcessEnvironment env;
QProcessEnvironment sysenv = QProcessEnvironment::systemEnvironment();

insertEnvironmentList({QStringLiteral(""LANG""), QStringLiteral(""LANGUAGE""),
QStringLiteral(""LC_CTYPE""), QStringLiteral(""LC_NUMERIC""), QStringLiteral(""LC_TIME""), QStringLiteral(""LC_COLLATE""),
QStringLiteral(""LC_MONETARY""), QStringLiteral(""LC_MESSAGES""), QStringLiteral(""LC_PAPER""), QStringLiteral(""LC_NAME""),
QStringLiteral(""LC_ADDRESS""), QStringLiteral(""LC_TELEPHONE""), QStringLiteral(""LC_MEASUREMENT""), QStringLiteral(""LC_IDENTIFICATION""),
QStringLiteral(""LD_LIBRARY_PATH""),
QStringLiteral(""QML2_IMPORT_PATH""),
QStringLiteral(""QT_PLUGIN_PATH""),
QStringLiteral(""XDG_DATA_DIRS"")
}, sysenv, env);

env.insert(QStringLiteral(""PATH""), mainConfig.Users.DefaultPath.get());
env.insert(QStringLiteral(""DISPLAY""), m_display->name());
env.insert(QStringLiteral(""XAUTHORITY""), m_authPath);
env.insert(QStringLiteral(""XCURSOR_THEME""), mainConfig.Theme.CursorTheme.get());
env.insert(QStringLiteral(""XDG_SEAT""), m_display->seat()->name());
env.insert(QStringLiteral(""XDG_SEAT_PATH""), daemonApp->displayManager()->seatPath(m_display->seat()->name()));
env.insert(QStringLiteral(""XDG_SESSION_PATH""), daemonApp->displayManager()->sessionPath(QStringLiteral(""Session%1"").arg(daemonApp->newSessionId())));
env.insert(QStringLiteral(""XDG_VTNR""), QString::number(m_display->terminalId()));
env.insert(QStringLiteral(""XDG_SESSION_CLASS""), QStringLiteral(""greeter""));
env.insert(QStringLiteral(""XDG_SESSION_TYPE""), m_display->sessionType());
m_auth->insertEnvironment(env);


qDebug() << ""Greeter starting..."";


m_auth->setUser(QStringLiteral(""sddm""));
m_auth->setGreeter(true);
m_auth->setSession(args.join(QLatin1Char(' ')));
m_auth->start();
}


return true;
}",[93],"daemon/Greeter.cpp in sddm before 0.13.0 does not properly disable the KDE crash handler, which allows local users to gain privileges by crashing a greeter when using certain themes, as demonstrated by the plasma-workspace breeze theme."
3593,"compute_U_value_R3(std::string const& user_password,
QPDF::EncryptionData const& data)
{


std::string k1 = QPDF::compute_encryption_key(user_password, data);
MD5 md5;
md5.encodeDataIncrementally(
pad_or_truncate_password_V4("""").c_str(), key_bytes);
md5.encodeDataIncrementally(data.getId1().c_str(),
data.getId1().length());
MD5::Digest digest;
md5.digest(digest);
iterate_rc4(digest, sizeof(MD5::Digest),
QUtil::unsigned_char_pointer(k1),
data.getLengthBytes(), 20, false);
char result[key_bytes];
memcpy(result, digest, sizeof(MD5::Digest));


for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)
{
result[i] = static_cast<char>((i * i) % 0xff);
}
return std::string(result, key_bytes);
}",[14],An issue was discovered in QPDF before 7.0.0. There is a stack-based out-of-bounds read in the function iterate_rc4 in QPDF_encryption.cc.
201540," static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
 				size_t msg_len)
 {
 	struct sock *sk = asoc->base.sk;
 	int err = 0;
 	long current_timeo = *timeo_p;
 	DEFINE_WAIT(wait);
 
 	pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
 		 *timeo_p, msg_len);
 
 	 
 	sctp_association_hold(asoc);
 
 	 
 	for (;;) {
 		prepare_to_wait_exclusive(&asoc->wait, &wait,
 					  TASK_INTERRUPTIBLE);
 		if (!*timeo_p)
 			goto do_nonblock;
 		if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
 		    asoc->base.dead)
 			goto do_error;
 		if (signal_pending(current))
 			goto do_interrupted;
 		if (msg_len <= sctp_wspace(asoc))
 			break;
 
 		 
  		release_sock(sk);
  		current_timeo = schedule_timeout(current_timeo);
		BUG_ON(sk != asoc->base.sk);
 		if (sk != asoc->base.sk)
 			goto do_error;
  		lock_sock(sk);
  
  		*timeo_p = current_timeo;
 	}
 
 out:
 	finish_wait(&asoc->wait, &wait);
 
 	 
 	sctp_association_put(asoc);
 
 	return err;
 
 do_error:
 	err = -EPIPE;
 	goto out;
 
 do_interrupted:
 	err = sock_intr_errno(*timeo_p);
 	goto out;
 
 do_nonblock:
 	err = -EAGAIN;
 	goto out;
 }","[33, 34, 32]",Race condition in the sctp_wait_for_sndbuf function in net/sctp/socket.c in the Linux kernel before 4.9.11 allows local users to cause a denial of service (assertion failure and panic) via a multithreaded application that peels off an association in a certain buffer-full state.
5090,"static av_cold int decode_init(AVCodecContext *avctx)
{
UtvideoContext * const c = avctx->priv_data;

c->avctx = avctx;

ff_bswapdsp_init(&c->bdsp);

if (avctx->extradata_size < 16) {
av_log(avctx, AV_LOG_ERROR,
""Insufficient extradata size %d, should be at least 16\n"",
avctx->extradata_size);
return AVERROR_INVALIDDATA;
}

av_log(avctx, AV_LOG_DEBUG, ""Encoder version %d.%d.%d.%d\n"",
avctx->extradata[3], avctx->extradata[2],
avctx->extradata[1], avctx->extradata[0]);
av_log(avctx, AV_LOG_DEBUG, ""Original format %""PRIX32""\n"",
AV_RB32(avctx->extradata + 4));
c->frame_info_size = AV_RL32(avctx->extradata + 8);
c->flags           = AV_RL32(avctx->extradata + 12);

if (c->frame_info_size != 4)
avpriv_request_sample(avctx, ""Frame info not 4 bytes"");
av_log(avctx, AV_LOG_DEBUG, ""Encoding parameters %08""PRIX32""\n"", c->flags);
c->slices      = (c->flags >> 24) + 1;
c->compression = c->flags & 1;
c->interlaced  = c->flags & 0x800;

c->slice_bits_size = 0;

switch (avctx->codec_tag) {
case MKTAG('U', 'L', 'R', 'G'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_RGB24;
break;
case MKTAG('U', 'L', 'R', 'A'):
c->planes      = 4;
avctx->pix_fmt = AV_PIX_FMT_RGBA;
break;
case MKTAG('U', 'L', 'Y', '0'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV420P;
avctx->colorspace = AVCOL_SPC_BT470BG;
break;
case MKTAG('U', 'L', 'Y', '2'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV422P;
avctx->colorspace = AVCOL_SPC_BT470BG;
break;
case MKTAG('U', 'L', 'H', '0'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV420P;
avctx->colorspace = AVCOL_SPC_BT709;
break;
case MKTAG('U', 'L', 'H', '2'):
c->planes      = 3;
avctx->pix_fmt = AV_PIX_FMT_YUV422P;
avctx->colorspace = AVCOL_SPC_BT709;
break;
default:
av_log(avctx, AV_LOG_ERROR, ""Unknown Ut Video FOURCC provided (%08X)\n"",
avctx->codec_tag);
return AVERROR_INVALIDDATA;
}

return 0;
}","[5, 68]",The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.
201071," l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)
 l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)
  {
  	const uint16_t *ptr = (const uint16_t *)dat;
  
 	if (length < 2) {
 		ND_PRINT((ndo, ""AVP too short""));
 		return;
 	}
  	ND_PRINT((ndo, ""%u"", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));
  }","[2, 6, 7, 8, 9]","The L2TP parser in tcpdump before 4.9.2 has a buffer over-read in print-l2tp.c, several functions."
206836," std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(
      mojo::ScopedSharedBufferHandle handle) {
    base::SharedMemoryHandle memory_handle;
    size_t memory_size = 0;
  bool read_only_flag = false;
   mojo::UnwrappedSharedMemoryHandleProtection protection;
  
    const MojoResult result = mojo::UnwrapSharedMemoryHandle(
      std::move(handle), &memory_handle, &memory_size, &read_only_flag);
       std::move(handle), &memory_handle, &memory_size, &protection);
    if (result != MOJO_RESULT_OK)
      return nullptr;
    DCHECK_GT(memory_size, 0u);
  
   const bool read_only =
       protection == mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly;
    std::unique_ptr<base::SharedMemory> shm =
      std::make_unique<base::SharedMemory>(memory_handle, read_only_flag);
       std::make_unique<base::SharedMemory>(memory_handle, read_only);
    if (!shm->Map(memory_size)) {
      DLOG(ERROR) << ""Map shared memory failed."";
      return nullptr;
   }
   return shm;
 }","[6, 10, 15, 16, 19, 5, 9, 18]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
201775," static Image *ReadSCTImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
   char
     magick[2];
 
   Image
     *image;
 
   MagickBooleanType
     status;
 
   MagickRealType
     height,
     width;
 
   Quantum
     pixel;
 
   register IndexPacket
     *indexes;
 
   register ssize_t
     i,
     x;
 
   register PixelPacket
     *q;
 
   ssize_t
     count,
     y;
 
   unsigned char
     buffer[768];
 
   size_t
     separations,
     separations_mask,
     units;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   count=ReadBlob(image,80,buffer);
   (void) count;
   count=ReadBlob(image,2,(unsigned char *) magick);
   if ((LocaleNCompare((char *) magick,""CT"",2) != 0) &&
       (LocaleNCompare((char *) magick,""LW"",2) != 0) &&
       (LocaleNCompare((char *) magick,""BM"",2) != 0) &&
       (LocaleNCompare((char *) magick,""PG"",2) != 0) &&
       (LocaleNCompare((char *) magick,""TX"",2) != 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   if ((LocaleNCompare((char *) magick,""LW"",2) == 0) ||
       (LocaleNCompare((char *) magick,""BM"",2) == 0) ||
       (LocaleNCompare((char *) magick,""PG"",2) == 0) ||
       (LocaleNCompare((char *) magick,""TX"",2) == 0))
     ThrowReaderException(CoderError,""OnlyContinuousTonePictureSupported"");
   count=ReadBlob(image,174,buffer);
   count=ReadBlob(image,768,buffer);
    
   units=1UL*ReadBlobByte(image);
   if (units == 0)
     image->units=PixelsPerCentimeterResolution;
   separations=1UL*ReadBlobByte(image);
   separations_mask=ReadBlobMSBShort(image);
   count=ReadBlob(image,14,buffer);
   buffer[14]='\0';
   height=StringToDouble((char *) buffer,(char **) NULL);
   count=ReadBlob(image,14,buffer);
   width=StringToDouble((char *) buffer,(char **) NULL);
   count=ReadBlob(image,12,buffer);
   buffer[12]='\0';
   image->rows=StringToUnsignedLong((char *) buffer);
   count=ReadBlob(image,12,buffer);
   image->columns=StringToUnsignedLong((char *) buffer);
   count=ReadBlob(image,200,buffer);
   count=ReadBlob(image,768,buffer);
   if (separations_mask == 0x0f)
     SetImageColorspace(image,CMYKColorspace);
   image->x_resolution=1.0*image->columns/width;
   image->y_resolution=1.0*image->rows/height;
   if (image_info->ping != MagickFalse)
     {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
     
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     for (i=0; i < (ssize_t) separations; i++)
     {
       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
       if (q == (PixelPacket *) NULL)
         break;
       indexes=GetAuthenticIndexQueue(image);
       for (x=0; x < (ssize_t) image->columns; x++)
       {
         pixel=(Quantum) ScaleCharToQuantum((unsigned char) ReadBlobByte(image));
         if (image->colorspace == CMYKColorspace)
           pixel=(Quantum) (QuantumRange-pixel);
         switch (i)
         {
           case 0:
           {
             SetPixelRed(q,pixel);
             SetPixelGreen(q,pixel);
             SetPixelBlue(q,pixel);
             break;
           }
           case 1:
           {
             SetPixelGreen(q,pixel);
             break;
           }
           case 2:
           {
             SetPixelBlue(q,pixel);
             break;
           }
           case 3:
           {
             if (image->colorspace == CMYKColorspace)
               SetPixelBlack(indexes+x,pixel);
             break;
           }
         }
         q++;
       }
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         break;
       if ((image->columns % 2) != 0)
         (void) ReadBlobByte(image);   
     }
     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
       image->rows);
     if (status == MagickFalse)
       break;
   }
   if (EOFBlob(image) != MagickFalse)
     ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
       image->filename);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[100, 101, 102, 103, 104, 105]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
199050," static int __init sit_init(void)
 {
 	int err;
  
  	printk(KERN_INFO ""IPv6 over IPv4 tunneling driver\n"");
  
	if (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {
		printk(KERN_INFO ""sit init: Can't add protocol\n"");
		return -EAGAIN;
	}
  	err = register_pernet_device(&sit_net_ops);
  	if (err < 0)
		xfrm4_tunnel_deregister(&sit_handler, AF_INET6);
 		return err;
 	err = xfrm4_tunnel_register(&sit_handler, AF_INET6);
 	if (err < 0) {
 		unregister_pernet_device(&sit_net_ops);
 		printk(KERN_INFO ""sit init: Can't add protocol\n"");
 	}
  	return err;
  }","[14, 15, 16, 17, 18, 19, 7, 8, 9, 10, 13]","The tunnels implementation in the Linux kernel before 2.6.34, when tunnel functionality is configured as a module, allows remote attackers to cause a denial of service (OOPS) by sending a packet during module loading."
202552," add_job(cupsd_client_t  *con,		 
 	cupsd_printer_t *printer,	 
 	mime_type_t     *filetype)	 
 {
   http_status_t	status;			 
   ipp_attribute_t *attr,		 
 		*auth_info;		 
   const char	*mandatory;		 
   const char	*val;			 
   int		priority;		 
   cupsd_job_t	*job;			 
   char		job_uri[HTTP_MAX_URI];	 
   int		kbytes;			 
   int		i;			 
   int		lowerpagerange;		 
   int		exact;			 
   ipp_attribute_t *media_col,		 
 		*media_margin;		 
   ipp_t		*unsup_col;		 
   static const char * const readonly[] = 
   {
     ""date-time-at-completed"",
     ""date-time-at-creation"",
     ""date-time-at-processing"",
     ""job-detailed-status-messages"",
     ""job-document-access-errors"",
     ""job-id"",
     ""job-impressions-completed"",
     ""job-k-octets-completed"",
     ""job-media-sheets-completed"",
     ""job-pages-completed"",
     ""job-printer-up-time"",
     ""job-printer-uri"",
     ""job-state"",
     ""job-state-message"",
     ""job-state-reasons"",
     ""job-uri"",
     ""number-of-documents"",
     ""number-of-intervening-jobs"",
     ""output-device-assigned"",
     ""time-at-completed"",
     ""time-at-creation"",
     ""time-at-processing""
   };
 
 
   cupsdLogMessage(CUPSD_LOG_DEBUG2, ""add_job(%p[%d], %p(%s), %p(%s/%s))"",
                   con, con->number, printer, printer->name,
 		  filetype, filetype ? filetype->super : ""none"",
 		  filetype ? filetype->type : ""none"");
 
   
 
   if (!printer->shared &&
       _cups_strcasecmp(con->http->hostname, ""localhost"") &&
       _cups_strcasecmp(con->http->hostname, ServerName))
   {
     send_ipp_status(con, IPP_NOT_AUTHORIZED,
                     _(""The printer or class is not shared.""));
     return (NULL);
   }
 
   
 
   auth_info = ippFindAttribute(con->request, ""auth-info"", IPP_TAG_TEXT);
 
   if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK)
   {
     send_http_error(con, status, printer);
     return (NULL);
   }
   else if (printer->num_auth_info_required == 1 &&
            !strcmp(printer->auth_info_required[0], ""negotiate"") &&
            !con->username[0])
   {
     send_http_error(con, HTTP_UNAUTHORIZED, printer);
     return (NULL);
   }
 #ifdef HAVE_SSL
   else if (auth_info && !con->http->tls &&
            !httpAddrLocalhost(con->http->hostaddr))
   {
     
 
     send_http_error(con, HTTP_UPGRADE_REQUIRED, printer);
     return (NULL);
   }
 #endif  
 
   
 
   if (!printer->accepting)
   {
     send_ipp_status(con, IPP_NOT_ACCEPTING,
                     _(""Destination \""%s\"" is not accepting jobs.""),
                     printer->name);
     return (NULL);
   }
 
   
 
   for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++)
   {
     if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL)
     {
       ippDeleteAttribute(con->request, attr);
 
       if (StrictConformance)
       {
 	send_ipp_status(con, IPP_BAD_REQUEST, _(""The '%s' Job Status attribute cannot be supplied in a job creation request.""), readonly[i]);
 	return (NULL);
       }
 
       cupsdLogMessage(CUPSD_LOG_INFO, ""Unexpected '%s' Job Status attribute in a job creation request."", readonly[i]);
     }
   }
 
   if (printer->pc)
   {
     for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory);
 	 mandatory;
 	 mandatory = (char *)cupsArrayNext(printer->pc->mandatory))
     {
       if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO))
       {
         
 
 	send_ipp_status(con, IPP_CONFLICT,
 			_(""The \""%s\"" attribute is required for print jobs.""),
 			mandatory);
 	return (NULL);
       }
     }
   }
 
   if (filetype && printer->filetypes &&
       !cupsArrayFind(printer->filetypes, filetype))
   {
     char	mimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2];
 					 
 
 
     snprintf(mimetype, sizeof(mimetype), ""%s/%s"", filetype->super,
              filetype->type);
 
     send_ipp_status(con, IPP_DOCUMENT_FORMAT,
                     _(""Unsupported format \""%s\"".""), mimetype);
 
     ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE,
                  ""document-format"", NULL, mimetype);
 
     return (NULL);
   }
 
   if ((attr = ippFindAttribute(con->request, ""copies"",
                                IPP_TAG_INTEGER)) != NULL)
   {
     if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies)
     {
       send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad copies value %d.""),
                       attr->values[0].integer);
       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,
 	            ""copies"", attr->values[0].integer);
       return (NULL);
     }
   }
 
   if ((attr = ippFindAttribute(con->request, ""job-sheets"",
                                IPP_TAG_ZERO)) != NULL)
   {
     if (attr->value_tag != IPP_TAG_KEYWORD &&
         attr->value_tag != IPP_TAG_NAME)
     {
       send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value type.""));
       return (NULL);
     }
 
     if (attr->num_values > 2)
     {
       send_ipp_status(con, IPP_BAD_REQUEST,
                       _(""Too many job-sheets values (%d > 2).""),
 		      attr->num_values);
       return (NULL);
     }
 
     for (i = 0; i < attr->num_values; i ++)
       if (strcmp(attr->values[i].string.text, ""none"") &&
           !cupsdFindBanner(attr->values[i].string.text))
       {
 	send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value \""%s\"".""),
 			attr->values[i].string.text);
 	return (NULL);
       }
   }
 
   if ((attr = ippFindAttribute(con->request, ""number-up"",
                                IPP_TAG_INTEGER)) != NULL)
   {
     if (attr->values[0].integer != 1 &&
         attr->values[0].integer != 2 &&
         attr->values[0].integer != 4 &&
         attr->values[0].integer != 6 &&
         attr->values[0].integer != 9 &&
         attr->values[0].integer != 16)
     {
       send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad number-up value %d.""),
                       attr->values[0].integer);
       ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER,
 	            ""number-up"", attr->values[0].integer);
       return (NULL);
     }
   }
 
   if ((attr = ippFindAttribute(con->request, ""page-ranges"",
                                IPP_TAG_RANGE)) != NULL)
   {
     for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++)
     {
       if (attr->values[i].range.lower < lowerpagerange ||
 	  attr->values[i].range.lower > attr->values[i].range.upper)
       {
 	send_ipp_status(con, IPP_BAD_REQUEST,
 	                _(""Bad page-ranges values %d-%d.""),
 	                attr->values[i].range.lower,
 			attr->values[i].range.upper);
 	return (NULL);
       }
 
       lowerpagerange = attr->values[i].range.upper + 1;
     }
   }
 
   
 
   if (!ippFindAttribute(con->request, ""PageRegion"", IPP_TAG_ZERO) &&
       !ippFindAttribute(con->request, ""PageSize"", IPP_TAG_ZERO) &&
       _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact))
   {
     if (!exact &&
         (media_col = ippFindAttribute(con->request, ""media-col"",
 	                              IPP_TAG_BEGIN_COLLECTION)) != NULL)
     {
       send_ipp_status(con, IPP_OK_SUBST, _(""Unsupported margins.""));
 
       unsup_col = ippNew();
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-bottom-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-bottom-margin"", media_margin->values[0].integer);
 
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-left-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-left-margin"", media_margin->values[0].integer);
 
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-right-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-right-margin"", media_margin->values[0].integer);
 
       if ((media_margin = ippFindAttribute(media_col->values[0].collection,
                                            ""media-top-margin"",
 					   IPP_TAG_INTEGER)) != NULL)
         ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
 	              ""media-top-margin"", media_margin->values[0].integer);
 
       ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, ""media-col"",
                        unsup_col);
       ippDelete(unsup_col);
     }
   }
 
   
 
   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)
     cupsdCleanJobs();
 
   if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs)
   {
     send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Too many active jobs.""));
     return (NULL);
   }
 
   if ((i = check_quotas(con, printer)) < 0)
   {
     send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Quota limit reached.""));
     return (NULL);
   }
   else if (i == 0)
   {
     send_ipp_status(con, IPP_NOT_AUTHORIZED, _(""Not allowed to print.""));
     return (NULL);
   }
 
   
 
   if ((attr = ippFindAttribute(con->request, ""job-priority"",
                                IPP_TAG_INTEGER)) != NULL)
     priority = attr->values[0].integer;
   else
   {
     if ((val = cupsGetOption(""job-priority"", printer->num_options,
                              printer->options)) != NULL)
       priority = atoi(val);
     else
       priority = 50;
 
     ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-priority"",
                   priority);
   }
 
   if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_ZERO)) == NULL)
     ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, ""job-name"", NULL, ""Untitled"");
   else if ((attr->value_tag != IPP_TAG_NAME &&
             attr->value_tag != IPP_TAG_NAMELANG) ||
            attr->num_values != 1)
   {
     send_ipp_status(con, IPP_ATTRIBUTES,
                     _(""Bad job-name value: Wrong type or count.""));
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
     return (NULL);
   }
   else if (!ippValidateAttribute(attr))
   {
     send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad job-name value: %s""),
                     cupsLastErrorString());
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
      return (NULL);
    }
  
   attr = ippFindAttribute(con->request, ""requesting-user-name"", IPP_TAG_NAME);
 
   if (attr && !ippValidateAttribute(attr))
   {
     send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad requesting-user-name value: %s""), cupsLastErrorString());
     if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)
       attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;
     return (NULL);
   }
 
    if ((job = cupsdAddJob(priority, printer->name)) == NULL)
    {
      send_ipp_status(con, IPP_INTERNAL_ERROR,
                     _(""Unable to add job for destination \""%s\"".""),
 		    printer->name);
     return (NULL);
   }
 
   job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE);
   job->attrs   = con->request;
   job->dirty   = 1;
   con->request = ippNewRequest(job->attrs->request.op.operation_id);
 
   cupsdMarkDirty(CUPSD_DIRTY_JOBS);
 
    add_job_uuid(job);
    apply_printer_defaults(printer, job);
  
  attr = ippFindAttribute(job->attrs, ""requesting-user-name"", IPP_TAG_NAME);
    if (con->username[0])
    {
      cupsdSetString(&job->username, con->username);
 
     if (attr)
       ippSetString(job->attrs, &attr, 0, con->username);
   }
   else if (attr)
   {
     cupsdLogMessage(CUPSD_LOG_DEBUG,
                     ""add_job: requesting-user-name=\""%s\"""",
                     attr->values[0].string.text);
 
     cupsdSetString(&job->username, attr->values[0].string.text);
   }
   else
     cupsdSetString(&job->username, ""anonymous"");
 
   if (!attr)
     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,
                  ""job-originating-user-name"", NULL, job->username);
   else
   {
     ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);
     ippSetName(job->attrs, &attr, ""job-originating-user-name"");
   }
 
   if (con->username[0] || auth_info)
   {
     save_auth_info(con, job, auth_info);
 
     
 
     if (auth_info)
       ippDeleteAttribute(job->attrs, auth_info);
   }
 
   if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_NAME)) != NULL)
     cupsdSetString(&(job->name), attr->values[0].string.text);
 
   if ((attr = ippFindAttribute(job->attrs, ""job-originating-host-name"",
                                IPP_TAG_ZERO)) != NULL)
   {
     
 
     if (attr->value_tag != IPP_TAG_NAME ||
         attr->num_values != 1 ||
         strcmp(con->http->hostname, ""localhost""))
     {
       
 
       ippDeleteAttribute(job->attrs, attr);
       ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-originating-host-name"", NULL, con->http->hostname);
     }
     else
       ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB);
   }
   else
   {
     
 
     ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME,
         	 ""job-originating-host-name"", NULL, con->http->hostname);
   }
 
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-completed"");
   ippAddDate(job->attrs, IPP_TAG_JOB, ""date-time-at-creation"", ippTimeToDate(time(NULL)));
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-processing"");
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-completed"");
   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""time-at-creation"", time(NULL));
   ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-processing"");
 
   
 
   ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id);
   job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM,
                              ""job-state"", IPP_JOB_STOPPED);
   job->state_value = (ipp_jstate_t)job->state->values[0].integer;
   job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,
                               ""job-state-reasons"", NULL, ""job-incoming"");
   job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-impressions-completed"", 0);
   job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER,
                               ""job-media-sheets-completed"", 0);
   ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, ""job-printer-uri"", NULL,
                printer->uri);
 
   if ((attr = ippFindAttribute(job->attrs, ""job-k-octets"", IPP_TAG_INTEGER)) != NULL)
     attr->values[0].integer = 0;
   else
     ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-k-octets"", 0);
 
   if ((attr = ippFindAttribute(job->attrs, ""job-hold-until"",
                                IPP_TAG_KEYWORD)) == NULL)
     attr = ippFindAttribute(job->attrs, ""job-hold-until"", IPP_TAG_NAME);
   if (!attr)
   {
     if ((val = cupsGetOption(""job-hold-until"", printer->num_options,
                              printer->options)) == NULL)
       val = ""no-hold"";
 
     attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD,
                         ""job-hold-until"", NULL, val);
   }
 
   if (printer->holding_new_jobs)
   {
     
 
     if (attr && strcmp(attr->values[0].string.text, ""no-hold""))
       cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0);
     else
       cupsdSetJobHoldUntil(job, ""indefinite"", 0);
 
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
 
     ippSetString(job->attrs, &job->reasons, 0, ""job-held-on-create"");
   }
   else if (attr && strcmp(attr->values[0].string.text, ""no-hold""))
   {
     
 
     cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0);
 
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
 
     ippSetString(job->attrs, &job->reasons, 0, ""job-hold-until-specified"");
   }
   else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB)
   {
     job->hold_until               = time(NULL) + MultipleOperationTimeout;
     job->state->values[0].integer = IPP_JOB_HELD;
     job->state_value              = IPP_JOB_HELD;
   }
   else
   {
     job->state->values[0].integer = IPP_JOB_PENDING;
     job->state_value              = IPP_JOB_PENDING;
 
     ippSetString(job->attrs, &job->reasons, 0, ""none"");
   }
 
   if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification)
   {
     
 
     if ((attr = ippFindAttribute(job->attrs, ""job-sheets"",
                                  IPP_TAG_ZERO)) == NULL)
     {
       cupsdLogMessage(CUPSD_LOG_DEBUG,
                       ""Adding default job-sheets values \""%s,%s\""..."",
                       printer->job_sheets[0], printer->job_sheets[1]);
 
       attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-sheets"",
                            2, NULL, NULL);
       ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]);
       ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]);
     }
 
     job->job_sheets = attr;
 
     
 
     if (Classification)
     {
       cupsdLogMessage(CUPSD_LOG_INFO,
                       ""Classification=\""%s\"", ClassifyOverride=%d"",
                       Classification ? Classification : ""(null)"",
 		      ClassifyOverride);
 
       if (ClassifyOverride)
       {
         if (!strcmp(attr->values[0].string.text, ""none"") &&
 	    (attr->num_values == 1 ||
 	     !strcmp(attr->values[1].string.text, ""none"")))
         {
 	  
 
           ippSetString(job->attrs, &attr, 0, Classification);
 
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED ""
 	                		     ""job-sheets=\""%s,none\"", ""
 					     ""job-originating-user-name=\""%s\"""",
 	              Classification, job->username);
 	}
 	else if (attr->num_values == 2 &&
 	         strcmp(attr->values[0].string.text,
 		        attr->values[1].string.text) &&
 		 strcmp(attr->values[0].string.text, ""none"") &&
 		 strcmp(attr->values[1].string.text, ""none""))
         {
 	  
 
           ippSetString(job->attrs, &attr, 1, attr->values[0].string.text);
 
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED ""
 	                		     ""job-sheets=\""%s,%s\"", ""
 					     ""job-originating-user-name=\""%s\"""",
 		      attr->values[0].string.text,
 		      attr->values[1].string.text, job->username);
 	}
 	else if (strcmp(attr->values[0].string.text, Classification) &&
 	         strcmp(attr->values[0].string.text, ""none"") &&
 		 (attr->num_values == 1 ||
 	          (strcmp(attr->values[1].string.text, Classification) &&
 	           strcmp(attr->values[1].string.text, ""none""))))
         {
 	  if (attr->num_values == 1)
             cupsdLogJob(job, CUPSD_LOG_NOTICE,
 			""CLASSIFICATION OVERRIDDEN ""
 			""job-sheets=\""%s\"", ""
 			""job-originating-user-name=\""%s\"""",
 	                attr->values[0].string.text, job->username);
           else
             cupsdLogJob(job, CUPSD_LOG_NOTICE,
 			""CLASSIFICATION OVERRIDDEN ""
 			""job-sheets=\""%s,%s\"",fffff ""
 			""job-originating-user-name=\""%s\"""",
 			attr->values[0].string.text,
 			attr->values[1].string.text, job->username);
         }
       }
       else if (strcmp(attr->values[0].string.text, Classification) &&
                (attr->num_values == 1 ||
 	       strcmp(attr->values[1].string.text, Classification)))
       {
         
 
         if (attr->num_values > 1 &&
 	    !strcmp(attr->values[0].string.text, attr->values[1].string.text))
 	{
           ippSetString(job->attrs, &attr, 0, Classification);
           ippSetString(job->attrs, &attr, 1, Classification);
 	}
         else
 	{
           if (attr->num_values == 1 ||
 	      strcmp(attr->values[0].string.text, ""none""))
             ippSetString(job->attrs, &attr, 0, Classification);
 
           if (attr->num_values > 1 &&
 	      strcmp(attr->values[1].string.text, ""none""))
 	    ippSetString(job->attrs, &attr, 1, Classification);
         }
 
         if (attr->num_values > 1)
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE,
 		      ""CLASSIFICATION FORCED ""
 		      ""job-sheets=\""%s,%s\"", ""
 		      ""job-originating-user-name=\""%s\"""",
 		      attr->values[0].string.text,
 		      attr->values[1].string.text, job->username);
         else
 	  cupsdLogJob(job, CUPSD_LOG_NOTICE,
 		      ""CLASSIFICATION FORCED ""
 		      ""job-sheets=\""%s\"", ""
 		      ""job-originating-user-name=\""%s\"""",
 		      Classification, job->username);
       }
     }
 
     
 
     if (!(printer->type & CUPS_PRINTER_REMOTE))
     {
       cupsdLogJob(job, CUPSD_LOG_INFO, ""Adding start banner page \""%s\""."",
 		  attr->values[0].string.text);
 
       if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0)
       {
         cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE,
 	                 ""Aborting job because the start banner could not be ""
 			 ""copied."");
         return (NULL);
       }
 
       cupsdUpdateQuota(printer, job->username, 0, kbytes);
     }
   }
   else if ((attr = ippFindAttribute(job->attrs, ""job-sheets"",
                                     IPP_TAG_ZERO)) != NULL)
     job->job_sheets = attr;
 
   
 
   httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), ""ipp"", NULL,
                    con->clientname, con->clientport, ""/jobs/%d"", job->id);
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, ""job-uri"", NULL,
                job_uri);
 
   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id);
 
   ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, ""job-state"",
                 job->state_value);
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, ""job-state-message"", NULL, """");
   ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, ""job-state-reasons"",
                NULL, job->reasons->values[0].string.text);
 
   con->response->request.status.status_code = IPP_OK;
 
   
 
   add_job_subscriptions(con, job);
 
   
 
   for (attr = job->attrs->attrs->next->next; attr; attr = attr->next)
     attr->group_tag = IPP_TAG_JOB;
 
   
 
   cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, ""Job created."");
 
   
 
   return (job);
 }","[336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 364]","The add_job function in scheduler/ipp.c in CUPS before 2.2.6, when D-Bus support is enabled, can be crashed by remote attackers by sending print jobs with an invalid username, related to a D-Bus notification."
198661,"  jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)
  {
    int i, j;
    int w, h;
    int leftbyte, rightbyte;
    int shift;
     uint32_t i, j;
     uint32_t w, h;
     uint32_t leftbyte, rightbyte;
     uint32_t shift;
      uint8_t *s, *ss;
      uint8_t *d, *dd;
      uint8_t mask, rightmask;
 
     if (op != JBIG2_COMPOSE_OR) {
          
         return jbig2_image_compose_unopt(ctx, dst, src, x, y, op);
     }
 
      
     w = src->width;
     h = src->height;
     ss = src->data;
 
     if (x < 0) {
         w += x;
         x = 0;
     }
     if (y < 0) {
          h += y;
          y = 0;
      }
    w = (x + w < dst->width) ? w : dst->width - x;
    h = (y + h < dst->height) ? h : dst->height - y;
     w = ((uint32_t)x + w < dst->width) ? w : ((dst->width >= (uint32_t)x) ? dst->width - (uint32_t)x : 0);
     h = ((uint32_t)y + h < dst->height) ? h : ((dst->height >= (uint32_t)y) ? dst->height - (uint32_t)y : 0);
  #ifdef JBIG2_DEBUG
      jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""compositing %dx%d at (%d, %d) after clipping\n"", w, h, x, y);
  #endif
 
      
     if ((w <= 0) || (h <= 0)) {
 #ifdef JBIG2_DEBUG
         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, ""zero clipping region"");
 #endif
         return 0;
     }
 #if 0
      
      
     if ((x == 0) && (w == src->width)) {
         memcpy(dst->data + y * dst->stride, src->data, h * src->stride);
         return 0;
      }
  #endif
  
    leftbyte = x >> 3;
    rightbyte = (x + w - 1) >> 3;
     leftbyte = (uint32_t)x >> 3;
     rightbyte = ((uint32_t)x + w - 1) >> 3;
      shift = x & 7;
  
       
     s = ss;
     d = dd = dst->data + y * dst->stride + leftbyte;
     if (d < dst->data || leftbyte > dst->stride || h * dst->stride < 0 || d - leftbyte + h * dst->stride > dst->data + dst->height * dst->stride) {
         return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, ""preventing heap overflow in jbig2_image_compose"");
     }
     if (leftbyte == rightbyte) {
         mask = 0x100 - (0x100 >> w);
         for (j = 0; j < h; j++) {
             *d |= (*s & mask) >> shift;
             d += dst->stride;
             s += src->stride;
         }
     } else if (shift == 0) {
         rightmask = (w & 7) ? 0x100 - (1 << (8 - (w & 7))) : 0xFF;
         for (j = 0; j < h; j++) {
             for (i = leftbyte; i < rightbyte; i++)
                 *d++ |= *s++;
             *d |= *s & rightmask;
             d = (dd += dst->stride);
             s = (ss += src->stride);
         }
     } else {
         bool overlap = (((w + 7) >> 3) < ((x + w + 7) >> 3) - (x >> 3));
 
         mask = 0x100 - (1 << shift);
         if (overlap)
             rightmask = (0x100 - (0x100 >> ((x + w) & 7))) >> (8 - shift);
         else
             rightmask = 0x100 - (0x100 >> (w & 7));
         for (j = 0; j < h; j++) {
             *d++ |= (*s & mask) >> shift;
             for (i = leftbyte; i < rightbyte - 1; i++) {
                 *d |= ((*s++ & ~mask) << (8 - shift));
                 *d++ |= ((*s & mask) >> shift);
             }
             if (overlap)
                 *d |= (*s & rightmask) << (8 - shift);
             else
                 *d |= ((s[0] & ~mask) << (8 - shift)) | ((s[1] & rightmask) >> shift);
             d = (dd += dst->stride);
             s = (ss += src->stride);
         }
     }
 
     return 0;
 }","[7, 8, 9, 10, 35, 36, 59, 60, 3, 4, 5, 6, 33, 34, 57, 58]","ghostscript before version 9.21 is vulnerable to a heap based buffer overflow that was found in the ghostscript jbig2_decode_gray_scale_image function which is used to decode halftone segments in a JBIG2 image. A document (PostScript or PDF) with an embedded, specially crafted, jbig2 image could trigger a segmentation fault in ghostscript."
204832," void AutofillDialogViews::SectionContainer::SetActive(bool active) {
   bool is_active = active && proxy_button_->visible();
    if (is_active == !!background())
      return;
  
  set_background(is_active ?
      views::Background::CreateSolidBackground(kShadingColor) :
      NULL);
   set_background(
       is_active ? views::Background::CreateSolidBackground(kLightShadingColor)
                 : NULL);
    SchedulePaint();
  }","[9, 10, 11, 6, 7, 8]","The FrameLoader::notifyIfInitialDocumentAccessed function in core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 31.0.1650.63, makes an incorrect check for an empty document during presentation of a modal dialog, which allows remote attackers to spoof the address bar via vectors involving the document.write method."
202535," ipt_do_table(struct sk_buff *skb,
 	     const struct nf_hook_state *state,
 	     struct xt_table *table)
 {
 	unsigned int hook = state->hook;
 	static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));
 	const struct iphdr *ip;
 	 
 	unsigned int verdict = NF_DROP;
 	const char *indev, *outdev;
 	const void *table_base;
 	struct ipt_entry *e, **jumpstack;
 	unsigned int stackidx, cpu;
 	const struct xt_table_info *private;
 	struct xt_action_param acpar;
 	unsigned int addend;
 
 	 
 	stackidx = 0;
 	ip = ip_hdr(skb);
 	indev = state->in ? state->in->name : nulldevname;
 	outdev = state->out ? state->out->name : nulldevname;
 	 
 	acpar.fragoff = ntohs(ip->frag_off) & IP_OFFSET;
 	acpar.thoff   = ip_hdrlen(skb);
 	acpar.hotdrop = false;
 	acpar.state   = state;
 
 	WARN_ON(!(table->valid_hooks & (1 << hook)));
 	local_bh_disable();
 	addend = xt_write_recseq_begin();
 	private = READ_ONCE(table->private);  
 	cpu        = smp_processor_id();
 	table_base = private->entries;
 	jumpstack  = (struct ipt_entry **)private->jumpstack[cpu];
 
 	 
 	if (static_key_false(&xt_tee_enabled))
 		jumpstack += private->stacksize * __this_cpu_read(nf_skb_duplicated);
 
 	e = get_entry(table_base, private->hook_entry[hook]);
 
 	do {
 		const struct xt_entry_target *t;
 		const struct xt_entry_match *ematch;
 		struct xt_counters *counter;
 
 		WARN_ON(!e);
 		if (!ip_packet_match(ip, indev, outdev,
 		    &e->ip, acpar.fragoff)) {
  no_match:
 			e = ipt_next_entry(e);
 			continue;
 		}
 
 		xt_ematch_foreach(ematch, e) {
 			acpar.match     = ematch->u.kernel.match;
 			acpar.matchinfo = ematch->data;
 			if (!acpar.match->match(skb, &acpar))
 				goto no_match;
 		}
 
 		counter = xt_get_this_cpu_counter(&e->counters);
 		ADD_COUNTER(*counter, skb->len, 1);
 
 		t = ipt_get_target(e);
 		WARN_ON(!t->u.kernel.target);
 
 #if IS_ENABLED(CONFIG_NETFILTER_XT_TARGET_TRACE)
 		 
 		if (unlikely(skb->nf_trace))
 			trace_packet(state->net, skb, hook, state->in,
 				     state->out, table->name, private, e);
 #endif
 		 
 		if (!t->u.kernel.target->target) {
 			int v;
 
 			v = ((struct xt_standard_target *)t)->verdict;
 			if (v < 0) {
 				 
 				if (v != XT_RETURN) {
 					verdict = (unsigned int)(-v) - 1;
 					break;
 				}
 				if (stackidx == 0) {
 					e = get_entry(table_base,
 					    private->underflow[hook]);
 				} else {
 					e = jumpstack[--stackidx];
 					e = ipt_next_entry(e);
 				}
  				continue;
  			}
  			if (table_base + v != ipt_next_entry(e) &&
			    !(e->ip.flags & IPT_F_GOTO))
 			    !(e->ip.flags & IPT_F_GOTO)) {
 				if (unlikely(stackidx >= private->stacksize)) {
 					verdict = NF_DROP;
 					break;
 				}
  				jumpstack[stackidx++] = e;
 			}
  
  			e = get_entry(table_base, v);
  			continue;
 		}
 
 		acpar.target   = t->u.kernel.target;
 		acpar.targinfo = t->data;
 
 		verdict = t->u.kernel.target->target(skb, &acpar);
 		if (verdict == XT_CONTINUE) {
 			 
 			ip = ip_hdr(skb);
 			e = ipt_next_entry(e);
 		} else {
 			 
 			break;
 		}
 	} while (!acpar.hotdrop);
 
 	xt_write_recseq_end(addend);
 	local_bh_enable();
 
 	if (acpar.hotdrop)
 		return NF_DROP;
 	else return verdict;
 }","[97, 98, 99, 100, 101, 103, 96]","The netfilter subsystem in the Linux kernel through 4.15.7 mishandles the case of a rule blob that contains a jump but lacks a user-defined chain, which allows local users to cause a denial of service (NULL pointer dereference) by leveraging the CAP_NET_RAW or CAP_NET_ADMIN capability, related to arpt_do_table in net/ipv4/netfilter/arp_tables.c, ipt_do_table in net/ipv4/netfilter/ip_tables.c, and ip6t_do_table in net/ipv6/netfilter/ip6_tables.c."
200410," static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,
 			    size_t len, loff_t *pos)
 {
 	struct ib_ucm_file *file = filp->private_data;
  	struct ib_ucm_cmd_hdr hdr;
  	ssize_t result;
  
 	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))
 		return -EACCES;
 
  	if (len < sizeof(hdr))
  		return -EINVAL;
  
 	if (copy_from_user(&hdr, buf, sizeof(hdr)))
 		return -EFAULT;
 
 	if (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))
 		return -EINVAL;
 
 	if (hdr.in + sizeof(hdr) > len)
 		return -EINVAL;
 
 	result = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),
 					hdr.in, hdr.out);
 	if (!result)
 		result = len;
 
 	return result;
 }","[8, 9, 10]","The InfiniBand (aka IB) stack in the Linux kernel before 4.5.3 incorrectly relies on the write system call, which allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a uAPI interface."
208584,"  virtual void SetUp() {
     fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
 
      tx_type_  = GET_PARAM(2);
      pitch_    = 8;
      fwd_txfm_ref = fdct8x8_ref;
     bit_depth_ = GET_PARAM(3);
     mask_ = (1 << bit_depth_) - 1;
    }","[8, 9]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
206660," void Document::InitContentSecurityPolicy(
     ContentSecurityPolicy* csp,
      const ContentSecurityPolicy* policy_to_inherit) {
    SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
  
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 
   if (policy_to_inherit) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
   } else if (frame_) {
     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()
                                                   : frame_->Client()->Opener();
     if (inherit_from && frame_ != inherit_from) {
       DCHECK(inherit_from->GetSecurityContext() &&
              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
       policy_to_inherit =
           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
           url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")) {
         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
       }
     }
   }
    if (policy_to_inherit && IsPluginDocument())
      GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
  GetContentSecurityPolicy()->BindToExecutionContext(this);
  }","[6, 7, 26]",Insufficient policy enforcement in Blink in Google Chrome prior to 64.0.3282.119 allowed a remote attacker to potentially bypass content security policy via a crafted HTML page.
9534,"int nfs_atomic_open(struct inode *dir, struct dentry *dentry,
struct file *file, unsigned open_flags,
umode_t mode)
{
DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);
struct nfs_open_context *ctx;
struct dentry *res;
struct iattr attr = { .ia_valid = ATTR_OPEN };
struct inode *inode;
unsigned int lookup_flags = 0;
unsigned long dir_verifier;
bool switched = false;
int created = 0;
int err;


BUG_ON(d_inode(dentry));

dfprintk(VFS, ""NFS: atomic_open(%s/%lu), %pd\n"",
dir->i_sb->s_id, dir->i_ino, dentry);

err = nfs_check_flags(open_flags);
if (err)
return err;


if ((open_flags & O_DIRECTORY)) {
if (!d_in_lookup(dentry)) {





return -ENOENT;
}
lookup_flags = LOOKUP_OPEN|LOOKUP_DIRECTORY;
goto no_open;
}

if (dentry->d_name.len > NFS_SERVER(dir)->namelen)
return -ENAMETOOLONG;

if (open_flags & O_CREAT) {
struct nfs_server *server = NFS_SERVER(dir);

if (!(server->attr_bitmask[2] & FATTR4_WORD2_MODE_UMASK))
mode &= ~current_umask();

attr.ia_valid |= ATTR_MODE;
attr.ia_mode = mode;
}
if (open_flags & O_TRUNC) {
attr.ia_valid |= ATTR_SIZE;
attr.ia_size = 0;
}

if (!(open_flags & O_CREAT) && !d_in_lookup(dentry)) {
d_drop(dentry);
switched = true;
dentry = d_alloc_parallel(dentry->d_parent,
&dentry->d_name, &wq);
if (IS_ERR(dentry))
return PTR_ERR(dentry);
if (unlikely(!d_in_lookup(dentry)))
return finish_no_open(file, dentry);
}

ctx = create_nfs_open_context(dentry, open_flags, file);
err = PTR_ERR(ctx);
if (IS_ERR(ctx))
goto out;

trace_nfs_atomic_open_enter(dir, ctx, open_flags);
inode = NFS_PROTO(dir)->open_context(dir, ctx, open_flags, &attr, &created);
if (created)
file->f_mode |= FMODE_CREATED;
if (IS_ERR(inode)) {
err = PTR_ERR(inode);
trace_nfs_atomic_open_exit(dir, ctx, open_flags, err);
put_nfs_open_context(ctx);
d_drop(dentry);
switch (err) {
case -ENOENT:
d_splice_alias(NULL, dentry);
if (nfs_server_capable(dir, NFS_CAP_CASE_INSENSITIVE))
dir_verifier = inode_peek_iversion_raw(dir);
else
dir_verifier = nfs_save_change_attribute(dir);
nfs_set_verifier(dentry, dir_verifier);
break;
case -EISDIR:
case -ENOTDIR:
goto no_open;
case -ELOOP:
if (!(open_flags & O_NOFOLLOW))
goto no_open;
break;

default:
break;
}
goto out;
}

err = nfs_finish_open(ctx, ctx->dentry, file, open_flags);
trace_nfs_atomic_open_exit(dir, ctx, open_flags, err);
put_nfs_open_context(ctx);
out:
if (unlikely(switched)) {
d_lookup_done(dentry);
dput(dentry);
}
return err;

no_open:
res = nfs_lookup(dir, dentry, lookup_flags);
if (switched) {
d_lookup_done(dentry);
if (!res)
res = dentry;
else
dput(dentry);
}
if (IS_ERR(res))
return PTR_ERR(res);
return finish_no_open(file, res);
}",[117],"An issue was discovered in fs/nfs/dir.c in the Linux kernel before 5.16.5. If an application sets the O_DIRECTORY flag, and tries to open a regular file, nfs_atomic_open() performs a regular lookup. If a regular file is found, ENOTDIR should occur, but the server instead returns uninitialized data in the file descriptor."
199207," static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,
 		      struct msghdr *msg, size_t size, int flags)
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;
 	size_t copied;
 	struct sk_buff *skb;
 	int er;
 
 	 
 
 	lock_sock(sk);
 	if (sk->sk_state != TCP_ESTABLISHED) {
 		release_sock(sk);
 		return -ENOTCONN;
 	}
 
 	 
 	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
 		release_sock(sk);
 		return er;
 	}
 
 	skb_reset_transport_header(skb);
 	copied     = skb->len;
 
 	if (copied > size) {
 		copied = size;
 		msg->msg_flags |= MSG_TRUNC;
 	}
 
 	er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
 	if (er < 0) {
 		skb_free_datagram(sk, skb);
 		release_sock(sk);
 		return er;
  	}
  
  	if (sax != NULL) {
 		memset(sax, 0, sizeof(sax));
  		sax->sax25_family = AF_NETROM;
  		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,
  			      AX25_ADDR_LEN);
 	}
 
 	msg->msg_namelen = sizeof(*sax);
 
 	skb_free_datagram(sk, skb);
 
 	release_sock(sk);
 	return copied;
 }",[40],"The nr_recvmsg function in net/netrom/af_netrom.c in the Linux kernel before 3.9-rc7 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory via a crafted recvmsg or recvfrom system call."
198321," static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
 {
 	long datalen;
 
 	datalen = parse_iv2((*p) + 2, p);
  
         (*p) += 2;
  
       if (datalen < 0 || (*p) + datalen >= max) {
        if (datalen < 0 || (max - (*p)) <= datalen) {
                 zend_error(E_WARNING, ""Insufficient data for unserializing - %ld required, %ld present"", datalen, (long)(max - (*p)));
                 return 0;
         }
 
 	if (ce->unserialize == NULL) {
 		zend_error(E_WARNING, ""Class %s has no unserializer"", ce->name);
 		object_init_ex(*rval, ce);
 	} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {
 		return 0;
 	}
 
 	(*p) += datalen;
 
 	return finish_nested_data(UNSERIALIZE_PASSTHRU);
 }","[10, 9]","Integer overflow in the object_custom function in ext/standard/var_unserializer.c in PHP before 5.4.34, 5.5.x before 5.5.18, and 5.6.x before 5.6.2 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via an argument to the unserialize function that triggers calculation of a large length value."
200563," void __scm_destroy(struct scm_cookie *scm)
 {
 	struct scm_fp_list *fpl = scm->fp;
 	int i;
 
 	if (fpl) {
  		scm->fp = NULL;
  		for (i=fpl->count-1; i>=0; i--)
  			fput(fpl->fp[i]);
 		free_uid(fpl->user);
  		kfree(fpl);
  	}
  }",[10],The Linux kernel before 4.5 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by leveraging incorrect tracking of descriptor ownership and sending each descriptor over a UNIX socket before closing it. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-4312.
205227," void AudioInputRendererHost::OnCreateStream(
     int stream_id, const media::AudioParameters& params,
     const std::string& device_id, bool automatic_gain_control) {
    VLOG(1) << ""AudioInputRendererHost::OnCreateStream(stream_id=""
            << stream_id << "")"";
    DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
  DCHECK(LookupById(stream_id) == NULL);
    
   if (LookupById(stream_id) != NULL) {
     SendErrorMessage(stream_id);
     return;
   }
  
    media::AudioParameters audio_params(params);
  
   if (media_stream_manager_->audio_input_device_manager()->
       ShouldUseFakeDevice()) {
     audio_params.Reset(media::AudioParameters::AUDIO_FAKE,
                        params.channel_layout(), params.sample_rate(),
                        params.bits_per_sample(), params.frames_per_buffer());
   } else if (WebContentsCaptureUtil::IsWebContentsDeviceId(device_id)) {
     audio_params.Reset(media::AudioParameters::AUDIO_VIRTUAL,
                        params.channel_layout(), params.sample_rate(),
                         params.bits_per_sample(), params.frames_per_buffer());
    }
  
  DCHECK_GT(audio_params.frames_per_buffer(), 0);
    uint32 buffer_size = audio_params.GetBytesPerBuffer();
  
   scoped_ptr<AudioEntry> entry(new AudioEntry());
 
   uint32 mem_size = sizeof(media::AudioInputBufferParameters) + buffer_size;
 
   if (!entry->shared_memory.CreateAndMapAnonymous(mem_size)) {
     SendErrorMessage(stream_id);
     return;
   }
 
   scoped_ptr<AudioInputSyncWriter> writer(
       new AudioInputSyncWriter(&entry->shared_memory));
 
   if (!writer->Init()) {
     SendErrorMessage(stream_id);
     return;
   }
 
   entry->writer.reset(writer.release());
   entry->controller = media::AudioInputController::CreateLowLatency(
       audio_manager_,
       this,
       audio_params,
       device_id,
       entry->writer.get());
 
   if (!entry->controller) {
     SendErrorMessage(stream_id);
     return;
   }
 
   if (params.format() == media::AudioParameters::AUDIO_PCM_LOW_LATENCY)
     entry->controller->SetAutomaticGainControl(automatic_gain_control);
 
   entry->stream_id = stream_id;
 
   audio_entries_.insert(std::make_pair(stream_id, entry.release()));
 }","[8, 9, 10, 11, 12, 7, 27]",Integer overflow in the audio IPC layer in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.
200656," int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)
 {
 	struct super_block *sb = inode->i_sb;
 	handle_t *handle;
 	struct ext4_ext_path *path;
 	struct ext4_extent *extent;
 	ext4_lblk_t offset_lblk, len_lblk, ee_start_lblk = 0;
 	unsigned int credits, ee_len;
 	int ret = 0, depth, split_flag = 0;
 	loff_t ioffset;
 
 	 
 	if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
 		return -EOPNOTSUPP;
 
 	 
 	if (offset & (EXT4_CLUSTER_SIZE(sb) - 1) ||
 			len & (EXT4_CLUSTER_SIZE(sb) - 1))
 		return -EINVAL;
 
 	if (!S_ISREG(inode->i_mode))
 		return -EOPNOTSUPP;
 
 	trace_ext4_insert_range(inode, offset, len);
 
 	offset_lblk = offset >> EXT4_BLOCK_SIZE_BITS(sb);
 	len_lblk = len >> EXT4_BLOCK_SIZE_BITS(sb);
 
 	 
 	if (ext4_should_journal_data(inode)) {
 		ret = ext4_force_commit(inode->i_sb);
 		if (ret)
 			return ret;
 	}
 
 	 
 	ioffset = round_down(offset, PAGE_SIZE);
 
 	 
 	ret = filemap_write_and_wait_range(inode->i_mapping, ioffset,
 			LLONG_MAX);
 	if (ret)
 		return ret;
 
 	 
 	mutex_lock(&inode->i_mutex);
 
 	 
 	if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {
 		ret = -EOPNOTSUPP;
 		goto out_mutex;
 	}
 
 	 
 	if (inode->i_size + len > inode->i_sb->s_maxbytes) {
 		ret = -EFBIG;
 		goto out_mutex;
 	}
 
 	 
 	if (offset >= i_size_read(inode)) {
 		ret = -EINVAL;
  		goto out_mutex;
  	}
  
	truncate_pagecache(inode, ioffset);
  	 
  	ext4_inode_block_unlocked_dio(inode);
  	inode_dio_wait(inode);
  
 	 
 	down_write(&EXT4_I(inode)->i_mmap_sem);
 	truncate_pagecache(inode, ioffset);
 
  	credits = ext4_writepage_trans_blocks(inode);
  	handle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);
  	if (IS_ERR(handle)) {
  		ret = PTR_ERR(handle);
		goto out_dio;
 		goto out_mmap;
  	}
  
  	 
 	inode->i_size += len;
 	EXT4_I(inode)->i_disksize += len;
 	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
 	ret = ext4_mark_inode_dirty(handle, inode);
 	if (ret)
 		goto out_stop;
 
 	down_write(&EXT4_I(inode)->i_data_sem);
 	ext4_discard_preallocations(inode);
 
 	path = ext4_find_extent(inode, offset_lblk, NULL, 0);
 	if (IS_ERR(path)) {
 		up_write(&EXT4_I(inode)->i_data_sem);
 		goto out_stop;
 	}
 
 	depth = ext_depth(inode);
 	extent = path[depth].p_ext;
 	if (extent) {
 		ee_start_lblk = le32_to_cpu(extent->ee_block);
 		ee_len = ext4_ext_get_actual_len(extent);
 
 		 
 		if ((offset_lblk > ee_start_lblk) &&
 				(offset_lblk < (ee_start_lblk + ee_len))) {
 			if (ext4_ext_is_unwritten(extent))
 				split_flag = EXT4_EXT_MARK_UNWRIT1 |
 					EXT4_EXT_MARK_UNWRIT2;
 			ret = ext4_split_extent_at(handle, inode, &path,
 					offset_lblk, split_flag,
 					EXT4_EX_NOCACHE |
 					EXT4_GET_BLOCKS_PRE_IO |
 					EXT4_GET_BLOCKS_METADATA_NOFAIL);
 		}
 
 		ext4_ext_drop_refs(path);
 		kfree(path);
 		if (ret < 0) {
 			up_write(&EXT4_I(inode)->i_data_sem);
 			goto out_stop;
 		}
 	}
 
 	ret = ext4_es_remove_extent(inode, offset_lblk,
 			EXT_MAX_BLOCKS - offset_lblk);
 	if (ret) {
 		up_write(&EXT4_I(inode)->i_data_sem);
 		goto out_stop;
 	}
 
 	 
 	ret = ext4_ext_shift_extents(inode, handle,
 		ee_start_lblk > offset_lblk ? ee_start_lblk : offset_lblk,
 		len_lblk, SHIFT_RIGHT);
 
 	up_write(&EXT4_I(inode)->i_data_sem);
 	if (IS_SYNC(inode))
 		ext4_handle_sync(handle);
  
  out_stop:
  	ext4_journal_stop(handle);
out_dio:
 out_mmap:
 	up_write(&EXT4_I(inode)->i_mmap_sem);
  	ext4_inode_resume_unlocked_dio(inode);
  out_mutex:
  	mutex_unlock(&inode->i_mutex);
 	return ret;
 }","[71, 72, 73, 74, 80, 146, 147, 66, 79, 145]",Multiple race conditions in the ext4 filesystem implementation in the Linux kernel before 4.5 allow local users to cause a denial of service (disk corruption) by writing to a page that is associated with a different user's file after unsynchronized hole punching and page-fault handling.
203070," static int rfcomm_get_dev_list(void __user *arg)
 {
 	struct rfcomm_dev *dev;
 	struct rfcomm_dev_list_req *dl;
 	struct rfcomm_dev_info *di;
 	int n = 0, size, err;
 	u16 dev_num;
 
 	BT_DBG("""");
 
 	if (get_user(dev_num, (u16 __user *) arg))
 		return -EFAULT;
 
 	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
 		return -EINVAL;
  
  	size = sizeof(*dl) + dev_num * sizeof(*di);
  
	dl = kmalloc(size, GFP_KERNEL);
 	dl = kzalloc(size, GFP_KERNEL);
  	if (!dl)
  		return -ENOMEM;
  
 	di = dl->dev_info;
 
 	spin_lock(&rfcomm_dev_lock);
 
 	list_for_each_entry(dev, &rfcomm_dev_list, list) {
 		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
 			continue;
 		(di + n)->id      = dev->id;
 		(di + n)->flags   = dev->flags;
 		(di + n)->state   = dev->dlc->state;
 		(di + n)->channel = dev->channel;
 		bacpy(&(di + n)->src, &dev->src);
 		bacpy(&(di + n)->dst, &dev->dst);
 		if (++n >= dev_num)
 			break;
 	}
 
 	spin_unlock(&rfcomm_dev_lock);
 
 	dl->dev_num = n;
 	size = sizeof(*dl) + n * sizeof(*di);
 
 	err = copy_to_user(arg, dl, size);
 	kfree(dl);
 
 	return err ? -EFAULT : 0;
 }","[20, 19]","The Bluetooth RFCOMM implementation in the Linux kernel before 3.6 does not properly initialize certain structures, which allows local users to obtain sensitive information from kernel memory via a crafted application."
198573,"  set_hunkmax (void)
  {
      if (!p_line)
	p_line = (char **) malloc (hunkmax * sizeof *p_line);
 	p_line = (char **) xmalloc (hunkmax * sizeof *p_line);
      if (!p_len)
	p_len = (size_t *) malloc (hunkmax * sizeof *p_len);
 	p_len = (size_t *) xmalloc (hunkmax * sizeof *p_len);
      if (!p_Char)
	p_Char = malloc (hunkmax * sizeof *p_Char);
 	p_Char = xmalloc (hunkmax * sizeof *p_Char);
  }","[5, 8, 11, 4, 7, 10]",GNU patch 2.7.2 and earlier allows remote attackers to cause a denial of service (memory consumption and segmentation fault) via a crafted diff file.
208549,"  virtual void SetUp() {
 
      fwd_txfm_ = GET_PARAM(0);
      inv_txfm_ = GET_PARAM(1);
      tx_type_  = GET_PARAM(2);
     bit_depth_ = GET_PARAM(3);
      pitch_    = 16;
      fwd_txfm_ref = fdct16x16_ref;
     inv_txfm_ref = idct16x16_ref;
     mask_ = (1 << bit_depth_) - 1;
 #if CONFIG_VP9_HIGHBITDEPTH
     switch (bit_depth_) {
       case VPX_BITS_10:
         inv_txfm_ref = idct16x16_10_ref;
         break;
       case VPX_BITS_12:
         inv_txfm_ref = idct16x16_12_ref;
         break;
       default:
         inv_txfm_ref = idct16x16_ref;
         break;
     }
 #else
     inv_txfm_ref = idct16x16_ref;
 #endif
    }","[6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
8437,"int ParseCertRelative(DecodedCert* cert, int type, int verify, void* cm)
{
int    ret = 0;
int    checkPathLen = 0;
int    decrementMaxPathLen = 0;
word32 confirmOID = 0;
#if defined(WOLFSSL_RENESAS_TSIP)
int    idx = 0;
#endif
byte*  tsip_encRsaKeyIdx;
#ifdef WOLFSSL_CERT_REQ
int    len = 0;
#endif

if (cert == NULL) {
return BAD_FUNC_ARG;
}

#ifdef WOLFSSL_CERT_REQ
if (type == CERTREQ_TYPE)
cert->isCSR = 1;
#endif

if (cert->sigCtx.state == SIG_STATE_BEGIN) {
cert->badDate = 0;
cert->criticalExt = 0;
if ((ret = DecodeToKey(cert, verify)) < 0) {
if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E)
cert->badDate = ret;
else
return ret;
}

WOLFSSL_MSG(""Parsed Past Key"");


#ifdef WOLFSSL_CERT_REQ

if (cert->isCSR) {
if (GetASNHeader_ex(cert->source,
ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED, &cert->srcIdx,
&len, cert->maxIdx, 1) < 0) {
WOLFSSL_MSG(""GetASNHeader_ex error"");
return ASN_PARSE_E;
}

if (len) {
word32 attrMaxIdx = cert->srcIdx + len;
word32 oid;
byte   tag;

if (attrMaxIdx > cert->maxIdx) {
WOLFSSL_MSG(""Attribute length greater than CSR length"");
return ASN_PARSE_E;
}

while (cert->srcIdx < attrMaxIdx) {


if (GetSequence(cert->source, &cert->srcIdx, &len,
attrMaxIdx) < 0) {
WOLFSSL_MSG(""attr GetSequence error"");
return ASN_PARSE_E;
}
if (GetObjectId(cert->source, &cert->srcIdx, &oid,
oidCsrAttrType, attrMaxIdx) < 0) {
WOLFSSL_MSG(""attr GetObjectId error"");
return ASN_PARSE_E;
}
if (GetSet(cert->source, &cert->srcIdx, &len,
attrMaxIdx) < 0) {
WOLFSSL_MSG(""attr GetSet error"");
return ASN_PARSE_E;
}
switch (oid) {
case CHALLENGE_PASSWORD_OID:
if (GetHeader(cert->source, &tag,
&cert->srcIdx, &len, attrMaxIdx, 1) < 0) {
WOLFSSL_MSG(""attr GetHeader error"");
return ASN_PARSE_E;
}
if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&
tag != ASN_IA5_STRING) {
WOLFSSL_MSG(""Unsupported attribute value format"");
return ASN_PARSE_E;
}
cert->cPwd = (char*)cert->source + cert->srcIdx;
cert->cPwdLen = len;
cert->srcIdx += len;
break;
case SERIAL_NUMBER_OID:
if (GetHeader(cert->source, &tag,
&cert->srcIdx, &len, attrMaxIdx, 1) < 0) {
WOLFSSL_MSG(""attr GetHeader error"");
return ASN_PARSE_E;
}
if (tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&
tag != ASN_IA5_STRING) {
WOLFSSL_MSG(""Unsupported attribute value format"");
return ASN_PARSE_E;
}
cert->sNum = (char*)cert->source + cert->srcIdx;
cert->sNumLen = len;
cert->srcIdx += len;
if (cert->sNumLen <= EXTERNAL_SERIAL_SIZE) {
XMEMCPY(cert->serial, cert->sNum, cert->sNumLen);
cert->serialSz = cert->sNumLen;
}
break;
case EXTENSION_REQUEST_OID:

cert->extensions    = &cert->source[cert->srcIdx];
cert->extensionsSz  = len;
cert->extensionsIdx = cert->srcIdx;

if ((ret = DecodeCertExtensions(cert)) < 0) {
if (ret == ASN_CRIT_EXT_E)
cert->criticalExt = ret;
else
return ret;
}
cert->srcIdx += len;
break;
default:
WOLFSSL_MSG(""Unsupported attribute type"");
return ASN_PARSE_E;
}
}
}
}
#endif

if (cert->srcIdx < cert->sigIndex) {
#ifndef ALLOW_V1_EXTENSIONS
if (cert->version < 2) {
WOLFSSL_MSG(""\tv1 and v2 certs not allowed extensions"");
return ASN_VERSION_E;
}
#endif


cert->extensions    = &cert->source[cert->srcIdx];
cert->extensionsSz  = cert->sigIndex - cert->srcIdx;
cert->extensionsIdx = cert->srcIdx;

if ((ret = DecodeCertExtensions(cert)) < 0) {
if (ret == ASN_CRIT_EXT_E)
cert->criticalExt = ret;
else
return ret;
}

#ifdef HAVE_OCSP

if (cert->ocspNoCheckSet && verify == VERIFY_OCSP)
verify = NO_VERIFY;
#endif

cert->srcIdx = cert->sigIndex;
}

if ((ret = GetAlgoId(cert->source, &cert->srcIdx,
#ifdef WOLFSSL_CERT_REQ
!cert->isCSR ? &confirmOID : &cert->signatureOID,
#else
&confirmOID,
#endif
oidSigType, cert->maxIdx)) < 0)
return ret;

if ((ret = GetSignature(cert)) < 0)
return ret;

if (confirmOID != cert->signatureOID
#ifdef WOLFSSL_CERT_REQ
&& !cert->isCSR
#endif
)
return ASN_SIG_OID_E;

#ifndef NO_SKID
if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
cert->pubKeySize > 0) {
ret = CalcHashId(cert->publicKey, cert->pubKeySize,
cert->extSubjKeyId);
if (ret != 0)
return ret;
}
#endif /* !NO_SKID */

if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
type != TRUSTED_PEER_TYPE)) {
cert->ca = NULL;
#ifndef NO_SKID
if (cert->extAuthKeyIdSet) {
cert->ca = GetCA(cm, cert->extAuthKeyId);
}
if (cert->ca == NULL && cert->extSubjKeyIdSet
&& verify != VERIFY_OCSP) {
cert->ca = GetCA(cm, cert->extSubjKeyId);
}
if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
cert->ca->subjectNameHash, KEYID_SIZE) != 0) {
cert->ca = NULL;
}
if (cert->ca == NULL) {
cert->ca = GetCAByName(cm, cert->issuerHash);


if (cert->ca && cert->extAuthKeyIdSet) {
WOLFSSL_MSG(""CA SKID doesn't match AKID"");
cert->ca = NULL;
}
}


#ifdef WOLFSSL_NO_TRUSTED_CERTS_VERIFY
if (cert->ca == NULL && verify == VERIFY_OCSP) {
cert->ca = GetCABySubjectAndPubKey(cert, cm);
if (cert->ca) {
ret = 0;
goto exit_pcr;
}
}
#endif /* WOLFSSL_NO_TRUSTED_CERTS_VERIFY */
#else
cert->ca = GetCA(cm, cert->issuerHash);
#endif /* !NO_SKID */

if (cert->ca) {
WOLFSSL_MSG(""CA found"");
}
}

if (cert->selfSigned) {
cert->maxPathLen = WOLFSSL_MAX_PATH_LEN;
} else {
























if (cert->ca && cert->pathLengthSet) {
cert->maxPathLen = cert->pathLength;
if (cert->isCA) {
WOLFSSL_MSG(""\tCA boolean set"");
if (cert->extKeyUsageSet) {
WOLFSSL_MSG(""\tExtension Key Usage Set"");
if ((cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0) {
checkPathLen = 1;
} else {
decrementMaxPathLen = 1;
}
} else {
checkPathLen = 1;
}
}

if (checkPathLen && cert->pathLengthSet) {
if (cert->pathLength < cert->ca->maxPathLen) {
WOLFSSL_MSG(""\tmaxPathLen status: set to pathLength"");
cert->maxPathLen = cert->pathLength;
} else {
decrementMaxPathLen = 1;
}
}

if (decrementMaxPathLen && cert->ca->maxPathLen > 0) {
WOLFSSL_MSG(""\tmaxPathLen status: reduce by 1"");
cert->maxPathLen = cert->ca->maxPathLen - 1;
if (verify != NO_VERIFY && type != CA_TYPE &&
type != TRUSTED_PEER_TYPE) {
WOLFSSL_MSG(""\tmaxPathLen status: OK"");
}
} else if (decrementMaxPathLen && cert->ca->maxPathLen == 0) {
cert->maxPathLen = 0;
if (verify != NO_VERIFY && type != CA_TYPE &&
type != TRUSTED_PEER_TYPE) {
WOLFSSL_MSG(""\tNon-entity cert, maxPathLen is 0"");
WOLFSSL_MSG(""\tmaxPathLen status: ERROR"");
return ASN_PATHLEN_INV_E;
}
}
} else if (cert->ca && cert->isCA) {

if (cert->ca->maxPathLen > 0) {
cert->maxPathLen = cert->ca->maxPathLen - 1;
} else {
cert->maxPathLen = 0;
if (verify != NO_VERIFY && type != CA_TYPE &&
type != TRUSTED_PEER_TYPE) {
WOLFSSL_MSG(""\tNon-entity cert, maxPathLen is 0"");
WOLFSSL_MSG(""\tmaxPathLen status: ERROR"");
return ASN_PATHLEN_INV_E;
}
}
}
}

#ifdef HAVE_OCSP
if (verify != NO_VERIFY && type != CA_TYPE &&
type != TRUSTED_PEER_TYPE) {
if (cert->ca) {

XMEMCPY(cert->issuerKeyHash, cert->ca->subjectKeyHash,
KEYID_SIZE);
}
}
#endif /* HAVE_OCSP */
}
#if defined(WOLFSSL_RENESAS_TSIP)

if (cert->keyOID == RSAk) {

if ((ret = RsaPublicKeyDecodeRawIndex(cert->publicKey, (word32*)&idx,
cert->pubKeySize,
&cert->sigCtx.pubkey_n_start,
&cert->sigCtx.pubkey_n_len,
&cert->sigCtx.pubkey_e_start,
&cert->sigCtx.pubkey_e_len)) != 0) {
WOLFSSL_MSG(""Decoding index from cert failed."");
return ret;
}
cert->sigCtx.certBegin = cert->certBegin;
}



if (cert->ca && tsip_checkCA(cert->ca->cm_idx) != 0 &&
cert->sigCtx.pubkey_n_len == 256) {


if (!cert->tsip_encRsaKeyIdx)
cert->tsip_encRsaKeyIdx =
(byte*)XMALLOC(TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,
cert->heap, DYNAMIC_TYPE_RSA);
if (cert->tsip_encRsaKeyIdx == NULL)
return MEMORY_E;
} else {
if (cert->ca) {

if (tsip_checkCA(cert->ca->cm_idx) == 0)
WOLFSSL_MSG(""TSIP isn't usable because the ca isn't verified ""
""by TSIP."");
else if (cert->sigCtx.pubkey_n_len != 256)
WOLFSSL_MSG(""TSIP isn't usable because the ca isn't signed by ""
""RSA 2048."");
else
WOLFSSL_MSG(""TSIP isn't usable"");
}
cert->tsip_encRsaKeyIdx = NULL;
}

tsip_encRsaKeyIdx = cert->tsip_encRsaKeyIdx;
#else
tsip_encRsaKeyIdx = NULL;
#endif

if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
if (cert->ca) {
if (verify == VERIFY || verify == VERIFY_OCSP ||
verify == VERIFY_SKIP_DATE) {

if ((ret = ConfirmSignature(&cert->sigCtx,
cert->source + cert->certBegin,
cert->sigIndex - cert->certBegin,
cert->ca->publicKey, cert->ca->pubKeySize,
cert->ca->keyOID, cert->signature,
cert->sigLength, cert->signatureOID,
tsip_encRsaKeyIdx)) != 0) {
if (ret != WC_PENDING_E) {
WOLFSSL_MSG(""Confirm signature failed"");
}
return ret;
}
}
#ifndef IGNORE_NAME_CONSTRAINTS
if (verify == VERIFY || verify == VERIFY_OCSP ||
verify == VERIFY_NAME || verify == VERIFY_SKIP_DATE) {


if (!ConfirmNameConstraints(cert->ca, cert)) {
WOLFSSL_MSG(""Confirm name constraint failed"");
return ASN_NAME_INVALID_E;
}
}
#endif /* IGNORE_NAME_CONSTRAINTS */
}
else {

WOLFSSL_MSG(""No CA signer to verify with"");
return ASN_NO_SIGNER_E;
}
}

#if defined(WOLFSSL_NO_TRUSTED_CERTS_VERIFY) && !defined(NO_SKID)
exit_pcr:
#endif

if (cert->badDate != 0) {
if (verify != VERIFY_SKIP_DATE) {
return cert->badDate;
}
WOLFSSL_MSG(""Date error: Verify option is skipping"");
}

if (cert->criticalExt != 0)
return cert->criticalExt;

return ret;
}","[155, 156]",wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.
200840," static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {
 	size_t i, j, k;
 	RBinDwarfDIE *dies;
 	RBinDwarfAttrValue *values;
 	if (!inf || !f) {
 		return;
 	}
 
 	for (i = 0; i < inf->length; i++) {
 		fprintf (f, ""  Compilation Unit @ offset 0x%""PFMT64x"":\n"", inf->comp_units [i].offset);
 		fprintf (f, ""   Length:        0x%x\n"", inf->comp_units [i].hdr.length);
 		fprintf (f, ""   Version:       %d\n"", inf->comp_units [i].hdr.version);
 		fprintf (f, ""   Abbrev Offset: 0x%x\n"", inf->comp_units [i].hdr.abbrev_offset);
 		fprintf (f, ""   Pointer Size:  %d\n"", inf->comp_units [i].hdr.pointer_size);
 
 		dies = inf->comp_units[i].dies;
 
 		for (j = 0; j < inf->comp_units[i].length; j++) {
 			fprintf (f, ""    Abbrev Number: %""PFMT64u"" "", dies[j].abbrev_code);
 
 			if (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&
 				       dwarf_tag_name_encodings[dies[j].tag]) {
 				fprintf (f, ""(%s)\n"", dwarf_tag_name_encodings[dies[j].tag]);
 			} else {
 				fprintf (f, ""(Unknown abbrev tag)\n"");
 			}
 
 			if (!dies[j].abbrev_code) {
 				continue;
 			}
  			values = dies[j].attr_values;
  
  			for (k = 0; k < dies[j].length; k++) {
				if (!values[k].name)
 				if (!values[k].name) {
  					continue;
 				}
  
  				if (values[k].name < DW_AT_vtable_elem_location &&
  						dwarf_attr_encodings[values[k].name]) {
 					fprintf (f, ""     %-18s : "", dwarf_attr_encodings[values[k].name]);
 				} else {
 					fprintf (f, ""     TODO\t"");
 				}
 				r_bin_dwarf_dump_attr_value (&values[k], f);
 				fprintf (f, ""\n"");
 			}
 		}
 	}
 }","[35, 37, 34]","In radare2 2.0.1, libr/bin/dwarf.c allows remote attackers to cause a denial of service (invalid read and application crash) via a crafted ELF file, related to r_bin_dwarf_parse_comp_unit in dwarf.c and sdb_set_internal in shlr/sdb/src/sdb.c."
201548," parse_range(char *str, size_t file_sz, int *nranges)
 int
 parse_ranges(struct client *clt, char *str, size_t file_sz)
  {
	static struct range	 ranges[MAX_RANGES];
  	int			 i = 0;
  	char			*p, *q;
 	struct range_data	*r = &clt->clt_ranges;
 
 	memset(r, 0, sizeof(*r));
  
  	 
  	if ((p = strchr(str, '=')) == NULL)
		return (NULL);
 		return (-1);
  
  	*p++ = '\0';
  	 
  	if (strcmp(str, ""bytes"") != 0)
		return (NULL);
 		return (-1);
  
  	while ((q = strchr(p, ',')) != NULL) {
  		*q++ = '\0';
  
  		 
		if (parse_range_spec(p, file_sz, &ranges[i]) == 0)
 		if (parse_range_spec(p, file_sz, &r->range[i]) == 0)
  			continue;
  
  		i++;
		if (i == MAX_RANGES)
			return (NULL);
 		if (i == SERVER_MAX_RANGES)
 			return (-1);
  
  		p = q;
  	}
  
	if (parse_range_spec(p, file_sz, &ranges[i]) != 0)
 	if (parse_range_spec(p, file_sz, &r->range[i]) != 0)
  		i++;
  
	*nranges = i;
	return (i ? ranges : NULL);
 	r->range_total = file_sz;
 	r->range_count = i;
 	return (i);
  }","[2, 3, 8, 9, 10, 15, 21, 28, 34, 35, 41, 46, 47, 48, 5, 14, 20, 27, 32, 33, 40, 44, 45]",httpd in OpenBSD allows remote attackers to cause a denial of service (memory consumption) via a series of requests for a large file using an HTTP Range header.
208627," void WT_VoiceFilter (S_FILTER_CONTROL *pFilter, S_WT_INT_FRAME *pWTIntFrame)
 {
     EAS_PCM *pAudioBuffer;
     EAS_I32 k;
     EAS_I32 b1;
     EAS_I32 b2;
     EAS_I32 z1;
     EAS_I32 z2;
     EAS_I32 acc0;
     EAS_I32 acc1;
     EAS_I32 numSamples;
 
   
 
      numSamples = pWTIntFrame->numSamples;
      if (numSamples <= 0) {
          ALOGE(""b/26366256"");
         android_errorWriteLog(0x534e4554, ""26366256"");
          return;
      }
      pAudioBuffer = pWTIntFrame->pAudioBuffer;
 
     z1 = pFilter->z1;
     z2 = pFilter->z2;
     b1 = -pWTIntFrame->frame.b1;
 
   
     b2 = -pWTIntFrame->frame.b2 >> 1;
 
   
     k = pWTIntFrame->frame.k >> 1;
 
  while (numSamples--)
  {
 
   
         acc0 = *pAudioBuffer;
         acc1 = z1 * b1;
         acc1 += z2 * b2;
         acc0 = acc1 + k * acc0;
         z2 = z1;
 
   
         z1 = acc0 >> 14;
  *pAudioBuffer++ = (EAS_I16) z1;
  }
 
   
     pFilter->z1 = (EAS_I16) z1;
     pFilter->z2 = (EAS_I16) z2;
 }",[18],"Sonivox in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not check for a negative number of samples, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to arm-wt-22k/lib_src/eas_wtengine.c and arm-wt-22k/lib_src/eas_wtsynth.c, aka internal bug 26366256."
198507," int tls1_change_cipher_state(SSL *s, int which)
 	{
 	static const unsigned char empty[]="""";
 	unsigned char *p,*mac_secret;
 	unsigned char *exp_label;
 	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
 	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
 	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
 	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
 	unsigned char *ms,*key,*iv;
 	int client_write;
 	EVP_CIPHER_CTX *dd;
 	const EVP_CIPHER *c;
 #ifndef OPENSSL_NO_COMP
 	const SSL_COMP *comp;
 #endif
 	const EVP_MD *m;
 	int mac_type;
 	int *mac_secret_size;
 	EVP_MD_CTX *mac_ctx;
 	EVP_PKEY *mac_key;
 	int is_export,n,i,j,k,exp_label_len,cl;
 	int reuse_dd = 0;
 
 	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
 	c=s->s3->tmp.new_sym_enc;
 	m=s->s3->tmp.new_hash;
 	mac_type = s->s3->tmp.new_mac_pkey_type;
 #ifndef OPENSSL_NO_COMP
 	comp=s->s3->tmp.new_compression;
 #endif
 
 #ifdef KSSL_DEBUG
 	printf(""tls1_change_cipher_state(which= %d) w/\n"", which);
 	printf(""\talg= %ld/%ld, comp= %p\n"",
 	       s->s3->tmp.new_cipher->algorithm_mkey,
 	       s->s3->tmp.new_cipher->algorithm_auth,
 	       comp);
 	printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c);
 	printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"",
                 c->nid,c->block_size,c->key_len,c->iv_len);
 	printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length);
 	{
         int i;
         for (i=0; i<s->s3->tmp.key_block_length; i++)
 		printf(""%02x"", s->s3->tmp.key_block[i]);  printf(""\n"");
         }
 #endif	 
 
 	if (which & SSL3_CC_READ)
 		{
 		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
 			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
 		else
 			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;
 
 		if (s->enc_read_ctx != NULL)
 			reuse_dd = 1;
 		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
 			goto err;
 		else
 			 
 			EVP_CIPHER_CTX_init(s->enc_read_ctx);
 		dd= s->enc_read_ctx;
 		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
 #ifndef OPENSSL_NO_COMP
 		if (s->expand != NULL)
 			{
 			COMP_CTX_free(s->expand);
 			s->expand=NULL;
 			}
 		if (comp != NULL)
 			{
 			s->expand=COMP_CTX_new(comp->method);
 			if (s->expand == NULL)
 				{
 				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
 				goto err2;
 				}
 			if (s->s3->rrec.comp == NULL)
 				s->s3->rrec.comp=(unsigned char *)
 					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
 			if (s->s3->rrec.comp == NULL)
 				goto err;
 			}
 #endif
 		 
  		if (s->version != DTLS1_VERSION)
 			memset(&(s->s3->read_sequence[0]),0,8);
 		mac_secret= &(s->s3->read_mac_secret[0]);
 		mac_secret_size=&(s->s3->read_mac_secret_size);
 		}
 	else
 		{
 		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
                         s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                         else
                         s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
               if (s->enc_write_ctx != NULL)
                if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
                         reuse_dd = 1;
               else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
                else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
                         goto err;
               else
                        
                       EVP_CIPHER_CTX_init(s->enc_write_ctx);
                 dd= s->enc_write_ctx;
               mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
                if (SSL_IS_DTLS(s))
                        {
                        mac_ctx = EVP_MD_CTX_create();
                        if (!mac_ctx)
                                goto err;
                        s->write_hash = mac_ctx;
                        }
                else
                        mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
  #ifndef OPENSSL_NO_COMP
                 if (s->compress != NULL)
                         {
 			s->compress=COMP_CTX_new(comp->method);
 			if (s->compress == NULL)
 				{
 				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
 				goto err2;
 				}
 			}
 #endif
 		 
  		if (s->version != DTLS1_VERSION)
 			memset(&(s->s3->write_sequence[0]),0,8);
 		mac_secret= &(s->s3->write_mac_secret[0]);
 		mac_secret_size = &(s->s3->write_mac_secret_size);
 		}
 
 	if (reuse_dd)
 		EVP_CIPHER_CTX_cleanup(dd);
 
 	p=s->s3->tmp.key_block;
 	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;
 
 	cl=EVP_CIPHER_key_length(c);
 	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
 	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
 	 
 	 
 	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
 		k = EVP_GCM_TLS_FIXED_IV_LEN;
 	else
 		k=EVP_CIPHER_iv_length(c);
 	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
 		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
 		{
 		ms=  &(p[ 0]); n=i+i;
 		key= &(p[ n]); n+=j+j;
 		iv=  &(p[ n]); n+=k+k;
 		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
 		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
 		client_write=1;
 		}
 	else
 		{
 		n=i;
 		ms=  &(p[ n]); n+=i+j;
 		key= &(p[ n]); n+=j+k;
 		iv=  &(p[ n]); n+=k;
 		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
 		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
 		client_write=0;
 		}
 
 	if (n > s->s3->tmp.key_block_length)
 		{
 		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
 		goto err2;
 		}
 
 	memcpy(mac_secret,ms,i);
 
 	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
 		{
 		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
 				mac_secret,*mac_secret_size);
 		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
 		EVP_PKEY_free(mac_key);
 		}
 #ifdef TLS_DEBUG
 printf(""which = %04X\nmac key="",which);
 { int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); }
 #endif
 	if (is_export)
 		{
 		 
 		if (!tls1_PRF(ssl_get_algorithm2(s),
 				exp_label,exp_label_len,
 				s->s3->client_random,SSL3_RANDOM_SIZE,
 				s->s3->server_random,SSL3_RANDOM_SIZE,
 				NULL,0,NULL,0,
 				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
 			goto err2;
 		key=tmp1;
 
 		if (k > 0)
 			{
 			if (!tls1_PRF(ssl_get_algorithm2(s),
 					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
 					s->s3->client_random,SSL3_RANDOM_SIZE,
 					s->s3->server_random,SSL3_RANDOM_SIZE,
 					NULL,0,NULL,0,
 					empty,0,iv1,iv2,k*2))
 				goto err2;
 			if (client_write)
 				iv=iv1;
 			else
 				iv= &(iv1[k]);
 			}
 		}
 
 	s->session->key_arg_length=0;
 #ifdef KSSL_DEBUG
 	{
         int i;
 	printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n"");
 	printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]);
 	printf(""\n"");
 	printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]);
 	printf(""\n"");
 	}
 #endif	 
 
 	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
 		{
 		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
 		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
 		}
 	else	
 		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));
 
 	 
 	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
 		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
 				*mac_secret_size,mac_secret);
 
 #ifdef TLS_DEBUG
 printf(""which = %04X\nkey="",which);
 { int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); }
 printf(""\niv="");
 { int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); }
 printf(""\n"");
 #endif
 
 	OPENSSL_cleanse(tmp1,sizeof(tmp1));
 	OPENSSL_cleanse(tmp2,sizeof(tmp1));
 	OPENSSL_cleanse(iv1,sizeof(iv1));
 	OPENSSL_cleanse(iv2,sizeof(iv2));
 	return(1);
 err:
 	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
 err2:
 	return(0);
 	}","[100, 103, 110, 111, 112, 113, 114, 115, 116, 117, 118, 99, 102, 105, 106, 107, 109]","The DTLS retransmission implementation in OpenSSL 1.0.0 before 1.0.0l and 1.0.1 before 1.0.1f does not properly maintain data structures for digest and encryption contexts, which might allow man-in-the-middle attackers to trigger the use of a different context and cause a denial of service (application crash) by interfering with packet delivery, related to ssl/d1_both.c and ssl/t1_enc.c."
205199," GDataFileError GDataWapiFeedProcessor::FeedToFileResourceMap(
     const std::vector<DocumentFeed*>& feed_list,
     FileResourceIdMap* file_map,
     int64* feed_changestamp,
     FeedToFileResourceMapUmaStats* uma_stats) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
   DCHECK(uma_stats);
 
   GDataFileError error = GDATA_FILE_OK;
   uma_stats->num_regular_files = 0;
   uma_stats->num_hosted_documents = 0;
   uma_stats->num_files_with_entry_kind.clear();
   for (size_t i = 0; i < feed_list.size(); ++i) {
     const DocumentFeed* feed = feed_list[i];
 
     if (i == 0) {
       const Link* root_feed_upload_link =
           feed->GetLinkByType(Link::RESUMABLE_CREATE_MEDIA);
       if (root_feed_upload_link)
         directory_service_->root()->set_upload_url(
             root_feed_upload_link->href());
       *feed_changestamp = feed->largest_changestamp();
       DCHECK_GE(*feed_changestamp, 0);
     }
 
     for (ScopedVector<DocumentEntry>::const_iterator iter =
               feed->entries().begin();
           iter != feed->entries().end(); ++iter) {
        DocumentEntry* doc = *iter;
      GDataEntry* entry = GDataEntry::FromDocumentEntry(
          NULL, doc, directory_service_);
       GDataEntry* entry = directory_service_->FromDocumentEntry(doc);
        if (!entry)
          continue;
       GDataFile* as_file = entry->AsGDataFile();
       if (as_file) {
         if (as_file->is_hosted_document())
           ++uma_stats->num_hosted_documents;
         else
           ++uma_stats->num_regular_files;
         ++uma_stats->num_files_with_entry_kind[as_file->kind()];
       }
 
       FileResourceIdMap::iterator map_entry =
           file_map->find(entry->resource_id());
 
       if (map_entry != file_map->end()) {
         LOG(WARNING) << ""Found duplicate file ""
                      << map_entry->second->base_name();
 
         delete map_entry->second;
         file_map->erase(map_entry);
       }
       file_map->insert(
           std::pair<std::string, GDataEntry*>(entry->resource_id(), entry));
     }
   }
 
   if (error != GDATA_FILE_OK) {
     STLDeleteValues(file_map);
   }
 
   return error;
 }","[32, 30, 31]",Use-after-free vulnerability in Google Chrome before 24.0.1312.56 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of fonts in CANVAS elements.
207740," white_point(PNG_CONST color_encoding *encoding)
 white_point(const color_encoding *encoding)
  {
     CIE_color white;
  
    white.X = encoding->red.X + encoding->green.X + encoding->blue.X;
    white.Y = encoding->red.Y + encoding->green.Y + encoding->blue.Y;
    white.Z = encoding->red.Z + encoding->green.Z + encoding->blue.Z;
 
  
     return white;
  }",[2],"Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
10102,"static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {
pyc_object *ret = NULL;
bool error = false;
ut32 size = 0;
ut32 n1 = 0;
ut32 n2 = 0;

ret = RZ_NEW0(pyc_object);
if (!ret) {
return NULL;
}

if ((pyc->magic_int & 0xffff) <= 62061) {
n1 = get_ut8(buffer, &error);
} else {
n1 = get_st32(buffer, &error);
}
if (error) {
free(ret);
return NULL;
}
ut8 *s1 = malloc(n1 + 1);
if (!s1) {
return NULL;
}

size = rz_buf_read(buffer, s1, n1);
if (size != n1) {
RZ_FREE(s1);
RZ_FREE(ret);
return NULL;
}
s1[n1] = '\0';

if ((pyc->magic_int & 0xffff) <= 62061) {
n2 = get_ut8(buffer, &error);
} else
n2 = get_st32(buffer, &error);
if (error) {
return NULL;
}
ut8 *s2 = malloc(n2 + 1);
if (!s2) {
return NULL;
}

size = rz_buf_read(buffer, s2, n2);
if (size != n2) {
RZ_FREE(s1);
RZ_FREE(s2);
RZ_FREE(ret);
return NULL;
}
s2[n2] = '\0';

ret->type = TYPE_COMPLEX;
ret->data = rz_str_newf(""%s+%sj"", s1, s2);
RZ_FREE(s1);
RZ_FREE(s2);
if (!ret->data) {
RZ_FREE(ret);
return NULL;
}
return ret;
}","[4, 18, 27, 28, 37, 39, 47, 48]","Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch."
207627," check_interlace_type(int PNG_CONST interlace_type)
 check_interlace_type(int const interlace_type)
  {
     
     if (interlace_type != PNG_INTERLACE_NONE)
     {
         
       fprintf(stderr, ""pngvalid: no interlace support\n"");
 
        exit(99);
     }
  }","[2, 4]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
197890," int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned char **in, long len,
                      const ASN1_ITEM *it,
                      int tag, int aclass, char opt, ASN1_TLC *ctx)
 {
     const ASN1_TEMPLATE *tt, *errtt = NULL;
     const ASN1_COMPAT_FUNCS *cf;
     const ASN1_EXTERN_FUNCS *ef;
     const ASN1_AUX *aux = it->funcs;
     ASN1_aux_cb *asn1_cb;
     const unsigned char *p = NULL, *q;
     unsigned char *wp = NULL;    
     unsigned char imphack = 0, oclass;
     char seq_eoc, seq_nolen, cst, isopt;
     long tmplen;
     int i;
      int otag;
      int ret = 0;
      ASN1_VALUE **pchptr, *ptmpval;
     int combine = aclass & ASN1_TFLG_COMBINE;
     aclass &= ~ASN1_TFLG_COMBINE;
      if (!pval)
          return 0;
      if (aux && aux->asn1_cb)
         asn1_cb = 0;
 
     switch (it->itype) {
     case ASN1_ITYPE_PRIMITIVE:
         if (it->templates) {
              
             if ((tag != -1) || opt) {
                 ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
                         ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
                 goto err;
             }
             return asn1_template_ex_d2i(pval, in, len,
                                         it->templates, opt, ctx);
         }
         return asn1_d2i_ex_primitive(pval, in, len, it,
                                      tag, aclass, opt, ctx);
         break;
 
     case ASN1_ITYPE_MSTRING:
         p = *in;
          
         ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
                               &p, len, -1, 0, 1, ctx);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
          
         if (oclass != V_ASN1_UNIVERSAL) {
              
             if (opt)
                 return -1;
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
             goto err;
         }
          
         if (!(ASN1_tag2bit(otag) & it->utype)) {
              
             if (opt)
                 return -1;
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
             goto err;
         }
         return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);
 
     case ASN1_ITYPE_EXTERN:
          
         ef = it->funcs;
         return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);
 
     case ASN1_ITYPE_COMPAT:
          
         cf = it->funcs;
 
          
         if (opt) {
             int exptag;
             p = *in;
             if (tag == -1)
                 exptag = it->utype;
             else
                 exptag = tag;
              
 
             ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
                                   &p, len, exptag, aclass, 1, ctx);
             if (!ret) {
                 ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                 goto err;
             }
             if (ret == -1)
                 return -1;
         }
 
          
 
         if (tag != -1) {
             wp = *(unsigned char **)in;
             imphack = *wp;
             if (p == NULL) {
                 ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
                 goto err;
             }
             *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
                                   | it->utype);
         }
 
         ptmpval = cf->asn1_d2i(pval, in, len);
 
         if (tag != -1)
             *wp = imphack;
 
         if (ptmpval)
             return 1;
 
         ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
         goto err;
 
     case ASN1_ITYPE_CHOICE:
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
         if (*pval) {
              
             i = asn1_get_choice_selector(pval, it);
             if ((i >= 0) && (i < it->tcount)) {
                 tt = it->templates + i;
                 pchptr = asn1_get_field_ptr(pval, tt);
                 ASN1_template_free(pchptr, tt);
                 asn1_set_choice_selector(pval, -1, it);
             }
         } else if (!ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
          
         p = *in;
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             pchptr = asn1_get_field_ptr(pval, tt);
              
             ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
              
             if (ret == -1)
                 continue;
              
             if (ret > 0)
                 break;
              
             errtt = tt;
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
          
         if (i == it->tcount) {
              
             if (opt) {
                  
                 ASN1_item_ex_free(pval, it);
                 return -1;
             }
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
             goto err;
         }
 
         asn1_set_choice_selector(pval, i, it);
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
             goto auxerr;
         *in = p;
         return 1;
 
     case ASN1_ITYPE_NDEF_SEQUENCE:
     case ASN1_ITYPE_SEQUENCE:
         p = *in;
         tmplen = len;
 
          
         if (tag == -1) {
             tag = V_ASN1_SEQUENCE;
             aclass = V_ASN1_UNIVERSAL;
         }
          
         ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
                               &p, len, tag, aclass, opt, ctx);
         if (!ret) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         } else if (ret == -1)
             return -1;
         if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
             len = tmplen - (p - *in);
             seq_nolen = 1;
         }
          
         else
             seq_nolen = seq_eoc;
         if (!cst) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
             goto err;
         }
 
         if (!*pval && !ASN1_item_ex_new(pval, it)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
             goto err;
         }
 
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
             goto auxerr;
 
          
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             if (tt->flags & ASN1_TFLG_ADB_MASK) {
                 const ASN1_TEMPLATE *seqtt;
                 ASN1_VALUE **pseqval;
                 seqtt = asn1_do_adb(pval, tt, 1);
                 pseqval = asn1_get_field_ptr(pval, seqtt);
                 ASN1_template_free(pseqval, seqtt);
             }
         }
 
          
         for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
             const ASN1_TEMPLATE *seqtt;
             ASN1_VALUE **pseqval;
             seqtt = asn1_do_adb(pval, tt, 1);
             if (!seqtt)
                 goto err;
             pseqval = asn1_get_field_ptr(pval, seqtt);
              
             if (!len)
                 break;
             q = p;
             if (asn1_check_eoc(&p, len)) {
                 if (!seq_eoc) {
                     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
                     goto err;
                 }
                 len -= p - q;
                 seq_eoc = 0;
                 q = p;
                 break;
             }
              
             if (i == (it->tcount - 1))
                 isopt = 0;
             else
                 isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
              
 
             ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
             if (!ret) {
                 errtt = seqtt;
                 goto err;
             } else if (ret == -1) {
                  
                 ASN1_template_free(pseqval, seqtt);
                 continue;
             }
              
             len -= p - q;
         }
 
          
         if (seq_eoc && !asn1_check_eoc(&p, len)) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
             goto err;
         }
          
         if (!seq_nolen && len) {
             ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
             goto err;
         }
 
          
         for (; i < it->tcount; tt++, i++) {
             const ASN1_TEMPLATE *seqtt;
             seqtt = asn1_do_adb(pval, tt, 1);
             if (!seqtt)
                 goto err;
             if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
                 ASN1_VALUE **pseqval;
                 pseqval = asn1_get_field_ptr(pval, seqtt);
                 ASN1_template_free(pseqval, seqtt);
             } else {
                 errtt = seqtt;
                 ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
                 goto err;
             }
         }
          
         if (!asn1_enc_save(pval, *in, p - *in, it))
             goto auxerr;
         if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
             goto auxerr;
         *in = p;
         return 1;
 
     default:
         return 0;
     }
  auxerr:
     ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
   auxerr:
      ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
   err:
    ASN1_item_ex_free(pval, it);
     if (combine == 0)
         ASN1_item_ex_free(pval, it);
      if (errtt)
          ERR_add_error_data(4, ""Field="", errtt->field_name,
                             "", Type="", it->sname);
 }","[19, 20, 310, 311, 309]","The ASN1_TFLG_COMBINE implementation in crypto/asn1/tasn_dec.c in OpenSSL before 0.9.8zh, 1.0.0 before 1.0.0t, 1.0.1 before 1.0.1q, and 1.0.2 before 1.0.2e mishandles errors caused by malformed X509_ATTRIBUTE data, which allows remote attackers to obtain sensitive information from process memory by triggering a decoding failure in a PKCS#7 or CMS application."
198828," xfs_acl_from_disk(struct xfs_acl *aclp)
 {
 	struct posix_acl_entry *acl_e;
 	struct posix_acl *acl;
 	struct xfs_acl_entry *ace;
  	int count, i;
  
  	count = be32_to_cpu(aclp->acl_cnt);
 	if (count > XFS_ACL_MAX_ENTRIES)
 		return ERR_PTR(-EFSCORRUPTED);
  
  	acl = posix_acl_alloc(count, GFP_KERNEL);
  	if (!acl)
 		return ERR_PTR(-ENOMEM);
 
 	for (i = 0; i < count; i++) {
 		acl_e = &acl->a_entries[i];
 		ace = &aclp->acl_entry[i];
 
 		 
 		acl_e->e_tag = be32_to_cpu(ace->ae_tag);
 		acl_e->e_perm = be16_to_cpu(ace->ae_perm);
 
 		switch (acl_e->e_tag) {
 		case ACL_USER:
 		case ACL_GROUP:
 			acl_e->e_id = be32_to_cpu(ace->ae_id);
 			break;
 		case ACL_USER_OBJ:
 		case ACL_GROUP_OBJ:
 		case ACL_MASK:
 		case ACL_OTHER:
 			acl_e->e_id = ACL_UNDEFINED_ID;
 			break;
 		default:
 			goto fail;
 		}
 	}
 	return acl;
 
 fail:
 	posix_acl_release(acl);
 	return ERR_PTR(-EINVAL);
 }","[9, 10]","Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow."
204061," static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod5(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestObj::s_info))
         return throwVMTypeError(exec);
     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
      TestObj* impl = static_cast<TestObj*>(castedThis->impl());
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
          setDOMException(exec, TYPE_MISMATCH_ERR);
          return JSValue::encode(jsUndefined());
     }
     RefPtr<TestCallback> callback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());
     impl->overloadedMethod(callback);
     return JSValue::encode(jsUndefined());
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
207548," status_t OMXNodeInstance::emptyBuffer(
         OMX::buffer_id buffer,
         OMX_U32 rangeOffset, OMX_U32 rangeLength,
 
          OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
      Mutex::Autolock autoLock(mLock);
  
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, kPortIndexInput);
     if (header == NULL) {
         return BAD_VALUE;
     }
      BufferMeta *buffer_meta =
          static_cast<BufferMeta *>(header->pAppPrivate);
      sp<ABuffer> backup = buffer_meta->getBuffer(header, true  , false  );
     sp<ABuffer> codec = buffer_meta->getBuffer(header, false  , false  );
 
  if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource
  && backup->capacity() >= sizeof(VideoNativeMetadata)
  && codec->capacity() >= sizeof(VideoGrallocMetadata)
  && ((VideoNativeMetadata *)backup->base())->eType
  == kMetadataBufferTypeANWBuffer) {
  VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();
  VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();
         CLOG_BUFFER(emptyBuffer, ""converting ANWB %p to handle %p"",
                 backupMeta.pBuffer, backupMeta.pBuffer->handle);
         codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;
         codecMeta.eType = kMetadataBufferTypeGrallocSource;
         header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;
         header->nOffset = 0;
  } else {
  if (rangeOffset > header->nAllocLen
  || rangeLength > header->nAllocLen - rangeOffset) {
             CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));
  if (fenceFd >= 0) {
  ::close(fenceFd);
  }
  return BAD_VALUE;
  }
         header->nFilledLen = rangeLength;
         header->nOffset = rangeOffset;
 
         buffer_meta->CopyToOMX(header);
  }
 
  return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);
 }","[9, 10, 11, 12, 8]","omx/OMXNodeInstance.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 does not validate the buffer port, which allows attackers to gain privileges via a crafted application, aka internal bug 28816827."
206574,"  void AcceleratedStaticBitmapImage::Transfer() {
  CheckThread();
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
    EnsureMailbox(kVerifiedSyncToken, GL_NEAREST);
  detach_thread_at_next_check_ = true;
   DETACH_FROM_THREAD(thread_checker_);
  }","[3, 6, 2, 5]","Incorrect, thread-unsafe use of SkImage in Canvas in Google Chrome prior to 71.0.3578.80 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page."
9437,"void rose_start_hbtimer(struct sock *sk)
{
struct rose_sock *rose = rose_sk(sk);

del_timer(&rose->timer);

rose->timer.function = rose_timer_expiry;
rose->timer.expires  = jiffies + rose->hb;

add_timer(&rose->timer);
}","[5, 10]",There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.
203114," int read_image_tga( gdIOCtx *ctx, oTga *tga )
 {
 	int pixel_block_size = (tga->bits / 8);
 	int image_block_size = (tga->width * tga->height) * pixel_block_size;
 	uint8_t* decompression_buffer = NULL;
 	unsigned char* conversion_buffer = NULL;
 	int buffer_caret = 0;
 	int bitmap_caret = 0;
 	int i = 0;
 	int j = 0;
 	uint8_t encoded_pixels;
 
 	if(overflow2(tga->width, tga->height)) {
 		return -1;
 	}
 
 	if(overflow2(tga->width * tga->height, pixel_block_size)) {
 		return -1;
 	}
 
 	if(overflow2(image_block_size, sizeof(int))) {
 		return -1;
 	}
 
 	 
 	if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE)
 		return -1;
 
 	 
 	tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int));
 	if (tga->bitmap == NULL)
 		return -1;
 
 	switch (tga->imagetype) {
 	case TGA_TYPE_RGB:
 		 
 		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
 		if (conversion_buffer == NULL) {
 			return -1;
 		}
 
 		if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
 			gd_error(""gd-tga: premature end of image data\n"");
 			gdFree(conversion_buffer);
 			return -1;
 		}
 
 		while (buffer_caret < image_block_size) {
 			tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret];
 			buffer_caret++;
 		}
 
 		gdFree(conversion_buffer);
 		break;
 
 	case TGA_TYPE_RGB_RLE:
 		 
 		decompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));
 		if (decompression_buffer == NULL) {
 			return -1;
 		}
 		conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char));
 		if (conversion_buffer == NULL) {
 			gd_error(""gd-tga: premature end of image data\n"");
 			gdFree( decompression_buffer );
 			return -1;
 		}
 
 		if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
 			gdFree(conversion_buffer);
 			gdFree(decompression_buffer);
 			return -1;
 		}
 
 		buffer_caret = 0;
 
 		while( buffer_caret < image_block_size) {
 			decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
 			buffer_caret++;
 		}
 
  		buffer_caret = 0;
  
  		while( bitmap_caret < image_block_size ) {
 			
  			if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {
  				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );
  				buffer_caret++;
  
				for (i = 0; i < encoded_pixels; i++) {
					for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {
						tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
 				if (encoded_pixels != 0) {
 				
 					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
 						gdFree( decompression_buffer );
 						gdFree( conversion_buffer );
 						return -1;
 					}
 
 					for (i = 0; i < encoded_pixels; i++) {
 						for (j = 0; j < pixel_block_size; j++, bitmap_caret++) {
 							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
 						}
  					}
  				}
  				buffer_caret += pixel_block_size;
  			} else {
  				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
  				buffer_caret++;
  
				for (i = 0; i < encoded_pixels; i++) {
					for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {
						tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
 				if (encoded_pixels != 0) {
 				
 					if (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {
 						gdFree( decompression_buffer );
 						gdFree( conversion_buffer );
 						return -1;
 					}
 
 					for (i = 0; i < encoded_pixels; i++) {
 						for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {
 							tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];
 						}
 						buffer_caret += pixel_block_size;
  					}
					buffer_caret += pixel_block_size;
  				}
  			}
  		}
 		gdFree( decompression_buffer );
 		gdFree( conversion_buffer );
 		break;
 	}
 
 	return 1;
 }","[85, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 90, 91, 92, 112, 113, 114, 129]",The read_image_tga function in gd_tga.c in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA image.
201785," static Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,
   char *text,ExceptionInfo *exception)
 {
   char
     filename[MaxTextExtent],
     geometry[MaxTextExtent],
     *p;
 
   DrawInfo
     *draw_info;
 
   Image
     *texture;
 
   MagickBooleanType
     status;
 
   PointInfo
     delta;
 
   RectangleInfo
     page;
 
   ssize_t
     offset;
 
   TypeMetric
     metrics;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
    
   delta.x=DefaultResolution;
   delta.y=DefaultResolution;
   if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))
     {
       GeometryInfo
         geometry_info;
 
       MagickStatusType
         flags;
 
       flags=ParseGeometry(PSDensityGeometry,&geometry_info);
       image->x_resolution=geometry_info.rho;
       image->y_resolution=geometry_info.sigma;
       if ((flags & SigmaValue) == 0)
         image->y_resolution=image->x_resolution;
     }
   page.width=612;
   page.height=792;
   page.x=43;
   page.y=43;
   if (image_info->page != (char *) NULL)
     (void) ParseAbsoluteGeometry(image_info->page,&page);
    
   image->columns=(size_t) floor((((double) page.width*image->x_resolution)/
      delta.x)+0.5);
    image->rows=(size_t) floor((((double) page.height*image->y_resolution)/
      delta.y)+0.5);
   status=SetImageExtent(image,image->columns,image->rows);
   if (status == MagickFalse)
     {
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
    image->page.x=0;
    image->page.y=0;
    texture=(Image *) NULL;
   if (image_info->texture != (char *) NULL)
     {
       ImageInfo
         *read_info;
 
       read_info=CloneImageInfo(image_info);
       SetImageInfoBlob(read_info,(void *) NULL,0);
       (void) CopyMagickString(read_info->filename,image_info->texture,
         MaxTextExtent);
       texture=ReadImage(read_info,exception);
       read_info=DestroyImageInfo(read_info);
     }
    
   (void) SetImageBackgroundColor(image);
   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
   (void) CloneString(&draw_info->text,image_info->filename);
   (void) FormatLocaleString(geometry,MaxTextExtent,""0x0%+ld%+ld"",(long) page.x,
     (long) page.y);
   (void) CloneString(&draw_info->geometry,geometry);
   status=GetTypeMetrics(image,draw_info,&metrics);
   if (status == MagickFalse)
     ThrowReaderException(TypeError,""UnableToGetTypeMetrics"");
   page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);
   (void) FormatLocaleString(geometry,MaxTextExtent,""0x0%+ld%+ld"",(long) page.x,
     (long) page.y);
   (void) CloneString(&draw_info->geometry,geometry);
   (void) CopyMagickString(filename,image_info->filename,MaxTextExtent);
   if (*draw_info->text != '\0')
     *draw_info->text='\0';
   p=text;
   for (offset=2*page.y; p != (char *) NULL; )
   {
      
     (void) ConcatenateString(&draw_info->text,text);
     (void) ConcatenateString(&draw_info->text,""\n"");
     offset+=(ssize_t) (metrics.ascent-metrics.descent);
     if (image->previous == (Image *) NULL)
       {
         status=SetImageProgress(image,LoadImageTag,offset,image->rows);
         if (status == MagickFalse)
           break;
       }
     p=ReadBlobString(image,text);
     if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))
       continue;
     if (texture != (Image *) NULL)
       {
         MagickProgressMonitor
           progress_monitor;
 
         progress_monitor=SetImageProgressMonitor(image,
           (MagickProgressMonitor) NULL,image->client_data);
         (void) TextureImage(image,texture);
         (void) SetImageProgressMonitor(image,progress_monitor,
           image->client_data);
       }
     (void) AnnotateImage(image,draw_info);
     if (p == (char *) NULL)
       break;
      
     *draw_info->text='\0';
     offset=2*page.y;
     AcquireNextImage(image_info,image);
     if (GetNextImageInList(image) == (Image *) NULL)
       {
         image=DestroyImageList(image);
         return((Image *) NULL);
       }
     image->next->columns=image->columns;
     image->next->rows=image->rows;
     image=SyncNextImageInList(image);
     (void) CopyMagickString(image->filename,filename,MaxTextExtent);
     (void) SetImageBackgroundColor(image);
     status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
       GetBlobSize(image));
     if (status == MagickFalse)
       break;
   }
   if (texture != (Image *) NULL)
     {
       MagickProgressMonitor
         progress_monitor;
 
       progress_monitor=SetImageProgressMonitor(image,
         (MagickProgressMonitor) NULL,image->client_data);
       (void) TextureImage(image,texture);
       (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);
     }
   (void) AnnotateImage(image,draw_info);
   if (texture != (Image *) NULL)
     texture=DestroyImage(texture);
   draw_info=DestroyDrawInfo(draw_info);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[66, 67, 68, 69, 70, 71]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
207300," void ObjectBackedNativeHandler::RouteFunction(
     const std::string& name,
     const std::string& feature_name,
     const HandlerFunction& handler_function) {
   v8::Isolate* isolate = v8::Isolate::GetCurrent();
   v8::HandleScope handle_scope(isolate);
   v8::Context::Scope context_scope(context_->v8_context());
 
    v8::Local<v8::Object> data = v8::Object::New(isolate);
    SetPrivate(data, kHandlerFunction,
               v8::External::New(isolate, new HandlerFunction(handler_function)));
   DCHECK(feature_name.empty() ||
          ExtensionAPI::GetSharedInstance()->GetFeatureDependency(feature_name))
       << feature_name;
    SetPrivate(data, kFeatureName,
               v8_helpers::ToV8StringUnsafe(isolate, feature_name));
    v8::Local<v8::FunctionTemplate> function_template =
       v8::FunctionTemplate::New(isolate, Router, data);
   v8::Local<v8::ObjectTemplate>::New(isolate, object_template_)
       ->Set(isolate, name.c_str(), function_template);
   router_data_.Append(data);
 }","[12, 13, 14]",The extensions subsystem in Google Chrome before 51.0.2704.63 allows remote attackers to bypass the Same Origin Policy via unspecified vectors.
200421," static PrimitiveInfo *TraceStrokePolygon(const DrawInfo *draw_info,
   const PrimitiveInfo *primitive_info)
 {
   typedef struct _LineSegment
   {
     double
       p,
       q;
   } LineSegment;
 
   LineSegment
     dx,
     dy,
     inverse_slope,
     slope,
     theta;
 
   MagickBooleanType
     closed_path;
 
   double
     delta_theta,
     dot_product,
     mid,
     miterlimit;
 
   PointInfo
     box_p[5],
     box_q[5],
     center,
     offset,
     *path_p,
     *path_q;
 
   PrimitiveInfo
     *polygon_primitive,
     *stroke_polygon;
 
   register ssize_t
     i;
 
   size_t
     arc_segments,
     max_strokes,
     number_vertices;
 
   ssize_t
     j,
     n,
     p,
     q;
 
    
   number_vertices=primitive_info->coordinates;
   max_strokes=2*number_vertices+6*BezierQuantum+360;
   path_p=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
     sizeof(*path_p));
   path_q=(PointInfo *) AcquireQuantumMemory((size_t) max_strokes,
     sizeof(*path_q));
   polygon_primitive=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
     number_vertices+2UL,sizeof(*polygon_primitive));
   if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL) ||
       (polygon_primitive == (PrimitiveInfo *) NULL))
     return((PrimitiveInfo *) NULL);
   (void) CopyMagickMemory(polygon_primitive,primitive_info,(size_t)
     number_vertices*sizeof(*polygon_primitive));
   closed_path=
     (primitive_info[number_vertices-1].point.x == primitive_info[0].point.x) &&
     (primitive_info[number_vertices-1].point.y == primitive_info[0].point.y) ?
     MagickTrue : MagickFalse;
   if ((draw_info->linejoin == RoundJoin) ||
       ((draw_info->linejoin == MiterJoin) && (closed_path != MagickFalse)))
     {
       polygon_primitive[number_vertices]=primitive_info[1];
       number_vertices++;
     }
   polygon_primitive[number_vertices].primitive=UndefinedPrimitive;
    
   dx.p=0.0;
   dy.p=0.0;
   for (n=1; n < (ssize_t) number_vertices; n++)
   {
     dx.p=polygon_primitive[n].point.x-polygon_primitive[0].point.x;
     dy.p=polygon_primitive[n].point.y-polygon_primitive[0].point.y;
     if ((fabs(dx.p) >= MagickEpsilon) || (fabs(dy.p) >= MagickEpsilon))
       break;
   }
   if (n == (ssize_t) number_vertices)
     n=(ssize_t) number_vertices-1L;
   slope.p=DrawEpsilonReciprocal(dx.p)*dy.p;
   inverse_slope.p=(-1.0*DrawEpsilonReciprocal(slope.p));
   mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;
   miterlimit=(double) (draw_info->miterlimit*draw_info->miterlimit*
     mid*mid);
   if ((draw_info->linecap == SquareCap) && (closed_path == MagickFalse))
     TraceSquareLinecap(polygon_primitive,number_vertices,mid);
   offset.x=sqrt((double) (mid*mid/(inverse_slope.p*inverse_slope.p+1.0)));
   offset.y=(double) (offset.x*inverse_slope.p);
   if ((dy.p*offset.x-dx.p*offset.y) > 0.0)
     {
       box_p[0].x=polygon_primitive[0].point.x-offset.x;
       box_p[0].y=polygon_primitive[0].point.y-offset.x*inverse_slope.p;
       box_p[1].x=polygon_primitive[n].point.x-offset.x;
       box_p[1].y=polygon_primitive[n].point.y-offset.x*inverse_slope.p;
       box_q[0].x=polygon_primitive[0].point.x+offset.x;
       box_q[0].y=polygon_primitive[0].point.y+offset.x*inverse_slope.p;
       box_q[1].x=polygon_primitive[n].point.x+offset.x;
       box_q[1].y=polygon_primitive[n].point.y+offset.x*inverse_slope.p;
     }
   else
     {
       box_p[0].x=polygon_primitive[0].point.x+offset.x;
       box_p[0].y=polygon_primitive[0].point.y+offset.y;
       box_p[1].x=polygon_primitive[n].point.x+offset.x;
       box_p[1].y=polygon_primitive[n].point.y+offset.y;
       box_q[0].x=polygon_primitive[0].point.x-offset.x;
       box_q[0].y=polygon_primitive[0].point.y-offset.y;
       box_q[1].x=polygon_primitive[n].point.x-offset.x;
       box_q[1].y=polygon_primitive[n].point.y-offset.y;
     }
    
   p=0;
   q=0;
   path_q[p++]=box_q[0];
   path_p[q++]=box_p[0];
   for (i=(ssize_t) n+1; i < (ssize_t) number_vertices; i++)
   {
      
     dx.q=polygon_primitive[i].point.x-polygon_primitive[n].point.x;
     dy.q=polygon_primitive[i].point.y-polygon_primitive[n].point.y;
     dot_product=dx.q*dx.q+dy.q*dy.q;
     if (dot_product < 0.25)
       continue;
     slope.q=DrawEpsilonReciprocal(dx.q)*dy.q;
     inverse_slope.q=(-1.0*DrawEpsilonReciprocal(slope.q));
     offset.x=sqrt((double) (mid*mid/(inverse_slope.q*inverse_slope.q+1.0)));
     offset.y=(double) (offset.x*inverse_slope.q);
     dot_product=dy.q*offset.x-dx.q*offset.y;
     if (dot_product > 0.0)
       {
         box_p[2].x=polygon_primitive[n].point.x-offset.x;
         box_p[2].y=polygon_primitive[n].point.y-offset.y;
         box_p[3].x=polygon_primitive[i].point.x-offset.x;
         box_p[3].y=polygon_primitive[i].point.y-offset.y;
         box_q[2].x=polygon_primitive[n].point.x+offset.x;
         box_q[2].y=polygon_primitive[n].point.y+offset.y;
         box_q[3].x=polygon_primitive[i].point.x+offset.x;
         box_q[3].y=polygon_primitive[i].point.y+offset.y;
       }
     else
       {
         box_p[2].x=polygon_primitive[n].point.x+offset.x;
         box_p[2].y=polygon_primitive[n].point.y+offset.y;
         box_p[3].x=polygon_primitive[i].point.x+offset.x;
         box_p[3].y=polygon_primitive[i].point.y+offset.y;
         box_q[2].x=polygon_primitive[n].point.x-offset.x;
         box_q[2].y=polygon_primitive[n].point.y-offset.y;
         box_q[3].x=polygon_primitive[i].point.x-offset.x;
         box_q[3].y=polygon_primitive[i].point.y-offset.y;
       }
     if (fabs((double) (slope.p-slope.q)) < MagickEpsilon)
       {
         box_p[4]=box_p[1];
         box_q[4]=box_q[1];
       }
     else
       {
         box_p[4].x=(double) ((slope.p*box_p[0].x-box_p[0].y-slope.q*box_p[3].x+
           box_p[3].y)/(slope.p-slope.q));
         box_p[4].y=(double) (slope.p*(box_p[4].x-box_p[0].x)+box_p[0].y);
         box_q[4].x=(double) ((slope.p*box_q[0].x-box_q[0].y-slope.q*box_q[3].x+
           box_q[3].y)/(slope.p-slope.q));
         box_q[4].y=(double) (slope.p*(box_q[4].x-box_q[0].x)+box_q[0].y);
        }
      if (q >= (ssize_t) (max_strokes-6*BezierQuantum-360))
        {
         max_strokes+=6*BezierQuantum+360;
         path_p=(PointInfo *) ResizeQuantumMemory(path_p,(size_t) max_strokes,
           sizeof(*path_p));
         path_q=(PointInfo *) ResizeQuantumMemory(path_q,(size_t) max_strokes,
           sizeof(*path_q));
         if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL))
           {
             polygon_primitive=(PrimitiveInfo *)
               RelinquishMagickMemory(polygon_primitive);
             return((PrimitiveInfo *) NULL);
           }
         if (~max_strokes < (6*BezierQuantum+360))
           {
             path_p=(PointInfo *) RelinquishMagickMemory(path_p);
             path_q=(PointInfo *) RelinquishMagickMemory(path_q);
           }
         else
           {
             max_strokes+=6*BezierQuantum+360;
             path_p=(PointInfo *) ResizeQuantumMemory(path_p,max_strokes,
               sizeof(*path_p));
             path_q=(PointInfo *) ResizeQuantumMemory(path_q,max_strokes,
               sizeof(*path_q));
           }
         if ((path_p == (PointInfo *) NULL) || (path_q == (PointInfo *) NULL))
           {
             if (path_p != (PointInfo *) NULL)
               path_p=(PointInfo *) RelinquishMagickMemory(path_p);
             if (path_q != (PointInfo *) NULL)
               path_q=(PointInfo *) RelinquishMagickMemory(path_q);
             polygon_primitive=(PrimitiveInfo *)
               RelinquishMagickMemory(polygon_primitive);
             return((PrimitiveInfo *) NULL);
           }
        }
      dot_product=dx.q*dy.p-dx.p*dy.q;
      if (dot_product <= 0.0)
       switch (draw_info->linejoin)
       {
         case BevelJoin:
         {
           path_q[q++]=box_q[1];
           path_q[q++]=box_q[2];
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_p[p++]=box_p[4];
           else
             {
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case MiterJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             {
               path_q[q++]=box_q[4];
               path_p[p++]=box_p[4];
             }
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case RoundJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_p[p++]=box_p[4];
           else
             {
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           center=polygon_primitive[n].point;
           theta.p=atan2(box_q[1].y-center.y,box_q[1].x-center.x);
           theta.q=atan2(box_q[2].y-center.y,box_q[2].x-center.x);
           if (theta.q < theta.p)
             theta.q+=(double) (2.0*MagickPI);
           arc_segments=(size_t) ceil((double) ((theta.q-theta.p)/
             (2.0*sqrt((double) (1.0/mid)))));
           path_q[q].x=box_q[1].x;
           path_q[q].y=box_q[1].y;
           q++;
           for (j=1; j < (ssize_t) arc_segments; j++)
           {
             delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);
             path_q[q].x=(double) (center.x+mid*cos(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             path_q[q].y=(double) (center.y+mid*sin(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             q++;
           }
           path_q[q++]=box_q[2];
           break;
         }
         default:
           break;
       }
     else
       switch (draw_info->linejoin)
       {
         case BevelJoin:
         {
           path_p[p++]=box_p[1];
           path_p[p++]=box_p[2];
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_q[q++]=box_q[4];
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
             }
           break;
         }
         case MiterJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             {
               path_q[q++]=box_q[4];
               path_p[p++]=box_p[4];
             }
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
               path_p[p++]=box_p[1];
               path_p[p++]=box_p[2];
             }
           break;
         }
         case RoundJoin:
         {
           dot_product=(box_q[4].x-box_p[4].x)*(box_q[4].x-box_p[4].x)+
             (box_q[4].y-box_p[4].y)*(box_q[4].y-box_p[4].y);
           if (dot_product <= miterlimit)
             path_q[q++]=box_q[4];
           else
             {
               path_q[q++]=box_q[1];
               path_q[q++]=box_q[2];
             }
           center=polygon_primitive[n].point;
           theta.p=atan2(box_p[1].y-center.y,box_p[1].x-center.x);
           theta.q=atan2(box_p[2].y-center.y,box_p[2].x-center.x);
           if (theta.p < theta.q)
             theta.p+=(double) (2.0*MagickPI);
           arc_segments=(size_t) ceil((double) ((theta.p-theta.q)/
             (2.0*sqrt((double) (1.0/mid)))));
           path_p[p++]=box_p[1];
           for (j=1; j < (ssize_t) arc_segments; j++)
           {
             delta_theta=(double) (j*(theta.q-theta.p)/arc_segments);
             path_p[p].x=(double) (center.x+mid*cos(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             path_p[p].y=(double) (center.y+mid*sin(fmod((double)
               (theta.p+delta_theta),DegreesToRadians(360.0))));
             p++;
           }
           path_p[p++]=box_p[2];
           break;
         }
         default:
           break;
       }
     slope.p=slope.q;
     inverse_slope.p=inverse_slope.q;
     box_p[0]=box_p[2];
     box_p[1]=box_p[3];
     box_q[0]=box_q[2];
     box_q[1]=box_q[3];
     dx.p=dx.q;
     dy.p=dy.q;
     n=i;
   }
   path_p[p++]=box_p[1];
   path_q[q++]=box_q[1];
    
   stroke_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
     (p+q+2UL*closed_path+2UL),sizeof(*stroke_polygon));
   if (stroke_polygon != (PrimitiveInfo *) NULL)
     {
       for (i=0; i < (ssize_t) p; i++)
       {
         stroke_polygon[i]=polygon_primitive[0];
         stroke_polygon[i].point=path_p[i];
       }
       if (closed_path != MagickFalse)
         {
           stroke_polygon[i]=polygon_primitive[0];
           stroke_polygon[i].point=stroke_polygon[0].point;
           i++;
         }
       for ( ; i < (ssize_t) (p+q+closed_path); i++)
       {
         stroke_polygon[i]=polygon_primitive[0];
         stroke_polygon[i].point=path_q[p+q+closed_path-(i+1)];
       }
       if (closed_path != MagickFalse)
         {
           stroke_polygon[i]=polygon_primitive[0];
           stroke_polygon[i].point=stroke_polygon[p+closed_path].point;
           i++;
         }
       stroke_polygon[i]=polygon_primitive[0];
       stroke_polygon[i].point=stroke_polygon[0].point;
       i++;
       stroke_polygon[i].primitive=UndefinedPrimitive;
       stroke_polygon[0].coordinates=(size_t) (p+q+2*closed_path+1);
     }
   path_p=(PointInfo *) RelinquishMagickMemory(path_p);
   path_q=(PointInfo *) RelinquishMagickMemory(path_q);
   polygon_primitive=(PrimitiveInfo *) RelinquishMagickMemory(polygon_primitive);
   return(stroke_polygon);
 }","[188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187]","The DrawImage function in MagickCore/draw.c in ImageMagick before 6.9.4-0 and 7.x before 7.0.1-2 makes an incorrect function call in attempting to locate the next token, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted file."
6306,"ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)
{
ngx_table_elt_t                 *header;
ngx_list_part_t                 *part;
ngx_uint_t                       i;

if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,
sizeof(ngx_table_elt_t)) != NGX_OK)
{
return NGX_ERROR;
}

dd(""before: parent req headers count: %d"",
(int) r->headers_in.headers.part.nelts);

part = &r->headers_in.headers.part;
header = part->elts;

for (i = 0;           ; i++) {

if (i >= part->nelts) {
if (part->next == NULL) {
break;
}

part = part->next;
header = part->elts;
i = 0;
}

dd(""setting request header %.*s: %.*s"", (int) header[i].key.len,
header[i].key.data, (int) header[i].value.len,
header[i].value.data);

if (ngx_http_lua_set_input_header(sr, header[i].key,
header[i].value, 0) == NGX_ERROR)
{
return NGX_ERROR;
}
}

dd(""after: parent req headers count: %d"",
(int) r->headers_in.headers.part.nelts);

return NGX_OK;
}","[3, 7, 13, 14, 16, 31, 43]","An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API."
206194,"   void DiscardTest(DiscardReason reason) {
     const base::TimeTicks kDummyLastActiveTime =
         base::TimeTicks() + kShortDelay;
 
     LifecycleUnit* background_lifecycle_unit = nullptr;
     LifecycleUnit* foreground_lifecycle_unit = nullptr;
     CreateTwoTabs(true  , &background_lifecycle_unit,
                   &foreground_lifecycle_unit);
     content::WebContents* initial_web_contents =
         tab_strip_model_->GetWebContentsAt(0);
     content::WebContentsTester::For(initial_web_contents)
         ->SetLastActiveTime(kDummyLastActiveTime);
 
      EXPECT_EQ(LifecycleUnitState::ACTIVE,
                background_lifecycle_unit->GetState());
    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));
     EXPECT_CALL(tab_observer_, OnDiscardedStateChange(::testing::_, true));
      background_lifecycle_unit->Discard(reason);
    testing::Mock::VerifyAndClear(&tab_observer_);
     ::testing::Mock::VerifyAndClear(&tab_observer_);
  
      TransitionFromPendingDiscardToDiscardedIfNeeded(reason,
                                                     background_lifecycle_unit);
 
     EXPECT_NE(initial_web_contents, tab_strip_model_->GetWebContentsAt(0));
     EXPECT_FALSE(tab_strip_model_->GetWebContentsAt(0)
                      ->GetController()
                      .GetPendingEntry());
     EXPECT_EQ(kDummyLastActiveTime,
               tab_strip_model_->GetWebContentsAt(0)->GetLastActiveTime());
 
     source_->SetFocusedTabStripModelForTesting(nullptr);
   }","[17, 20, 16, 19]","Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects."
207684," make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
 make_errors(png_modifier* const pm, png_byte const colour_type,
     int bdlo, int const bdhi)
  {
     for (; bdlo <= bdhi; ++bdlo)
     {
  int interlace_type;
 
  for (interlace_type = PNG_INTERLACE_NONE;
            interlace_type < INTERLACE_LAST; ++interlace_type)
  {
  unsigned int test;
 
           char name[FILE_NAME_SIZE];
  
           standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,
            interlace_type, 0, 0, 0);
             interlace_type, 0, 0, do_own_interlace);
  
         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)
          for (test=0; test<ARRAY_SIZE(error_test); ++test)
           {
              make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,
                 test, name);
 
  if (fail(pm))
  return 0;
  }
  }
  }
 
  return 1;  
 }","[3, 4, 19, 22, 2, 18, 21]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205928," GaiaCookieManagerService::ExternalCcResultFetcher::CreateFetcher(
     const GURL& url) {
   std::unique_ptr<net::URLFetcher> fetcher =
       net::URLFetcher::Create(0, url, net::URLFetcher::GET, this);
    fetcher->SetRequestContext(helper_->request_context());
    fetcher->SetLoadFlags(net::LOAD_DO_NOT_SEND_COOKIES |
                          net::LOAD_DO_NOT_SAVE_COOKIES);
   data_use_measurement::DataUseUserData::AttachToFetcher(
       fetcher.get(), data_use_measurement::DataUseUserData::SIGNIN);
  
   fetcher->SetAutomaticallyRetryOnNetworkChanges(1);
   return fetcher;
 }","[8, 9]","Integer overflow in the SkAutoSTArray implementation in include/core/SkTemplates.h in the filters implementation in Skia, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a reset action with a large count value, leading to an out-of-bounds write operation."
204389," v8::Handle<v8::Value> AppWindowCustomBindings::GetView(
     const v8::Arguments& args) {
   if (args.Length() != 1)
     return v8::Undefined();
 
   if (!args[0]->IsInt32())
     return v8::Undefined();
 
   int view_id = args[0]->Int32Value();
 
   if (view_id == MSG_ROUTING_NONE)
     return v8::Undefined();
 
   FindViewByID view_finder(view_id);
   content::RenderView::ForEach(&view_finder);
   content::RenderView* view = view_finder.view();
   if (!view)
     return v8::Undefined();
 
   content::RenderView* render_view = GetCurrentRenderView();
   if (!render_view)
     return v8::Undefined();
    WebKit::WebFrame* opener = render_view->GetWebView()->mainFrame();
    WebKit::WebFrame* frame = view->GetWebView()->mainFrame();
    frame->setOpener(opener);
   content::RenderThread::Get()->Send(
       new ExtensionHostMsg_ResumeRequests(view->GetRoutingID()));
  
    v8::Local<v8::Value> window = frame->mainWorldScriptContext()->Global();
    return window;
 }","[26, 27]",Use-after-free vulnerability in the PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted document.
9800,"static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)
{
struct pfkey_sock *pfk = pfkey_sk(sk);
struct sk_buff *supp_skb;

if (hdr->sadb_msg_satype > SADB_SATYPE_MAX)
return -EINVAL;

if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {
if (pfk->registered&(1<<hdr->sadb_msg_satype))
return -EEXIST;
pfk->registered |= (1<<hdr->sadb_msg_satype);
}

xfrm_probe_algs();

supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);
if (!supp_skb) {
if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)
pfk->registered &= ~(1<<hdr->sadb_msg_satype);

return -ENOBUFS;
}

pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,
sock_net(sk));
return 0;
}","[15, 18]",A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.
8103,"AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)
{
core_server_config *conf = ap_get_core_module_config(r->server->module_config);
const char *host_header = apr_table_get(r->headers_in, ""Host"");
int is_v6literal = 0;
int have_hostname_from_url = 0;

if (r->hostname) {




have_hostname_from_url = 1;
is_v6literal = fix_hostname(r, NULL, conf->http_conformance);
}
else if (host_header != NULL) {
is_v6literal = fix_hostname(r, host_header, conf->http_conformance);
}
if (r->status != HTTP_OK)
return;

if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {






if (have_hostname_from_url && host_header != NULL) {
const char *repl = construct_host_header(r, is_v6literal);
apr_table_setn(r->headers_in, ""Host"", repl);
ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)
""Replacing host header '%s' with host '%s' given ""
""in the request uri"", host_header, repl);
}
}


if (r->connection->vhost_lookup_data) {
if (r->hostname)
check_hostalias(r);
else
check_serverpath(r);
}
}","[8, 19, 20, 41, 43]","A crafted method sent through HTTP/2 will bypass validation and be forwarded by mod_proxy, which can lead to request splitting or cache poisoning. This issue affects Apache HTTP Server 2.4.17 to 2.4.48."
5955,"static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)
{
struct rtl8xxxu_priv *priv = hw->priv;
struct urb *urb;
u32 val32;
int ret;

urb = usb_alloc_urb(0, GFP_KERNEL);
if (!urb)
return -ENOMEM;

usb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,
priv->int_buf, USB_INTR_CONTENT_LENGTH,
rtl8xxxu_int_complete, priv, 1);
usb_anchor_urb(urb, &priv->int_anchor);
ret = usb_submit_urb(urb, GFP_KERNEL);
if (ret) {
usb_unanchor_urb(urb);
goto error;
}

val32 = rtl8xxxu_read32(priv, REG_USB_HIMR);
val32 |= USB_HIMR_CPWM;
rtl8xxxu_write32(priv, REG_USB_HIMR, val32);

error:
return ret;
}",[19],"A memory leak in the rtl8xxxu_submit_int_urb() function in drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-a2cdd07488e6."
202035," static Image *ReadICONImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   IconFile
     icon_file;
 
   IconInfo
     icon_info;
 
   Image
     *image;
 
   MagickBooleanType
     status;
 
   register ssize_t
     i,
     x;
 
   register Quantum
     *q;
 
   register unsigned char
     *p;
 
   size_t
     bit,
     byte,
     bytes_per_line,
     one,
     scanline_pad;
 
   ssize_t
     count,
     offset,
     y;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   (void) LogMagickEvent(CoderEvent,GetMagickModule(),""%s"",image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   icon_file.reserved=(short) ReadBlobLSBShort(image);
   icon_file.resource_type=(short) ReadBlobLSBShort(image);
   icon_file.count=(short) ReadBlobLSBShort(image);
   if ((icon_file.reserved != 0) ||
       ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||
       (icon_file.count > MaxIcons))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   for (i=0; i < icon_file.count; i++)
   {
     icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);
     icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);
     icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);
     icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);
     icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);
     icon_file.directory[i].bits_per_pixel=(unsigned short)
       ReadBlobLSBShort(image);
     icon_file.directory[i].size=ReadBlobLSBLong(image);
     icon_file.directory[i].offset=ReadBlobLSBLong(image);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
   }
   one=1;
   for (i=0; i < icon_file.count; i++)
   {
      
     offset=(ssize_t) SeekBlob(image,(MagickOffsetType)
       icon_file.directory[i].offset,SEEK_SET);
     if (offset < 0)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     icon_info.size=ReadBlobLSBLong(image);
     icon_info.width=(unsigned char) ((int) ReadBlobLSBLong(image));
     icon_info.height=(unsigned char) ((int) ReadBlobLSBLong(image)/2);
     icon_info.planes=ReadBlobLSBShort(image);
     icon_info.bits_per_pixel=ReadBlobLSBShort(image);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
           image->filename);
         break;
       }
     if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || 
         (icon_info.size == 0x474e5089))
       {
         Image
           *icon_image;
 
         ImageInfo
           *read_info;
 
         size_t
           length;
 
         unsigned char
           *png;
 
          
          length=icon_file.directory[i].size;
         if (~length < 16)
           ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));
          if (png == (unsigned char *) NULL)
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         (void) CopyMagickMemory(png,""\211PNG\r\n\032\n\000\000\000\015"",12);
         png[12]=(unsigned char) icon_info.planes;
         png[13]=(unsigned char) (icon_info.planes >> 8);
         png[14]=(unsigned char) icon_info.bits_per_pixel;
         png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);
         count=ReadBlob(image,length-16,png+16);
         icon_image=(Image *) NULL;
         if (count > 0)
           {
             read_info=CloneImageInfo(image_info);
             (void) CopyMagickString(read_info->magick,""PNG"",MagickPathExtent);
             icon_image=BlobToImage(read_info,png,length+16,exception);
             read_info=DestroyImageInfo(read_info);
           }
         png=(unsigned char *) RelinquishMagickMemory(png);
         if (icon_image == (Image *) NULL)
           {
             if (count != (ssize_t) (length-16))
               ThrowReaderException(CorruptImageError,
                 ""InsufficientImageDataInFile"");
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         DestroyBlob(icon_image);
         icon_image->blob=ReferenceBlob(image->blob);
         ReplaceImageInList(&image,icon_image);
       }
     else
       {
         if (icon_info.bits_per_pixel > 32)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         icon_info.compression=ReadBlobLSBLong(image);
         icon_info.image_size=ReadBlobLSBLong(image);
         icon_info.x_pixels=ReadBlobLSBLong(image);
         icon_info.y_pixels=ReadBlobLSBLong(image);
         icon_info.number_colors=ReadBlobLSBLong(image);
         icon_info.colors_important=ReadBlobLSBLong(image);
         image->alpha_trait=BlendPixelTrait;
         image->columns=(size_t) icon_file.directory[i].width;
         if ((ssize_t) image->columns > icon_info.width)
           image->columns=(size_t) icon_info.width;
         if (image->columns == 0)
           image->columns=256;
         image->rows=(size_t) icon_file.directory[i].height;
         if ((ssize_t) image->rows > icon_info.height)
           image->rows=(size_t) icon_info.height;
         if (image->rows == 0)
           image->rows=256;
         image->depth=icon_info.bits_per_pixel;
         if (image->debug != MagickFalse)
           {
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               "" scene    = %.20g"",(double) i);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   size   = %.20g"",(double) icon_info.size);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   width  = %.20g"",(double) icon_file.directory[i].width);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   height = %.20g"",(double) icon_file.directory[i].height);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   colors = %.20g"",(double ) icon_info.number_colors);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   planes = %.20g"",(double) icon_info.planes);
             (void) LogMagickEvent(CoderEvent,GetMagickModule(),
               ""   bpp    = %.20g"",(double) icon_info.bits_per_pixel);
           }
       if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))
         {
           image->storage_class=PseudoClass;
           image->colors=icon_info.number_colors;
           if (image->colors == 0)
             image->colors=one << icon_info.bits_per_pixel;
         }
       if (image->storage_class == PseudoClass)
         {
           register ssize_t
             i;
 
           unsigned char
             *icon_colormap;
 
            
           if (AcquireImageColormap(image,image->colors,exception) ==
               MagickFalse)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
             image->colors,4UL*sizeof(*icon_colormap));
           if (icon_colormap == (unsigned char *) NULL)
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);
           if (count != (ssize_t) (4*image->colors))
             ThrowReaderException(CorruptImageError,
               ""InsufficientImageDataInFile"");
           p=icon_colormap;
           for (i=0; i < (ssize_t) image->colors; i++)
           {
             image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);
             image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);
             image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);
             p++;
           }
           icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);
         }
          
         if ((image_info->ping != MagickFalse) &&
             (image_info->number_scenes != 0))
           if (image->scene >= (image_info->scene+image_info->number_scenes-1))
             break;
         status=SetImageExtent(image,image->columns,image->rows,exception);
         if (status == MagickFalse)
           return(DestroyImageList(image));
         bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &
           ~31) >> 3;
         (void) bytes_per_line;
         scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-
           (image->columns*icon_info.bits_per_pixel)) >> 3;
         switch (icon_info.bits_per_pixel)
         {
           case 1:
           {
              
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) (image->columns-7); x+=8)
               {
                 byte=(size_t) ReadBlobByte(image);
                 for (bit=0; bit < 8; bit++)
                 {
                   SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :
                     0x00),q);
                   q+=GetPixelChannels(image);
                 }
               }
               if ((image->columns % 8) != 0)
                 {
                   byte=(size_t) ReadBlobByte(image);
                   for (bit=0; bit < (image->columns % 8); bit++)
                   {
                     SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 :
                       0x00),q);
                     q+=GetPixelChannels(image);
                   }
                 }
               for (x=0; x < (ssize_t) scanline_pad; x++)
                 (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,image->rows-y-1,
                     image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             break;
           }
           case 4:
           {
              
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < ((ssize_t) image->columns-1); x+=2)
               {
                 byte=(size_t) ReadBlobByte(image);
                 SetPixelIndex(image,((byte >> 4) & 0xf),q);
                 q+=GetPixelChannels(image);
                 SetPixelIndex(image,((byte) & 0xf),q);
                 q+=GetPixelChannels(image);
               }
               if ((image->columns % 2) != 0)
                 {
                   byte=(size_t) ReadBlobByte(image);
                   SetPixelIndex(image,((byte >> 4) & 0xf),q);
                   q+=GetPixelChannels(image);
                 }
               for (x=0; x < (ssize_t) scanline_pad; x++)
                 (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,image->rows-y-1,
                     image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             break;
           }
           case 8:
           {
              
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 byte=(size_t) ReadBlobByte(image);
                 SetPixelIndex(image,byte,q);
                 q+=GetPixelChannels(image);
               }
               for (x=0; x < (ssize_t) scanline_pad; x++)
                 (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,image->rows-y-1,
                     image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             break;
           }
           case 16:
           {
              
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 byte=(size_t) ReadBlobByte(image);
                 byte|=(size_t) (ReadBlobByte(image) << 8);
                 SetPixelIndex(image,byte,q);
                 q+=GetPixelChannels(image);
               }
               for (x=0; x < (ssize_t) scanline_pad; x++)
                 (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,image->rows-y-1,
                     image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             break;
           }
           case 24:
           case 32:
           {
              
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                 SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
                   ReadBlobByte(image)),q);
                 SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
                   ReadBlobByte(image)),q);
                 SetPixelRed(image,ScaleCharToQuantum((unsigned char)
                   ReadBlobByte(image)),q);
                 if (icon_info.bits_per_pixel == 32)
                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                     ReadBlobByte(image)),q);
                 q+=GetPixelChannels(image);
               }
               if (icon_info.bits_per_pixel == 24)
                 for (x=0; x < (ssize_t) scanline_pad; x++)
                   (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
               if (image->previous == (Image *) NULL)
                 {
                   status=SetImageProgress(image,LoadImageTag,image->rows-y-1,
                     image->rows);
                   if (status == MagickFalse)
                     break;
                 }
             }
             break;
           }
           default:
             ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         }
         if (image_info->ping == MagickFalse)
           (void) SyncImage(image,exception);
         if (icon_info.bits_per_pixel != 32)
           {
              
             image->storage_class=DirectClass;
             for (y=(ssize_t) image->rows-1; y >= 0; y--)
             {
               q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
               if (q == (Quantum *) NULL)
                 break;
               for (x=0; x < ((ssize_t) image->columns-7); x+=8)
               {
                 byte=(size_t) ReadBlobByte(image);
                 for (bit=0; bit < 8; bit++)
                 {
                   SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?
                     TransparentAlpha : OpaqueAlpha),q);
                   q+=GetPixelChannels(image);
                 }
               }
               if ((image->columns % 8) != 0)
                 {
                   byte=(size_t) ReadBlobByte(image);
                   for (bit=0; bit < (image->columns % 8); bit++)
                   {
                     SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ?
                       TransparentAlpha : OpaqueAlpha),q);
                     q+=GetPixelChannels(image);
                   }
                 }
               if ((image->columns % 32) != 0)
                 for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)
                   (void) ReadBlobByte(image);
               if (SyncAuthenticPixels(image,exception) == MagickFalse)
                 break;
             }
           }
         if (EOFBlob(image) != MagickFalse)
           {
             ThrowFileException(exception,CorruptImageError,
               ""UnexpectedEndOfFile"",image->filename);
             break;
           }
       }
      
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     if (i < (ssize_t) (icon_file.count-1))
       {
          
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   }
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[112, 113]",Integer truncation issue in coders/pict.c in ImageMagick before 7.0.5-0 allows remote attackers to cause a denial of service (application crash) via a crafted .pict file.
205482," void UsbFindDevicesFunction::OnGetDevicesComplete(
     const std::vector<scoped_refptr<UsbDevice>>& devices) {
   result_.reset(new base::ListValue());
   barrier_ = base::BarrierClosure(
       devices.size(), base::Bind(&UsbFindDevicesFunction::OpenComplete, this));
 
   for (const scoped_refptr<UsbDevice>& device : devices) {
     if (device->vendor_id() != vendor_id_ ||
          device->product_id() != product_id_) {
        barrier_.Run();
      } else {
      device->OpenInterface(
          interface_id_,
          base::Bind(&UsbFindDevicesFunction::OnDeviceOpened, this));
       device->Open(base::Bind(&UsbFindDevicesFunction::OnDeviceOpened, this));
      }
    }
  }","[15, 12, 13, 14]",Use-after-free vulnerability in the WebSocketDispatcherHost::SendOrDrop function in content/browser/renderer_host/websocket_dispatcher_host.cc in the Web Sockets implementation in Google Chrome before 33.0.1750.149 might allow remote attackers to bypass the sandbox protection mechanism by leveraging an incorrect deletion in a certain failure case.
206153," png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
                int num_text)
 {
    int i;
 
    png_debug1(1, ""in %s storage function"", ((png_ptr == NULL ||
       png_ptr->chunk_name[0] == '\0') ?
       ""text"" : (png_const_charp)png_ptr->chunk_name));
 
    if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
       return(0);
 
     
    if (info_ptr->num_text + num_text > info_ptr->max_text)
    {
       int old_max_text = info_ptr->max_text;
       int old_num_text = info_ptr->num_text;
 
       if (info_ptr->text != NULL)
       {
          png_textp old_text;
 
          info_ptr->max_text = info_ptr->num_text + num_text + 8;
          old_text = info_ptr->text;
 
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
             (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
          {
              
             info_ptr->max_text = old_max_text;
             info_ptr->text = old_text;
             return(1);
          }
          png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
             png_sizeof(png_text)));
          png_free(png_ptr, old_text);
       }
       else
       {
          info_ptr->max_text = num_text + 8;
          info_ptr->num_text = 0;
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
             (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
          {
              
             info_ptr->num_text = old_num_text;
             info_ptr->max_text = old_max_text;
             return(1);
          }
 #ifdef PNG_FREE_ME_SUPPORTED
          info_ptr->free_me |= PNG_FREE_TEXT;
 #endif
       }
       png_debug1(3, ""allocated %d entries for info_ptr->text"",
          info_ptr->max_text);
    }
 
    for (i = 0; i < num_text; i++)
    {
       png_size_t text_length, key_len;
       png_size_t lang_len, lang_key_len;
       png_textp textp = &(info_ptr->text[info_ptr->num_text]);
 
       if (text_ptr[i].key == NULL)
           continue;
 
       key_len = png_strlen(text_ptr[i].key);
 
       if (text_ptr[i].compression <= 0)
       {
          lang_len = 0;
          lang_key_len = 0;
       }
 
       else
 #ifdef PNG_iTXt_SUPPORTED
       {
           
 
          if (text_ptr[i].lang != NULL)
             lang_len = png_strlen(text_ptr[i].lang);
          else
             lang_len = 0;
          if (text_ptr[i].lang_key != NULL)
             lang_key_len = png_strlen(text_ptr[i].lang_key);
          else
             lang_key_len = 0;
       }
 #else  
       {
          png_warning(png_ptr, ""iTXt chunk not supported."");
          continue;
       }
 #endif
 
       if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
       {
          text_length = 0;
 #ifdef PNG_iTXt_SUPPORTED
          if (text_ptr[i].compression > 0)
             textp->compression = PNG_ITXT_COMPRESSION_NONE;
          else
 #endif
             textp->compression = PNG_TEXT_COMPRESSION_NONE;
       }
 
       else
       {
          text_length = png_strlen(text_ptr[i].text);
          textp->compression = text_ptr[i].compression;
       }
 
       textp->key = (png_charp)png_malloc_warn(png_ptr,
          (png_uint_32)
           (key_len + text_length + lang_len + lang_key_len + 4));
        if (textp->key == NULL)
           return(1);
      png_debug2(2, ""Allocated %lu bytes at %x in png_set_text"",
       png_debug2(2, ""Allocated %lu bytes at %p in png_set_text"",
                   (png_uint_32)
                   (key_len + lang_len + lang_key_len + text_length + 4),
                 (int)textp->key);
                  textp->key);
  
        png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
        *(textp->key + key_len) = '\0';
 #ifdef PNG_iTXt_SUPPORTED
       if (text_ptr[i].compression > 0)
       {
          textp->lang = textp->key + key_len + 1;
          png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
          *(textp->lang + lang_len) = '\0';
          textp->lang_key = textp->lang + lang_len + 1;
          png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
          *(textp->lang_key + lang_key_len) = '\0';
          textp->text = textp->lang_key + lang_key_len + 1;
       }
       else
 #endif
       {
 #ifdef PNG_iTXt_SUPPORTED
          textp->lang=NULL;
          textp->lang_key=NULL;
 #endif
          textp->text = textp->key + key_len + 1;
       }
       if (text_length)
          png_memcpy(textp->text, text_ptr[i].text,
             (png_size_t)(text_length));
       *(textp->text + text_length) = '\0';
 
 #ifdef PNG_iTXt_SUPPORTED
       if (textp->compression > 0)
       {
          textp->text_length = 0;
          textp->itxt_length = text_length;
       }
       else
 #endif
 
       {
          textp->text_length = text_length;
 #ifdef PNG_iTXt_SUPPORTED
          textp->itxt_length = 0;
 #endif
       }
       info_ptr->num_text++;
       png_debug1(3, ""transferred text chunk %d"", info_ptr->num_text);
    }
    return(0);
 }","[121, 125, 120, 124]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
200378," static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) 
 static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
  {
  
  	const char* loc_name        	= NULL;
 	int         loc_name_len    	= 0;
 
 	char*       tag_value		= NULL;
 	char*       empty_result	= """";
 
 	int         result    		= 0;
 	char*       msg        		= NULL;
 
 	UErrorCode  status          	= U_ZERO_ERROR;
 
 	intl_error_reset( NULL TSRMLS_CC );
 
 	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"",
 	&loc_name ,&loc_name_len ) == FAILURE) {
 		spprintf(&msg , 0, ""locale_get_%s : unable to parse input params"", tag_name );
 		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );
 		efree(msg);
 
 		RETURN_FALSE;
     }
 
 	if(loc_name_len == 0) {
 		loc_name = intl_locale_get_default(TSRMLS_C);
 	}
 
 	 
 	tag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);
 
 	 
 	if( result == -1 ) {
 		if( tag_value){
 			efree( tag_value);
 		}
 		RETURN_STRING( empty_result , TRUE);
 	}
 
 	 
 	if( tag_value){
 		RETURN_STRING( tag_value , FALSE);
 	}
 
 	 
 	if( result ==0) {
 		spprintf(&msg , 0, ""locale_get_%s : unable to get locale %s"", tag_name , tag_name );
 		intl_error_set( NULL, status, msg , 1 TSRMLS_CC );
 		efree(msg);
 		RETURN_NULL();
 	}
 
  }",[2],"The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call."
201836,"  process_add_smartcard_key(SocketEntry *e)
  {
	char *provider = NULL, *pin;
 	char *provider = NULL, *pin, canonical_provider[PATH_MAX];
  	int r, i, version, count = 0, success = 0, confirm = 0;
  	u_int seconds;
  	time_t death = 0;
 	u_char type;
 	struct sshkey **keys = NULL, *k;
 	Identity *id;
 	Idtab *tab;
 
 	if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||
 	    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)
 		fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
 
 	while (sshbuf_len(e->request)) {
 		if ((r = sshbuf_get_u8(e->request, &type)) != 0)
 			fatal(""%s: buffer error: %s"", __func__, ssh_err(r));
 		switch (type) {
 		case SSH_AGENT_CONSTRAIN_LIFETIME:
 			if ((r = sshbuf_get_u32(e->request, &seconds)) != 0)
 				fatal(""%s: buffer error: %s"",
 				    __func__, ssh_err(r));
 			death = monotime() + seconds;
 			break;
 		case SSH_AGENT_CONSTRAIN_CONFIRM:
 			confirm = 1;
 			break;
 		default:
 			error(""process_add_smartcard_key: ""
 			    ""Unknown constraint type %d"", type);
  			goto send;
  		}
  	}
 	if (realpath(provider, canonical_provider) == NULL) {
 		verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"",
 		    provider, strerror(errno));
 		goto send;
 	}
 	if (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {
 		verbose(""refusing PKCS#11 add of \""%.100s\"": ""
 		    ""provider not whitelisted"", canonical_provider);
 		goto send;
 	}
 	debug(""%s: add %.100s"", __func__, canonical_provider);
  	if (lifetime && !death)
  		death = monotime() + lifetime;
  
	count = pkcs11_add_provider(provider, pin, &keys);
 	count = pkcs11_add_provider(canonical_provider, pin, &keys);
  	for (i = 0; i < count; i++) {
  		k = keys[i];
  		version = k->type == KEY_RSA1 ? 1 : 2;
  		tab = idtab_lookup(version);
  		if (lookup_identity(k, version) == NULL) {
  			id = xcalloc(1, sizeof(Identity));
  			id->key = k;
			id->provider = xstrdup(provider);
			id->comment = xstrdup(provider);  
 			id->provider = xstrdup(canonical_provider);
 			id->comment = xstrdup(canonical_provider);  
  			id->death = death;
  			id->confirm = confirm;
  			TAILQ_INSERT_TAIL(&tab->idlist, id, next);
 			tab->nentries++;
 			success = 1;
 		} else {
 			sshkey_free(k);
 		}
 		keys[i] = NULL;
 	}
 send:
 	free(pin);
 	free(provider);
 	free(keys);
 	send_status(e, success);
 }","[4, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 51, 61, 62, 3, 50, 59, 60]",Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.
200595," static void test_show_object(struct object *object,
			     struct strbuf *path,
			     const char *last, void *data)
 static void test_show_object(struct object *object, const char *name,
 			     void *data)
  {
  	struct bitmap_test_data *tdata = data;
  	int bitmap_pos;
 
 	bitmap_pos = bitmap_position(object->oid.hash);
 	if (bitmap_pos < 0)
 		die(""Object not in bitmap: %s\n"", oid_to_hex(&object->oid));
 
 	bitmap_set(tdata->base, bitmap_pos);
 	display_progress(tdata->prg, ++tdata->seen);
 }","[4, 5, 2, 3]","Integer overflow in Git before 2.7.4 allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, which triggers a heap-based buffer overflow."
198197," uint NotificationsEngine::Notify(const QString &app_name, uint replaces_id,
                                  const QString &app_icon, const QString &summary, const QString &body,
                                  const QStringList &actions, const QVariantMap &hints, int timeout)
 {
     uint partOf = 0;
     const QString appRealName = hints[QStringLiteral(""x-kde-appname"")].toString();
     const QString eventId = hints[QStringLiteral(""x-kde-eventId"")].toString();
     const bool skipGrouping = hints[QStringLiteral(""x-kde-skipGrouping"")].toBool();
 
     if (!replaces_id && m_activeNotifications.values().contains(app_name + summary) && !skipGrouping && !m_alwaysReplaceAppsList.contains(app_name)) {
         partOf = m_activeNotifications.key(app_name + summary).midRef(13).toUInt();
     }
 
      qDebug() << ""Currrent active notifications:"" << m_activeNotifications;
      qDebug() << ""Guessing partOf as:"" << partOf;
      qDebug() << "" New Notification: "" << summary << body << timeout << ""& Part of:"" << partOf;
    QString _body;
     QString bodyFinal = NotificationSanitizer::parse(body);
  
      if (partOf > 0) {
          const QString source = QStringLiteral(""notification %1"").arg(partOf);
          Plasma::DataContainer *container = containerForSource(source);
          if (container) {
            _body = container->data()[QStringLiteral(""body"")].toString();
            if (_body != body) {
                _body.append(""\n"").append(body);
            } else {
                _body = body;
             const QString previousBody = container->data()[QStringLiteral(""body"")].toString();
             if (previousBody != bodyFinal) {
                  
                  
                  
                 bodyFinal = previousBody + QStringLiteral(""<br/>"") + bodyFinal;
              }
  
              replaces_id = partOf;
             CloseNotification(partOf);
         }
     }
 
     uint id = replaces_id ? replaces_id : m_nextId++;
 
     if (m_alwaysReplaceAppsList.contains(app_name)) {
         if (m_notificationsFromReplaceableApp.contains(app_name)) {
             id = m_notificationsFromReplaceableApp.value(app_name);
         } else {
             m_notificationsFromReplaceableApp.insert(app_name, id);
         }
     }
 
     QString appname_str = app_name;
     if (appname_str.isEmpty()) {
         appname_str = i18n(""Unknown Application"");
     }
 
     bool isPersistent = timeout == 0;
 
  
      const int AVERAGE_WORD_LENGTH = 6;
      const int WORD_PER_MINUTE = 250;
    int count = summary.length() + body.length();
     int count = summary.length() + body.length() - strlen(""<?xml version=\""1.0\""><html></html>"");
  
         timeout = 60000 * count / AVERAGE_WORD_LENGTH / WORD_PER_MINUTE;
 
         timeout = 2000 + qMax(timeout, 3000);
     }","[18, 29, 30, 31, 32, 33, 34, 63, 17, 24, 25, 26, 27, 28, 62]","An issue was discovered in KDE Plasma Workspace before 5.12.0. dataengines/notifications/notificationsengine.cpp allows remote attackers to discover client IP addresses via a URL in a notification, as demonstrated by the src attribute of an IMG element."
207936," WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
                                                UWORD32 u4_total_coeff_trail_one,  
  dec_bit_stream_t *ps_bitstrm)
 {
     UWORD32 u4_total_zeroes;
     WORD32 i;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
 
      UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
      UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
      UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    WORD16 i2_level_arr[16];
      
      
      
     WORD16 ai2_level_arr[19];
     WORD16 *i2_level_arr = &ai2_level_arr[3];
  
      tu_sblk4x4_coeff_data_t *ps_tu_4x4;
      WORD16 *pi2_coeff_data;
  dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;
 
     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
     ps_tu_4x4->u2_sig_coeff_map = 0;
     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];
 
     i = u4_total_coeff - 1;
 
  if(u4_trailing_ones)
  {
   
   
   
   
         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
         WORD16 (*ppi2_trlone_lkup)[3] =
  (WORD16 (*)[3])gai2_ih264d_trailing_one_level;
         WORD16 *pi2_trlone_lkup;
 
         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);
 
         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];
 
  while(u4_cnt--)
             i2_level_arr[i--] = *pi2_trlone_lkup++;
  }
 
   
   
   
  if(i >= 0)
  {
   
   
   
   
         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
         WORD32 u2_lev_code, u2_abs_value;
         UWORD32 u4_lev_prefix;
 
   
   
   
         FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                               pu4_bitstrm_buf);
 
   
   
   
         u2_lev_code = MIN(15, u4_lev_prefix);
 
         u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;
 
  if(14 == u4_lev_prefix)
             u4_lev_suffix_size = 4;
  else if(15 <= u4_lev_prefix)
  {
             u2_lev_code += 15;
             u4_lev_suffix_size = u4_lev_prefix - 3;
  }
  else
             u4_lev_suffix_size = 0;
 
  if(16 <= u4_lev_prefix)
  {
             u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
  }
  if(u4_lev_suffix_size)
  {
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code += u4_lev_suffix;
  }
 
         u2_abs_value = (u2_lev_code + 2) >> 1;
   
   
   
         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;
 
   
   
   
  while(i >= 0)
  {
 
   
   
   
             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
                                   pu4_bitstrm_buf);
 
             u4_lev_suffix_size =
  (15 <= u4_lev_prefix) ?
  (u4_lev_prefix - 3) : u4_suffix_len;
 
   
   
   
             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
                     u4_lev_suffix_size);
             u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
  + u4_lev_suffix;
 
  if(16 <= u4_lev_prefix)
  {
                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
  }
             u2_abs_value = (u2_lev_code + 2) >> 1;
 
   
   
   
             i2_level_arr[i--] =
  (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;
 
   
   
   
             u4_suffix_len +=
  (u4_suffix_len < 6) ?
  (u2_abs_value
  > (3
  << (u4_suffix_len
  - 1))) :
  0;
  }
 
   
   
   
  }
 
   
   
   
  {
         UWORD32 u4_index;
  const UWORD8 (*ppu1_total_zero_lkup)[64] =
  (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;
 
         NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);
         u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];
 
         FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
         u4_total_zeroes &= 0xf;
  }
 
   
   
   
  {
  const UWORD8 *pu1_table_runbefore;
         UWORD32 u4_run;
         WORD32 k;
         UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
         WORD32 u4_zeroes_left = u4_total_zeroes;
         k = u4_total_coeff - 1;
 
   
   
   
  while((u4_zeroes_left > 6) && k)
  {
             UWORD32 u4_code;
 
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
  if(u4_code != 0)
  {
                 FLUSHBITS(u4_bitstream_offset, 3);
                 u4_run = (7 - u4_code);
  }
  else
  {
 
                 FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,
                                        pu4_bitstrm_buf, 11);
                 u4_run = (4 + u4_code);
  }
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
  *pi2_coeff_data++ = i2_level_arr[k--];
             u4_zeroes_left -= u4_run;
             u4_scan_pos -= (u4_run + 1);
  }
 
   
   
   
         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
  while((u4_zeroes_left > 0) && k)
  {
             UWORD32 u4_code;
             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);
 
             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
             u4_run = u4_code >> 2;
 
             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
  *pi2_coeff_data++ = i2_level_arr[k--];
             u4_zeroes_left -= u4_run;
             u4_scan_pos -= (u4_run + 1);
  }
   
   
   
 
   
   
   
  if(u4_zeroes_left < 0)
  return -1;
  while(k >= 0)
  {
 
             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
  *pi2_coeff_data++ = i2_level_arr[k--];
             u4_scan_pos--;
  }
  }
 
  {
         WORD32 offset;
         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
         offset = ALIGN4(offset);
         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
  }
 
     ps_bitstrm->u4_ofst = u4_bitstream_offset;
  return 0;
 }","[13, 14, 15, 16, 17, 12]","Multiple stack-based buffer underflows in decoder/ih264d_parse_cavlc.c in mediaserver in Android 6.x before 2016-04-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 26399350."
207965," IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)
 {
     UWORD32 i;
  yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;
 
  stream_t *ps_stream       = &ps_dec->s_bit_stream;
     UWORD8   *pu1_vld_buf;
 
     WORD16 i2_dc_diff;
     UWORD32 u4_frame_width = ps_dec->u2_frame_width;
     UWORD32 u4_frm_offset = 0;
  if(ps_dec->u2_picture_structure != FRAME_PICTURE)
  {
         u4_frame_width <<= 1;
  if(ps_dec->u2_picture_structure == BOTTOM_FIELD)
  {
             u4_frm_offset = ps_dec->u2_frame_width;
  }
  }
 
  do
  {
 
         UWORD32 u4_x_offset, u4_y_offset;
         UWORD32 u4_blk_pos;
         WORD16 i2_dc_val;
 
         UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);
         UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;
         UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;
         UWORD32 u4_dst_wd           = u4_frame_width;
 
           
           
           
        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)
         while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&
                 ps_stream->u4_offset < ps_stream->u4_max_offset)
              impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);
  
           
   
   
         impeg2d_bit_stream_flush(ps_stream,1);
 
  if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)
  {
   
  }
 
   
  for(i = 0; i < NUM_LUMA_BLKS; ++i)
  {
 
             u4_x_offset    = gai2_impeg2_blk_x_off[i];
             u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;
             u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;
             pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;
 
             i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);
             i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;
             ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;
             i2_dc_val = CLIP_U8(i2_dc_val);
 
             ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
  }
 
 
 
   
 
         u4_dst_x_offset                >>= 1;
         u4_dst_y_offset                >>= 2;
         u4_dst_wd                      >>= 1;
         pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;
         i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
         i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;
         ps_dec->u2_def_dc_pred[U_CHROMA] = i2_dc_val;
         i2_dc_val = CLIP_U8(i2_dc_val);
         ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
 
 
   
 
         pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;
         i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);
         i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;
         ps_dec->u2_def_dc_pred[V_CHROMA] = i2_dc_val;
         i2_dc_val = CLIP_U8(i2_dc_val);
         ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);
 
   
 
 
         ps_dec->u2_num_mbs_left--;
         ps_dec->u2_mb_x++;
 
  if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)
  {
  return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;
  }
  else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)
  {
             ps_dec->u2_mb_x = 0;
             ps_dec->u2_mb_y++;
 
  }
 
   
         impeg2d_bit_stream_flush(ps_stream,1);
  }
  while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);
  return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
 } ","[37, 38, 36]","libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591."
8304,"void Compute(OpKernelContext* context) override {
const Tensor& input = context->input(0);
const Tensor& diag = context->input(1);




int32_t lower_diag_index = 0;
int32_t upper_diag_index = 0;


if (context->num_inputs() > kNumV1Inputs) {
auto& diag_index = context->input(2);
OP_REQUIRES(context,
TensorShapeUtils::IsScalar(diag_index.shape()) ||
TensorShapeUtils::IsVector(diag_index.shape()),
errors::InvalidArgument(
""diag_index must be a scalar or vector, received shape: "",
diag_index.shape().DebugString()));
lower_diag_index = diag_index.flat<int32>()(0);
upper_diag_index = lower_diag_index;
if (TensorShapeUtils::IsVector(diag_index.shape())) {
auto diag_index_size = diag_index.dim_size(0);
OP_REQUIRES(
context, 0 < diag_index_size && diag_index_size <= 2,
errors::InvalidArgument(
""diag_index must have only one or two elements, received "",
diag_index_size, "" elements.""));
if (diag_index_size > 1) {
upper_diag_index = diag_index.flat<int32>()(1);
}
}
}

const TensorShape& input_shape = input.shape();
const TensorShape& diag_shape = diag.shape();
const int input_rank = input_shape.dims();


OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),
errors::InvalidArgument(
""input must be at least 2-dim, received shape: "",
input.shape().DebugString()));
OP_REQUIRES(context, TensorShapeUtils::IsVectorOrHigher(diag_shape),
errors::InvalidArgument(
""diagonal must be at least 1-dim, received shape: "",
diag_shape.DebugString()));


const Eigen::Index num_rows = input_shape.dim_size(input_rank - 2);
const Eigen::Index num_cols = input_shape.dim_size(input_rank - 1);
OP_REQUIRES(
context,
(-num_rows < lower_diag_index && lower_diag_index < num_cols) ||
lower_diag_index == 0,
errors::InvalidArgument(
""lower_diag_index is out of bound: "", lower_diag_index,
"" It must be between "", -num_rows, "" and "", num_cols));
OP_REQUIRES(context,
(-num_rows < upper_diag_index && upper_diag_index < num_cols) ||
upper_diag_index == 0,
errors::InvalidArgument(
""upper_diag_index is out of bound: "", upper_diag_index,
"" It must be between "", -num_rows, "" and "", num_cols));
OP_REQUIRES(
context, lower_diag_index <= upper_diag_index,
errors::InvalidArgument(
""lower_diag_index must not be larger than upper_diag_index: "",
lower_diag_index, "" > "", upper_diag_index));


const Eigen::Index num_diags = upper_diag_index - lower_diag_index + 1;
OP_REQUIRES(
context,
lower_diag_index == upper_diag_index ||
(diag_shape.dim_size(input_rank - 2) == num_diags),
errors::InvalidArgument(""The number of diagonals provided in `diag` ""
""is not consistent with `lower_diag_index` and ""
""`upper_diag_index`""));

TensorShape expected_diag_shape = input_shape;
expected_diag_shape.RemoveLastDims(2);
if (num_diags > 1) expected_diag_shape.AddDim(num_diags);
const int32_t max_diag_len =
std::min(num_rows + std::min(upper_diag_index, 0),
num_cols - std::max(lower_diag_index, 0));
expected_diag_shape.AddDim(max_diag_len);
OP_REQUIRES(
context, expected_diag_shape == diag_shape,
errors::InvalidArgument(
""Either first dimensions of diagonal don't match input.shape[:-2], ""
""or diagonal.shape[:-1] is not equal to the longests diagonal in ""
""range [lower_diag_index:upper_diag_index].\nInput shape: "",
input_shape.DebugString(),
""\nDiagonal shape: "", diag_shape.DebugString(),
""\nExpected diagonal shape: "", expected_diag_shape.DebugString()));

if (input.NumElements() == 0) {

context->set_output(0, input);
return;
}

auto input_reshaped = input.flat_inner_dims<T, 3>();
auto diag_reshaped = diag.flat<T>();
Tensor* output = nullptr;
OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(
{0}, 0, input_shape, &output));
auto output_reshaped = output->flat_inner_dims<T, 3>();
functor::MatrixSetDiag<Device, T>::Compute(
context, context->eigen_device<Device>(), input_reshaped, diag_reshaped,
output_reshaped, lower_diag_index, upper_diag_index, max_diag_len,
left_align_superdiagonal_, left_align_subdiagonal_);
}",[20],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause undefined behavior via binding a reference to null pointer in all operations of type `tf.raw_ops.MatrixSetDiagV*`. The [implementation](https://github.com/tensorflow/tensorflow/blob/84d053187cb80d975ef2b9684d4b61981bca0c41/tensorflow/core/kernels/linalg/matrix_diag_op.cc) has incomplete validation that the value of `k` is a valid tensor. We have check that this value is either a scalar or a vector, but there is no check for the number of elements. If this is an empty tensor, then code that accesses the first element of the tensor is wrong. We have patched the issue in GitHub commit ff8894044dfae5568ecbf2ed514c1a37dc394f1b. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
205249," bool UnprivilegedProcessDelegate::LaunchProcess(
     IPC::Listener* delegate,
     ScopedHandle* process_exit_event_out) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
   std::string channel_name = GenerateIpcChannelName(this);
 
    ScopedHandle client;
    scoped_ptr<IPC::ChannelProxy> server;
  if (!CreateConnectedIpcChannel(channel_name, delegate, &client, &server))
   ScopedHandle pipe;
   if (!CreateConnectedIpcChannel(channel_name, io_task_runner_, delegate,
                                  &client, &server, &pipe)) {
      return false;
   }
  
   std::string pipe_handle = base::StringPrintf(
       ""%d"", reinterpret_cast<ULONG_PTR>(client.Get()));
 
   CommandLine command_line(binary_path_);
   command_line.AppendSwitchASCII(kDaemonPipeSwitchName, pipe_handle);
   command_line.CopySwitchesFrom(*CommandLine::ForCurrentProcess(),
                                 kCopiedSwitchNames,
                                 arraysize(kCopiedSwitchNames));
 
   ScopedHandle worker_thread;
   worker_process_.Close();
   if (!LaunchProcessWithToken(command_line.GetProgram(),
                               command_line.GetCommandLineString(),
                               NULL,
                               true,
                               0,
                               &worker_process_,
                               &worker_thread)) {
     return false;
   }
 
   ScopedHandle process_exit_event;
   if (!DuplicateHandle(GetCurrentProcess(),
                        worker_process_,
                        GetCurrentProcess(),
                        process_exit_event.Receive(),
                        SYNCHRONIZE,
                        FALSE,
                        0)) {
     LOG_GETLASTERROR(ERROR) << ""Failed to duplicate a handle"";
     KillProcess(CONTROL_C_EXIT);
     return false;
   }
 
   channel_ = server.Pass();
   *process_exit_event_out = process_exit_event.Pass();
    return true;
  }","[10, 11, 12, 14, 9]",Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving PDF fields.
8226,"static void adapter_stop(struct btd_adapter *adapter)
{

reply_pending_requests(adapter);

cancel_passive_scanning(adapter);

remove_discovery_list(adapter);

discovery_cleanup(adapter, 0);

adapter->filtered_discovery = false;
adapter->no_scan_restart_delay = false;
g_free(adapter->current_discovery_filter);
adapter->current_discovery_filter = NULL;

adapter->discovering = false;

while (adapter->connections) {
struct btd_device *device = adapter->connections->data;
uint8_t addr_type = btd_device_get_bdaddr_type(device);

adapter_remove_connection(adapter, device, BDADDR_BREDR);
if (addr_type != BDADDR_BREDR)
adapter_remove_connection(adapter, device, addr_type);
}

g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Discovering"");

if (adapter->dev_class) {


adapter->dev_class = 0;
g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Class"");
}

g_dbus_emit_property_changed(dbus_conn, adapter->path,
ADAPTER_INTERFACE, ""Powered"");

DBG(""adapter %s has been disabled"", adapter->path);
}",[17],"bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers."
201080," isis_print(netdissect_options *ndo,
            const uint8_t *p, u_int length)
 {
     const struct isis_common_header *isis_header;
 
     const struct isis_iih_lan_header *header_iih_lan;
     const struct isis_iih_ptp_header *header_iih_ptp;
     const struct isis_lsp_header *header_lsp;
     const struct isis_csnp_header *header_csnp;
     const struct isis_psnp_header *header_psnp;
 
     const struct isis_tlv_lsp *tlv_lsp;
     const struct isis_tlv_ptp_adj *tlv_ptp_adj;
     const struct isis_tlv_is_reach *tlv_is_reach;
     const struct isis_tlv_es_reach *tlv_es_reach;
 
     uint8_t pdu_type, max_area, id_length, tlv_type, tlv_len, tmp, alen, lan_alen, prefix_len;
     uint8_t ext_is_len, ext_ip_len, mt_len;
     const uint8_t *optr, *pptr, *tptr;
     u_short packet_len,pdu_len, key_id;
     u_int i,vendor_id;
     int sigcheck;
 
     packet_len=length;
     optr = p;  
     isis_header = (const struct isis_common_header *)p;
     ND_TCHECK(*isis_header);
     if (length < ISIS_COMMON_HEADER_SIZE)
         goto trunc;
     pptr = p+(ISIS_COMMON_HEADER_SIZE);
     header_iih_lan = (const struct isis_iih_lan_header *)pptr;
     header_iih_ptp = (const struct isis_iih_ptp_header *)pptr;
     header_lsp = (const struct isis_lsp_header *)pptr;
     header_csnp = (const struct isis_csnp_header *)pptr;
     header_psnp = (const struct isis_psnp_header *)pptr;
 
     if (!ndo->ndo_eflag)
         ND_PRINT((ndo, ""IS-IS""));
 
      
 
     if (isis_header->version != ISIS_VERSION) {
 	ND_PRINT((ndo, ""version %d packet not supported"", isis_header->version));
 	return (0);
     }
 
     if ((isis_header->id_length != SYSTEM_ID_LEN) && (isis_header->id_length != 0)) {
 	ND_PRINT((ndo, ""system ID length of %d is not supported"",
 	       isis_header->id_length));
 	return (0);
     }
 
     if (isis_header->pdu_version != ISIS_VERSION) {
 	ND_PRINT((ndo, ""version %d packet not supported"", isis_header->pdu_version));
 	return (0);
     }
 
     if (length < isis_header->fixed_len) {
 	ND_PRINT((ndo, ""fixed header length %u > packet length %u"", isis_header->fixed_len, length));
 	return (0);
     }
 
     if (isis_header->fixed_len < ISIS_COMMON_HEADER_SIZE) {
 	ND_PRINT((ndo, ""fixed header length %u < minimum header size %u"", isis_header->fixed_len, (u_int)ISIS_COMMON_HEADER_SIZE));
 	return (0);
     }
 
     max_area = isis_header->max_area;
     switch(max_area) {
     case 0:
 	max_area = 3;	  
 	break;
     case 255:
 	ND_PRINT((ndo, ""bad packet -- 255 areas""));
 	return (0);
     default:
 	break;
     }
 
     id_length = isis_header->id_length;
     switch(id_length) {
     case 0:
         id_length = 6;	  
 	break;
     case 1:               
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
     case 7:
     case 8:
         break;
     case 255:
         id_length = 0;    
 	break;
     default:
         break;
     }
 
      
     if (id_length != 6 ) {
 	ND_PRINT((ndo, ""bad packet -- illegal sys-ID length (%u)"", id_length));
 	return (0);
     }
 
     pdu_type=isis_header->pdu_type;
 
      
     if (ndo->ndo_vflag == 0) {
         ND_PRINT((ndo, ""%s%s"",
                ndo->ndo_eflag ? """" : "", "",
                tok2str(isis_pdu_values, ""unknown PDU-Type %u"", pdu_type)));
     } else {
          
         ND_PRINT((ndo, ""%slength %u"", ndo->ndo_eflag ? """" : "", "", length));
 
         ND_PRINT((ndo, ""\n\t%s, hlen: %u, v: %u, pdu-v: %u, sys-id-len: %u (%u), max-area: %u (%u)"",
                tok2str(isis_pdu_values,
                        ""unknown, type %u"",
                        pdu_type),
                isis_header->fixed_len,
                isis_header->version,
                isis_header->pdu_version,
                id_length,
                isis_header->id_length,
                max_area,
                isis_header->max_area));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, optr, ""\n\t"", 8))  
                 return (0);                          
         }
     }
 
     switch (pdu_type) {
 
     case ISIS_PDU_L1_LAN_IIH:
     case ISIS_PDU_L2_LAN_IIH:
         if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)) {
             ND_PRINT((ndo, "", bogus fixed header length %u should be %lu"",
                      isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)));
             return (0);
         }
         ND_TCHECK(*header_iih_lan);
         if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE)
             goto trunc;
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", src-id %s"",
                       isis_print_id(header_iih_lan->source_id, SYSTEM_ID_LEN)));
             ND_PRINT((ndo, "", lan-id %s, prio %u"",
                       isis_print_id(header_iih_lan->lan_id,NODE_ID_LEN),
                       header_iih_lan->priority));
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
         pdu_len=EXTRACT_16BITS(header_iih_lan->pdu_len);
         if (packet_len>pdu_len) {
            packet_len=pdu_len;  
            length=pdu_len;
         }
 
         ND_PRINT((ndo, ""\n\t  source-id: %s,  holding time: %us, Flags: [%s]"",
                   isis_print_id(header_iih_lan->source_id,SYSTEM_ID_LEN),
                   EXTRACT_16BITS(header_iih_lan->holding_time),
                   tok2str(isis_iih_circuit_type_values,
                           ""unknown circuit type 0x%02x"",
                           header_iih_lan->circuit_type)));
 
         ND_PRINT((ndo, ""\n\t  lan-id:    %s, Priority: %u, PDU length: %u"",
                   isis_print_id(header_iih_lan->lan_id, NODE_ID_LEN),
                   (header_iih_lan->priority) & ISIS_LAN_PRIORITY_MASK,
                   pdu_len));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, pptr, ""\n\t  "", ISIS_IIH_LAN_HEADER_SIZE))
                 return (0);
         }
 
         packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
         pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_LAN_HEADER_SIZE);
         break;
 
     case ISIS_PDU_PTP_IIH:
         if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)) {
             ND_PRINT((ndo, "", bogus fixed header length %u should be %lu"",
                       isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)));
             return (0);
         }
         ND_TCHECK(*header_iih_ptp);
         if (length < ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE)
             goto trunc;
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", src-id %s"", isis_print_id(header_iih_ptp->source_id, SYSTEM_ID_LEN)));
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
         pdu_len=EXTRACT_16BITS(header_iih_ptp->pdu_len);
         if (packet_len>pdu_len) {
             packet_len=pdu_len;  
             length=pdu_len;
         }
 
         ND_PRINT((ndo, ""\n\t  source-id: %s, holding time: %us, Flags: [%s]"",
                   isis_print_id(header_iih_ptp->source_id,SYSTEM_ID_LEN),
                   EXTRACT_16BITS(header_iih_ptp->holding_time),
                   tok2str(isis_iih_circuit_type_values,
                           ""unknown circuit type 0x%02x"",
                           header_iih_ptp->circuit_type)));
 
         ND_PRINT((ndo, ""\n\t  circuit-id: 0x%02x, PDU length: %u"",
                   header_iih_ptp->circuit_id,
                   pdu_len));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, pptr, ""\n\t  "", ISIS_IIH_PTP_HEADER_SIZE))
                 return (0);
         }
 
         packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
         pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_IIH_PTP_HEADER_SIZE);
         break;
 
     case ISIS_PDU_L1_LSP:
     case ISIS_PDU_L2_LSP:
         if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)) {
             ND_PRINT((ndo, "", bogus fixed header length %u should be %lu"",
                    isis_header->fixed_len, (unsigned long)ISIS_LSP_HEADER_SIZE));
             return (0);
         }
         ND_TCHECK(*header_lsp);
         if (length < ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE)
             goto trunc;
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", lsp-id %s, seq 0x%08x, lifetime %5us"",
                       isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),
                       EXTRACT_32BITS(header_lsp->sequence_number),
                       EXTRACT_16BITS(header_lsp->remaining_lifetime)));
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
         pdu_len=EXTRACT_16BITS(header_lsp->pdu_len);
         if (packet_len>pdu_len) {
             packet_len=pdu_len;  
             length=pdu_len;
         }
 
         ND_PRINT((ndo, ""\n\t  lsp-id: %s, seq: 0x%08x, lifetime: %5us\n\t  chksum: 0x%04x"",
                isis_print_id(header_lsp->lsp_id, LSP_ID_LEN),
                EXTRACT_32BITS(header_lsp->sequence_number),
                EXTRACT_16BITS(header_lsp->remaining_lifetime),
                EXTRACT_16BITS(header_lsp->checksum)));
 
         osi_print_cksum(ndo, (const uint8_t *)header_lsp->lsp_id,
                         EXTRACT_16BITS(header_lsp->checksum),
                         12, length-12);
 
         ND_PRINT((ndo, "", PDU length: %u, Flags: [ %s"",
                pdu_len,
                ISIS_MASK_LSP_OL_BIT(header_lsp->typeblock) ? ""Overload bit set, "" : """"));
 
         if (ISIS_MASK_LSP_ATT_BITS(header_lsp->typeblock)) {
             ND_PRINT((ndo, ""%s"", ISIS_MASK_LSP_ATT_DEFAULT_BIT(header_lsp->typeblock) ? ""default "" : """"));
             ND_PRINT((ndo, ""%s"", ISIS_MASK_LSP_ATT_DELAY_BIT(header_lsp->typeblock) ? ""delay "" : """"));
             ND_PRINT((ndo, ""%s"", ISIS_MASK_LSP_ATT_EXPENSE_BIT(header_lsp->typeblock) ? ""expense "" : """"));
             ND_PRINT((ndo, ""%s"", ISIS_MASK_LSP_ATT_ERROR_BIT(header_lsp->typeblock) ? ""error "" : """"));
             ND_PRINT((ndo, ""ATT bit set, ""));
         }
         ND_PRINT((ndo, ""%s"", ISIS_MASK_LSP_PARTITION_BIT(header_lsp->typeblock) ? ""P bit set, "" : """"));
         ND_PRINT((ndo, ""%s ]"", tok2str(isis_lsp_istype_values, ""Unknown(0x%x)"",
                   ISIS_MASK_LSP_ISTYPE_BITS(header_lsp->typeblock))));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, pptr, ""\n\t  "", ISIS_LSP_HEADER_SIZE))
                 return (0);
         }
 
         packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
         pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_LSP_HEADER_SIZE);
         break;
 
     case ISIS_PDU_L1_CSNP:
     case ISIS_PDU_L2_CSNP:
         if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)) {
             ND_PRINT((ndo, "", bogus fixed header length %u should be %lu"",
                       isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)));
             return (0);
         }
         ND_TCHECK(*header_csnp);
         if (length < ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE)
             goto trunc;
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", src-id %s"", isis_print_id(header_csnp->source_id, NODE_ID_LEN)));
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
         pdu_len=EXTRACT_16BITS(header_csnp->pdu_len);
         if (packet_len>pdu_len) {
             packet_len=pdu_len;  
             length=pdu_len;
         }
 
         ND_PRINT((ndo, ""\n\t  source-id:    %s, PDU length: %u"",
                isis_print_id(header_csnp->source_id, NODE_ID_LEN),
                pdu_len));
         ND_PRINT((ndo, ""\n\t  start lsp-id: %s"",
                isis_print_id(header_csnp->start_lsp_id, LSP_ID_LEN)));
         ND_PRINT((ndo, ""\n\t  end lsp-id:   %s"",
                isis_print_id(header_csnp->end_lsp_id, LSP_ID_LEN)));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, pptr, ""\n\t  "", ISIS_CSNP_HEADER_SIZE))
                 return (0);
         }
 
         packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
         pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_CSNP_HEADER_SIZE);
         break;
 
     case ISIS_PDU_L1_PSNP:
     case ISIS_PDU_L2_PSNP:
         if (isis_header->fixed_len != (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)) {
             ND_PRINT((ndo, ""- bogus fixed header length %u should be %lu"",
                    isis_header->fixed_len, (unsigned long)(ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)));
             return (0);
         }
         ND_TCHECK(*header_psnp);
         if (length < ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE)
             goto trunc;
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", src-id %s"", isis_print_id(header_psnp->source_id, NODE_ID_LEN)));
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
         pdu_len=EXTRACT_16BITS(header_psnp->pdu_len);
         if (packet_len>pdu_len) {
             packet_len=pdu_len;  
             length=pdu_len;
         }
 
         ND_PRINT((ndo, ""\n\t  source-id:    %s, PDU length: %u"",
                isis_print_id(header_psnp->source_id, NODE_ID_LEN),
                pdu_len));
 
         if (ndo->ndo_vflag > 1) {
             if (!print_unknown_data(ndo, pptr, ""\n\t  "", ISIS_PSNP_HEADER_SIZE))
                 return (0);
         }
 
         packet_len -= (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
         pptr = p + (ISIS_COMMON_HEADER_SIZE+ISIS_PSNP_HEADER_SIZE);
         break;
 
     default:
         if (ndo->ndo_vflag == 0) {
             ND_PRINT((ndo, "", length %u"", length));
             return (1);
         }
 	(void)print_unknown_data(ndo, pptr, ""\n\t  "", length);
 	return (0);
     }
 
      
 
     while (packet_len > 0) {
 	ND_TCHECK2(*pptr, 2);
 	if (packet_len < 2)
 	    goto trunc;
 	tlv_type = *pptr++;
 	tlv_len = *pptr++;
         tmp =tlv_len;  
         tptr = pptr;
 	packet_len -= 2;
 
          
 	ND_PRINT((ndo, ""\n\t    %s TLV #%u, length: %u"",
                tok2str(isis_tlv_values,
                        ""unknown"",
                        tlv_type),
                tlv_type,
                tlv_len));
 
         if (tlv_len == 0)  
 	    continue;
 
 	if (packet_len < tlv_len)
 	    goto trunc;
 
          
 	switch (tlv_type) {
 	case ISIS_TLV_AREA_ADDR:
  	    ND_TCHECK2(*tptr, 1);
  	    alen = *tptr++;
  	    while (tmp && alen < tmp) {
 	        ND_TCHECK2(*tptr, alen);
  		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"",
                         alen,
                         isonsap_string(ndo, tptr, alen)));
 		tptr += alen;
 		tmp -= alen + 1;
 		if (tmp==0)  
                     break;
 		ND_TCHECK2(*tptr, 1);
 		alen = *tptr++;
 	    }
 	    break;
 	case ISIS_TLV_ISNEIGH:
 	    while (tmp >= ETHER_ADDR_LEN) {
                 ND_TCHECK2(*tptr, ETHER_ADDR_LEN);
                 ND_PRINT((ndo, ""\n\t      SNPA: %s"", isis_print_id(tptr, ETHER_ADDR_LEN)));
                 tmp -= ETHER_ADDR_LEN;
                 tptr += ETHER_ADDR_LEN;
 	    }
 	    break;
 
         case ISIS_TLV_ISNEIGH_VARLEN:
             if (!ND_TTEST2(*tptr, 1) || tmp < 3)  
 		goto trunctlv;
 	    lan_alen = *tptr++;  
 	    if (lan_alen == 0) {
                 ND_PRINT((ndo, ""\n\t      LAN address length 0 bytes (invalid)""));
                 break;
             }
             tmp --;
             ND_PRINT((ndo, ""\n\t      LAN address length %u bytes "", lan_alen));
 	    while (tmp >= lan_alen) {
                 ND_TCHECK2(*tptr, lan_alen);
                 ND_PRINT((ndo, ""\n\t\tIS Neighbor: %s"", isis_print_id(tptr, lan_alen)));
                 tmp -= lan_alen;
                 tptr +=lan_alen;
             }
             break;
 
 	case ISIS_TLV_PADDING:
 	    break;
 
         case ISIS_TLV_MT_IS_REACH:
             mt_len = isis_print_mtid(ndo, tptr, ""\n\t      "");
             if (mt_len == 0)  
                 goto trunctlv;
             tptr+=mt_len;
             tmp-=mt_len;
             while (tmp >= 2+NODE_ID_LEN+3+1) {
                 ext_is_len = isis_print_ext_is_reach(ndo, tptr, ""\n\t      "", tlv_type);
                 if (ext_is_len == 0)  
                     goto trunctlv;
 
                 tmp-=ext_is_len;
                 tptr+=ext_is_len;
             }
             break;
 
         case ISIS_TLV_IS_ALIAS_ID:
 	    while (tmp >= NODE_ID_LEN+1) {  
 	        ext_is_len = isis_print_ext_is_reach(ndo, tptr, ""\n\t      "", tlv_type);
 		if (ext_is_len == 0)  
 	            goto trunctlv;
 		tmp-=ext_is_len;
 		tptr+=ext_is_len;
 	    }
 	    break;
 
         case ISIS_TLV_EXT_IS_REACH:
             while (tmp >= NODE_ID_LEN+3+1) {  
                 ext_is_len = isis_print_ext_is_reach(ndo, tptr, ""\n\t      "", tlv_type);
                 if (ext_is_len == 0)  
                     goto trunctlv;
                 tmp-=ext_is_len;
                 tptr+=ext_is_len;
             }
             break;
         case ISIS_TLV_IS_REACH:
 	    ND_TCHECK2(*tptr,1);   
             ND_PRINT((ndo, ""\n\t      %s"",
                    tok2str(isis_is_reach_virtual_values,
                            ""bogus virtual flag 0x%02x"",
                            *tptr++)));
 	    tlv_is_reach = (const struct isis_tlv_is_reach *)tptr;
             while (tmp >= sizeof(struct isis_tlv_is_reach)) {
 		ND_TCHECK(*tlv_is_reach);
 		ND_PRINT((ndo, ""\n\t      IS Neighbor: %s"",
 		       isis_print_id(tlv_is_reach->neighbor_nodeid, NODE_ID_LEN)));
 		isis_print_metric_block(ndo, &tlv_is_reach->isis_metric_block);
 		tmp -= sizeof(struct isis_tlv_is_reach);
 		tlv_is_reach++;
 	    }
             break;
 
         case ISIS_TLV_ESNEIGH:
 	    tlv_es_reach = (const struct isis_tlv_es_reach *)tptr;
             while (tmp >= sizeof(struct isis_tlv_es_reach)) {
 		ND_TCHECK(*tlv_es_reach);
 		ND_PRINT((ndo, ""\n\t      ES Neighbor: %s"",
                        isis_print_id(tlv_es_reach->neighbor_sysid, SYSTEM_ID_LEN)));
 		isis_print_metric_block(ndo, &tlv_es_reach->isis_metric_block);
 		tmp -= sizeof(struct isis_tlv_es_reach);
 		tlv_es_reach++;
 	    }
             break;
 
              
 	case ISIS_TLV_INT_IP_REACH:
 	case ISIS_TLV_EXT_IP_REACH:
 		if (!isis_print_tlv_ip_reach(ndo, pptr, ""\n\t      "", tlv_len))
 			return (1);
 		break;
 
 	case ISIS_TLV_EXTD_IP_REACH:
 	    while (tmp>0) {
                 ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, ""\n\t      "", AF_INET);
                 if (ext_ip_len == 0)  
                     goto trunctlv;
                 tptr+=ext_ip_len;
 		tmp-=ext_ip_len;
 	    }
 	    break;
 
         case ISIS_TLV_MT_IP_REACH:
             mt_len = isis_print_mtid(ndo, tptr, ""\n\t      "");
             if (mt_len == 0) {  
                 goto trunctlv;
             }
             tptr+=mt_len;
             tmp-=mt_len;
 
             while (tmp>0) {
                 ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, ""\n\t      "", AF_INET);
                 if (ext_ip_len == 0)  
                     goto trunctlv;
                 tptr+=ext_ip_len;
 		tmp-=ext_ip_len;
 	    }
 	    break;
 
 	case ISIS_TLV_IP6_REACH:
 	    while (tmp>0) {
                 ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, ""\n\t      "", AF_INET6);
                 if (ext_ip_len == 0)  
                     goto trunctlv;
                 tptr+=ext_ip_len;
 		tmp-=ext_ip_len;
 	    }
 	    break;
 
 	case ISIS_TLV_MT_IP6_REACH:
             mt_len = isis_print_mtid(ndo, tptr, ""\n\t      "");
             if (mt_len == 0) {  
                 goto trunctlv;
             }
             tptr+=mt_len;
             tmp-=mt_len;
 
 	    while (tmp>0) {
                 ext_ip_len = isis_print_extd_ip_reach(ndo, tptr, ""\n\t      "", AF_INET6);
                 if (ext_ip_len == 0)  
                     goto trunctlv;
                 tptr+=ext_ip_len;
 		tmp-=ext_ip_len;
 	    }
 	    break;
 
 	case ISIS_TLV_IP6ADDR:
 	    while (tmp>=sizeof(struct in6_addr)) {
 		ND_TCHECK2(*tptr, sizeof(struct in6_addr));
 
                 ND_PRINT((ndo, ""\n\t      IPv6 interface address: %s"",
 		       ip6addr_string(ndo, tptr)));
 
 		tptr += sizeof(struct in6_addr);
 		tmp -= sizeof(struct in6_addr);
 	    }
 	    break;
 	case ISIS_TLV_AUTH:
 	    ND_TCHECK2(*tptr, 1);
 
             ND_PRINT((ndo, ""\n\t      %s: "",
                    tok2str(isis_subtlv_auth_values,
                            ""unknown Authentication type 0x%02x"",
                            *tptr)));
 
 	    switch (*tptr) {
 	    case ISIS_SUBTLV_AUTH_SIMPLE:
 		if (fn_printzp(ndo, tptr + 1, tlv_len - 1, ndo->ndo_snapend))
 		    goto trunctlv;
 		break;
 	    case ISIS_SUBTLV_AUTH_MD5:
 		for(i=1;i<tlv_len;i++) {
 		    ND_TCHECK2(*(tptr + i), 1);
 		    ND_PRINT((ndo, ""%02x"", *(tptr + i)));
 		}
 		if (tlv_len != ISIS_SUBTLV_AUTH_MD5_LEN+1)
                     ND_PRINT((ndo, "", (invalid subTLV) ""));
 
                 sigcheck = signature_verify(ndo, optr, length, tptr + 1,
                                             isis_clear_checksum_lifetime,
                                             header_lsp);
                 ND_PRINT((ndo, "" (%s)"", tok2str(signature_check_values, ""Unknown"", sigcheck)));
 
 		break;
             case ISIS_SUBTLV_AUTH_GENERIC:
 		ND_TCHECK2(*(tptr + 1), 2);
                 key_id = EXTRACT_16BITS((tptr+1));
                 ND_PRINT((ndo, ""%u, password: "", key_id));
                 for(i=1 + sizeof(uint16_t);i<tlv_len;i++) {
                     ND_TCHECK2(*(tptr + i), 1);
                     ND_PRINT((ndo, ""%02x"", *(tptr + i)));
                 }
                 break;
 	    case ISIS_SUBTLV_AUTH_PRIVATE:
 	    default:
 		if (!print_unknown_data(ndo, tptr + 1, ""\n\t\t  "", tlv_len - 1))
 		    return(0);
 		break;
 	    }
 	    break;
 
 	case ISIS_TLV_PTP_ADJ:
 	    tlv_ptp_adj = (const struct isis_tlv_ptp_adj *)tptr;
 	    if(tmp>=1) {
 		ND_TCHECK2(*tptr, 1);
 		ND_PRINT((ndo, ""\n\t      Adjacency State: %s (%u)"",
 		       tok2str(isis_ptp_adjancey_values, ""unknown"", *tptr),
                         *tptr));
 		tmp--;
 	    }
 	    if(tmp>sizeof(tlv_ptp_adj->extd_local_circuit_id)) {
 		ND_TCHECK(tlv_ptp_adj->extd_local_circuit_id);
 		ND_PRINT((ndo, ""\n\t      Extended Local circuit-ID: 0x%08x"",
 		       EXTRACT_32BITS(tlv_ptp_adj->extd_local_circuit_id)));
 		tmp-=sizeof(tlv_ptp_adj->extd_local_circuit_id);
 	    }
 	    if(tmp>=SYSTEM_ID_LEN) {
 		ND_TCHECK2(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN);
 		ND_PRINT((ndo, ""\n\t      Neighbor System-ID: %s"",
 		       isis_print_id(tlv_ptp_adj->neighbor_sysid, SYSTEM_ID_LEN)));
 		tmp-=SYSTEM_ID_LEN;
 	    }
 	    if(tmp>=sizeof(tlv_ptp_adj->neighbor_extd_local_circuit_id)) {
 		ND_TCHECK(tlv_ptp_adj->neighbor_extd_local_circuit_id);
 		ND_PRINT((ndo, ""\n\t      Neighbor Extended Local circuit-ID: 0x%08x"",
 		       EXTRACT_32BITS(tlv_ptp_adj->neighbor_extd_local_circuit_id)));
 	    }
 	    break;
 
 	case ISIS_TLV_PROTOCOLS:
 	    ND_PRINT((ndo, ""\n\t      NLPID(s): ""));
 	    while (tmp>0) {
 		ND_TCHECK2(*(tptr), 1);
 		ND_PRINT((ndo, ""%s (0x%02x)"",
                        tok2str(nlpid_values,
                                ""unknown"",
                                *tptr),
                        *tptr));
 		if (tmp>1)  
 		    ND_PRINT((ndo, "", ""));
                 tptr++;
                 tmp--;
 	    }
 	    break;
 
     case ISIS_TLV_MT_PORT_CAP:
     {
       ND_TCHECK2(*(tptr), 2);
 
       ND_PRINT((ndo, ""\n\t       RES: %d, MTID(s): %d"",
               (EXTRACT_16BITS (tptr) >> 12),
               (EXTRACT_16BITS (tptr) & 0x0fff)));
 
       tmp = tmp-2;
       tptr = tptr+2;
 
       if (tmp)
         isis_print_mt_port_cap_subtlv(ndo, tptr, tmp);
 
       break;
     }
 
     case ISIS_TLV_MT_CAPABILITY:
 
       ND_TCHECK2(*(tptr), 2);
 
       ND_PRINT((ndo, ""\n\t      O: %d, RES: %d, MTID(s): %d"",
                 (EXTRACT_16BITS(tptr) >> 15) & 0x01,
                 (EXTRACT_16BITS(tptr) >> 12) & 0x07,
                 EXTRACT_16BITS(tptr) & 0x0fff));
 
       tmp = tmp-2;
       tptr = tptr+2;
 
       if (tmp)
         isis_print_mt_capability_subtlv(ndo, tptr, tmp);
 
       break;
 
 	case ISIS_TLV_TE_ROUTER_ID:
 	    ND_TCHECK2(*pptr, sizeof(struct in_addr));
 	    ND_PRINT((ndo, ""\n\t      Traffic Engineering Router ID: %s"", ipaddr_string(ndo, pptr)));
 	    break;
 
 	case ISIS_TLV_IPADDR:
 	    while (tmp>=sizeof(struct in_addr)) {
 		ND_TCHECK2(*tptr, sizeof(struct in_addr));
 		ND_PRINT((ndo, ""\n\t      IPv4 interface address: %s"", ipaddr_string(ndo, tptr)));
 		tptr += sizeof(struct in_addr);
 		tmp -= sizeof(struct in_addr);
 	    }
 	    break;
 
 	case ISIS_TLV_HOSTNAME:
 	    ND_PRINT((ndo, ""\n\t      Hostname: ""));
 	    if (fn_printzp(ndo, tptr, tmp, ndo->ndo_snapend))
 		goto trunctlv;
 	    break;
 
 	case ISIS_TLV_SHARED_RISK_GROUP:
 	    if (tmp < NODE_ID_LEN)
 	        break;
 	    ND_TCHECK2(*tptr, NODE_ID_LEN);
 	    ND_PRINT((ndo, ""\n\t      IS Neighbor: %s"", isis_print_id(tptr, NODE_ID_LEN)));
 	    tptr+=(NODE_ID_LEN);
 	    tmp-=(NODE_ID_LEN);
 
 	    if (tmp < 1)
 	        break;
 	    ND_TCHECK2(*tptr, 1);
 	    ND_PRINT((ndo, "", Flags: [%s]"", ISIS_MASK_TLV_SHARED_RISK_GROUP(*tptr++) ? ""numbered"" : ""unnumbered""));
 	    tmp--;
 
 	    if (tmp < sizeof(struct in_addr))
 	        break;
 	    ND_TCHECK2(*tptr, sizeof(struct in_addr));
 	    ND_PRINT((ndo, ""\n\t      IPv4 interface address: %s"", ipaddr_string(ndo, tptr)));
 	    tptr+=sizeof(struct in_addr);
 	    tmp-=sizeof(struct in_addr);
 
 	    if (tmp < sizeof(struct in_addr))
 	        break;
 	    ND_TCHECK2(*tptr, sizeof(struct in_addr));
 	    ND_PRINT((ndo, ""\n\t      IPv4 neighbor address: %s"", ipaddr_string(ndo, tptr)));
 	    tptr+=sizeof(struct in_addr);
 	    tmp-=sizeof(struct in_addr);
 
 	    while (tmp>=4) {
                 ND_TCHECK2(*tptr, 4);
                 ND_PRINT((ndo, ""\n\t      Link-ID: 0x%08x"", EXTRACT_32BITS(tptr)));
                 tptr+=4;
                 tmp-=4;
 	    }
 	    break;
 
 	case ISIS_TLV_LSP:
 	    tlv_lsp = (const struct isis_tlv_lsp *)tptr;
 	    while(tmp>=sizeof(struct isis_tlv_lsp)) {
 		ND_TCHECK((tlv_lsp->lsp_id)[LSP_ID_LEN-1]);
 		ND_PRINT((ndo, ""\n\t      lsp-id: %s"",
                        isis_print_id(tlv_lsp->lsp_id, LSP_ID_LEN)));
 		ND_TCHECK2(tlv_lsp->sequence_number, 4);
 		ND_PRINT((ndo, "", seq: 0x%08x"", EXTRACT_32BITS(tlv_lsp->sequence_number)));
 		ND_TCHECK2(tlv_lsp->remaining_lifetime, 2);
 		ND_PRINT((ndo, "", lifetime: %5ds"", EXTRACT_16BITS(tlv_lsp->remaining_lifetime)));
 		ND_TCHECK2(tlv_lsp->checksum, 2);
 		ND_PRINT((ndo, "", chksum: 0x%04x"", EXTRACT_16BITS(tlv_lsp->checksum)));
 		tmp-=sizeof(struct isis_tlv_lsp);
 		tlv_lsp++;
 	    }
 	    break;
 
 	case ISIS_TLV_CHECKSUM:
 	    if (tmp < ISIS_TLV_CHECKSUM_MINLEN)
 	        break;
 	    ND_TCHECK2(*tptr, ISIS_TLV_CHECKSUM_MINLEN);
 	    ND_PRINT((ndo, ""\n\t      checksum: 0x%04x "", EXTRACT_16BITS(tptr)));
              
             osi_print_cksum(ndo, optr, EXTRACT_16BITS(tptr), tptr-optr,
                 length);
 	    break;
 
 	case ISIS_TLV_POI:
 	    if (tlv_len >= SYSTEM_ID_LEN + 1) {
 		ND_TCHECK2(*tptr, SYSTEM_ID_LEN + 1);
 		ND_PRINT((ndo, ""\n\t      Purge Originator System-ID: %s"",
 		       isis_print_id(tptr + 1, SYSTEM_ID_LEN)));
 	    }
 
 	    if (tlv_len == 2 * SYSTEM_ID_LEN + 1) {
 		ND_TCHECK2(*tptr, 2 * SYSTEM_ID_LEN + 1);
 		ND_PRINT((ndo, ""\n\t      Received from System-ID: %s"",
 		       isis_print_id(tptr + SYSTEM_ID_LEN + 1, SYSTEM_ID_LEN)));
 	    }
 	    break;
 
 	case ISIS_TLV_MT_SUPPORTED:
             if (tmp < ISIS_TLV_MT_SUPPORTED_MINLEN)
                 break;
 	    while (tmp>1) {
 		 
 		if (tmp!=1) {
                     mt_len = isis_print_mtid(ndo, tptr, ""\n\t      "");
                     if (mt_len == 0)  
                         goto trunctlv;
                     tptr+=mt_len;
                     tmp-=mt_len;
 		} else {
 		    ND_PRINT((ndo, ""\n\t      invalid MT-ID""));
 		    break;
 		}
 	    }
 	    break;
 
 	case ISIS_TLV_RESTART_SIGNALING:
              
             if (tmp < ISIS_TLV_RESTART_SIGNALING_FLAGLEN)
                 break;
             ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_FLAGLEN);
             ND_PRINT((ndo, ""\n\t      Flags [%s]"",
                    bittok2str(isis_restart_flag_values, ""none"", *tptr)));
             tptr+=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
             tmp-=ISIS_TLV_RESTART_SIGNALING_FLAGLEN;
 
              
             if (tmp == 0)
                 break;
 
             if (tmp < ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN)
                 break;
             ND_TCHECK2(*tptr, ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN);
 
             ND_PRINT((ndo, "", Remaining holding time %us"", EXTRACT_16BITS(tptr)));
             tptr+=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
             tmp-=ISIS_TLV_RESTART_SIGNALING_HOLDTIMELEN;
 
              
             if (tmp == SYSTEM_ID_LEN) {
                     ND_TCHECK2(*tptr, SYSTEM_ID_LEN);
                     ND_PRINT((ndo, "", for %s"", isis_print_id(tptr,SYSTEM_ID_LEN)));
             }
 	    break;
 
         case ISIS_TLV_IDRP_INFO:
 	    if (tmp < ISIS_TLV_IDRP_INFO_MINLEN)
 	        break;
             ND_TCHECK2(*tptr, ISIS_TLV_IDRP_INFO_MINLEN);
             ND_PRINT((ndo, ""\n\t      Inter-Domain Information Type: %s"",
                    tok2str(isis_subtlv_idrp_values,
                            ""Unknown (0x%02x)"",
                            *tptr)));
             switch (*tptr++) {
             case ISIS_SUBTLV_IDRP_ASN:
                 ND_TCHECK2(*tptr, 2);  
                 ND_PRINT((ndo, ""AS Number: %u"", EXTRACT_16BITS(tptr)));
                 break;
             case ISIS_SUBTLV_IDRP_LOCAL:
             case ISIS_SUBTLV_IDRP_RES:
             default:
                 if (!print_unknown_data(ndo, tptr, ""\n\t      "", tlv_len - 1))
                     return(0);
                 break;
             }
             break;
 
         case ISIS_TLV_LSP_BUFFERSIZE:
 	    if (tmp < ISIS_TLV_LSP_BUFFERSIZE_MINLEN)
 	        break;
             ND_TCHECK2(*tptr, ISIS_TLV_LSP_BUFFERSIZE_MINLEN);
             ND_PRINT((ndo, ""\n\t      LSP Buffersize: %u"", EXTRACT_16BITS(tptr)));
             break;
 
         case ISIS_TLV_PART_DIS:
             while (tmp >= SYSTEM_ID_LEN) {
                 ND_TCHECK2(*tptr, SYSTEM_ID_LEN);
                 ND_PRINT((ndo, ""\n\t      %s"", isis_print_id(tptr, SYSTEM_ID_LEN)));
                 tptr+=SYSTEM_ID_LEN;
                 tmp-=SYSTEM_ID_LEN;
             }
             break;
 
         case ISIS_TLV_PREFIX_NEIGH:
 	    if (tmp < sizeof(struct isis_metric_block))
 	        break;
             ND_TCHECK2(*tptr, sizeof(struct isis_metric_block));
             ND_PRINT((ndo, ""\n\t      Metric Block""));
             isis_print_metric_block(ndo, (const struct isis_metric_block *)tptr);
             tptr+=sizeof(struct isis_metric_block);
             tmp-=sizeof(struct isis_metric_block);
 
             while(tmp>0) {
                 ND_TCHECK2(*tptr, 1);
                 prefix_len=*tptr++;  
                 if (prefix_len < 2) {
                     ND_PRINT((ndo, ""\n\t\tAddress: prefix length %u < 2"", prefix_len));
                     break;
                 }
                 tmp--;
                 if (tmp < prefix_len/2)
                     break;
                 ND_TCHECK2(*tptr, prefix_len / 2);
                 ND_PRINT((ndo, ""\n\t\tAddress: %s/%u"",
                        isonsap_string(ndo, tptr, prefix_len / 2), prefix_len * 4));
                 tptr+=prefix_len/2;
                 tmp-=prefix_len/2;
             }
             break;
 
         case ISIS_TLV_IIH_SEQNR:
 	    if (tmp < ISIS_TLV_IIH_SEQNR_MINLEN)
 	        break;
             ND_TCHECK2(*tptr, ISIS_TLV_IIH_SEQNR_MINLEN);  
             ND_PRINT((ndo, ""\n\t      Sequence number: %u"", EXTRACT_32BITS(tptr)));
             break;
 
         case ISIS_TLV_VENDOR_PRIVATE:
 	    if (tmp < ISIS_TLV_VENDOR_PRIVATE_MINLEN)
 	        break;
             ND_TCHECK2(*tptr, ISIS_TLV_VENDOR_PRIVATE_MINLEN);  
             vendor_id = EXTRACT_24BITS(tptr);
             ND_PRINT((ndo, ""\n\t      Vendor: %s (%u)"",
                    tok2str(oui_values, ""Unknown"", vendor_id),
                    vendor_id));
             tptr+=3;
             tmp-=3;
             if (tmp > 0)  
                 if (!print_unknown_data(ndo, tptr, ""\n\t\t"", tmp))
                     return(0);
             break;
              
 
         case ISIS_TLV_DECNET_PHASE4:
         case ISIS_TLV_LUCENT_PRIVATE:
         case ISIS_TLV_IPAUTH:
         case ISIS_TLV_NORTEL_PRIVATE1:
         case ISIS_TLV_NORTEL_PRIVATE2:
 
 	default:
 		if (ndo->ndo_vflag <= 1) {
 			if (!print_unknown_data(ndo, pptr, ""\n\t\t"", tlv_len))
 				return(0);
 		}
 		break;
 	}
          
 	if (ndo->ndo_vflag> 1) {
 		if (!print_unknown_data(ndo, pptr, ""\n\t      "", tlv_len))
 			return(0);
 	}
 
 	pptr += tlv_len;
 	packet_len -= tlv_len;
     }
 
     if (packet_len != 0) {
 	ND_PRINT((ndo, ""\n\t      %u straggler bytes"", packet_len));
     }
     return (1);
 
  trunc:
     ND_PRINT((ndo, ""%s"", tstr));
     return (1);
 
  trunctlv:
     ND_PRINT((ndo, ""\n\t\t""));
     ND_PRINT((ndo, ""%s"", tstr));
     return(1);
 }",[395],The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().
203335," static int b_unpack (lua_State *L) {
   Header h;
   const char *fmt = luaL_checkstring(L, 1);
    size_t ld;
    const char *data = luaL_checklstring(L, 2, &ld);
    size_t pos = luaL_optinteger(L, 3, 1) - 1;
   int n = 0;   
    defaultoptions(&h);
  lua_settop(L, 2);
    while (*fmt) {
      int opt = *fmt++;
      size_t size = optsize(L, opt, &fmt);
      pos += gettoalign(pos, &h, opt, size);
      luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
    luaL_checkstack(L, 1, ""too many results"");
      
     luaL_checkstack(L, 2, ""too many results"");
      switch (opt) {
        case 'b': case 'B': case 'h': case 'H':
        case 'l': case 'L': case 'T': case 'i':  case 'I': {   
          int issigned = islower(opt);
          lua_Number res = getinteger(data+pos, h.endian, issigned, size);
        lua_pushnumber(L, res);
         lua_pushnumber(L, res); n++;
          break;
        }
        case 'x': {
         break;
       }
       case 'f': {
          float f;
          memcpy(&f, data+pos, size);
          correctbytes((char *)&f, sizeof(f), h.endian);
        lua_pushnumber(L, f);
         lua_pushnumber(L, f); n++;
          break;
        }
        case 'd': {
          double d;
          memcpy(&d, data+pos, size);
          correctbytes((char *)&d, sizeof(d), h.endian);
        lua_pushnumber(L, d);
         lua_pushnumber(L, d); n++;
          break;
        }
        case 'c': {
          if (size == 0) {
          if (!lua_isnumber(L, -1))
            luaL_error(L, ""format `c0' needs a previous size"");
           if (n == 0 || !lua_isnumber(L, -1))
             luaL_error(L, ""format 'c0' needs a previous size"");
            size = lua_tonumber(L, -1);
          lua_pop(L, 1);
          luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
           lua_pop(L, 1); n--;
           luaL_argcheck(L, size <= ld && pos <= ld - size,
                            2, ""data string too short"");
          }
        lua_pushlstring(L, data+pos, size);
         lua_pushlstring(L, data+pos, size); n++;
          break;
        }
        case 's': {
          const char *e = (const char *)memchr(data+pos, '\0', ld - pos);
          if (e == NULL)
            luaL_error(L, ""unfinished string in data"");
          size = (e - (data+pos)) + 1;
        lua_pushlstring(L, data+pos, size - 1);
         lua_pushlstring(L, data+pos, size - 1); n++;
          break;
        }
        default: controloptions(L, opt, &fmt, &h);
      }
      pos += size;
    }
  lua_pushinteger(L, pos + 1);
  return lua_gettop(L) - 2;
   lua_pushinteger(L, pos + 1);   
   return n + 1;
  }","[7, 16, 17, 24, 35, 43, 50, 51, 55, 56, 57, 60, 69, 78, 79, 9, 15, 23, 34, 42, 48, 49, 53, 54, 59, 68, 76, 77]","An Integer Overflow issue was discovered in the struct library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2, leading to a failure of bounds checking."
200112," static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)
 {
 	zval *retval_ptr = NULL;
 	zval fname;
 
 	if (Z_TYPE_PP(rval) != IS_OBJECT) {
 		return 0;
 	}
 
 	if (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {
  	     
  	    if(Z_TYPE_PP(rval) == IS_OBJECT) {
  	       zend_hash_clean(Z_OBJPROP_PP(rval));
 	       zend_object_store_ctor_failed(*rval TSRMLS_CC);
  	    }
  	    ZVAL_NULL(*rval);
  		return 0;
 	}
 
     if (Z_TYPE_PP(rval) != IS_OBJECT) {
         return 0;
     }
 
 	if (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&
 		zend_hash_exists(&Z_OBJCE_PP(rval)->function_table, ""__wakeup"", sizeof(""__wakeup""))) {
 		INIT_PZVAL(&fname);
 		ZVAL_STRINGL(&fname, ""__wakeup"", sizeof(""__wakeup"") - 1, 0);
 		BG(serialize_lock)++;
 		call_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);
 		BG(serialize_lock)--;
 	}
 
 	if (retval_ptr) {
 		zval_ptr_dtor(&retval_ptr);
 	}
 
 	if (EG(exception)) {
 		return 0;
 	}
 
 	return finish_nested_data(UNSERIALIZE_PASSTHRU);
 
 }",[14],"ext/standard/var_unserializer.re in PHP before 5.6.26 mishandles object-deserialization failures, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via an unserialize call that references a partially constructed object."
204605," void SignatureUtil::CheckSignature(
     const FilePath& file_path,
     ClientDownloadRequest_SignatureInfo* signature_info) {
   VLOG(2) << ""Checking signature for "" << file_path.value();
 
   WINTRUST_FILE_INFO file_info;
   file_info.cbStruct = sizeof(file_info);
   file_info.pcwszFilePath = file_path.value().c_str();
   file_info.hFile = NULL;
   file_info.pgKnownSubject = NULL;
 
   WINTRUST_DATA wintrust_data;
   wintrust_data.cbStruct = sizeof(wintrust_data);
   wintrust_data.pPolicyCallbackData = NULL;
   wintrust_data.pSIPClientData = NULL;
   wintrust_data.dwUIChoice = WTD_UI_NONE;
   wintrust_data.fdwRevocationChecks = WTD_REVOKE_NONE;
   wintrust_data.dwUnionChoice = WTD_CHOICE_FILE;
   wintrust_data.pFile = &file_info;
   wintrust_data.dwStateAction = WTD_STATEACTION_VERIFY;
   wintrust_data.hWVTStateData = NULL;
   wintrust_data.pwszURLReference = NULL;
   wintrust_data.dwProvFlags = WTD_CACHE_ONLY_URL_RETRIEVAL;
   wintrust_data.dwUIContext = WTD_UICONTEXT_EXECUTE;
 
   GUID policy_guid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
 
   LONG result = WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),
                                &policy_guid,
                                &wintrust_data);
 
   CRYPT_PROVIDER_DATA* prov_data = WTHelperProvDataFromStateData(
       wintrust_data.hWVTStateData);
   if (prov_data) {
     if (prov_data->csSigners > 0) {
       signature_info->set_trusted(result == ERROR_SUCCESS);
     }
      for (DWORD i = 0; i < prov_data->csSigners; ++i) {
        const CERT_CHAIN_CONTEXT* cert_chain_context =
            prov_data->pasSigners[i].pChainContext;
       if (!cert_chain_context)
         break;
        for (DWORD j = 0; j < cert_chain_context->cChain; ++j) {
          CERT_SIMPLE_CHAIN* simple_chain = cert_chain_context->rgpChain[j];
          ClientDownloadRequest_CertificateChain* chain =
              signature_info->add_certificate_chain();
         if (!simple_chain)
           break;
          for (DWORD k = 0; k < simple_chain->cElement; ++k) {
            CERT_CHAIN_ELEMENT* element = simple_chain->rgpElement[k];
            chain->add_element()->set_certificate(
               element->pCertContext->pbCertEncoded,
               element->pCertContext->cbCertEncoded);
         }
       }
     }
 
     wintrust_data.dwStateAction = WTD_STATEACTION_CLOSE;
     WinVerifyTrust(static_cast<HWND>(INVALID_HANDLE_VALUE),
                    &policy_guid, &wintrust_data);
   }
 }","[41, 42, 47, 48]","Google Chrome before 17.0.963.46 does not properly check signatures, which allows remote attackers to cause a denial of service (application crash) via unspecified vectors."
10124,"rsa_oaep_sha1_decrypt(const struct rsa_private_key *key,
size_t label_length, const uint8_t *label,
size_t *length, uint8_t *message,
const mpz_t gibberish)
{
mpz_t m;
int res;
struct sha1_ctx ctx;

mpz_init(m);
rsa_compute_root(key, m, gibberish);

res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,
&ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,
label_length, label, length, message);
mpz_clear(m);
return res;
}",[10],Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token.
207926," static int sysMapFD(int fd, MemMapping* pMap)
 {
  off_t start;
  size_t length;
  void* memPtr;
 
     assert(pMap != NULL);
 
  if (getFileStartAndLength(fd, &start, &length) < 0)
  return -1;
 
     memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
  if (memPtr == MAP_FAILED) {
         LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
             fd, (int) start, strerror(errno));
  return -1;
  }
 
     pMap->addr = memPtr;
 
      pMap->length = length;
      pMap->range_count = 1;
      pMap->ranges = malloc(sizeof(MappedRange));
     if (pMap->ranges == NULL) {
         LOGE(""malloc failed: %s\n"", strerror(errno));
         munmap(memPtr, length);
         return -1;
     }
      pMap->ranges[0].addr = memPtr;
      pMap->ranges[0].length = length;
  
  return 0;
 }","[24, 25, 26, 27, 28]","Multiple integer overflows in minzip/SysUtil.c in the Recovery Procedure in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allow attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26960931."
200083," int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)
 {
 	mpi_ptr_t mp_marker = NULL, bp_marker = NULL, ep_marker = NULL;
 	mpi_ptr_t xp_marker = NULL;
 	mpi_ptr_t tspace = NULL;
 	mpi_ptr_t rp, ep, mp, bp;
 	mpi_size_t esize, msize, bsize, rsize;
 	int esign, msign, bsign, rsign;
 	mpi_size_t size;
 	int mod_shift_cnt;
 	int negative_result;
 	int assign_rp = 0;
 	mpi_size_t tsize = 0;	 
 	 
 	int rc = -ENOMEM;
 
 	esize = exp->nlimbs;
 	msize = mod->nlimbs;
 	size = 2 * msize;
 	esign = exp->sign;
 	msign = mod->sign;
 
 	rp = res->d;
 	ep = exp->d;
 
 	if (!msize)
 		return -EINVAL;
 
  	if (!esize) {
  		 
		rp[0] = 1;
  		res->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;
 		if (res->nlimbs) {
 			if (mpi_resize(res, 1) < 0)
 				goto enomem;
 			rp = res->d;
 			rp[0] = 1;
 		}
  		res->sign = 0;
  		goto leave;
  	}
 
 	 
 	mp = mp_marker = mpi_alloc_limb_space(msize);
 	if (!mp)
 		goto enomem;
 	mod_shift_cnt = count_leading_zeros(mod->d[msize - 1]);
 	if (mod_shift_cnt)
 		mpihelp_lshift(mp, mod->d, msize, mod_shift_cnt);
 	else
 		MPN_COPY(mp, mod->d, msize);
 
 	bsize = base->nlimbs;
 	bsign = base->sign;
 	if (bsize > msize) {	 
 		 
 		bp = bp_marker = mpi_alloc_limb_space(bsize + 1);
 		if (!bp)
 			goto enomem;
 		MPN_COPY(bp, base->d, bsize);
 		 
 		mpihelp_divrem(bp + msize, 0, bp, bsize, mp, msize);
 		bsize = msize;
 		 
 		MPN_NORMALIZE(bp, bsize);
 	} else
 		bp = base->d;
 
 	if (!bsize) {
 		res->nlimbs = 0;
 		res->sign = 0;
 		goto leave;
 	}
 
 	if (res->alloced < size) {
 		 
 		if (rp == ep || rp == mp || rp == bp) {
 			rp = mpi_alloc_limb_space(size);
 			if (!rp)
 				goto enomem;
 			assign_rp = 1;
 		} else {
 			if (mpi_resize(res, size) < 0)
 				goto enomem;
 			rp = res->d;
 		}
 	} else {		 
 		if (rp == bp) {
 			 
 			BUG_ON(bp_marker);
 			bp = bp_marker = mpi_alloc_limb_space(bsize);
 			if (!bp)
 				goto enomem;
 			MPN_COPY(bp, rp, bsize);
 		}
 		if (rp == ep) {
 			 
 			ep = ep_marker = mpi_alloc_limb_space(esize);
 			if (!ep)
 				goto enomem;
 			MPN_COPY(ep, rp, esize);
 		}
 		if (rp == mp) {
 			 
 			BUG_ON(mp_marker);
 			mp = mp_marker = mpi_alloc_limb_space(msize);
 			if (!mp)
 				goto enomem;
 			MPN_COPY(mp, rp, msize);
 		}
 	}
 
 	MPN_COPY(rp, bp, bsize);
 	rsize = bsize;
 	rsign = bsign;
 
 	{
 		mpi_size_t i;
 		mpi_ptr_t xp;
 		int c;
 		mpi_limb_t e;
 		mpi_limb_t carry_limb;
 		struct karatsuba_ctx karactx;
 
 		xp = xp_marker = mpi_alloc_limb_space(2 * (msize + 1));
 		if (!xp)
 			goto enomem;
 
 		memset(&karactx, 0, sizeof karactx);
 		negative_result = (ep[0] & 1) && base->sign;
 
 		i = esize - 1;
 		e = ep[i];
 		c = count_leading_zeros(e);
 		e = (e << c) << 1;	 
 		c = BITS_PER_MPI_LIMB - 1 - c;
 
 		 
 
 		for (;;) {
 			while (c) {
 				mpi_ptr_t tp;
 				mpi_size_t xsize;
 
 				 
 				if (rsize < KARATSUBA_THRESHOLD)
 					mpih_sqr_n_basecase(xp, rp, rsize);
 				else {
 					if (!tspace) {
 						tsize = 2 * rsize;
 						tspace =
 						    mpi_alloc_limb_space(tsize);
 						if (!tspace)
 							goto enomem;
 					} else if (tsize < (2 * rsize)) {
 						mpi_free_limb_space(tspace);
 						tsize = 2 * rsize;
 						tspace =
 						    mpi_alloc_limb_space(tsize);
 						if (!tspace)
 							goto enomem;
 					}
 					mpih_sqr_n(xp, rp, rsize, tspace);
 				}
 
 				xsize = 2 * rsize;
 				if (xsize > msize) {
 					mpihelp_divrem(xp + msize, 0, xp, xsize,
 						       mp, msize);
 					xsize = msize;
 				}
 
 				tp = rp;
 				rp = xp;
 				xp = tp;
 				rsize = xsize;
 
 				if ((mpi_limb_signed_t) e < 0) {
 					 
 					if (bsize < KARATSUBA_THRESHOLD) {
 						mpi_limb_t tmp;
 						if (mpihelp_mul
 						    (xp, rp, rsize, bp, bsize,
 						     &tmp) < 0)
 							goto enomem;
 					} else {
 						if (mpihelp_mul_karatsuba_case
 						    (xp, rp, rsize, bp, bsize,
 						     &karactx) < 0)
 							goto enomem;
 					}
 
 					xsize = rsize + bsize;
 					if (xsize > msize) {
 						mpihelp_divrem(xp + msize, 0,
 							       xp, xsize, mp,
 							       msize);
 						xsize = msize;
 					}
 
 					tp = rp;
 					rp = xp;
 					xp = tp;
 					rsize = xsize;
 				}
 				e <<= 1;
 				c--;
 			}
 
 			i--;
 			if (i < 0)
 				break;
 			e = ep[i];
 			c = BITS_PER_MPI_LIMB;
 		}
 
 		 
 		if (mod_shift_cnt) {
 			carry_limb =
 			    mpihelp_lshift(res->d, rp, rsize, mod_shift_cnt);
 			rp = res->d;
 			if (carry_limb) {
 				rp[rsize] = carry_limb;
 				rsize++;
 			}
 		} else {
 			MPN_COPY(res->d, rp, rsize);
 			rp = res->d;
 		}
 
 		if (rsize >= msize) {
 			mpihelp_divrem(rp + msize, 0, rp, rsize, mp, msize);
 			rsize = msize;
 		}
 
 		 
 		if (mod_shift_cnt)
 			mpihelp_rshift(rp, rp, rsize, mod_shift_cnt);
 		MPN_NORMALIZE(rp, rsize);
 
 		mpihelp_release_karatsuba_ctx(&karactx);
 	}
 
 	if (negative_result && rsize) {
 		if (mod_shift_cnt)
 			mpihelp_rshift(mp, mp, msize, mod_shift_cnt);
 		mpihelp_sub(rp, mp, msize, rp, rsize);
 		rsize = msize;
 		rsign = msign;
 		MPN_NORMALIZE(rp, rsize);
 	}
 	res->nlimbs = rsize;
 	res->sign = rsign;
 
 leave:
 	rc = 0;
 enomem:
 	if (assign_rp)
 		mpi_assign_limb_space(res, rp, size);
 	if (mp_marker)
 		mpi_free_limb_space(mp_marker);
 	if (bp_marker)
 		mpi_free_limb_space(bp_marker);
 	if (ep_marker)
 		mpi_free_limb_space(ep_marker);
 	if (xp_marker)
 		mpi_free_limb_space(xp_marker);
 	if (tspace)
 		mpi_free_limb_space(tspace);
 	return rc;
 }","[33, 34, 35, 36, 37, 38, 31]","The mpi_powm function in lib/mpi/mpi-pow.c in the Linux kernel through 4.8.11 does not ensure that memory is allocated for limb data, which allows local users to cause a denial of service (stack memory corruption and panic) via an add_key system call for an RSA key with a zero exponent."
202766," MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,
   ExceptionInfo *exception)
 {
 #define ComplexImageTag  ""Complex/Image""
 
   CacheView
     *Ai_view,
     *Ar_view,
     *Bi_view,
     *Br_view,
     *Ci_view,
     *Cr_view;
 
   const char
     *artifact;
 
   const Image
     *Ai_image,
     *Ar_image,
     *Bi_image,
     *Br_image;
 
   double
     snr;
 
   Image
     *Ci_image,
     *complex_images,
     *Cr_image,
     *image;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     progress;
 
   ssize_t
     y;
 
   assert(images != (Image *) NULL);
   assert(images->signature == MagickCoreSignature);
   if (images->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",images->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   if (images->next == (Image *) NULL)
     {
       (void) ThrowMagickException(exception,GetMagickModule(),ImageError,
         ""ImageSequenceRequired"",""`%s'"",images->filename);
       return((Image *) NULL);
     }
   image=CloneImage(images,0,0,MagickTrue,exception);
   if (image == (Image *) NULL)
     return((Image *) NULL);
   if (SetImageStorageClass(image,DirectClass) == MagickFalse)
     {
       image=DestroyImageList(image);
       return(image);
     }
   image->depth=32UL;
   complex_images=NewImageList();
   AppendImageToList(&complex_images,image);
   image=CloneImage(images,0,0,MagickTrue,exception);
   if (image == (Image *) NULL)
     {
       complex_images=DestroyImageList(complex_images);
       return(complex_images);
     }
   AppendImageToList(&complex_images,image);
    
   artifact=GetImageArtifact(image,""complex:snr"");
   snr=0.0;
   if (artifact != (const char *) NULL)
     snr=StringToDouble(artifact,(char **) NULL);
   Ar_image=images;
   Ai_image=images->next;
   Br_image=images;
   Bi_image=images->next;
   if ((images->next->next != (Image *) NULL) &&
       (images->next->next->next != (Image *) NULL))
     {
       Br_image=images->next->next;
       Bi_image=images->next->next->next;
     }
   Cr_image=complex_images;
   Ci_image=complex_images->next;
   Ar_view=AcquireVirtualCacheView(Ar_image,exception);
   Ai_view=AcquireVirtualCacheView(Ai_image,exception);
   Br_view=AcquireVirtualCacheView(Br_image,exception);
   Bi_view=AcquireVirtualCacheView(Bi_image,exception);
   Cr_view=AcquireAuthenticCacheView(Cr_image,exception);
   Ci_view=AcquireAuthenticCacheView(Ci_image,exception);
   status=MagickTrue;
    progress=0;
  #if defined(MAGICKCORE_OPENMP_SUPPORT)
    #pragma omp parallel for schedule(static) shared(progress,status) \
    magick_number_threads(images,complex_images,images->rows,1L)
     magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)
  #endif
  for (y=0; y < (ssize_t) images->rows; y++)
   for (y=0; y < (ssize_t) Cr_image->rows; y++)
    {
      register const PixelPacket
        *magick_restrict Ai,
       *magick_restrict Ar,
       *magick_restrict Bi,
       *magick_restrict Br;
 
     register PixelPacket
       *magick_restrict Ci,
       *magick_restrict Cr;
 
     register ssize_t
       x;
  
      if (status == MagickFalse)
        continue;
    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,
      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);
    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,
      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);
    Br=GetCacheViewVirtualPixels(Br_view,0,y,
      MagickMax(Br_image->columns,Cr_image->columns),1,exception);
    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,
      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);
     Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);
     Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);
     Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);
     Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);
      Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);
      Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);
      if ((Ar == (const PixelPacket *) NULL) ||
         (Ai == (const PixelPacket *) NULL) ||
         (Br == (const PixelPacket *) NULL) ||
         (Bi == (const PixelPacket *) NULL) ||
         (Cr == (PixelPacket *) NULL) || (Ci == (PixelPacket *) NULL))
       {
          status=MagickFalse;
          continue;
        }
    for (x=0; x < (ssize_t) images->columns; x++)
     for (x=0; x < (ssize_t) Cr_image->columns; x++)
      {
        switch (op)
        {
         case AddComplexOperator:
         {
           Cr->red=Ar->red+Br->red;
           Ci->red=Ai->red+Bi->red;
           Cr->green=Ar->green+Br->green;
           Ci->green=Ai->green+Bi->green;
           Cr->blue=Ar->blue+Br->blue;
           Ci->blue=Ai->blue+Bi->blue;
           if (images->matte != MagickFalse)
             {
               Cr->opacity=Ar->opacity+Br->opacity;
               Ci->opacity=Ai->opacity+Bi->opacity;
             }
           break;
         }
         case ConjugateComplexOperator:
         default:
         {
           Cr->red=Ar->red;
           Ci->red=(-Bi->red);
           Cr->green=Ar->green;
           Ci->green=(-Bi->green);
           Cr->blue=Ar->blue;
           Ci->blue=(-Bi->blue);
           if (images->matte != MagickFalse)
             {
               Cr->opacity=Ar->opacity;
               Ci->opacity=(-Bi->opacity);
             }
           break;
         }
         case DivideComplexOperator:
         {
           double
              gamma;
  
            gamma=PerceptibleReciprocal(Br->red*Br->red+Bi->red*Bi->red+snr);
          Cr->red=gamma*(Ar->red*Br->red+Ai->red*Bi->red);
          Ci->red=gamma*(Ai->red*Br->red-Ar->red*Bi->red);
          gamma=PerceptibleReciprocal(Br->green*Br->green+Bi->green*Bi->green+
            snr);
          Cr->green=gamma*(Ar->green*Br->green+Ai->green*Bi->green);
          Ci->green=gamma*(Ai->green*Br->green-Ar->green*Bi->green);
          gamma=PerceptibleReciprocal(Br->blue*Br->blue+Bi->blue*Bi->blue+snr);
          Cr->blue=gamma*(Ar->blue*Br->blue+Ai->blue*Bi->blue);
          Ci->blue=gamma*(Ai->blue*Br->blue-Ar->blue*Bi->blue);
           Cr->red=gamma*((double) Ar->red*Br->red+(double) Ai->red*Bi->red);
           Ci->red=gamma*((double) Ai->red*Br->red-(double) Ar->red*Bi->red);
           gamma=PerceptibleReciprocal((double) Br->green*Br->green+(double)
             Bi->green*Bi->green+snr);
           Cr->green=gamma*((double) Ar->green*Br->green+(double)
             Ai->green*Bi->green);
           Ci->green=gamma*((double) Ai->green*Br->green-(double)
             Ar->green*Bi->green);
           gamma=PerceptibleReciprocal((double) Br->blue*Br->blue+(double)
             Bi->blue*Bi->blue+snr);
           Cr->blue=gamma*((double) Ar->blue*Br->blue+(double)
             Ai->blue*Bi->blue);
           Ci->blue=gamma*((double) Ai->blue*Br->blue-(double)
              Ar->blue*Bi->blue);
            if (images->matte != MagickFalse)
              {
              gamma=PerceptibleReciprocal(Br->opacity*Br->opacity+Bi->opacity*
                Bi->opacity+snr);
              Cr->opacity=gamma*(Ar->opacity*Br->opacity+Ai->opacity*
                Bi->opacity);
              Ci->opacity=gamma*(Ai->opacity*Br->opacity-Ar->opacity*
                Bi->opacity);
               gamma=PerceptibleReciprocal((double) Br->opacity*Br->opacity+
                 (double) Bi->opacity*Bi->opacity+snr);
               Cr->opacity=gamma*((double) Ar->opacity*Br->opacity+(double)
                 Ai->opacity*Bi->opacity);
               Ci->opacity=gamma*((double) Ai->opacity*Br->opacity-(double)
                 Ar->opacity*Bi->opacity);
              }
            break;
          }
          case MagnitudePhaseComplexOperator:
          {
          Cr->red=sqrt(Ar->red*Ar->red+Ai->red*Ai->red);
          Ci->red=atan2(Ai->red,Ar->red)/(2.0*MagickPI)+0.5;
          Cr->green=sqrt(Ar->green*Ar->green+Ai->green*Ai->green);
          Ci->green=atan2(Ai->green,Ar->green)/(2.0*MagickPI)+0.5;
          Cr->blue=sqrt(Ar->blue*Ar->blue+Ai->blue*Ai->blue);
           Cr->red=sqrt((double) Ar->red*Ar->red+(double) Ai->red*Ai->red);
           Ci->red=atan2((double) Ai->red,(double) Ar->red)/(2.0*MagickPI)+0.5;
           Cr->green=sqrt((double) Ar->green*Ar->green+(double)
             Ai->green*Ai->green);
           Ci->green=atan2((double) Ai->green,(double) Ar->green)/
             (2.0*MagickPI)+0.5;
           Cr->blue=sqrt((double) Ar->blue*Ar->blue+(double) Ai->blue*Ai->blue);
            Ci->blue=atan2(Ai->blue,Ar->blue)/(2.0*MagickPI)+0.5;
            if (images->matte != MagickFalse)
              {
              Cr->opacity=sqrt(Ar->opacity*Ar->opacity+Ai->opacity*Ai->opacity);
              Ci->opacity=atan2(Ai->opacity,Ar->opacity)/(2.0*MagickPI)+0.5;
               Cr->opacity=sqrt((double) Ar->opacity*Ar->opacity+(double)
                 Ai->opacity*Ai->opacity);
               Ci->opacity=atan2((double) Ai->opacity,(double) Ar->opacity)/
                 (2.0*MagickPI)+0.5;
              }
            break;
          }
          case MultiplyComplexOperator:
          {
          Cr->red=QuantumScale*(Ar->red*Br->red-Ai->red*Bi->red);
          Ci->red=QuantumScale*(Ai->red*Br->red+Ar->red*Bi->red);
          Cr->green=QuantumScale*(Ar->green*Br->green-Ai->green*Bi->green);
          Ci->green=QuantumScale*(Ai->green*Br->green+Ar->green*Bi->green);
          Cr->blue=QuantumScale*(Ar->blue*Br->blue-Ai->blue*Bi->blue);
          Ci->blue=QuantumScale*(Ai->blue*Br->blue+Ar->blue*Bi->blue);
           Cr->red=QuantumScale*((double) Ar->red*Br->red-(double)
             Ai->red*Bi->red);
           Ci->red=QuantumScale*((double) Ai->red*Br->red+(double)
             Ar->red*Bi->red);
           Cr->green=QuantumScale*((double) Ar->green*Br->green-(double)
             Ai->green*Bi->green);
           Ci->green=QuantumScale*((double) Ai->green*Br->green+(double)
             Ar->green*Bi->green);
           Cr->blue=QuantumScale*((double) Ar->blue*Br->blue-(double)
             Ai->blue*Bi->blue);
           Ci->blue=QuantumScale*((double) Ai->blue*Br->blue+(double)
             Ar->blue*Bi->blue);
            if (images->matte != MagickFalse)
              {
              Cr->opacity=QuantumScale*(Ar->opacity*Br->opacity-Ai->opacity*
                Bi->opacity);
              Ci->opacity=QuantumScale*(Ai->opacity*Br->opacity+Ar->opacity*
                Bi->opacity);
               Cr->opacity=QuantumScale*((double) Ar->opacity*Br->opacity-
                 (double) Ai->opacity*Bi->opacity);
               Ci->opacity=QuantumScale*((double) Ai->opacity*Br->opacity+
                 (double) Ar->opacity*Bi->opacity);
              }
            break;
          }
         case RealImaginaryComplexOperator:
         {
           Cr->red=Ar->red*cos(2.0*MagickPI*(Ai->red-0.5));
           Ci->red=Ar->red*sin(2.0*MagickPI*(Ai->red-0.5));
           Cr->green=Ar->green*cos(2.0*MagickPI*(Ai->green-0.5));
           Ci->green=Ar->green*sin(2.0*MagickPI*(Ai->green-0.5));
           Cr->blue=Ar->blue*cos(2.0*MagickPI*(Ai->blue-0.5));
           Ci->blue=Ar->blue*sin(2.0*MagickPI*(Ai->blue-0.5));
           if (images->matte != MagickFalse)
             {
                Cr->opacity=Ar->opacity*cos(2.0*MagickPI*(Ai->opacity-0.5));
                Ci->opacity=Ar->opacity*sin(2.0*MagickPI*(Ai->opacity-0.5));
             }
           break;
         }
         case SubtractComplexOperator:
         {
           Cr->red=Ar->red-Br->red;
           Ci->red=Ai->red-Bi->red;
           Cr->green=Ar->green-Br->green;
            Ci->green=Ai->green-Bi->green;
            Cr->blue=Ar->blue-Br->blue;
            Ci->blue=Ai->blue-Bi->blue;
          if (images->matte != MagickFalse)
           if (Cr_image->matte != MagickFalse)
              {
                Cr->opacity=Ar->opacity-Br->opacity;
                Ci->opacity=Ai->opacity-Bi->opacity;
             }
           break;
         }
       }
       Ar++;
       Ai++;
       Br++;
       Bi++;
       Cr++;
       Ci++;
     }
     if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)
       status=MagickFalse;
     if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)
       status=MagickFalse;
     if (images->progress_monitor != (MagickProgressMonitor) NULL)
       {
         MagickBooleanType
           proceed;
 
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
         #pragma omp atomic
 #endif
         progress++;
         proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);
         if (proceed == MagickFalse)
           status=MagickFalse;
       }
   }
   Cr_view=DestroyCacheView(Cr_view);
   Ci_view=DestroyCacheView(Ci_view);
   Br_view=DestroyCacheView(Br_view);
   Bi_view=DestroyCacheView(Bi_view);
   Ar_view=DestroyCacheView(Ar_view);
   Ai_view=DestroyCacheView(Ai_view);
   if (status == MagickFalse)
     complex_images=DestroyImageList(complex_images);
   return(complex_images);
 }","[99, 102, 127, 128, 129, 130, 143, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 215, 216, 217, 218, 219, 220, 231, 232, 233, 234, 235, 236, 237, 243, 244, 245, 246, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 276, 277, 278, 279, 307, 98, 101, 119, 120, 121, 122, 123, 124, 125, 126, 142, 184, 185, 186, 187, 188, 189, 190, 191, 192, 209, 210, 211, 212, 213, 214, 226, 227, 228, 229, 230, 241, 242, 252, 253, 254, 255, 256, 257, 272, 273, 274, 275, 306]",ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow in MagickCore/fourier.c in ComplexImage.
202175," static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,
 			     struct mschmd_header *chm, int entire)
 {
   unsigned int section, name_len, x, errors, num_chunks;
   unsigned char buf[0x54], *chunk = NULL, *name, *p, *end;
   struct mschmd_file *fi, *link = NULL;
   off_t offset, length;
   int num_entries;
 
    
   chm->files         = NULL;
   chm->sysfiles      = NULL;
   chm->chunk_cache   = NULL;
   chm->sec0.base.chm = chm;
   chm->sec0.base.id  = 0;
   chm->sec1.base.chm = chm;
   chm->sec1.base.id  = 1;
   chm->sec1.content  = NULL;
   chm->sec1.control  = NULL;
   chm->sec1.spaninfo = NULL;
   chm->sec1.rtable   = NULL;
 
    
   if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
    
   if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) {
     return MSPACK_ERR_SIGNATURE;
   }
 
    
   if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) {
     D((""incorrect GUIDs""))
     return MSPACK_ERR_SIGNATURE;
   }
 
   chm->version   = EndGetI32(&buf[chmhead_Version]);
   chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]);
   chm->language  = EndGetI32(&buf[chmhead_LanguageID]);
   if (chm->version > 3) {
     sys->message(fh, ""WARNING; CHM version > 3"");
   }
 
    
   if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
    
   if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) ||
       read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) ||
       read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh))
   {
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) {
     return MSPACK_ERR_SEEK;
   }
 
    
   if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) {
     return MSPACK_ERR_READ;
   }
   if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) {
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) {
     return MSPACK_ERR_SEEK;
   }
 
    
   if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) {
     return MSPACK_ERR_READ;
   }
 
   chm->dir_offset = sys->tell(fh);
   chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]);
   chm->density    = EndGetI32(&buf[chmhs1_Density]);
   chm->depth      = EndGetI32(&buf[chmhs1_Depth]);
   chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]);
   chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]);
   chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]);
   chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]);
 
   if (chm->version < 3) {
      
     chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks);
   }
 
    
   if (chm->sec0.offset > chm->length) {
     D((""content section begins after file has ended""))
     return MSPACK_ERR_DATAFORMAT;
   }
   
    
   if (chm->chunk_size < (pmgl_Entries + 2)) {
     D((""chunk size not large enough""))
     return MSPACK_ERR_DATAFORMAT;
   }
   if (chm->num_chunks == 0) {
     D((""no chunks""))
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (chm->num_chunks > 100000) {
     D((""more than 100,000 chunks""))
     return MSPACK_ERR_DATAFORMAT;
   }   
   if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) {
     D((""chunks larger than entire file""))
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) {
     sys->message(fh, ""WARNING; chunk size is not a power of two"");
   }
   if (chm->first_pmgl != 0) {
     sys->message(fh, ""WARNING; first PMGL chunk is not zero"");
   }
   if (chm->first_pmgl > chm->last_pmgl) {
     D((""first pmgl chunk is after last pmgl chunk""))
     return MSPACK_ERR_DATAFORMAT;
   }
   if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) {
     D((""index_root outside valid range""))
     return MSPACK_ERR_DATAFORMAT;
   }
 
    
   if (!entire) {
     return MSPACK_ERR_OK;
   }
 
    
   if ((x = chm->first_pmgl) != 0) {
     if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) {
       return MSPACK_ERR_SEEK;
     }
   }
   num_chunks = chm->last_pmgl - x + 1;
 
   if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) {
     return MSPACK_ERR_NOMEMORY;
   }
 
    
   errors = 0;
   while (num_chunks--) {
      
     if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) {
       sys->free(chunk);
       return MSPACK_ERR_READ;
     }
 
      
     if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue;
 
     if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) {
       sys->message(fh, ""WARNING; PMGL quickref area is too small"");
     }
     if (EndGetI32(&chunk[pmgl_QuickRefSize]) > 
 	((int)chm->chunk_size - pmgl_Entries))
     {
       sys->message(fh, ""WARNING; PMGL quickref area is too large"");
     }
 
     p = &chunk[pmgl_Entries];
     end = &chunk[chm->chunk_size - 2];
     num_entries = EndGetI16(end);
 
      while (num_entries--) {
        READ_ENCINT(name_len);
        if (name_len > (unsigned int) (end - p)) goto chunk_end;
       
      if (name_len == 0) goto chunk_end;
        name = p; p += name_len;
        READ_ENCINT(section);
        READ_ENCINT(offset);
        READ_ENCINT(length);
  
        
       if (name_len < 2 || !name[0] || !name[1]) continue;
 
         
       if ((offset == 0) && (length == 0)) {
 	if ((name_len > 0) && (name[name_len-1] == '/')) continue;
       }
 
       if (section > 1) {
 	sys->message(fh, ""invalid section number '%u'."", section);
 	continue;
       }
 
       if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) {
 	sys->free(chunk);
 	return MSPACK_ERR_NOMEMORY;
       }
 
       fi->next     = NULL;
       fi->filename = (char *) &fi[1];
       fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)
 		                     : (struct mschmd_section *) (&chm->sec1));
       fi->offset   = offset;
       fi->length   = length;
       sys->copy(name, fi->filename, (size_t) name_len);
       fi->filename[name_len] = '\0';
 
       if (name[0] == ':' && name[1] == ':') {
 	 
 	if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) {
 	  if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) {
 	    chm->sec1.content = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) {
 	    chm->sec1.control = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {
 	    chm->sec1.spaninfo = fi;
 	  }
 	  else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) {
 	    chm->sec1.rtable = fi;
 	  }
 	}
 	fi->next = chm->sysfiles;
 	chm->sysfiles = fi;
       }
       else {
 	 
 	if (link) link->next = fi; else chm->files = fi;
 	link = fi;
       }
     }
 
      
   chunk_end:
     if (num_entries >= 0) {
       D((""chunk ended before all entries could be read""))
       errors++;
     }
 
   }
   sys->free(chunk);
   return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK;
 }","[190, 191, 192, 183, 184]",chmd_read_headers in mspack/chmd.c in libmspack before 0.8alpha accepts a filename that has '0' as its first or second character (such as the */0* name).
86,"int rose_parse_facilities(unsigned char *p,
struct rose_facilities_struct *facilities)
{
int facilities_len, len;

facilities_len = *p++;

if (facilities_len == 0)
return 0;

while (facilities_len > 0) {
if (*p == 0x00) {
facilities_len--;
p++;

switch (*p) {
case FAC_NATIONAL:
len = rose_parse_national(p + 1, facilities, facilities_len - 1);
facilities_len -= len + 1;
p += len + 1;
break;

case FAC_CCITT:
len = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);
facilities_len -= len + 1;
p += len + 1;
break;

default:
printk(KERN_DEBUG ""ROSE: rose_parse_facilities - unknown facilities family %02X\n"", *p);
facilities_len--;
p++;
break;
}
} else
break;
}

return 1;
}","[19, 25]","Array index error in the rose_parse_national function in net/rose/rose_subr.c in the Linux kernel before 2.6.39 allows remote attackers to cause a denial of service (heap memory corruption) or possibly have unspecified other impact by composing FAC_NATIONAL_DIGIS data that specifies a large number of digipeaters, and then sending this data to a ROSE socket."
7476,"static int r_cmd_java_call(void *user, const char *input) {
RCore *core = (RCore *) user;
int res = false;
ut32 i = 0;
if (strncmp (input, ""java"", 4)) {
return false;
}
if (input[4] != ' ') {
return r_cmd_java_handle_help (core, input);
}
for (; i < END_CMDS; i++) {

IFDBG r_cons_printf (""Checking cmd: %s %d\n"", JAVA_CMDS[i].name,
strncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));
if (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {
const char *cmd = input + 5 + JAVA_CMDS[i].name_len;
if (*cmd && *cmd == ' ') {
cmd++;
}

res =  JAVA_CMDS[i].handler (core, cmd);
break;
}
}
if (!res) {
return r_cmd_java_handle_help (core, input);
}
return true;
}",[11],"An off-by-one overflow flaw was found in radare2 due to mismatched array length in core_java.c. This could allow an attacker to cause a crash, and perform a denail of service attack."
7363,"static void sunkbd_reinit(struct work_struct *work)
{
struct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);

wait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);

serio_write(sunkbd->serio, SUNKBD_CMD_SETLED);
serio_write(sunkbd->serio,
(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |
(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |
(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |
!!test_bit(LED_NUML,    sunkbd->dev->led));
serio_write(sunkbd->serio,
SUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));
serio_write(sunkbd->serio,
SUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));
}","[3, 5]","A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free."
206736,"  NetworkHandler::NetworkHandler(const std::string& host_id)
      : DevToolsDomainHandler(Network::Metainfo::domainName),
      process_(nullptr),
       browser_context_(nullptr),
       storage_partition_(nullptr),
        host_(nullptr),
        enabled_(false),
        host_id_(host_id),
       bypass_service_worker_(false),
       cache_disabled_(false),
       weak_factory_(this) {
   static bool have_configured_service_worker_context = false;
   if (have_configured_service_worker_context)
     return;
   have_configured_service_worker_context = true;
   BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                           base::BindOnce(&ConfigureServiceWorkerContextOnIO));
 }","[4, 5, 3]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
7646,"void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){
int i = 0;
int iTbl = 0;
while( i<128 ){
int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];
int n = (aFts5UnicodeData[iTbl] >> 5) + i;
for(; i<128 && i<n; i++){
aAscii[i] = (u8)bToken;
}
iTbl++;
}
}",[10],"An issue was found in fts5UnicodeTokenize() in ext/fts5/fts5_tokenize.c in Sqlite. A unicode61 tokenizer configured to treat unicode ""control-characters"" (class Cc), was treating embedded nul characters as tokens. The issue was fixed in sqlite-3.34.0 and later."
5511,"TEST_F(HeaderTableTests, set_capacity) {
HPACKHeader accept(""accept-encoding"", ""gzip"");
uint32_t max = 10;
uint32_t capacity = accept.bytes() * max;
HeaderTable table(capacity);


for (size_t i = 0; i < max; i++) {
EXPECT_EQ(table.add(accept), true);
}

table.setCapacity(capacity / 2);
EXPECT_EQ(table.size(), max / 2);
EXPECT_EQ(table.bytes(), capacity / 2);
}",[8],"In the course of decompressing HPACK inside the HTTP2 protocol, an unexpected sequence of header table resize operations can place the header table into a corrupted state, leading to a use-after-free condition and undefined behavior. This issue affects Proxygen from v0.29.0 until v2017.04.03.00."
200133," int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,
 		   unsigned int flags, struct timespec *timeout)
 {
 	int fput_needed, err, datagrams;
 	struct socket *sock;
 	struct mmsghdr __user *entry;
 	struct compat_mmsghdr __user *compat_entry;
 	struct msghdr msg_sys;
 	struct timespec end_time;
 
 	if (timeout &&
 	    poll_select_set_timeout(&end_time, timeout->tv_sec,
 				    timeout->tv_nsec))
 		return -EINVAL;
 
 	datagrams = 0;
 
 	sock = sockfd_lookup_light(fd, &err, &fput_needed);
 	if (!sock)
 		return err;
 
 	err = sock_error(sock->sk);
 	if (err)
 		goto out_put;
 
 	entry = mmsg;
 	compat_entry = (struct compat_mmsghdr __user *)mmsg;
 
 	while (datagrams < vlen) {
 		 
 		if (MSG_CMSG_COMPAT & flags) {
 			err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry,
 					     &msg_sys, flags & ~MSG_WAITFORONE,
 					     datagrams);
 			if (err < 0)
 				break;
 			err = __put_user(err, &compat_entry->msg_len);
 			++compat_entry;
 		} else {
 			err = ___sys_recvmsg(sock,
 					     (struct user_msghdr __user *)entry,
 					     &msg_sys, flags & ~MSG_WAITFORONE,
 					     datagrams);
 			if (err < 0)
 				break;
 			err = put_user(err, &entry->msg_len);
 			++entry;
 		}
 
 		if (err)
 			break;
 		++datagrams;
 
 		 
 		if (flags & MSG_WAITFORONE)
 			flags |= MSG_DONTWAIT;
 
 		if (timeout) {
 			ktime_get_ts(timeout);
 			*timeout = timespec_sub(end_time, *timeout);
 			if (timeout->tv_sec < 0) {
 				timeout->tv_sec = timeout->tv_nsec = 0;
 				break;
 			}
 
 			 
 			if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
 				break;
 		}
 
 		 
 		if (msg_sys.msg_flags & MSG_OOB)
 			break;
  		cond_resched();
  	}
  
out_put:
	fput_light(sock->file, fput_needed);
  	if (err == 0)
		return datagrams;
 		goto out_put;
  
	if (datagrams != 0) {
 	if (datagrams == 0) {
 		datagrams = err;
 		goto out_put;
 	}
 
 	 
 	if (err != -EAGAIN) {
  		 
		if (err != -EAGAIN) {
			 
			sock->sk->sk_err = -err;
		}
		return datagrams;
 		sock->sk->sk_err = -err;
  	}
 out_put:
 	fput_light(sock->file, fput_needed);
  
	return err;
 	return datagrams;
  }","[81, 84, 85, 86, 87, 88, 89, 90, 97, 99, 100, 103, 77, 78, 80, 83, 92, 93, 94, 95, 96, 102]",Use-after-free vulnerability in the __sys_recvmmsg function in net/socket.c in the Linux kernel before 4.5.2 allows remote attackers to execute arbitrary code via vectors involving a recvmmsg system call that is mishandled during error processing.
206513," bool NavigatorImpl::NavigateToEntry(
     FrameTreeNode* frame_tree_node,
     const FrameNavigationEntry& frame_entry,
     const NavigationEntryImpl& entry,
     ReloadType reload_type,
     bool is_same_document_history_load,
     bool is_history_navigation_in_new_child,
     bool is_pending_entry,
     const scoped_refptr<ResourceRequestBodyImpl>& post_body) {
   TRACE_EVENT0(""browser,navigation"", ""NavigatorImpl::NavigateToEntry"");
 
   GURL dest_url = frame_entry.url();
   Referrer dest_referrer = frame_entry.referrer();
   if (reload_type == ReloadType::ORIGINAL_REQUEST_URL &&
       entry.GetOriginalRequestURL().is_valid() && !entry.GetHasPostData()) {
     dest_url = entry.GetOriginalRequestURL();
      dest_referrer = Referrer();
    }
  
    
   if (frame_tree_node->IsMainFrame()) {
     const GURL& virtual_url = entry.GetVirtualURL();
     if (!virtual_url.is_valid() && !virtual_url.is_empty()) {
       LOG(WARNING) << ""Refusing to load for invalid virtual URL: ""
                    << virtual_url.possibly_invalid_spec();
       return false;
     }
   }
 
    if (!dest_url.is_valid() && !dest_url.is_empty()) {
      LOG(WARNING) << ""Refusing to load invalid URL: ""
                  << dest_url.possibly_invalid_spec();
     return false;
   }
 
   if (dest_url.spec().size() > url::kMaxURLChars) {
     LOG(WARNING) << ""Refusing to load URL as it exceeds "" << url::kMaxURLChars
                  << "" characters."";
     return false;
   }
 
   base::TimeTicks navigation_start = base::TimeTicks::Now();
   TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
       ""navigation,rail"", ""NavigationTiming navigationStart"",
       TRACE_EVENT_SCOPE_GLOBAL, navigation_start);
 
   LoFiState lofi_state = LOFI_UNSPECIFIED;
   if (!frame_tree_node->IsMainFrame()) {
     lofi_state = frame_tree_node->frame_tree()
                      ->root()
                      ->current_frame_host()
                      ->last_navigation_lofi_state();
   } else if (reload_type == ReloadType::DISABLE_LOFI_MODE) {
     lofi_state = LOFI_OFF;
   }
 
   if (IsBrowserSideNavigationEnabled()) {
     navigation_data_.reset(new NavigationMetricsData(navigation_start, dest_url,
                                                      entry.restore_type()));
     RequestNavigation(frame_tree_node, dest_url, dest_referrer, frame_entry,
                       entry, reload_type, lofi_state,
                       is_same_document_history_load,
                       is_history_navigation_in_new_child, navigation_start);
     if (frame_tree_node->IsMainFrame() &&
         frame_tree_node->navigation_request()) {
       TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(
           ""navigation"", ""Navigation timeToNetworkStack"",
           frame_tree_node->navigation_request()->navigation_handle(),
           navigation_start,
           ""FrameTreeNode id"", frame_tree_node->frame_tree_node_id());
     }
 
   } else {
     RenderFrameHostImpl* dest_render_frame_host =
         frame_tree_node->render_manager()->Navigate(
             dest_url, frame_entry, entry, reload_type != ReloadType::NONE);
     if (!dest_render_frame_host)
       return false;   
 
     if (is_pending_entry)
       CHECK_EQ(controller_->GetPendingEntry(), &entry);
 
     CheckWebUIRendererDoesNotDisplayNormalURL(dest_render_frame_host, dest_url);
 
     bool is_transfer = entry.transferred_global_request_id().child_id != -1;
     if (is_transfer)
       dest_render_frame_host->set_is_loading(true);
 
     if (is_pending_entry && controller_->GetPendingEntryIndex() != -1)
       DCHECK(frame_entry.page_state().IsValid());
 
     bool is_transfer_to_same =
         is_transfer &&
         entry.transferred_global_request_id().child_id ==
             dest_render_frame_host->GetProcess()->GetID();
     if (!is_transfer_to_same) {
       navigation_data_.reset(new NavigationMetricsData(
           navigation_start, dest_url, entry.restore_type()));
       FrameMsg_Navigate_Type::Value navigation_type = GetNavigationType(
           controller_->GetBrowserContext(), entry, reload_type);
       dest_render_frame_host->Navigate(
           entry.ConstructCommonNavigationParams(
               frame_entry, post_body, dest_url, dest_referrer, navigation_type,
               lofi_state, navigation_start),
           entry.ConstructStartNavigationParams(),
           entry.ConstructRequestNavigationParams(
               frame_entry, is_same_document_history_load,
               is_history_navigation_in_new_child,
               entry.GetSubframeUniqueNames(frame_tree_node),
               frame_tree_node->has_committed_real_load(),
               controller_->GetPendingEntryIndex() == -1,
               controller_->GetIndexOfEntry(&entry),
               controller_->GetLastCommittedEntryIndex(),
               controller_->GetEntryCount()));
     }
   }
 
   if (is_pending_entry)
     CHECK_EQ(controller_->GetPendingEntry(), &entry);
 
   if (controller_->GetPendingEntryIndex() == -1 &&
       dest_url.SchemeIs(url::kJavaScriptScheme)) {
     return false;
   }
 
   if (delegate_ && is_pending_entry)
     delegate_->DidStartNavigationToPendingEntry(dest_url, reload_type);
 
   return true;
 }","[20, 21, 22, 23, 24, 25, 26, 27, 28, 29]","Incorrect handling of invalid URLs in Google Chrome prior to 55.0.2883.75 for Mac, Windows and Linux, and 55.0.2883.84 for Android allowed a remote attacker to spoof the contents of the Omnibox (URL bar) via a crafted HTML page."
207172,"  bool RenderFrameHostManager::CanSubframeSwapProcess(
      const GURL& dest_url,
      SiteInstance* source_instance,
    SiteInstance* dest_instance,
    bool was_server_redirect) {
     SiteInstance* dest_instance) {
   DCHECK(!source_instance || !dest_instance);
 
   GURL resolved_url = dest_url;
   if (url::Origin::Create(resolved_url).unique()) {
     if (source_instance) {
       resolved_url = source_instance->GetSiteURL();
     } else if (dest_instance) {
        resolved_url = dest_instance->GetSiteURL();
      } else {
      if (!was_server_redirect)
        
        
        
        
        
        
        
        
        
        
        
        
       if (resolved_url.IsAboutBlank() ||
           resolved_url == GURL(content::kAboutSrcDocURL)) {
          return false;
       }
      }
    }
  
   if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                              resolved_url)) {
     DCHECK(!dest_instance ||
            dest_instance == render_frame_host_->GetSiteInstance());
     return false;
   }
 
   return true;
 }","[6, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 4, 5, 16]",Insufficient policy enforcement in site isolation in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to bypass site isolation via a crafted HTML page.
205470," void ClipboardMessageFilter::OnWriteObjectsAsync(
     const ui::Clipboard::ObjectMap& objects) {
    scoped_ptr<ui::Clipboard::ObjectMap> sanitized_objects(
        new ui::Clipboard::ObjectMap(objects));
  sanitized_objects->erase(ui::Clipboard::CBF_SMBITMAP);
   SanitizeObjectMap(sanitized_objects.get(), kFilterBitmap);
  
  #if defined(OS_WIN)
   BrowserThread::PostTask(
       BrowserThread::UI,
       FROM_HERE,
       base::Bind(
           &WriteObjectsOnUIThread, base::Owned(sanitized_objects.release())));
 #else
   GetClipboard()->WriteObjects(
       ui::CLIPBOARD_TYPE_COPY_PASTE, *sanitized_objects.get());
 #endif
 }","[6, 5]","The ScopedClipboardWriter::WritePickledData function in ui/base/clipboard/scoped_clipboard_writer.cc in Google Chrome before 33.0.1750.152 on OS X and Linux and before 33.0.1750.154 on Windows does not verify a certain format value, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the clipboard."
198530," static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)
 {
     SSISlave *ss = SSI_SLAVE(opaque);
     ssi_sd_state *s = (ssi_sd_state *)opaque;
     int i;
 
     if (version_id != 1)
         return -EINVAL;
 
     s->mode = qemu_get_be32(f);
     s->cmd = qemu_get_be32(f);
     for (i = 0; i < 4; i++)
         s->cmdarg[i] = qemu_get_be32(f);
      for (i = 0; i < 5; i++)
          s->response[i] = qemu_get_be32(f);
      s->arglen = qemu_get_be32(f);
     if (s->mode == SSI_SD_CMDARG &&
         (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {
         return -EINVAL;
     }
      s->response_pos = qemu_get_be32(f);
      s->stopping = qemu_get_be32(f);
     if (s->mode == SSI_SD_RESPONSE &&
         (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||
         (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {
         return -EINVAL;
     }
  
      ss->cs = qemu_get_be32(f);
     s->mode = SSI_SD_CMD;
     dinfo = drive_get_next(IF_SD);
     s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, true);
     if (s->sd == NULL) {
         return -1;
     }
     register_savevm(dev, ""ssi_sd"", -1, 1, ssi_sd_save, ssi_sd_load, s);
     return 0;
 }","[17, 18, 19, 20, 23, 24, 25, 26, 27]",The ssi_sd_transfer function in hw/sd/ssi-sd.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted arglen value in a savevm image.
198213," void _xml_endElementHandler(void *userData, const XML_Char *name)
 {
 	xml_parser *parser = (xml_parser *)userData;
 	char *tag_name;
 
 	if (parser) {
 		zval *retval, *args[2];
 
 		tag_name = _xml_decode_tag(parser, name);
 
 		if (parser->endElementHandler) {
 			args[0] = _xml_resource_zval(parser->index);
 			args[1] = _xml_string_zval(((char *) tag_name) + parser->toffset);
 
                         if ((retval = xml_call_handler(parser, parser->endElementHandler, parser->endElementPtr, 2, args))) {
                                 zval_ptr_dtor(&retval);
                         }
               } 
                }
  
                 if (parser->data) {
                         zval *tag;
 
 			if (parser->lastwasopen) {
 				add_assoc_string(*(parser->ctag),""type"",""complete"",1);
 			} else {
                                 MAKE_STD_ZVAL(tag);
  
                                 array_init(tag);
 
                                 _xml_add_to_info(parser,((char *) tag_name) + parser->toffset);
  
                                 add_assoc_string(tag,""tag"",((char *) tag_name) + parser->toffset,1);  
                                 add_assoc_string(tag,""type"",""close"",1);
                                 add_assoc_long(tag,""level"",parser->level);
 
                                 zend_hash_next_index_insert(Z_ARRVAL_P(parser->data),&tag,sizeof(zval*),NULL);
                         }
  
 			parser->lastwasopen = 0;
 		}
 
 		efree(tag_name);
 
 		if ((parser->ltags) && (parser->level <= XML_MAXLEVEL)) {
 			efree(parser->ltags[parser->level-1]);
 		}
 
 		parser->level--;
 	}
 }","[19, 30, 36, 18]","The xml_parse_into_struct function in ext/xml/xml.c in PHP before 5.5.35, 5.6.x before 5.6.21, and 7.x before 7.0.6 allows remote attackers to cause a denial of service (buffer under-read and segmentation fault) or possibly have unspecified other impact via crafted XML data in the second argument, leading to a parser level of zero."
205224,"  void UnloadController::TabReplacedAt(TabStripModel* tab_strip_model,
                                       TabContents* old_contents,
                                       TabContents* new_contents,
                                       int index) {
  TabDetachedImpl(old_contents);
   TabDetachedImpl(old_contents->web_contents());
    TabAttachedImpl(new_contents->web_contents());
  }","[6, 5]","The hyphenation functionality in Google Chrome before 24.0.1312.52 does not properly validate file names, which has unspecified impact and attack vectors."
201590," void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) {
 	EUID_ASSERT();
 	EUID_ROOT();
 	char *comm = pid_proc_comm(pid);
 	EUID_USER();
 	if (!comm) {
 		fprintf(stderr, ""Error: cannot find sandbox\n"");
 		exit(1);
 	}
 
 	if (strcmp(comm, ""firejail"") != 0) {
 		fprintf(stderr, ""Error: cannot find sandbox\n"");
 		exit(1);
 	}
 	free(comm);
 	
 	char *name;
 	if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1)
 		errExit(""asprintf"");
 	struct stat s;
 	if (stat(name, &s) == -1) {
 		fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n"");
 		exit(1);
 	}
 
 	pid_t child;
 	if (find_child(pid, &child) == -1) {
 		fprintf(stderr, ""Error: cannot join the network namespace\n"");
 		exit(1);
 	}
 
 	EUID_ROOT();
 	if (join_namespace(child, ""net"")) {
 		fprintf(stderr, ""Error: cannot join the network namespace\n"");
 		exit(1);
 	}
 
 	if (strcmp(command, ""set"") == 0)
 		bandwidth_set(pid, dev, down, up);
 	else if (strcmp(command, ""clear"") == 0)
 		bandwidth_remove(pid, dev);
 
 	char *devname = NULL;
 	if (dev) {
 		char *fname;
 		if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1)
 			errExit(""asprintf"");
 		FILE *fp = fopen(fname, ""r"");
 		if (!fp) {
 			fprintf(stderr, ""Error: cannot read network map file %s\n"", fname);
 			exit(1);
 		}
 		
 		char buf[1024];
 		int len = strlen(dev);
 		while (fgets(buf, 1024, fp)) {
 			char *ptr = strchr(buf, '\n');
 			if (ptr)
 				*ptr = '\0';
 			if (*buf == '\0')
 				break;
 
 			if (strncmp(buf, dev, len) == 0  && buf[len] == ':') {
 				devname = strdup(buf + len + 1);
 				if (!devname)
 					errExit(""strdup"");
 				if (if_nametoindex(devname) == 0) {
 					fprintf(stderr, ""Error: cannot find network device %s\n"", devname);
 					exit(1);
 				}
 				break;
 			}
 		}
 		free(fname);
 		fclose(fp);
 	}
 	
 	char *cmd = NULL;
 	if (devname) {
 		if (strcmp(command, ""set"") == 0) {
 			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"",
 				LIBDIR, command, devname, down, up) == -1)
 				errExit(""asprintf"");
 		}
 		else {
 			if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"",
 				LIBDIR, command, devname) == -1)
 				errExit(""asprintf"");
 		}
 	}
 	else {
 		if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1)
 			errExit(""asprintf"");
 	}
 	assert(cmd);
 
 	environ = NULL;
 
 	if (setreuid(0, 0))
 		errExit(""setreuid"");
  	if (setregid(0, 0))
  		errExit(""setregid"");
  
	if (!cfg.shell)
		cfg.shell = guess_shell();
	if (!cfg.shell) {
		fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n"");
		exit(1);
	}
  	char *arg[4];
	arg[0] = cfg.shell;
 	arg[0] = ""/bin/sh"";
  	arg[1] = ""-c"";
  	arg[2] = cmd;
  	arg[3] = NULL;
 	clearenv();
 	execvp(arg[0], arg);
 	
 	errExit(""execvp"");
 }","[112, 104, 105, 106, 107, 108, 109, 111]","Firejail before 0.9.44.4, when running a bandwidth command, allows local users to gain root privileges via the --shell argument."
201420," static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,
                              uint32_t length)
  {
      int v, i;
  
     if (!(s->state & PNG_IHDR)) {
         av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
         return AVERROR_INVALIDDATA;
     }
 
     if (s->state & PNG_IDAT) {
         av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
         return AVERROR_INVALIDDATA;
     }
 
      if (s->color_type == PNG_COLOR_TYPE_PALETTE) {
          if (length > 256 || !(s->state & PNG_PLTE))
              return AVERROR_INVALIDDATA;
 
         for (i = 0; i < length; i++) {
             v = bytestream2_get_byte(&s->gb);
             s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);
          }
      } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {
          if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||
            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))
             (s->color_type == PNG_COLOR_TYPE_RGB && length != 6) ||
             s->bit_depth == 1)
              return AVERROR_INVALIDDATA;
  
          for (i = 0; i < length / 2; i++) {
              
             v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);
 
             if (s->bit_depth > 8)
                 AV_WB16(&s->transparent_color_be[2 * i], v);
             else
                 s->transparent_color_be[i] = v;
         }
     } else {
         return AVERROR_INVALIDDATA;
     }
 
     bytestream2_skip(&s->gb, 4);  
     s->has_trns = 1;
 
     return 0;
 }","[6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 27, 28, 26]",FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.
4645,"static void urlParsePostBody(struct URL *url,
const struct HttpConnection *http,
const char *buf, int len) {
struct HashMap contentType;
initHashMap(&contentType, urlDestroyHashMapEntry, NULL);
const char *ctHeader     = getFromHashMap(&http->header, ""content-type"");
urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);
if (getRefFromHashMap(&contentType, ""application/x-www-form-urlencoded"")) {
urlParseQueryString(&url->args, buf, len);
} else if (getRefFromHashMap(&contentType, ""multipart/form-data"")) {
const char *boundary   = getFromHashMap(&contentType, ""boundary"");
if (boundary && *boundary) {
const char *lastPart = NULL;
for (const char *part = buf; len > 0; ) {
const char *ptr;
if ((part == buf && (ptr = urlMemstr(part, len, ""--"")) != NULL) ||
(ptr = urlMemstr(part, len, ""\r\n--"")) != NULL) {
len             -= ptr - part + (part == buf ? 2 : 4);
part             = ptr + (part == buf ? 2 : 4);
if (!urlMemcmp(part, len, boundary)) {
int i          = strlen(boundary);
len           -= i;
part          += i;
if (!urlMemcmp(part, len, ""\r\n"")) {
len         -= 2;
part        += 2;
if (lastPart) {
urlParsePart(url, lastPart, ptr - lastPart);
} else {
if (ptr != buf) {
info(""[http] Ignoring prologue before \""multipart/form-data\""!"");
}
}
lastPart     = part;
} else if (!urlMemcmp(part, len, ""--\r\n"")) {
len         -= 4;
part        += 4;
urlParsePart(url, lastPart, ptr - lastPart);
lastPart     = NULL;
if (len > 0) {
info(""[http] Ignoring epilogue past end of \""multipart/""
""form-data\""!"");
}
}
}
}
}
if (lastPart) {
warn(""[http] Missing final \""boundary\"" for \""multipart/form-data\""!"");
}
} else {
warn(""[http] Missing \""boundary\"" information for \""multipart/form-data\""!"");
}
}
destroyHashMap(&contentType);
}",[48],"libhttp/url.c in shellinabox through 2.20 has an implementation flaw in the HTTP request parsing logic. By sending a crafted multipart/form-data HTTP request, an attacker could exploit this to force shellinaboxd into an infinite loop, exhausting available CPU resources and taking the service down."
201917,"  int jas_stream_gobble(jas_stream_t *stream, int n)
  {
  	int m;
 	if (n < 0) {
 		jas_deprecated(""negative count for jas_stream_gobble"");
 	}
  	m = n;
  	for (m = n; m > 0; --m) {
  		if (jas_stream_getc(stream) == EOF) {
 			return n - m;
 		}
 	}
 	return n;
 }","[4, 5, 6]","Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities."
198544," rm_cred_handler(Service *  , int  , Stream *stream) {
   char * name = NULL;
   int rtnVal = FALSE;
   int rc;
   bool found_cred;
   CredentialWrapper * cred_wrapper = NULL;
   char * owner = NULL;
   const char * user;
 
   ReliSock * socket = (ReliSock*)stream;
 
   if (!socket->triedAuthentication()) {
     CondorError errstack;
     if( ! SecMan::authenticate_sock(socket, READ, &errstack) ) {
       dprintf (D_ALWAYS, ""Unable to authenticate, qutting\n"");
       goto EXIT;
     }
   }
 
 
   socket->decode();
 
   if (!socket->code(name)) {
     dprintf (D_ALWAYS, ""Error receiving credential name\n""); 
     goto EXIT;
   }
 
   user = socket->getFullyQualifiedUser();
 
   dprintf (D_ALWAYS, ""Authenticated as %s\n"", user);
 
   if (strchr (name, ':')) {
 
     owner = strdup (name);
     char * pColon = strchr (owner, ':');
      *pColon = '\0';
      
    sprintf (name, (char*)(pColon+sizeof(char)));
     sprintf (name, ""%s"", (char*)(pColon+sizeof(char)));
    
      if (strcmp (owner, user) != 0) { 
        dprintf (D_ALWAYS, ""Requesting another user's (%s) credential %s\n"", owner, name);
 
       if (!isSuperUser (user)) {
 	dprintf (D_ALWAYS, ""User %s is NOT super user, request DENIED\n"", user);
 	goto EXIT;
       } else {
 	dprintf (D_FULLDEBUG, ""User %s is super user, request GRANTED\n"", user);
       }
     }
 
   } else {
     owner = strdup (user);
   }
 
   dprintf (D_ALWAYS, ""Attempting to delete cred %s for user %s\n"", name, owner);
   
 
   found_cred=false;
   credentials.Rewind();
   while (credentials.Next(cred_wrapper)) {
 	  if (cred_wrapper->cred->GetType() == X509_CREDENTIAL_TYPE) {
 		  if ((strcmp(cred_wrapper->cred->GetName(), name) == 0) && 
 			  (strcmp(cred_wrapper->cred->GetOwner(), owner) == 0)) {
 			  credentials.DeleteCurrent();
 			  found_cred=true;
 			  break;  
 		  }
 	  }
   }
 
 
   if (found_cred) {
     priv_state priv = set_root_priv();
     unlink (cred_wrapper->GetStorageName());
     SaveCredentialList();
     set_priv(priv);
     delete cred_wrapper;
     dprintf (D_ALWAYS, ""Removed credential %s for owner %s\n"", name, owner);
   } else {
     dprintf (D_ALWAYS, ""Unable to remove credential %s:%s (not found)\n"", owner, name); 
   }
 	    
   
   free (owner);
   
   socket->encode();
  
 
   rc = (found_cred)?CREDD_SUCCESS:CREDD_CREDENTIAL_NOT_FOUND;
   socket->code(rc);
 
   rtnVal = TRUE;
 
 EXIT:
   if (name != NULL) {
 	  free (name);
   }
   return rtnVal;
 }","[39, 38]","Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors."
8354,"void AverageEvalFloat(TfLiteContext* context, TfLiteNode* node,
TfLitePoolParams* params, OpData* data,
const TfLiteTensor* input, TfLiteTensor* output) {
float activation_min, activation_max;
CalculateActivationRange(params->activation, &activation_min,
&activation_max);
#define TF_LITE_AVERAGE_POOL(type)                                       \
  tflite::PoolParams op_params;                                          \
  op_params.stride_height = params->stride_height;                       \
  op_params.stride_width = params->stride_width;                         \
  op_params.filter_height = params->filter_height;                       \
  op_params.filter_width = params->filter_width;                         \
  op_params.padding_values.height = data->padding.height;                \
  op_params.padding_values.width = data->padding.width;                  \
  op_params.float_activation_min = activation_min;                       \
  op_params.float_activation_max = activation_max;                       \
  type::AveragePool(op_params, GetTensorShape(input),                    \
                    GetTensorData<float>(input), GetTensorShape(output), \
                    GetTensorData<float>(output))
if (kernel_type == kReference) {
TF_LITE_AVERAGE_POOL(reference_ops);
} else {
TF_LITE_AVERAGE_POOL(optimized_ops);
}
#undef TF_LITE_AVERAGE_POOL
}","[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 23]","TensorFlow is an end-to-end open source platform for machine learning. In affected versions the strided slice implementation in TFLite has a logic bug which can allow an attacker to trigger an infinite loop. This arises from newly introduced support for [ellipsis in axis definition](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/strided_slice.cc#L103-L122). An attacker can craft a model such that `ellipsis_end_idx` is smaller than `i` (e.g., always negative). In this case, the inner loop does not increase `i` and the `continue` statement causes execution to skip over the preincrement at the end of the outer loop. We have patched the issue in GitHub commit dfa22b348b70bb89d6d6ec0ff53973bacb4f4695. TensorFlow 2.6.0 is the only affected version."
198308,"  static js_Ast *memberexp(js_State *J)
  {
       js_Ast *a;
       INCREC();
       a = newexp(J);
        js_Ast *a = newexp(J);
        SAVEREC();
  loop:
        INCREC();
         if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
         if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
       DECREC();
        POPREC();
         return a;
  }","[6, 7, 9, 13, 3, 4, 5, 12]","jsparse.c in Artifex MuJS through 1.0.2 does not properly maintain the AST depth for binary expressions, which allows remote attackers to cause a denial of service (excessive recursion) via a crafted file."
199574," bqarr_in(PG_FUNCTION_ARGS)
 {
 	char	   *buf = (char *) PG_GETARG_POINTER(0);
 	WORKSTATE	state;
 	int32		i;
 	QUERYTYPE  *query;
 	int32		commonlen;
 	ITEM	   *ptr;
 	NODE	   *tmp;
 	int32		pos = 0;
 
 #ifdef BS_DEBUG
 	StringInfoData pbuf;
 #endif
 
 	state.buf = buf;
 	state.state = WAITOPERAND;
 	state.count = 0;
 	state.num = 0;
 	state.str = NULL;
 
 	 
 	makepol(&state);
 	if (!state.num)
 		ereport(ERROR,
  				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
  				 errmsg(""empty query"")));
  
 	if (state.num > QUERYTYPEMAXITEMS)
 		ereport(ERROR,
 				(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
 		errmsg(""number of query items (%d) exceeds the maximum allowed (%d)"",
 			   state.num, (int) QUERYTYPEMAXITEMS)));
  	commonlen = COMPUTESIZE(state.num);
 
  	query = (QUERYTYPE *) palloc(commonlen);
  	SET_VARSIZE(query, commonlen);
  	query->size = state.num;
 	ptr = GETQUERY(query);
 
 	for (i = state.num - 1; i >= 0; i--)
 	{
 		ptr[i].type = state.str->type;
 		ptr[i].val = state.str->val;
 		tmp = state.str->next;
 		pfree(state.str);
 		state.str = tmp;
 	}
 
 	pos = query->size - 1;
 	findoprnd(ptr, &pos);
 #ifdef BS_DEBUG
 	initStringInfo(&pbuf);
 	for (i = 0; i < query->size; i++)
 	{
 		if (ptr[i].type == OPR)
 			appendStringInfo(&pbuf, ""%c(%d) "", ptr[i].val, ptr[i].left);
 		else
 			appendStringInfo(&pbuf, ""%d "", ptr[i].val);
 	}
 	elog(DEBUG3, ""POR: %s"", pbuf.data);
 	pfree(pbuf.data);
 #endif
 
 	PG_RETURN_POINTER(query);
 }","[29, 30, 31, 32, 33, 35]","Multiple integer overflows in contrib/hstore/hstore_io.c in PostgreSQL 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to have unspecified impact via vectors related to the (1) hstore_recv, (2) hstore_from_arrays, and (3) hstore_from_array functions in contrib/hstore/hstore_io.c; and the (4) hstoreArrayToPairs function in contrib/hstore/hstore_op.c, which triggers a buffer overflow.  NOTE: this issue was SPLIT from CVE-2014-0064 because it has a different set of affected versions."
198885," static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)
 {
 	__be32 *p;
 
 	RESERVE_SPACE(4+NFS4_STATEID_SIZE+4);
  	WRITE32(OP_OPEN_DOWNGRADE);
  	WRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);
  	WRITE32(arg->seqid->sequence->counter);
	encode_share_access(xdr, arg->open_flags);
 	encode_share_access(xdr, arg->fmode);
  	return 0;
  }","[10, 9]",The encode_share_access function in fs/nfs/nfs4xdr.c in the Linux kernel before 2.6.29 allows local users to cause a denial of service (BUG and system crash) by using the mknod system call with a pathname on an NFSv4 filesystem.
207721," standard_info_part2(standard_display *dp, png_const_structp pp,
 
      png_const_infop pi, int nImages)
  {
      
   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
      png_get_bit_depth(pp, pi));
    {
       png_byte ct = png_get_color_type(pp, pi);
       png_byte bd = png_get_bit_depth(pp, pi);
 
       if (bd >= 8 && (ct == PNG_COLOR_TYPE_RGB || ct == PNG_COLOR_TYPE_GRAY) &&
           dp->filler)
           ct |= 4;  
 
       dp->pixel_size = bit_size(pp, ct, bd);
    }
     dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;
     dp->cbRow = png_get_rowbytes(pp, pi);
  
   
  if (dp->cbRow != (dp->bit_width+7)/8)
       png_error(pp, ""bad png_get_rowbytes calculation"");
 
   
    store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
 }","[8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 6, 7]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
200130," PS_SERIALIZER_DECODE_FUNC(php_binary)  
 {
 	const char *p;
 	char *name;
 	const char *endptr = val + vallen;
 	zval *current;
  	int namelen;
  	int has_value;
  	php_unserialize_data_t var_hash;
 	int skip = 0;
  
  	PHP_VAR_UNSERIALIZE_INIT(var_hash);
  
  	for (p = val; p < endptr; ) {
  		zval **tmp;
 		skip = 0;
  		namelen = ((unsigned char)(*p)) & (~PS_BIN_UNDEF);
  
  		if (namelen < 0 || namelen > PS_BIN_MAX || (p + namelen) >= endptr) {
 			PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 			return FAILURE;
 		}
 
 		has_value = *p & PS_BIN_UNDEF ? 0 : 1;
 
 		name = estrndup(p + 1, namelen);
 
 		p += namelen + 1;
  
  		if (zend_hash_find(&EG(symbol_table), name, namelen + 1, (void **) &tmp) == SUCCESS) {
  			if ((Z_TYPE_PP(tmp) == IS_ARRAY && Z_ARRVAL_PP(tmp) == &EG(symbol_table)) || *tmp == PS(http_session_vars)) {
				efree(name);
				continue;
 				skip = 1;
  			}
  		}
  
  		if (has_value) {
  			ALLOC_INIT_ZVAL(current);
  			if (php_var_unserialize(&current, (const unsigned char **) &p, (const unsigned char *) endptr, &var_hash TSRMLS_CC)) {
				php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
 				if (!skip) {
 					php_set_session_var(name, namelen, current, &var_hash  TSRMLS_CC);
 				}
  			} else {
  				PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
  				return FAILURE;
  			}
  			var_push_dtor_no_addref(&var_hash, &current);
  		}
		PS_ADD_VARL(name, namelen);
 		if (!skip) {
 			PS_ADD_VARL(name, namelen);
 		}
  		efree(name);
  	}
  
 	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
 
 	return SUCCESS;
 }
  ","[10, 16, 34, 42, 43, 44, 52, 53, 54, 32, 33, 41, 51]","ext/session/session.c in PHP before 5.6.25 and 7.x before 7.0.10 skips invalid session names in a way that triggers incorrect parsing, which allows remote attackers to inject arbitrary-type session data by leveraging control of a session name, as demonstrated by object injection."
199067," int tpm_open(struct inode *inode, struct file *file)
 {
 	int minor = iminor(inode);
 	struct tpm_chip *chip = NULL, *pos;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(pos, &tpm_chip_list, list) {
 		if (pos->vendor.miscdev.minor == minor) {
 			chip = pos;
 			get_device(chip->dev);
 			break;
 		}
 	}
 	rcu_read_unlock();
 
 	if (!chip)
 		return -ENODEV;
 
 	if (test_and_set_bit(0, &chip->is_open)) {
 		dev_dbg(chip->dev, ""Another process owns this TPM\n"");
 		put_device(chip->dev);
  		return -EBUSY;
  	}
  
	chip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);
 	chip->data_buffer = kzalloc(TPM_BUFSIZE, GFP_KERNEL);
  	if (chip->data_buffer == NULL) {
  		clear_bit(0, &chip->is_open);
  		put_device(chip->dev);
 		return -ENOMEM;
 	}
 
 	atomic_set(&chip->data_pending, 0);
 
 	file->private_data = chip;
 	return 0;
 }","[26, 25]","The tpm_open function in drivers/char/tpm/tpm.c in the Linux kernel before 2.6.39 does not initialize a certain buffer, which allows local users to obtain potentially sensitive information from kernel memory via unspecified vectors."
198759," static int udf_load_logicalvol(struct super_block *sb, sector_t block,
 			       struct kernel_lb_addr *fileset)
 {
 	struct logicalVolDesc *lvd;
 	int i, j, offset;
 	uint8_t type;
 	struct udf_sb_info *sbi = UDF_SB(sb);
  	struct genericPartitionMap *gpm;
  	uint16_t ident;
  	struct buffer_head *bh;
 	unsigned int table_len;
  	int ret = 0;
  
  	bh = udf_read_tagged(sb, block, block, &ident);
  	if (!bh)
  		return 1;
  	BUG_ON(ident != TAG_IDENT_LVD);
  	lvd = (struct logicalVolDesc *)bh->b_data;
 	table_len = le32_to_cpu(lvd->mapTableLength);
 	if (sizeof(*lvd) + table_len > sb->s_blocksize) {
 		udf_err(sb, ""error loading logical volume descriptor: ""
 			""Partition table too long (%u > %lu)\n"", table_len,
 			sb->s_blocksize - sizeof(*lvd));
 		goto out_bh;
 	}
  
  	ret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));
  	if (ret)
  		goto out_bh;
  
  	for (i = 0, offset = 0;
	     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);
 	     i < sbi->s_partitions && offset < table_len;
  	     i++, offset += gpm->partitionMapLength) {
  		struct udf_part_map *map = &sbi->s_partmaps[i];
  		gpm = (struct genericPartitionMap *)
 				&(lvd->partitionMaps[offset]);
 		type = gpm->partitionMapType;
 		if (type == 1) {
 			struct genericPartitionMap1 *gpm1 =
 				(struct genericPartitionMap1 *)gpm;
 			map->s_partition_type = UDF_TYPE1_MAP15;
 			map->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);
 			map->s_partition_num = le16_to_cpu(gpm1->partitionNum);
 			map->s_partition_func = NULL;
 		} else if (type == 2) {
 			struct udfPartitionMap2 *upm2 =
 						(struct udfPartitionMap2 *)gpm;
 			if (!strncmp(upm2->partIdent.ident, UDF_ID_VIRTUAL,
 						strlen(UDF_ID_VIRTUAL))) {
 				u16 suf =
 					le16_to_cpu(((__le16 *)upm2->partIdent.
 							identSuffix)[0]);
 				if (suf < 0x0200) {
 					map->s_partition_type =
 							UDF_VIRTUAL_MAP15;
 					map->s_partition_func =
 							udf_get_pblock_virt15;
 				} else {
 					map->s_partition_type =
 							UDF_VIRTUAL_MAP20;
 					map->s_partition_func =
 							udf_get_pblock_virt20;
 				}
 			} else if (!strncmp(upm2->partIdent.ident,
 						UDF_ID_SPARABLE,
 						strlen(UDF_ID_SPARABLE))) {
 				uint32_t loc;
 				struct sparingTable *st;
 				struct sparablePartitionMap *spm =
 					(struct sparablePartitionMap *)gpm;
 
 				map->s_partition_type = UDF_SPARABLE_MAP15;
 				map->s_type_specific.s_sparing.s_packet_len =
 						le16_to_cpu(spm->packetLength);
 				for (j = 0; j < spm->numSparingTables; j++) {
 					struct buffer_head *bh2;
 
 					loc = le32_to_cpu(
 						spm->locSparingTable[j]);
 					bh2 = udf_read_tagged(sb, loc, loc,
 							     &ident);
 					map->s_type_specific.s_sparing.
 							s_spar_map[j] = bh2;
 
 					if (bh2 == NULL)
 						continue;
 
 					st = (struct sparingTable *)bh2->b_data;
 					if (ident != 0 || strncmp(
 						st->sparingIdent.ident,
 						UDF_ID_SPARING,
 						strlen(UDF_ID_SPARING))) {
 						brelse(bh2);
 						map->s_type_specific.s_sparing.
 							s_spar_map[j] = NULL;
 					}
 				}
 				map->s_partition_func = udf_get_pblock_spar15;
 			} else if (!strncmp(upm2->partIdent.ident,
 						UDF_ID_METADATA,
 						strlen(UDF_ID_METADATA))) {
 				struct udf_meta_data *mdata =
 					&map->s_type_specific.s_metadata;
 				struct metadataPartitionMap *mdm =
 						(struct metadataPartitionMap *)
 						&(lvd->partitionMaps[offset]);
 				udf_debug(""Parsing Logical vol part %d type %d  id=%s\n"",
 					  i, type, UDF_ID_METADATA);
 
 				map->s_partition_type = UDF_METADATA_MAP25;
 				map->s_partition_func = udf_get_pblock_meta25;
 
 				mdata->s_meta_file_loc   =
 					le32_to_cpu(mdm->metadataFileLoc);
 				mdata->s_mirror_file_loc =
 					le32_to_cpu(mdm->metadataMirrorFileLoc);
 				mdata->s_bitmap_file_loc =
 					le32_to_cpu(mdm->metadataBitmapFileLoc);
 				mdata->s_alloc_unit_size =
 					le32_to_cpu(mdm->allocUnitSize);
 				mdata->s_align_unit_size =
 					le16_to_cpu(mdm->alignUnitSize);
 				if (mdm->flags & 0x01)
 					mdata->s_flags |= MF_DUPLICATE_MD;
 
 				udf_debug(""Metadata Ident suffix=0x%x\n"",
 					  le16_to_cpu(*(__le16 *)
 						      mdm->partIdent.identSuffix));
 				udf_debug(""Metadata part num=%d\n"",
 					  le16_to_cpu(mdm->partitionNum));
 				udf_debug(""Metadata part alloc unit size=%d\n"",
 					  le32_to_cpu(mdm->allocUnitSize));
 				udf_debug(""Metadata file loc=%d\n"",
 					  le32_to_cpu(mdm->metadataFileLoc));
 				udf_debug(""Mirror file loc=%d\n"",
 					  le32_to_cpu(mdm->metadataMirrorFileLoc));
 				udf_debug(""Bitmap file loc=%d\n"",
 					  le32_to_cpu(mdm->metadataBitmapFileLoc));
 				udf_debug(""Flags: %d %d\n"",
 					  mdata->s_flags, mdm->flags);
 			} else {
 				udf_debug(""Unknown ident: %s\n"",
 					  upm2->partIdent.ident);
 				continue;
 			}
 			map->s_volumeseqnum = le16_to_cpu(upm2->volSeqNum);
 			map->s_partition_num = le16_to_cpu(upm2->partitionNum);
 		}
 		udf_debug(""Partition (%d:%d) type %d on volume %d\n"",
 			  i, map->s_partition_num, type, map->s_volumeseqnum);
 	}
 
 	if (fileset) {
 		struct long_ad *la = (struct long_ad *)&(lvd->logicalVolContentsUse[0]);
 
 		*fileset = lelb_to_cpu(la->extLocation);
 		udf_debug(""FileSet found in LogicalVolDesc at block=%d, partition=%d\n"",
 			  fileset->logicalBlockNum,
 			  fileset->partitionReferenceNum);
 	}
 	if (lvd->integritySeqExt.extLength)
 		udf_load_logicalvolint(sb, leea_to_cpu(lvd->integritySeqExt));
 
 out_bh:
 	brelse(bh);
 	return ret;
 }","[11, 19, 20, 21, 22, 23, 24, 25, 33, 32]",Heap-based buffer overflow in the udf_load_logicalvol function in fs/udf/super.c in the Linux kernel before 3.4.5 allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted UDF filesystem.
197984," int ssl3_client_hello(SSL *s)
 {
     unsigned char *buf;
     unsigned char *p, *d;
     int i;
     unsigned long l;
     int al = 0;
 #ifndef OPENSSL_NO_COMP
     int j;
     SSL_COMP *comp;
 #endif
 
     buf = (unsigned char *)s->init_buf->data;
     if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
         SSL_SESSION *sess = s->session;
         if ((sess == NULL) ||
             (sess->ssl_version != s->version) ||
             !sess->session_id_length || (sess->not_resumable)) {
             if (!ssl_get_new_session(s, 0))
                 goto err;
         }
         if (s->method->version == DTLS_ANY_VERSION) {
              
             int options = s->options;
              
             if (options & SSL_OP_NO_DTLSv1_2) {
                 if (tls1_suiteb(s)) {
                     SSLerr(SSL_F_SSL3_CLIENT_HELLO,
                            SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                     goto err;
                 }
                  
                 if (options & SSL_OP_NO_DTLSv1) {
                     SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);
                     goto err;
                 }
                  
                 s->method = DTLSv1_client_method();
                 s->version = DTLS1_VERSION;
             } else {
                  
                 if (options & SSL_OP_NO_DTLSv1)
                     s->method = DTLSv1_2_client_method();
                 s->version = DTLS1_2_VERSION;
             }
             s->client_version = s->version;
         }
          
 
         p = s->s3->client_random;
 
          
         if (SSL_IS_DTLS(s)) {
             size_t idx;
             i = 1;
             for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {
                 if (p[idx]) {
                     i = 0;
                     break;
                 }
             }
          } else
              i = 1;
  
        if (i)
            ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random));
         if (i && ssl_fill_hello_random(s, 0, p,
                                        sizeof(s->s3->client_random)) <= 0)
             goto err;
  
           
          d = p = ssl_handshake_start(s);
          
         *(p++) = s->client_version >> 8;
         *(p++) = s->client_version & 0xff;
 
          
         memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
         p += SSL3_RANDOM_SIZE;
 
          
         if (s->new_session)
             i = 0;
         else
             i = s->session->session_id_length;
         *(p++) = i;
         if (i != 0) {
             if (i > (int)sizeof(s->session->session_id)) {
                 SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             memcpy(p, s->session->session_id, i);
             p += i;
         }
 
          
         if (SSL_IS_DTLS(s)) {
             if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
                 SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                 goto err;
             }
             *(p++) = s->d1->cookie_len;
             memcpy(p, s->d1->cookie, s->d1->cookie_len);
             p += s->d1->cookie_len;
         }
 
          
         i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
         if (i == 0) {
             SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
             goto err;
         }
 #ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
          
         if (TLS1_get_version(s) >= TLS1_2_VERSION
             && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
             i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
 #endif
         s2n(i, p);
         p += i;
 
          
 #ifdef OPENSSL_NO_COMP
         *(p++) = 1;
 #else
 
         if (!ssl_allow_compression(s) || !s->ctx->comp_methods)
             j = 0;
         else
             j = sk_SSL_COMP_num(s->ctx->comp_methods);
         *(p++) = 1 + j;
         for (i = 0; i < j; i++) {
             comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
             *(p++) = comp->id;
         }
 #endif
         *(p++) = 0;              
 
 #ifndef OPENSSL_NO_TLSEXT
          
         if (ssl_prepare_clienthello_tlsext(s) <= 0) {
             SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
             goto err;
         }
         if ((p =
              ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,
                                         &al)) == NULL) {
             ssl3_send_alert(s, SSL3_AL_FATAL, al);
             SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
             goto err;
         }
 #endif
 
         l = p - d;
         ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);
         s->state = SSL3_ST_CW_CLNT_HELLO_B;
     }
 
      
     return ssl_do_write(s);
  err:
     return (-1);
 }","[67, 68, 69, 65, 66]","The ssl3_client_hello function in s3_clnt.c in OpenSSL 1.0.2 before 1.0.2a does not ensure that the PRNG is seeded before proceeding with a handshake, which makes it easier for remote attackers to defeat cryptographic protection mechanisms by sniffing the network and then conducting a brute-force attack."
203996,"   static void IBusBusNameOwnerChangedCallback(
      IBusBus* bus,
      const gchar* name, const gchar* old_name, const gchar* new_name,
      gpointer user_data) {
   void IBusBusNameOwnerChanged(IBusBus* bus,
                                const gchar* name,
                                const gchar* old_name,
                                const gchar* new_name) {
      DCHECK(name);
      DCHECK(old_name);
      DCHECK(new_name);
    DLOG(INFO) << ""Name owner is changed: name="" << name
               << "", old_name="" << old_name << "", new_name="" << new_name;
     VLOG(1) << ""Name owner is changed: name="" << name
             << "", old_name="" << old_name << "", new_name="" << new_name;
  
      if (name != std::string(""org.freedesktop.IBus.Config"")) {
       return;
     }
 
     const std::string empty_string;
     if (old_name != empty_string || new_name == empty_string) {
        LOG(WARNING) << ""Unexpected name owner change: name="" << name
                     << "", old_name="" << old_name << "", new_name="" << new_name;
        
        return;
      }
  
    LOG(INFO) << ""IBus config daemon is started. Recovering ibus_config_"";
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
     VLOG(1) << ""IBus config daemon is started. Recovering ibus_config_"";
  
    self->MaybeRestoreConnections();
      
     MaybeRestoreConnections();
    }","[5, 6, 7, 8, 14, 15, 25, 33, 36, 37, 2, 3, 4, 12, 13, 29, 30, 31, 32, 35]","Google Chrome before 13.0.782.107 does not properly handle nested functions in PDF documents, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted document."
6125,"lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,
LYS_NODE type, const struct lys_node **ret)
{
const struct lys_node *node;

assert((mod || parent) && name);
assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));

if (!mod) {
mod = lys_node_module(parent);
}


node = NULL;
while ((node = lys_getnext(node, parent, mod, 0))) {
if (!type || (node->nodetype & type)) {

if (lys_node_module(node) != lys_main_module(mod)) {
continue;
}


if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {
if (ret) {
*ret = node;
}
return EXIT_SUCCESS;
}
}
}

return EXIT_FAILURE;
}","[2, 15]","An invalid memory access flaw is present in libyang before v1.0-r1 in the function resolve_feature_value() when an if-feature statement is used inside a list key node, and the feature used is not defined. Applications that use libyang to parse untrusted input yang files may crash."
199668," static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,
 			       struct msghdr *m, size_t len, int flags)
 
 {
 	struct sock *sk = sock->sk;
 	struct sk_buff *skb;
 	int ret;
 	int copylen;
 
 	ret = -EOPNOTSUPP;
  	if (m->msg_flags&MSG_OOB)
  		goto read_error;
  
	m->msg_namelen = 0;
  	skb = skb_recv_datagram(sk, flags, 0 , &ret);
  	if (!skb)
  		goto read_error;
 	copylen = skb->len;
 	if (len < copylen) {
 		m->msg_flags |= MSG_TRUNC;
 		copylen = len;
 	}
 
 	ret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);
 	if (ret)
 		goto out_free;
 
 	ret = (flags & MSG_TRUNC) ? skb->len : copylen;
 out_free:
 	skb_free_datagram(sk, skb);
 	caif_check_flow_release(sk);
 	return ret;
 
 read_error:
 	return ret;
 }",[14],"The x25_recvmsg function in net/x25/af_x25.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call."
201045," pgm_print(netdissect_options *ndo,
           register const u_char *bp, register u_int length,
           register const u_char *bp2)
 {
 	register const struct pgm_header *pgm;
 	register const struct ip *ip;
 	register char ch;
 	uint16_t sport, dport;
 	u_int nla_afnum;
 	char nla_buf[INET6_ADDRSTRLEN];
 	register const struct ip6_hdr *ip6;
 	uint8_t opt_type, opt_len;
 	uint32_t seq, opts_len, len, offset;
 
 	pgm = (const struct pgm_header *)bp;
 	ip = (const struct ip *)bp2;
 	if (IP_V(ip) == 6)
 		ip6 = (const struct ip6_hdr *)bp2;
 	else
 		ip6 = NULL;
 	ch = '\0';
 	if (!ND_TTEST(pgm->pgm_dport)) {
 		if (ip6) {
 			ND_PRINT((ndo, ""%s > %s: [|pgm]"",
 				ip6addr_string(ndo, &ip6->ip6_src),
 				ip6addr_string(ndo, &ip6->ip6_dst)));
 			return;
 		} else {
 			ND_PRINT((ndo, ""%s > %s: [|pgm]"",
 				ipaddr_string(ndo, &ip->ip_src),
 				ipaddr_string(ndo, &ip->ip_dst)));
 			return;
 		}
 	}
 
 	sport = EXTRACT_16BITS(&pgm->pgm_sport);
 	dport = EXTRACT_16BITS(&pgm->pgm_dport);
 
 	if (ip6) {
 		if (ip6->ip6_nxt == IPPROTO_PGM) {
 			ND_PRINT((ndo, ""%s.%s > %s.%s: "",
 				ip6addr_string(ndo, &ip6->ip6_src),
 				tcpport_string(ndo, sport),
 				ip6addr_string(ndo, &ip6->ip6_dst),
 				tcpport_string(ndo, dport)));
 		} else {
 			ND_PRINT((ndo, ""%s > %s: "",
 				tcpport_string(ndo, sport), tcpport_string(ndo, dport)));
 		}
 	} else {
 		if (ip->ip_p == IPPROTO_PGM) {
 			ND_PRINT((ndo, ""%s.%s > %s.%s: "",
 				ipaddr_string(ndo, &ip->ip_src),
 				tcpport_string(ndo, sport),
 				ipaddr_string(ndo, &ip->ip_dst),
 				tcpport_string(ndo, dport)));
 		} else {
 			ND_PRINT((ndo, ""%s > %s: "",
 				tcpport_string(ndo, sport), tcpport_string(ndo, dport)));
 		}
 	}
 
 	ND_TCHECK(*pgm);
 
         ND_PRINT((ndo, ""PGM, length %u"", EXTRACT_16BITS(&pgm->pgm_length)));
 
         if (!ndo->ndo_vflag)
             return;
 
 	ND_PRINT((ndo, "" 0x%02x%02x%02x%02x%02x%02x "",
 		     pgm->pgm_gsid[0],
                      pgm->pgm_gsid[1],
                      pgm->pgm_gsid[2],
 		     pgm->pgm_gsid[3],
                      pgm->pgm_gsid[4],
                      pgm->pgm_gsid[5]));
 	switch (pgm->pgm_type) {
 	case PGM_SPM: {
 	    const struct pgm_spm *spm;
 
 	    spm = (const struct pgm_spm *)(pgm + 1);
 	    ND_TCHECK(*spm);
 	    bp = (const u_char *) (spm + 1);
 
 	    switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) {
 	    case AFNUM_INET:
 		ND_TCHECK2(*bp, sizeof(struct in_addr));
 		addrtostr(bp, nla_buf, sizeof(nla_buf));
 		bp += sizeof(struct in_addr);
 		break;
 	    case AFNUM_INET6:
 		ND_TCHECK2(*bp, sizeof(struct in6_addr));
 		addrtostr6(bp, nla_buf, sizeof(nla_buf));
 		bp += sizeof(struct in6_addr);
 		break;
 	    default:
 		goto trunc;
 		break;
 	    }
 
 	    ND_PRINT((ndo, ""SPM seq %u trail %u lead %u nla %s"",
 			 EXTRACT_32BITS(&spm->pgms_seq),
                          EXTRACT_32BITS(&spm->pgms_trailseq),
 			 EXTRACT_32BITS(&spm->pgms_leadseq),
                          nla_buf));
 	    break;
 	}
 
 	case PGM_POLL: {
 	    const struct pgm_poll *poll_msg;
 
 	    poll_msg = (const struct pgm_poll *)(pgm + 1);
 	    ND_TCHECK(*poll_msg);
 	    ND_PRINT((ndo, ""POLL seq %u round %u"",
 			 EXTRACT_32BITS(&poll_msg->pgmp_seq),
                          EXTRACT_16BITS(&poll_msg->pgmp_round)));
 	    bp = (const u_char *) (poll_msg + 1);
 	    break;
 	}
 	case PGM_POLR: {
 	    const struct pgm_polr *polr;
 	    uint32_t ivl, rnd, mask;
 
 	    polr = (const struct pgm_polr *)(pgm + 1);
 	    ND_TCHECK(*polr);
 	    bp = (const u_char *) (polr + 1);
 
 	    switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) {
 	    case AFNUM_INET:
 		ND_TCHECK2(*bp, sizeof(struct in_addr));
 		addrtostr(bp, nla_buf, sizeof(nla_buf));
 		bp += sizeof(struct in_addr);
 		break;
 	    case AFNUM_INET6:
 		ND_TCHECK2(*bp, sizeof(struct in6_addr));
 		addrtostr6(bp, nla_buf, sizeof(nla_buf));
 		bp += sizeof(struct in6_addr);
 		break;
 	    default:
 		goto trunc;
 		break;
 	    }
 
 	    ND_TCHECK2(*bp, sizeof(uint32_t));
 	    ivl = EXTRACT_32BITS(bp);
 	    bp += sizeof(uint32_t);
 
 	    ND_TCHECK2(*bp, sizeof(uint32_t));
 	    rnd = EXTRACT_32BITS(bp);
 	    bp += sizeof(uint32_t);
 
 	    ND_TCHECK2(*bp, sizeof(uint32_t));
 	    mask = EXTRACT_32BITS(bp);
 	    bp += sizeof(uint32_t);
 
 	    ND_PRINT((ndo, ""POLR seq %u round %u nla %s ivl %u rnd 0x%08x ""
 			 ""mask 0x%08x"", EXTRACT_32BITS(&polr->pgmp_seq),
 			 EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask));
 	    break;
 	}
 	case PGM_ODATA: {
 	    const struct pgm_data *odata;
 
 	    odata = (const struct pgm_data *)(pgm + 1);
 	    ND_TCHECK(*odata);
 	    ND_PRINT((ndo, ""ODATA trail %u seq %u"",
 			 EXTRACT_32BITS(&odata->pgmd_trailseq),
 			 EXTRACT_32BITS(&odata->pgmd_seq)));
 	    bp = (const u_char *) (odata + 1);
 	    break;
 	}
 
 	case PGM_RDATA: {
 	    const struct pgm_data *rdata;
 
 	    rdata = (const struct pgm_data *)(pgm + 1);
 	    ND_TCHECK(*rdata);
 	    ND_PRINT((ndo, ""RDATA trail %u seq %u"",
 			 EXTRACT_32BITS(&rdata->pgmd_trailseq),
 			 EXTRACT_32BITS(&rdata->pgmd_seq)));
 	    bp = (const u_char *) (rdata + 1);
 	    break;
 	}
 
 	case PGM_NAK:
 	case PGM_NULLNAK:
 	case PGM_NCF: {
 	    const struct pgm_nak *nak;
 	    char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN];
 
 	    nak = (const struct pgm_nak *)(pgm + 1);
 	    ND_TCHECK(*nak);
 	    bp = (const u_char *) (nak + 1);
 
 	     
 	    switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) {
 	    case AFNUM_INET:
 		ND_TCHECK2(*bp, sizeof(struct in_addr));
 		addrtostr(bp, source_buf, sizeof(source_buf));
 		bp += sizeof(struct in_addr);
 		break;
 	    case AFNUM_INET6:
 		ND_TCHECK2(*bp, sizeof(struct in6_addr));
 		addrtostr6(bp, source_buf, sizeof(source_buf));
 		bp += sizeof(struct in6_addr);
 		break;
 	    default:
 		goto trunc;
 		break;
 	    }
 
 	     
 	    bp += (2 * sizeof(uint16_t));
 	    switch (EXTRACT_16BITS(bp)) {
 	    case AFNUM_INET:
 		ND_TCHECK2(*bp, sizeof(struct in_addr));
 		addrtostr(bp, group_buf, sizeof(group_buf));
 		bp += sizeof(struct in_addr);
 		break;
 	    case AFNUM_INET6:
 		ND_TCHECK2(*bp, sizeof(struct in6_addr));
 		addrtostr6(bp, group_buf, sizeof(group_buf));
 		bp += sizeof(struct in6_addr);
 		break;
 	    default:
 		goto trunc;
 		break;
 	    }
 
 	     
 	    switch (pgm->pgm_type) {
 		case PGM_NAK:
 		    ND_PRINT((ndo, ""NAK ""));
 		    break;
 		case PGM_NULLNAK:
 		    ND_PRINT((ndo, ""NNAK ""));
 		    break;
 		case PGM_NCF:
 		    ND_PRINT((ndo, ""NCF ""));
 		    break;
 		default:
                     break;
 	    }
 	    ND_PRINT((ndo, ""(%s -> %s), seq %u"",
 			 source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq)));
 	    break;
 	}
 
 	case PGM_ACK: {
 	    const struct pgm_ack *ack;
 
 	    ack = (const struct pgm_ack *)(pgm + 1);
 	    ND_TCHECK(*ack);
 	    ND_PRINT((ndo, ""ACK seq %u"",
 			 EXTRACT_32BITS(&ack->pgma_rx_max_seq)));
 	    bp = (const u_char *) (ack + 1);
 	    break;
 	}
 
 	case PGM_SPMR:
 	    ND_PRINT((ndo, ""SPMR""));
 	    break;
 
 	default:
 	    ND_PRINT((ndo, ""UNKNOWN type 0x%02x"", pgm->pgm_type));
 	    break;
 
 	}
 	if (pgm->pgm_options & PGM_OPT_BIT_PRESENT) {
 
 	     
 	    if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) {
 		ND_PRINT((ndo, ""[|OPT]""));
 		return;
 	    }
 
 	     
 	    opt_type = *bp++;
 	    if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) {
 		ND_PRINT((ndo, ""[First option bad, should be PGM_OPT_LENGTH, is %u]"", opt_type & PGM_OPT_MASK));
 		return;
 	    }
 	    opt_len = *bp++;
 	    if (opt_len != 4) {
 		ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != 4]"", opt_len));
 		return;
 	    }
 	    opts_len = EXTRACT_16BITS(bp);
 	    if (opts_len < 4) {
 		ND_PRINT((ndo, ""[Bad total option length %u < 4]"", opts_len));
 		return;
 	    }
 	    bp += sizeof(uint16_t);
 	    ND_PRINT((ndo, "" OPTS LEN %d"", opts_len));
 	    opts_len -= 4;
 
 	    while (opts_len) {
 		if (opts_len < PGM_MIN_OPT_LEN) {
 		    ND_PRINT((ndo, ""[Total option length leaves no room for final option]""));
 		    return;
 		}
 		if (!ND_TTEST2(*bp, 2)) {
 		    ND_PRINT((ndo, "" [|OPT]""));
 		    return;
 		}
 		opt_type = *bp++;
 		opt_len = *bp++;
 		if (opt_len < PGM_MIN_OPT_LEN) {
 		    ND_PRINT((ndo, ""[Bad option, length %u < %u]"", opt_len,
 		        PGM_MIN_OPT_LEN));
 		    break;
 		}
 		if (opts_len < opt_len) {
 		    ND_PRINT((ndo, ""[Total option length leaves no room for final option]""));
 		    return;
 		}
 		if (!ND_TTEST2(*bp, opt_len - 2)) {
 		    ND_PRINT((ndo, "" [|OPT]""));
 		    return;
 		}
  
  		switch (opt_type & PGM_OPT_MASK) {
  		case PGM_OPT_LENGTH:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != 4]"", opt_len));
 #define PGM_OPT_LENGTH_LEN	(2+2)
 		    if (opt_len != PGM_OPT_LENGTH_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != %u]"",
 			    opt_len, PGM_OPT_LENGTH_LEN));
  			return;
  		    }
  		    ND_PRINT((ndo, "" OPTS LEN (extra?) %d"", EXTRACT_16BITS(bp)));
		    bp += sizeof(uint16_t);
		    opts_len -= 4;
 		    bp += 2;
 		    opts_len -= PGM_OPT_LENGTH_LEN;
  		    break;
  
  		case PGM_OPT_FRAGMENT:
		    if (opt_len != 16) {
			ND_PRINT((ndo, ""[Bad OPT_FRAGMENT option, length %u != 16]"", opt_len));
 #define PGM_OPT_FRAGMENT_LEN	(2+2+4+4+4)
 		    if (opt_len != PGM_OPT_FRAGMENT_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_FRAGMENT option, length %u != %u]"",
 			    opt_len, PGM_OPT_FRAGMENT_LEN));
  			return;
  		    }
  		    bp += 2;
  		    seq = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    offset = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    len = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" FRAG seq %u off %u len %u"", seq, offset, len));
		    opts_len -= 16;
 		    opts_len -= PGM_OPT_FRAGMENT_LEN;
  		    break;
  
  		case PGM_OPT_NAK_LIST:
  		    bp += 2;
		    opt_len -= sizeof(uint32_t);	 
 		    opt_len -= 4;	 
  		    ND_PRINT((ndo, "" NAK LIST""));
  		    while (opt_len) {
			if (opt_len < sizeof(uint32_t)) {
 			if (opt_len < 4) {
  			    ND_PRINT((ndo, ""[Option length not a multiple of 4]""));
  			    return;
  			}
			ND_TCHECK2(*bp, sizeof(uint32_t));
 			ND_TCHECK2(*bp, 4);
  			ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(bp)));
			bp += sizeof(uint32_t);
			opt_len -= sizeof(uint32_t);
			opts_len -= sizeof(uint32_t);
 			bp += 4;
 			opt_len -= 4;
 			opts_len -= 4;
  		    }
  		    break;
  
  		case PGM_OPT_JOIN:
		    if (opt_len != 8) {
			ND_PRINT((ndo, ""[Bad OPT_JOIN option, length %u != 8]"", opt_len));
 #define PGM_OPT_JOIN_LEN	(2+2+4)
 		    if (opt_len != PGM_OPT_JOIN_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_JOIN option, length %u != %u]"",
 			    opt_len, PGM_OPT_JOIN_LEN));
  			return;
  		    }
  		    bp += 2;
  		    seq = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" JOIN %u"", seq));
		    opts_len -= 8;
 		    opts_len -= PGM_OPT_JOIN_LEN;
  		    break;
  
  		case PGM_OPT_NAK_BO_IVL:
		    if (opt_len != 12) {
			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_IVL option, length %u != 12]"", opt_len));
 #define PGM_OPT_NAK_BO_IVL_LEN	(2+2+4+4)
 		    if (opt_len != PGM_OPT_NAK_BO_IVL_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_IVL option, length %u != %u]"",
 			    opt_len, PGM_OPT_NAK_BO_IVL_LEN));
  			return;
  		    }
  		    bp += 2;
  		    offset = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    seq = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" BACKOFF ivl %u ivlseq %u"", offset, seq));
		    opts_len -= 12;
 		    opts_len -= PGM_OPT_NAK_BO_IVL_LEN;
  		    break;
  
  		case PGM_OPT_NAK_BO_RNG:
		    if (opt_len != 12) {
			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_RNG option, length %u != 12]"", opt_len));
 #define PGM_OPT_NAK_BO_RNG_LEN	(2+2+4+4)
 		    if (opt_len != PGM_OPT_NAK_BO_RNG_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_NAK_BO_RNG option, length %u != %u]"",
 			    opt_len, PGM_OPT_NAK_BO_RNG_LEN));
  			return;
  		    }
  		    bp += 2;
  		    offset = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    seq = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" BACKOFF max %u min %u"", offset, seq));
		    opts_len -= 12;
 		    opts_len -= PGM_OPT_NAK_BO_RNG_LEN;
  		    break;
  
  		case PGM_OPT_REDIRECT:
 #define PGM_OPT_REDIRECT_FIXED_LEN	(2+2+2+2)
 		    if (opt_len < PGM_OPT_REDIRECT_FIXED_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u < %u]"",
 			    opt_len, PGM_OPT_REDIRECT_FIXED_LEN));
 			return;
 		    }
  		    bp += 2;
  		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += (2 * sizeof(uint16_t));
 		    bp += 2+2;
  		    switch (nla_afnum) {
  		    case AFNUM_INET:
			if (opt_len != 4 + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != 4 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != %u + address size]"",
 			        opt_len, PGM_OPT_REDIRECT_FIXED_LEN));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in_addr));
  			addrtostr(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in_addr);
			opts_len -= 4 + sizeof(struct in_addr);
 			opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in_addr);
  			break;
  		    case AFNUM_INET6:
			if (opt_len != 4 + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != 4 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != %u + address size]"",
 			        PGM_OPT_REDIRECT_FIXED_LEN, opt_len));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in6_addr));
  			addrtostr6(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in6_addr);
			opts_len -= 4 + sizeof(struct in6_addr);
 			opts_len -= PGM_OPT_REDIRECT_FIXED_LEN + sizeof(struct in6_addr);
  			break;
  		    default:
  			goto trunc;
 			break;
 		    }
 
 		    ND_PRINT((ndo, "" REDIRECT %s"",  nla_buf));
  		    break;
  
  		case PGM_OPT_PARITY_PRM:
		    if (opt_len != 8) {
			ND_PRINT((ndo, ""[Bad OPT_PARITY_PRM option, length %u != 8]"", opt_len));
 #define PGM_OPT_PARITY_PRM_LEN	(2+2+4)
 		    if (opt_len != PGM_OPT_PARITY_PRM_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_PARITY_PRM option, length %u != %u]"",
 			    opt_len, PGM_OPT_PARITY_PRM_LEN));
  			return;
  		    }
  		    bp += 2;
  		    len = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" PARITY MAXTGS %u"", len));
		    opts_len -= 8;
 		    opts_len -= PGM_OPT_PARITY_PRM_LEN;
  		    break;
  
  		case PGM_OPT_PARITY_GRP:
		    if (opt_len != 8) {
			ND_PRINT((ndo, ""[Bad OPT_PARITY_GRP option, length %u != 8]"", opt_len));
 #define PGM_OPT_PARITY_GRP_LEN	(2+2+4)
 		    if (opt_len != PGM_OPT_PARITY_GRP_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_PARITY_GRP option, length %u != %u]"",
 			    opt_len, PGM_OPT_PARITY_GRP_LEN));
  			return;
  		    }
  		    bp += 2;
  		    seq = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" PARITY GROUP %u"", seq));
		    opts_len -= 8;
 		    opts_len -= PGM_OPT_PARITY_GRP_LEN;
  		    break;
  
  		case PGM_OPT_CURR_TGSIZE:
		    if (opt_len != 8) {
			ND_PRINT((ndo, ""[Bad OPT_CURR_TGSIZE option, length %u != 8]"", opt_len));
 #define PGM_OPT_CURR_TGSIZE_LEN	(2+2+4)
 		    if (opt_len != PGM_OPT_CURR_TGSIZE_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_CURR_TGSIZE option, length %u != %u]"",
 			    opt_len, PGM_OPT_CURR_TGSIZE_LEN));
  			return;
  		    }
  		    bp += 2;
  		    len = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    ND_PRINT((ndo, "" PARITY ATGS %u"", len));
		    opts_len -= 8;
 		    opts_len -= PGM_OPT_CURR_TGSIZE_LEN;
  		    break;
  
  		case PGM_OPT_NBR_UNREACH:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_NBR_UNREACH option, length %u != 4]"", opt_len));
 #define PGM_OPT_NBR_UNREACH_LEN	(2+2)
 		    if (opt_len != PGM_OPT_NBR_UNREACH_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_NBR_UNREACH option, length %u != %u]"",
 			    opt_len, PGM_OPT_NBR_UNREACH_LEN));
  			return;
  		    }
  		    bp += 2;
  		    ND_PRINT((ndo, "" NBR_UNREACH""));
		    opts_len -= 4;
 		    opts_len -= PGM_OPT_NBR_UNREACH_LEN;
  		    break;
  
  		case PGM_OPT_PATH_NLA:
 		    ND_PRINT((ndo, "" PATH_NLA [%d]"", opt_len));
 		    bp += opt_len;
 		    opts_len -= opt_len;
  		    break;
  
  		case PGM_OPT_SYN:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_SYN option, length %u != 4]"", opt_len));
 #define PGM_OPT_SYN_LEN	(2+2)
 		    if (opt_len != PGM_OPT_SYN_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_SYN option, length %u != %u]"",
 			    opt_len, PGM_OPT_SYN_LEN));
  			return;
  		    }
  		    bp += 2;
  		    ND_PRINT((ndo, "" SYN""));
		    opts_len -= 4;
 		    opts_len -= PGM_OPT_SYN_LEN;
  		    break;
  
  		case PGM_OPT_FIN:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_FIN option, length %u != 4]"", opt_len));
 #define PGM_OPT_FIN_LEN	(2+2)
 		    if (opt_len != PGM_OPT_FIN_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_FIN option, length %u != %u]"",
 			    opt_len, PGM_OPT_FIN_LEN));
  			return;
  		    }
  		    bp += 2;
  		    ND_PRINT((ndo, "" FIN""));
		    opts_len -= 4;
 		    opts_len -= PGM_OPT_FIN_LEN;
  		    break;
  
  		case PGM_OPT_RST:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_RST option, length %u != 4]"", opt_len));
 #define PGM_OPT_RST_LEN	(2+2)
 		    if (opt_len != PGM_OPT_RST_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_RST option, length %u != %u]"",
 			    opt_len, PGM_OPT_RST_LEN));
  			return;
  		    }
  		    bp += 2;
  		    ND_PRINT((ndo, "" RST""));
		    opts_len -= 4;
 		    opts_len -= PGM_OPT_RST_LEN;
  		    break;
  
  		case PGM_OPT_CR:
 		    ND_PRINT((ndo, "" CR""));
 		    bp += opt_len;
 		    opts_len -= opt_len;
  		    break;
  
  		case PGM_OPT_CRQST:
		    if (opt_len != 4) {
			ND_PRINT((ndo, ""[Bad OPT_CRQST option, length %u != 4]"", opt_len));
 #define PGM_OPT_CRQST_LEN	(2+2)
 		    if (opt_len != PGM_OPT_CRQST_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_CRQST option, length %u != %u]"",
 			    opt_len, PGM_OPT_CRQST_LEN));
  			return;
  		    }
  		    bp += 2;
  		    ND_PRINT((ndo, "" CRQST""));
		    opts_len -= 4;
 		    opts_len -= PGM_OPT_CRQST_LEN;
  		    break;
  
  		case PGM_OPT_PGMCC_DATA:
 #define PGM_OPT_PGMCC_DATA_FIXED_LEN	(2+2+4+2+2)
 		    if (opt_len < PGM_OPT_PGMCC_DATA_FIXED_LEN) {
 			ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u < %u]"",
 			    opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
 			return;
 		    }
  		    bp += 2;
  		    offset = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += (2 * sizeof(uint16_t));
 		    bp += 2+2;
  		    switch (nla_afnum) {
  		    case AFNUM_INET:
			if (opt_len != 12 + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != %u + address size]"",
 			        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in_addr));
  			addrtostr(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in_addr);
			opts_len -= 12 + sizeof(struct in_addr);
 			opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in_addr);
  			break;
  		    case AFNUM_INET6:
			if (opt_len != 12 + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != %u + address size]"",
 			        opt_len, PGM_OPT_PGMCC_DATA_FIXED_LEN));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in6_addr));
  			addrtostr6(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in6_addr);
			opts_len -= 12 + sizeof(struct in6_addr);
 			opts_len -= PGM_OPT_PGMCC_DATA_FIXED_LEN + sizeof(struct in6_addr);
  			break;
  		    default:
  			goto trunc;
 			break;
 		    }
 
 		    ND_PRINT((ndo, "" PGMCC DATA %u %s"", offset, nla_buf));
  		    break;
  
  		case PGM_OPT_PGMCC_FEEDBACK:
 #define PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN	(2+2+4+2+2)
 		    if (opt_len < PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN) {
 			ND_PRINT((ndo, ""[Bad PGM_OPT_PGMCC_FEEDBACK option, length %u < %u]"",
 			    opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
 			return;
 		    }
  		    bp += 2;
  		    offset = EXTRACT_32BITS(bp);
		    bp += sizeof(uint32_t);
 		    bp += 4;
  		    nla_afnum = EXTRACT_16BITS(bp);
		    bp += (2 * sizeof(uint16_t));
 		    bp += 2+2;
  		    switch (nla_afnum) {
  		    case AFNUM_INET:
			if (opt_len != 12 + sizeof(struct in_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]"",
 			        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in_addr));
  			addrtostr(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in_addr);
			opts_len -= 12 + sizeof(struct in_addr);
 			opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in_addr);
  			break;
  		    case AFNUM_INET6:
			if (opt_len != 12 + sizeof(struct in6_addr)) {
			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len));
 			if (opt_len != PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr)) {
 			    ND_PRINT((ndo, ""[Bad OPT_PGMCC_FEEDBACK option, length %u != %u + address size]"",
 			        opt_len, PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN));
  			    return;
  			}
  			ND_TCHECK2(*bp, sizeof(struct in6_addr));
  			addrtostr6(bp, nla_buf, sizeof(nla_buf));
  			bp += sizeof(struct in6_addr);
			opts_len -= 12 + sizeof(struct in6_addr);
 			opts_len -= PGM_OPT_PGMCC_FEEDBACK_FIXED_LEN + sizeof(struct in6_addr);
  			break;
  		    default:
  			goto trunc;
 			break;
 		    }
 
 		    ND_PRINT((ndo, "" PGMCC FEEDBACK %u %s"", offset, nla_buf));
 		    break;
 
 		default:
 		    ND_PRINT((ndo, "" OPT_%02X [%d] "", opt_type, opt_len));
 		    bp += opt_len;
 		    opts_len -= opt_len;
 		    break;
 		}
 
 		if (opt_type & PGM_OPT_END)
 		    break;
 	     }
 	}
 
 	ND_PRINT((ndo, "" [%u]"", length));
 	if (ndo->ndo_packettype == PT_PGM_ZMTP1 &&
 	    (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA))
 		zmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length));
 
 	return;
 
 trunc:
 	ND_PRINT((ndo, ""[|pgm]""));
 	if (ch != '\0')
 		ND_PRINT((ndo, "">""));
 }","[326, 327, 328, 329, 335, 336, 342, 343, 344, 345, 351, 354, 357, 360, 366, 370, 375, 380, 381, 382, 389, 390, 391, 392, 398, 401, 407, 408, 409, 410, 416, 419, 422, 428, 429, 430, 431, 437, 440, 443, 447, 448, 449, 450, 451, 452, 456, 461, 462, 463, 470, 475, 476, 477, 484, 497, 498, 499, 500, 506, 509, 515, 516, 517, 518, 524, 527, 533, 534, 535, 536, 542, 545, 551, 552, 553, 554, 560, 572, 573, 574, 575, 581, 587, 588, 589, 590, 596, 602, 603, 604, 605, 611, 623, 624, 625, 626, 632, 636, 637, 638, 639, 640, 641, 645, 648, 653, 654, 655, 662, 667, 668, 669, 676, 687, 688, 689, 690, 691, 692, 696, 699, 704, 705, 706, 713, 718, 719, 720, 727, 324, 325, 333, 334, 340, 341, 350, 353, 356, 359, 365, 369, 374, 377, 378, 379, 387, 388, 397, 400, 405, 406, 415, 418, 421, 426, 427, 436, 439, 442, 455, 459, 460, 469, 473, 474, 483, 495, 496, 505, 508, 513, 514, 523, 526, 531, 532, 541, 544, 549, 550, 559, 570, 571, 580, 585, 586, 595, 600, 601, 610, 621, 622, 631, 644, 647, 651, 652, 661, 665, 666, 675, 695, 698, 702, 703, 712, 716, 717, 726]",The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print().
197894," static void lsi_execute_script(LSIState *s)
 {
     PCIDevice *pci_dev = PCI_DEVICE(s);
     uint32_t insn;
     uint32_t addr, addr_high;
     int opcode;
     int insn_processed = 0;
 
     s->istat1 |= LSI_ISTAT1_SRUN;
 again:
  
      s->istat1 |= LSI_ISTAT1_SRUN;
  again:
    insn_processed++;
     if (++insn_processed > LSI_MAX_INSN) {
          
         if (!(s->sien0 & LSI_SIST0_UDC)) {
             qemu_log_mask(LOG_GUEST_ERROR,
                           ""lsi_scsi: inf. loop with UDC masked"");
         }
         lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
         lsi_disconnect(s);
         trace_lsi_execute_script_stop();
         return;
     }
      insn = read_dword(s, s->dsp);
      if (!insn) {
           
         s->ia = s->dsp - 8;
         if (insn & (1 << 29)) {
              
             addr = read_dword(s, addr);
         } else if (insn & (1 << 28)) {
             uint32_t buf[2];
             int32_t offset;
              
 
              
             offset = sextract32(addr, 0, 24);
             pci_dma_read(pci_dev, s->dsa + offset, buf, 8);
              
             s->dbc = cpu_to_le32(buf[0]) & 0xffffff;
             s->rbc = s->dbc;
             addr = cpu_to_le32(buf[1]);
 
              
             if (lsi_dma_40bit(s))
                 addr_high = cpu_to_le32(buf[0]) >> 24;
             else if (lsi_dma_ti64bit(s)) {
                 int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;
                 switch (selector) {
                 case 0 ... 0x0f:
                      
                     addr_high = s->scratch[2 + selector];
                     break;
                 case 0x10:
                     addr_high = s->mmrs;
                     break;
                 case 0x11:
                     addr_high = s->mmws;
                     break;
                 case 0x12:
                     addr_high = s->sfs;
                     break;
                 case 0x13:
                     addr_high = s->drs;
                     break;
                 case 0x14:
                     addr_high = s->sbms;
                     break;
                 case 0x15:
                     addr_high = s->dbms;
                     break;
                 default:
                     qemu_log_mask(LOG_GUEST_ERROR,
                           ""lsi_scsi: Illegal selector specified (0x%x > 0x15) ""
                           ""for 64-bit DMA block move"", selector);
                     break;
                 }
             }
         } else if (lsi_dma_64bit(s)) {
              
             s->dbms = read_dword(s, s->dsp);
             s->dsp += 4;
             s->ia = s->dsp - 12;
         }
         if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {
             trace_lsi_execute_script_blockmove_badphase(
                     scsi_phase_name(s->sstat1),
                     scsi_phase_name(insn >> 24));
             lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);
             break;
         }
         s->dnad = addr;
         s->dnad64 = addr_high;
         switch (s->sstat1 & 0x7) {
         case PHASE_DO:
             s->waiting = LSI_DMA_SCRIPTS;
             lsi_do_dma(s, 1);
             if (s->waiting)
                 s->waiting = LSI_DMA_IN_PROGRESS;
             break;
         case PHASE_DI:
             s->waiting = LSI_DMA_SCRIPTS;
             lsi_do_dma(s, 0);
             if (s->waiting)
                 s->waiting = LSI_DMA_IN_PROGRESS;
             break;
         case PHASE_CMD:
             lsi_do_command(s);
             break;
         case PHASE_ST:
             lsi_do_status(s);
             break;
         case PHASE_MO:
             lsi_do_msgout(s);
             break;
         case PHASE_MI:
             lsi_do_msgin(s);
             break;
         default:
             qemu_log_mask(LOG_UNIMP, ""lsi_scsi: Unimplemented phase %s\n"",
                           scsi_phase_name(s->sstat1));
         }
         s->dfifo = s->dbc & 0xff;
         s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);
         s->sbc = s->dbc;
         s->rbc -= s->dbc;
         s->ua = addr + s->dbc;
         break;
 
     case 1:  
         opcode = (insn >> 27) & 7;
         if (opcode < 5) {
             uint32_t id;
 
             if (insn & (1 << 25)) {
                 id = read_dword(s, s->dsa + sextract32(insn, 0, 24));
             } else {
                 id = insn;
             }
             id = (id >> 16) & 0xf;
             if (insn & (1 << 26)) {
                 addr = s->dsp + sextract32(addr, 0, 24);
             }
             s->dnad = addr;
             switch (opcode) {
             case 0:  
                 s->sdid = id;
                 if (s->scntl1 & LSI_SCNTL1_CON) {
                     trace_lsi_execute_script_io_alreadyreselected();
                     s->dsp = s->dnad;
                     break;
                 }
                 s->sstat0 |= LSI_SSTAT0_WOA;
                 s->scntl1 &= ~LSI_SCNTL1_IARB;
                 if (!scsi_device_find(&s->bus, 0, id, 0)) {
                     lsi_bad_selection(s, id);
                     break;
                 }
                 trace_lsi_execute_script_io_selected(id,
                                              insn & (1 << 3) ? "" ATN"" : """");
                  
                 s->select_tag = id << 8;
                 s->scntl1 |= LSI_SCNTL1_CON;
                 if (insn & (1 << 3)) {
                     s->socl |= LSI_SOCL_ATN;
                     s->sbcl |= LSI_SBCL_ATN;
                 }
                 s->sbcl |= LSI_SBCL_BSY;
                 lsi_set_phase(s, PHASE_MO);
                 s->waiting = LSI_NOWAIT;
                 break;
             case 1:  
                 trace_lsi_execute_script_io_disconnect();
                 s->scntl1 &= ~LSI_SCNTL1_CON;
                  
                 if (!s->current) {
                     lsi_request *p = get_pending_req(s);
                     if (p) {
                         lsi_reselect(s, p);
                     }
                 }
                 break;
             case 2:  
                 if (s->istat0 & LSI_ISTAT0_SIGP) {
                     s->dsp = s->dnad;
                 } else if (!lsi_irq_on_rsl(s)) {
                         lsi_wait_reselect(s);
                 }
                 break;
             case 3:  
                 trace_lsi_execute_script_io_set(
                         insn & (1 << 3) ? "" ATN"" : """",
                         insn & (1 << 6) ? "" ACK"" : """",
                         insn & (1 << 9) ? "" TM"" : """",
                         insn & (1 << 10) ? "" CC"" : """");
                 if (insn & (1 << 3)) {
                     s->socl |= LSI_SOCL_ATN;
                     s->sbcl |= LSI_SBCL_ATN;
                     lsi_set_phase(s, PHASE_MO);
                 }
 
                 if (insn & (1 << 6)) {
                     s->sbcl |= LSI_SBCL_ACK;
                 }
 
                 if (insn & (1 << 9)) {
                     qemu_log_mask(LOG_UNIMP,
                         ""lsi_scsi: Target mode not implemented\n"");
                 }
                 if (insn & (1 << 10))
                     s->carry = 1;
                 break;
             case 4:  
                 trace_lsi_execute_script_io_clear(
                         insn & (1 << 3) ? "" ATN"" : """",
                         insn & (1 << 6) ? "" ACK"" : """",
                         insn & (1 << 9) ? "" TM"" : """",
                         insn & (1 << 10) ? "" CC"" : """");
                 if (insn & (1 << 3)) {
                     s->socl &= ~LSI_SOCL_ATN;
                     s->sbcl &= ~LSI_SBCL_ATN;
                 }
 
                 if (insn & (1 << 6)) {
                     s->sbcl &= ~LSI_SBCL_ACK;
                 }
 
                 if (insn & (1 << 10))
                     s->carry = 0;
                 break;
             }
         } else {
             uint8_t op0;
             uint8_t op1;
             uint8_t data8;
             int reg;
             int operator;
 
             static const char *opcode_names[3] =
                 {""Write"", ""Read"", ""Read-Modify-Write""};
             static const char *operator_names[8] =
                 {""MOV"", ""SHL"", ""OR"", ""XOR"", ""AND"", ""SHR"", ""ADD"", ""ADC""};
 
             reg = ((insn >> 16) & 0x7f) | (insn & 0x80);
             data8 = (insn >> 8) & 0xff;
             opcode = (insn >> 27) & 7;
             operator = (insn >> 24) & 7;
             trace_lsi_execute_script_io_opcode(
                     opcode_names[opcode - 5], reg,
                     operator_names[operator], data8, s->sfbr,
                     (insn & (1 << 23)) ? "" SFBR"" : """");
             op0 = op1 = 0;
             switch (opcode) {
             case 5:  
                 op0 = s->sfbr;
                 op1 = data8;
                 break;
             case 6:  
                 if (operator)
                     op0 = lsi_reg_readb(s, reg);
                 op1 = data8;
                 break;
             case 7:  
                 if (operator)
                     op0 = lsi_reg_readb(s, reg);
                 if (insn & (1 << 23)) {
                     op1 = s->sfbr;
                 } else {
                     op1 = data8;
                 }
                 break;
             }
 
             switch (operator) {
             case 0:  
                 op0 = op1;
                 break;
             case 1:  
                 op1 = op0 >> 7;
                 op0 = (op0 << 1) | s->carry;
                 s->carry = op1;
                 break;
             case 2:  
                 op0 |= op1;
                 break;
             case 3:  
                 op0 ^= op1;
                 break;
             case 4:  
                 op0 &= op1;
                 break;
             case 5:  
                 op1 = op0 & 1;
                 op0 = (op0 >> 1) | (s->carry << 7);
                 s->carry = op1;
                 break;
             case 6:  
                 op0 += op1;
                 s->carry = op0 < op1;
                 break;
             case 7:  
                 op0 += op1 + s->carry;
                 if (s->carry)
                     s->carry = op0 <= op1;
                 else
                     s->carry = op0 < op1;
                 break;
             }
 
             switch (opcode) {
             case 5:  
             case 7:  
                 lsi_reg_writeb(s, reg, op0);
                 break;
             case 6:  
                 s->sfbr = op0;
                 break;
             }
         }
         break;
 
     case 2:  
         {
             int cond;
             int jmp;
 
             if ((insn & 0x002e0000) == 0) {
                 trace_lsi_execute_script_tc_nop();
                 break;
             }
             if (s->sist1 & LSI_SIST1_STO) {
                 trace_lsi_execute_script_tc_delayedselect_timeout();
                 lsi_stop_script(s);
                 break;
             }
             cond = jmp = (insn & (1 << 19)) != 0;
             if (cond == jmp && (insn & (1 << 21))) {
                 trace_lsi_execute_script_tc_compc(s->carry == jmp);
                 cond = s->carry != 0;
             }
             if (cond == jmp && (insn & (1 << 17))) {
                 trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),
                         jmp ? '=' : '!', scsi_phase_name(insn >> 24));
                 cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);
             }
             if (cond == jmp && (insn & (1 << 18))) {
                 uint8_t mask;
 
                 mask = (~insn >> 8) & 0xff;
                 trace_lsi_execute_script_tc_compd(
                         s->sfbr, mask, jmp ? '=' : '!', insn & mask);
                 cond = (s->sfbr & mask) == (insn & mask);
             }
             if (cond == jmp) {
                 if (insn & (1 << 23)) {
                      
                     addr = s->dsp + sextract32(addr, 0, 24);
                 }
                 switch ((insn >> 27) & 7) {
                 case 0:  
                     trace_lsi_execute_script_tc_jump(addr);
                     s->adder = addr;
                     s->dsp = addr;
                     break;
                 case 1:  
                     trace_lsi_execute_script_tc_call(addr);
                     s->temp = s->dsp;
                     s->dsp = addr;
                     break;
                 case 2:  
                     trace_lsi_execute_script_tc_return(s->temp);
                     s->dsp = s->temp;
                     break;
                 case 3:  
                     trace_lsi_execute_script_tc_interrupt(s->dsps);
                     if ((insn & (1 << 20)) != 0) {
                         s->istat0 |= LSI_ISTAT0_INTF;
                         lsi_update_irq(s);
                     } else {
                         lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);
                     }
                     break;
                 default:
                     trace_lsi_execute_script_tc_illegal();
                     lsi_script_dma_interrupt(s, LSI_DSTAT_IID);
                     break;
                 }
             } else {
                 trace_lsi_execute_script_tc_cc_failed();
             }
         }
         break;
 
     case 3:
         if ((insn & (1 << 29)) == 0) {
              
             uint32_t dest;
              
             dest = read_dword(s, s->dsp);
             s->dsp += 4;
             lsi_memcpy(s, dest, addr, insn & 0xffffff);
         } else {
             uint8_t data[7];
             int reg;
             int n;
             int i;
 
             if (insn & (1 << 28)) {
                 addr = s->dsa + sextract32(addr, 0, 24);
             }
             n = (insn & 7);
             reg = (insn >> 16) & 0xff;
             if (insn & (1 << 24)) {
                 pci_dma_read(pci_dev, addr, data, n);
                 trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);
                 for (i = 0; i < n; i++) {
                     lsi_reg_writeb(s, reg + i, data[i]);
                 }
             } else {
                 trace_lsi_execute_script_mm_store(reg, n, addr);
                 for (i = 0; i < n; i++) {
                     data[i] = lsi_reg_readb(s, reg + i);
                 }
                 pci_dma_write(pci_dev, addr, data, n);
             }
         }
     }
     if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {
          
         if (!(s->sien0 & LSI_SIST0_UDC)) {
             qemu_log_mask(LOG_GUEST_ERROR,
                           ""lsi_scsi: inf. loop with UDC masked"");
         }
         lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);
         lsi_disconnect(s);
     } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {
         if (s->dcntl & LSI_DCNTL_SSM) {
              }
          }
      }","[15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 14]","In QEMU 1:4.1-1, 1:2.1+dfsg-12+deb8u6, 1:2.8+dfsg-6+deb9u8, 1:3.1+dfsg-8~deb10u1, 1:3.1+dfsg-8+deb10u2, and 1:2.1+dfsg-12+deb8u12 (fixed), when executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well."
204353," static void* lookupOpenGLFunctionAddress(const char* functionName, bool* success = 0)
 {
     if (success && !*success)
         return 0;
 
     void* target = getProcAddress(functionName);
     if (target)
         return target;
 
     String fullFunctionName(functionName);
     fullFunctionName.append(""ARB"");
     target = getProcAddress(fullFunctionName.utf8().data());
     if (target)
         return target;
 
     fullFunctionName = functionName;
     fullFunctionName.append(""EXT"");
     target = getProcAddress(fullFunctionName.utf8().data());
 
 #if defined(GL_ES_VERSION_2_0)
      fullFunctionName = functionName;
      fullFunctionName.append(""ANGLE"");
      target = getProcAddress(fullFunctionName.utf8().data());
     if (target)
         return target;
  
      fullFunctionName = functionName;
      fullFunctionName.append(""APPLE"");
     target = getProcAddress(fullFunctionName.utf8().data());
 #endif
 
     if (!target && success)
         *success = false;
 
     return target;
 }","[24, 25]",Multiple unspecified vulnerabilities in the PDF functionality in Google Chrome before 22.0.1229.79 allow remote attackers to have an unknown impact via a crafted document.
207635," gamma_info_imp(gamma_display *dp, png_structp pp, png_infop pi)
 {
   
    standard_info_part1(&dp->this, pp, pi);
 
 
      
     if (dp->scale16)
  #     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
          png_set_scale_16(pp);
 #     else
   
 #        ifdef PNG_READ_16_TO_8_SUPPORTED
             png_set_strip_16(pp);
 #        else
             png_error(pp, ""scale16 (16 to 8 bit conversion) not supported"");
 #        endif
 #     endif
 
  if (dp->expand16)
 #     ifdef PNG_READ_EXPAND_16_SUPPORTED
          png_set_expand_16(pp);
 #     else
          png_error(pp, ""expand16 (8 to 16 bit conversion) not supported"");
 #     endif
 
  if (dp->do_background >= ALPHA_MODE_OFFSET)
  {
 #     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
  {
   
  int mode = dp->do_background - ALPHA_MODE_OFFSET;
 
   
         PNG_CONST double sg = dp->screen_gamma;
          const double sg = dp->screen_gamma;
  #        ifndef PNG_FLOATING_POINT_SUPPORTED
            PNG_CONST png_fixed_point g = fix(sg);
             const png_fixed_point g = fix(sg);
  #        endif
  
  #        ifdef PNG_FLOATING_POINT_SUPPORTED
             png_set_alpha_mode(pp, mode, sg);
 #        else
             png_set_alpha_mode_fixed(pp, mode, g);
 #        endif
 
   
  if (mode == PNG_ALPHA_STANDARD && sg != 1)
  {
 #           ifdef PNG_FLOATING_POINT_SUPPORTED
                png_set_gamma(pp, sg, dp->file_gamma);
 #           else
                png_fixed_point f = fix(dp->file_gamma);
                png_set_gamma_fixed(pp, g, f);
 #           endif
  }
  }
 #     else
          png_error(pp, ""alpha mode handling not supported"");
 #     endif
  }
 
  else
  {
   
 #     ifdef PNG_FLOATING_POINT_SUPPORTED
          png_set_gamma(pp, dp->screen_gamma, dp->file_gamma);
 #     else
  {
          png_fixed_point s = fix(dp->screen_gamma);
          png_fixed_point f = fix(dp->file_gamma);
          png_set_gamma_fixed(pp, s, f);
  }
 #     endif
 
  if (dp->do_background)
  {
 
  #     ifdef PNG_READ_BACKGROUND_SUPPORTED
            
         PNG_CONST double bg = dp->background_gamma;
          const double bg = dp->background_gamma;
  #        ifndef PNG_FLOATING_POINT_SUPPORTED
            PNG_CONST png_fixed_point g = fix(bg);
             const png_fixed_point g = fix(bg);
  #        endif
  
  #        ifdef PNG_FLOATING_POINT_SUPPORTED
             png_set_background(pp, &dp->background_color, dp->do_background,
  0 , bg);
 #        else
             png_set_background_fixed(pp, &dp->background_color,
                dp->do_background, 0 , g);
 #        endif
 #     else
          png_error(pp, ""png_set_background not supported"");
 #     endif
  }
  }
 
  {
  int i = dp->this.use_update_info;
   
  do
          png_read_update_info(pp, pi);
  while (--i > 0);
  }
 
   
    standard_info_part2(&dp->this, pp, pi, 1  );
 }","[36, 39, 83, 86, 35, 38, 82, 85]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
451,"DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)
{
unsigned i = 0, o;
int q = 0;
int curanswer;
ResourceRecord rr;
unsigned short ptr;


rr.type = DNS_QUERY_NONE;
rr.rdlength = 0;
rr.ttl = 1;
rr.rr_class = 0;

if (!(header.flags1 & FLAGS_MASK_QR))
return std::make_pair((unsigned char*)NULL,""Not a query result"");

if (header.flags1 & FLAGS_MASK_OPCODE)
return std::make_pair((unsigned char*)NULL,""Unexpected value in DNS reply packet"");

if (header.flags2 & FLAGS_MASK_RCODE)
return std::make_pair((unsigned char*)NULL,""Domain name not found"");

if (header.ancount < 1)
return std::make_pair((unsigned char*)NULL,""No resource records returned"");


length -= 12;

while ((unsigned int)q < header.qdcount && i < length)
{
if (header.payload[i] > 63)
{
i += 6;
q++;
}
else
{
if (header.payload[i] == 0)
{
q++;
i += 5;
}
else i += header.payload[i] + 1;
}
}
curanswer = 0;
while ((unsigned)curanswer < header.ancount)
{
q = 0;
while (q == 0 && i < length)
{
if (header.payload[i] > 63)
{
i += 2;
q = 1;
}
else
{
if (header.payload[i] == 0)
{
i++;
q = 1;
}
else i += header.payload[i] + 1;
}
}
if (length - i < 10)
return std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");


DNS::FillResourceRecord(&rr,&header.payload[i]);

i += 10;
ServerInstance->Logs->Log(""RESOLVER"",DEBUG,""Resolver: rr.type is %d and this.type is %d rr.class %d this.class %d"", rr.type, this->type, rr.rr_class, this->rr_class);
if (rr.type != this->type)
{
curanswer++;
i += rr.rdlength;
continue;
}
if (rr.rr_class != this->rr_class)
{
curanswer++;
i += rr.rdlength;
continue;
}
break;
}
if ((unsigned int)curanswer == header.ancount)
return std::make_pair((unsigned char*)NULL,""No A, AAAA or PTR type answers ("" + ConvToStr(header.ancount) + "" answers)"");

if (i + rr.rdlength > (unsigned int)length)
return std::make_pair((unsigned char*)NULL,""Resource record larger than stated"");

if (rr.rdlength > 1023)
return std::make_pair((unsigned char*)NULL,""Resource record too large"");

this->ttl = rr.ttl;

switch (rr.type)
{



case DNS_QUERY_CNAME:
case DNS_QUERY_PTR:
o = 0;
q = 0;
while (q == 0 && i < length && o + 256 < 1023)
{

if (header.payload[i] > 63)
{
memcpy(&ptr,&header.payload[i],2);

i = ntohs(ptr);


if (!(i & DN_COMP_BITMASK))
return std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");


i &= ~DN_COMP_BITMASK;


i =- 12;
}
else
{
if (header.payload[i] == 0)
{
q = 1;
}
else
{
res[o] = 0;
if (o != 0)
res[o++] = '.';

if (o + header.payload[i] > sizeof(DNSHeader))
return std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");

memcpy(&res[o], &header.payload[i + 1], header.payload[i]);
o += header.payload[i];
i += header.payload[i] + 1;
}
}
}
res[o] = 0;
break;
case DNS_QUERY_AAAA:
if (rr.rdlength != sizeof(struct in6_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 16 bytes for an ipv6 entry -- malformed/hostile packet?"");

memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
case DNS_QUERY_A:
if (rr.rdlength != sizeof(struct in_addr))
return std::make_pair((unsigned char *) NULL, ""rr.rdlength is larger than 4 bytes for an ipv4 entry -- malformed/hostile packet?"");

memcpy(res,&header.payload[i],rr.rdlength);
res[rr.rdlength] = 0;
break;
default:
return std::make_pair((unsigned char *) NULL, ""don't know how to handle undefined type ("" + ConvToStr(rr.type) + "") -- rejecting"");
break;
}
return std::make_pair(res,""No error"");
}",[68],inspircd in Debian before 2.0.7 does not properly handle unsigned integers.  NOTE: This vulnerability exists because of an incomplete fix to CVE-2012-1836.
205334," PlatformNotificationData ToPlatformNotificationData(
     const WebNotificationData& web_data) {
   PlatformNotificationData platform_data;
   platform_data.title = web_data.title;
 
   switch (web_data.direction) {
     case WebNotificationData::DirectionLeftToRight:
       platform_data.direction =
           PlatformNotificationData::DIRECTION_LEFT_TO_RIGHT;
       break;
     case WebNotificationData::DirectionRightToLeft:
       platform_data.direction =
           PlatformNotificationData::DIRECTION_RIGHT_TO_LEFT;
       break;
     case WebNotificationData::DirectionAuto:
       platform_data.direction = PlatformNotificationData::DIRECTION_AUTO;
       break;
   }
 
   platform_data.lang = base::UTF16ToUTF8(base::StringPiece16(web_data.lang));
   platform_data.body = web_data.body;
   platform_data.tag = base::UTF16ToUTF8(base::StringPiece16(web_data.tag));
   platform_data.icon = blink::WebStringToGURL(web_data.icon.string());
   platform_data.vibration_pattern.assign(web_data.vibrate.begin(),
                                          web_data.vibrate.end());
   platform_data.timestamp = base::Time::FromJsTime(web_data.timestamp);
   platform_data.silent = web_data.silent;
   platform_data.require_interaction = web_data.requireInteraction;
   platform_data.data.assign(web_data.data.begin(), web_data.data.end());
   platform_data.actions.resize(web_data.actions.size());
   for (size_t i = 0; i < web_data.actions.size(); ++i) {
      platform_data.actions[i].action =
          base::UTF16ToUTF8(base::StringPiece16(web_data.actions[i].action));
      platform_data.actions[i].title = web_data.actions[i].title;
     platform_data.actions[i].icon =
         blink::WebStringToGURL(web_data.actions[i].icon.string());
    }
  
    return platform_data;
 }","[35, 36]",Multiple unspecified vulnerabilities in Google Chrome before 35.0.1916.114 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
205738,"  void Textfield::OnFocus() {
 #if defined(OS_MACOSX)
   if (text_input_type_ == ui::TEXT_INPUT_TYPE_PASSWORD)
     password_input_enabler_.reset(new ui::ScopedPasswordInputEnabler());
 #endif   
 
    GetRenderText()->set_focused(true);
    if (ShouldShowCursor()) {
      UpdateCursorViewPosition();
     cursor_view_.SetVisible(true);
   }
   if (GetInputMethod())
     GetInputMethod()->SetFocusedTextInputClient(this);
   OnCaretBoundsChanged();
   if (ShouldBlinkCursor())
     StartBlinkingCursor();
   if (use_focus_ring_) {
     FocusRing::Install(this, invalid_
                                  ? ui::NativeTheme::kColorId_AlertSeverityHigh
                                  : ui::NativeTheme::kColorId_NumColors);
   }
   SchedulePaint();
   View::OnFocus();
 }","[2, 3, 4, 5, 6]",Multiple unspecified vulnerabilities in Google Chrome before 46.0.2490.71 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
200825," static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct net *net = sock_net(sk);
 	struct ipcm_cookie ipc;
 	struct rtable *rt = NULL;
 	struct flowi4 fl4;
 	int free = 0;
 	__be32 daddr;
 	__be32 saddr;
 	u8  tos;
  	int err;
  	struct ip_options_data opt_copy;
  	struct raw_frag_vec rfv;
 	int hdrincl;
  
  	err = -EMSGSIZE;
  	if (len > 0xFFFF)
  		goto out;
  
 	 
 	hdrincl = inet->hdrincl;
  	 
 
 	err = -EOPNOTSUPP;
 	if (msg->msg_flags & MSG_OOB)	 
 		goto out;                
 
 	 
 
 	if (msg->msg_namelen) {
 		DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
 		err = -EINVAL;
 		if (msg->msg_namelen < sizeof(*usin))
 			goto out;
 		if (usin->sin_family != AF_INET) {
 			pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"",
 				     __func__, current->comm);
 			err = -EAFNOSUPPORT;
 			if (usin->sin_family)
 				goto out;
 		}
 		daddr = usin->sin_addr.s_addr;
 		 
 	} else {
 		err = -EDESTADDRREQ;
 		if (sk->sk_state != TCP_ESTABLISHED)
 			goto out;
 		daddr = inet->inet_daddr;
 	}
 
 	ipc.sockc.tsflags = sk->sk_tsflags;
 	ipc.addr = inet->inet_saddr;
 	ipc.opt = NULL;
 	ipc.tx_flags = 0;
 	ipc.ttl = 0;
 	ipc.tos = -1;
 	ipc.oif = sk->sk_bound_dev_if;
 
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sk, msg, &ipc, false);
 		if (unlikely(err)) {
 			kfree(ipc.opt);
 			goto out;
 		}
 		if (ipc.opt)
 			free = 1;
 	}
 
 	saddr = ipc.addr;
 	ipc.addr = daddr;
 
 	if (!ipc.opt) {
 		struct ip_options_rcu *inet_opt;
 
 		rcu_read_lock();
 		inet_opt = rcu_dereference(inet->inet_opt);
 		if (inet_opt) {
 			memcpy(&opt_copy, inet_opt,
 			       sizeof(*inet_opt) + inet_opt->opt.optlen);
 			ipc.opt = &opt_copy.opt;
 		}
 		rcu_read_unlock();
 	}
 
 	if (ipc.opt) {
 		err = -EINVAL;
  		 
		if (inet->hdrincl)
 		if (hdrincl)
  			goto done;
  		if (ipc.opt->opt.srr) {
  			if (!daddr)
 				goto done;
 			daddr = ipc.opt->opt.faddr;
 		}
 	}
 	tos = get_rtconn_flags(&ipc, sk);
 	if (msg->msg_flags & MSG_DONTROUTE)
 		tos |= RTO_ONLINK;
 
 	if (ipv4_is_multicast(daddr)) {
 		if (!ipc.oif)
 			ipc.oif = inet->mc_index;
 		if (!saddr)
 			saddr = inet->mc_addr;
 	} else if (!ipc.oif)
 		ipc.oif = inet->uc_index;
  
  	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
  			   RT_SCOPE_UNIVERSE,
			   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 			   hdrincl ? IPPROTO_RAW : sk->sk_protocol,
  			   inet_sk_flowi_flags(sk) |
			    (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
 			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),
  			   daddr, saddr, 0, 0, sk->sk_uid);
  
	if (!inet->hdrincl) {
 	if (!hdrincl) {
  		rfv.msg = msg;
  		rfv.hlen = 0;
  
 		err = raw_probe_proto_opt(&rfv, &fl4);
 		if (err)
 			goto done;
 	}
 
 	security_sk_classify_flow(sk, flowi4_to_flowi(&fl4));
 	rt = ip_route_output_flow(net, &fl4, sk);
 	if (IS_ERR(rt)) {
 		err = PTR_ERR(rt);
 		rt = NULL;
 		goto done;
 	}
 
 	err = -EACCES;
 	if (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))
 		goto done;
 
 	if (msg->msg_flags & MSG_CONFIRM)
  		goto do_confirm;
  back_from_confirm:
  
	if (inet->hdrincl)
 	if (hdrincl)
  		err = raw_send_hdrinc(sk, &fl4, msg, len,
  				      &rt, msg->msg_flags, &ipc.sockc);
  
 	 else {
 		sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags);
 
 		if (!ipc.addr)
 			ipc.addr = fl4.daddr;
 		lock_sock(sk);
 		err = ip_append_data(sk, &fl4, raw_getfrag,
 				     &rfv, len, 0,
 				     &ipc, &rt, msg->msg_flags);
 		if (err)
 			ip_flush_pending_frames(sk);
 		else if (!(msg->msg_flags & MSG_MORE)) {
 			err = ip_push_pending_frames(sk, &fl4);
 			if (err == -ENOBUFS && !inet->recverr)
 				err = 0;
 		}
 		release_sock(sk);
 	}
 done:
 	if (free)
 		kfree(ipc.opt);
 	ip_rt_put(rt);
 
 out:
 	if (err < 0)
 		return err;
 	return len;
 
 do_confirm:
 	if (msg->msg_flags & MSG_PROBE)
 		dst_confirm_neigh(&rt->dst, &fl4.daddr);
 	if (!(msg->msg_flags & MSG_PROBE) || len)
 		goto back_from_confirm;
 	err = 0;
 	goto done;
 }","[15, 21, 22, 90, 113, 116, 120, 146, 89, 112, 115, 119, 145]",The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges.
205865," void RenderProcessHostImpl::CreateMessageFilters() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   AddFilter(new ResourceSchedulerFilter(GetID()));
   MediaInternals* media_internals = MediaInternals::GetInstance();
   scoped_refptr<BrowserPluginMessageFilter> bp_message_filter(
       new BrowserPluginMessageFilter(GetID()));
   AddFilter(bp_message_filter.get());
 
   scoped_refptr<net::URLRequestContextGetter> request_context(
       storage_partition_impl_->GetURLRequestContext());
   scoped_refptr<RenderMessageFilter> render_message_filter(
       new RenderMessageFilter(
           GetID(), GetBrowserContext(), request_context.get(),
           widget_helper_.get(), media_internals,
           storage_partition_impl_->GetDOMStorageContext(),
           storage_partition_impl_->GetCacheStorageContext()));
   AddFilter(render_message_filter.get());
 
   render_frame_message_filter_ = new RenderFrameMessageFilter(
       GetID(),
 #if BUILDFLAG(ENABLE_PLUGINS)
       PluginServiceImpl::GetInstance(),
 #else
       nullptr,
 #endif
       GetBrowserContext(),
       request_context.get(),
       widget_helper_.get());
   AddFilter(render_frame_message_filter_.get());
 
   BrowserContext* browser_context = GetBrowserContext();
   ResourceContext* resource_context = browser_context->GetResourceContext();
 
   scoped_refptr<net::URLRequestContextGetter> media_request_context(
       GetStoragePartition()->GetMediaURLRequestContext());
 
   ResourceMessageFilter::GetContextsCallback get_contexts_callback(
       base::Bind(&GetContexts, browser_context->GetResourceContext(),
                  request_context, media_request_context));
 
   scoped_refptr<ChromeBlobStorageContext> blob_storage_context =
       ChromeBlobStorageContext::GetFor(browser_context);
 
   resource_message_filter_ = new ResourceMessageFilter(
       GetID(), storage_partition_impl_->GetAppCacheService(),
       blob_storage_context.get(),
       storage_partition_impl_->GetFileSystemContext(),
       storage_partition_impl_->GetServiceWorkerContext(),
       get_contexts_callback);
 
   AddFilter(resource_message_filter_.get());
 
   media::AudioManager* audio_manager =
       BrowserMainLoop::GetInstance()->audio_manager();
   MediaStreamManager* media_stream_manager =
       BrowserMainLoop::GetInstance()->media_stream_manager();
   audio_input_renderer_host_ = new AudioInputRendererHost(
       GetID(), base::GetProcId(GetHandle()), audio_manager,
       media_stream_manager, AudioMirroringManager::GetInstance(),
        BrowserMainLoop::GetInstance()->user_input_monitor());
    AddFilter(audio_input_renderer_host_.get());
    audio_renderer_host_ = new AudioRendererHost(
      GetID(), audio_manager, AudioMirroringManager::GetInstance(),
      media_stream_manager,
       GetID(), audio_manager, BrowserMainLoop::GetInstance()->audio_system(),
       AudioMirroringManager::GetInstance(), media_stream_manager,
        browser_context->GetResourceContext()->GetMediaDeviceIDSalt());
    AddFilter(audio_renderer_host_.get());
    AddFilter(
       new MidiHost(GetID(), BrowserMainLoop::GetInstance()->midi_service()));
   AddFilter(new AppCacheDispatcherHost(
       storage_partition_impl_->GetAppCacheService(), GetID()));
   AddFilter(new ClipboardMessageFilter(blob_storage_context));
   AddFilter(new DOMStorageMessageFilter(
       storage_partition_impl_->GetDOMStorageContext()));
 
 #if BUILDFLAG(ENABLE_WEBRTC)
   peer_connection_tracker_host_ = new PeerConnectionTrackerHost(
       GetID(), webrtc_eventlog_host_.GetWeakPtr());
   AddFilter(peer_connection_tracker_host_.get());
   AddFilter(new MediaStreamDispatcherHost(
       GetID(), browser_context->GetResourceContext()->GetMediaDeviceIDSalt(),
       media_stream_manager));
   AddFilter(new MediaStreamTrackMetricsHost());
 #endif
 #if BUILDFLAG(ENABLE_PLUGINS)
   AddFilter(new PepperRendererConnection(GetID()));
 #endif
   AddFilter(new SpeechRecognitionDispatcherHost(
       GetID(), storage_partition_impl_->GetURLRequestContext()));
   AddFilter(new FileAPIMessageFilter(
       GetID(), storage_partition_impl_->GetURLRequestContext(),
       storage_partition_impl_->GetFileSystemContext(),
       blob_storage_context.get(), StreamContext::GetFor(browser_context)));
   AddFilter(new BlobDispatcherHost(
       GetID(), blob_storage_context,
       make_scoped_refptr(storage_partition_impl_->GetFileSystemContext())));
   AddFilter(new FileUtilitiesMessageFilter(GetID()));
   AddFilter(
       new DatabaseMessageFilter(storage_partition_impl_->GetDatabaseTracker()));
 #if defined(OS_MACOSX)
   AddFilter(new TextInputClientMessageFilter());
 #elif defined(OS_WIN)
   AddFilter(new DWriteFontProxyMessageFilter());
 
   channel_->AddFilter(new FontCacheDispatcher());
 #endif
 
   message_port_message_filter_ = new MessagePortMessageFilter(
       base::Bind(&RenderWidgetHelper::GetNextRoutingID,
                  base::Unretained(widget_helper_.get())));
   AddFilter(message_port_message_filter_.get());
 
   scoped_refptr<CacheStorageDispatcherHost> cache_storage_filter =
       new CacheStorageDispatcherHost();
   cache_storage_filter->Init(storage_partition_impl_->GetCacheStorageContext());
   AddFilter(cache_storage_filter.get());
 
   scoped_refptr<ServiceWorkerDispatcherHost> service_worker_filter =
       new ServiceWorkerDispatcherHost(
           GetID(), message_port_message_filter_.get(), resource_context);
   service_worker_filter->Init(
       storage_partition_impl_->GetServiceWorkerContext());
   AddFilter(service_worker_filter.get());
 
   AddFilter(new SharedWorkerMessageFilter(
       GetID(), resource_context,
       WorkerStoragePartition(
           storage_partition_impl_->GetURLRequestContext(),
           storage_partition_impl_->GetMediaURLRequestContext(),
           storage_partition_impl_->GetAppCacheService(),
           storage_partition_impl_->GetQuotaManager(),
           storage_partition_impl_->GetFileSystemContext(),
           storage_partition_impl_->GetDatabaseTracker(),
           storage_partition_impl_->GetIndexedDBContext(),
           storage_partition_impl_->GetServiceWorkerContext()),
       message_port_message_filter_.get()));
 
 #if BUILDFLAG(ENABLE_WEBRTC)
   p2p_socket_dispatcher_host_ = new P2PSocketDispatcherHost(
       resource_context, request_context.get());
   AddFilter(p2p_socket_dispatcher_host_.get());
 #endif
 
   AddFilter(new TraceMessageFilter(GetID()));
   AddFilter(new ResolveProxyMsgHelper(request_context.get()));
   AddFilter(new QuotaDispatcherHost(
       GetID(), storage_partition_impl_->GetQuotaManager(),
       GetContentClient()->browser()->CreateQuotaPermissionContext()));
 
   scoped_refptr<ServiceWorkerContextWrapper> service_worker_context(
       static_cast<ServiceWorkerContextWrapper*>(
           storage_partition_impl_->GetServiceWorkerContext()));
   notification_message_filter_ = new NotificationMessageFilter(
       GetID(), storage_partition_impl_->GetPlatformNotificationContext(),
       resource_context, service_worker_context, browser_context);
   AddFilter(notification_message_filter_.get());
 
   AddFilter(new ProfilerMessageFilter(PROCESS_TYPE_RENDERER));
   AddFilter(new HistogramMessageFilter());
   AddFilter(new MemoryMessageFilter(this));
   AddFilter(new PushMessagingMessageFilter(
       GetID(), storage_partition_impl_->GetServiceWorkerContext()));
 #if defined(OS_ANDROID)
   AddFilter(new ScreenOrientationListenerAndroid());
   synchronous_compositor_filter_ =
       new SynchronousCompositorBrowserFilter(GetID());
   AddFilter(synchronous_compositor_filter_.get());
 #endif
 }","[65, 66, 63, 64]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
201739," static Image *ReadGIFImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
 #define LSBFirstOrder(x,y)  (((y) << 8) | (x))
 
   Image
     *image,
     *meta_image;
 
   int
     number_extensionss=0;
 
   MagickBooleanType
     status;
 
   RectangleInfo
     page;
 
   register ssize_t
     i;
 
   register unsigned char
     *p;
 
   size_t
     delay,
     dispose,
     duration,
     global_colors,
     image_count,
     iterations,
     one;
 
   ssize_t
     count,
     opacity;
 
   unsigned char
     background,
     c,
     flag,
     *global_colormap,
     header[MaxTextExtent],
     magick[12];
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   count=ReadBlob(image,6,magick);
   if ((count != 6) || ((LocaleNCompare((char *) magick,""GIF87"",5) != 0) &&
       (LocaleNCompare((char *) magick,""GIF89"",5) != 0)))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
   page.width=ReadBlobLSBShort(image);
   page.height=ReadBlobLSBShort(image);
   flag=(unsigned char) ReadBlobByte(image);
   background=(unsigned char) ReadBlobByte(image);
   c=(unsigned char) ReadBlobByte(image);   
   one=1;
   global_colors=one << (((size_t) flag & 0x07)+1);
   global_colormap=(unsigned char *) AcquireQuantumMemory((size_t)
     MagickMax(global_colors,256),3UL*sizeof(*global_colormap));
   if (global_colormap == (unsigned char *) NULL)
     ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
   if (BitSet((int) flag,0x80) != 0)
     count=ReadBlob(image,(size_t) (3*global_colors),global_colormap);
   delay=0;
   dispose=0;
   duration=0;
   iterations=1;
   opacity=(-1);
   image_count=0;
   meta_image=AcquireImage(image_info);   
   for ( ; ; )
   {
     count=ReadBlob(image,1,&c);
     if (count != 1)
       break;
     if (c == (unsigned char) ';')
       break;   
     if (c == (unsigned char) '!')
       {
          
 
         count=ReadBlob(image,1,&c);
         if (count != 1)
           {
             global_colormap=(unsigned char *) RelinquishMagickMemory(
               global_colormap);
             ThrowReaderException(CorruptImageError,""UnableToReadExtensionBlock"");
           }
         switch (c)
         {
           case 0xf9:
           {
              
             while (ReadBlobBlock(image,header) != 0) ;
             dispose=(size_t) (header[0] >> 2);
             delay=(size_t) ((header[2] << 8) | header[1]);
             if ((ssize_t) (header[0] & 0x01) == 0x01)
               opacity=(ssize_t) header[3];
             break;
           }
           case 0xfe:
           {
             char
               *comments;
 
             size_t
               length;
 
              
             comments=AcquireString((char *) NULL);
             for (length=0; ; length+=count)
             {
               count=(ssize_t) ReadBlobBlock(image,header);
               if (count == 0)
                 break;
               header[count]='\0';
               (void) ConcatenateString(&comments,(const char *) header);
             }
             (void) SetImageProperty(meta_image,""comment"",comments);
             comments=DestroyString(comments);
             break;
           }
           case 0xff:
           {
             MagickBooleanType
               loop;
 
              
             loop=MagickFalse;
             if (ReadBlobBlock(image,header) != 0)
               loop=LocaleNCompare((char *) header,""NETSCAPE2.0"",11) == 0 ?
                 MagickTrue : MagickFalse;
             if (loop != MagickFalse)
               {
                 while (ReadBlobBlock(image,header) != 0)
                   iterations=(size_t) ((header[2] << 8) | header[1]);
                 break;
               }
             else
               {
                 char
                   name[MaxTextExtent];
 
                 int
                   block_length,
                   info_length,
                   reserved_length;
 
                 MagickBooleanType
                   i8bim,
                   icc,
                   iptc,
                   magick;
 
                 StringInfo
                   *profile;
 
                 unsigned char
                   *info;
 
                  
                 icc=LocaleNCompare((char *) header,""ICCRGBG1012"",11) == 0 ?
                   MagickTrue : MagickFalse;
                 magick=LocaleNCompare((char *) header,""ImageMagick"",11) == 0 ?
                   MagickTrue : MagickFalse;
                 i8bim=LocaleNCompare((char *) header,""MGK8BIM0000"",11) == 0 ?
                   MagickTrue : MagickFalse;
                 iptc=LocaleNCompare((char *) header,""MGKIPTC0000"",11) == 0 ?
                   MagickTrue : MagickFalse;
                 number_extensionss++;
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""    Reading GIF application extension"");
                 info=(unsigned char *) AcquireQuantumMemory(255UL,sizeof(*info));
                 reserved_length=255;
                 for (info_length=0; ; )
                 {
                   block_length=(int) ReadBlobBlock(image,&info[info_length]);
                   if (block_length == 0)
                     break;
                   info_length+=block_length;
                   if (info_length > (reserved_length-255))
                     {
                       reserved_length+=4096;
                       info=(unsigned char *) ResizeQuantumMemory(info,(size_t)
                         reserved_length,sizeof(*info));
                       if (info == (unsigned char *) NULL)
                         ThrowReaderException(ResourceLimitError,
                           ""MemoryAllocationFailed"");
                     }
                 }
                 profile=BlobToStringInfo(info,(size_t) info_length);
                 if (profile == (StringInfo *) NULL)
                   ThrowReaderException(ResourceLimitError,
                     ""MemoryAllocationFailed"");
                 if (i8bim != MagickFalse)
                   (void) CopyMagickString(name,""8bim"",sizeof(name));
                 else if (icc != MagickFalse)
                   (void) CopyMagickString(name,""icc"",sizeof(name));
                 else if (iptc != MagickFalse)
                   (void) CopyMagickString(name,""iptc"",sizeof(name));
                 else if (magick != MagickFalse)
                   {
                     (void) CopyMagickString(name,""magick"",sizeof(name));
                     image->gamma=StringToDouble((char *) info+6,(char **) NULL);
                   }
                 else
                   (void) FormatLocaleString(name,sizeof(name),""gif:%.11s"",
                     header);
                 info=(unsigned char *) RelinquishMagickMemory(info);
                 if (magick == MagickFalse)
                   (void) SetImageProfile(meta_image,name,profile);
                 profile=DestroyStringInfo(profile);
                 (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                   ""      profile name=%s"",name);
               }
             break;
           }
           default:
           {
             while (ReadBlobBlock(image,header) != 0) ;
             break;
           }
         }
       }
     if (c != (unsigned char) ',')
       continue;
     if (image_count != 0)
       {
          
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             global_colormap=(unsigned char *) RelinquishMagickMemory(
               global_colormap);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
       }
     image_count++;
      
     meta_image->scene=image->scene;
     CloneImageProperties(image,meta_image);
     DestroyImageProperties(meta_image);
     CloneImageProfiles(image,meta_image);
     DestroyImageProfiles(meta_image);
     image->storage_class=PseudoClass;
     image->compression=LZWCompression;
     page.x=(ssize_t) ReadBlobLSBShort(image);
     page.y=(ssize_t) ReadBlobLSBShort(image);
     image->columns=ReadBlobLSBShort(image);
     image->rows=ReadBlobLSBShort(image);
     image->depth=8;
     flag=(unsigned char) ReadBlobByte(image);
     image->interlace=BitSet((int) flag,0x40) != 0 ? GIFInterlace : NoInterlace;
     image->colors=BitSet((int) flag,0x80) == 0 ? global_colors :
       one << ((size_t) (flag & 0x07)+1);
     if (opacity >= (ssize_t) image->colors)
       opacity=(-1);
     image->page.width=page.width;
     image->page.height=page.height;
     image->page.y=page.y;
     image->page.x=page.x;
     image->delay=delay;
     image->iterations=iterations;
     image->ticks_per_second=100;
     image->dispose=(DisposeType) dispose;
     image->matte=opacity >= 0 ? MagickTrue : MagickFalse;
     delay=0;
     dispose=0;
     if ((image->columns == 0) || (image->rows == 0))
       {
         global_colormap=(unsigned char *) RelinquishMagickMemory(
           global_colormap);
         ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
       }
      
     if (AcquireImageColormap(image,image->colors) == MagickFalse)
       {
         global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
         ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
       }
     if (BitSet((int) flag,0x80) == 0)
       {
          
         p=global_colormap;
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           image->colormap[i].red=ScaleCharToQuantum(*p++);
           image->colormap[i].green=ScaleCharToQuantum(*p++);
           image->colormap[i].blue=ScaleCharToQuantum(*p++);
           if (i == opacity)
             {
               image->colormap[i].opacity=(Quantum) TransparentOpacity;
               image->transparent_color=image->colormap[opacity];
             }
         }
         image->background_color=image->colormap[MagickMin(background,
           image->colors-1)];
       }
     else
       {
         unsigned char
           *colormap;
 
          
         colormap=(unsigned char *) AcquireQuantumMemory(image->colors,3*
           sizeof(*colormap));
         if (colormap == (unsigned char *) NULL)
           {
             global_colormap=(unsigned char *) RelinquishMagickMemory(
               global_colormap);
             ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
           }
         count=ReadBlob(image,(3*image->colors)*sizeof(*colormap),colormap);
         if (count != (ssize_t) (3*image->colors))
           {
             global_colormap=(unsigned char *) RelinquishMagickMemory(
               global_colormap);
             colormap=(unsigned char *) RelinquishMagickMemory(colormap);
             ThrowReaderException(CorruptImageError,
               ""InsufficientImageDataInFile"");
           }
         p=colormap;
         for (i=0; i < (ssize_t) image->colors; i++)
         {
           image->colormap[i].red=ScaleCharToQuantum(*p++);
           image->colormap[i].green=ScaleCharToQuantum(*p++);
           image->colormap[i].blue=ScaleCharToQuantum(*p++);
           if (i == opacity)
             image->colormap[i].opacity=(Quantum) TransparentOpacity;
         }
         colormap=(unsigned char *) RelinquishMagickMemory(colormap);
       }
     if (image->gamma == 1.0)
       {
         for (i=0; i < (ssize_t) image->colors; i++)
           if (IsGrayPixel(image->colormap+i) == MagickFalse)
             break;
         (void) SetImageColorspace(image,i == (ssize_t) image->colors ?
           GRAYColorspace : RGBColorspace);
       }
      if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
        if (image->scene >= (image_info->scene+image_info->number_scenes-1))
          break;
     status=SetImageExtent(image,image->columns,image->rows);
     if (status == MagickFalse)
       {
         InheritException(exception,&image->exception);
         return(DestroyImageList(image));
       }
       
     if (image_info->ping != MagickFalse)
       status=PingGIFImage(image);
     else
       status=DecodeImage(image,opacity);
     if ((image_info->ping == MagickFalse) && (status == MagickFalse))
       {
         global_colormap=(unsigned char *) RelinquishMagickMemory(
           global_colormap);
         ThrowReaderException(CorruptImageError,""CorruptImage"");
       }
     duration+=image->delay*image->iterations;
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     opacity=(-1);
     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) image->scene-1,
       image->scene);
     if (status == MagickFalse)
       break;
   }
   image->duration=duration;
   meta_image=DestroyImage(meta_image);
   global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);
   if ((image->columns == 0) || (image->rows == 0))
     ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize"");
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }","[361, 362, 363, 364, 365, 366]",Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
197902," int CCITTFaxStream::lookChar() {
   int code1, code2, code3;
   int b1i, blackPixels, i, bits;
   GBool gotEOL;
 
   if (buf != EOF) {
     return buf;
   }
 
   if (outputBits == 0) {
 
     if (eof) {
       return EOF;
     }
 
     err = gFalse;
 
     if (nextLine2D) {
        for (i = 0; i < columns && codingLine[i] < columns; ++i) {
  	refLine[i] = codingLine[i];
        }
      refLine[i++] = columns;
      refLine[i] = columns;
       for (; i < columns + 2; ++i) {
 	refLine[i] = columns;
       }
        codingLine[0] = 0;
        a0i = 0;
        b1i = 0;
       while (codingLine[a0i] < columns && !err) {
 	code1 = getTwoDimCode();
 	switch (code1) {
 	case twoDimPass:
 	  if (likely(b1i + 1 < columns + 2)) {
 	    addPixels(refLine[b1i + 1], blackPixels);
 	    if (refLine[b1i + 1] < columns) {
 	      b1i += 2;
 	    }
 	  }
 	  break;
 	case twoDimHoriz:
 	  code1 = code2 = 0;
 	  if (blackPixels) {
 	    do {
 	      code1 += code3 = getBlackCode();
 	    } while (code3 >= 64);
 	    do {
 	      code2 += code3 = getWhiteCode();
 	    } while (code3 >= 64);
 	  } else {
 	    do {
 	      code1 += code3 = getWhiteCode();
 	    } while (code3 >= 64);
 	    do {
 	      code2 += code3 = getBlackCode();
 	    } while (code3 >= 64);
 	  }
 	  addPixels(codingLine[a0i] + code1, blackPixels);
 	  if (codingLine[a0i] < columns) {
 	    addPixels(codingLine[a0i] + code2, blackPixels ^ 1);
 	  }
 	  while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	    b1i += 2;
 	    if (unlikely(b1i > columns + 1)) {
 	      error(errSyntaxError, getPos(),
 		""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	      err = gTrue;
 	      break;
 	    }
 	  }
 	  break;
 	case twoDimVertR3:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixels(refLine[b1i] + 3, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    ++b1i;
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVertR2:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixels(refLine[b1i] + 2, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    ++b1i;
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVertR1:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixels(refLine[b1i] + 1, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    ++b1i;
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVert0:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixels(refLine[b1i], blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    ++b1i;
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVertL3:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixelsNeg(refLine[b1i] - 3, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    if (b1i > 0) {
 	      --b1i;
 	    } else {
 	      ++b1i;
 	    }
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVertL2:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixelsNeg(refLine[b1i] - 2, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    if (b1i > 0) {
 	      --b1i;
 	    } else {
 	      ++b1i;
 	    }
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 	        error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	        err = gTrue;
 	        break;
 	      }
 	    }
 	  }
 	  break;
 	case twoDimVertL1:
 	  if (unlikely(b1i > columns + 1)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	    err = gTrue;
 	    break;
 	  }
 	  addPixelsNeg(refLine[b1i] - 1, blackPixels);
 	  blackPixels ^= 1;
 	  if (codingLine[a0i] < columns) {
 	    if (b1i > 0) {
 	      --b1i;
 	    } else {
 	      ++b1i;
 	    }
 	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
 	      b1i += 2;
 	      if (unlikely(b1i > columns + 1)) {
 		error(errSyntaxError, getPos(),
 		  ""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 		err = gTrue;
 		break;
 	      }
 	    }
 	  }
 	  break;
 	case EOF:
 	  addPixels(columns, 0);
 	  eof = gTrue;
 	  break;
 	default:
 	  error(errSyntaxError, getPos(),
 		""Bad 2D code {0:04x} in CCITTFax stream"", code1);
 	  addPixels(columns, 0);
 	  err = gTrue;
 	  break;
 	}
       }
 
     } else {
       codingLine[0] = 0;
       a0i = 0;
       blackPixels = 0;
       while (codingLine[a0i] < columns) {
 	code1 = 0;
 	if (blackPixels) {
 	  do {
 	    code1 += code3 = getBlackCode();
 	  } while (code3 >= 64);
 	} else {
 	  do {
 	    code1 += code3 = getWhiteCode();
 	  } while (code3 >= 64);
 	}
 	addPixels(codingLine[a0i] + code1, blackPixels);
 	blackPixels ^= 1;
       }
     }
 
     gotEOL = gFalse;
     if (!endOfBlock && row == rows - 1) {
       eof = gTrue;
     } else if (endOfLine || !byteAlign) {
       code1 = lookBits(12);
       if (endOfLine) {
 	while (code1 != EOF && code1 != 0x001) {
 	  eatBits(1);
 	  code1 = lookBits(12);
 	}
       } else {
 	while (code1 == 0) {
 	  eatBits(1);
 	  code1 = lookBits(12);
 	}
       }
       if (code1 == 0x001) {
 	eatBits(12);
 	gotEOL = gTrue;
       }
     }
 
     if (byteAlign && !gotEOL) {
       inputBits &= ~7;
     }
 
     if (lookBits(1) == EOF) {
       eof = gTrue;
     }
 
     if (!eof && encoding > 0) {
       nextLine2D = !lookBits(1);
       eatBits(1);
     }
 
     if (endOfBlock && !endOfLine && byteAlign) {
       code1 = lookBits(24);
       if (code1 == 0x001001) {
 	eatBits(12);
 	gotEOL = gTrue;
       }
     }
     if (endOfBlock && gotEOL) {
       code1 = lookBits(12);
       if (code1 == 0x001) {
 	eatBits(12);
 	if (encoding > 0) {
 	  lookBits(1);
 	  eatBits(1);
 	}
 	if (encoding >= 0) {
 	  for (i = 0; i < 4; ++i) {
 	    code1 = lookBits(12);
 	    if (code1 != 0x001) {
 	      error(errSyntaxError, getPos(),
 		    ""Bad RTC code in CCITTFax stream"");
 	    }
 	    eatBits(12);
 	    if (encoding > 0) {
 	      lookBits(1);
 	      eatBits(1);
 	    }
 	  }
 	}
 	eof = gTrue;
       }
 
     } else if (err && endOfLine) {
       while (1) {
 	code1 = lookBits(13);
 	if (code1 == EOF) {
 	  eof = gTrue;
 	  return EOF;
 	}
 	if ((code1 >> 1) == 0x001) {
 	  break;
 	}
 	eatBits(1);
       }
       eatBits(12); 
       if (encoding > 0) {
 	eatBits(1);
 	nextLine2D = !(code1 & 1);
       }
     }
 
     if (codingLine[0] > 0) {
       outputBits = codingLine[a0i = 0];
     } else {
       outputBits = codingLine[a0i = 1];
     }
 
     ++row;
   }
 
   if (outputBits >= 8) {
     buf = (a0i & 1) ? 0x00 : 0xff;
     outputBits -= 8;
     if (outputBits == 0 && codingLine[a0i] < columns) {
       ++a0i;
       outputBits = codingLine[a0i] - codingLine[a0i - 1];
     }
   } else {
     bits = 8;
     buf = 0;
     do {
       if (outputBits > bits) {
 	buf <<= bits;
 	if (!(a0i & 1)) {
 	  buf |= 0xff >> (8 - bits);
 	}
 	outputBits -= bits;
 	bits = 0;
       } else {
 	buf <<= outputBits;
 	if (!(a0i & 1)) {
 	  buf |= 0xff >> (8 - outputBits);
 	}
 	bits -= outputBits;
 	outputBits = 0;
 	if (codingLine[a0i] < columns) {
 	  ++a0i;
 	  if (unlikely(a0i > columns)) {
 	    error(errSyntaxError, getPos(),
 	      ""Bad bits {0:04x} in CCITTFax stream"", bits);
 	      err = gTrue;
 	      break;
 	  }
 	  outputBits = codingLine[a0i] - codingLine[a0i - 1];
 	} else if (bits > 0) {
 	  buf <<= bits;
 	  bits = 0;
 	}
       }
     } while (bits);
   }
   if (black) {
     buf ^= 0xff;
   }
   return buf;
 }","[24, 25, 26, 22, 23]",poppler/Stream.cc in poppler before 0.22.1 allows context-dependent attackers to have an unspecified impact via vectors that trigger a read of uninitialized memory by the CCITTFaxStream::lookChar function.
200414," static ssize_t hfi1_file_write(struct file *fp, const char __user *data,
 			       size_t count, loff_t *offset)
 {
 	const struct hfi1_cmd __user *ucmd;
 	struct hfi1_filedata *fd = fp->private_data;
 	struct hfi1_ctxtdata *uctxt = fd->uctxt;
 	struct hfi1_cmd cmd;
 	struct hfi1_user_info uinfo;
 	struct hfi1_tid_info tinfo;
 	unsigned long addr;
 	ssize_t consumed = 0, copy = 0, ret = 0;
 	void *dest = NULL;
 	__u64 user_val = 0;
  	int uctxt_required = 1;
  	int must_be_root = 0;
  
 	 
 	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
 		return -EACCES;
 
  	if (count < sizeof(cmd)) {
  		ret = -EINVAL;
  		goto bail;
 	}
 
 	ucmd = (const struct hfi1_cmd __user *)data;
 	if (copy_from_user(&cmd, ucmd, sizeof(cmd))) {
 		ret = -EFAULT;
 		goto bail;
 	}
 
 	consumed = sizeof(cmd);
 
 	switch (cmd.type) {
 	case HFI1_CMD_ASSIGN_CTXT:
 		uctxt_required = 0;	 
 		copy = sizeof(uinfo);
 		dest = &uinfo;
 		break;
 	case HFI1_CMD_SDMA_STATUS_UPD:
 	case HFI1_CMD_CREDIT_UPD:
 		copy = 0;
 		break;
 	case HFI1_CMD_TID_UPDATE:
 	case HFI1_CMD_TID_FREE:
 	case HFI1_CMD_TID_INVAL_READ:
 		copy = sizeof(tinfo);
 		dest = &tinfo;
 		break;
 	case HFI1_CMD_USER_INFO:
 	case HFI1_CMD_RECV_CTRL:
 	case HFI1_CMD_POLL_TYPE:
 	case HFI1_CMD_ACK_EVENT:
 	case HFI1_CMD_CTXT_INFO:
 	case HFI1_CMD_SET_PKEY:
 	case HFI1_CMD_CTXT_RESET:
 		copy = 0;
 		user_val = cmd.addr;
 		break;
 	case HFI1_CMD_EP_INFO:
 	case HFI1_CMD_EP_ERASE_CHIP:
 	case HFI1_CMD_EP_ERASE_RANGE:
 	case HFI1_CMD_EP_READ_RANGE:
 	case HFI1_CMD_EP_WRITE_RANGE:
 		uctxt_required = 0;	 
 		must_be_root = 1;	 
 		copy = 0;
 		break;
 	default:
 		ret = -EINVAL;
 		goto bail;
 	}
 
 	 
 	if (copy) {
 		if (copy_from_user(dest, (void __user *)cmd.addr, copy)) {
 			ret = -EFAULT;
 			goto bail;
 		}
 		consumed += copy;
 	}
 
 	 
 	if (uctxt_required && !uctxt) {
 		ret = -EINVAL;
 		goto bail;
 	}
 
 	 
 	if (must_be_root && !capable(CAP_SYS_ADMIN)) {
 		ret = -EPERM;
 		goto bail;
 	}
 
 	switch (cmd.type) {
 	case HFI1_CMD_ASSIGN_CTXT:
 		ret = assign_ctxt(fp, &uinfo);
 		if (ret < 0)
 			goto bail;
 		ret = setup_ctxt(fp);
 		if (ret)
 			goto bail;
 		ret = user_init(fp);
 		break;
 	case HFI1_CMD_CTXT_INFO:
 		ret = get_ctxt_info(fp, (void __user *)(unsigned long)
 				    user_val, cmd.len);
 		break;
 	case HFI1_CMD_USER_INFO:
 		ret = get_base_info(fp, (void __user *)(unsigned long)
 				    user_val, cmd.len);
 		break;
 	case HFI1_CMD_SDMA_STATUS_UPD:
 		break;
 	case HFI1_CMD_CREDIT_UPD:
 		if (uctxt && uctxt->sc)
 			sc_return_credits(uctxt->sc);
 		break;
 	case HFI1_CMD_TID_UPDATE:
 		ret = hfi1_user_exp_rcv_setup(fp, &tinfo);
 		if (!ret) {
 			 
 			addr = (unsigned long)cmd.addr +
 				offsetof(struct hfi1_tid_info, tidcnt);
 			if (copy_to_user((void __user *)addr, &tinfo.tidcnt,
 					 sizeof(tinfo.tidcnt) +
 					 sizeof(tinfo.length)))
 				ret = -EFAULT;
 		}
 		break;
 	case HFI1_CMD_TID_INVAL_READ:
 		ret = hfi1_user_exp_rcv_invalid(fp, &tinfo);
 		if (ret)
 			break;
 		addr = (unsigned long)cmd.addr +
 			offsetof(struct hfi1_tid_info, tidcnt);
 		if (copy_to_user((void __user *)addr, &tinfo.tidcnt,
 				 sizeof(tinfo.tidcnt)))
 			ret = -EFAULT;
 		break;
 	case HFI1_CMD_TID_FREE:
 		ret = hfi1_user_exp_rcv_clear(fp, &tinfo);
 		if (ret)
 			break;
 		addr = (unsigned long)cmd.addr +
 			offsetof(struct hfi1_tid_info, tidcnt);
 		if (copy_to_user((void __user *)addr, &tinfo.tidcnt,
 				 sizeof(tinfo.tidcnt)))
 			ret = -EFAULT;
 		break;
 	case HFI1_CMD_RECV_CTRL:
 		ret = manage_rcvq(uctxt, fd->subctxt, (int)user_val);
 		break;
 	case HFI1_CMD_POLL_TYPE:
 		uctxt->poll_type = (typeof(uctxt->poll_type))user_val;
 		break;
 	case HFI1_CMD_ACK_EVENT:
 		ret = user_event_ack(uctxt, fd->subctxt, user_val);
 		break;
 	case HFI1_CMD_SET_PKEY:
 		if (HFI1_CAP_IS_USET(PKEY_CHECK))
 			ret = set_ctxt_pkey(uctxt, fd->subctxt, user_val);
 		else
 			ret = -EPERM;
 		break;
 	case HFI1_CMD_CTXT_RESET: {
 		struct send_context *sc;
 		struct hfi1_devdata *dd;
 
 		if (!uctxt || !uctxt->dd || !uctxt->sc) {
 			ret = -EINVAL;
 			break;
 		}
 		 
 		dd = uctxt->dd;
 		sc = uctxt->sc;
 		 
 		wait_event_interruptible_timeout(
 			sc->halt_wait, (sc->flags & SCF_HALTED),
 			msecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT));
 		if (!(sc->flags & SCF_HALTED)) {
 			ret = -ENOLCK;
 			break;
 		}
 		 
 		if (sc->flags & SCF_FROZEN) {
 			wait_event_interruptible_timeout(
 				dd->event_queue,
 				!(ACCESS_ONCE(dd->flags) & HFI1_FROZEN),
 				msecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT));
 			if (dd->flags & HFI1_FROZEN) {
 				ret = -ENOLCK;
 				break;
 			}
 			if (dd->flags & HFI1_FORCED_FREEZE) {
 				 
 				ret = -ENODEV;
 				break;
 			}
 			sc_disable(sc);
 			ret = sc_enable(sc);
 			hfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_ENB,
 				     uctxt->ctxt);
 		} else {
 			ret = sc_restart(sc);
 		}
 		if (!ret)
 			sc_return_credits(sc);
 		break;
 	}
 	case HFI1_CMD_EP_INFO:
 	case HFI1_CMD_EP_ERASE_CHIP:
 	case HFI1_CMD_EP_ERASE_RANGE:
 	case HFI1_CMD_EP_READ_RANGE:
 	case HFI1_CMD_EP_WRITE_RANGE:
 		ret = handle_eprom_command(fp, &cmd);
 		break;
 	}
 
 	if (ret >= 0)
 		ret = consumed;
 bail:
 	return ret;
 }","[17, 18, 19, 20]","The InfiniBand (aka IB) stack in the Linux kernel before 4.5.3 incorrectly relies on the write system call, which allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a uAPI interface."
201710," static Image *ReadLABELImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
   char
     geometry[MaxTextExtent],
     *property;
 
   const char
     *label;
 
   DrawInfo
     *draw_info;
 
   Image
     *image;
 
   MagickBooleanType
     status;
 
   TypeMetric
     metrics;
 
   size_t
     height,
     width;
 
    
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickSignature);
   image=AcquireImage(image_info);
   (void) ResetImagePage(image,""0x0+0+0"");
   property=InterpretImageProperties(image_info,image,image_info->filename);
   (void) SetImageProperty(image,""label"",property);
   property=DestroyString(property);
   label=GetImageProperty(image,""label"");
   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
   draw_info->text=ConstantString(label);
   metrics.width=0;
   metrics.ascent=0.0;
    status=GetMultilineTypeMetrics(image,draw_info,&metrics);
    if ((image->columns == 0) && (image->rows == 0))
      {
      image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
       image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
        image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
      }
    else
     if (((image->columns == 0) || (image->rows == 0)) ||
         (fabs(image_info->pointsize) < MagickEpsilon))
       {
         double
           high,
           low;
 
          
         for ( ; ; draw_info->pointsize*=2.0)
         {
           (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
             -metrics.bounds.x1,metrics.ascent);
           if (draw_info->gravity == UndefinedGravity)
             (void) CloneString(&draw_info->geometry,geometry);
           (void) GetMultilineTypeMetrics(image,draw_info,&metrics);
           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
           if ((image->columns != 0) && (image->rows != 0))
             {
               if ((width >= image->columns) && (height >= image->rows))
                 break;
             }
           else
             if (((image->columns != 0) && (width >= image->columns)) ||
                 ((image->rows != 0) && (height >= image->rows)))
               break;
         }
         high=draw_info->pointsize;
         for (low=1.0; (high-low) > 0.5; )
         {
           draw_info->pointsize=(low+high)/2.0;
           (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
             -metrics.bounds.x1,metrics.ascent);
           if (draw_info->gravity == UndefinedGravity)
             (void) CloneString(&draw_info->geometry,geometry);
           (void) GetMultilineTypeMetrics(image,draw_info,&metrics);
           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);
           if ((image->columns != 0) && (image->rows != 0))
             {
               if ((width < image->columns) && (height < image->rows))
                 low=draw_info->pointsize+0.5;
               else
                 high=draw_info->pointsize-0.5;
             }
           else
             if (((image->columns != 0) && (width < image->columns)) ||
                 ((image->rows != 0) && (height < image->rows)))
               low=draw_info->pointsize+0.5;
             else
               high=draw_info->pointsize-0.5;
         }
         draw_info->pointsize=(low+high)/2.0-0.5;
       }
   status=GetMultilineTypeMetrics(image,draw_info,&metrics);
   if (status == MagickFalse)
     {
       draw_info=DestroyDrawInfo(draw_info);
       InheritException(exception,&image->exception);
       image=DestroyImageList(image);
        return((Image *) NULL);
      }
    if (image->columns == 0)
    image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);
     image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);
    if (image->columns == 0)
    image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
     image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
       0.5);
    if (image->rows == 0)
    image->rows=(size_t) (metrics.ascent-metrics.descent+
     image->rows=(size_t) floor(metrics.ascent-metrics.descent+
        draw_info->stroke_width+0.5);
    if (image->rows == 0)
    image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);
     image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+
       0.5);
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
       draw_info=DestroyDrawInfo(draw_info);
       InheritException(exception,&image->exception);
       return(DestroyImageList(image));
     }
   if (SetImageBackgroundColor(image) == MagickFalse)
     {
       draw_info=DestroyDrawInfo(draw_info);
       InheritException(exception,&image->exception);
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
    
   (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",
     draw_info->direction == RightToLeftDirection ? image->columns-
     metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?
     metrics.ascent : 0.0);
   draw_info->geometry=AcquireString(geometry);
   status=AnnotateImage(image,draw_info);
   if (image_info->pointsize == 0.0)
     {
       char
         pointsize[MaxTextExtent];
 
       (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"",
         draw_info->pointsize);
       (void) SetImageProperty(image,""label:pointsize"",pointsize);
     }
   draw_info=DestroyDrawInfo(draw_info);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   return(GetFirstImageInList(image));
 }","[49, 117, 120, 121, 124, 128, 129, 48, 116, 119, 123, 127]","magick/memory.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via vectors involving *too many exceptions,* which trigger a buffer overflow."
198706," static int ext4_split_extent_at(handle_t *handle,
 			     struct inode *inode,
 			     struct ext4_ext_path *path,
 			     ext4_lblk_t split,
 			     int split_flag,
 			     int flags)
 {
 	ext4_fsblk_t newblock;
 	ext4_lblk_t ee_block;
 	struct ext4_extent *ex, newex, orig_ex;
 	struct ext4_extent *ex2 = NULL;
  	unsigned int ee_len, depth;
  	int err = 0;
  
 	BUG_ON((split_flag & (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2)) ==
 	       (EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2));
 
  	ext_debug(""ext4_split_extents_at: inode %lu, logical""
  		""block %llu\n"", inode->i_ino, (unsigned long long)split);
  
 	ext4_ext_show_leaf(inode, path);
 
 	depth = ext_depth(inode);
 	ex = path[depth].p_ext;
 	ee_block = le32_to_cpu(ex->ee_block);
 	ee_len = ext4_ext_get_actual_len(ex);
 	newblock = split - ee_block + ext4_ext_pblock(ex);
 
 	BUG_ON(split < ee_block || split >= (ee_block + ee_len));
 
 	err = ext4_ext_get_access(handle, inode, path + depth);
 	if (err)
 		goto out;
 
 	if (split == ee_block) {
 		 
 		if (split_flag & EXT4_EXT_MARK_UNINIT2)
 			ext4_ext_mark_uninitialized(ex);
 		else
 			ext4_ext_mark_initialized(ex);
 
 		if (!(flags & EXT4_GET_BLOCKS_PRE_IO))
 			ext4_ext_try_to_merge(handle, inode, path, ex);
 
 		err = ext4_ext_dirty(handle, inode, path + path->p_depth);
 		goto out;
 	}
 
 	 
 	memcpy(&orig_ex, ex, sizeof(orig_ex));
 	ex->ee_len = cpu_to_le16(split - ee_block);
 	if (split_flag & EXT4_EXT_MARK_UNINIT1)
 		ext4_ext_mark_uninitialized(ex);
 
 	 
 	err = ext4_ext_dirty(handle, inode, path + depth);
 	if (err)
 		goto fix_extent_len;
 
 	ex2 = &newex;
 	ex2->ee_block = cpu_to_le32(split);
 	ex2->ee_len   = cpu_to_le16(ee_len - (split - ee_block));
 	ext4_ext_store_pblock(ex2, newblock);
 	if (split_flag & EXT4_EXT_MARK_UNINIT2)
 		ext4_ext_mark_uninitialized(ex2);
  
  	err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);
  	if (err == -ENOSPC && (EXT4_EXT_MAY_ZEROOUT & split_flag)) {
		err = ext4_ext_zeroout(inode, &orig_ex);
 		if (split_flag & (EXT4_EXT_DATA_VALID1|EXT4_EXT_DATA_VALID2)) {
 			if (split_flag & EXT4_EXT_DATA_VALID1)
 				err = ext4_ext_zeroout(inode, ex2);
 			else
 				err = ext4_ext_zeroout(inode, ex);
 		} else
 			err = ext4_ext_zeroout(inode, &orig_ex);
 
  		if (err)
  			goto fix_extent_len;
  		 
 		ex->ee_len = cpu_to_le16(ee_len);
 		ext4_ext_try_to_merge(handle, inode, path, ex);
 		err = ext4_ext_dirty(handle, inode, path + path->p_depth);
 		goto out;
 	} else if (err)
 		goto fix_extent_len;
 
 out:
 	ext4_ext_show_leaf(inode, path);
 	return err;
 
 fix_extent_len:
 	ex->ee_len = orig_ex.ee_len;
 	ext4_ext_dirty(handle, inode, path + depth);
 	return err;
 }","[15, 16, 17, 70, 71, 72, 73, 74, 75, 76, 77, 69]",Race condition in fs/ext4/extents.c in the Linux kernel before 3.4.16 allows local users to obtain sensitive information from a deleted file by reading an extent that was not properly marked as uninitialized.
207848,"  long Cluster::HasBlockEntries(
      const Segment* pSegment,
      long long off,   
  long long& pos, long& len) {
   assert(pSegment);
   assert(off >= 0);  
 
  IMkvReader* const pReader = pSegment->m_pReader;
 
  long long total, avail;
 
  long status = pReader->Length(&total, &avail);
 
  if (status < 0)  
  return status;
 
   assert((total < 0) || (avail <= total));
 
   pos = pSegment->m_start + off;  
 
  if ((total >= 0) && (pos >= total))
  return 0;  
 
  const long long segment_stop =
  (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;
 
  long long cluster_stop = -1;  
 
  {
  if ((pos + 1) > avail) {
       len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
  long long result = GetUIntLength(pReader, pos, len);
 
  if (result < 0)  
  return static_cast<long>(result);
 
  if (result > 0)  
  return E_BUFFER_NOT_FULL;
 
  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
  return E_FILE_FORMAT_INVALID;
 
  if ((total >= 0) && ((pos + len) > total))
  return 0;
 
  if ((pos + len) > avail)
  return E_BUFFER_NOT_FULL;
 
  const long long id = ReadUInt(pReader, pos, len);
 
  if (id < 0)  
  return static_cast<long>(id);
 
  if (id != 0x0F43B675)  
  return -1;  
 
     pos += len;  
 
 
  if ((pos + 1) > avail) {
       len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
     result = GetUIntLength(pReader, pos, len);
 
  if (result < 0)  
  return static_cast<long>(result);
 
  if (result > 0)  
  return E_BUFFER_NOT_FULL;
 
  if ((segment_stop >= 0) && ((pos + len) > segment_stop))
  return E_FILE_FORMAT_INVALID;
 
  if ((total >= 0) && ((pos + len) > total))
  return 0;
 
  if ((pos + len) > avail)
  return E_BUFFER_NOT_FULL;
 
  const long long size = ReadUInt(pReader, pos, len);
 
  if (size < 0)  
  return static_cast<long>(size);
 
  if (size == 0)
  return 0;  
 
     pos += len;  
 
 
  const long long unknown_size = (1LL << (7 * len)) - 1;
 
  if (size != unknown_size) {
       cluster_stop = pos + size;
       assert(cluster_stop >= 0);
 
  if ((segment_stop >= 0) && (cluster_stop > segment_stop))
  return E_FILE_FORMAT_INVALID;
 
  if ((total >= 0) && (cluster_stop > total))
  return 0;  
  }
  }
 
  for (;;) {
  if ((cluster_stop >= 0) && (pos >= cluster_stop))
  return 0;  
 
  if ((pos + 1) > avail) {
       len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
  long long result = GetUIntLength(pReader, pos, len);
 
  if (result < 0)  
  return static_cast<long>(result);
 
  if (result > 0)  
  return E_BUFFER_NOT_FULL;
 
  if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
  return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > avail)
  return E_BUFFER_NOT_FULL;
 
  const long long id = ReadUInt(pReader, pos, len);
 
  if (id < 0)  
  return static_cast<long>(id);
 
 
  if (id == 0x0F43B675)  
  return 0;  
 
  if (id == 0x0C53BB6B)  
  return 0;  
 
     pos += len;  
 
  if ((cluster_stop >= 0) && (pos >= cluster_stop))
  return E_FILE_FORMAT_INVALID;
 
 
  if ((pos + 1) > avail) {
       len = 1;
  return E_BUFFER_NOT_FULL;
  }
 
     result = GetUIntLength(pReader, pos, len);
 
  if (result < 0)  
  return static_cast<long>(result);
 
  if (result > 0)  
  return E_BUFFER_NOT_FULL;
 
  if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
  return E_FILE_FORMAT_INVALID;
 
  if ((pos + len) > avail)
  return E_BUFFER_NOT_FULL;
 
  const long long size = ReadUInt(pReader, pos, len);
 
  if (size < 0)  
  return static_cast<long>(size);
 
     pos += len;  
 
 
  if ((cluster_stop >= 0) && (pos > cluster_stop))
  return E_FILE_FORMAT_INVALID;
 
  if (size == 0)  
  continue;
 
  const long long unknown_size = (1LL << (7 * len)) - 1;
 
  if (size == unknown_size)
  return E_FILE_FORMAT_INVALID;  
 
  if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
  return E_FILE_FORMAT_INVALID;
 
  if (id == 0x20)  
  return 1;  
 
  if (id == 0x23)  
 
        return 1;   
  
      pos += size;   
    assert((cluster_stop < 0) || (pos <= cluster_stop));
     if (cluster_stop >= 0 && pos > cluster_stop)
       return E_FILE_FORMAT_INVALID;
    }
  }","[201, 202, 200]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
206840," void MojoAudioInputIPC::StreamCreated(
     media::mojom::AudioInputStreamPtr stream,
     media::mojom::AudioInputStreamClientRequest stream_client_request,
     mojo::ScopedSharedBufferHandle shared_memory,
     mojo::ScopedHandle socket,
     bool initially_muted) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(delegate_);
   DCHECK(socket.is_valid());
   DCHECK(shared_memory.is_valid());
   DCHECK(!stream_);
   DCHECK(!stream_client_binding_.is_bound());
   stream_ = std::move(stream);
   stream_client_binding_.Bind(std::move(stream_client_request));
 
   base::PlatformFile socket_handle;
   auto result = mojo::UnwrapPlatformFile(std::move(socket), &socket_handle);
    DCHECK_EQ(result, MOJO_RESULT_OK);
  
    base::SharedMemoryHandle memory_handle;
  bool read_only = true;
   mojo::UnwrappedSharedMemoryHandleProtection protection;
    result = mojo::UnwrapSharedMemoryHandle(std::move(shared_memory),
                                          &memory_handle, nullptr, &read_only);
                                           &memory_handle, nullptr, &protection);
    DCHECK_EQ(result, MOJO_RESULT_OK);
  DCHECK(read_only);
   DCHECK_EQ(protection, mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);
  
    delegate_->OnStreamCreated(memory_handle, socket_handle, initially_muted);
  }","[22, 25, 28, 21, 24, 27]",Incorrect use of mojo::WrapSharedMemoryHandle in Mojo in Google Chrome prior to 65.0.3325.146 allowed a remote attacker who had compromised the renderer process to perform an out of bounds memory write via a crafted HTML page.
208238," OMX_ERRORTYPE SoftOpus::internalGetParameter(
         OMX_INDEXTYPE index, OMX_PTR params) {
  switch ((int)index) {
  case OMX_IndexParamAudioAndroidOpus:
  {
 
              OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *opusParams =
                  (OMX_AUDIO_PARAM_ANDROID_OPUSTYPE *)params;
  
             if (!isValidOMXParam(opusParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (opusParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
 
             opusParams->nAudioBandWidth = 0;
             opusParams->nSampleRate = kRate;
             opusParams->nBitRate = 0;
 
  if (!isConfigured()) {
                 opusParams->nChannels = 1;
  } else {
                 opusParams->nChannels = mHeader->channels;
  }
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioPcm:
  {
 
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
             pcmParams->eNumData = OMX_NumericalDataSigned;
             pcmParams->eEndian = OMX_EndianBig;
             pcmParams->bInterleaved = OMX_TRUE;
             pcmParams->nBitPerSample = 16;
             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
             pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;
             pcmParams->nSamplingRate = kRate;
 
  if (!isConfigured()) {
                 pcmParams->nChannels = 1;
  } else {
                 pcmParams->nChannels = mHeader->channels;
  }
 
  return OMX_ErrorNone;
  }
 
  default:
  return SimpleSoftOMXComponent::internalGetParameter(index, params);
  }
 }","[10, 11, 12, 13, 37, 38, 39, 40]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
200175," isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
     struct idr *idr)
 {
 	struct iso9660 *iso9660;
 	struct isoent *np;
  	unsigned char *p;
  	size_t l;
  	int r;
	int ffmax, parent_len;
 	size_t ffmax, parent_len;
  	static const struct archive_rb_tree_ops rb_ops = {
  		isoent_cmp_node_joliet, isoent_cmp_key_joliet
  	};
 
 	if (isoent->children.cnt == 0)
 		return (0);
 
 	iso9660 = a->format_data;
 	if (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)
 		ffmax = 206;
  	else
  		ffmax = 128;
  
	r = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);
 	r = idr_start(a, idr, isoent->children.cnt, (int)ffmax, 6, 2, &rb_ops);
  	if (r < 0)
  		return (r);
  
 	parent_len = 1;
 	for (np = isoent; np->parent != np; np = np->parent)
 		parent_len += np->mb_len + 1;
 
 	for (np = isoent->children.first; np != NULL; np = np->chnext) {
 		unsigned char *dot;
  		int ext_off, noff, weight;
  		size_t lt;
  
		if ((int)(l = np->file->basename_utf16.length) > ffmax)
 		if ((l = np->file->basename_utf16.length) > ffmax)
  			l = ffmax;
  
  		p = malloc((l+1)*2);
 		if (p == NULL) {
 			archive_set_error(&a->archive, ENOMEM,
 			    ""Can't allocate memory"");
 			return (ARCHIVE_FATAL);
 		}
 		memcpy(p, np->file->basename_utf16.s, l);
 		p[l] = 0;
 		p[l+1] = 0;
 
 		np->identifier = (char *)p;
 		lt = l;
 		dot = p + l;
 		weight = 0;
 		while (lt > 0) {
 			if (!joliet_allowed_char(p[0], p[1]))
 				archive_be16enc(p, 0x005F);  
 			else if (p[0] == 0 && p[1] == 0x2E)  
 				dot = p;
 			p += 2;
 			lt -= 2;
 		}
 		ext_off = (int)(dot - (unsigned char *)np->identifier);
 		np->ext_off = ext_off;
 		np->ext_len = (int)l - ext_off;
 		np->id_len = (int)l;
 
  		 
		if ((int)np->file->basename_utf16.length > ffmax) {
 		if (np->file->basename_utf16.length > ffmax) {
  			if (archive_strncpy_l(&iso9660->mbs,
  			    (const char *)np->identifier, l,
  				iso9660->sconv_from_utf16be) != 0 &&
 			    errno == ENOMEM) {
 				archive_set_error(&a->archive, errno,
 				    ""No memory"");
 				return (ARCHIVE_FATAL);
 			}
 			np->mb_len = (int)iso9660->mbs.length;
 			if (np->mb_len != (int)np->file->basename.length)
 				weight = np->mb_len;
 		} else
 			np->mb_len = (int)np->file->basename.length;
  
  		 
		if (parent_len + np->mb_len > 240) {
 		if (parent_len > 240
 		    || np->mb_len > 240
 		    || parent_len + np->mb_len > 240) {
  			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
  			    ""The regulation of Joliet extensions;""
  			    "" A length of a full-pathname of `%s' is ""
 			    ""longer than 240 bytes, (p=%d, b=%d)"",
 			    archive_entry_pathname(np->file->entry),
 			    (int)parent_len, (int)np->mb_len);
 			return (ARCHIVE_FATAL);
 		}
  
  		 
		if ((int)l == ffmax)
 		if (l == ffmax)
  			noff = ext_off - 6;
		else if ((int)l == ffmax-2)
 		else if (l == ffmax-2)
  			noff = ext_off - 4;
		else if ((int)l == ffmax-4)
 		else if (l == ffmax-4)
  			noff = ext_off - 2;
  		else
  			noff = ext_off;
 		 
 		idr_register(idr, np, weight, noff);
 	}
 
 	 
 	idr_resolve(idr, idr_set_num_beutf16);
 
 	return (ARCHIVE_OK);
 }","[10, 25, 39, 71, 88, 89, 90, 102, 105, 108, 9, 24, 38, 70, 87, 101, 104, 107]","Integer overflow in the ISO9660 writer in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) or execute arbitrary code via vectors related to verifying filename lengths when writing an ISO9660 archive, which trigger a buffer overflow."
208119,"  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
  Handle<JSObject> object,
 
                                         Handle<Object> value,
                                         uint32_t start_from, uint32_t length) {
      DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map = handle(object->map(), isolate);
     Handle<Map> original_map(object->map(), isolate);
      Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                       isolate);
      bool search_for_hole = value->IsUndefined(isolate);
  
      for (uint32_t k = start_from; k < length; ++k) {
       DCHECK_EQ(object->map(), *original_map);
        uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                              ALL_PROPERTIES);
        if (entry == kMaxUInt32) {
  if (search_for_hole) return Just(true);
  continue;
  }
 
  Handle<Object> element_k =
  Subclass::GetImpl(isolate, *parameter_map, entry);
 
  if (element_k->IsAccessorPair()) {
  LookupIterator it(isolate, object, k, LookupIterator::OWN);
         DCHECK(it.IsFound());
         DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
  Object::GetPropertyWithAccessor(&it),
  Nothing<bool>());
 
  if (value->SameValueZero(*element_k)) return Just(true);
 
  if (object->map() != *original_map) {
  return IncludesValueSlowPath(isolate, object, value, k + 1, length);
  }
  } else if (value->SameValueZero(*element_k)) {
  return Just(true);
  }
  }
  return Just(false);
  }","[8, 14, 7]","In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046"
205950," int SpdyProxyClientSocket::DoReadReplyComplete(int result) {
 
   if (result < 0)
     return result;
 
   if (response_.headers->GetParsedHttpVersion() < HttpVersion(1, 0))
     return ERR_TUNNEL_CONNECTION_FAILED;
 
   net_log_.AddEvent(
       NetLog::TYPE_HTTP_TRANSACTION_READ_TUNNEL_RESPONSE_HEADERS,
       base::Bind(&HttpResponseHeaders::NetLogCallback, response_.headers));
 
   switch (response_.headers->response_code()) {
     case 200:   
       next_state_ = STATE_OPEN;
       return OK;
 
      case 302:   
      if (SanitizeProxyRedirect(&response_, request_.url)) {
        redirect_has_load_timing_info_ =
            spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);
        spdy_stream_->DetachDelegate();
        next_state_ = STATE_DISCONNECTED;
        return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;
      } else {
       if (!SanitizeProxyRedirect(&response_)) {
          LogBlockedTunnelResponse();
          return ERR_TUNNEL_CONNECTION_FAILED;
        }
  
       redirect_has_load_timing_info_ =
           spdy_stream_->GetLoadTimingInfo(&redirect_load_timing_info_);
        
       spdy_stream_->DetachDelegate();
       next_state_ = STATE_DISCONNECTED;
       return ERR_HTTPS_PROXY_TUNNEL_RESPONSE;
 
      case 407:   
        next_state_ = STATE_OPEN;
       if (!SanitizeProxyAuth(&response_)) {
         LogBlockedTunnelResponse();
         return ERR_TUNNEL_CONNECTION_FAILED;
       }
        return HandleProxyAuthChallenge(auth_.get(), &response_, net_log_);
  
      default:
       LogBlockedTunnelResponse();
       return ERR_TUNNEL_CONNECTION_FAILED;
   }
 }","[26, 31, 32, 33, 34, 35, 36, 37, 40, 41, 42, 43, 19, 20, 21, 22, 23, 24, 25]","net/http/proxy_client_socket.cc in Google Chrome before 41.0.2272.76 does not properly handle a 407 (aka Proxy Authentication Required) HTTP status code accompanied by a Set-Cookie header, which allows remote proxy servers to conduct cookie-injection attacks via a crafted response."
206880," void DoCanonicalizeRef(const CHAR* spec,
                        const Component& ref,
                        CanonOutput* output,
                        Component* out_ref) {
   if (ref.len < 0) {
     *out_ref = Component();
     return;
   }
 
   output->push_back('#');
   out_ref->begin = output->length();
 
   int end = ref.end();
   for (int i = ref.begin; i < end; i++) {
     if (spec[i] == 0) {
       continue;
     } else if (static_cast<UCHAR>(spec[i]) < 0x20) {
       AppendEscapedChar(static_cast<unsigned char>(spec[i]), output);
     } else if (static_cast<UCHAR>(spec[i]) < 0x80) {
        output->push_back(static_cast<char>(spec[i]));
      } else {
      unsigned code_point;
      ReadUTFChar(spec, &i, end, &code_point);
      AppendUTF8Value(code_point, output);
       AppendUTF8EscapedChar(spec, &i, end, output);
      }
    }
  
   out_ref->len = output->length() - out_ref->begin;
 }","[25, 22, 23, 24]",Insufficient encoding of URL fragment identifiers in Blink in Google Chrome prior to 65.0.3325.146 allowed a remote attacker to perform a DOM based XSS attack via a crafted HTML page.
5054,"void HTTPSession::onCertificate(uint16_t certId,
std::unique_ptr<IOBuf> authenticator) {
DestructorGuard dg(this);
VLOG(4) << ""CERTIFICATE on"" << *this << "", certId="" << certId;

bool isValid = false;
auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
if (fizzBase) {
if (isUpstream()) {
isValid = secondAuthManager_->validateAuthenticator(
*fizzBase,
TransportDirection::UPSTREAM,
certId,
std::move(authenticator));
} else {
isValid = secondAuthManager_->validateAuthenticator(
*fizzBase,
TransportDirection::DOWNSTREAM,
certId,
std::move(authenticator));
}
} else {
VLOG(4) << ""Underlying transport does not support secondary ""
""authentication."";
return;
}
if (isValid) {
VLOG(4) << ""Successfully validated the authenticator provided by the peer."";
} else {
VLOG(4) << ""Failed to validate the authenticator provided by the peer"";
}
}",[6],Proxygen fails to validate that a secondary auth manager is set before dereferencing it. That can cause a denial of service issue when parsing a Certificate/CertificateRequest HTTP2 Frame over a fizz (TLS 1.3) transport. This issue affects Proxygen releases starting from v2018.10.29.00 until the fix in v2018.11.19.00.
205766," void PrintPreviewMessageHandler::OnDidPreviewPage(
     const PrintHostMsg_DidPreviewPage_Params& params) {
   int page_number = params.page_number;
   if (page_number < FIRST_PAGE_INDEX || !params.data_size)
     return;
 
   PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
    if (!print_preview_ui)
      return;
  
  scoped_refptr<base::RefCountedBytes> data_bytes =
      GetDataFromHandle(params.metafile_data_handle, params.data_size);
  DCHECK(data_bytes);
  print_preview_ui->SetPrintPreviewDataForIndex(page_number,
                                                std::move(data_bytes));
  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);
   if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {
     auto* client = PrintCompositeClient::FromWebContents(web_contents());
     DCHECK(client);
 
      
     client->DoComposite(
         params.metafile_data_handle, params.data_size,
         base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,
                        weak_ptr_factory_.GetWeakPtr(), params.page_number,
                        params.preview_request_id));
   } else {
     NotifyUIPreviewPageReady(
         page_number, params.preview_request_id,
         GetDataFromHandle(params.metafile_data_handle, params.data_size));
   }
  }","[17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 11, 12, 13, 14, 15, 16]","The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call."
200122," static void php_wddx_pop_element(void *user_data, const XML_Char *name)
 {
 	st_entry 			*ent1, *ent2;
 	wddx_stack 			*stack = (wddx_stack *)user_data;
 	HashTable 			*target_hash;
 	zend_class_entry 	**pce;
 	zval				*obj;
 	zval				*tmp;
 	TSRMLS_FETCH();
 
  
 	if (stack->top == 0) {
 		return;
 	}
 
 	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
 		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
 	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
 		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
 		!strcmp(name, EL_DATETIME)) {
 		wddx_stack_top(stack, (void**)&ent1);
 
 		if (!ent1->data) {
 			if (stack->top > 1) {
 				stack->top--;
 			} else {
 				stack->done = 1;
 			}
 			efree(ent1);
 			return;
 		}
 
 		if (!strcmp(name, EL_BINARY)) {
 			int new_len=0;
 			unsigned char *new_str;
  
  			new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
  			STR_FREE(Z_STRVAL_P(ent1->data));
			Z_STRVAL_P(ent1->data) = new_str;
			Z_STRLEN_P(ent1->data) = new_len;
 			if (new_str) {
 				Z_STRVAL_P(ent1->data) = new_str;
 				Z_STRLEN_P(ent1->data) = new_len;
 			} else {
 				ZVAL_EMPTY_STRING(ent1->data);
 			}
  		}
  
  		 
 		if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
 			zval *fname, *retval = NULL;
 
 			MAKE_STD_ZVAL(fname);
 			ZVAL_STRING(fname, ""__wakeup"", 1);
 
 			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);
 
 			zval_dtor(fname);
 			FREE_ZVAL(fname);
 			if (retval) {
 				zval_ptr_dtor(&retval);
 			}
 		}
 
 		if (stack->top > 1) {
 			stack->top--;
 			wddx_stack_top(stack, (void**)&ent2);
 
 			 
 			if (ent2->type == ST_FIELD && ent2->data == NULL) {
 				zval_ptr_dtor(&ent1->data);
 				efree(ent1);
 				return;
 			}
 
 			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
 				target_hash = HASH_OF(ent2->data);
 
 				if (ent1->varname) {
 					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
 						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
 						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
 						zend_bool incomplete_class = 0;
 
 						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
 						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
 										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
 							incomplete_class = 1;
 							pce = &PHP_IC_ENTRY;
 						}
 
 						 
 						MAKE_STD_ZVAL(obj);
 						object_init_ex(obj, *pce);
 
 						 
 						zend_hash_merge(Z_OBJPROP_P(obj),
 										Z_ARRVAL_P(ent2->data),
 										(void (*)(void *)) zval_add_ref,
 										(void *) &tmp, sizeof(zval *), 0);
 
 						if (incomplete_class) {
 							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
 						}
 
 						 
 						zval_ptr_dtor(&ent2->data);
 
 						 
 						ent2->data = obj;
 
 						 
 						zval_ptr_dtor(&ent1->data);
 					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
 						zend_class_entry *old_scope = EG(scope);
 
 						EG(scope) = Z_OBJCE_P(ent2->data);
 						Z_DELREF_P(ent1->data);
 						add_property_zval(ent2->data, ent1->varname, ent1->data);
 						EG(scope) = old_scope;
 					} else {
 						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
 					}
 					efree(ent1->varname);
 				} else	{
 					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
 				}
 			}
 			efree(ent1);
 		} else {
 			stack->done = 1;
 		}
 	} else if (!strcmp(name, EL_VAR) && stack->varname) {
 		efree(stack->varname);
 		stack->varname = NULL;
 	} else if (!strcmp(name, EL_FIELD)) {
 		st_entry *ent;
 		wddx_stack_top(stack, (void **)&ent);
 		efree(ent);
 		stack->top--;
 	}
 }","[41, 42, 43, 44, 45, 46, 39, 40]","The php_wddx_pop_element function in ext/wddx/wddx.c in PHP before 5.6.25 and 7.x before 7.0.10 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) or possibly have unspecified other impact via an invalid base64 binary value, as demonstrated by a wddx_deserialize call that mishandles a binary element in a wddxPacket XML document."
9631,"static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)
{
u32 i, sf_type;
GF_ChildNodeItem *list;
void *slot_ptr;

switch (field.fieldType) {
case GF_SG_VRML_SFNODE:
gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
return;
case GF_SG_VRML_MFNODE:
list = * ((GF_ChildNodeItem **) field.far_ptr);
assert( list );
sdump->indent++;
while (list) {
gf_dump_vrml_node(sdump, list->node, 1, NULL);
list = list->next;
}
sdump->indent--;
return;
case GF_SG_VRML_SFCOMMANDBUFFER:
return;
}
if (gf_sg_vrml_is_sf_field(field.fieldType)) {
if (sdump->XMLDump) StartAttribute(sdump, ""value"");
gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);
if (sdump->XMLDump) EndAttribute(sdump);
} else {
GenMFField *mffield;
mffield = (GenMFField *) field.far_ptr;
sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""["");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, "" value=\'"");
} else {
StartAttribute(sdump, ""value"");
}
for (i=0; i<mffield->count; i++) {
if (i) gf_fprintf(sdump->trace, "" "");
gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);

gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);
}
if (!sdump->XMLDump) {
gf_fprintf(sdump->trace, ""]"");
} else if (sf_type==GF_SG_VRML_SFSTRING) {
gf_fprintf(sdump->trace, ""\'"");
} else {
EndAttribute(sdump);
}
}
}",[39],NULL Pointer Dereference in GitHub repository gpac/gpac prior to v2.1.0-DEV.
208516," void usage_exit() {
 void usage_exit(void) {
    fprintf(stderr, ""Usage: %s <codec> <width> <height> <infile> <outfile>\n"",
            exec_name);
    exit(EXIT_FAILURE);
  }",[2],"libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
3816,"void CLASS foveon_load_camf()
{
unsigned type, wide, high, i, j, row, col, diff;
ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];

fseek (ifp, meta_offset, SEEK_SET);
type = get4();  get4();  get4();
wide = get4();
high = get4();
if (type == 2) {
fread (meta_data, 1, meta_length, ifp);
for (i=0; i < meta_length; i++) {
high = (high * 1597 + 51749) % 244944;
wide = high * (INT64) 301593171 >> 24;
meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;
}
} else if (type == 4) {
free (meta_data);
meta_data = (char *) malloc (meta_length = wide*high*3/2);
merror (meta_data, ""foveon_load_camf()"");
foveon_huff (huff);
get4();
getbits(-1);
for (j=row=0; row < high; row++) {
for (col=0; col < wide; col++) {
diff = ljpeg_diff(huff);
if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
else         hpred[col & 1] += diff;
if (col & 1) {
meta_data[j++] = hpred[0] >> 4;
meta_data[j++] = hpred[0] << 4 | hpred[1] >> 8;
meta_data[j++] = hpred[1];
}
}
}
} else
fprintf (stderr,_(""%s has unknown CAMF type %d.\n""), ifname, type);
}","[4, 10]","An integer overflow error within the ""foveon_load_camf()"" function (dcraw_foveon.c) in LibRaw-demosaic-pack-GPL2 before 0.18.2 can be exploited to cause a heap-based buffer overflow."
208602,"    virtual void SetUp() {
    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;
      svc_.log_level = SVC_LOG_DEBUG;
      svc_.log_print = 0;
  
     codec_iface_ = vpx_codec_vp9_cx();
  const vpx_codec_err_t res =
         vpx_codec_enc_config_default(codec_iface_, &codec_enc_, 0);
     EXPECT_EQ(VPX_CODEC_OK, res);
 
     codec_enc_.g_w = kWidth;
     codec_enc_.g_h = kHeight;
     codec_enc_.g_timebase.num = 1;
     codec_enc_.g_timebase.den = 60;
 
      codec_enc_.kf_min_dist = 100;
      codec_enc_.kf_max_dist = 100;
  
    vpx_codec_dec_cfg_t dec_cfg = {0};
     vpx_codec_dec_cfg_t dec_cfg = vpx_codec_dec_cfg_t();
      VP9CodecFactory codec_factory;
      decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);
 
     tile_columns_ = 0;
     tile_rows_ = 0;
    }","[20, 23, 24, 25, 2, 19]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
208605," int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&argc, argv);
 
 
  #if ARCH_X86 || ARCH_X86_64
    const int simd_caps = x86_simd_caps();
    if (!(simd_caps & HAS_MMX))
    append_negative_gtest_filter("":MMX/*"");
     append_negative_gtest_filter("":MMX.*:MMX/*"");
    if (!(simd_caps & HAS_SSE))
    append_negative_gtest_filter("":SSE/*"");
     append_negative_gtest_filter("":SSE.*:SSE/*"");
    if (!(simd_caps & HAS_SSE2))
    append_negative_gtest_filter("":SSE2/*"");
     append_negative_gtest_filter("":SSE2.*:SSE2/*"");
    if (!(simd_caps & HAS_SSE3))
    append_negative_gtest_filter("":SSE3/*"");
     append_negative_gtest_filter("":SSE3.*:SSE3/*"");
    if (!(simd_caps & HAS_SSSE3))
    append_negative_gtest_filter("":SSSE3/*"");
     append_negative_gtest_filter("":SSSE3.*:SSSE3/*"");
    if (!(simd_caps & HAS_SSE4_1))
    append_negative_gtest_filter("":SSE4_1/*"");
     append_negative_gtest_filter("":SSE4_1.*:SSE4_1/*"");
    if (!(simd_caps & HAS_AVX))
    append_negative_gtest_filter("":AVX/*"");
     append_negative_gtest_filter("":AVX.*:AVX/*"");
    if (!(simd_caps & HAS_AVX2))
    append_negative_gtest_filter("":AVX2/*"");
     append_negative_gtest_filter("":AVX2.*:AVX2/*"");
  #endif
  
  #if !CONFIG_SHARED
 
  
  #if CONFIG_VP8
    vp8_rtcd();
#endif
 #endif   
  #if CONFIG_VP9
    vp9_rtcd();
#endif
#endif
 #endif   
   vpx_dsp_rtcd();
   vpx_scale_rtcd();
 #endif   
  
    return RUN_ALL_TESTS();
  }","[9, 12, 15, 18, 21, 24, 27, 30, 39, 44, 45, 46, 47, 8, 11, 14, 17, 20, 23, 26, 29, 38, 42, 43]","libvpx in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.0 before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to libwebm/mkvparser.cpp and other files, aka internal bug 23452792."
206546,"  void ProfileChooserView::SignOutAllWebAccounts() {
    Hide();
    ProfileOAuth2TokenServiceFactory::GetForProfile(browser_->profile())
      ->RevokeAllCredentials();
       ->RevokeAllCredentials(signin_metrics::SourceForRefreshTokenOperation::
                                  kUserMenu_SignOutAllAccounts);
  }","[5, 6, 4]","The JSGenericLowering class in compiler/js-generic-lowering.cc in Google V8, as used in Google Chrome before 50.0.2661.94, mishandles comparison operators, which allows remote attackers to obtain sensitive information via crafted JavaScript code."
202571,"  int hns_ppe_get_sset_count(int stringset)
  {
	if (stringset == ETH_SS_STATS)
 	if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)
  		return ETH_PPE_STATIC_NUM;
  	return 0;
  }","[4, 3]","In the Linux kernel before 4.12, Hisilicon Network Subsystem (HNS) does not consider the ETH_SS_PRIV_FLAGS case when retrieving sset_count data, which allows local users to cause a denial of service (buffer overflow and memory corruption) or possibly have unspecified other impact, as demonstrated by incompatibility between hns_get_sset_count and ethtool_get_strings."
203332," static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
 {
 	struct fsck_gitmodules_data *data = vdata;
 	const char *subsection, *key;
 	int subsection_len;
 	char *name;
 
 	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
 	    !subsection)
 		return 0;
 
 	name = xmemdupz(subsection, subsection_len);
 	if (check_submodule_name(name) < 0)
 		data->ret |= report(data->options, data->obj,
 				    FSCK_MSG_GITMODULES_NAME,
 				    ""disallowed submodule name: %s"",
 				    name);
 	if (!strcmp(key, ""url"") && value &&
 	    looks_like_command_line_option(value))
 		data->ret |= report(data->options, data->obj,
  				    FSCK_MSG_GITMODULES_URL,
  				    ""disallowed submodule url: %s"",
  				    value);
 	if (!strcmp(key, ""path"") && value &&
 	    looks_like_command_line_option(value))
 		data->ret |= report(data->options, data->obj,
 				    FSCK_MSG_GITMODULES_PATH,
 				    ""disallowed submodule path: %s"",
 				    value);
  	free(name);
  
  	return 0;
 }","[24, 25, 26, 27, 28, 29]","Git before 2.14.5, 2.15.x before 2.15.3, 2.16.x before 2.16.5, 2.17.x before 2.17.2, 2.18.x before 2.18.1, and 2.19.x before 2.19.1 allows remote code execution during processing of a recursive *git clone* of a superproject if a .gitmodules file has a URL field beginning with a '-' character."
204826," v8::Handle<v8::Value> V8WebSocket::sendCallback(const v8::Arguments& args)
 {
      INC_STATS(""DOM.WebSocket.send()"");
  
      if (!args.Length())
        return V8Proxy::throwNotEnoughArgumentsError();
         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());
  
      WebSocket* webSocket = V8WebSocket::toNative(args.Holder());
      v8::Handle<v8::Value> message = args[0];
     ExceptionCode ec = 0;
     bool result;
     if (V8ArrayBuffer::HasInstance(message)) {
         ArrayBuffer* arrayBuffer = V8ArrayBuffer::toNative(v8::Handle<v8::Object>::Cast(message));
         ASSERT(arrayBuffer);
         result = webSocket->send(arrayBuffer, ec);
     } else if (V8Blob::HasInstance(message)) {
         Blob* blob = V8Blob::toNative(v8::Handle<v8::Object>::Cast(message));
         ASSERT(blob);
         result = webSocket->send(blob, ec);
     } else {
         v8::TryCatch tryCatch;
         v8::Handle<v8::String> stringMessage = message->ToString();
         if (tryCatch.HasCaught())
             return throwError(tryCatch.Exception(), args.GetIsolate());
         result = webSocket->send(toWebCoreString(stringMessage), ec);
     }
     if (ec)
         return throwError(ec, args.GetIsolate());
 
     return v8Boolean(result);
 }","[7, 6]","The browser native UI in Google Chrome before 17.0.963.83 does not require user confirmation before an unpacked extension installation, which allows user-assisted remote attackers to have an unspecified impact via a crafted extension."
199913," static int read_request_line(request_rec *r, apr_bucket_brigade *bb)
 {
     const char *ll;
     const char *uri;
     const char *pro;
 
     unsigned int major = 1, minor = 0;    
     char http[5];
     apr_size_t len;
     int num_blank_lines = 0;
     int max_blank_lines = r->server->limit_req_fields;
     core_server_config *conf = ap_get_core_module_config(r->server->module_config);
     int strict = conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT;
     int enforce_strict = !(conf->http_conformance & AP_HTTP_CONFORMANCE_LOGONLY);
 
     if (max_blank_lines <= 0) {
         max_blank_lines = DEFAULT_LIMIT_REQUEST_FIELDS;
     }
 
      
 
     do {
         apr_status_t rv;
 
          
         r->the_request = NULL;
         rv = ap_rgetline(&(r->the_request), (apr_size_t)(r->server->limit_req_line + 2),
                          &len, r, 0, bb);
 
         if (rv != APR_SUCCESS) {
             r->request_time = apr_time_now();
 
              
              if (APR_STATUS_IS_ENOSPC(rv)) {
                  r->status    = HTTP_REQUEST_URI_TOO_LARGE;
                r->proto_num = HTTP_VERSION(1,0);
                r->protocol  = apr_pstrdup(r->pool, ""HTTP/1.0"");
              }
              else if (APR_STATUS_IS_TIMEUP(rv)) {
                  r->status = HTTP_REQUEST_TIME_OUT;
              }
              else if (APR_STATUS_IS_EINVAL(rv)) {
                  r->status = HTTP_BAD_REQUEST;
              }
             r->proto_num = HTTP_VERSION(1,0);
             r->protocol  = apr_pstrdup(r->pool, ""HTTP/1.0"");
              return 0;
          }
      } while ((len <= 0) && (++num_blank_lines < max_blank_lines));
 
     if (APLOGrtrace5(r)) {
         ap_log_rerror(APLOG_MARK, APLOG_TRACE5, 0, r,
                       ""Request received from client: %s"",
                       ap_escape_logitem(r->pool, r->the_request));
     }
 
     r->request_time = apr_time_now();
     ll = r->the_request;
     r->method = ap_getword_white(r->pool, &ll);
 
     uri = ap_getword_white(r->pool, &ll);
 
      
 
     r->method_number = ap_method_number_of(r->method);
     if (r->method_number == M_GET && r->method[0] == 'H') {
         r->header_only = 1;
     }
 
     ap_parse_uri(r, uri);
 
     if (ll[0]) {
         r->assbackwards = 0;
         pro = ll;
         len = strlen(ll);
     } else {
         r->assbackwards = 1;
         pro = ""HTTP/0.9"";
         len = 8;
         if (conf->http09_enable == AP_HTTP09_DISABLE) {
                 r->status = HTTP_VERSION_NOT_SUPPORTED;
                 r->protocol = apr_pstrmemdup(r->pool, pro, len);
                  
                 r->assbackwards = 0;
                 r->proto_num = HTTP_VERSION(0, 9);
                 r->connection->keepalive = AP_CONN_CLOSE;
                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02401)
                               ""HTTP/0.9 denied by server configuration"");
                 return 0;
         }
     }
     r->protocol = apr_pstrmemdup(r->pool, pro, len);
 
      
     if (len == 8
         && pro[0] == 'H' && pro[1] == 'T' && pro[2] == 'T' && pro[3] == 'P'
         && pro[4] == '/' && apr_isdigit(pro[5]) && pro[6] == '.'
         && apr_isdigit(pro[7])) {
         r->proto_num = HTTP_VERSION(pro[5] - '0', pro[7] - '0');
     }
     else {
         if (strict) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02418)
                           ""Invalid protocol '%s'"", r->protocol);
             if (enforce_strict) {
                 r->status = HTTP_BAD_REQUEST;
                 return 0;
             }
         }
         if (3 == sscanf(r->protocol, ""%4s/%u.%u"", http, &major, &minor)
             && (strcasecmp(""http"", http) == 0)
             && (minor < HTTP_VERSION(1, 0)) ) {  
             r->proto_num = HTTP_VERSION(major, minor);
         }
         else {
             r->proto_num = HTTP_VERSION(1, 0);
         }
     }
 
     if (strict) {
         int err = 0;
         if (ap_has_cntrl(r->the_request)) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02420)
                           ""Request line must not contain control characters"");
             err = HTTP_BAD_REQUEST;
         }
         if (r->parsed_uri.fragment) {
              
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02421)
                           ""URI must not contain a fragment"");
             err = HTTP_BAD_REQUEST;
         }
         else if (r->parsed_uri.user || r->parsed_uri.password) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02422)
                           ""URI must not contain a username/password"");
             err = HTTP_BAD_REQUEST;
         }
         else if (r->method_number == M_INVALID) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02423)
                           ""Invalid HTTP method string: %s"", r->method);
             err = HTTP_NOT_IMPLEMENTED;
         }
         else if (r->assbackwards == 0 && r->proto_num < HTTP_VERSION(1, 0)) {
             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02424)
                           ""HTTP/0.x does not take a protocol"");
             err = HTTP_BAD_REQUEST;
         }
 
         if (err && enforce_strict) {
             r->status = err;
             return 0;
         }
     }
 
     return 1;
 }","[45, 46, 36, 37]","The read_request_line function in server/protocol.c in the Apache HTTP Server 2.4.12 does not initialize the protocol structure member, which allows remote attackers to cause a denial of service (NULL pointer dereference and process crash) by sending a request that lacks a method to an installation that enables the INCLUDES filter and has an ErrorDocument 400 directive specifying a local URI."
202365," void xgroupCommand(client *c) {
     const char *help[] = {
 ""CREATE      <key> <groupname> <id or $>  -- Create a new consumer group."",
 ""SETID       <key> <groupname> <id or $>  -- Set the current group ID."",
 ""DELGROUP    <key> <groupname>            -- Remove the specified group."",
 ""DELCONSUMER <key> <groupname> <consumer> -- Remove the specified conusmer."",
 ""HELP                                     -- Prints this help."",
 NULL
     };
     stream *s = NULL;
     sds grpname = NULL;
     streamCG *cg = NULL;
     char *opt = c->argv[1]->ptr;  
 
       
      if (c->argc >= 4) {
          robj *o = lookupKeyWriteOrReply(c,c->argv[2],shared.nokeyerr);
        if (o == NULL) return;
         if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
          s = o->ptr;
          grpname = c->argv[3]->ptr;
  
          
         if ((cg = streamLookupCG(s,grpname)) == NULL &&
             (!strcasecmp(opt,""SETID"") ||
              !strcasecmp(opt,""DELCONSUMER"")))
         {
             addReplyErrorFormat(c, ""-NOGROUP No such consumer group '%s' ""
                                    ""for key name '%s'"",
                                    (char*)grpname, (char*)c->argv[2]->ptr);
             return;
         }
     }
 
      
     if (!strcasecmp(opt,""CREATE"") && c->argc == 5) {
         streamID id;
         if (!strcmp(c->argv[4]->ptr,""$"")) {
             id = s->last_id;
         } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
             return;
         }
         streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);
         if (cg) {
             addReply(c,shared.ok);
             server.dirty++;
         } else {
             addReplySds(c,
                 sdsnew(""-BUSYGROUP Consumer Group name already exists\r\n""));
         }
     } else if (!strcasecmp(opt,""SETID"") && c->argc == 5) {
         streamID id;
         if (!strcmp(c->argv[4]->ptr,""$"")) {
             id = s->last_id;
         } else if (streamParseIDOrReply(c,c->argv[4],&id,0) != C_OK) {
             return;
         }
         cg->last_id = id;
         addReply(c,shared.ok);
     } else if (!strcasecmp(opt,""DESTROY"") && c->argc == 4) {
         if (cg) {
             raxRemove(s->cgroups,(unsigned char*)grpname,sdslen(grpname),NULL);
             streamFreeCG(cg);
             addReply(c,shared.cone);
         } else {
             addReply(c,shared.czero);
         }
     } else if (!strcasecmp(opt,""DELCONSUMER"") && c->argc == 5) {
          
         long long pending = streamDelConsumer(cg,c->argv[4]->ptr);
         addReplyLongLong(c,pending);
         server.dirty++;
     } else if (!strcasecmp(opt,""HELP"")) {
         addReplyHelp(c, help);
     } else {
         addReply(c,shared.syntaxerr);
     }
 }","[19, 18]",Type confusion in the xgroupCommand function in t_stream.c in redis-server in Redis before 5.0 allows remote attackers to cause denial-of-service via an XGROUP command in which the key is not a stream.
204306," void NaClListener::OnMsgStart(const nacl::NaClStartParams& params) {
   struct NaClChromeMainArgs *args = NaClChromeMainArgsCreate();
   if (args == NULL) {
     LOG(ERROR) << ""NaClChromeMainArgsCreate() failed"";
      return;
    }
  
  if (params.enable_ipc_proxy) {
    IPC::ChannelHandle channel_handle =
        IPC::Channel::GenerateVerifiedChannelID(""nacl"");
    scoped_refptr<NaClIPCAdapter> ipc_adapter(new NaClIPCAdapter(
        channel_handle, io_thread_.message_loop_proxy()));
    args->initial_ipc_desc = ipc_adapter.get()->MakeNaClDesc();
#if defined(OS_POSIX)
    channel_handle.socket = base::FileDescriptor(
        ipc_adapter.get()->TakeClientFileDescriptor(), true);
#endif
    if (!Send(new NaClProcessHostMsg_PpapiChannelCreated(channel_handle)))
      LOG(ERROR) << ""Failed to send IPC channel handle to renderer."";
  }
    std::vector<nacl::FileDescriptor> handles = params.handles;
  
  #if defined(OS_LINUX) || defined(OS_MACOSX)
   args->urandom_fd = dup(base::GetUrandomFD());
   if (args->urandom_fd < 0) {
     LOG(ERROR) << ""Failed to dup() the urandom FD"";
     return;
   }
   args->create_memory_object_func = CreateMemoryObject;
 # if defined(OS_MACOSX)
   CHECK(handles.size() >= 1);
   g_shm_fd = nacl::ToNativeHandle(handles[handles.size() - 1]);
   handles.pop_back();
 # endif
 #endif
 
   CHECK(handles.size() >= 1);
   NaClHandle irt_handle = nacl::ToNativeHandle(handles[handles.size() - 1]);
   handles.pop_back();
 
 #if defined(OS_WIN)
   args->irt_fd = _open_osfhandle(reinterpret_cast<intptr_t>(irt_handle),
                                  _O_RDONLY | _O_BINARY);
   if (args->irt_fd < 0) {
     LOG(ERROR) << ""_open_osfhandle() failed"";
     return;
   }
 #else
   args->irt_fd = irt_handle;
 #endif
 
   if (params.validation_cache_enabled) {
     CHECK_EQ(params.validation_cache_key.length(), (size_t) 64);
     args->validation_cache = CreateValidationCache(
         new BrowserValidationDBProxy(this), params.validation_cache_key,
         params.version);
   }
 
   CHECK(handles.size() == 1);
   args->imc_bootstrap_handle = nacl::ToNativeHandle(handles[0]);
   args->enable_exception_handling = params.enable_exception_handling;
   args->enable_debug_stub = params.enable_debug_stub;
 #if defined(OS_WIN)
   args->broker_duplicate_handle_func = BrokerDuplicateHandle;
   args->attach_debug_exception_handler_func = AttachDebugExceptionHandler;
 #endif
   NaClChromeMainStart(args);
   NOTREACHED();
 }","[8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]",Use-after-free vulnerability in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving SVG text references.
199798," static int __driver_rfc4106_decrypt(struct aead_request *req)
 {
 	u8 one_entry_in_sg = 0;
 	u8 *src, *dst, *assoc;
 	unsigned long tempCipherLen = 0;
 	__be32 counter = cpu_to_be32(1);
 	int retval = 0;
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	struct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);
 	u32 key_len = ctx->aes_key_expanded.key_length;
 	void *aes_ctx = &(ctx->aes_key_expanded);
 	unsigned long auth_tag_len = crypto_aead_authsize(tfm);
 	u8 iv_and_authTag[32+AESNI_ALIGN];
 	u8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);
 	u8 *authTag = iv + 16;
 	struct scatter_walk src_sg_walk;
 	struct scatter_walk assoc_sg_walk;
 	struct scatter_walk dst_sg_walk;
 	unsigned int i;
 
 	if (unlikely((req->cryptlen < auth_tag_len) ||
 		(req->assoclen != 8 && req->assoclen != 12)))
 		return -EINVAL;
 	if (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))
 	        return -EINVAL;
 	if (unlikely(key_len != AES_KEYSIZE_128 &&
 	             key_len != AES_KEYSIZE_192 &&
 	             key_len != AES_KEYSIZE_256))
 	        return -EINVAL;
 
 	 
 	 
 	 
 
 	tempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);
 	 
 	for (i = 0; i < 4; i++)
 		*(iv+i) = ctx->nonce[i];
 	for (i = 0; i < 8; i++)
 		*(iv+4+i) = req->iv[i];
 	*((__be32 *)(iv+12)) = counter;
 
 	if ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {
 		one_entry_in_sg = 1;
 		scatterwalk_start(&src_sg_walk, req->src);
 		scatterwalk_start(&assoc_sg_walk, req->assoc);
 		src = scatterwalk_map(&src_sg_walk);
 		assoc = scatterwalk_map(&assoc_sg_walk);
 		dst = src;
 		if (unlikely(req->src != req->dst)) {
 			scatterwalk_start(&dst_sg_walk, req->dst);
 			dst = scatterwalk_map(&dst_sg_walk);
 		}
 
 	} else {
 		 
  		src = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);
  		if (!src)
  			return -ENOMEM;
		assoc = (src + req->cryptlen + auth_tag_len);
 		assoc = (src + req->cryptlen);
  		scatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);
  		scatterwalk_map_and_copy(assoc, req->assoc, 0,
  			req->assoclen, 0);
 		dst = src;
 	}
 
 	aesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,
 		ctx->hash_subkey, assoc, (unsigned long)req->assoclen,
 		authTag, auth_tag_len);
 
 	 
 	retval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?
 		-EBADMSG : 0;
 
 	if (one_entry_in_sg) {
 		if (unlikely(req->src != req->dst)) {
 			scatterwalk_unmap(dst);
 			scatterwalk_done(&dst_sg_walk, 0, 0);
 		}
 		scatterwalk_unmap(src);
 		scatterwalk_unmap(assoc);
  		scatterwalk_done(&src_sg_walk, 0, 0);
  		scatterwalk_done(&assoc_sg_walk, 0, 0);
  	} else {
		scatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);
 		scatterwalk_map_and_copy(dst, req->dst, 0, tempCipherLen, 1);
  		kfree(src);
  	}
  	return retval;
 }","[61, 87, 60, 86]","The __driver_rfc4106_decrypt function in arch/x86/crypto/aesni-intel_glue.c in the Linux kernel before 3.19.3 does not properly determine the memory locations used for encrypted data, which allows context-dependent attackers to cause a denial of service (buffer overflow and system crash) or possibly execute arbitrary code by triggering a crypto API call, as demonstrated by use of a libkcapi test program with an AF_ALG(aead) socket."
205868,"    void WaitForCallback() {
      if (!use_audio_thread_) {
        base::RunLoop().RunUntilIdle();
        return;
      }
    media::WaitableMessageLoopEvent event;
     WaitableMessageLoopEvent event;
      audio_thread_.task_runner()->PostTaskAndReply(
          FROM_HERE, base::Bind(&base::DoNothing), event.GetClosure());
     event.RunAndWait();
     base::RunLoop().RunUntilIdle();
   }","[7, 6]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
202379," NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
   if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
       lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
       lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
       lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
       lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
     JsVar *rhs;
 
     int op = lex->tk;
     JSP_ASSERT_MATCH(op);
     rhs = jspeAssignmentExpression();
     rhs = jsvSkipNameAndUnLock(rhs);  
  
      if (JSP_SHOULD_EXECUTE && lhs) {
        if (op=='=') {
         
        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
            jsvAddName(execInfo.root, lhs);
        }
        jspReplaceWith(lhs, rhs);
         jspReplaceWithOrAddToRoot(lhs, rhs);
        } else {
          if (op==LEX_PLUSEQUAL) op='+';
          else if (op==LEX_MINUSEQUAL) op='-';
         else if (op==LEX_MULEQUAL) op='*';
         else if (op==LEX_DIVEQUAL) op='/';
         else if (op==LEX_MODEQUAL) op='%';
         else if (op==LEX_ANDEQUAL) op='&';
         else if (op==LEX_OREQUAL) op='|';
         else if (op==LEX_XOREQUAL) op='^';
         else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
         else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
         else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
         if (op=='+' && jsvIsName(lhs)) {
           JsVar *currentValue = jsvSkipName(lhs);
           if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
              
             JsVar *str = jsvAsString(rhs, false);
             jsvAppendStringVarComplete(currentValue, str);
             jsvUnLock(str);
             op = 0;
           }
           jsvUnLock(currentValue);
         }
         if (op) {
            
           JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
           jspReplaceWith(lhs, res);
           jsvUnLock(res);
         }
       }
     }
     jsvUnLock(rhs);
   }
   return lhs;
 }","[22, 16, 17, 18, 19, 20, 21]",Espruino before 1.99 allows attackers to cause a denial of service (application crash) and a potential Information Disclosure with user crafted input files via a Buffer Overflow or Out-of-bounds Read during syntax parsing of certain for loops in jsparse.c.
206996," ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
     const ChildProcessLauncherHelper::Process& process,
     bool known_dead) {
   ChildProcessTerminationInfo info;
    if (!java_peer_avaiable_on_client_thread_)
      return info;
  
  Java_ChildProcessLauncherHelperImpl_getTerminationInfo(
   Java_ChildProcessLauncherHelperImpl_getTerminationInfoAndStop(
        AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));
  
    base::android::ApplicationState app_state =
       base::android::ApplicationStatusListener::GetState();
   bool app_foreground =
       app_state == base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES ||
       app_state == base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES;
 
   if (app_foreground &&
       (info.binding_state == base::android::ChildBindingState::MODERATE ||
        info.binding_state == base::android::ChildBindingState::STRONG)) {
     info.status = base::TERMINATION_STATUS_OOM_PROTECTED;
   } else {
     info.status = base::TERMINATION_STATUS_NORMAL_TERMINATION;
   }
   return info;
 }","[9, 8]",Process lifetime issue in Chrome in Google Chrome on Android prior to 74.0.3729.108 allowed a remote attacker to potentially persist an exploited process via a crafted HTML page.
207610," display_log(struct display *dp, error_level level, const char *fmt, ...)
   
 {
    dp->results |= 1U << level;
 
  if (level > (error_level)(dp->options & LEVEL_MASK))
  {
  const char *lp;
       va_list ap;
 
  switch (level)
  {
  case INFORMATION:    lp = ""information""; break;
  case LIBPNG_WARNING: lp = ""warning(libpng)""; break;
  case APP_WARNING:    lp = ""warning(pngimage)""; break;
  case APP_FAIL:       lp = ""error(continuable)""; break;
  case LIBPNG_ERROR:   lp = ""error(libpng)""; break;
  case LIBPNG_BUG:     lp = ""bug(libpng)""; break;
  case APP_ERROR:      lp = ""error(pngimage)""; break;
  case USER_ERROR:     lp = ""error(user)""; break;
 
  case INTERNAL_ERROR:  
  case VERBOSE: case WARNINGS: case ERRORS: case QUIET:
  default:             lp = ""bug(pngimage)""; break;
  }
 
       fprintf(stderr, ""%s: %s: %s"",
          dp->filename != NULL ? dp->filename : ""<stdin>"", lp, dp->operation);
 
  if (dp->transforms != 0)
  {
 
           int tr = dp->transforms;
  
           if (is_combo(tr))
            fprintf(stderr, ""(0x%x)"", tr);
          {
             if (dp->options & LIST_COMBOS)
             {
                int trx = tr;
 
                fprintf(stderr, ""("");
                if (trx)
                {
                   int start = 0;
 
                   while (trx)
                   {
                      int trz = trx & -trx;
 
                      if (start) fprintf(stderr, ""+"");
                      fprintf(stderr, ""%s"", transform_name(trz));
                      start = 1;
                      trx &= ~trz;
                   }
                }
 
                else
                   fprintf(stderr, ""-"");
                fprintf(stderr, "")"");
             }
 
             else
                fprintf(stderr, ""(0x%x)"", tr);
          }
  
           else
              fprintf(stderr, ""(%s)"", transform_name(tr));
  }
 
       fprintf(stderr, "": "");
 
       va_start(ap, fmt);
       vfprintf(stderr, fmt, ap);
       va_end(ap);
 
       fputc('\n', stderr);
  }
   
 
   
  if (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))
       longjmp(dp->error_return, level);
 }","[37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 36]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
204026," EncodedJSValue JSC_HOST_CALL jsTestCustomNamedGetterPrototypeFunctionAnotherFunction(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestCustomNamedGetter::s_info))
         return throwVMTypeError(exec);
     JSTestCustomNamedGetter* castedThis = jsCast<JSTestCustomNamedGetter*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestCustomNamedGetter::s_info);
      TestCustomNamedGetter* impl = static_cast<TestCustomNamedGetter*>(castedThis->impl());
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
      if (exec->hadException())
          return JSValue::encode(jsUndefined());
     impl->anotherFunction(str);
     return JSValue::encode(jsUndefined());
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
199310," static int ptrace_check_attach(struct task_struct *child, bool ignore_state)
 {
 	int ret = -ESRCH;
 
 	 
  	read_lock(&tasklist_lock);
	if ((child->ptrace & PT_PTRACED) && child->parent == current) {
 	if (child->ptrace && child->parent == current) {
 		WARN_ON(child->state == __TASK_TRACED);
  		 
		spin_lock_irq(&child->sighand->siglock);
		WARN_ON_ONCE(task_is_stopped(child));
		if (ignore_state || (task_is_traced(child) &&
				     !(child->jobctl & JOBCTL_LISTENING)))
 		if (ignore_state || ptrace_freeze_traced(child))
  			ret = 0;
		spin_unlock_irq(&child->sighand->siglock);
  	}
  	read_unlock(&tasklist_lock);
  
	if (!ret && !ignore_state)
		ret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;
 	if (!ret && !ignore_state) {
 		if (!wait_task_inactive(child, __TASK_TRACED)) {
 			 
 			WARN_ON(child->state == __TASK_TRACED);
 			ret = -ESRCH;
 		}
 	}
  
	 
  	return ret;
  }","[8, 9, 15, 23, 24, 25, 26, 27, 28, 29, 7, 11, 12, 13, 14, 17, 21, 22, 31]","Race condition in the ptrace functionality in the Linux kernel before 3.7.5 allows local users to gain privileges via a PTRACE_SETREGS ptrace system call in a crafted application, as demonstrated by ptrace_death."
9714,"void Compute(OpKernelContext* ctx) override {
Buffer* buf = nullptr;
OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));
core::ScopedUnref scope(buf);
Buffer::Tuple tuple;

std::size_t index = ctx->input(0).scalar<int>()();

OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));

OP_REQUIRES(
ctx, tuple.size() == (size_t)ctx->num_outputs(),
errors::InvalidArgument(""Mismatch stage/unstage: "", tuple.size(),
"" vs. "", ctx->num_outputs()));

for (size_t i = 0; i < tuple.size(); ++i) {
ctx->set_output(i, tuple[i]);
}
}",[7],"TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.StagePeek` does not fully validate the input arguments. This results in a `CHECK`-failure which can be used to trigger a denial of service attack. The code assumes `index` is a scalar but there is no validation for this before accessing its value. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue."
198177,"   ft_smooth_render_generic( FT_Renderer       render,
                             FT_GlyphSlot      slot,
                             FT_Render_Mode    mode,
                             const FT_Vector*  origin,
                             FT_Render_Mode    required_mode )
   {
     FT_Error     error;
     FT_Outline*  outline = NULL;
     FT_BBox      cbox;
     FT_UInt      width, height, height_org, width_org, pitch;
     FT_Bitmap*   bitmap;
     FT_Memory    memory;
     FT_Int       hmul = mode == FT_RENDER_MODE_LCD;
     FT_Int       vmul = mode == FT_RENDER_MODE_LCD_V;
     FT_Pos       x_shift, y_shift, x_left, y_top;
 
     FT_Raster_Params  params;
 
 
      
     if ( slot->format != render->glyph_format )
     {
       error = Smooth_Err_Invalid_Argument;
       goto Exit;
     }
 
      
     if ( mode != required_mode )
       return Smooth_Err_Cannot_Render_Glyph;
 
     outline = &slot->outline;
 
      
     if ( origin )
       FT_Outline_Translate( outline, origin->x, origin->y );
 
      
     FT_Outline_Get_CBox( outline, &cbox );
 
     cbox.xMin = FT_PIX_FLOOR( cbox.xMin );
     cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
     cbox.xMax = FT_PIX_CEIL( cbox.xMax );
     cbox.yMax = FT_PIX_CEIL( cbox.yMax );
 
     width  = (FT_UInt)( ( cbox.xMax - cbox.xMin ) >> 6 );
     height = (FT_UInt)( ( cbox.yMax - cbox.yMin ) >> 6 );
     bitmap = &slot->bitmap;
     memory = render->root.memory;
 
     width_org  = width;
     height_org = height;
 
      
     if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
     {
       FT_FREE( bitmap->buffer );
       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
     }
 
      
     pitch = width;
     if ( hmul )
     {
       width = width * 3;
       pitch = FT_PAD_CEIL( width, 4 );
     }
 
     if ( vmul )
       height *= 3;
 
     x_shift = (FT_Int) cbox.xMin;
     y_shift = (FT_Int) cbox.yMin;
     x_left  = (FT_Int)( cbox.xMin >> 6 );
     y_top   = (FT_Int)( cbox.yMax >> 6 );
 
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
     if ( slot->library->lcd_filter_func )
     {
       FT_Int  extra = slot->library->lcd_extra;
 
 
       if ( hmul )
       {
         x_shift -= 64 * ( extra >> 1 );
         width   += 3 * extra;
         pitch    = FT_PAD_CEIL( width, 4 );
         x_left  -= extra >> 1;
       }
 
       if ( vmul )
       {
         y_shift -= 64 * ( extra >> 1 );
         height  += 3 * extra;
         y_top   += extra >> 1;
       }
     }
 
 #endif
 
 #if FT_UINT_MAX > 0xFFFFU
  
       
       
    if ( width > 0xFFFFU || height > 0xFFFFU )
     if ( width > 0x7FFFU || height > 0x7FFFU )
      {
        FT_ERROR(( ""ft_smooth_render_generic: glyph too large: %d x %d\n"",
                   width, height ));
       return Smooth_Err_Raster_Overflow;
     }
 
 #endif
 
     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
     bitmap->num_grays  = 256;
     bitmap->width      = width;
     bitmap->rows       = height;
     bitmap->pitch      = pitch;
 
      
     FT_Outline_Translate( outline, -x_shift, -y_shift );
 
     if ( FT_ALLOC( bitmap->buffer, (FT_ULong)pitch * height ) )
       goto Exit;
 
     slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
 
      
     params.target = bitmap;
     params.source = outline;
     params.flags  = FT_RASTER_FLAG_AA;
 
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
      
     {
       FT_Vector*  points     = outline->points;
       FT_Vector*  points_end = points + outline->n_points;
       FT_Vector*  vec;
 
 
       if ( hmul )
         for ( vec = points; vec < points_end; vec++ )
           vec->x *= 3;
 
       if ( vmul )
         for ( vec = points; vec < points_end; vec++ )
           vec->y *= 3;
     }
 
      
     error = render->raster_render( render->raster, &params );
 
      
     {
       FT_Vector*  points     = outline->points;
       FT_Vector*  points_end = points + outline->n_points;
       FT_Vector*  vec;
 
 
       if ( hmul )
         for ( vec = points; vec < points_end; vec++ )
           vec->x /= 3;
 
       if ( vmul )
         for ( vec = points; vec < points_end; vec++ )
           vec->y /= 3;
     }
 
     if ( slot->library->lcd_filter_func )
       slot->library->lcd_filter_func( bitmap, mode, slot->library );
 
 #else  
 
      
     error = render->raster_render( render->raster, &params );
 
      
     if ( hmul )
     {
       FT_Byte*  line = bitmap->buffer;
       FT_UInt   hh;
 
 
       for ( hh = height_org; hh > 0; hh--, line += pitch )
       {
         FT_UInt   xx;
         FT_Byte*  end = line + width;
 
 
         for ( xx = width_org; xx > 0; xx-- )
         {
           FT_UInt  pixel = line[xx-1];
 
 
           end[-3] = (FT_Byte)pixel;
           end[-2] = (FT_Byte)pixel;
           end[-1] = (FT_Byte)pixel;
           end    -= 3;
         }
       }
     }
 
      
     if ( vmul )
     {
       FT_Byte*  read  = bitmap->buffer + ( height - height_org ) * pitch;
       FT_Byte*  write = bitmap->buffer;
       FT_UInt   hh;
 
 
       for ( hh = height_org; hh > 0; hh-- )
       {
         ft_memcpy( write, read, pitch );
         write += pitch;
 
         ft_memcpy( write, read, pitch );
         write += pitch;
 
         ft_memcpy( write, read, pitch );
         write += pitch;
         read  += pitch;
       }
     }
 
 #endif  
 
     FT_Outline_Translate( outline, x_shift, y_shift );
 
      
     if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )
       return Smooth_Err_Invalid_Pixel_Size;
 
     if ( error )
       goto Exit;
 
     slot->format      = FT_GLYPH_FORMAT_BITMAP;
     slot->bitmap_left = (FT_Int)x_left;
     slot->bitmap_top  = (FT_Int)y_top;
 
   Exit:
     if ( outline && origin )
       FT_Outline_Translate( outline, -origin->x, -origin->y );
 
     return error;
   }","[106, 105]",Integer overflow in the gray_render_span function in smooth/ftgrays.c in FreeType before 2.4.0 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.
202237," sc_parse_ef_gdo_content(const unsigned char *gdo, size_t gdo_len,
 		unsigned char *iccsn, size_t *iccsn_len,
 		unsigned char *chn, size_t *chn_len)
 {
 	int r = SC_SUCCESS, iccsn_found = 0, chn_found = 0;
 	const unsigned char *p = gdo;
 	size_t left = gdo_len;
 
 	while (left >= 2) {
 		unsigned int cla, tag;
 		size_t tag_len;
 
 		r = sc_asn1_read_tag(&p, left, &cla, &tag, &tag_len);
 		if (r != SC_SUCCESS) {
 			if (r == SC_ERROR_ASN1_END_OF_CONTENTS) {
 				 
 				r = SC_SUCCESS;
 			}
 			break;
 		}
 		if (p == NULL) {
 			 
 			break;
 		}
 
 		if (cla == SC_ASN1_TAG_APPLICATION) {
 			switch (tag) {
 				case 0x1A:
 					iccsn_found = 1;
 					if (iccsn && iccsn_len) {
 						memcpy(iccsn, p, MIN(tag_len, *iccsn_len));
 						*iccsn_len = MIN(tag_len, *iccsn_len);
 					}
 					break;
 				case 0x1F20:
 					chn_found = 1;
 					if (chn && chn_len) {
 						memcpy(chn, p, MIN(tag_len, *chn_len));
 						*chn_len = MIN(tag_len, *chn_len);
 					}
 					break;
 			}
  		}
  
  		p += tag_len;
		left -= (p - gdo);
 		left = gdo_len - (p - gdo);
  	}
  
  	if (!iccsn_found && iccsn_len)
 		*iccsn_len = 0;
 	if (!chn_found && chn_len)
 		*chn_len = 0;
 
 	return r;
 }","[47, 46]",Various out of bounds reads when handling responses in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to potentially crash the opensc library using programs.
8033,"void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)
{
u32 i, count;

count =  gf_isom_get_udta_count(file, track_number);
if (!count) return;

if (has_itags) {
for (i=0; i<count; i++) {
u32 type;
bin128 uuid;
gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);
if (type == GF_ISOM_BOX_TYPE_META) {
count--;
break;
}
}
if (!count) return;
}

fprintf(stderr, ""%d UDTA types: "", count);

for (i=0; i<count; i++) {
u32 j, type, nb_items, first=GF_TRUE;
bin128 uuid;
gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);
nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);
fprintf(stderr, ""%s (%d) "", gf_4cc_to_str(type), nb_items);
for (j=0; j<nb_items; j++) {
u8 *udta=NULL;
u32 udta_size;
gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);
if (!udta) continue;
if (gf_utf8_is_legal(udta, udta_size)) {
if (first) {
fprintf(stderr, ""\n"");
first = GF_FALSE;
}
fprintf(stderr, ""\t%s\n"", (char *) udta);
}
gf_free(udta);
}
}
fprintf(stderr, ""\n"");
}","[34, 39]",Heap buffer overflow in the print_udta function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file.
207434," EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)
 {
     EAS_RESULT result;
     SDLS_SYNTHESIZER_DATA dls;
     EAS_U32 temp;
     EAS_I32 pos;
     EAS_I32 chunkPos;
     EAS_I32 size;
     EAS_I32 instSize;
     EAS_I32 rgnPoolSize;
     EAS_I32 artPoolSize;
     EAS_I32 waveLenSize;
     EAS_I32 endDLS;
     EAS_I32 wvplPos;
     EAS_I32 wvplSize;
     EAS_I32 linsPos;
     EAS_I32 linsSize;
     EAS_I32 ptblPos;
     EAS_I32 ptblSize;
  void *p;
 
   
     EAS_HWMemSet(&dls, 0, sizeof(dls));
 
   
     dls.hwInstData = hwInstData;
     dls.fileHandle = fileHandle;
 
   
  *ppDLS = NULL;
 
   
  if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)
  return result;
  if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)
  return result;
 
   
     dls.bigEndian = (temp == CHUNK_RIFF);
 
   
     pos = offset;
  if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
  return result;
  if (temp != CHUNK_DLS)
  {
  {   }
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
     linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;
 
   
     endDLS = offset + size;
     pos = offset + 12;
  while (pos < endDLS)
  {
         chunkPos = pos;
 
   
  if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)
  return result;
 
   
  switch (temp)
  {
  case CHUNK_CDL:
  if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)
  return result;
  if (!temp)
  return EAS_ERROR_UNRECOGNIZED_FORMAT;
  break;
 
  case CHUNK_LINS:
                 linsPos = chunkPos + 12;
                 linsSize = size - 4;
  break;
 
  case CHUNK_WVPL:
                 wvplPos = chunkPos + 12;
                 wvplSize = size - 4;
  break;
 
  case CHUNK_PTBL:
                 ptblPos = chunkPos + 8;
                 ptblSize = size - 4;
  break;
 
  default:
  break;
  }
  }
 
   
  if (linsSize == 0)
  {
  {   }
  return EAS_ERROR_UNRECOGNIZED_FORMAT;
  }
 
   
  if (wvplSize == 0)
  {
  {   }
  return EAS_ERROR_UNRECOGNIZED_FORMAT;
  }
 
   
  if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))
  {
  {   }
  return EAS_ERROR_UNRECOGNIZED_FORMAT;
  }
 
   
  if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)
  return result;
 
   
  if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))
  {
  {   }
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
     dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
  if (dls.wsmpData == NULL)
  {
  {   }
  return EAS_ERROR_MALLOC_FAILED;
  }
     EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));
 
   
     result = Parse_lins(&dls, linsPos, linsSize);
  if (result == EAS_SUCCESS)
  {
 
   
  if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))
  {
  {   }
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
  if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))
  {
  {   }
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
  if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))
  {
  {   }
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
   
         instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);
 
   
         rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);
 
   
         dls.artCount++;
         artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);
 
   
         waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));
 
   
         size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;
  if (size <= 0) {
  return EAS_ERROR_FILE_FORMAT;
  }
 
   
         dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);
  if (dls.pDLS == NULL)
  {
  {   }
  return EAS_ERROR_MALLOC_FAILED;
  }
         EAS_HWMemSet(dls.pDLS, 0, size);
         dls.pDLS->refCount = 1;
         p = PtrOfs(dls.pDLS, sizeof(S_EAS));
 
   
         dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;
         dls.pDLS->pDLSPrograms = p;
         p = PtrOfs(p, instSize);
 
   
         dls.pDLS->pDLSRegions = p;
         dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;
         p = PtrOfs(p, rgnPoolSize);
 
   
         dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;
         dls.pDLS->pDLSArticulations = p;
         p = PtrOfs(p, artPoolSize);
 
   
         dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;
         dls.pDLS->pDLSSampleLen = p;
         p = PtrOfs(p, waveLenSize);
 
   
         dls.pDLS->pDLSSampleOffsets = p;
         p = PtrOfs(p, waveLenSize);
 
   
         dls.pDLS->pDLSSamples = p;
 
   
         dls.filterUsed = EAS_FALSE;
 
   
         result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);
 
      }
  
       
    Convert_art(&dls, &defaultArt, 0);
    dls.artCount = 1;
     if (dls.pDLS) {
         Convert_art(&dls, &defaultArt, 0);
         dls.artCount = 1;
     }
  
       
      dls.regionCount = dls.instCount = 0;
  if (result == EAS_SUCCESS)
         result = Parse_lins(&dls, linsPos, linsSize);
 
   
  if (dls.wsmpData)
         EAS_HWFree(dls.hwInstData, dls.wsmpData);
 
   
  if (result == EAS_SUCCESS)
  {
  *ppDLS = dls.pDLS;
 #ifdef _DEBUG_DLS
  DumpDLS(dls.pDLS);
 #endif
  }
 
   
  else
  DLSCleanup(dls.hwInstData, dls.pDLS);
 
  return result;
 }","[231, 232, 233, 234, 229, 230]","arm-wt-22k/lib_src/eas_mdls.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 allows remote attackers to cause a denial of service (NULL pointer dereference, and device hang or reboot) via a crafted media file, aka internal bug 29770686."
200999," rsvp_obj_print(netdissect_options *ndo,
                const u_char *pptr, u_int plen, const u_char *tptr,
                const char *ident, u_int tlen,
                const struct rsvp_common_header *rsvp_com_header)
 {
     const struct rsvp_object_header *rsvp_obj_header;
     const u_char *obj_tptr;
     union {
         const struct rsvp_obj_integrity_t *rsvp_obj_integrity;
         const struct rsvp_obj_frr_t *rsvp_obj_frr;
     } obj_ptr;
 
     u_short rsvp_obj_len,rsvp_obj_ctype,obj_tlen,intserv_serv_tlen;
     int hexdump,processed,padbytes,error_code,error_value,i,sigcheck;
     union {
 	float f;
 	uint32_t i;
     } bw;
     uint8_t namelen;
 
     u_int action, subchannel;
 
     while(tlen>=sizeof(struct rsvp_object_header)) {
          
         ND_TCHECK2(*tptr, sizeof(struct rsvp_object_header));
 
         rsvp_obj_header = (const struct rsvp_object_header *)tptr;
         rsvp_obj_len=EXTRACT_16BITS(rsvp_obj_header->length);
         rsvp_obj_ctype=rsvp_obj_header->ctype;
 
         if(rsvp_obj_len % 4) {
             ND_PRINT((ndo, ""%sERROR: object header size %u not a multiple of 4"", ident, rsvp_obj_len));
             return -1;
         }
         if(rsvp_obj_len < sizeof(struct rsvp_object_header)) {
             ND_PRINT((ndo, ""%sERROR: object header too short %u < %lu"", ident, rsvp_obj_len,
                    (unsigned long)sizeof(const struct rsvp_object_header)));
             return -1;
         }
 
         ND_PRINT((ndo, ""%s%s Object (%u) Flags: [%s"",
                ident,
                tok2str(rsvp_obj_values,
                        ""Unknown"",
                        rsvp_obj_header->class_num),
                rsvp_obj_header->class_num,
                ((rsvp_obj_header->class_num) & 0x80) ? ""ignore"" : ""reject""));
 
         if (rsvp_obj_header->class_num > 128)
             ND_PRINT((ndo, "" %s"",
                    ((rsvp_obj_header->class_num) & 0x40) ? ""and forward"" : ""silently""));
 
         ND_PRINT((ndo, "" if unknown], Class-Type: %s (%u), length: %u"",
                tok2str(rsvp_ctype_values,
                        ""Unknown"",
                        ((rsvp_obj_header->class_num)<<8)+rsvp_obj_ctype),
                rsvp_obj_ctype,
                rsvp_obj_len));
 
         if(tlen < rsvp_obj_len) {
             ND_PRINT((ndo, ""%sERROR: object goes past end of objects TLV"", ident));
             return -1;
         }
 
         obj_tptr=tptr+sizeof(struct rsvp_object_header);
         obj_tlen=rsvp_obj_len-sizeof(struct rsvp_object_header);
 
          
         if (!ND_TTEST2(*tptr, rsvp_obj_len))
             return -1;
         hexdump=FALSE;
 
         switch(rsvp_obj_header->class_num) {
         case RSVP_OBJ_SESSION:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 8)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv4 DestAddress: %s, Protocol ID: 0x%02x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        *(obj_tptr + sizeof(struct in_addr))));
                 ND_PRINT((ndo, ""%s  Flags: [0x%02x], DestPort %u"",
                        ident,
                        *(obj_tptr+5),
                        EXTRACT_16BITS(obj_tptr + 6)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 20)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv6 DestAddress: %s, Protocol ID: 0x%02x"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        *(obj_tptr + sizeof(struct in6_addr))));
                 ND_PRINT((ndo, ""%s  Flags: [0x%02x], DestPort %u"",
                        ident,
                        *(obj_tptr+sizeof(struct in6_addr)+1),
                        EXTRACT_16BITS(obj_tptr + sizeof(struct in6_addr) + 2)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
 
             case RSVP_CTYPE_TUNNEL_IPV6:
                 if (obj_tlen < 36)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv6 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+18),
                        ip6addr_string(ndo, obj_tptr + 20)));
                 obj_tlen-=36;
                 obj_tptr+=36;
                 break;
 
             case RSVP_CTYPE_14:  
                 if (obj_tlen < 26)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv6 P2MP LSP ID: 0x%08x, Tunnel ID: 0x%04x, Extended Tunnel ID: %s"",
                        ident,
                        EXTRACT_32BITS(obj_tptr),
                        EXTRACT_16BITS(obj_tptr+6),
                        ip6addr_string(ndo, obj_tptr + 8)));
                 obj_tlen-=26;
                 obj_tptr+=26;
                 break;
             case RSVP_CTYPE_13:  
                 if (obj_tlen < 12)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv4 P2MP LSP ID: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+6),
                        ipaddr_string(ndo, obj_tptr + 8)));
                 obj_tlen-=12;
                 obj_tptr+=12;
                 break;
             case RSVP_CTYPE_TUNNEL_IPV4:
             case RSVP_CTYPE_UNI_IPV4:
                 if (obj_tlen < 12)
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv4 Tunnel EndPoint: %s, Tunnel ID: 0x%04x, Extended Tunnel ID: %s"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+6),
                        ipaddr_string(ndo, obj_tptr + 8)));
                 obj_tlen-=12;
                 obj_tptr+=12;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_CONFIRM:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < sizeof(struct in_addr))
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv4 Receiver Address: %s"",
                        ident,
                        ipaddr_string(ndo, obj_tptr)));
                 obj_tlen-=sizeof(struct in_addr);
                 obj_tptr+=sizeof(struct in_addr);
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < sizeof(struct in6_addr))
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv6 Receiver Address: %s"",
                        ident,
                        ip6addr_string(ndo, obj_tptr)));
                 obj_tlen-=sizeof(struct in6_addr);
                 obj_tptr+=sizeof(struct in6_addr);
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_NOTIFY_REQ:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < sizeof(struct in_addr))
                     return -1;
                 ND_PRINT((ndo, ""%s  IPv4 Notify Node Address: %s"",
                        ident,
                        ipaddr_string(ndo, obj_tptr)));
                 obj_tlen-=sizeof(struct in_addr);
                 obj_tptr+=sizeof(struct in_addr);
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < sizeof(struct in6_addr))
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv6 Notify Node Address: %s"",
                        ident,
                        ip6addr_string(ndo, obj_tptr)));
                 obj_tlen-=sizeof(struct in6_addr);
                 obj_tptr+=sizeof(struct in6_addr);
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_SUGGESTED_LABEL:  
         case RSVP_OBJ_UPSTREAM_LABEL:   
         case RSVP_OBJ_RECOVERY_LABEL:   
         case RSVP_OBJ_LABEL:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 while(obj_tlen >= 4 ) {
                     ND_PRINT((ndo, ""%s  Label: %u"", ident, EXTRACT_32BITS(obj_tptr)));
                     obj_tlen-=4;
                     obj_tptr+=4;
                 }
                 break;
             case RSVP_CTYPE_2:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Generalized Label: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr)));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             case RSVP_CTYPE_3:
                 if (obj_tlen < 12)
                     return-1;
                 ND_PRINT((ndo, ""%s  Waveband ID: %u%s  Start Label: %u, Stop Label: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr),
                        ident,
                        EXTRACT_32BITS(obj_tptr+4),
                        EXTRACT_32BITS(obj_tptr + 8)));
                 obj_tlen-=12;
                 obj_tptr+=12;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_STYLE:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Reservation Style: %s, Flags: [0x%02x]"",
                        ident,
                        tok2str(rsvp_resstyle_values,
                                ""Unknown"",
                                EXTRACT_24BITS(obj_tptr+1)),
                        *(obj_tptr)));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_SENDER_TEMPLATE:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, Source Port: %u"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 6)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 20)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, Source Port: %u"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 18)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
             case RSVP_CTYPE_13:  
                 if (obj_tlen < 40)
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x""
                        ""%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+18),
                        ident,
                        ip6addr_string(ndo, obj_tptr+20),
                        EXTRACT_16BITS(obj_tptr + 38)));
                 obj_tlen-=40;
                 obj_tptr+=40;
                 break;
             case RSVP_CTYPE_TUNNEL_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv4 Tunnel Sender Address: %s, LSP-ID: 0x%04x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 6)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_12:  
                 if (obj_tlen < 16)
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x""
                        ""%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+6),
                        ident,
                        ipaddr_string(ndo, obj_tptr+8),
                        EXTRACT_16BITS(obj_tptr + 12)));
                 obj_tlen-=16;
                 obj_tptr+=16;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_LABEL_REQ:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 while(obj_tlen >= 4 ) {
                     ND_PRINT((ndo, ""%s  L3 Protocol ID: %s"",
                            ident,
                            tok2str(ethertype_values,
                                    ""Unknown Protocol (0x%04x)"",
                                    EXTRACT_16BITS(obj_tptr + 2))));
                     obj_tlen-=4;
                     obj_tptr+=4;
                 }
                 break;
             case RSVP_CTYPE_2:
                 if (obj_tlen < 12)
                     return-1;
                 ND_PRINT((ndo, ""%s  L3 Protocol ID: %s"",
                        ident,
                        tok2str(ethertype_values,
                                ""Unknown Protocol (0x%04x)"",
                                EXTRACT_16BITS(obj_tptr + 2))));
                 ND_PRINT((ndo, "",%s merge capability"",((*(obj_tptr + 4)) & 0x80) ? ""no"" : """" ));
                 ND_PRINT((ndo, ""%s  Minimum VPI/VCI: %u/%u"",
                        ident,
                        (EXTRACT_16BITS(obj_tptr+4))&0xfff,
                        (EXTRACT_16BITS(obj_tptr + 6)) & 0xfff));
                 ND_PRINT((ndo, ""%s  Maximum VPI/VCI: %u/%u"",
                        ident,
                        (EXTRACT_16BITS(obj_tptr+8))&0xfff,
                        (EXTRACT_16BITS(obj_tptr + 10)) & 0xfff));
                 obj_tlen-=12;
                 obj_tptr+=12;
                 break;
             case RSVP_CTYPE_3:
                 if (obj_tlen < 12)
                     return-1;
                 ND_PRINT((ndo, ""%s  L3 Protocol ID: %s"",
                        ident,
                        tok2str(ethertype_values,
                                ""Unknown Protocol (0x%04x)"",
                                EXTRACT_16BITS(obj_tptr + 2))));
                 ND_PRINT((ndo, ""%s  Minimum/Maximum DLCI: %u/%u, %s%s bit DLCI"",
                        ident,
                        (EXTRACT_32BITS(obj_tptr+4))&0x7fffff,
                        (EXTRACT_32BITS(obj_tptr+8))&0x7fffff,
                        (((EXTRACT_16BITS(obj_tptr+4)>>7)&3) == 0 ) ? ""10"" : """",
                        (((EXTRACT_16BITS(obj_tptr + 4) >> 7) & 3) == 2 ) ? ""23"" : """"));
                 obj_tlen-=12;
                 obj_tptr+=12;
                 break;
             case RSVP_CTYPE_4:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  LSP Encoding Type: %s (%u)"",
                        ident,
                        tok2str(gmpls_encoding_values,
                                ""Unknown"",
                                *obj_tptr),
 		       *obj_tptr));
                 ND_PRINT((ndo, ""%s  Switching Type: %s (%u), Payload ID: %s (0x%04x)"",
                        ident,
                        tok2str(gmpls_switch_cap_values,
                                ""Unknown"",
                                *(obj_tptr+1)),
 		       *(obj_tptr+1),
                        tok2str(gmpls_payload_values,
                                ""Unknown"",
                                EXTRACT_16BITS(obj_tptr+2)),
 		       EXTRACT_16BITS(obj_tptr + 2)));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_RRO:
         case RSVP_OBJ_ERO:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 while(obj_tlen >= 4 ) {
 		    u_char length;
 
 		    ND_TCHECK2(*obj_tptr, 4);
 		    length = *(obj_tptr + 1);
                     ND_PRINT((ndo, ""%s  Subobject Type: %s, length %u"",
                            ident,
                            tok2str(rsvp_obj_xro_values,
                                    ""Unknown %u"",
                                    RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)),
                            length));
 
                     if (length == 0) {  
                         ND_PRINT((ndo, ""%s  ERROR: zero length ERO subtype"", ident));
                         break;
                     }
 
                     switch(RSVP_OBJ_XRO_MASK_SUBOBJ(*obj_tptr)) {
 		    u_char prefix_length;
 
                     case RSVP_OBJ_XRO_IPV4:
 			if (length != 8) {
 				ND_PRINT((ndo, "" ERROR: length != 8""));
 				goto invalid;
 			}
 			ND_TCHECK2(*obj_tptr, 8);
 			prefix_length = *(obj_tptr+6);
 			if (prefix_length != 32) {
 				ND_PRINT((ndo, "" ERROR: Prefix length %u != 32"",
 					  prefix_length));
 				goto invalid;
 			}
                         ND_PRINT((ndo, "", %s, %s/%u, Flags: [%s]"",
                                RSVP_OBJ_XRO_MASK_LOOSE(*obj_tptr) ? ""Loose"" : ""Strict"",
                                ipaddr_string(ndo, obj_tptr+2),
                                *(obj_tptr+6),
                                bittok2str(rsvp_obj_rro_flag_values,
                                    ""none"",
                                    *(obj_tptr + 7))));  
                     break;
                     case RSVP_OBJ_XRO_LABEL:
 			if (length != 8) {
 				ND_PRINT((ndo, "" ERROR: length != 8""));
 				goto invalid;
 			}
 			ND_TCHECK2(*obj_tptr, 8);
                         ND_PRINT((ndo, "", Flags: [%s] (%#x), Class-Type: %s (%u), %u"",
                                bittok2str(rsvp_obj_rro_label_flag_values,
                                    ""none"",
                                    *(obj_tptr+2)),
                                *(obj_tptr+2),
                                tok2str(rsvp_ctype_values,
                                        ""Unknown"",
                                        *(obj_tptr+3) + 256*RSVP_OBJ_RRO),
                                *(obj_tptr+3),
                                EXTRACT_32BITS(obj_tptr + 4)));
                     }
                     obj_tlen-=*(obj_tptr+1);
                     obj_tptr+=*(obj_tptr+1);
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_HELLO:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
             case RSVP_CTYPE_2:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Instance: 0x%08x, Destination Instance: 0x%08x"",
                        ident,
                        EXTRACT_32BITS(obj_tptr),
                        EXTRACT_32BITS(obj_tptr + 4)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_RESTART_CAPABILITY:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Restart  Time: %ums, Recovery Time: %ums"",
                        ident,
                        EXTRACT_32BITS(obj_tptr),
                        EXTRACT_32BITS(obj_tptr + 4)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_SESSION_ATTRIBUTE:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_TUNNEL_IPV4:
                 if (obj_tlen < 4)
                     return-1;
                 namelen = *(obj_tptr+3);
                 if (obj_tlen < 4+namelen)
                     return-1;
                 ND_PRINT((ndo, ""%s  Session Name: "", ident));
                 for (i = 0; i < namelen; i++)
                     safeputchar(ndo, *(obj_tptr + 4 + i));
                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Flags: [%s] (%#x)"",
                        ident,
                        (int)*obj_tptr,
                        (int)*(obj_tptr+1),
                        bittok2str(rsvp_session_attribute_flag_values,
                                   ""none"",
                                   *(obj_tptr+2)),
                        *(obj_tptr + 2)));
                 obj_tlen-=4+*(obj_tptr+3);
                 obj_tptr+=4+*(obj_tptr+3);
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
 	case RSVP_OBJ_GENERALIZED_UNI:
             switch(rsvp_obj_ctype) {
 		int subobj_type,af,subobj_len,total_subobj_len;
 
             case RSVP_CTYPE_1:
 
                 if (obj_tlen < 4)
                     return-1;
 
 		 
 		total_subobj_len = obj_tlen;
                 while(total_subobj_len > 0) {
                     subobj_len  = EXTRACT_16BITS(obj_tptr);
                     subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;
                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
 
                     ND_PRINT((ndo, ""%s  Subobject Type: %s (%u), AF: %s (%u), length: %u"",
                            ident,
                            tok2str(rsvp_obj_generalized_uni_values, ""Unknown"", subobj_type),
                            subobj_type,
                            tok2str(af_values, ""Unknown"", af), af,
                            subobj_len));
 
                     if(subobj_len == 0)
                         goto invalid;
 
                     switch(subobj_type) {
                     case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:
                     case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:
 
                         switch(af) {
                         case AFNUM_INET:
                             if (subobj_len < 8)
                                 return -1;
                             ND_PRINT((ndo, ""%s    UNI IPv4 TNA address: %s"",
                                    ident, ipaddr_string(ndo, obj_tptr + 4)));
                             break;
                         case AFNUM_INET6:
                             if (subobj_len < 20)
                                 return -1;
                             ND_PRINT((ndo, ""%s    UNI IPv6 TNA address: %s"",
                                    ident, ip6addr_string(ndo, obj_tptr + 4)));
                             break;
                         case AFNUM_NSAP:
                             if (subobj_len) {
                                  
                                 hexdump=TRUE;
                             }
                             break;
                         }
                         break;
 
                     case RSVP_GEN_UNI_SUBOBJ_DIVERSITY:
                         if (subobj_len) {
                              
                             hexdump=TRUE;
                         }
                         break;
 
                     case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL:
                         if (subobj_len < 16) {
                             return -1;
                         }
 
                         ND_PRINT((ndo, ""%s    U-bit: %x, Label type: %u, Logical port id: %u, Label: %u"",
                                ident,
                                ((EXTRACT_32BITS(obj_tptr+4))>>31),
                                ((EXTRACT_32BITS(obj_tptr+4))&0xFF),
                                EXTRACT_32BITS(obj_tptr+8),
                                EXTRACT_32BITS(obj_tptr + 12)));
                         break;
 
                     case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL:
                         if (subobj_len < 8) {
                             return -1;
                         }
 
                         ND_PRINT((ndo, ""%s    Service level: %u"",
                                ident, (EXTRACT_32BITS(obj_tptr + 4)) >> 24));
                         break;
 
                     default:
                         hexdump=TRUE;
                         break;
                     }
                     total_subobj_len-=subobj_len;
                     obj_tptr+=subobj_len;
                     obj_tlen+=subobj_len;
 		}
 
                 if (total_subobj_len) {
                      
                     hexdump=TRUE;
                 }
                 break;
 
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_RSVP_HOP:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_3:  
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_32BITS(obj_tptr + 4)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 if (obj_tlen)
                     hexdump=TRUE;  
                 break;
             case RSVP_CTYPE_4:  
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 20)
                     return-1;
                 ND_PRINT((ndo, ""%s  Previous/Next Interface: %s, Logical Interface Handle: 0x%08x"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_32BITS(obj_tptr + 16)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 hexdump=TRUE;  
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_TIME_VALUES:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Refresh Period: %ums"",
                        ident,
                        EXTRACT_32BITS(obj_tptr)));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
          
         case RSVP_OBJ_SENDER_TSPEC:
         case RSVP_OBJ_ADSPEC:
         case RSVP_OBJ_FLOWSPEC:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_2:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Msg-Version: %u, length: %u"",
                        ident,
                        (*obj_tptr & 0xf0) >> 4,
                        EXTRACT_16BITS(obj_tptr + 2) << 2));
                 obj_tptr+=4;  
                 obj_tlen-=4;
 
                 while (obj_tlen >= 4) {
                     intserv_serv_tlen=EXTRACT_16BITS(obj_tptr+2)<<2;
                     ND_PRINT((ndo, ""%s  Service Type: %s (%u), break bit %s set, Service length: %u"",
                            ident,
                            tok2str(rsvp_intserv_service_type_values,""unknown"",*(obj_tptr)),
                            *(obj_tptr),
                            (*(obj_tptr+1)&0x80) ? """" : ""not"",
                            intserv_serv_tlen));
 
                     obj_tptr+=4;  
                     obj_tlen-=4;
 
                     while (intserv_serv_tlen>=4) {
                         processed = rsvp_intserv_print(ndo, obj_tptr, obj_tlen);
                         if (processed == 0)
                             break;
                         obj_tlen-=processed;
                         intserv_serv_tlen-=processed;
                         obj_tptr+=processed;
                     }
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_FILTERSPEC:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, Source Port: %u"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 6)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 20)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, Source Port: %u"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 18)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
             case RSVP_CTYPE_3:
                 if (obj_tlen < 20)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, Flow Label: %u"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_24BITS(obj_tptr + 17)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
             case RSVP_CTYPE_TUNNEL_IPV6:
                 if (obj_tlen < 20)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, LSP-ID: 0x%04x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 18)));
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
             case RSVP_CTYPE_13:  
                 if (obj_tlen < 40)
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv6 Tunnel Sender Address: %s, LSP ID: 0x%04x""
                        ""%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+18),
                        ident,
                        ip6addr_string(ndo, obj_tptr+20),
                        EXTRACT_16BITS(obj_tptr + 38)));
                 obj_tlen-=40;
                 obj_tptr+=40;
                 break;
             case RSVP_CTYPE_TUNNEL_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Source Address: %s, LSP-ID: 0x%04x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr + 6)));
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_12:  
                 if (obj_tlen < 16)
                     return-1;
                 ND_PRINT((ndo, ""%s  IPv4 Tunnel Sender Address: %s, LSP ID: 0x%04x""
                        ""%s  Sub-Group Originator ID: %s, Sub-Group ID: 0x%04x"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        EXTRACT_16BITS(obj_tptr+6),
                        ident,
                        ipaddr_string(ndo, obj_tptr+8),
                        EXTRACT_16BITS(obj_tptr + 12)));
                 obj_tlen-=16;
                 obj_tptr+=16;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
          case RSVP_OBJ_FASTREROUTE:
               
              obj_ptr.rsvp_obj_frr = (const struct rsvp_obj_frr_t *)obj_tptr;
            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
  
              switch(rsvp_obj_ctype) {
              case RSVP_CTYPE_1:  
                  if (obj_tlen < sizeof(struct rsvp_obj_frr_t))
                      return-1;
                 bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
                  ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                         ident,
                         (int)obj_ptr.rsvp_obj_frr->setup_prio,
                        (int)obj_ptr.rsvp_obj_frr->hold_prio,
                        (int)obj_ptr.rsvp_obj_frr->hop_limit,
                         bw.f * 8 / 1000000));
                 ND_PRINT((ndo, ""%s  Include-any: 0x%08x, Exclude-any: 0x%08x, Include-all: 0x%08x"",
                        ident,
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_all)));
                 obj_tlen-=sizeof(struct rsvp_obj_frr_t);
                 obj_tptr+=sizeof(struct rsvp_obj_frr_t);
                 break;
 
              case RSVP_CTYPE_TUNNEL_IPV4:  
                  if (obj_tlen < 16)
                      return-1;
                 bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
                  ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                         ident,
                         (int)obj_ptr.rsvp_obj_frr->setup_prio,
                        (int)obj_ptr.rsvp_obj_frr->hold_prio,
                        (int)obj_ptr.rsvp_obj_frr->hop_limit,
                         bw.f * 8 / 1000000));
                 ND_PRINT((ndo, ""%s  Include Colors: 0x%08x, Exclude Colors: 0x%08x"",
                        ident,
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->include_any),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->exclude_any)));
                 obj_tlen-=16;
                 obj_tptr+=16;
                 break;
 
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_DETOUR:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_TUNNEL_IPV4:
                 while(obj_tlen >= 8) {
                     ND_PRINT((ndo, ""%s  PLR-ID: %s, Avoid-Node-ID: %s"",
                            ident,
                            ipaddr_string(ndo, obj_tptr),
                            ipaddr_string(ndo, obj_tptr + 4)));
                     obj_tlen-=8;
                     obj_tptr+=8;
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_CLASSTYPE:
         case RSVP_OBJ_CLASSTYPE_OLD:  
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_ERROR_SPEC:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_3:  
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 8)
                     return-1;
                 error_code=*(obj_tptr+5);
                 error_value=EXTRACT_16BITS(obj_tptr+6);
                 ND_PRINT((ndo, ""%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)"",
                        ident,
                        ipaddr_string(ndo, obj_tptr),
                        *(obj_tptr+4),
                        ident,
                        tok2str(rsvp_obj_error_code_values,""unknown"",error_code),
                        error_code));
                 switch (error_code) {
                 case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:
                     ND_PRINT((ndo, "", Error Value: %s (%u)"",
                            tok2str(rsvp_obj_error_code_routing_values,""unknown"",error_value),
                            error_value));
                     break;
                 case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE:  
                 case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD:
                     ND_PRINT((ndo, "", Error Value: %s (%u)"",
                            tok2str(rsvp_obj_error_code_diffserv_te_values,""unknown"",error_value),
                            error_value));
                     break;
                 default:
                     ND_PRINT((ndo, "", Unknown Error Value (%u)"", error_value));
                     break;
                 }
                 obj_tlen-=8;
                 obj_tptr+=8;
                 break;
             case RSVP_CTYPE_4:  
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 20)
                     return-1;
                 error_code=*(obj_tptr+17);
                 error_value=EXTRACT_16BITS(obj_tptr+18);
                 ND_PRINT((ndo, ""%s  Error Node Address: %s, Flags: [0x%02x]%s  Error Code: %s (%u)"",
                        ident,
                        ip6addr_string(ndo, obj_tptr),
                        *(obj_tptr+16),
                        ident,
                        tok2str(rsvp_obj_error_code_values,""unknown"",error_code),
                        error_code));
 
                 switch (error_code) {
                 case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING:
                     ND_PRINT((ndo, "", Error Value: %s (%u)"",
                            tok2str(rsvp_obj_error_code_routing_values,""unknown"",error_value),
 			   error_value));
                     break;
                 default:
                     break;
                 }
                 obj_tlen-=20;
                 obj_tptr+=20;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_PROPERTIES:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 4)
                     return-1;
                 padbytes = EXTRACT_16BITS(obj_tptr+2);
                 ND_PRINT((ndo, ""%s  TLV count: %u, padding bytes: %u"",
                        ident,
                        EXTRACT_16BITS(obj_tptr),
                        padbytes));
                 obj_tlen-=4;
                 obj_tptr+=4;
                  
                 while(obj_tlen >= 2 + padbytes) {
                     ND_PRINT((ndo, ""%s    %s TLV (0x%02x), length: %u"",  
                            ident,
                            tok2str(rsvp_obj_prop_tlv_values,""unknown"",*obj_tptr),
                            *obj_tptr,
                            *(obj_tptr + 1)));
                     if (obj_tlen < *(obj_tptr+1))
                         return-1;
                     if (*(obj_tptr+1) < 2)
                         return -1;
                     print_unknown_data(ndo, obj_tptr + 2, ""\n\t\t"", *(obj_tptr + 1) - 2);
                     obj_tlen-=*(obj_tptr+1);
                     obj_tptr+=*(obj_tptr+1);
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_MESSAGE_ID:      
         case RSVP_OBJ_MESSAGE_ID_ACK:  
         case RSVP_OBJ_MESSAGE_ID_LIST:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
             case RSVP_CTYPE_2:
                 if (obj_tlen < 8)
                     return-1;
                 ND_PRINT((ndo, ""%s  Flags [0x%02x], epoch: %u"",
                        ident,
                        *obj_tptr,
                        EXTRACT_24BITS(obj_tptr + 1)));
                 obj_tlen-=4;
                 obj_tptr+=4;
                  
                 while(obj_tlen >= 4) {
                     ND_PRINT((ndo, ""%s    Message-ID 0x%08x (%u)"",
                            ident,
                            EXTRACT_32BITS(obj_tptr),
                            EXTRACT_32BITS(obj_tptr)));
                     obj_tlen-=4;
                     obj_tptr+=4;
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_INTEGRITY:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < sizeof(struct rsvp_obj_integrity_t))
                     return-1;
                 obj_ptr.rsvp_obj_integrity = (const struct rsvp_obj_integrity_t *)obj_tptr;
                 ND_PRINT((ndo, ""%s  Key-ID 0x%04x%08x, Sequence 0x%08x%08x, Flags [%s]"",
                        ident,
                        EXTRACT_16BITS(obj_ptr.rsvp_obj_integrity->key_id),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->key_id+2),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->sequence+4),
                        bittok2str(rsvp_obj_integrity_flag_values,
                                   ""none"",
                                   obj_ptr.rsvp_obj_integrity->flags)));
                 ND_PRINT((ndo, ""%s  MD5-sum 0x%08x%08x%08x%08x "",
                        ident,
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+4),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest+8),
                        EXTRACT_32BITS(obj_ptr.rsvp_obj_integrity->digest + 12)));
 
                 sigcheck = signature_verify(ndo, pptr, plen,
                                             obj_ptr.rsvp_obj_integrity->digest,
                                             rsvp_clear_checksum,
                                             rsvp_com_header);
                 ND_PRINT((ndo, "" (%s)"", tok2str(signature_check_values, ""Unknown"", sigcheck)));
 
                 obj_tlen+=sizeof(struct rsvp_obj_integrity_t);
                 obj_tptr+=sizeof(struct rsvp_obj_integrity_t);
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_ADMIN_STATUS:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Flags [%s]"", ident,
                        bittok2str(rsvp_obj_admin_status_flag_values, ""none"",
                                   EXTRACT_32BITS(obj_tptr))));
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_LABEL_SET:
             switch(rsvp_obj_ctype) {
             case RSVP_CTYPE_1:
                 if (obj_tlen < 4)
                     return-1;
                 action = (EXTRACT_16BITS(obj_tptr)>>8);
 
                 ND_PRINT((ndo, ""%s  Action: %s (%u), Label type: %u"", ident,
                        tok2str(rsvp_obj_label_set_action_values, ""Unknown"", action),
                        action, ((EXTRACT_32BITS(obj_tptr) & 0x7F))));
 
                 switch (action) {
                 case LABEL_SET_INCLUSIVE_RANGE:
                 case LABEL_SET_EXCLUSIVE_RANGE:  
 
 		     
 		    if (obj_tlen < 12)
 			return -1;
 		    ND_PRINT((ndo, ""%s  Start range: %u, End range: %u"", ident,
                            EXTRACT_32BITS(obj_tptr+4),
                            EXTRACT_32BITS(obj_tptr + 8)));
 		    obj_tlen-=12;
 		    obj_tptr+=12;
                     break;
 
                 default:
                     obj_tlen-=4;
                     obj_tptr+=4;
                     subchannel = 1;
                     while(obj_tlen >= 4 ) {
                         ND_PRINT((ndo, ""%s  Subchannel #%u: %u"", ident, subchannel,
                                EXTRACT_32BITS(obj_tptr)));
                         obj_tptr+=4;
                         obj_tlen-=4;
                         subchannel++;
                     }
                     break;
                 }
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
         case RSVP_OBJ_S2L:
             switch (rsvp_obj_ctype) {
             case RSVP_CTYPE_IPV4:
                 if (obj_tlen < 4)
                     return-1;
                 ND_PRINT((ndo, ""%s  Sub-LSP destination address: %s"",
                        ident, ipaddr_string(ndo, obj_tptr)));
 
                 obj_tlen-=4;
                 obj_tptr+=4;
                 break;
             case RSVP_CTYPE_IPV6:
                 if (obj_tlen < 16)
                     return-1;
                 ND_PRINT((ndo, ""%s  Sub-LSP destination address: %s"",
                        ident, ip6addr_string(ndo, obj_tptr)));
 
                 obj_tlen-=16;
                 obj_tptr+=16;
                 break;
             default:
                 hexdump=TRUE;
             }
             break;
 
          
 
         case RSVP_OBJ_SCOPE:
         case RSVP_OBJ_POLICY_DATA:
         case RSVP_OBJ_ACCEPT_LABEL_SET:
         case RSVP_OBJ_PROTECTION:
         default:
             if (ndo->ndo_vflag <= 1)
                 print_unknown_data(ndo, obj_tptr, ""\n\t    "", obj_tlen);  
             break;
         }
          
         if (ndo->ndo_vflag > 1 || hexdump == TRUE)
             print_unknown_data(ndo, tptr + sizeof(struct rsvp_object_header), ""\n\t    "",  
                                rsvp_obj_len - sizeof(struct rsvp_object_header));
 
         tptr+=rsvp_obj_len;
         tlen-=rsvp_obj_len;
     }
     return 0;
 invalid:
     ND_PRINT((ndo, ""%s"", istr));
     return -1;
 trunc:
     ND_PRINT((ndo, ""\n\t\t""));
     ND_PRINT((ndo, ""%s"", tstr));
     return -1;
 }","[822, 841, 816]",The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().
6070,"make_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)
{
const uint16_t buf_len = 511;
char buf[buf_len + 1];
struct lys_type_bit **bits = NULL;
struct lyxp_expr *exp;
const char *module_name, *cur_expr, *end;
int i, j, count;
int64_t num;
uint64_t unum;
uint8_t c;

switch (type) {
case LY_TYPE_BITS:
bits = (struct lys_type_bit **)data1;
count = *((int *)data2);

buf[0] = '\0';
for (i = 0; i < count; i++) {
if (!bits[i]) {

continue;
}
if (buf[0]) {
sprintf(buf + strlen(buf), "" %s"", bits[i]->name);
} else {
strcpy(buf, bits[i]->name);
}
}
break;

case LY_TYPE_IDENT:
module_name = (const char *)data1;

if (!strchr(*value, ':')) {
sprintf(buf, ""%s:%s"", module_name, *value);
} else {
strcpy(buf, *value);
}
break;

case LY_TYPE_INST:
exp = lyxp_parse_expr(ctx, *value);
LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), 0);

module_name = NULL;
count = 0;
for (i = 0; (unsigned)i < exp->used; ++i) {
cur_expr = &exp->expr[exp->expr_pos[i]];


if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {
if (count + (cur_expr - end) > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return 0;
}
strncpy(&buf[count], end, cur_expr - end);
count += cur_expr - end;
}

if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {

++end;
j = end - cur_expr;

if (!module_name || strncmp(cur_expr, module_name, j)) {

if (count + j > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return 0;
}
strncpy(&buf[count], cur_expr, j);
count += j;
}
module_name = cur_expr;


if (count + (exp->tok_len[i] - j) > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return 0;
}
strncpy(&buf[count], end, exp->tok_len[i] - j);
count += exp->tok_len[i] - j;
} else {
if (count + exp->tok_len[i] > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return 0;
}
strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);
count += exp->tok_len[i];
}
}
if (count > buf_len) {
LOGINT(ctx);
lyxp_expr_free(exp);
return 0;
}
buf[count] = '\0';

lyxp_expr_free(exp);
break;

case LY_TYPE_DEC64:
num = *((int64_t *)data1);
c = *((uint8_t *)data2);
if (num) {
count = sprintf(buf, ""%""PRId64"" "", num);
if ( (num > 0 && (count - 1) <= c)
|| (count - 2) <= c ) {




count = sprintf(buf, ""%0*""PRId64"" "", (num > 0) ? (c + 1) : (c + 2), num);
}
for (i = c, j = 1; i > 0 ; i--) {
if (j && i > 1 && buf[count - 2] == '0') {

buf[count - 1] = '\0';
} else {
j = 0;
buf[count - 1] = buf[count - 2];
}
count--;
}
buf[count - 1] = '.';
} else {

sprintf(buf, ""0.0"");
}
break;

case LY_TYPE_INT8:
case LY_TYPE_INT16:
case LY_TYPE_INT32:
case LY_TYPE_INT64:
num = *((int64_t *)data1);
sprintf(buf, ""%""PRId64, num);
break;

case LY_TYPE_UINT8:
case LY_TYPE_UINT16:
case LY_TYPE_UINT32:
case LY_TYPE_UINT64:
unum = *((uint64_t *)data1);
sprintf(buf, ""%""PRIu64, unum);
break;

default:

return 0;
}

if (strcmp(buf, *value)) {
lydict_remove(ctx, *value);
*value = lydict_insert(ctx, buf, 0);
return 1;
}

return 0;
}","[13, 25, 27, 44, 54, 56, 70, 72, 81, 83, 89, 91, 100, 161]","In all versions of libyang before 1.0-r5, a stack-based buffer overflow was discovered in the way libyang parses YANG files with a leaf of type ""bits"". An application that uses libyang to parse untrusted YANG files may be vulnerable to this flaw, which would allow an attacker to cause a denial of service or possibly gain code execution."
202038,"  dwarf_elf_object_access_load_section(void* obj_in,
      Dwarf_Half section_index,
     Dwarf_Small** section_data,
     int* error)
 {
     dwarf_elf_object_access_internals_t*obj =
         (dwarf_elf_object_access_internals_t*)obj_in;
     if (section_index == 0) {
         return DW_DLV_NO_ENTRY;
     }
 
     {
         Elf_Scn *scn = 0;
         Elf_Data *data = 0;
 
         scn = elf_getscn(obj->elf, section_index);
         if (scn == NULL) {
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
 
          
         data = elf_getdata(scn, NULL);
         if (data == NULL) {
              *error = DW_DLE_MDE;
              return DW_DLV_ERROR;
          }
         if (!data->d_buf) {
              
             *error = DW_DLE_MDE;
             return DW_DLV_ERROR;
         }
          *section_data = data->d_buf;
      }
      return DW_DLV_OK;
 }","[28, 29, 30, 31, 32]",libdwarf 20151114 and earlier allows remote attackers to cause a denial of service (NULL pointer dereference and crash) via a debug_abbrev section marked NOBITS in an ELF file.
204270," xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
     xmlChar limit = 0;
     xmlChar *buf = NULL;
     xmlChar *rep = NULL;
     int len = 0;
     int buf_size = 0;
     int c, l, in_space = 0;
     xmlChar *current = NULL;
     xmlEntityPtr ent;
 
     if (NXT(0) == '""') {
 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
 	limit = '""';
         NEXT;
     } else if (NXT(0) == '\'') {
 	limit = '\'';
 	ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
         NEXT;
     } else {
 	xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
 	return(NULL);
     }
 
      
     buf_size = XML_PARSER_BUFFER_SIZE;
     buf = (xmlChar *) xmlMallocAtomic(buf_size * sizeof(xmlChar));
     if (buf == NULL) goto mem_error;
 
      
     c = CUR_CHAR(l);
     while ((NXT(0) != limit) &&  
            (IS_CHAR(c)) && (c != '<')) {
 	if (c == 0) break;
 	if (c == '&') {
 	    in_space = 0;
 	    if (NXT(1) == '#') {
 		int val = xmlParseCharRef(ctxt);
 
 		if (val == '&') {
 		    if (ctxt->replaceEntities) {
 			if (len > buf_size - 10) {
 			    growBuffer(buf, 10);
 			}
 			buf[len++] = '&';
 		    } else {
 			 
 			if (len > buf_size - 10) {
 			    growBuffer(buf, 10);
 			}
 			buf[len++] = '&';
 			buf[len++] = '#';
 			buf[len++] = '3';
 			buf[len++] = '8';
 			buf[len++] = ';';
 		    }
 		} else if (val != 0) {
 		    if (len > buf_size - 10) {
 			growBuffer(buf, 10);
 		    }
 		    len += xmlCopyChar(0, &buf[len], val);
 		}
 	    } else {
 		ent = xmlParseEntityRef(ctxt);
 		ctxt->nbentities++;
 		if (ent != NULL)
 		    ctxt->nbentities += ent->owner;
 		if ((ent != NULL) &&
 		    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
 		    if (len > buf_size - 10) {
 			growBuffer(buf, 10);
 		    }
 		    if ((ctxt->replaceEntities == 0) &&
 		        (ent->content[0] == '&')) {
 			buf[len++] = '&';
 			buf[len++] = '#';
 			buf[len++] = '3';
 			buf[len++] = '8';
 			buf[len++] = ';';
 		    } else {
 			buf[len++] = ent->content[0];
 		    }
 		} else if ((ent != NULL) && 
 		           (ctxt->replaceEntities != 0)) {
 		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);
 			if (rep != NULL) {
 			    current = rep;
 			    while (*current != 0) {  
                                 if ((*current == 0xD) || (*current == 0xA) ||
                                     (*current == 0x9)) {
                                     buf[len++] = 0x20;
                                     current++;
                                 } else
                                     buf[len++] = *current++;
 				if (len > buf_size - 10) {
 				    growBuffer(buf, 10);
 				}
 			    }
 			    xmlFree(rep);
 			    rep = NULL;
 			}
 		    } else {
 			if (len > buf_size - 10) {
 			    growBuffer(buf, 10);
 			}
 			if (ent->content != NULL)
 			    buf[len++] = ent->content[0];
 		    }
 		} else if (ent != NULL) {
 		    int i = xmlStrlen(ent->name);
 		    const xmlChar *cur = ent->name;
 
 		     
 		    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
 			(ent->content != NULL)) {
 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);
 			if (rep != NULL) {
 			    xmlFree(rep);
 			    rep = NULL;
 			}
 		    }
 
 		     
 		    buf[len++] = '&';
 		    while (len > buf_size - i - 10) {
 			growBuffer(buf, i + 10);
 		    }
 		    for (;i > 0;i--)
 			buf[len++] = *cur++;
 		    buf[len++] = ';';
 		}
 	    }
 	} else {
 	    if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
 	        if ((len != 0) || (!normalize)) {
 		    if ((!normalize) || (!in_space)) {
 			COPY_BUF(l,buf,len,0x20);
 			while (len > buf_size - 10) {
 			    growBuffer(buf, 10);
 			}
 		    }
 		    in_space = 1;
 		}
 	    } else {
 	        in_space = 0;
 		COPY_BUF(l,buf,len,c);
 		if (len > buf_size - 10) {
 		    growBuffer(buf, 10);
 		}
 	    }
 	    NEXTL(l);
 	}
 	GROW;
  	c = CUR_CHAR(l);
      }
      if ((in_space) && (normalize)) {
        while (buf[len - 1] == 0x20) len--;
         while ((len > 0) && (buf[len - 1] == 0x20)) len--;
      }
      buf[len] = 0;
      if (RAW == '<') {
 	xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
     } else if (RAW != limit) {
 	if ((c != 0) && (!IS_CHAR(c))) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
 			   ""invalid character in attribute value\n"");
 	} else {
 	    xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
 			   ""AttValue: ' expected\n"");
         }
     } else
 	NEXT;
     if (attlen != NULL) *attlen = len;
     return(buf);
 
 mem_error:
     xmlErrMemory(ctxt, NULL);
     if (buf != NULL)
         xmlFree(buf);
     if (rep != NULL)
         xmlFree(rep);
     return(NULL);
 }","[161, 160]","Heap-based buffer underflow in the xmlParseAttValueComplex function in parser.c in libxml2 2.9.0 and earlier, as used in Google Chrome before 23.0.1271.91 and other products, allows remote attackers to cause a denial of service or possibly execute arbitrary code via crafted entities in an XML document."
204868," void RenderThreadImpl::Shutdown() {
   FOR_EACH_OBSERVER(
       RenderProcessObserver, observers_, OnRenderProcessShutdown());
 
   ChildThread::Shutdown();
 
   if (memory_observer_) {
     message_loop()->RemoveTaskObserver(memory_observer_.get());
     memory_observer_.reset();
   }
  
    if (webkit_platform_support_) {
      
      
      
     WebView::willEnterModalLoop();
      webkit_platform_support_->web_database_observer_impl()->
          WaitForAllDatabasesToClose();
     WebView::didExitModalLoop();
    }
  
   if (devtools_agent_message_filter_.get()) {
     RemoveFilter(devtools_agent_message_filter_.get());
     devtools_agent_message_filter_ = NULL;
   }
 
   RemoveFilter(audio_input_message_filter_.get());
   audio_input_message_filter_ = NULL;
 
   RemoveFilter(audio_message_filter_.get());
   audio_message_filter_ = NULL;
 
 #if defined(ENABLE_WEBRTC)
   RTCPeerConnectionHandler::DestructAllHandlers();
 
   peer_connection_factory_.reset();
 #endif
   RemoveFilter(vc_manager_->video_capture_message_filter());
   vc_manager_.reset();
 
   RemoveFilter(db_message_filter_.get());
   db_message_filter_ = NULL;
 
   if (file_thread_)
     file_thread_->Stop();
 
   if (compositor_output_surface_filter_.get()) {
     RemoveFilter(compositor_output_surface_filter_.get());
     compositor_output_surface_filter_ = NULL;
   }
 
   media_thread_.reset();
   compositor_thread_.reset();
   input_handler_manager_.reset();
   if (input_event_filter_.get()) {
     RemoveFilter(input_event_filter_.get());
     input_event_filter_ = NULL;
   }
 
   embedded_worker_dispatcher_.reset();
 
   main_thread_indexed_db_dispatcher_.reset();
 
   if (webkit_platform_support_)
     blink::shutdown();
 
   lazy_tls.Pointer()->Set(NULL);
 
 #if defined(OS_WIN)
   NPChannelBase::CleanupChannels();
 #endif
 }","[13, 14, 15, 16, 19]","Multiple race conditions in the Web Audio implementation in Blink, as used in Google Chrome before 30.0.1599.66, allow remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to threading in core/html/HTMLMediaElement.cpp, core/platform/audio/AudioDSPKernelProcessor.cpp, core/platform/audio/HRTFElevation.cpp, and modules/webaudio/ConvolverNode.cpp."
202335,"  xfs_dinode_verify(
  	struct xfs_mount	*mp,
 	xfs_ino_t		ino,
 	struct xfs_dinode	*dip)
 {
 	xfs_failaddr_t		fa;
 	uint16_t		mode;
 	uint16_t		flags;
 	uint64_t		flags2;
 	uint64_t		di_size;
 
 	if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 		return __this_address;
 
 	 
 	if (dip->di_version >= 3) {
 		if (!xfs_sb_version_hascrc(&mp->m_sb))
 			return __this_address;
 		if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize,
 				      XFS_DINODE_CRC_OFF))
 			return __this_address;
 		if (be64_to_cpu(dip->di_ino) != ino)
 			return __this_address;
 		if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid))
 			return __this_address;
 	}
 
 	 
 	di_size = be64_to_cpu(dip->di_size);
 	if (di_size & (1ULL << 63))
 		return __this_address;
 
 	mode = be16_to_cpu(dip->di_mode);
 	if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN)
 		return __this_address;
 
 	 
 	if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0)
 		return __this_address;
 
 	 
 	if (mode &&
 	    be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) >
 			be64_to_cpu(dip->di_nblocks))
 		return __this_address;
 
 	if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize)
 		return __this_address;
 
 	flags = be16_to_cpu(dip->di_flags);
 
 	if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp)
 		return __this_address;
 
 	 
 	switch (mode & S_IFMT) {
 	case S_IFIFO:
 	case S_IFCHR:
 	case S_IFBLK:
 	case S_IFSOCK:
 		if (dip->di_format != XFS_DINODE_FMT_DEV)
 			return __this_address;
 		break;
  	case S_IFREG:
  	case S_IFLNK:
  	case S_IFDIR:
		switch (dip->di_format) {
		case XFS_DINODE_FMT_LOCAL:
			 
			if (S_ISREG(mode))
				return __this_address;
			if (di_size > XFS_DFORK_DSIZE(dip, mp))
				return __this_address;
			if (dip->di_nextents)
				return __this_address;
			 
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
 		fa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);
 		if (fa)
 			return fa;
  		break;
  	case 0:
  		 
 		break;
 	default:
 		return __this_address;
  	}
  
  	if (XFS_DFORK_Q(dip)) {
		switch (dip->di_aformat) {
		case XFS_DINODE_FMT_LOCAL:
			if (dip->di_anextents)
				return __this_address;
		 
		case XFS_DINODE_FMT_EXTENTS:
		case XFS_DINODE_FMT_BTREE:
			break;
		default:
			return __this_address;
		}
 		fa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);
 		if (fa)
 			return fa;
  	} else {
  		 
 		switch (dip->di_aformat) {
 		case 0:
 		case XFS_DINODE_FMT_EXTENTS:
 			break;
 		default:
 			return __this_address;
 		}
 		if (dip->di_anextents)
 			return __this_address;
 	}
 
 	 
 	fa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize),
 			mode, flags);
 	if (fa)
 		return fa;
 
 	 
 	if (dip->di_version < 3)
 		return NULL;
 
 	flags2 = be64_to_cpu(dip->di_flags2);
 
 	 
 	if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) &&
 	     !xfs_sb_version_hasreflink(&mp->m_sb))
 		return __this_address;
 
 	 
 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG)
 		return __this_address;
 
 	 
 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME))
 		return __this_address;
 
 	 
 	if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX))
 		return __this_address;
 
 	 
 	fa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize),
 			mode, flags, flags2);
 	if (fa)
 		return fa;
 
 	return NULL;
 }","[83, 84, 85, 106, 107, 108, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105]","An issue was discovered in fs/xfs/libxfs/xfs_inode_buf.c in the Linux kernel through 4.17.3. A denial of service (memory corruption and BUG) can occur for a corrupted xfs image upon encountering an inode that is in extent format, but has more extents than fit in the inode fork."
199261," int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)
  {
  	skb_orphan(skb);
  
	if (!(dev->flags & IFF_UP))
		return NET_RX_DROP;
	if (skb->len > (dev->mtu + dev->hard_header_len))
 	if (!(dev->flags & IFF_UP) ||
 	    (skb->len > (dev->mtu + dev->hard_header_len))) {
 		kfree_skb(skb);
  		return NET_RX_DROP;
 	}
  	skb_set_dev(skb, dev);
  	skb->tstamp.tv64 = 0;
  	skb->pkt_type = PACKET_HOST;
 	skb->protocol = eth_type_trans(skb, dev);
 	return netif_rx(skb);
 }","[8, 9, 10, 12, 5, 6, 7]","The veth (aka virtual Ethernet) driver in the Linux kernel before 2.6.34 does not properly manage skbs during congestion, which allows remote attackers to cause a denial of service (system crash) by leveraging lack of skb consumption in conjunction with a double-free error."
200082," packet_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)
 {
 	struct sock *sk = sock->sk;
 	struct packet_sock *po = pkt_sk(sk);
 	int ret;
 
 	if (level != SOL_PACKET)
 		return -ENOPROTOOPT;
 
 	switch (optname) {
 	case PACKET_ADD_MEMBERSHIP:
 	case PACKET_DROP_MEMBERSHIP:
 	{
 		struct packet_mreq_max mreq;
 		int len = optlen;
 		memset(&mreq, 0, sizeof(mreq));
 		if (len < sizeof(struct packet_mreq))
 			return -EINVAL;
 		if (len > sizeof(mreq))
 			len = sizeof(mreq);
 		if (copy_from_user(&mreq, optval, len))
 			return -EFAULT;
 		if (len < (mreq.mr_alen + offsetof(struct packet_mreq, mr_address)))
 			return -EINVAL;
 		if (optname == PACKET_ADD_MEMBERSHIP)
 			ret = packet_mc_add(sk, &mreq);
 		else
 			ret = packet_mc_drop(sk, &mreq);
 		return ret;
 	}
 
 	case PACKET_RX_RING:
 	case PACKET_TX_RING:
 	{
 		union tpacket_req_u req_u;
 		int len;
 
 		switch (po->tp_version) {
 		case TPACKET_V1:
 		case TPACKET_V2:
 			len = sizeof(req_u.req);
 			break;
 		case TPACKET_V3:
 		default:
 			len = sizeof(req_u.req3);
 			break;
 		}
 		if (optlen < len)
 			return -EINVAL;
 		if (copy_from_user(&req_u.req, optval, len))
 			return -EFAULT;
 		return packet_set_ring(sk, &req_u, 0,
 			optname == PACKET_TX_RING);
 	}
 	case PACKET_COPY_THRESH:
 	{
 		int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		pkt_sk(sk)->copy_thresh = val;
 		return 0;
 	}
 	case PACKET_VERSION:
 	{
 		int val;
  
  		if (optlen != sizeof(val))
  			return -EINVAL;
		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
			return -EBUSY;
  		if (copy_from_user(&val, optval, sizeof(val)))
  			return -EFAULT;
  		switch (val) {
  		case TPACKET_V1:
  		case TPACKET_V2:
  		case TPACKET_V3:
			po->tp_version = val;
			return 0;
 			break;
  		default:
  			return -EINVAL;
  		}
 		lock_sock(sk);
 		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec) {
 			ret = -EBUSY;
 		} else {
 			po->tp_version = val;
 			ret = 0;
 		}
 		release_sock(sk);
 		return ret;
  	}
  	case PACKET_RESERVE:
  	{
 		unsigned int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
 			return -EBUSY;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		po->tp_reserve = val;
 		return 0;
 	}
 	case PACKET_LOSS:
 	{
 		unsigned int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
 			return -EBUSY;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		po->tp_loss = !!val;
 		return 0;
 	}
 	case PACKET_AUXDATA:
 	{
 		int val;
 
 		if (optlen < sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		po->auxdata = !!val;
 		return 0;
 	}
 	case PACKET_ORIGDEV:
 	{
 		int val;
 
 		if (optlen < sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		po->origdev = !!val;
 		return 0;
 	}
 	case PACKET_VNET_HDR:
 	{
 		int val;
 
 		if (sock->type != SOCK_RAW)
 			return -EINVAL;
 		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
 			return -EBUSY;
 		if (optlen < sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		po->has_vnet_hdr = !!val;
 		return 0;
 	}
 	case PACKET_TIMESTAMP:
 	{
 		int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		po->tp_tstamp = val;
 		return 0;
 	}
 	case PACKET_FANOUT:
 	{
 		int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		return fanout_add(sk, val & 0xffff, val >> 16);
 	}
 	case PACKET_FANOUT_DATA:
 	{
 		if (!po->fanout)
 			return -EINVAL;
 
 		return fanout_set_data(po, optval, optlen);
 	}
 	case PACKET_TX_HAS_OFF:
 	{
 		unsigned int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)
 			return -EBUSY;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 		po->tp_tx_has_off = !!val;
 		return 0;
 	}
 	case PACKET_QDISC_BYPASS:
 	{
 		int val;
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
 		if (copy_from_user(&val, optval, sizeof(val)))
 			return -EFAULT;
 
 		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
 		return 0;
 	}
 	default:
 		return -ENOPROTOOPT;
 	}
 }","[83, 87, 88, 89, 90, 91, 92, 93, 94, 95, 73, 74, 81, 82]","Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions."
198991," static int intel_pmu_handle_irq(struct pt_regs *regs)
 {
 	struct perf_sample_data data;
 	struct cpu_hw_events *cpuc;
 	int bit, loops;
 	u64 status;
 	int handled;
 
 	perf_sample_data_init(&data, 0);
 
 	cpuc = &__get_cpu_var(cpu_hw_events);
 
 	 
 	apic_write(APIC_LVTPC, APIC_DM_NMI);
 
 	intel_pmu_disable_all();
 	handled = intel_pmu_drain_bts_buffer();
 	status = intel_pmu_get_status();
 	if (!status) {
 		intel_pmu_enable_all(0);
 		return handled;
 	}
 
 	loops = 0;
 again:
 	intel_pmu_ack_status(status);
 	if (++loops > 100) {
 		WARN_ONCE(1, ""perfevents: irq loop stuck!\n"");
 		perf_event_print_debug();
 		intel_pmu_reset();
 		goto done;
 	}
 
 	inc_irq_stat(apic_perf_irqs);
 
 	intel_pmu_lbr_read();
 
 	 
 	if (__test_and_clear_bit(62, (unsigned long *)&status)) {
 		handled++;
 		x86_pmu.drain_pebs(regs);
 	}
 
 	for_each_set_bit(bit, (unsigned long *)&status, X86_PMC_IDX_MAX) {
 		struct perf_event *event = cpuc->events[bit];
 
 		handled++;
 
 		if (!test_bit(bit, cpuc->active_mask))
 			continue;
 
 		if (!intel_pmu_save_and_restart(event))
 			continue;
  
  		data.period = event->hw.last_period;
  
		if (perf_event_overflow(event, 1, &data, regs))
 		if (perf_event_overflow(event, &data, regs))
  			x86_pmu_stop(event, 0);
  	}
  
 	 
 	status = intel_pmu_get_status();
 	if (status)
 		goto again;
 
 done:
 	intel_pmu_enable_all(0);
 	return handled;
 }","[58, 57]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
201448,"  static int install_thread_keyring(void)
  {
 	struct cred *new;
 	int ret;
 
 	new = prepare_creds();
  	if (!new)
  		return -ENOMEM;
  
	BUG_ON(new->thread_keyring);
  	ret = install_thread_keyring_to_cred(new);
  	if (ret < 0) {
  		abort_creds(new);
 		return ret;
 	}
 
 	return commit_creds(new);
  }",[10],The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.
9182,"static bool init_ehdr(ELFOBJ *bin) {
ut8 e_ident[EI_NIDENT];
ut8 ehdr[sizeof (Elf_(Ehdr))] = {0};
int i, len;
if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {
R_LOG_ERROR (""read (magic)"");
return false;
}
sdb_set (bin->kv, ""elf_type.cparse"", ""enum elf_type { ET_NONE=0, ET_REL=1,""
"" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,""
"" ET_LOPROC=0xff00, ET_HIPROC=0xffff };"", 0);
sdb_set (bin->kv, ""elf_machine.cparse"", ""enum elf_machine {EM_NONE=0, EM_M32=1,""
"" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,""
"" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,""
"" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,""
"" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,""
"" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,""
"" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,""
"" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,""
"" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,""
"" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,""
"" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,""
"" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,""
"" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,""
"" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,""
"" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,""
"" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,""
"" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,""
"" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,""
"" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,""
"" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,""
"" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,""
"" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,""
"" EM_TI_ARP32=143, EM_TI_PRU=144,""
"" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,""
"" EM_QDSP6=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,""
"" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,""
"" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,""
"" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,""
"" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,""
"" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,""
"" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,""
"" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,""
"" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,""
"" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,""
"" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,""
"" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,""
"" EM_CSKY=252, EM_KVX=256, EM_LOONGARCH=258}"", 0);
sdb_set (bin->kv, ""elf_class.cparse"", ""enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};"", 0);
sdb_set (bin->kv, ""elf_data.cparse"", ""enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};"", 0);
sdb_set (bin->kv, ""elf_hdr_version.cparse"", ""enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};"", 0);
sdb_set (bin->kv, ""elf_obj_version.cparse"", ""enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};"", 0);
sdb_num_set (bin->kv, ""elf_header.offset"", 0, 0);
sdb_num_set (bin->kv, ""elf_header.size"", sizeof (Elf_(Ehdr)), 0);
sdb_set (bin->kv, ""elf_ident.format"", ""[4]z[1]E[1]E[1]E.::""
"" magic (elf_class)class (elf_data)data (elf_hdr_version)version"", 0);
#if R_BIN_ELF64
sdb_set (bin->kv, ""elf_header.format"", ""?[2]E[2]E[4]EqqqxN2N2N2N2N2N2""
"" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version""
"" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx"", 0);
#else
sdb_set (bin->kv, ""elf_header.format"", ""?[2]E[2]E[4]ExxxxN2N2N2N2N2N2""
"" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version""
"" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx"", 0);
#endif
bin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;
memset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));
len = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));
if (len < 32) {
R_LOG_ERROR (""read (ehdr)"");
return false;
}

memcpy (&bin->ehdr.e_ident, ehdr, 16);
if (!__is_valid_ident (bin)) {
return false;
}
i = 16;

bin->ehdr.e_type = READ16 (ehdr, i);
bin->ehdr.e_machine = READ16 (ehdr, i);
bin->ehdr.e_version = READ32 (ehdr, i);
#if R_BIN_ELF64
bin->ehdr.e_entry = READ64 (ehdr, i);
bin->ehdr.e_phoff = READ64 (ehdr, i);
bin->ehdr.e_shoff = READ64 (ehdr, i);
#else
bin->ehdr.e_entry = READ32 (ehdr, i);
bin->ehdr.e_phoff = READ32 (ehdr, i);
bin->ehdr.e_shoff = READ32 (ehdr, i);
#endif
bin->ehdr.e_flags = READ32 (ehdr, i);
bin->ehdr.e_ehsize = READ16 (ehdr, i);
bin->ehdr.e_phentsize = READ16 (ehdr, i);
bin->ehdr.e_phnum = READ16 (ehdr, i);
bin->ehdr.e_shentsize = READ16 (ehdr, i);
bin->ehdr.e_shnum = READ16 (ehdr, i);
bin->ehdr.e_shstrndx = READ16 (ehdr, i);
return true;



}","[6, 70]","Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."
207611," main(const int argc, const char * const * const argv)
 {
   
  int option_end, ilog = 0;
  struct display d;
 
    validate_T();
    display_init(&d);
 
  for (option_end=1; option_end<argc; ++option_end)
  {
  const char *name = argv[option_end];
 
  if (strcmp(name, ""--verbose"") == 0)
          d.options = (d.options & ~LEVEL_MASK) | VERBOSE;
 
  else if (strcmp(name, ""--warnings"") == 0)
          d.options = (d.options & ~LEVEL_MASK) | WARNINGS;
 
  else if (strcmp(name, ""--errors"") == 0)
          d.options = (d.options & ~LEVEL_MASK) | ERRORS;
 
  else if (strcmp(name, ""--quiet"") == 0)
          d.options = (d.options & ~LEVEL_MASK) | QUIET;
 
  else if (strcmp(name, ""--exhaustive"") == 0)
          d.options |= EXHAUSTIVE;
 
  else if (strcmp(name, ""--fast"") == 0)
          d.options &= ~EXHAUSTIVE;
 
  else if (strcmp(name, ""--strict"") == 0)
          d.options |= STRICT;
 
  else if (strcmp(name, ""--relaxed"") == 0)
          d.options &= ~STRICT;
 
  else if (strcmp(name, ""--log"") == 0)
  {
          ilog = option_end;  
          d.options |= LOG;
  }
 
  else if (strcmp(name, ""--nolog"") == 0)
          d.options &= ~LOG;
 
  else if (strcmp(name, ""--continue"") == 0)
          d.options |= CONTINUE;
 
  else if (strcmp(name, ""--stop"") == 0)
          d.options &= ~CONTINUE;
 
  else if (strcmp(name, ""--skip-bugs"") == 0)
          d.options |= SKIP_BUGS;
 
  else if (strcmp(name, ""--test-all"") == 0)
          d.options &= ~SKIP_BUGS;
 
  else if (strcmp(name, ""--log-skipped"") == 0)
          d.options |= LOG_SKIPPED;
 
  else if (strcmp(name, ""--nolog-skipped"") == 0)
          d.options &= ~LOG_SKIPPED;
 
  else if (strcmp(name, ""--find-bad-combos"") == 0)
          d.options |= FIND_BAD_COMBOS;
 
 
        else if (strcmp(name, ""--nofind-bad-combos"") == 0)
           d.options &= ~FIND_BAD_COMBOS;
  
       else if (strcmp(name, ""--list-combos"") == 0)
          d.options |= LIST_COMBOS;
 
       else if (strcmp(name, ""--nolist-combos"") == 0)
          d.options &= ~LIST_COMBOS;
 
        else if (name[0] == '-' && name[1] == '-')
        {
           fprintf(stderr, ""pngimage: %s: unknown option\n"", name);
  return 99;
  }
 
  else
  break;  
  }
 
  {
  int i;
  int errors = 0;
 
  for (i=option_end; i<argc; ++i)
  {
  {
  int ret = do_test(&d, argv[i]);
 
  if (ret > QUIET)  
  return 99;
  }
 
   
  {
  const int pass = (d.options & STRICT) ?
                RESULT_STRICT(d.results) : RESULT_RELAXED(d.results);
 
  if (!pass)
  ++errors;
 
  if (d.options & LOG)
  {
  int j;
 
                printf(""%s: pngimage "", pass ? ""PASS"" : ""FAIL"");
 
  for (j=1; j<option_end; ++j) if (j != ilog)
                   printf(""%s "", argv[j]);
 
                printf(""%s\n"", d.filename);
  }
  }
 
 
           display_clean(&d);
        }
  
        
       display_destroy(&d);
 
        return errors != 0;
     }
  }","[72, 73, 74, 75, 76, 77, 126, 127, 128]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
207127," bool Performance::PassesTimingAllowCheck(
     const ResourceResponse& response,
      const SecurityOrigin& initiator_security_origin,
      const AtomicString& original_timing_allow_origin,
      ExecutionContext* context) {
   const KURL& response_url = response.WasFetchedViaServiceWorker()
                                  ? response.OriginalURLViaServiceWorker()
                                  : response.Url();
    scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response.Url());
       SecurityOrigin::Create(response_url);
    if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
      return true;
  
   const AtomicString& timing_allow_origin_string =
       original_timing_allow_origin.IsEmpty()
           ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
           : original_timing_allow_origin;
   if (timing_allow_origin_string.IsEmpty() ||
       EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
     return false;
 
   if (timing_allow_origin_string == ""*"") {
     UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
     return true;
   }
 
   const String& security_origin = initiator_security_origin.ToString();
   Vector<String> timing_allow_origins;
   timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
   if (timing_allow_origins.size() > 1) {
     UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
   } else if (timing_allow_origins.size() == 1 &&
              timing_allow_origin_string != ""*"") {
     UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
   }
   for (const String& allow_origin : timing_allow_origins) {
     const String allow_origin_stripped = allow_origin.StripWhiteSpace();
     if (allow_origin_stripped == security_origin ||
         allow_origin_stripped == ""*"") {
       return true;
     }
   }
 
   return false;
 }","[6, 7, 8, 11, 10]",Insufficient policy enforcement in ServiceWorker in Google Chrome prior to 68.0.3440.75 allowed a remote attacker to obtain potentially sensitive information from process memory via a crafted HTML page.
208217," OMX_ERRORTYPE SoftAMRNBEncoder::internalSetParameter(
         OMX_INDEXTYPE index, const OMX_PTR params) {
  switch (index) {
  case OMX_IndexParamStandardComponentRole:
  {
 
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
             if (!isValidOMXParam(roleParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (strncmp((const char *)roleParams->cRole,
                          ""audio_encoder.amrnb"",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
  return OMX_ErrorUndefined;
  }
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioPortFormat:
  {
 
              const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
             if (!isValidOMXParam(formatParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
 
  if (formatParams->nIndex > 0) {
  return OMX_ErrorNoMore;
  }
 
  if ((formatParams->nPortIndex == 0
  && formatParams->eEncoding != OMX_AUDIO_CodingPCM)
  || (formatParams->nPortIndex == 1
  && formatParams->eEncoding != OMX_AUDIO_CodingAMR)) {
  return OMX_ErrorUndefined;
  }
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioAmr:
  {
 
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
             if (!isValidOMXParam(amrParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
 
  if (amrParams->nChannels != 1
  || amrParams->eAMRDTXMode != OMX_AUDIO_AMRDTXModeOff
  || amrParams->eAMRFrameFormat
  != OMX_AUDIO_AMRFrameFormatFSF
  || amrParams->eAMRBandMode < OMX_AUDIO_AMRBandModeNB0
  || amrParams->eAMRBandMode > OMX_AUDIO_AMRBandModeNB7) {
  return OMX_ErrorUndefined;
  }
 
             mBitRate = amrParams->nBitRate;
             mMode = amrParams->eAMRBandMode - 1;
 
             amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;
             amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;
 
  return OMX_ErrorNone;
  }
 
  case OMX_IndexParamAudioPcm:
  {
 
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
             if (!isValidOMXParam(pcmParams)) {
                 return OMX_ErrorBadParameter;
             }
 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
 
  if (pcmParams->nChannels != 1
  || pcmParams->nSamplingRate != (OMX_U32)kSampleRate) {
  return OMX_ErrorUndefined;
  }
 
  return OMX_ErrorNone;
  }
 
 
  default:
  return SimpleSoftOMXComponent::internalSetParameter(index, params);
  }
 }","[10, 11, 12, 13, 29, 30, 31, 32, 57, 58, 59, 60, 89, 90, 91, 92]","mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 does not validate OMX buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27207275."
204580,"  void WebPluginProxy::SetWindowlessPumpEvent(HANDLE pump_messages_event) {
    HANDLE pump_messages_event_for_renderer = NULL;
  DuplicateHandle(GetCurrentProcess(), pump_messages_event,
                  channel_->renderer_handle(),
                  &pump_messages_event_for_renderer,
                  0, FALSE, DUPLICATE_SAME_ACCESS);
   sandbox::BrokerDuplicateHandle(pump_messages_event, channel_->peer_pid(),
                                  &pump_messages_event_for_renderer,
                                  SYNCHRONIZE | EVENT_MODIFY_STATE, 0);
    DCHECK(pump_messages_event_for_renderer != NULL);
    Send(new PluginHostMsg_SetWindowlessPumpEvent(
        route_id_, pump_messages_event_for_renderer));
 }","[7, 8, 9, 3, 4, 5, 6]","Google Chrome before 20.0.1132.43 on Windows does not properly isolate sandboxed processes, which might allow remote attackers to cause a denial of service (process interference) via unspecified vectors."
8012,"void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)
{
GF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);

if (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);
av1->emul_esd = gf_odf_desc_esd_new(2);
av1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;
av1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;

if (btrt) {
av1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;
av1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;
av1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;
}
if (av1->av1_config) {
GF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);
if (av1_cfg) {
gf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);
gf_odf_av1_cfg_del(av1_cfg);
}
}
}",[15],The AV1_DuplicateConfig function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.
1420,"std::string bdecode_error_category::message(int ev) const BOOST_SYSTEM_NOEXCEPT
{
static char const* msgs[] =
{
""no error"",
""expected string in bencoded string"",
""expected colon in bencoded string"",
""unexpected end of file in bencoded string"",
""expected value (list, dict, int or string) in bencoded string"",
""bencoded nesting depth exceeded"",
""bencoded item count limit exceeded"",
};
if (ev < 0 || ev >= int(sizeof(msgs)/sizeof(msgs[0])))
return ""Unknown error"";
return msgs[ev];
}",[13],"The lazy_bdecode function in BitTorrent bootstrap-dht (aka Bootstrap) allows remote attackers to execute arbitrary code via a crafted packet, which triggers an out-of-bounds read, related to ""Improper Indexing."""
204051," EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestObj::s_info))
         return throwVMTypeError(exec);
     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
      TestObj* impl = static_cast<TestObj*>(castedThis->impl());
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
      if (exec->hadException())
          return JSValue::encode(jsUndefined());
 
     size_t argsCount = exec->argumentCount();
     if (argsCount <= 1) {
         impl->methodWithNonOptionalArgAndOptionalArg(nonOpt);
         return JSValue::encode(jsUndefined());
     }
 
     int opt(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
     impl->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);
     return JSValue::encode(jsUndefined());
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
207205," void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   QueuedRequest* request = GetCurrentRequest();
 
   if (request == nullptr)
     return;
 
   std::vector<QueuedRequestDispatcher::ClientInfo> clients;
   for (const auto& kv : clients_) {
     auto client_identity = kv.second->identity;
     const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);
     if (pid == base::kNullProcessId) {
       VLOG(1) << ""Couldn't find a PID for client \"""" << client_identity.name()
               << ""."" << client_identity.instance() << ""\"""";
       continue;
     }
      clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
    }
  
  auto chrome_callback = base::Bind(
      &CoordinatorImpl::OnChromeMemoryDumpResponse, base::Unretained(this));
  auto os_callback = base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                                base::Unretained(this), request->dump_guid);
   auto chrome_callback =
       base::Bind(&CoordinatorImpl::OnChromeMemoryDumpResponse,
                  weak_ptr_factory_.GetWeakPtr());
   auto os_callback =
       base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                  weak_ptr_factory_.GetWeakPtr(), request->dump_guid);
    QueuedRequestDispatcher::SetUpAndDispatch(request, clients, chrome_callback,
                                              os_callback);
  
    base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
        FROM_HERE,
        base::BindOnce(&CoordinatorImpl::OnQueuedRequestTimedOut,
                     base::Unretained(this), request->dump_guid),
                      weak_ptr_factory_.GetWeakPtr(), request->dump_guid),
        client_process_timeout_);
  
    if (request->args.add_to_trace && heap_profiler_) {
     request->heap_dump_in_progress = true;
 
     bool strip_path_from_mapped_files =
         base::trace_event::TraceLog::GetInstance()
             ->GetCurrentTraceConfig()
              .IsArgumentFilterEnabled();
      heap_profiler_->DumpProcessesForTracing(
          strip_path_from_mapped_files,
            base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                           base::Unretained(this), request->dump_guid));
         base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                             weak_ptr_factory_.GetWeakPtr(),
                             request->dump_guid));
  
      base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
          FROM_HERE,
          base::BindOnce(&CoordinatorImpl::OnHeapDumpTimeOut,
                       base::Unretained(this), request->dump_guid),
                        weak_ptr_factory_.GetWeakPtr(), request->dump_guid),
          kHeapDumpTimeout);
    }
  
   FinalizeGlobalMemoryDumpIfAllManagersReplied();
 }","[24, 25, 26, 27, 28, 29, 37, 51, 52, 53, 59, 20, 21, 22, 23, 36, 49, 50, 58]",A use after free in ResourceCoordinator in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.
201389,"  static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
  {
 	u8 *buf;
  	int ret;
  
 	buf = kmemdup(&data, 1, GFP_NOIO);
 	if (!buf)
 		return -ENOMEM;
 
  	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
  			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 			      indx, buf, 1, 1000);
  	if (ret < 0)
  		netif_dbg(pegasus, drv, pegasus->net,
  			  ""%s returned %d\n"", __func__, ret);
 	kfree(buf);
  	return ret;
  }","[3, 6, 7, 8, 9, 13, 17, 12]","drivers/net/usb/pegasus.c in the Linux kernel 4.9.x before 4.9.11 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist."
205261," bool WtsSessionProcessDelegate::Core::Initialize(uint32 session_id) {
   if (base::win::GetVersion() == base::win::VERSION_XP)
      launch_elevated_ = false;
  
    if (launch_elevated_) {
      
     HMODULE kernel32 = ::GetModuleHandle(L""kernel32.dll"");
     CHECK(kernel32 != NULL);
 
     get_named_pipe_client_pid_ =
         reinterpret_cast<GetNamedPipeClientProcessIdFn>(
             GetProcAddress(kernel32, ""GetNamedPipeClientProcessId""));
     CHECK(get_named_pipe_client_pid_ != NULL);
 
      process_exit_event_.Set(CreateEvent(NULL, TRUE, FALSE, NULL));
      if (!process_exit_event_.IsValid()) {
        LOG(ERROR) << ""Failed to create a nameless event"";
       return false;
     }
 
     io_task_runner_->PostTask(FROM_HERE,
                               base::Bind(&Core::InitializeJob, this));
   }
 
   return CreateSessionToken(session_id, &session_token_);
 }","[6, 7, 8, 9, 10, 11, 12, 13, 14]",Use-after-free vulnerability in Google Chrome before 24.0.1312.52 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors involving PDF fields.
206633," void FrameFetchContext::AddResourceTiming(const ResourceTimingInfo& info) {
   if (!document_)
     return;
   LocalFrame* frame = document_->GetFrame();
   if (!frame)
     return;
 
   if (info.IsMainResource()) {
     DCHECK(frame->Owner());
      frame->Owner()->AddResourceTiming(info);
    frame->DidSendResourceTimingInfoToParent();
     frame->SetShouldSendResourceTimingInfoToParent(false);
      return;
    }
  
   DOMWindowPerformance::performance(*document_->domWindow())
       ->GenerateAndAddResourceTiming(info);
 }","[12, 11]",Incorrect handling of timer information during navigation in Blink in Google Chrome prior to 70.0.3538.67 allowed a remote attacker to obtain cross origin URLs via a crafted HTML page.
203777,"  bool ExtensionService::IsDownloadFromGallery(const GURL& download_url,
                                               const GURL& referrer_url) {
   if (IsDownloadFromMiniGallery(download_url) &&
       StartsWithASCII(referrer_url.spec(),
                       extension_urls::kMiniGalleryBrowsePrefix, false)) {
     return true;
   }
 
   const Extension* download_extension = GetExtensionByWebExtent(download_url);
   const Extension* referrer_extension = GetExtensionByWebExtent(referrer_url);
   const Extension* webstore_app = GetWebStoreApp();
 
    bool referrer_valid = (referrer_extension == webstore_app);
    bool download_valid = (download_extension == webstore_app);
  
    
   if (!download_valid) {
     for (size_t i = 0; i < arraysize(kAllowedDownloadURLPatterns); i++) {
       URLPattern pattern(URLPattern::SCHEME_HTTPS,
                          kAllowedDownloadURLPatterns[i]);
       if (pattern.MatchesURL(download_url)) {
         download_valid = true;
         break;
       }
     }
   }
 
    GURL store_url =
        GURL(CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
            switches::kAppsGalleryURL));
   if (!store_url.is_empty()) {
     std::string store_tld =
         net::RegistryControlledDomainService::GetDomainAndRegistry(store_url);
     if (!referrer_valid) {
       std::string referrer_tld =
           net::RegistryControlledDomainService::GetDomainAndRegistry(
               referrer_url);
       referrer_valid = referrer_url.is_empty() || (referrer_tld == store_tld);
     }
 
     if (!download_valid) {
       std::string download_tld =
           net::RegistryControlledDomainService::GetDomainAndRegistry(
               download_url);
 
       download_valid = (download_tld == store_tld);
     }
   }
 
   return (referrer_valid && download_valid);
 }","[16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]","Google Chrome before 14.0.835.163 uses incorrect permissions for non-gallery pages, which has unspecified impact and attack vectors."
198457,"  int virtio_load(VirtIODevice *vdev, QEMUFile *f)
  {
      int i, ret;
     int32_t config_len;
      uint32_t num;
      uint32_t features;
      uint32_t supported_features;
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
 
     if (k->load_config) {
         ret = k->load_config(qbus->parent, f);
         if (ret)
             return ret;
     }
 
     qemu_get_8s(f, &vdev->status);
     qemu_get_8s(f, &vdev->isr);
     qemu_get_be16s(f, &vdev->queue_sel);
     if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {
         return -1;
     }
     qemu_get_be32s(f, &features);
 
     if (virtio_set_features(vdev, features) < 0) {
         supported_features = k->get_features(qbus->parent);
         error_report(""Features 0x%x unsupported. Allowed features: 0x%x"",
                      features, supported_features);
                       features, supported_features);
          return -1;
      }
    vdev->config_len = qemu_get_be32(f);
     config_len = qemu_get_be32(f);
     if (config_len != vdev->config_len) {
         error_report(""Unexpected config length 0x%x. Expected 0x%zx"",
                      config_len, vdev->config_len);
         return -1;
     }
      qemu_get_buffer(f, vdev->config, vdev->config_len);
  
      num = qemu_get_be32(f);
     for (i = 0; i < num; i++) {
         vdev->vq[i].vring.num = qemu_get_be32(f);
         if (k->has_variable_vring_alignment) {
             vdev->vq[i].vring.align = qemu_get_be32(f);
         }
         vdev->vq[i].pa = qemu_get_be64(f);
         qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);
         vdev->vq[i].signalled_used_valid = false;
         vdev->vq[i].notification = true;
 
         if (vdev->vq[i].pa) {
             uint16_t nheads;
             virtqueue_init(&vdev->vq[i]);
             nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;
              
             if (nheads > vdev->vq[i].vring.num) {
                 error_report(""VQ %d size 0x%x Guest index 0x%x ""
                              ""inconsistent with Host index 0x%x: delta 0x%x"",
                              i, vdev->vq[i].vring.num,
                              vring_avail_idx(&vdev->vq[i]),
                              vdev->vq[i].last_avail_idx, nheads);
                 return -1;
             }
         } else if (vdev->vq[i].last_avail_idx) {
             error_report(""VQ %d address 0x0 ""
                          ""inconsistent with Host index 0x%x"",
                          i, vdev->vq[i].last_avail_idx);
                 return -1;
 	}
         if (k->load_queue) {
             ret = k->load_queue(qbus->parent, i, f);
             if (ret)
                 return ret;
         }
     }
 
     virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
     return 0;
 }","[4, 32, 33, 34, 35, 36, 37, 31]",Heap-based buffer overflow in the virtio_load function in hw/virtio/virtio.c in QEMU before 1.7.2 might allow remote attackers to execute arbitrary code via a crafted config length in a savevm image.
202363," int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)
 {
     MpegEncContext *s = &ctx->m;
     unsigned startcode, v;
     int ret;
     int vol = 0;
 
       
      align_get_bits(gb);
  
      
      
      
     if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
         s->avctx->bits_per_raw_sample = 0;
 
      if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) {
          skip_bits(gb, 24);
          if (get_bits(gb, 8) == 0xF0)
             goto end;
     }
 
     startcode = 0xff;
     for (;;) {
         if (get_bits_count(gb) >= gb->size_in_bits) {
             if (gb->size_in_bits == 8 &&
                 (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) {
                 av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits);
                 return FRAME_SKIPPED;   
             } else
                 return AVERROR_INVALIDDATA;   
         }
 
          
         v = get_bits(gb, 8);
         startcode = ((startcode << 8) | v) & 0xffffffff;
 
         if ((startcode & 0xFFFFFF00) != 0x100)
             continue;   
 
         if (s->avctx->debug & FF_DEBUG_STARTCODE) {
             av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode);
             if (startcode <= 0x11F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start"");
             else if (startcode <= 0x12F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start"");
             else if (startcode <= 0x13F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode <= 0x15F)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start"");
             else if (startcode <= 0x1AF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Reserved"");
             else if (startcode == 0x1B0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start"");
             else if (startcode == 0x1B1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End"");
             else if (startcode == 0x1B2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""User Data"");
             else if (startcode == 0x1B3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start"");
             else if (startcode == 0x1B4)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error"");
             else if (startcode == 0x1B5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start"");
             else if (startcode == 0x1B6)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start"");
             else if (startcode == 0x1B7)
                 av_log(s->avctx, AV_LOG_DEBUG, ""slice start"");
             else if (startcode == 0x1B8)
                 av_log(s->avctx, AV_LOG_DEBUG, ""extension start"");
             else if (startcode == 0x1B9)
                 av_log(s->avctx, AV_LOG_DEBUG, ""fgs start"");
             else if (startcode == 0x1BA)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start"");
             else if (startcode == 0x1BB)
                 av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start"");
             else if (startcode == 0x1BC)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start"");
             else if (startcode == 0x1BD)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start"");
             else if (startcode == 0x1BE)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start"");
             else if (startcode == 0x1BF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start"");
             else if (startcode == 0x1C0)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start"");
             else if (startcode == 0x1C1)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start"");
             else if (startcode == 0x1C2)
                 av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start"");
             else if (startcode == 0x1C3)
                 av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start"");
             else if (startcode <= 0x1C5)
                 av_log(s->avctx, AV_LOG_DEBUG, ""reserved"");
             else if (startcode <= 0x1FF)
                 av_log(s->avctx, AV_LOG_DEBUG, ""System start"");
             av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb));
         }
 
         if (startcode >= 0x120 && startcode <= 0x12F) {
             if (vol) {
                 av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n"");
                 continue;
             }
             vol++;
             if ((ret = decode_vol_header(ctx, gb)) < 0)
                 return ret;
         } else if (startcode == USER_DATA_STARTCODE) {
             decode_user_data(ctx, gb);
         } else if (startcode == GOP_STARTCODE) {
             mpeg4_decode_gop_header(s, gb);
         } else if (startcode == VOS_STARTCODE) {
             mpeg4_decode_profile_level(s, gb);
             if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
                 (s->avctx->level > 0 && s->avctx->level < 9)) {
                 s->studio_profile = 1;
                 next_start_code_studio(gb);
                 extension_and_user_data(s, gb, 0);
             }
         } else if (startcode == VISUAL_OBJ_STARTCODE) {
             if (s->studio_profile) {
                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)
                     return ret;
             } else
                 mpeg4_decode_visual_object(s, gb);
         } else if (startcode == VOP_STARTCODE) {
             break;
         }
 
         align_get_bits(gb);
         startcode = 0xff;
     }
 
 end:
     if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)
         s->low_delay = 1;
     s->avctx->has_b_frames = !s->low_delay;
 
     if (s->studio_profile) {
         if (!s->avctx->bits_per_raw_sample) {
             av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n"");
             return AVERROR_INVALIDDATA;
         }
         return decode_studio_vop_header(ctx, gb);
     } else
         return decode_vop_header(ctx, gb);
 }","[11, 12, 13, 14, 15, 16]","An inconsistent bits-per-sample value in the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service."
201891,"  jpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)
  {
  	jpc_streamlist_t *streams;
	uchar *dataptr;
 	jas_uchar *dataptr;
  	uint_fast32_t datacnt;
  	uint_fast32_t tpcnt;
  	jpc_ppxstabent_t *ent;
 	int entno;
 	jas_stream_t *stream;
 	int n;
 
 	if (!(streams = jpc_streamlist_create())) {
 		goto error;
 	}
 
 	if (!tab->numents) {
 		return streams;
 	}
 
 	entno = 0;
 	ent = tab->ents[entno];
 	dataptr = ent->data;
 	datacnt = ent->len;
 	for (;;) {
 
 		 
 		if (datacnt < 4) {
 			goto error;
 		}
 		if (!(stream = jas_stream_memopen(0, 0))) {
 			goto error;
 		}
 		if (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),
 		  stream)) {
 			goto error;
 		}
 		tpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)
 		  | dataptr[3];
 		datacnt -= 4;
 		dataptr += 4;
 
 		 
 		while (tpcnt) {
 			if (!datacnt) {
 				if (++entno >= tab->numents) {
 					goto error;
 				}
 				ent = tab->ents[entno];
 				dataptr = ent->data;
 				datacnt = ent->len;
 			}
 			n = JAS_MIN(tpcnt, datacnt);
 			if (jas_stream_write(stream, dataptr, n) != n) {
 				goto error;
 			}
 			tpcnt -= n;
 			dataptr += n;
 			datacnt -= n;
 		}
 		jas_stream_rewind(stream);
 		if (!datacnt) {
 			if (++entno >= tab->numents) {
 				break;
 			}
 			ent = tab->ents[entno];
 			dataptr = ent->data;
 			datacnt = ent->len;
 		}
 	}
 
 	return streams;
 
 error:
 	if (streams) {
 		jpc_streamlist_destroy(streams);
 	}
 	return 0;
 }","[5, 4]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
202975," process_demand_active(STREAM s)
  {
  	uint8 type;
  	uint16 len_src_descriptor, len_combined_caps;
 	struct stream packet = *s;
  
  	 
  	rd_create_ui();
  
  	in_uint32_le(s, g_rdp_shareid);
  	in_uint16_le(s, len_src_descriptor);
  	in_uint16_le(s, len_combined_caps);
 
 	if (!s_check_rem(s, len_src_descriptor))
 	{
 		rdp_protocol_error(""rdp_demand_active(), consume of source descriptor from stream would overrun"", &packet);
 	}
  	in_uint8s(s, len_src_descriptor);
  
  	logger(Protocol, Debug, ""process_demand_active(), shareid=0x%x"", g_rdp_shareid);
 
 	rdp_process_server_caps(s, len_combined_caps);
 
 	rdp_send_confirm_active();
 	rdp_send_synchronise();
 	rdp_send_control(RDP_CTL_COOPERATE);
 	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
 	rdp_recv(&type);	 
 	rdp_recv(&type);	 
 	rdp_recv(&type);	 
 	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
 		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
 
 	if (g_rdp_version >= RDP_V5)
 	{
 		rdp_enum_bmpcache2();
 		rdp_send_fonts(3);
 	}
 	else
 	{
 		rdp_send_fonts(1);
 		rdp_send_fonts(2);
 	}
 
 	rdp_recv(&type);	 
 	reset_order_state();
 }","[5, 13, 14, 15, 16, 17]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.
9140,"RCoreSymCacheElement *r_coresym_cache_element_new(RBinFile *bf, RBuffer *buf, ut64 off, int bits, char * file_name) {
RCoreSymCacheElement *result = NULL;
ut8 *b = NULL;
RCoreSymCacheElementHdr *hdr = r_coresym_cache_element_header_new (buf, off, bits);
if (!hdr) {
return NULL;
}
if (hdr->version != 1) {
eprintf (""Unsupported CoreSymbolication cache version (%d)\n"", hdr->version);
goto beach;
}
if (hdr->size == 0 || hdr->size > r_buf_size (buf) - off) {
eprintf (""Corrupted CoreSymbolication header: size out of bounds (0x%x)\n"", hdr->size);
goto beach;
}
result = R_NEW0 (RCoreSymCacheElement);
if (!result) {
goto beach;
}
result->hdr = hdr;
b = malloc (hdr->size);
if (!b) {
goto beach;
}
if (r_buf_read_at (buf, off, b, hdr->size) != hdr->size) {
goto beach;
}
ut8 *end = b + hdr->size;
if (file_name) {
result->file_name = file_name;
} else if (hdr->file_name_off) {
result->file_name = str_dup_safe (b, b + (size_t)hdr->file_name_off, end);
}
if (hdr->version_off) {
result->binary_version = str_dup_safe (b, b + (size_t)hdr->version_off, end);
}
const size_t word_size = bits / 8;
const ut64 start_of_sections = (ut64)hdr->n_segments * R_CS_EL_SIZE_SEG + R_CS_EL_OFF_SEGS;
const ut64 sect_size = (bits == 32) ? R_CS_EL_SIZE_SECT_32 : R_CS_EL_SIZE_SECT_64;
const ut64 start_of_symbols = start_of_sections + (ut64)hdr->n_sections * sect_size;
const ut64 start_of_lined_symbols = start_of_symbols + (ut64)hdr->n_symbols * R_CS_EL_SIZE_SYM;
const ut64 start_of_line_info = start_of_lined_symbols + (ut64)hdr->n_lined_symbols * R_CS_EL_SIZE_LSYM;
const ut64 start_of_unknown_pairs = start_of_line_info + (ut64)hdr->n_line_info * R_CS_EL_SIZE_LINFO;
const ut64 start_of_strings = start_of_unknown_pairs + (ut64)hdr->n_symbols * 8;

ut64 page_zero_size = 0;
size_t page_zero_idx = 0;
if (UT32_MUL_OVFCHK (hdr->n_segments, sizeof (RCoreSymCacheElementSegment))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_sections, sizeof (RCoreSymCacheElementSection))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_symbols, sizeof (RCoreSymCacheElementSymbol))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_lined_symbols, sizeof (RCoreSymCacheElementLinedSymbol))) {
goto beach;
} else if (UT32_MUL_OVFCHK (hdr->n_line_info, sizeof (RCoreSymCacheElementLineInfo))) {
goto beach;
}
if (hdr->n_segments > 0) {
result->segments = R_NEWS0 (RCoreSymCacheElementSegment, hdr->n_segments);
if (!result->segments) {
goto beach;
}
size_t i;
ut8 *cursor = b + R_CS_EL_OFF_SEGS;
for (i = 0; i < hdr->n_segments && cursor + sizeof (RCoreSymCacheElementSegment) < end; i++) {
RCoreSymCacheElementSegment *seg = &result->segments[i];
seg->paddr = seg->vaddr = r_read_le64 (cursor);
cursor += 8;
if (cursor >= end) {
break;
}
seg->size = seg->vsize = r_read_le64 (cursor);
cursor += 8;
if (cursor >= end) {
break;
}
seg->name = str_dup_safe_fixed (b, cursor, 16, end);
cursor += 16;
if (!seg->name) {
continue;
}

if (!strcmp (seg->name, ""__PAGEZERO"")) {
page_zero_size = seg->size;
page_zero_idx = i;
seg->paddr = seg->vaddr = 0;
seg->size = 0;
}
}
for (i = 0; i < hdr->n_segments && page_zero_size > 0; i++) {
if (i == page_zero_idx) {
continue;
}
RCoreSymCacheElementSegment *seg = &result->segments[i];
if (seg->vaddr < page_zero_size) {
seg->vaddr += page_zero_size;
}
}
}
bool relative_to_strings = false;
ut8* string_origin;
if (hdr->n_sections > 0) {
result->sections = R_NEWS0 (RCoreSymCacheElementSection, hdr->n_sections);
if (!result->sections) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_sections;
for (i = 0; i < hdr->n_sections && cursor < end; i++) {
ut8 *sect_start = cursor;
RCoreSymCacheElementSection *sect = &result->sections[i];
sect->vaddr = sect->paddr = r_read_ble (cursor, false, bits);
if (sect->vaddr < page_zero_size) {
sect->vaddr += page_zero_size;
}
cursor += word_size;
if (cursor >= end) {
break;
}
sect->size = r_read_ble (cursor, false, bits);
cursor += word_size;
if (cursor >= end) {
break;
}
ut64 sect_name_off = r_read_ble (cursor, false, bits);
if (!i && !sect_name_off) {
relative_to_strings = true;
}
cursor += word_size;
if (bits == 32) {
cursor += word_size;
}
string_origin = relative_to_strings? b + start_of_strings : sect_start;
sect->name = str_dup_safe (b, string_origin + (size_t)sect_name_off, end);
}
}
if (hdr->n_symbols) {
result->symbols = R_NEWS0 (RCoreSymCacheElementSymbol, hdr->n_symbols);
if (!result->symbols) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_symbols;
for (i = 0; i < hdr->n_symbols && cursor + R_CS_EL_SIZE_SYM <= end; i++) {
RCoreSymCacheElementSymbol *sym = &result->symbols[i];
sym->paddr = r_read_le32 (cursor);
sym->size = r_read_le32 (cursor + 0x4);
sym->unk1 = r_read_le32 (cursor + 0x8);
size_t name_off = r_read_le32 (cursor + 0xc);
size_t mangled_name_off = r_read_le32 (cursor + 0x10);
sym->unk2 = (st32)r_read_le32 (cursor + 0x14);
string_origin = relative_to_strings? b + start_of_strings : cursor;
sym->name = str_dup_safe (b, string_origin + name_off, end);
if (!sym->name) {
cursor += R_CS_EL_SIZE_SYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
sym->mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
if (!sym->mangled_name) {
cursor += R_CS_EL_SIZE_SYM;
continue;
}
cursor += R_CS_EL_SIZE_SYM;
}
}
if (hdr->n_lined_symbols) {
result->lined_symbols = R_NEWS0 (RCoreSymCacheElementLinedSymbol, hdr->n_lined_symbols);
if (!result->lined_symbols) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_lined_symbols;
for (i = 0; i < hdr->n_lined_symbols && cursor + R_CS_EL_SIZE_LSYM <= end; i++) {
RCoreSymCacheElementLinedSymbol *lsym = &result->lined_symbols[i];
lsym->sym.paddr = r_read_le32 (cursor);
lsym->sym.size = r_read_le32 (cursor + 0x4);
lsym->sym.unk1 = r_read_le32 (cursor + 0x8);
size_t name_off = r_read_le32 (cursor + 0xc);
size_t mangled_name_off = r_read_le32 (cursor + 0x10);
lsym->sym.unk2 = (st32)r_read_le32 (cursor + 0x14);
size_t file_name_off = r_read_le32 (cursor + 0x18);
lsym->flc.line = r_read_le32 (cursor + 0x1c);
lsym->flc.col = r_read_le32 (cursor + 0x20);
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->sym.name = str_dup_safe (b, string_origin + name_off, end);
if (!lsym->sym.name) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->sym.mangled_name = str_dup_safe (b, string_origin + mangled_name_off, end);
if (!lsym->sym.mangled_name) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
string_origin = relative_to_strings? b + start_of_strings : cursor;
lsym->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
if (!lsym->flc.file) {
cursor += R_CS_EL_SIZE_LSYM;
continue;
}
cursor += R_CS_EL_SIZE_LSYM;
meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, lsym->sym.paddr), lsym->sym.size, &lsym->flc);
}
}
if (hdr->n_line_info) {
result->line_info = R_NEWS0 (RCoreSymCacheElementLineInfo, hdr->n_line_info);
if (!result->line_info) {
goto beach;
}
size_t i;
ut8 *cursor = b + start_of_line_info;
for (i = 0; i < hdr->n_line_info && cursor + R_CS_EL_SIZE_LINFO <= end; i++) {
RCoreSymCacheElementLineInfo *info = &result->line_info[i];
info->paddr = r_read_le32 (cursor);
info->size = r_read_le32 (cursor + 4);
size_t file_name_off = r_read_le32 (cursor + 8);
info->flc.line = r_read_le32 (cursor + 0xc);
info->flc.col = r_read_le32 (cursor + 0x10);
string_origin = relative_to_strings? b + start_of_strings : cursor;
info->flc.file = str_dup_safe (b, string_origin + file_name_off, end);
if (!info->flc.file) {
break;
}
cursor += R_CS_EL_SIZE_LINFO;
meta_add_fileline (bf, r_coresym_cache_element_pa2va (result, info->paddr), info->size, &info->flc);
}
}








beach:
free (b);
return result;
}","[118, 123, 135]","Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.8. The bug causes the program reads data past the end of the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash."
206723," void EmulationHandler::SetRenderer(RenderProcessHost* process_host,
 void EmulationHandler::SetRenderer(int process_host_id,
                                     RenderFrameHostImpl* frame_host) {
    if (host_ == frame_host)
      return;
 
   host_ = frame_host;
   if (touch_emulation_enabled_)
     UpdateTouchEventEmulationState();
   UpdateDeviceEmulationState();
 }",[2],An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
203284," int main( int  , char ** argv)
 {
 
   InitializeMagick(*argv);
 
   int failures=0;
 
   try {
 
     string srcdir("""");
     if(getenv(""SRCDIR"") != 0)
       srcdir = getenv(""SRCDIR"");
 
 
     list<Image> imageList;
     readImages( &imageList, srcdir + ""test_image_anim.miff"" );
 
     Image appended;
 
     appendImages( &appended, imageList.begin(), imageList.end() );
     if (( appended.signature() != ""3a90bb0bb8f69f6788ab99e9e25598a0d6c5cdbbb797f77ad68011e0a8b1689d"" ) &&
         ( appended.signature() != ""c15fcd1e739b73638dc4e36837bdb53f7087359544664caf7b1763928129f3c7"" ) &&
         ( appended.signature() != ""229ff72f812e5f536245dc3b4502a0bc2ab2363f67c545863a85ab91ebfbfb83"" ) &&
         ( appended.signature() != ""b98c42c55fc4e661cb3684154256809c03c0c6b53da2738b6ce8066e1b6ddef0"" ))
       {
 	++failures;
 	cout << ""Line: "" << __LINE__
 	     << ""  Horizontal append failed, signature = ""
 	     << appended.signature() << endl;
 	appended.write(""appendImages_horizontal_out.miff"");
       }
 
      appendImages( &appended, imageList.begin(), imageList.end(), true );
      if (( appended.signature() != ""d73d25ccd6011936d08b6d0d89183b7a61790544c2195269aff4db2f782ffc08"" ) &&
        ( appended.signature() != ""0909f7ffa7c6ea410fb2ebfdbcb19d61b19c4bd271851ce3bd51662519dc2b58"" ) &&
         ( appended.signature() != ""f3590c183018757da798613a23505ab9600b35935988eee12f096cb6219f2bc3"" ) &&
          ( appended.signature() != ""11b97ba6ac1664aa1c2faed4c86195472ae9cce2ed75402d975bb4ffcf1de751"" ) &&
          ( appended.signature() != ""cae4815eeb3cb689e73b94d897a9957d3414d1d4f513e8b5e52579b05d164bfe"" ))
        {
 	++failures;
 	cout << ""Line: "" << __LINE__
 	     << ""  Vertical append failed, signature = ""
 	     << appended.signature() << endl;
 	appended.write(""appendImages_vertical_out.miff"");
       }
     
   }
 
   catch( Exception &error_ )
     {
       cout << ""Caught exception: "" << error_.what() << endl;
       return 1;
     }
   catch( exception &error_ )
     {
       cout << ""Caught exception: "" << error_.what() << endl;
       return 1;
     }
 
   if ( failures )
     {
       cout << failures << "" failures"" << endl;
       return 1;
     }
   
   return 0;
 }","[36, 35]",The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
9850,"void SFS_CompoundExpression(ScriptParser *parser)
{
if (parser->codec->LastError) return;
SFS_Expression(parser);
if (! gf_bs_read_int(parser->bs, 1)) return;
SFS_AddString(parser, "","");
SFS_CompoundExpression(parser);
}",[6],Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.
198957," static void emulate_load_store_insn(struct pt_regs *regs,
 	void __user *addr, unsigned int __user *pc)
 {
 	union mips_instruction insn;
  	unsigned long value;
  	unsigned int res;
  
	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,
		      1, 0, regs, 0);
 	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);
  
  	 
 	__get_user(insn.word, pc);
 
 	switch (insn.i_format.opcode) {
 	 
 	case ll_op:
 	case lld_op:
 	case sc_op:
 	case scd_op:
 
 	 
 	case ldl_op:
 	case ldr_op:
 	case lwl_op:
 	case lwr_op:
 	case sdl_op:
 	case sdr_op:
 	case swl_op:
 	case swr_op:
 	case lb_op:
 	case lbu_op:
 	case sb_op:
 		goto sigbus;
 
 	 
 	case lh_op:
 		if (!access_ok(VERIFY_READ, addr, 2))
 			goto sigbus;
 
 		__asm__ __volatile__ ("".set\tnoat\n""
 #ifdef __BIG_ENDIAN
 			""1:\tlb\t%0, 0(%2)\n""
 			""2:\tlbu\t$1, 1(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tlb\t%0, 1(%2)\n""
 			""2:\tlbu\t$1, 0(%2)\n\t""
 #endif
 			""sll\t%0, 0x8\n\t""
 			""or\t%0, $1\n\t""
 			""li\t%1, 0\n""
 			""3:\t.set\tat\n\t""
 			"".section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%1, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=&r"" (value), ""=r"" (res)
 			: ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		regs->regs[insn.i_format.rt] = value;
 		break;
 
 	case lw_op:
 		if (!access_ok(VERIFY_READ, addr, 4))
 			goto sigbus;
 
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			""1:\tlwl\t%0, (%2)\n""
 			""2:\tlwr\t%0, 3(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tlwl\t%0, 3(%2)\n""
 			""2:\tlwr\t%0, (%2)\n\t""
 #endif
 			""li\t%1, 0\n""
 			""3:\t.section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%1, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=&r"" (value), ""=r"" (res)
 			: ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		regs->regs[insn.i_format.rt] = value;
 		break;
 
 	case lhu_op:
 		if (!access_ok(VERIFY_READ, addr, 2))
 			goto sigbus;
 
 		__asm__ __volatile__ (
 			"".set\tnoat\n""
 #ifdef __BIG_ENDIAN
 			""1:\tlbu\t%0, 0(%2)\n""
 			""2:\tlbu\t$1, 1(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tlbu\t%0, 1(%2)\n""
 			""2:\tlbu\t$1, 0(%2)\n\t""
 #endif
 			""sll\t%0, 0x8\n\t""
 			""or\t%0, $1\n\t""
 			""li\t%1, 0\n""
 			""3:\t.set\tat\n\t""
 			"".section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%1, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=&r"" (value), ""=r"" (res)
 			: ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		regs->regs[insn.i_format.rt] = value;
 		break;
 
 	case lwu_op:
 #ifdef CONFIG_64BIT
 		 
 		if (!access_ok(VERIFY_READ, addr, 4))
 			goto sigbus;
 
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			""1:\tlwl\t%0, (%2)\n""
 			""2:\tlwr\t%0, 3(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tlwl\t%0, 3(%2)\n""
 			""2:\tlwr\t%0, (%2)\n\t""
 #endif
 			""dsll\t%0, %0, 32\n\t""
 			""dsrl\t%0, %0, 32\n\t""
 			""li\t%1, 0\n""
 			""3:\t.section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%1, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=&r"" (value), ""=r"" (res)
 			: ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		regs->regs[insn.i_format.rt] = value;
 		break;
 #endif  
 
 		 
 		goto sigill;
 
 	case ld_op:
 #ifdef CONFIG_64BIT
 		 
 		if (!access_ok(VERIFY_READ, addr, 8))
 			goto sigbus;
 
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			""1:\tldl\t%0, (%2)\n""
 			""2:\tldr\t%0, 7(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tldl\t%0, 7(%2)\n""
 			""2:\tldr\t%0, (%2)\n\t""
 #endif
 			""li\t%1, 0\n""
 			""3:\t.section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%1, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=&r"" (value), ""=r"" (res)
 			: ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		regs->regs[insn.i_format.rt] = value;
 		break;
 #endif  
 
 		 
 		goto sigill;
 
 	case sh_op:
 		if (!access_ok(VERIFY_WRITE, addr, 2))
 			goto sigbus;
 
 		value = regs->regs[insn.i_format.rt];
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			"".set\tnoat\n""
 			""1:\tsb\t%1, 1(%2)\n\t""
 			""srl\t$1, %1, 0x8\n""
 			""2:\tsb\t$1, 0(%2)\n\t""
 			"".set\tat\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			"".set\tnoat\n""
 			""1:\tsb\t%1, 0(%2)\n\t""
 			""srl\t$1,%1, 0x8\n""
 			""2:\tsb\t$1, 1(%2)\n\t""
 			"".set\tat\n\t""
 #endif
 			""li\t%0, 0\n""
 			""3:\n\t""
 			"".section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%0, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 			: ""=r"" (res)
 			: ""r"" (value), ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		break;
 
 	case sw_op:
 		if (!access_ok(VERIFY_WRITE, addr, 4))
 			goto sigbus;
 
 		value = regs->regs[insn.i_format.rt];
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			""1:\tswl\t%1,(%2)\n""
 			""2:\tswr\t%1, 3(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tswl\t%1, 3(%2)\n""
 			""2:\tswr\t%1, (%2)\n\t""
 #endif
 			""li\t%0, 0\n""
 			""3:\n\t""
 			"".section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%0, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 		: ""=r"" (res)
 		: ""r"" (value), ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		break;
 
 	case sd_op:
 #ifdef CONFIG_64BIT
 		 
 		if (!access_ok(VERIFY_WRITE, addr, 8))
 			goto sigbus;
 
 		value = regs->regs[insn.i_format.rt];
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
 			""1:\tsdl\t%1,(%2)\n""
 			""2:\tsdr\t%1, 7(%2)\n\t""
 #endif
 #ifdef __LITTLE_ENDIAN
 			""1:\tsdl\t%1, 7(%2)\n""
 			""2:\tsdr\t%1, (%2)\n\t""
 #endif
 			""li\t%0, 0\n""
 			""3:\n\t""
 			"".section\t.fixup,\""ax\""\n\t""
 			""4:\tli\t%0, %3\n\t""
 			""j\t3b\n\t""
 			"".previous\n\t""
 			"".section\t__ex_table,\""a\""\n\t""
 			STR(PTR)""\t1b, 4b\n\t""
 			STR(PTR)""\t2b, 4b\n\t""
 			"".previous""
 		: ""=r"" (res)
 		: ""r"" (value), ""r"" (addr), ""i"" (-EFAULT));
 		if (res)
 			goto fault;
 		compute_return_epc(regs);
 		break;
 #endif  
 
 		 
 		goto sigill;
 
 	case lwc1_op:
 	case ldc1_op:
 	case swc1_op:
 	case sdc1_op:
 		 
 		goto sigbus;
 
 	 
 	case lwc2_op:
 		cu2_notifier_call_chain(CU2_LWC2_OP, regs);
 		break;
 
 	case ldc2_op:
 		cu2_notifier_call_chain(CU2_LDC2_OP, regs);
 		break;
 
 	case swc2_op:
 		cu2_notifier_call_chain(CU2_SWC2_OP, regs);
 		break;
 
 	case sdc2_op:
 		cu2_notifier_call_chain(CU2_SDC2_OP, regs);
 		break;
 
 	default:
 		 
 		goto sigill;
 	}
 
 #ifdef CONFIG_DEBUG_FS
 	unaligned_instructions++;
 #endif
 
 	return;
 
 fault:
 	 
 	if (fixup_exception(regs))
 		return;
 
 	die_if_kernel(""Unhandled kernel unaligned access"", regs);
 	force_sig(SIGSEGV, current);
 
 	return;
 
 sigbus:
 	die_if_kernel(""Unhandled kernel unaligned access"", regs);
 	force_sig(SIGBUS, current);
 
 	return;
 
 sigill:
 	die_if_kernel(""Unhandled kernel unaligned access or invalid instruction"", regs);
 	force_sig(SIGILL, current);
 }","[10, 8, 9]","The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application."
206140," png_do_read_interlace(png_structp png_ptr)
 {
    png_row_infop row_info = &(png_ptr->row_info);
    png_bytep row = png_ptr->row_buf + 1;
    int pass = png_ptr->pass;
     png_uint_32 transformations = png_ptr->transformations;
      
      
 #ifndef PNG_USE_GLOBAL_ARRAYS
     PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 #endif
  
     png_debug(1, ""in png_do_read_interlace"");
     if (row != NULL && row_info != NULL)
    {
       png_uint_32 final_width;
 
       final_width = row_info->width * png_pass_inc[pass];
 
       switch (row_info->pixel_depth)
       {
          case 1:
          {
             png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
             png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
             int sshift, dshift;
             int s_start, s_end, s_inc;
             int jstop = png_pass_inc[pass];
             png_byte v;
             png_uint_32 i;
             int j;
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                 sshift = (int)((row_info->width + 7) & 0x07);
                 dshift = (int)((final_width + 7) & 0x07);
                 s_start = 7;
                 s_end = 0;
                 s_inc = -1;
             }
             else
 #endif
             {
                 sshift = 7 - (int)((row_info->width + 7) & 0x07);
                 dshift = 7 - (int)((final_width + 7) & 0x07);
                 s_start = 0;
                 s_end = 7;
                 s_inc = 1;
             }
 
             for (i = 0; i < row_info->width; i++)
             {
                v = (png_byte)((*sp >> sshift) & 0x01);
                for (j = 0; j < jstop; j++)
                {
                   *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                   *dp |= (png_byte)(v << dshift);
                   if (dshift == s_end)
                   {
                      dshift = s_start;
                      dp--;
                   }
                   else
                      dshift += s_inc;
                }
                if (sshift == s_end)
                {
                   sshift = s_start;
                   sp--;
                }
                else
                   sshift += s_inc;
             }
             break;
          }
          case 2:
          {
             png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
             png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
             int sshift, dshift;
             int s_start, s_end, s_inc;
             int jstop = png_pass_inc[pass];
             png_uint_32 i;
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                sshift = (int)(((row_info->width + 3) & 0x03) << 1);
                dshift = (int)(((final_width + 3) & 0x03) << 1);
                s_start = 6;
                s_end = 0;
                s_inc = -2;
             }
             else
 #endif
             {
                sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
                dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
                s_start = 0;
                s_end = 6;
                s_inc = 2;
             }
 
             for (i = 0; i < row_info->width; i++)
             {
                png_byte v;
                int j;
 
                v = (png_byte)((*sp >> sshift) & 0x03);
                for (j = 0; j < jstop; j++)
                {
                   *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                   *dp |= (png_byte)(v << dshift);
                   if (dshift == s_end)
                   {
                      dshift = s_start;
                      dp--;
                   }
                   else
                      dshift += s_inc;
                }
                if (sshift == s_end)
                {
                   sshift = s_start;
                   sp--;
                }
                else
                   sshift += s_inc;
             }
             break;
          }
          case 4:
          {
             png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
             png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
             int sshift, dshift;
             int s_start, s_end, s_inc;
             png_uint_32 i;
             int jstop = png_pass_inc[pass];
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if (transformations & PNG_PACKSWAP)
             {
                sshift = (int)(((row_info->width + 1) & 0x01) << 2);
                dshift = (int)(((final_width + 1) & 0x01) << 2);
                s_start = 4;
                s_end = 0;
                s_inc = -4;
             }
             else
 #endif
             {
                sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
                dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
                s_start = 0;
                s_end = 4;
                s_inc = 4;
             }
 
             for (i = 0; i < row_info->width; i++)
             {
                png_byte v = (png_byte)((*sp >> sshift) & 0xf);
                int j;
 
                for (j = 0; j < jstop; j++)
                {
                   *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                   *dp |= (png_byte)(v << dshift);
                   if (dshift == s_end)
                   {
                      dshift = s_start;
                      dp--;
                   }
                   else
                      dshift += s_inc;
                }
                if (sshift == s_end)
                {
                   sshift = s_start;
                   sp--;
                }
                else
                   sshift += s_inc;
             }
             break;
          }
          default:
          {
             png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
             png_bytep sp = row + (png_size_t)(row_info->width - 1)
                 * pixel_bytes;
             png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
 
             int jstop = png_pass_inc[pass];
             png_uint_32 i;
 
             for (i = 0; i < row_info->width; i++)
             {
                png_byte v[8];
                int j;
 
                png_memcpy(v, sp, pixel_bytes);
                for (j = 0; j < jstop; j++)
                {
                   png_memcpy(dp, v, pixel_bytes);
                   dp -= pixel_bytes;
                }
                sp -= pixel_bytes;
             }
             break;
          }
       }
       row_info->width = final_width;
       row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
    }
 #ifndef PNG_READ_PACKSWAP_SUPPORTED
    PNG_UNUSED(transformations)  
 #endif
 }","[9, 11]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
207404," static vpx_codec_err_t vp8_decode(vpx_codec_alg_priv_t *ctx,
  const uint8_t *data,
  unsigned int            data_sz,
  void *user_priv,
  long                    deadline)
 {
  vpx_codec_err_t res = VPX_CODEC_OK;
  unsigned int resolution_change = 0;
  unsigned int w, h;
 
  if (!ctx->fragments.enabled && (data == NULL && data_sz == 0))
  {
  return 0;
  }
 
   
  if(update_fragments(ctx, data, data_sz, &res) <= 0)
  return res;
 
   
     w = ctx->si.w;
     h = ctx->si.h;
 
     res = vp8_peek_si_internal(ctx->fragments.ptrs[0], ctx->fragments.sizes[0],
  &ctx->si, ctx->decrypt_cb, ctx->decrypt_state);
 
  if((res == VPX_CODEC_UNSUP_BITSTREAM) && !ctx->si.is_kf)
  {
   
         res = VPX_CODEC_OK;
  }
 
  if(!ctx->decoder_init && !ctx->si.is_kf)
         res = VPX_CODEC_UNSUP_BITSTREAM;
 
  if ((ctx->si.h != h) || (ctx->si.w != w))
         resolution_change = 1;
 
   
  if (!res && !ctx->decoder_init)
  {
       VP8D_CONFIG oxcf;
 
       oxcf.Width = ctx->si.w;
       oxcf.Height = ctx->si.h;
       oxcf.Version = 9;
       oxcf.postprocess = 0;
       oxcf.max_threads = ctx->cfg.threads;
       oxcf.error_concealment =
  (ctx->base.init_flags & VPX_CODEC_USE_ERROR_CONCEALMENT);
 
   
  if (!ctx->postproc_cfg_set
  && (ctx->base.init_flags & VPX_CODEC_USE_POSTPROC)) {
          ctx->postproc_cfg.post_proc_flag =
              VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE;
          ctx->postproc_cfg.deblocking_level = 4;
          ctx->postproc_cfg.noise_level = 0;
  }
 
        res = vp8_create_decoder_instances(&ctx->yv12_frame_buffers, &oxcf);
        ctx->decoder_init = 1;
  }
 
   
  if (ctx->decoder_init) {
       ctx->yv12_frame_buffers.pbi[0]->decrypt_cb = ctx->decrypt_cb;
       ctx->yv12_frame_buffers.pbi[0]->decrypt_state = ctx->decrypt_state;
  }
 
  if (!res)
  {
         VP8D_COMP *pbi = ctx->yv12_frame_buffers.pbi[0];
  if (resolution_change)
  {
             VP8_COMMON *const pc = & pbi->common;
             MACROBLOCKD *const xd  = & pbi->mb;
 #if CONFIG_MULTITHREAD
  int i;
 #endif
             pc->Width = ctx->si.w;
             pc->Height = ctx->si.h;
  {
  int prev_mb_rows = pc->mb_rows;
 
 
                  if (setjmp(pbi->common.error.jmp))
                  {
                      pbi->common.error.setjmp = 0;
                      
                     ctx->si.w = 0;
                     ctx->si.h = 0;
                      vp8_clear_system_state();
                       
                      return -1;
  }
 
                 pbi->common.error.setjmp = 1;
 
  if (pc->Width <= 0)
  {
                     pc->Width = w;
                     vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,
  ""Invalid frame width"");
  }
 
  if (pc->Height <= 0)
  {
                     pc->Height = h;
                     vpx_internal_error(&pc->error, VPX_CODEC_CORRUPT_FRAME,
  ""Invalid frame height"");
  }
 
  if (vp8_alloc_frame_buffers(pc, pc->Width, pc->Height))
                     vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,
  ""Failed to allocate frame buffers"");
 
                 xd->pre = pc->yv12_fb[pc->lst_fb_idx];
                 xd->dst = pc->yv12_fb[pc->new_fb_idx];
 
 #if CONFIG_MULTITHREAD
  for (i = 0; i < pbi->allocated_decoding_thread_count; i++)
  {
                     pbi->mb_row_di[i].mbd.dst = pc->yv12_fb[pc->new_fb_idx];
                     vp8_build_block_doffsets(&pbi->mb_row_di[i].mbd);
  }
 #endif
                 vp8_build_block_doffsets(&pbi->mb);
 
   
 #if CONFIG_ERROR_CONCEALMENT
 
  if (pbi->ec_enabled)
  {
   
                     pc->prev_mip = vpx_calloc(
  (pc->mb_cols + 1) * (pc->mb_rows + 1),
  sizeof(MODE_INFO));
 
  if (!pc->prev_mip)
  {
                         vp8_de_alloc_frame_buffers(pc);
                         vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,
  ""Failed to allocate""
  ""last frame MODE_INFO array"");
  }
 
                     pc->prev_mi = pc->prev_mip + pc->mode_info_stride + 1;
 
  if (vp8_alloc_overlap_lists(pbi))
                         vpx_internal_error(&pc->error, VPX_CODEC_MEM_ERROR,
  ""Failed to allocate overlap lists ""
  ""for error concealment"");
  }
 
 #endif
 
 #if CONFIG_MULTITHREAD
  if (pbi->b_multithreaded_rd)
                     vp8mt_alloc_temp_buffers(pbi, pc->Width, prev_mb_rows);
 #else
  (void)prev_mb_rows;
 #endif
  }
 
             pbi->common.error.setjmp = 0;
 
   
             pbi->common.fb_idx_ref_cnt[0] = 0;
  }
 
   
         pbi->fragments = ctx->fragments;
 
         ctx->user_priv = user_priv;
  if (vp8dx_receive_compressed_data(pbi, data_sz, data, deadline))
  {
             res = update_error_state(ctx, &pbi->common.error);
  }
 
   
         ctx->fragments.count = 0;
  }
 
  return res;
 }","[90, 91, 92]","A remote denial of service vulnerability in libvpx in Mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-11-01 could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Android ID: A-30593765."
8707,"void pjmedia_rtcp_xr_rx_rtcp_xr( pjmedia_rtcp_xr_session *sess,
const void *pkt,
pj_size_t size)
{
const pjmedia_rtcp_xr_pkt       *rtcp_xr = (pjmedia_rtcp_xr_pkt*) pkt;
const pjmedia_rtcp_xr_rb_rr_time  *rb_rr_time = NULL;
const pjmedia_rtcp_xr_rb_dlrr     *rb_dlrr = NULL;
const pjmedia_rtcp_xr_rb_stats    *rb_stats = NULL;
const pjmedia_rtcp_xr_rb_voip_mtc *rb_voip_mtc = NULL;
const pjmedia_rtcp_xr_rb_header   *rb_hdr = (pjmedia_rtcp_xr_rb_header*)
rtcp_xr->buf;
unsigned pkt_len, rb_len;

if (rtcp_xr->common.pt != RTCP_XR)
return;

pkt_len = pj_ntohs((pj_uint16_t)rtcp_xr->common.length);

if ((pkt_len + 1) > (size / 4))
return;


while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)
{
rb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);


if (rb_len) {
switch (rb_hdr->bt) {
case BT_RR_TIME:
rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;
break;
case BT_DLRR:
rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;
break;
case BT_STATS:
rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;
break;
case BT_VOIP_METRICS:
rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;
break;
default:
break;
}
}
rb_hdr = (pjmedia_rtcp_xr_rb_header*)
((pj_int32_t*)rb_hdr + rb_len + 1);
}


if (rb_rr_time) {

sess->rx_lrr = ((pj_ntohl(rb_rr_time->ntp_sec) & 0x0000FFFF) << 16) |
((pj_ntohl(rb_rr_time->ntp_frac) >> 16) & 0xFFFF);


pj_get_timestamp(&sess->rx_lrr_time);

TRACE_((sess->name, ""Rx RTCP SR: ntp_ts=%p"", sess->rx_lrr,
(pj_uint32_t)(sess->rx_lrr_time.u64*65536/
sess->rtcp_session->ts_freq.u64)));
}


if (rb_dlrr) {
pj_uint32_t lrr, now, dlrr;
pj_uint64_t eedelay;
pjmedia_rtcp_ntp_rec ntp;




lrr = pj_ntohl(rb_dlrr->item.lrr);


dlrr = pj_ntohl(rb_dlrr->item.dlrr);


pjmedia_rtcp_get_ntp_time(sess->rtcp_session, &ntp);
now = ((ntp.hi & 0xFFFF) << 16) + (ntp.lo >> 16);


eedelay = now - lrr - dlrr;





if (eedelay < 4294) {
eedelay = (eedelay * 1000000) >> 16;
} else {
eedelay = (eedelay * 1000) >> 16;
eedelay *= 1000;
}

TRACE_((sess->name, ""Rx RTCP XR DLRR: lrr=%p, dlrr=%p (%d:%03dms), ""
""now=%p, rtt=%p"",
lrr, dlrr, dlrr/65536, (dlrr%65536)*1000/65536,
now, (pj_uint32_t)eedelay));




if (now-dlrr >= lrr) {
unsigned rtt = (pj_uint32_t)eedelay;




if (eedelay <= 30 * 1000 * 1000UL) {




if (rtt>((unsigned)sess->stat.rtt.mean*3) && sess->stat.rtt.n!=0)
{
unsigned orig_rtt = rtt;
rtt = (unsigned)sess->stat.rtt.mean*3;
PJ_LOG(5,(sess->name,
""RTT value %d usec is normalized to %d usec"",
orig_rtt, rtt));
}

TRACE_((sess->name, ""RTCP RTT is set to %d usec"", rtt));
pj_math_stat_update(&sess->stat.rtt, rtt);
}
} else {
PJ_LOG(5, (sess->name, ""Internal RTCP NTP clock skew detected: ""
""lrr=%p, now=%p, dlrr=%p (%d:%03dms), ""
""diff=%d"",
lrr, now, dlrr, dlrr/65536,
(dlrr%65536)*1000/65536,
dlrr-(now-lrr)));
}
}


if (rb_stats) {
pj_uint8_t flags = rb_stats->header.specific;

pj_bzero(&sess->stat.tx.stat_sum, sizeof(sess->stat.tx.stat_sum));


sess->stat.tx.stat_sum.begin_seq = pj_ntohs(rb_stats->begin_seq);
sess->stat.tx.stat_sum.end_seq   = pj_ntohs(rb_stats->end_seq);


sess->stat.tx.stat_sum.l = (flags & (1 << 7)) != 0;
sess->stat.tx.stat_sum.d = (flags & (1 << 6)) != 0;
sess->stat.tx.stat_sum.j = (flags & (1 << 5)) != 0;
sess->stat.tx.stat_sum.t = (flags & (3 << 3)) != 0;


if (sess->stat.tx.stat_sum.l) {
sess->stat.tx.stat_sum.lost = pj_ntohl(rb_stats->lost);
}

if (sess->stat.tx.stat_sum.d) {
sess->stat.tx.stat_sum.dup = pj_ntohl(rb_stats->dup);
}

if (sess->stat.tx.stat_sum.j) {
sess->stat.tx.stat_sum.jitter.min = pj_ntohl(rb_stats->jitter_min);
sess->stat.tx.stat_sum.jitter.max = pj_ntohl(rb_stats->jitter_max);
sess->stat.tx.stat_sum.jitter.mean= pj_ntohl(rb_stats->jitter_mean);
pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.jitter,
pj_ntohl(rb_stats->jitter_dev));
}

if (sess->stat.tx.stat_sum.t) {
sess->stat.tx.stat_sum.toh.min = rb_stats->toh_min;
sess->stat.tx.stat_sum.toh.max = rb_stats->toh_max;
sess->stat.tx.stat_sum.toh.mean= rb_stats->toh_mean;
pj_math_stat_set_stddev(&sess->stat.tx.stat_sum.toh,
pj_ntohl(rb_stats->toh_dev));
}

pj_gettimeofday(&sess->stat.tx.stat_sum.update);
}


if (rb_voip_mtc) {
sess->stat.tx.voip_mtc.loss_rate = rb_voip_mtc->loss_rate;
sess->stat.tx.voip_mtc.discard_rate = rb_voip_mtc->discard_rate;
sess->stat.tx.voip_mtc.burst_den = rb_voip_mtc->burst_den;
sess->stat.tx.voip_mtc.gap_den = rb_voip_mtc->gap_den;
sess->stat.tx.voip_mtc.burst_dur = pj_ntohs(rb_voip_mtc->burst_dur);
sess->stat.tx.voip_mtc.gap_dur = pj_ntohs(rb_voip_mtc->gap_dur);
sess->stat.tx.voip_mtc.rnd_trip_delay =
pj_ntohs(rb_voip_mtc->rnd_trip_delay);
sess->stat.tx.voip_mtc.end_sys_delay =
pj_ntohs(rb_voip_mtc->end_sys_delay);

sess->stat.tx.voip_mtc.signal_lvl = (pj_int8_t)
((rb_voip_mtc->signal_lvl > 127)?
((int)rb_voip_mtc->signal_lvl - 256) :
rb_voip_mtc->signal_lvl);
sess->stat.tx.voip_mtc.noise_lvl  = (pj_int8_t)
((rb_voip_mtc->noise_lvl > 127)?
((int)rb_voip_mtc->noise_lvl - 256) :
rb_voip_mtc->noise_lvl);
sess->stat.tx.voip_mtc.rerl = rb_voip_mtc->rerl;
sess->stat.tx.voip_mtc.gmin = rb_voip_mtc->gmin;
sess->stat.tx.voip_mtc.r_factor = rb_voip_mtc->r_factor;
sess->stat.tx.voip_mtc.ext_r_factor = rb_voip_mtc->ext_r_factor;
sess->stat.tx.voip_mtc.mos_lq = rb_voip_mtc->mos_lq;
sess->stat.tx.voip_mtc.mos_cq = rb_voip_mtc->mos_cq;
sess->stat.tx.voip_mtc.rx_config = rb_voip_mtc->rx_config;
sess->stat.tx.voip_mtc.jb_nom = pj_ntohs(rb_voip_mtc->jb_nom);
sess->stat.tx.voip_mtc.jb_max = pj_ntohs(rb_voip_mtc->jb_max);
sess->stat.tx.voip_mtc.jb_abs_max = pj_ntohs(rb_voip_mtc->jb_abs_max);

pj_gettimeofday(&sess->stat.tx.voip_mtc.update);
}
}","[31, 34, 37, 40]","PJSIP is a free and open source multimedia communication library. In version 2.11.1 and prior, if incoming RTCP XR message contain block, the data field is not checked against the received packet size, potentially resulting in an out-of-bound read access. This affects all users that use PJMEDIA and RTCP XR. A malicious actor can send a RTCP XR message with an invalid packet size."
8913,"R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {
RBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);
if (!se) {
return NULL;
}
se->tag = type;
if (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {
se->info.obj_val_cp_idx = (ut16) value;
} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {





se->info.uninit_offset = (ut16) value;
}
return se;
}","[3, 4, 6, 7, 8, 9, 15]",Buffer Access with Incorrect Length Value in GitHub repository radareorg/radare2 prior to 5.6.2.
8145,"static Image *ReadTIFFImage(const ImageInfo *image_info,
ExceptionInfo *exception)
{
#define MaxPixelChannels  32
#define ThrowTIFFException(severity,message) \
{ \
  if (pixel_info != (MemoryInfo *) NULL) \
    pixel_info=RelinquishVirtualMemory(pixel_info); \
  if (quantum_info != (QuantumInfo *) NULL) \
    quantum_info=DestroyQuantumInfo(quantum_info); \
  TIFFClose(tiff); \
  ThrowReaderException(severity,message); \
}

const char
*option;

float
*chromaticity,
x_position,
y_position,
x_resolution,
y_resolution;

Image
*image;

int
tiff_status;

MagickBooleanType
more_frames;

MagickStatusType
status;

MemoryInfo
*pixel_info = (MemoryInfo *) NULL;

QuantumInfo
*quantum_info;

QuantumType
quantum_type;

ssize_t
i;

size_t
number_pixels;

ssize_t
y;

TIFF
*tiff;

TIFFMethodType
method;

uint16
compress_tag,
bits_per_sample,
endian,
extra_samples,
interlace,
max_sample_value,
min_sample_value,
orientation,
pages,
photometric,
*sample_info,
sample_format,
samples_per_pixel,
units,
value;

uint32
height,
rows_per_strip,
width;

unsigned char
*pixels;

void
*sans[4] = { NULL, NULL, NULL, NULL };




assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickCoreSignature);
if (image_info->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
image_info->filename);
assert(exception != (ExceptionInfo *) NULL);
assert(exception->signature == MagickCoreSignature);
image=AcquireImage(image_info);
status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
if (status == MagickFalse)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
(void) SetMagickThreadValue(tiff_exception,exception);
tiff=TIFFClientOpen(image->filename,""rb"",(thandle_t) image,TIFFReadBlob,
TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,
TIFFUnmapBlob);
if (tiff == (TIFF *) NULL)
{
image=DestroyImageList(image);
return((Image *) NULL);
}
if (exception->severity > ErrorException)
{
TIFFClose(tiff);
image=DestroyImageList(image);
return((Image *) NULL);
}
if (image_info->number_scenes != 0)
{





if (image_info->scene < (size_t)TIFFNumberOfDirectories(tiff))
{
for (i=0; i < (ssize_t) image_info->scene; i++)
{
status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
if (status == MagickFalse)
{
TIFFClose(tiff);
image=DestroyImageList(image);
return((Image *) NULL);
}
AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
TIFFClose(tiff);
image=DestroyImageList(image);
return((Image *) NULL);
}
image=SyncNextImageInList(image);
}
}
}
more_frames=MagickTrue;
do
{

photometric=PHOTOMETRIC_RGB;
if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||
(TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||
(TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))
{
TIFFClose(tiff);
ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
}
if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&
((bits_per_sample <= 0) || (bits_per_sample > 32)))
{
TIFFClose(tiff);
ThrowReaderException(CorruptImageError,""UnsupportedBitsPerPixel"");
}
if (sample_format == SAMPLEFORMAT_IEEEFP)
(void) SetImageProperty(image,""quantum:format"",""floating-point"");
switch (photometric)
{
case PHOTOMETRIC_MINISBLACK:
{
(void) SetImageProperty(image,""tiff:photometric"",""min-is-black"");
break;
}
case PHOTOMETRIC_MINISWHITE:
{
(void) SetImageProperty(image,""tiff:photometric"",""min-is-white"");
break;
}
case PHOTOMETRIC_PALETTE:
{
(void) SetImageProperty(image,""tiff:photometric"",""palette"");
break;
}
case PHOTOMETRIC_RGB:
{
(void) SetImageProperty(image,""tiff:photometric"",""RGB"");
break;
}
case PHOTOMETRIC_CIELAB:
{
(void) SetImageProperty(image,""tiff:photometric"",""CIELAB"");
break;
}
case PHOTOMETRIC_LOGL:
{
(void) SetImageProperty(image,""tiff:photometric"",""CIE Log2(L)"");
break;
}
case PHOTOMETRIC_LOGLUV:
{
(void) SetImageProperty(image,""tiff:photometric"",""LOGLUV"");
break;
}
#if defined(PHOTOMETRIC_MASK)
case PHOTOMETRIC_MASK:
{
(void) SetImageProperty(image,""tiff:photometric"",""MASK"");
break;
}
#endif
case PHOTOMETRIC_SEPARATED:
{
(void) SetImageProperty(image,""tiff:photometric"",""separated"");
break;
}
case PHOTOMETRIC_YCBCR:
{
(void) SetImageProperty(image,""tiff:photometric"",""YCBCR"");
break;
}
default:
{
(void) SetImageProperty(image,""tiff:photometric"",""unknown"");
break;
}
}
if (image->debug != MagickFalse)
{
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Geometry: %ux%u"",
(unsigned int) width,(unsigned int) height);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Interlace: %u"",
interlace);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Bits per sample: %u"",bits_per_sample);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Min sample value: %u"",min_sample_value);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Max sample value: %u"",max_sample_value);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Photometric ""
""interpretation: %s"",GetImageProperty(image,""tiff:photometric""));
}
image->columns=(size_t) width;
image->rows=(size_t) height;
image->depth=(size_t) bits_per_sample;
if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),""Image depth: %.20g"",
(double) image->depth);
image->endian=MSBEndian;
if (endian == FILLORDER_LSB2MSB)
image->endian=LSBEndian;
#if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
if (TIFFIsBigEndian(tiff) == 0)
{
(void) SetImageProperty(image,""tiff:endian"",""lsb"");
image->endian=LSBEndian;
}
else
{
(void) SetImageProperty(image,""tiff:endian"",""msb"");
image->endian=MSBEndian;
}
#endif
if ((photometric == PHOTOMETRIC_MINISBLACK) ||
(photometric == PHOTOMETRIC_MINISWHITE))
image->colorspace=GRAYColorspace;
if (photometric == PHOTOMETRIC_SEPARATED)
image->colorspace=CMYKColorspace;
if (photometric == PHOTOMETRIC_CIELAB)
image->colorspace=LabColorspace;
if ((photometric == PHOTOMETRIC_YCBCR) && (compress_tag != COMPRESSION_JPEG))
image->colorspace=YCbCrColorspace;
status=TIFFGetProfiles(tiff,image);
if (status == MagickFalse)
{
TIFFClose(tiff);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
status=TIFFGetProperties(tiff,image);
if (status == MagickFalse)
{
TIFFClose(tiff);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
option=GetImageOption(image_info,""tiff:exif-properties"");
if ((option == (const char *) NULL) ||
(IsMagickTrue(option) != MagickFalse))
(void) TIFFGetEXIFProperties(tiff,image);
option=GetImageOption(image_info,""tiff:gps-properties"");
if ((option == (const char *) NULL) ||
(IsMagickTrue(option) != MagickFalse))
(void) TIFFGetGPSProperties(tiff,image);
if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&
(TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))
{
image->x_resolution=x_resolution;
image->y_resolution=y_resolution;
}
if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans,sans) == 1)
{
if (units == RESUNIT_INCH)
image->units=PixelsPerInchResolution;
if (units == RESUNIT_CENTIMETER)
image->units=PixelsPerCentimeterResolution;
}
if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&
(TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))
{
image->page.x=CastDoubleToLong(ceil(x_position*
image->x_resolution-0.5));
image->page.y=CastDoubleToLong(ceil(y_position*
image->y_resolution-0.5));
}
if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)
image->orientation=(OrientationType) orientation;
if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)
{
if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))
{
image->chromaticity.white_point.x=chromaticity[0];
image->chromaticity.white_point.y=chromaticity[1];
}
}
if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)
{
if ((chromaticity != (float *) NULL) && (*chromaticity != 0.0))
{
image->chromaticity.red_primary.x=chromaticity[0];
image->chromaticity.red_primary.y=chromaticity[1];
image->chromaticity.green_primary.x=chromaticity[2];
image->chromaticity.green_primary.y=chromaticity[3];
image->chromaticity.blue_primary.x=chromaticity[4];
image->chromaticity.blue_primary.y=chromaticity[5];
}
}
#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
if ((compress_tag != COMPRESSION_NONE) &&
(TIFFIsCODECConfigured(compress_tag) == 0))
{
TIFFClose(tiff);
ThrowReaderException(CoderError,""CompressNotSupported"");
}
#endif
switch (compress_tag)
{
case COMPRESSION_NONE: image->compression=NoCompression; break;
case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;
case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;
case COMPRESSION_JPEG:
{
image->compression=JPEGCompression;
#if defined(JPEG_SUPPORT)
{
char
sampling_factor[MaxTextExtent];

int
tiff_status;

uint16
horizontal,
vertical;

tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,
&vertical);
if (tiff_status == 1)
{
(void) FormatLocaleString(sampling_factor,MaxTextExtent,""%dx%d"",
horizontal,vertical);
(void) SetImageProperty(image,""jpeg:sampling-factor"",
sampling_factor);
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""Sampling Factors: %s"",sampling_factor);
}
}
#endif
break;
}
case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;
#if defined(COMPRESSION_LZMA)
case COMPRESSION_LZMA: image->compression=LZMACompression; break;
#endif
case COMPRESSION_LZW: image->compression=LZWCompression; break;
case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;
case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
#if defined(COMPRESSION_WEBP)
case COMPRESSION_WEBP: image->compression=WebPCompression; break;
#endif
#if defined(COMPRESSION_ZSTD)
case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;
#endif
default: image->compression=RLECompression; break;
}
quantum_info=(QuantumInfo *) NULL;
if ((photometric == PHOTOMETRIC_PALETTE) &&
(pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
{
size_t
colors;

colors=(size_t) GetQuantumRange(bits_per_sample)+1;
if (AcquireImageColormap(image,colors) == MagickFalse)
{
TIFFClose(tiff);
ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
}
}
if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)
image->scene=value;
if (image->storage_class == PseudoClass)
{
int
tiff_status;

size_t
range;

uint16
*blue_colormap,
*green_colormap,
*red_colormap;




tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,
&green_colormap,&blue_colormap);
if (tiff_status == 1)
{
if ((red_colormap != (uint16 *) NULL) &&
(green_colormap != (uint16 *) NULL) &&
(blue_colormap != (uint16 *) NULL))
{
range=255;
for (i=0; i < (ssize_t) image->colors; i++)
if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||
(blue_colormap[i] >= 256))
{
range=65535;
break;
}
for (i=0; i < (ssize_t) image->colors; i++)
{
image->colormap[i].red=ClampToQuantum(((double)
QuantumRange*red_colormap[i])/range);
image->colormap[i].green=ClampToQuantum(((double)
QuantumRange*green_colormap[i])/range);
image->colormap[i].blue=ClampToQuantum(((double)
QuantumRange*blue_colormap[i])/range);
}
}
}
}
if (image_info->ping != MagickFalse)
{
if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
goto next_tiff_frame;
}
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
{
TIFFClose(tiff);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}
status=SetImageColorspace(image,image->colorspace);
status&=ResetImagePixels(image,exception);
if (status == MagickFalse)
{
TIFFClose(tiff);
InheritException(exception,&image->exception);
return(DestroyImageList(image));
}



quantum_info=AcquireQuantumInfo(image_info,image);
if (quantum_info == (QuantumInfo *) NULL)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
if (sample_format == SAMPLEFORMAT_UINT)
status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
if (sample_format == SAMPLEFORMAT_INT)
status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
if (sample_format == SAMPLEFORMAT_IEEEFP)
status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
if (status == MagickFalse)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
status=MagickTrue;
switch (photometric)
{
case PHOTOMETRIC_MINISBLACK:
{
quantum_info->min_is_white=MagickFalse;
break;
}
case PHOTOMETRIC_MINISWHITE:
{
quantum_info->min_is_white=MagickTrue;
break;
}
default:
break;
}
extra_samples=0;
tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
&sample_info,sans);
if (tiff_status == 1)
{
(void) SetImageProperty(image,""tiff:alpha"",""unspecified"");
if (extra_samples == 0)
{
if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
image->matte=MagickTrue;
}
else
for (i=0; i < extra_samples; i++)
{
image->matte=MagickTrue;
if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
{
SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);
(void) SetImageProperty(image,""tiff:alpha"",""associated"");
}
else
if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
{
SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
(void) SetImageProperty(image,""tiff:alpha"",""unassociated"");
}
}
}
if (image->matte != MagickFalse)
(void) SetImageAlphaChannel(image,OpaqueAlphaChannel);
if (samples_per_pixel > MaxPixelChannels)
{
TIFFClose(tiff);
ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded"");
}
method=ReadGenericMethod;
rows_per_strip=(uint32) image->rows;
if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
{
char
value[MaxTextExtent];

(void) FormatLocaleString(value,MaxTextExtent,""%u"",(unsigned int)
rows_per_strip);
(void) SetImageProperty(image,""tiff:rows-per-strip"",value);
method=ReadStripMethod;
if (rows_per_strip > (uint32) image->rows)
rows_per_strip=(uint32) image->rows;
}
if (TIFFIsTiled(tiff) != MagickFalse)
{
uint32
columns,
rows;

if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
(TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
ThrowTIFFException(CoderError,""ImageIsNotTiled"");
if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
(AcquireMagickResource(HeightResource,rows) == MagickFalse))
ThrowTIFFException(ImageError,""WidthOrHeightExceedsLimit"");
method=ReadTileMethod;
}
if ((photometric == PHOTOMETRIC_LOGLUV) ||
(compress_tag == COMPRESSION_CCITTFAX3))
method=ReadGenericMethod;
if (image->compression == JPEGCompression)
method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
samples_per_pixel);
quantum_info->endian=LSBEndian;
if (TIFFScanlineSize(tiff) <= 0)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
if (((MagickSizeType) TIFFScanlineSize(tiff)) > (2.53*GetBlobSize(image)))
ThrowTIFFException(CorruptImageError,""InsufficientImageDataInFile"");
number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)
image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
log(2.0))),image->columns*rows_per_strip));
pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
if (pixel_info == (MemoryInfo *) NULL)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
(void) ResetMagickMemory(pixels,0,number_pixels*sizeof(uint32));
quantum_type=GrayQuantum;
if (image->storage_class == PseudoClass)
quantum_type=IndexQuantum;
if (interlace != PLANARCONFIG_SEPARATE)
{
size_t
pad;

pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
if (image->matte != MagickFalse)
{
if (image->storage_class == PseudoClass)
quantum_type=IndexAlphaQuantum;
else
quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
GrayAlphaQuantum;
}
if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))
{
quantum_type=RGBQuantum;
pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
if (image->matte != MagickFalse)
{
quantum_type=RGBAQuantum;
pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
}
if (image->colorspace == CMYKColorspace)
{
quantum_type=CMYKQuantum;
pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
if (image->matte != MagickFalse)
{
quantum_type=CMYKAQuantum;
pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
}
}
status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >>
3));
if (status == MagickFalse)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
}
}
switch (method)
{
case ReadYCCKMethod:
{



for (y=0; y < (ssize_t) image->rows; y++)
{
int
status;

IndexPacket
*indexes;

PixelPacket
*magick_restrict q;

ssize_t
x;

unsigned char
*p;

status=TIFFReadPixels(tiff,0,y,(char *) pixels);
if (status == -1)
break;
q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
indexes=GetAuthenticIndexQueue(image);
p=pixels;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelCyan(q,ScaleCharToQuantum(ClampYCC((double) *p+
(1.402*(double) *(p+2))-179.456)));
SetPixelMagenta(q,ScaleCharToQuantum(ClampYCC((double) *p-
(0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
135.45984)));
SetPixelYellow(q,ScaleCharToQuantum(ClampYCC((double) *p+
(1.772*(double) *(p+1))-226.816)));
SetPixelBlack(indexes+x,ScaleCharToQuantum((unsigned char)*(p+3)));
q++;
p+=4;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
break;
}
case ReadStripMethod:
{
unsigned char
*p;

size_t
extent;

ssize_t
stride,
strip_id;

tsize_t
strip_size;

unsigned char
*strip_pixels;




extent=2*TIFFStripSize(tiff);
#if defined(TIFF_VERSION_BIG)
extent+=image->columns*sizeof(uint64);
#else
extent+=image->columns*sizeof(uint32);
#endif
strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,
sizeof(*strip_pixels));
if (strip_pixels == (unsigned char *) NULL)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
(void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));
stride=TIFFVStripSize(tiff,1);
strip_id=0;
p=strip_pixels;
for (i=0; i < (ssize_t) samples_per_pixel; i++)
{
size_t
rows_remaining;

switch (i)
{
case 0: break;
case 1: quantum_type=GreenQuantum; break;
case 2: quantum_type=BlueQuantum; break;
case 3:
{
quantum_type=AlphaQuantum;
if (image->colorspace == CMYKColorspace)
quantum_type=BlackQuantum;
break;
}
case 4: quantum_type=AlphaQuantum; break;
default: break;
}
rows_remaining=0;
for (y=0; y < (ssize_t) image->rows; y++)
{
PixelPacket
*magick_restrict q;

q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
if (rows_remaining == 0)
{
strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,
TIFFStripSize(tiff));
if (strip_size == -1)
break;
rows_remaining=rows_per_strip;
if ((y+rows_per_strip) > (ssize_t) image->rows)
rows_remaining=(rows_per_strip-(y+rows_per_strip-
image->rows));
p=strip_pixels;
strip_id++;
}
(void) ImportQuantumPixels(image,(CacheView *) NULL,
quantum_info,quantum_type,p,exception);
p+=stride;
rows_remaining--;
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))
break;
}
strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
break;
}
case ReadTileMethod:
{
unsigned char
*p;

size_t
extent;

uint32
columns,
rows;

unsigned char
*tile_pixels;




if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
(TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
ThrowTIFFException(CoderError,""ImageIsNotTiled"");
number_pixels=(MagickSizeType) columns*rows;
if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
extent=TIFFTileSize(tiff);
#if defined(TIFF_VERSION_BIG)
extent+=columns*sizeof(uint64);
#else
extent+=columns*sizeof(uint32);
#endif
tile_pixels=(unsigned char *) AcquireQuantumMemory(extent,
sizeof(*tile_pixels));
if (tile_pixels == (unsigned char *) NULL)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
(void) memset(tile_pixels,0,extent*sizeof(*tile_pixels));
for (i=0; i < (ssize_t) samples_per_pixel; i++)
{
switch (i)
{
case 0: break;
case 1: quantum_type=GreenQuantum; break;
case 2: quantum_type=BlueQuantum; break;
case 3:
{
quantum_type=AlphaQuantum;
if (image->colorspace == CMYKColorspace)
quantum_type=BlackQuantum;
break;
}
case 4: quantum_type=AlphaQuantum; break;
default: break;
}
for (y=0; y < (ssize_t) image->rows; y+=rows)
{
ssize_t
x;

size_t
rows_remaining;

rows_remaining=image->rows-y;
if ((ssize_t) (y+rows) < (ssize_t) image->rows)
rows_remaining=rows;
for (x=0; x < (ssize_t) image->columns; x+=columns)
{
size_t
columns_remaining,
row;

columns_remaining=image->columns-x;
if ((ssize_t) (x+columns) < (ssize_t) image->columns)
columns_remaining=columns;
if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)
break;
p=tile_pixels;
for (row=0; row < rows_remaining; row++)
{
PixelPacket
*magick_restrict q;

q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,
exception);
if (q == (PixelPacket *) NULL)
break;
(void) ImportQuantumPixels(image,(CacheView *) NULL,
quantum_info,quantum_type,p,exception);
p+=TIFFTileRowSize(tiff);
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
}
}
}
if ((samples_per_pixel > 1) && (interlace != PLANARCONFIG_SEPARATE))
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) i,
samples_per_pixel);
if (status == MagickFalse)
break;
}
}
tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
break;
}
case ReadGenericMethod:
default:
{
MemoryInfo
*generic_info = (MemoryInfo *) NULL;

uint32
*p;

uint32
*pixels;




if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
number_pixels=(MagickSizeType) image->columns*image->rows;
#if defined(TIFF_VERSION_BIG)
number_pixels+=image->columns*sizeof(uint64);
#else
number_pixels+=image->columns*sizeof(uint32);
#endif
generic_info=AcquireVirtualMemory(number_pixels,sizeof(*pixels));
if (generic_info == (MemoryInfo *) NULL)
ThrowTIFFException(ResourceLimitError,""MemoryAllocationFailed"");
pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);
(void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
image->rows,(uint32 *) pixels,0);
p=pixels+(image->columns*image->rows)-1;
for (y=0; y < (ssize_t) image->rows; y++)
{
ssize_t
x;

PixelPacket
*magick_restrict q;

q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
if (q == (PixelPacket *) NULL)
break;
q+=image->columns-1;
for (x=0; x < (ssize_t) image->columns; x++)
{
SetPixelRed(q,ScaleCharToQuantum((unsigned char) TIFFGetR(*p)));
SetPixelGreen(q,ScaleCharToQuantum((unsigned char) TIFFGetG(*p)));
SetPixelBlue(q,ScaleCharToQuantum((unsigned char) TIFFGetB(*p)));
if (image->matte == MagickFalse)
SetPixelOpacity(q,OpaqueOpacity);
else
SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) TIFFGetA(*p)));
p--;
q--;
}
if (SyncAuthenticPixels(image,exception) == MagickFalse)
break;
if (image->previous == (Image *) NULL)
{
status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
image->rows);
if (status == MagickFalse)
break;
}
}
generic_info=RelinquishVirtualMemory(generic_info);
break;
}
}
pixel_info=RelinquishVirtualMemory(pixel_info);
SetQuantumImageType(image,quantum_type);
next_tiff_frame:
if (quantum_info != (QuantumInfo *) NULL)
quantum_info=DestroyQuantumInfo(quantum_info);
if (photometric == PHOTOMETRIC_CIELAB)
DecodeLabImage(image,exception);
if ((photometric == PHOTOMETRIC_LOGL) ||
(photometric == PHOTOMETRIC_MINISBLACK) ||
(photometric == PHOTOMETRIC_MINISWHITE))
{
image->type=GrayscaleType;
if (bits_per_sample == 1)
image->type=BilevelType;
}



if (image_info->number_scenes != 0)
if (image->scene >= (image_info->scene+image_info->number_scenes-1))
break;
more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
if (more_frames != MagickFalse)
{



AcquireNextImage(image_info,image);
if (GetNextImageInList(image) == (Image *) NULL)
{
status=MagickFalse;
break;
}
image=SyncNextImageInList(image);
status=SetImageProgress(image,LoadImagesTag,image->scene-1,
image->scene);
if (status == MagickFalse)
break;
}
} while ((status != MagickFalse) && (more_frames != MagickFalse));
TIFFClose(tiff);
if ((image_info->number_scenes != 0) &&
(image_info->scene >= GetImageListLength(image)))
status=MagickFalse;
if (status == MagickFalse)
return(DestroyImageList(image));
TIFFReadPhotoshopLayers(image_info,image,exception);
return(GetFirstImageInList(image));
}","[176, 548, 550, 551]","A vulnerability was found in ImageMagick-7.0.11-5, where executing a crafted file with the convert command, ASAN detects memory leaks."
202968," cliprdr_process(STREAM s)
 {
  	uint16 type, status;
  	uint32 length, format;
  	uint8 *data;
 	struct stream packet = *s;
  
  	in_uint16_le(s, type);
  	in_uint16_le(s, status);
 	in_uint32_le(s, length);
 	data = s->p;
 
  	logger(Clipboard, Debug, ""cliprdr_process(), type=%d, status=%d, length=%d"", type, status,
  	       length);
  
 	if (!s_check_rem(s, length))
 	{
 		rdp_protocol_error(""cliprdr_process(), consume of packet from stream would overrun"", &packet);
 	}
 
  	if (status == CLIPRDR_ERROR)
  	{
  		switch (type)
 		{
 			case CLIPRDR_FORMAT_ACK:
 				 
 				cliprdr_send_native_format_announce(last_formats,
 								    last_formats_length);
 				break;
 			case CLIPRDR_DATA_RESPONSE:
 				ui_clip_request_failed();
 				break;
 			default:
 				logger(Clipboard, Warning,
 				       ""cliprdr_process(), unhandled error (type=%d)"", type);
 		}
 
 		return;
 	}
 
 	switch (type)
 	{
 		case CLIPRDR_CONNECT:
 			ui_clip_sync();
 			break;
 		case CLIPRDR_FORMAT_ANNOUNCE:
 			ui_clip_format_announce(data, length);
 			cliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);
 			return;
 		case CLIPRDR_FORMAT_ACK:
 			break;
 		case CLIPRDR_DATA_REQUEST:
 			in_uint32_le(s, format);
 			ui_clip_request_data(format);
 			break;
 		case CLIPRDR_DATA_RESPONSE:
 			ui_clip_handle_data(data, length);
 			break;
 		case 7:	 
 			break;
 		default:
 			logger(Clipboard, Warning, ""cliprdr_process(), unhandled packet type %d"",
 			       type);
 	}
 }","[6, 16, 17, 18, 19, 20]",rdesktop versions up to and including v1.8.3 contain a Buffer Overflow over the global variables in the function seamless_process_line() that results in memory corruption and probably even a remote code execution.
9570,"static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt,
const pj_uint8_t *start, const pj_uint8_t *max,
int *parsed_len, int *name_len)
{
const pj_uint8_t *p;
pj_status_t status;


if (rec_counter > 10) {

return PJLIB_UTIL_EDNSINNAMEPTR;
}

*name_len = *parsed_len = 0;
p = start;
while (*p) {
if ((*p & 0xc0) == 0xc0) {

int ptr_len = 0;
int dummy;
pj_uint16_t offset;


pj_memcpy(&offset, p, 2);
offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));
offset = pj_ntohs(offset);


if (offset >= max - pkt)
return PJLIB_UTIL_EDNSINNAMEPTR;


status = get_name_len(rec_counter+1, pkt, pkt + offset, max,
&dummy, &ptr_len);
if (status != PJ_SUCCESS)
return status;

*parsed_len += 2;
*name_len += ptr_len;

return PJ_SUCCESS;
} else {
unsigned label_len = *p;


if (pkt+label_len > max)
return PJLIB_UTIL_EDNSINNAMEPTR;

p += (label_len + 1);
*parsed_len += (label_len + 1);

if (*p != 0)
++label_len;

*name_len += label_len;

if (p >= max)
return PJLIB_UTIL_EDNSINSIZE;
}
}
++p;
(*parsed_len)++;

return PJ_SUCCESS;
}","[46, 57, 58]",PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.12 and prior affects applications that uses PJSIP DNS resolution. It doesn't affect PJSIP users who utilize an external resolver. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver instead.
203054," cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,
     uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
 {
 	const cdf_section_header_t *shp;
 	cdf_section_header_t sh;
 	const uint8_t *p, *q, *e;
 	int16_t s16;
 	int32_t s32;
 	uint32_t u32;
 	int64_t s64;
 	uint64_t u64;
 	cdf_timestamp_t tp;
 	size_t i, o, o4, nelements, j;
 	cdf_property_info_t *inp;
 
 	if (offs > UINT32_MAX / 4) {
 		errno = EFTYPE;
 		goto out;
 	}
 	shp = CAST(const cdf_section_header_t *, (const void *)
 	    ((const char *)sst->sst_tab + offs));
 	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
 		goto out;
 	sh.sh_len = CDF_TOLE4(shp->sh_len);
 #define CDF_SHLEN_LIMIT (UINT32_MAX / 8)
 	if (sh.sh_len > CDF_SHLEN_LIMIT) {
 		errno = EFTYPE;
 		goto out;
 	}
 	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
 #define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))
 	if (sh.sh_properties > CDF_PROP_LIMIT)
 		goto out;
 	DPRINTF((""section len: %u properties %u\n"", sh.sh_len,
 	    sh.sh_properties));
 	if (*maxcount) {
 		if (*maxcount > CDF_PROP_LIMIT)
 			goto out;
 		*maxcount += sh.sh_properties;
 		inp = CAST(cdf_property_info_t *,
 		    realloc(*info, *maxcount * sizeof(*inp)));
 	} else {
 		*maxcount = sh.sh_properties;
 		inp = CAST(cdf_property_info_t *,
 		    malloc(*maxcount * sizeof(*inp)));
 	}
 	if (inp == NULL)
 		goto out;
 	*info = inp;
 	inp += *count;
 	*count += sh.sh_properties;
 	p = CAST(const uint8_t *, (const void *)
 	    ((const char *)(const void *)sst->sst_tab +
 	    offs + sizeof(sh)));
 	e = CAST(const uint8_t *, (const void *)
 	    (((const char *)(const void *)shp) + sh.sh_len));
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
 		q = (const uint8_t *)(const void *)
 		    ((const char *)(const void *)p +
 		    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);
 		if (q > e) {
 			DPRINTF((""Ran of the end %p > %p\n"", q, e));
 			goto out;
 		}
 		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
 		inp[i].pi_type = CDF_GETUINT32(q, 0);
 		DPRINTF((""%d) id=%x type=%x offs=%x,%d\n"", i, inp[i].pi_id,
 		    inp[i].pi_type, q - p, CDF_GETUINT32(p, (i << 1) + 1)));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
 			o = 2;
 		} else {
 			nelements = 1;
 			o = 1;
 		}
 		o4 = o * sizeof(uint32_t);
 		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
 			goto unknown;
 		switch (inp[i].pi_type & CDF_TYPEMASK) {
 		case CDF_NULL:
 		case CDF_EMPTY:
 			break;
 		case CDF_SIGNED16:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&s16, &q[o4], sizeof(s16));
 			inp[i].pi_s16 = CDF_TOLE2(s16);
 			break;
 		case CDF_SIGNED32:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&s32, &q[o4], sizeof(s32));
 			inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);
 			break;
 		case CDF_BOOL:
 		case CDF_UNSIGNED32:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&u32, &q[o4], sizeof(u32));
 			inp[i].pi_u32 = CDF_TOLE4(u32);
 			break;
 		case CDF_SIGNED64:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&s64, &q[o4], sizeof(s64));
 			inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);
 			break;
 		case CDF_UNSIGNED64:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&u64, &q[o4], sizeof(u64));
 			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
 			break;
 		case CDF_LENGTH32_STRING:
 		case CDF_LENGTH32_WSTRING:
 			if (nelements > 1) {
 				size_t nelem = inp - *info;
 				if (*maxcount > CDF_PROP_LIMIT
 				    || nelements > CDF_PROP_LIMIT)
 					goto out;
 				*maxcount += nelements;
 				inp = CAST(cdf_property_info_t *,
 				    realloc(*info, *maxcount * sizeof(*inp)));
 				if (inp == NULL)
 					goto out;
 				*info = inp;
 				inp = *info + nelem;
 			}
 			DPRINTF((""nelements = %d\n"", nelements));
 			for (j = 0; j < nelements; j++, i++) {
 				uint32_t l = CDF_GETUINT32(q, o);
 				inp[i].pi_str.s_len = l;
 				inp[i].pi_str.s_buf = (const char *)
 				    (const void *)(&q[o4 + sizeof(l)]);
 				DPRINTF((""l = %d, r = %d, s = %s\n"", l,
 				    CDF_ROUND(l, sizeof(l)),
  				    inp[i].pi_str.s_buf));
  				l = 4 + (uint32_t)CDF_ROUND(l, sizeof(l));
  				o += l >> 2;
 				if (q + o >= e)
 					goto out;
  				o4 = o * sizeof(uint32_t);
  			}
  			i--;
 			break;
 		case CDF_FILETIME:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			(void)memcpy(&tp, &q[o4], sizeof(tp));
 			inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);
 			break;
 		case CDF_CLIPBOARD:
 			if (inp[i].pi_type & CDF_VECTOR)
 				goto unknown;
 			break;
 		default:
 		unknown:
 			DPRINTF((""Don't know how to deal with %x\n"",
 			    inp[i].pi_type));
 			goto out;
 		}
 	}
 	return 0;
 out:
 	free(*info);
 	return -1;
 }","[142, 143]",file before 5.11 and libmagic allow remote attackers to cause a denial of service (crash) via a crafted Composite Document File (CDF) file that triggers (1) an out-of-bounds read or (2) an invalid pointer dereference.
198171,"   main( int    argc,
         char*  argv[] )
   {
     int    old_ptsize, orig_ptsize, file;
     int    first_glyph = 0;
     int    XisSetup = 0;
     char*  execname;
     int    option;
     int    file_loaded;
 
     grEvent  event;
 
 
     execname = ft_basename( argv[0] );
 
     while ( 1 )
     {
       option = getopt( argc, argv, ""d:e:f:r:"" );
 
       if ( option == -1 )
         break;
 
       switch ( option )
       {
       case 'd':
         parse_design_coords( optarg );
         break;
 
       case 'e':
         encoding = (FT_Encoding)make_tag( optarg );
         break;
 
       case 'f':
         first_glyph = atoi( optarg );
         break;
 
       case 'r':
         res = atoi( optarg );
         if ( res < 1 )
           usage( execname );
         break;
 
       default:
         usage( execname );
         break;
       }
     }
 
     argc -= optind;
     argv += optind;
 
     if ( argc <= 1 )
       usage( execname );
 
     if ( sscanf( argv[0], ""%d"", &orig_ptsize ) != 1 )
       orig_ptsize = 64;
 
     file = 1;
 
      
     error = FT_Init_FreeType( &library );
     if ( error )
       PanicZ( ""Could not initialize FreeType library"" );
 
   NewFile:
     ptsize      = orig_ptsize;
     hinted      = 1;
     file_loaded = 0;
 
      
     error = FT_New_Face( library, argv[file], 0, &face );
     if ( error )
       goto Display_Font;
 
     if ( encoding != FT_ENCODING_NONE )
     {
       error = FT_Select_Charmap( face, encoding );
       if ( error )
         goto Display_Font;
     }
 
      
     error = FT_Get_MM_Var( face, &multimaster );
     if ( error )
       goto Display_Font;
 
      
      
     {
       int  n;
 
 
       for ( n = 0; n < (int)multimaster->num_axis; n++ )
       {
         design_pos[n] = n < requested_cnt ? requested_pos[n]
                                           : multimaster->axis[n].def;
         if ( design_pos[n] < multimaster->axis[n].minimum )
           design_pos[n] = multimaster->axis[n].minimum;
         else if ( design_pos[n] > multimaster->axis[n].maximum )
           design_pos[n] = multimaster->axis[n].maximum;
       }
     }
 
     error = FT_Set_Var_Design_Coordinates( face,
                                            multimaster->num_axis,
                                            design_pos );
     if ( error )
       goto Display_Font;
 
     file_loaded++;
 
     Reset_Scale( ptsize );
 
     num_glyphs = face->num_glyphs;
     glyph      = face->glyph;
     size       = face->size;
 
   Display_Font:
      
     if ( !XisSetup )
     {
       XisSetup = 1;
       Init_Display();
     }
 
     grSetTitle( surface, ""FreeType Glyph Viewer - press F1 for help"" );
     old_ptsize = ptsize;
 
     if ( file_loaded >= 1 )
     {
       Fail = 0;
       Num  = first_glyph;
 
       if ( Num >= num_glyphs )
         Num = num_glyphs - 1;
 
       if ( Num < 0 )
         Num = 0;
     }
 
     for ( ;; )
     {
       int  key;
 
 
       Clear_Display();
 
       if ( file_loaded >= 1 )
       {
         switch ( render_mode )
         {
         case 0:
           Render_Text( Num );
           break;
 
         default:
            Render_All( Num, ptsize );
          }
  
        sprintf( Header, ""%s %s (file %s)"",
         sprintf( Header, ""%.50s %.50s (file %.100s)"",
                           face->family_name,
                           face->style_name,
                           ft_basename( argv[file] ) );
 
         if ( !new_header )
           new_header = Header;
 
         grWriteCellString( &bit, 0, 0, new_header, fore_color );
         new_header = 0;
 
         sprintf( Header, ""axis: "" );
         {
           int  n;
 
 
           for ( n = 0; n < (int)multimaster->num_axis; n++ )
           {
             char  temp[32];
 
 
             sprintf( temp, ""  %s:%g"",
                            multimaster->axis[n].name,
                            design_pos[n]/65536. );
             strcat( Header, temp );
           }
         }
         grWriteCellString( &bit, 0, 16, Header, fore_color );
 
         sprintf( Header, ""at %d points, first glyph = %d"",
                          ptsize,
                          Num );
        }
        else
        {
        sprintf( Header, ""%s: not an MM font file, or could not be opened"",
         sprintf( Header, ""%.100s: not an MM font file, or could not be opened"",
                           ft_basename( argv[file] ) );
        }
       grWriteCellString( &bit, 0, 8, Header, fore_color );
       grRefreshSurface( surface );
 
       grListenSurface( surface, 0, &event );
       if ( !( key = Process_Event( &event ) ) )
         goto End;
 
       if ( key == 'n' )
       {
         if ( file_loaded >= 1 )
           FT_Done_Face( face );
 
         if ( file < argc - 1 )
           file++;
 
         goto NewFile;
       }
 
       if ( key == 'p' )
       {
         if ( file_loaded >= 1 )
           FT_Done_Face( face );
 
         if ( file > 1 )
           file--;
 
         goto NewFile;
       }
 
       if ( ptsize != old_ptsize )
       {
         Reset_Scale( ptsize );
 
         old_ptsize = ptsize;
       }
     }
 
   End:
     grDoneSurface( surface );
     grDoneDevices();
 
     free            ( multimaster );
     FT_Done_Face    ( face        );
     FT_Done_FreeType( library     );
 
     printf( ""Execution completed successfully.\n"" );
     printf( ""Fails = %d\n"", Fail );
 
     exit( 0 );       
     return 0;        
   }","[161, 197, 160, 196]",Multiple buffer overflows in demo programs in FreeType before 2.4.0 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted font file.
207182," static NavigationPolicy NavigationPolicyForRequest(
    const FrameLoadRequest& request) {
 static NavigationPolicy NavigationPolicyForEvent(Event* event) {
    NavigationPolicy policy = kNavigationPolicyCurrentTab;
  Event* event = request.TriggeringEvent();
  if (!event)
    return policy;
  if (request.Form() && event->UnderlyingEvent())
    event = event->UnderlyingEvent();
    if (event->IsMouseEvent()) {
      MouseEvent* mouse_event = ToMouseEvent(event);
      NavigationPolicyFromMouseEvent(
         mouse_event->button(), mouse_event->ctrlKey(), mouse_event->shiftKey(),
         mouse_event->altKey(), mouse_event->metaKey(), &policy);
   } else if (event->IsKeyboardEvent()) {
     KeyboardEvent* key_event = ToKeyboardEvent(event);
     NavigationPolicyFromMouseEvent(0, key_event->ctrlKey(),
                                    key_event->shiftKey(), key_event->altKey(),
                                    key_event->metaKey(), &policy);
   } else if (event->IsGestureEvent()) {
     GestureEvent* gesture_event = ToGestureEvent(event);
     NavigationPolicyFromMouseEvent(
         0, gesture_event->ctrlKey(), gesture_event->shiftKey(),
         gesture_event->altKey(), gesture_event->metaKey(), &policy);
   }
    return policy;
  }","[3, 2, 5, 6, 7, 8, 9]",A missing check for JS-simulated input events in Blink in Google Chrome prior to 69.0.3497.81 allowed a remote attacker to download arbitrary files with no user input via a crafted HTML page.
207871," long ContentEncoding::ParseContentEncAESSettingsEntry(
  long long start, long long size, IMkvReader* pReader,
  ContentEncAESSettings* aes) {
   assert(pReader);
   assert(aes);
 
  long long pos = start;
  const long long stop = start + size;
 
  while (pos < stop) {
  long long id, size;
  const long status = ParseElementHeader(pReader, pos, stop, id, size);
  if (status < 0)  
  return status;
 
  if (id == 0x7E8) {
       aes->cipher_mode = UnserializeUInt(pReader, pos, size);
  if (aes->cipher_mode != 1)
  return E_FILE_FORMAT_INVALID;
 
      }
  
      pos += size;   
    assert(pos <= stop);
     if (pos > stop)
       return E_FILE_FORMAT_INVALID;
    }
  
    return 0;
 }","[25, 26, 24]","libvpx in libwebm in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted mkv file, aka internal bug 23167726."
7446,"static void consume_one_event(unsigned cpu,
struct evtchn_fifo_control_block *control_block,
unsigned priority, unsigned long *ready,
bool drop)
{
struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
uint32_t head;
evtchn_port_t port;
event_word_t *word;

head = q->head[priority];





if (head == 0) {
virt_rmb();
head = control_block->head[priority];
}

port = head;
word = event_word_from_port(port);
head = clear_linked(word);








if (head == 0)
clear_bit(priority, ready);

if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
if (unlikely(drop))
pr_warn(""Dropping pending event for port %u\n"", port);
else
handle_irq_for_port(port);
}

q->head[priority] = head;
}","[3, 4, 37, 40]","An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. Guest OS users can cause a denial of service (host OS hang) via a high rate of events to dom0, aka CID-e99502f76271."
7521,"static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)
{
x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];

t->branch[0] = NULL;
t->branch[1] = NULL;
t->leaf = UNDEFINED_LEAF;

tree->free_node_index++;

return t;
}",[3],"In LibRaw, there is an out-of-bounds write vulnerability within the ""new_node()"" function (libraw\src\x3f\x3f_utils_patched.cpp) that can be triggered via a crafted X3F file."
198686," pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)
 {
   g_return_if_fail (new_len >= 0);
 
    while (new_len > string->space)
      {
        if (string->space == 0)
	string->space = 1;
 	{
 	  string->space = 4;
 	}
        else
	string->space *= 2;
      if (string->space < 0)
  	{
	  g_warning (""glyph string length overflows maximum integer size, truncated"");
	  new_len = string->space = G_MAXINT - 8;
 	  const guint max_space =
 	    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));
 
 	  guint more_space = (guint)string->space * 2;
 
 	  if (more_space > max_space)
 	    {
 	      more_space = max_space;
 
 	      if ((guint)new_len > max_space)
 		{
 		  g_error (""%s: failed to allocate glyph string of length %i\n"",
 			   G_STRLOC, new_len);
 		}
 	    }
 
 	  string->space = more_space;
  	}
      }
  
   string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));
   string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));
   string->num_glyphs = new_len;
 }","[9, 10, 11, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 8, 13, 14, 16, 17]","Integer overflow in the pango_glyph_string_set_size function in pango/glyphstring.c in Pango before 1.24 allows context-dependent attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a long glyph string that triggers a heap-based buffer overflow, as demonstrated by a long document.location value in Firefox."
206131," png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
 {
    png_infop info_ptr = *ptr_ptr;
 
    png_debug(1, ""in png_info_init_3"");
 
    if (info_ptr == NULL)
       return;
 
    if (png_sizeof(png_info) > png_info_struct_size)
    {
        png_destroy_struct(info_ptr);
        info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
        *ptr_ptr = info_ptr;
       if (info_ptr == NULL)
          return;
     }
  
      
    png_memset(info_ptr, 0, png_sizeof(png_info));
 }","[15, 16]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
203903," bool AutofillDownloadManager::StartUploadRequest(
     const FormStructure& form,
     bool form_was_autofilled,
     const FieldTypeSet& available_field_types) {
   if (next_upload_request_ > base::Time::Now()) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
     return false;
   }
 
    double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                               GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
   if (form.upload_required() == UPLOAD_NOT_REQUIRED ||
       (form.upload_required() == USE_UPLOAD_RATES &&
        base::RandDouble() > upload_rate)) {
      VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
      return false;
   }
 
   std::string form_xml;
   if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                 &form_xml))
     return false;
 
   FormRequestData request_data;
   request_data.form_signatures.push_back(form.FormSignature());
   request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;
 
   return StartRequest(form_xml, request_data);
 }","[13, 14, 15, 12]",Use-after-free vulnerability in Google Chrome before 13.0.782.107 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to resource caching.
205093," static ScriptPromise fulfillImageBitmap(ExecutionContext* context, PassRefPtrWillBeRawPtr<ImageBitmap> imageBitmap)
  {
      RefPtr<ScriptPromiseResolver> resolver = ScriptPromiseResolver::create(context);
      ScriptPromise promise = resolver->promise();
    resolver->resolve(imageBitmap);
     if (imageBitmap) {
         resolver->resolve(imageBitmap);
     } else {
         v8::Isolate* isolate = ScriptState::current()->isolate();
         resolver->reject(ScriptValue(v8::Null(isolate), isolate));
     }
      return promise;
  }","[6, 7, 8, 9, 10, 11, 5]","Multiple unspecified vulnerabilities in the IPC layer in Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allow remote attackers to cause a denial of service (memory corruption) or possibly have other impact via unknown vectors."
204365," ConflictResolver::ProcessSimpleConflict(WriteTransaction* trans,
                                         const Id& id,
                                         const Cryptographer* cryptographer,
                                         StatusController* status) {
   MutableEntry entry(trans, syncable::GET_BY_ID, id);
   CHECK(entry.good());
 
   if (!entry.Get(syncable::IS_UNAPPLIED_UPDATE) ||
       !entry.Get(syncable::IS_UNSYNCED)) {
     return NO_SYNC_PROGRESS;
   }
 
   if (entry.Get(syncable::IS_DEL) && entry.Get(syncable::SERVER_IS_DEL)) {
     entry.Put(syncable::IS_UNSYNCED, false);
     entry.Put(syncable::IS_UNAPPLIED_UPDATE, false);
     return NO_SYNC_PROGRESS;
   }
 
   if (!entry.Get(syncable::SERVER_IS_DEL)) {
     bool name_matches = entry.Get(syncable::NON_UNIQUE_NAME) ==
                         entry.Get(syncable::SERVER_NON_UNIQUE_NAME);
     bool parent_matches = entry.Get(syncable::PARENT_ID) ==
                           entry.Get(syncable::SERVER_PARENT_ID);
     bool entry_deleted = entry.Get(syncable::IS_DEL);
 
     syncable::Id server_prev_id = entry.ComputePrevIdFromServerPosition(
         entry.Get(syncable::SERVER_PARENT_ID));
     bool needs_reinsertion = !parent_matches ||
          server_prev_id != entry.Get(syncable::PREV_ID);
     DVLOG_IF(1, needs_reinsertion) << ""Insertion needed, server prev id ""
         << "" is "" << server_prev_id << "", local prev id is ""
         << entry.Get(syncable::PREV_ID);
     const sync_pb::EntitySpecifics& specifics =
         entry.Get(syncable::SPECIFICS);
     const sync_pb::EntitySpecifics& server_specifics =
         entry.Get(syncable::SERVER_SPECIFICS);
     const sync_pb::EntitySpecifics& base_server_specifics =
         entry.Get(syncable::BASE_SERVER_SPECIFICS);
     std::string decrypted_specifics, decrypted_server_specifics;
     bool specifics_match = false;
     bool server_encrypted_with_default_key = false;
     if (specifics.has_encrypted()) {
       DCHECK(cryptographer->CanDecryptUsingDefaultKey(specifics.encrypted()));
       decrypted_specifics = cryptographer->DecryptToString(
           specifics.encrypted());
     } else {
       decrypted_specifics = specifics.SerializeAsString();
     }
     if (server_specifics.has_encrypted()) {
       server_encrypted_with_default_key =
           cryptographer->CanDecryptUsingDefaultKey(
               server_specifics.encrypted());
       decrypted_server_specifics = cryptographer->DecryptToString(
           server_specifics.encrypted());
     } else {
       decrypted_server_specifics = server_specifics.SerializeAsString();
     }
     if (decrypted_server_specifics == decrypted_specifics &&
         server_encrypted_with_default_key == specifics.has_encrypted()) {
       specifics_match = true;
     }
     bool base_server_specifics_match = false;
     if (server_specifics.has_encrypted() &&
         IsRealDataType(GetModelTypeFromSpecifics(base_server_specifics))) {
       std::string decrypted_base_server_specifics;
       if (!base_server_specifics.has_encrypted()) {
         decrypted_base_server_specifics =
             base_server_specifics.SerializeAsString();
       } else {
         decrypted_base_server_specifics = cryptographer->DecryptToString(
             base_server_specifics.encrypted());
       }
       if (decrypted_server_specifics == decrypted_base_server_specifics)
           base_server_specifics_match = true;
     }
 
     if (entry.GetModelType() == syncable::NIGORI) {
       sync_pb::EntitySpecifics specifics =
           entry.Get(syncable::SERVER_SPECIFICS);
       sync_pb::NigoriSpecifics* server_nigori = specifics.mutable_nigori();
       cryptographer->UpdateNigoriFromEncryptedTypes(server_nigori);
       if (cryptographer->is_ready()) {
         cryptographer->GetKeys(server_nigori->mutable_encrypted());
         server_nigori->set_using_explicit_passphrase(
              entry.Get(syncable::SPECIFICS).nigori().
                  using_explicit_passphrase());
        }
      if (entry.Get(syncable::SPECIFICS).nigori().sync_tabs()) {
        server_nigori->set_sync_tabs(true);
      }
        entry.Put(syncable::SPECIFICS, specifics);
       DVLOG(1) << ""Resolving simple conflict, merging nigori nodes: "" << entry;
       status->increment_num_server_overwrites();
       OverwriteServerChanges(trans, &entry);
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 NIGORI_MERGE,
                                 CONFLICT_RESOLUTION_SIZE);
     } else if (!entry_deleted && name_matches && parent_matches &&
                specifics_match && !needs_reinsertion) {
       DVLOG(1) << ""Resolving simple conflict, everything matches, ignoring ""
                << ""changes for: "" << entry;
       OverwriteServerChanges(trans, &entry);
       IgnoreLocalChanges(&entry);
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 CHANGES_MATCH,
                                 CONFLICT_RESOLUTION_SIZE);
     } else if (base_server_specifics_match) {
       DVLOG(1) << ""Resolving simple conflict, ignoring server encryption ""
                << "" changes for: "" << entry;
       status->increment_num_server_overwrites();
       OverwriteServerChanges(trans, &entry);
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 IGNORE_ENCRYPTION,
                                 CONFLICT_RESOLUTION_SIZE);
     } else if (entry_deleted || !name_matches || !parent_matches) {
       OverwriteServerChanges(trans, &entry);
       status->increment_num_server_overwrites();
       DVLOG(1) << ""Resolving simple conflict, overwriting server changes ""
                << ""for: "" << entry;
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 OVERWRITE_SERVER,
                                 CONFLICT_RESOLUTION_SIZE);
     } else {
       DVLOG(1) << ""Resolving simple conflict, ignoring local changes for: ""
                << entry;
       IgnoreLocalChanges(&entry);
       status->increment_num_local_overwrites();
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 OVERWRITE_LOCAL,
                                 CONFLICT_RESOLUTION_SIZE);
     }
     entry.Put(syncable::BASE_SERVER_SPECIFICS, sync_pb::EntitySpecifics());
     return SYNC_PROGRESS;
   } else {   
     if (entry.Get(syncable::IS_DIR)) {
       Directory::ChildHandles children;
       trans->directory()->GetChildHandlesById(trans,
                                               entry.Get(syncable::ID),
                                               &children);
       if (0 != children.size()) {
         DVLOG(1) << ""Entry is a server deleted directory with local contents, ""
                  << ""should be a hierarchy conflict. (race condition)."";
         return NO_SYNC_PROGRESS;
       }
     }
 
     if (!entry.Get(syncable::UNIQUE_CLIENT_TAG).empty()) {
       DCHECK_EQ(entry.Get(syncable::SERVER_VERSION), 0) << ""For the server to ""
           ""know to re-create, client-tagged items should revert to version 0 ""
           ""when server-deleted."";
       OverwriteServerChanges(trans, &entry);
       status->increment_num_server_overwrites();
       DVLOG(1) << ""Resolving simple conflict, undeleting server entry: ""
                << entry;
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 OVERWRITE_SERVER,
                                 CONFLICT_RESOLUTION_SIZE);
       entry.Put(syncable::SERVER_VERSION, 0);
       entry.Put(syncable::BASE_VERSION, 0);
     } else {
       SyncerUtil::SplitServerInformationIntoNewEntry(trans, &entry);
 
       MutableEntry server_update(trans, syncable::GET_BY_ID, id);
       CHECK(server_update.good());
       CHECK(server_update.Get(syncable::META_HANDLE) !=
             entry.Get(syncable::META_HANDLE))
           << server_update << entry;
       UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
                                 UNDELETE,
                                 CONFLICT_RESOLUTION_SIZE);
     }
     return SYNC_PROGRESS;
   }
 }","[88, 89, 90]",Race condition in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the plug-in paint buffer.
10022,"void Compute(OpKernelContext* ctx) override {
const Tensor& data = ctx->input(0);
OP_REQUIRES(ctx, data.dims() <= 2,
errors::InvalidArgument(
""Shape must be at most rank 2 but is rank "", data.dims()));

const Tensor& size_t = ctx->input(1);
const Tensor& weights = ctx->input(2);

OP_REQUIRES(ctx, size_t.dims() == 0,
errors::InvalidArgument(""Shape must be rank 0 but is rank "",
size_t.dims()));
Tidx size = size_t.scalar<Tidx>()();
OP_REQUIRES(
ctx, size >= 0,
errors::InvalidArgument(""size ("", size, "") must be non-negative""));

Tensor* out_t;
functor::SetZeroFunctor<Device, T> fill;
if (data.dims() == 1) {
OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({size}), &out_t));
auto out = out_t->flat<T>();
fill(ctx->eigen_device<Device>(), out);
if (binary_output_) {
OP_REQUIRES_OK(
ctx, functor::BincountFunctor<Device, Tidx, T, true>::Compute(
ctx, data.flat<Tidx>(), weights.flat<T>(), out, size));
} else {
OP_REQUIRES_OK(
ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(
ctx, data.flat<Tidx>(), weights.flat<T>(), out, size));
}
} else if (data.dims() == 2) {
const int64_t num_rows = data.dim_size(0);
auto weight_matrix =
(weights.NumElements() == 0)
? weights.shaped<T, 2>(gtl::InlinedVector<int64_t, 2>(2, 0))
: weights.matrix<T>();
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));
auto out = out_t->matrix<T>();
fill(ctx->eigen_device<Device>(), out_t->flat<T>());
if (binary_output_) {
OP_REQUIRES_OK(
ctx, functor::BincountReduceFunctor<Device, Tidx, T, true>::Compute(
ctx, data.matrix<Tidx>(), weight_matrix, out, size));
} else {
OP_REQUIRES_OK(
ctx,
functor::BincountReduceFunctor<Device, Tidx, T, false>::Compute(
ctx, data.matrix<Tidx>(), weight_matrix, out, size));
}
}
}",[13],"TensorFlow is an open source platform for machine learning. `DenseBincount` assumes its input tensor `weights` to either have the same shape as its input tensor `input` or to be length-0. A different `weights` shape will trigger a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bf4c14353c2328636a18bfad1e151052c81d5f43. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
201871," void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1, int r0,
  int c0, int r1, int c1)
 void jas_matrix_bindsub(jas_matrix_t *mat0, jas_matrix_t *mat1,
   jas_matind_t r0, jas_matind_t c0, jas_matind_t r1, jas_matind_t c1)
  {
	int i;
 	jas_matind_t i;
  
  	if (mat0->data_) {
  		if (!(mat0->flags_ & JAS_MATRIX_REF)) {
 			jas_free(mat0->data_);
 		}
 		mat0->data_ = 0;
 		mat0->datasize_ = 0;
 	}
 	if (mat0->rows_) {
 		jas_free(mat0->rows_);
 		mat0->rows_ = 0;
 	}
 	mat0->flags_ |= JAS_MATRIX_REF;
 	mat0->numrows_ = r1 - r0 + 1;
 	mat0->numcols_ = c1 - c0 + 1;
 	mat0->maxrows_ = mat0->numrows_;
 	if (!(mat0->rows_ = jas_alloc2(mat0->maxrows_, sizeof(jas_seqent_t *)))) {
 		 
 		abort();
 	}
 
 	for (i = 0; i < mat0->numrows_; ++i) {
 		mat0->rows_[i] = mat1->rows_[r0 + i] + c0;
 	}
 
 	mat0->xstart_ = mat1->xstart_ + c0;
 	mat0->ystart_ = mat1->ystart_ + r0;
 	mat0->xend_ = mat0->xstart_ + mat0->numcols_;
 	mat0->yend_ = mat0->ystart_ + mat0->numrows_;
 }","[3, 4, 7, 2, 6]",Integer overflow in jas_image.c in JasPer before 1.900.25 allows remote attackers to cause a denial of service (application crash) via a crafted file.
199348,"  _archive_write_data(struct archive *_a, const void *buff, size_t s)
  {
  	struct archive_write *a = (struct archive_write *)_a;
 	const size_t max_write = INT_MAX;
 
  	archive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,
  	    ARCHIVE_STATE_DATA, ""archive_write_data"");
 	 
 	if (s > max_write)
 		s = max_write;
  	archive_clear_error(&a->archive);
  	return ((a->format_write_data)(a, buff, s));
  }","[4, 5, 8, 9, 10]","Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow."
206334," void UrlFetcherDownloader::StartURLFetch(const GURL& url) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
   if (download_dir_.empty()) {
     Result result;
     result.error = -1;
 
     DownloadMetrics download_metrics;
     download_metrics.url = url;
     download_metrics.downloader = DownloadMetrics::kUrlFetcher;
     download_metrics.error = -1;
     download_metrics.downloaded_bytes = -1;
     download_metrics.total_bytes = -1;
     download_metrics.download_time_ms = 0;
 
     main_task_runner()->PostTask(
         FROM_HERE, base::BindOnce(&UrlFetcherDownloader::OnDownloadComplete,
                                   base::Unretained(this), false, result,
                                   download_metrics));
      return;
    }
  
  const auto file_path = download_dir_.AppendASCII(url.ExtractFileName());
   file_path_ = download_dir_.AppendASCII(url.ExtractFileName());
    network_fetcher_ = network_fetcher_factory_->Create();
    network_fetcher_->DownloadToFile(
      url, file_path,
       url, file_path_,
        base::BindOnce(&UrlFetcherDownloader::OnResponseStarted,
                       base::Unretained(this)),
        base::BindRepeating(&UrlFetcherDownloader::OnDownloadProgress,
                            base::Unretained(this)),
        base::BindOnce(&UrlFetcherDownloader::OnNetworkFetcherComplete,
                     base::Unretained(this), file_path));
                      base::Unretained(this)));
  
    download_start_time_ = base::TimeTicks::Now();
  }","[24, 28, 35, 23, 27, 34]","Insufficient Policy Enforcement in Omnibox in Google Chrome prior to 59.0.3071.86 for Mac, Windows, and Linux, and 59.0.3071.92 for Android, allowed a remote attacker to perform domain spoofing via IDN homographs in a crafted domain name."
203784," RenderThread::~RenderThread() {
   FOR_EACH_OBSERVER(
       RenderProcessObserver, observers_, OnRenderProcessShutdown());
 
   if (web_database_observer_impl_.get())
      web_database_observer_impl_->WaitForAllDatabasesToClose();
  
   RemoveFilter(devtools_agent_message_filter_.get());
   devtools_agent_message_filter_ = NULL;
 
    RemoveFilter(audio_input_message_filter_.get());
    audio_input_message_filter_ = NULL;
  
   RemoveFilter(audio_message_filter_.get());
   audio_message_filter_ = NULL;
 
   RemoveFilter(vc_manager_->video_capture_message_filter());
 
   RemoveFilter(db_message_filter_.get());
   db_message_filter_ = NULL;
 
   if (file_thread_.get())
     file_thread_->Stop();
 
   if (webkit_client_.get())
     WebKit::shutdown();
 
   lazy_tls.Pointer()->Set(NULL);
 
 #if defined(OS_WIN)
   PluginChannelBase::CleanupChannels();
   if (RenderProcessImpl::InProcessPlugins())
     CoUninitialize();
 #endif
 }","[8, 9, 10]","Google Chrome before 14.0.835.163 does not properly handle strings in PDF documents, which allows remote attackers to have an unspecified impact via a crafted document that triggers an incorrect read operation."
201098," ikev2_auth_print(netdissect_options *ndo, u_char tpay,
 		const struct isakmp_gen *ext,
 		u_int item_len _U_, const u_char *ep,
 		uint32_t phase _U_, uint32_t doi _U_,
 		uint32_t proto _U_, int depth _U_)
 {
 	struct ikev2_auth a;
 	const char *v2_auth[]={ ""invalid"", ""rsasig"",
 				""shared-secret"", ""dsssig"" };
 	const u_char *authdata = (const u_char*)ext + sizeof(a);
 	unsigned int len;
 
 	ND_TCHECK(*ext);
 	UNALIGNED_MEMCPY(&a, ext, sizeof(a));
  	ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
  	len = ntohs(a.h.len);
  
	ND_PRINT((ndo,"" len=%d method=%s"", len-4,
 	 
 	ND_PRINT((ndo,"" len=%u method=%s"", len-4,
  		  STR_OR_ID(a.auth_method, v2_auth)));
	if (1 < ndo->ndo_vflag && 4 < len) {
		ND_PRINT((ndo,"" authdata=(""));
		if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
			goto trunc;
		ND_PRINT((ndo,"") ""));
	} else if(ndo->ndo_vflag && 4 < len) {
		if(!ike_show_somedata(ndo, authdata, ep)) goto trunc;
 	if (len > 4) {
 		if (ndo->ndo_vflag > 1) {
 			ND_PRINT((ndo, "" authdata=(""));
 			if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
 				goto trunc;
 			ND_PRINT((ndo, "") ""));
 		} else if (ndo->ndo_vflag) {
 			if (!ike_show_somedata(ndo, authdata, ep))
 				goto trunc;
 		}
  	}
  
  	return (const u_char *)ext + len;
 trunc:
 	ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay)));
 	return NULL;
 }","[19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 18, 22, 23, 24, 25, 26, 27, 28]","The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions."
6296,"static int sd_isoc_nego(struct gspca_dev *gspca_dev)
{
int ret, packet_size, min_packet_size;
struct usb_host_interface *alt;

switch (gspca_dev->pixfmt.width) {
case 160:
min_packet_size = 200;
break;
case 176:
min_packet_size = 266;
break;
default:
min_packet_size = 400;
break;
}

alt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];
packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
if (packet_size <= min_packet_size)
return -EIO;

packet_size -= 100;
if (packet_size < min_packet_size)
packet_size = min_packet_size;
alt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);

ret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);
if (ret < 0)
pr_err(""set alt 1 err %d\n"", ret);

return ret;
}",[18],"In the Linux kernel before 5.6.1, drivers/media/usb/gspca/xirlink_cit.c (aka the Xirlink camera USB driver) mishandles invalid descriptors, aka CID-a246b4d54770."
198679," _XcursorThemeInherits (const char *full)
 {
     char    line[8192];
     char    *result = NULL;
     FILE    *f;
 
     if (!full)
         return NULL;
 
     f = fopen (full, ""r"");
     if (f)
     {
 	while (fgets (line, sizeof (line), f))
 	{
 	    if (!strncmp (line, ""Inherits"", 8))
 	    {
 		char    *l = line + 8;
 		char    *r;
 		while (*l == ' ') l++;
  		if (*l != '=') continue;
  		l++;
  		while (*l == ' ') l++;
		result = malloc (strlen (l));
 		result = malloc (strlen (l) + 1);
  		if (result)
  		{
  		    r = result;
 		    while (*l)
 		    {
 			while (XcursorSep(*l) || XcursorWhite (*l)) l++;
 			if (!*l)
 			    break;
 			if (r != result)
 			    *r++ = ':';
 			while (*l && !XcursorWhite(*l) &&
 			       !XcursorSep(*l))
 			    *r++ = *l++;
 		    }
 		    *r++ = '\0';
 		}
 		break;
 	    }
 	}
 	fclose (f);
     }
     return result;
 }","[24, 23]",_XcursorThemeInherits in library.c in libXcursor before 1.1.15 allows remote attackers to cause denial of service or potentially code execution via a one-byte heap overflow.
8320,"void Compute(OpKernelContext* ctx) override {
const Tensor& indices_tensor = ctx->input(0);
OP_REQUIRES(ctx,
TensorShapeUtils::IsVector(indices_tensor.shape()) ||
TensorShapeUtils::IsScalar(indices_tensor.shape()),
errors::InvalidArgument(
""The indices can only be scalar or vector, got \"""",
indices_tensor.shape().DebugString(), ""\""""));

const Tensor& dims_tensor = ctx->input(1);
OP_REQUIRES(
ctx, TensorShapeUtils::IsVector(dims_tensor.shape()),
errors::InvalidArgument(""The indices can only be 1-D, got \"""",
dims_tensor.shape().DebugString(), ""\""""));

auto dims = dims_tensor.vec<Tidx>();


Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod();
Tidx dims_prod = dims_prod_eigen();
const Tidx* indices = indices_tensor.flat<Tidx>().data();
int64 size = indices_tensor.NumElements();
bool check = std::all_of(indices, indices + size,
[&](Tidx index) { return index < dims_prod; });
OP_REQUIRES(ctx, check,
errors::InvalidArgument(""index is out of bound as with dims""));

Eigen::array<bool, 1> reverse({true});

Tensor strides_tensor;
OP_REQUIRES_OK(ctx,
ctx->allocate_temp(DataTypeToEnum<Tidx>::value,
TensorShape({dims_tensor.NumElements()}),
&strides_tensor));

auto strides = strides_tensor.vec<Tidx>();
strides = dims.reverse(reverse)
.scan(0, Eigen::internal::ProdReducer<Tidx>(), false)
.reverse(reverse);

Tensor strides_shifted_tensor;
OP_REQUIRES_OK(ctx,
ctx->allocate_temp(DataTypeToEnum<Tidx>::value,
TensorShape({dims_tensor.NumElements()}),
&strides_shifted_tensor));

auto strides_shifted = strides_shifted_tensor.vec<Tidx>();
strides_shifted = dims.reverse(reverse)
.scan(0, Eigen::internal::ProdReducer<Tidx>(), true)
.reverse(reverse);

Tensor* output_tensor = nullptr;
if (TensorShapeUtils::IsScalar(indices_tensor.shape())) {
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements()}),
&output_tensor));

auto output = output_tensor->vec<Tidx>();

output = output.constant(indices_tensor.scalar<Tidx>()());
output = output.binaryExpr(strides, mod_op<Tidx>()) / strides_shifted;
} else {
OP_REQUIRES_OK(
ctx, ctx->allocate_output(0,
TensorShape({dims_tensor.NumElements(),
indices_tensor.NumElements()}),
&output_tensor));

auto output = output_tensor->matrix<Tidx>();

Eigen::array<Eigen::Index, 2> reshape{
{static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}};
Eigen::array<Eigen::Index, 2> bcast(
{1, static_cast<Eigen::Index>(indices_tensor.NumElements())});
Eigen::array<Eigen::Index, 2> indices_reshape{
{1, static_cast<Eigen::Index>(indices_tensor.NumElements())}};
Eigen::array<Eigen::Index, 2> indices_bcast(
{static_cast<Eigen::Index>(dims_tensor.NumElements()), 1});

output = indices_tensor.vec<Tidx>()
.reshape(indices_reshape)
.broadcast(indices_bcast);
output = output.binaryExpr(strides.reshape(reshape).broadcast(bcast),
mod_op<Tidx>()) /
strides_shifted.reshape(reshape).broadcast(bcast);
}
}",[19],"TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can cause denial of service in applications serving models using `tf.raw_ops.UnravelIndex` by triggering a division by 0. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/unravel_index_op.cc#L36) does not check that the tensor subsumed by `dims` is not empty. Hence, if one element of `dims` is 0, the implementation does a division by 0. We have patched the issue in GitHub commit a776040a5e7ebf76eeb7eb923bf1ae417dd4d233. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
207723," standard_row_validate(standard_display *dp, png_const_structp pp,
  int iImage, int iDisplay, png_uint_32 y)
 {
  int where;
    png_byte std[STANDARD_ROWMAX];
 
   
    memset(std, 178, sizeof std);
    standard_row(pp, std, dp->id, y);
 
   
     if (iImage >= 0 &&
        (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),
             dp->bit_width)) != 0)
  {
  char msg[64];
       sprintf(msg, ""PNG image row[%lu][%d] changed from %.2x to %.2x"",
  (unsigned long)y, where-1, std[where-1],
          store_image_row(dp->ps, pp, iImage, y)[where-1]);
 
        png_error(pp, msg);
     }
  
#if PNG_LIBPNG_VER < 10506
    
#endif
     if (iDisplay >= 0 &&
        (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),
           dp->bit_width)) != 0)
     {
        char msg[64];
      sprintf(msg, ""display  row[%lu][%d] changed from %.2x to %.2x"",
       sprintf(msg, ""display row[%lu][%d] changed from %.2x to %.2x"",
           (unsigned long)y, where-1, std[where-1],
           store_image_row(dp->ps, pp, iDisplay, y)[where-1]);
        png_error(pp, msg);
  }
 }","[33, 24, 25, 26, 32]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205193," GDataDirectoryService::GDataDirectoryService()
     : blocking_task_runner_(NULL),
       serialized_size_(0),
        largest_changestamp_(0),
        origin_(UNINITIALIZED),
        weak_ptr_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {
  root_.reset(new GDataDirectory(NULL, this));
   root_.reset(CreateGDataDirectory());
    if (!util::IsDriveV2ApiEnabled())
      InitializeRootEntry(kGDataRootDirectoryResourceId);
  }","[8, 7]",Use-after-free vulnerability in Google Chrome before 24.0.1312.56 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the handling of fonts in CANVAS elements.
199434,"  static int ceph_x_decrypt(struct ceph_crypto_key *secret,
			  void **p, void *end, void *obuf, size_t olen)
 			  void **p, void *end, void **obuf, size_t olen)
  {
  	struct ceph_x_encrypt_header head;
  	size_t head_len = sizeof(head);
 	int len, ret;
 
 	len = ceph_decode_32(p);
 	if (*p + len > end)
  		return -EINVAL;
  
  	dout(""ceph_x_decrypt len %d\n"", len);
	ret = ceph_decrypt2(secret, &head, &head_len, obuf, &olen,
			    *p, len);
 	if (*obuf == NULL) {
 		*obuf = kmalloc(len, GFP_NOFS);
 		if (!*obuf)
 			return -ENOMEM;
 		olen = len;
 	}
 
 	ret = ceph_decrypt2(secret, &head, &head_len, *obuf, &olen, *p, len);
  	if (ret)
  		return ret;
  	if (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)
 		return -EPERM;
 	*p += len;
 	return olen;
 }","[3, 16, 17, 18, 19, 20, 21, 22, 23, 2, 14, 15]","net/ceph/auth_x.c in Ceph, as used in the Linux kernel before 3.16.3, does not properly validate auth replies, which allows remote attackers to cause a denial of service (system crash) or possibly have unspecified other impact via crafted data from the IP address of a Ceph Monitor."
5694,"static inline void get_conn_text(const conn *c, const int af,
char* addr, struct sockaddr *sock_addr) {
char addr_text[MAXPATHLEN];
addr_text[0] = '\0';
const char *protoname = ""?"";
unsigned short port = 0;

switch (af) {
case AF_INET:
(void) inet_ntop(af,
&((struct sockaddr_in *)sock_addr)->sin_addr,
addr_text,
sizeof(addr_text) - 1);
port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
break;

case AF_INET6:
addr_text[0] = '[';
addr_text[1] = '\0';
if (inet_ntop(af,
&((struct sockaddr_in6 *)sock_addr)->sin6_addr,
addr_text + 1,
sizeof(addr_text) - 2)) {
strcat(addr_text, ""]"");
}
port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);
protoname = IS_UDP(c->transport) ? ""udp6"" : ""tcp6"";
break;

case AF_UNIX:
strncpy(addr_text,
((struct sockaddr_un *)sock_addr)->sun_path,
sizeof(addr_text) - 1);
addr_text[sizeof(addr_text)-1] = '\0';
protoname = ""unix"";
break;
}

if (strlen(addr_text) < 2) {




sprintf(addr_text, ""<AF %d>"", af);
}

if (port) {
sprintf(addr, ""%s:%s:%u"", protoname, addr_text, port);
} else {
sprintf(addr, ""%s:%s"", protoname, addr_text);
}
}","[8, 32, 34, 35]","memcached 1.5.16, when UNIX sockets are used, has a stack-based buffer over-read in conn_to_str in memcached.c."
200046," loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)
    {
    uint32   i;
    float    xres = 0.0, yres = 0.0;
  uint16   nstrips = 0, ntiles = 0, planar = 0;
   uint32   nstrips = 0, ntiles = 0;
   uint16   planar = 0;
    uint16   bps = 0, spp = 0, res_unit = 0;
    uint16   orientation = 0;
    uint16   input_compression = 0, input_photometric = 0;
   uint16   subsampling_horiz, subsampling_vert;
   uint32   width = 0, length = 0;
   uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;
   uint32   tw = 0, tl = 0;        
   uint32   tile_rowsize = 0;
   unsigned char *read_buff = NULL;
   unsigned char *new_buff  = NULL;
   int      readunit = 0;
   static   uint32  prev_readsize = 0;
 
   TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);
   TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);
   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
   TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
   if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
     TIFFError(""loadImage"",""Image lacks Photometric interpreation tag"");
   if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))
     TIFFError(""loadimage"",""Image lacks image width tag"");
   if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))
     TIFFError(""loadimage"",""Image lacks image length tag"");
   TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);
   TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);
   if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))
     res_unit = RESUNIT_INCH;
   if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))
     input_compression = COMPRESSION_NONE;
 
 #ifdef DEBUG2
   char compressionid[16];
 
   switch (input_compression)
     {
     case COMPRESSION_NONE:	 
 	 strcpy (compressionid, ""None/dump"");
          break;         
     case COMPRESSION_CCITTRLE:	   
 	 strcpy (compressionid, ""Huffman RLE"");
          break;         
     case COMPRESSION_CCITTFAX3:	   
 	 strcpy (compressionid, ""Group3 Fax"");
          break;         
     case COMPRESSION_CCITTFAX4:	   
 	 strcpy (compressionid, ""Group4 Fax"");
          break;         
     case COMPRESSION_LZW:	   
 	 strcpy (compressionid, ""LZW"");
          break;         
     case COMPRESSION_OJPEG:	   
 	 strcpy (compressionid, ""Old Jpeg"");
          break;         
     case COMPRESSION_JPEG:	   
 	 strcpy (compressionid, ""New Jpeg"");
          break;         
     case COMPRESSION_NEXT:	   
 	 strcpy (compressionid, ""Next RLE"");
          break;         
     case COMPRESSION_CCITTRLEW:    
 	 strcpy (compressionid, ""CITTRLEW"");
          break;         
     case COMPRESSION_PACKBITS:	   
 	 strcpy (compressionid, ""Mac Packbits"");
          break;         
     case COMPRESSION_THUNDERSCAN:  
 	 strcpy (compressionid, ""Thunderscan"");
          break;         
     case COMPRESSION_IT8CTPAD:	   
 	 strcpy (compressionid, ""IT8 padded"");
          break;         
     case COMPRESSION_IT8LW:	   
 	 strcpy (compressionid, ""IT8 RLE"");
          break;         
     case COMPRESSION_IT8MP:	   
 	 strcpy (compressionid, ""IT8 mono"");
          break;         
     case COMPRESSION_IT8BL:	   
 	 strcpy (compressionid, ""IT8 lineart"");
          break;         
     case COMPRESSION_PIXARFILM:	   
 	 strcpy (compressionid, ""Pixar 10 bit"");
          break;         
     case COMPRESSION_PIXARLOG:	   
 	 strcpy (compressionid, ""Pixar 11bit"");
          break;         
     case COMPRESSION_DEFLATE:	   
 	 strcpy (compressionid, ""Deflate"");
          break;         
     case COMPRESSION_ADOBE_DEFLATE:  
 	 strcpy (compressionid, ""Adobe deflate"");
          break;         
     default:
 	 strcpy (compressionid, ""None/unknown"");
          break;         
     }
   TIFFError(""loadImage"", ""Input compression %s"", compressionid);
 #endif
 
   scanlinesize = TIFFScanlineSize(in);
   image->bps = bps;
   image->spp = spp;
   image->planar = planar;
   image->width = width;
   image->length = length;
   image->xres = xres;
   image->yres = yres;
   image->res_unit = res_unit;
   image->compression = input_compression;
   image->photometric = input_photometric;
 #ifdef DEBUG2
   char photometricid[12];
 
   switch (input_photometric)
     {
     case PHOTOMETRIC_MINISWHITE:
          strcpy (photometricid, ""MinIsWhite"");
          break;
     case PHOTOMETRIC_MINISBLACK:
          strcpy (photometricid, ""MinIsBlack"");
          break;
     case PHOTOMETRIC_RGB:
          strcpy (photometricid, ""RGB"");
          break;
     case PHOTOMETRIC_PALETTE:
          strcpy (photometricid, ""Palette"");
          break;
     case PHOTOMETRIC_MASK:
          strcpy (photometricid, ""Mask"");
          break;
     case PHOTOMETRIC_SEPARATED:
          strcpy (photometricid, ""Separated"");
          break;
     case PHOTOMETRIC_YCBCR:
          strcpy (photometricid, ""YCBCR"");
          break;
     case PHOTOMETRIC_CIELAB:
          strcpy (photometricid, ""CIELab"");
          break;
     case PHOTOMETRIC_ICCLAB:
          strcpy (photometricid, ""ICCLab"");
          break;
     case PHOTOMETRIC_ITULAB:
          strcpy (photometricid, ""ITULab"");
          break;
     case PHOTOMETRIC_LOGL:
          strcpy (photometricid, ""LogL"");
          break;
     case PHOTOMETRIC_LOGLUV:
          strcpy (photometricid, ""LOGLuv"");
          break;
     default:
          strcpy (photometricid, ""Unknown"");
          break;
     }
   TIFFError(""loadImage"", ""Input photometric interpretation %s"", photometricid);
 
 #endif
   image->orientation = orientation;
   switch (orientation)
     {
     case 0:
     case ORIENTATION_TOPLEFT:
          image->adjustments = 0;
 	 break;
     case ORIENTATION_TOPRIGHT:
          image->adjustments = MIRROR_HORIZ;
 	 break;
     case ORIENTATION_BOTRIGHT:
          image->adjustments = ROTATECW_180;
 	 break;
     case ORIENTATION_BOTLEFT:
          image->adjustments = MIRROR_VERT; 
 	 break;
     case ORIENTATION_LEFTTOP:
          image->adjustments = MIRROR_VERT | ROTATECW_90;
 	 break;
     case ORIENTATION_RIGHTTOP:
          image->adjustments = ROTATECW_90;
 	 break;
     case ORIENTATION_RIGHTBOT:
          image->adjustments = MIRROR_VERT | ROTATECW_270;
 	 break; 
     case ORIENTATION_LEFTBOT:
          image->adjustments = ROTATECW_270;
 	 break;
     default:
          image->adjustments = 0;
          image->orientation = ORIENTATION_TOPLEFT;
    }
 
   if ((bps == 0) || (spp == 0))
     {
     TIFFError(""loadImage"", ""Invalid samples per pixel (%d) or bits per sample (%d)"",
 	       spp, bps);
     return (-1);
     }
 
   if (TIFFIsTiled(in))
     {
     readunit = TILE;
     tlsize = TIFFTileSize(in);
     ntiles = TIFFNumberOfTiles(in);
     TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
     TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
 
     tile_rowsize  = TIFFTileRowSize(in);      
     if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)
     {
 	TIFFError(""loadImage"", ""File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero."");
 	exit(-1);
     }
     buffsize = tlsize * ntiles;
     if (tlsize != (buffsize / ntiles))
     {
 	TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
 	exit(-1);
     }
 
     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))
       {
       buffsize = ntiles * tl * tile_rowsize;
       if (ntiles != (buffsize / tl / tile_rowsize))
       {
 	TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
 	exit(-1);
       }
       
 #ifdef DEBUG2
       TIFFError(""loadImage"",
 	        ""Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",
                 tlsize, (unsigned long)buffsize);
 #endif
       }
     
     if (dump->infile != NULL)
       dump_info (dump->infile, dump->format, """", 
                  ""Tilesize: %u, Number of Tiles: %u, Tile row size: %u"",
                  tlsize, ntiles, tile_rowsize);
     }
   else
     {
     uint32 buffsize_check;
     readunit = STRIP;
     TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
     stsize = TIFFStripSize(in);
     nstrips = TIFFNumberOfStrips(in);
     if (nstrips == 0 || stsize == 0)
     {
 	TIFFError(""loadImage"", ""File appears to be striped, but the number of stipes or stripe size is zero."");
 	exit(-1);
     }
 
     buffsize = stsize * nstrips;
     if (stsize != (buffsize / nstrips))
     {
 	TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
 	exit(-1);
     }
     buffsize_check = ((length * width * spp * bps) + 7);
     if (length != ((buffsize_check - 7) / width / spp / bps))
     {
 	TIFFError(""loadImage"", ""Integer overflow detected."");
 	exit(-1);
     }
     if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))
       {
       buffsize =  ((length * width * spp * bps) + 7) / 8;
 #ifdef DEBUG2
       TIFFError(""loadImage"",
 	        ""Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",
                 stsize, (unsigned long)buffsize);
 #endif
       }
     
     if (dump->infile != NULL)
       dump_info (dump->infile, dump->format, """",
                  ""Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u"",
 		 stsize, nstrips, rowsperstrip, scanlinesize);
     }
   
   if (input_compression == COMPRESSION_JPEG)
     {   
     jpegcolormode = JPEGCOLORMODE_RGB;
     TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
     }
    
   else 
     {    
     if (input_photometric == PHOTOMETRIC_YCBCR)
       {
       TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
  		           &subsampling_horiz, &subsampling_vert);
       if (subsampling_horiz != 1 || subsampling_vert != 1)
         {
 	TIFFError(""loadImage"", 
 		""Can't copy/convert subsampled image with subsampling %d horiz %d vert"",
                 subsampling_horiz, subsampling_vert);
         return (-1);
         }
 	}
     }
  
   read_buff = *read_ptr;
     
     
    if (!read_buff)
   {
     if( buffsize > 0xFFFFFFFFU - 3 )
     {
         TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer"");
         return (-1);
     }
      read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
   }
    else
      {
      if (prev_readsize < buffsize)
     {
       if( buffsize > 0xFFFFFFFFU - 3 )
        {
           TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer"");
           return (-1);
       }
        new_buff = _TIFFrealloc(read_buff, buffsize+3);
        if (!new_buff)
          {
 	free (read_buff);
         read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
         }
       else
         read_buff = new_buff;
       }
     }
   if (!read_buff)
     {
     TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer"");
     return (-1);
     }
 
   read_buff[buffsize] = 0;
   read_buff[buffsize+1] = 0;
   read_buff[buffsize+2] = 0;
 
   prev_readsize = buffsize;
   *read_ptr = read_buff;
 
    
   switch (readunit) {
     case STRIP:
          if (planar == PLANARCONFIG_CONTIG)
            {
 	     if (!(readContigStripsIntoBuffer(in, read_buff)))
 	     {
 	     TIFFError(""loadImage"", ""Unable to read contiguous strips into buffer"");
 	     return (-1);
              }
            }
          else
            {
 	   if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))
 	     {
 	     TIFFError(""loadImage"", ""Unable to read separate strips into buffer"");
 	     return (-1);
              }
            }
          break;
 
     case TILE:
          if (planar == PLANARCONFIG_CONTIG)
            {
 	   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
 	     {
 	     TIFFError(""loadImage"", ""Unable to read contiguous tiles into buffer"");
 	     return (-1);
              }
            }
          else
            {
 	   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
 	     {
 	     TIFFError(""loadImage"", ""Unable to read separate tiles into buffer"");
 	     return (-1);
              }
            }
          break;
     default: TIFFError(""loadImage"", ""Unsupported image file format"");
           return (-1);
           break;
     }
   if ((dump->infile != NULL) && (dump->level == 2))
     {
     dump_info  (dump->infile, dump->format, ""loadImage"", 
                 ""Image width %d, length %d, Raw image data, %4d bytes"",
                 width, length,  buffsize);
     dump_info  (dump->infile, dump->format, """", 
                 ""Bits per sample %d, Samples per pixel %d"", bps, spp);
 
     for (i = 0; i < length; i++)
       dump_buffer(dump->infile, dump->format, 1, scanlinesize, 
                   i, read_buff + (i * scanlinesize));
     }
   return (0);
   }    ","[6, 7, 315, 316, 317, 318, 319, 320, 322, 326, 327, 329, 330, 331, 5]","tools/tiffcrop.c in libtiff 4.0.6 has out-of-bounds write vulnerabilities in buffers. Reported as MSVR 35093, MSVR 35096, and MSVR 35097."
9510,"Status OpLevelCostEstimator::PredictCropAndResize(const OpContext& op_context,
NodeCosts* node_costs) const {
bool found_unknown_shapes = false;

const auto method = op_context.op_info.attr().find(""method"");
bool use_bilinear_interp;
if (method == op_context.op_info.attr().end() ||
method->second.s() == ""bilinear"") {
use_bilinear_interp = true;
} else if (method->second.s() == ""nearest"") {
use_bilinear_interp = false;
} else {
LOG(WARNING) << ""method attr in CropAndResize invalid; expected bilinear ""
""or nearest."";
return PredictCostOfAnUnknownOp(op_context, node_costs);
}

const int64_t num_boxes = op_context.op_info.inputs(1).shape().dim(0).size();
const auto crop_shape = MaybeGetMinimumShape(
op_context.op_info.outputs(0).shape(), 4, &found_unknown_shapes);
const int64_t crop_height = crop_shape.dim(1).size();
const int64_t crop_width = crop_shape.dim(2).size();
const int64_t output_elements = CalculateTensorElementCount(
op_context.op_info.outputs(0), &found_unknown_shapes);

#define EIGEN_COST(X) Eigen::internal::functor_traits<Eigen::internal::X>::Cost
const auto sub_cost = EIGEN_COST(scalar_difference_op<float>);
const auto add_cost = EIGEN_COST(scalar_sum_op<float>);
const auto mul_cost = EIGEN_COST(scalar_product_op<float>);
auto div_cost = EIGEN_COST(scalar_div_cost<float>);
const auto floor_cost = EIGEN_COST(scalar_floor_op<float>);
const auto ceil_cost = EIGEN_COST(scalar_ceil_op<float>);
auto round_cost = EIGEN_COST(scalar_round_op<float>);
const auto cast_to_float_cost = Eigen::internal::functor_traits<
Eigen::internal::scalar_cast_op<int64_t, float>>::Cost;
#undef EIGEN_COST







int64_t ops = (sub_cost * 6 + mul_cost * 2 + div_cost * 2) * num_boxes;

ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * num_boxes;

ops += (mul_cost * 2 + sub_cost + add_cost) * crop_height * crop_width *
num_boxes;

if (use_bilinear_interp) {

ops += (floor_cost + ceil_cost + sub_cost) * crop_height * num_boxes;

ops += (floor_cost + ceil_cost + sub_cost) * crop_height * crop_width *
num_boxes;

ops +=
(cast_to_float_cost * 4 + add_cost * 3 + sub_cost * 3 + mul_cost * 3) *
output_elements;
} else                           {

ops += round_cost * 2 * crop_height * crop_width * num_boxes;

ops += cast_to_float_cost * output_elements;
}
return PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,
node_costs);
}","[44, 46, 48, 49, 53, 55, 56, 63]","Tensorflow is an Open Source Machine Learning Framework. Under certain scenarios, Grappler component of TensorFlow is vulnerable to an integer overflow during cost estimation for crop and resize. Since the cropping parameters are user controlled, a malicious person can trigger undefined behavior. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range."
6092,"static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)
{
struct task_group *tg = cfs_rq->tg;
struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);
u64 amount = 0, min_amount, expires;
int expires_seq;


min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;

raw_spin_lock(&cfs_b->lock);
if (cfs_b->quota == RUNTIME_INF)
amount = min_amount;
else {
start_cfs_bandwidth(cfs_b);

if (cfs_b->runtime > 0) {
amount = min(cfs_b->runtime, min_amount);
cfs_b->runtime -= amount;
cfs_b->idle = 0;
}
}
expires_seq = cfs_b->expires_seq;
expires = cfs_b->runtime_expires;
raw_spin_unlock(&cfs_b->lock);

cfs_rq->runtime_remaining += amount;





if (cfs_rq->expires_seq != expires_seq) {
cfs_rq->expires_seq = expires_seq;
cfs_rq->runtime_expires = expires;
}

return cfs_rq->runtime_remaining > 0;
}","[5, 6, 23, 24, 33, 34, 35]","kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)"
199899," local void process(char *path)
 {
     int method = -1;                 
     size_t len;                      
     struct stat st;                  
      
     static char *sufs[] = {"".z"", ""-z"", ""_z"", "".Z"", "".gz"", ""-gz"", "".zz"", ""-zz"",
                            "".zip"", "".ZIP"", "".tgz"", NULL};
 
      
     if (path == NULL) {
         strcpy(g.inf, ""<stdin>"");
         g.ind = 0;
         g.name = NULL;
         g.mtime = g.headis & 2 ?
                   (fstat(g.ind, &st) ? time(NULL) : st.st_mtime) : 0;
         len = 0;
     }
     else {
          
         if (path != g.inf) {
             strncpy(g.inf, path, sizeof(g.inf));
             if (g.inf[sizeof(g.inf) - 1])
                 bail(""name too long: "", path);
         }
         len = strlen(g.inf);
 
          
         if (lstat(g.inf, &st)) {
             if (errno == ENOENT && (g.list || g.decode)) {
                 char **try = sufs;
                 do {
                     if (*try == NULL || len + strlen(*try) >= sizeof(g.inf))
                         break;
                     strcpy(g.inf + len, *try++);
                     errno = 0;
                 } while (lstat(g.inf, &st) && errno == ENOENT);
             }
 #ifdef EOVERFLOW
             if (errno == EOVERFLOW || errno == EFBIG)
                 bail(g.inf,
                     "" too large -- not compiled with large file support"");
 #endif
             if (errno) {
                 g.inf[len] = 0;
                 complain(""%s does not exist -- skipping"", g.inf);
                 return;
             }
             len = strlen(g.inf);
         }
 
          
         if ((st.st_mode & S_IFMT) != S_IFREG &&
             (st.st_mode & S_IFMT) != S_IFLNK &&
             (st.st_mode & S_IFMT) != S_IFDIR) {
             complain(""%s is a special file or device -- skipping"", g.inf);
             return;
         }
         if ((st.st_mode & S_IFMT) == S_IFLNK && !g.force && !g.pipeout) {
             complain(""%s is a symbolic link -- skipping"", g.inf);
             return;
         }
         if ((st.st_mode & S_IFMT) == S_IFDIR && !g.recurse) {
             complain(""%s is a directory -- skipping"", g.inf);
             return;
         }
 
          
         if ((st.st_mode & S_IFMT) == S_IFDIR) {
             char *roll, *item, *cut, *base, *bigger;
             size_t len, hold;
             DIR *here;
             struct dirent *next;
 
              
             here = opendir(g.inf);
             if (here == NULL)
                 return;
             hold = 512;
             roll = MALLOC(hold);
             if (roll == NULL)
                 bail(""not enough memory"", """");
             *roll = 0;
             item = roll;
             while ((next = readdir(here)) != NULL) {
                 if (next->d_name[0] == 0 ||
                     (next->d_name[0] == '.' && (next->d_name[1] == 0 ||
                      (next->d_name[1] == '.' && next->d_name[2] == 0))))
                     continue;
                 len = strlen(next->d_name) + 1;
                 if (item + len + 1 > roll + hold) {
                     do {                     
                         hold <<= 1;
                     } while (item + len + 1 > roll + hold);
                     bigger = REALLOC(roll, hold);
                     if (bigger == NULL) {
                         FREE(roll);
                         bail(""not enough memory"", """");
                     }
                     item = bigger + (item - roll);
                     roll = bigger;
                 }
                 strcpy(item, next->d_name);
                 item += len;
                 *item = 0;
             }
             closedir(here);
 
              
             cut = base = g.inf + strlen(g.inf);
             if (base > g.inf && base[-1] != (unsigned char)'/') {
                 if ((size_t)(base - g.inf) >= sizeof(g.inf))
                     bail(""path too long"", g.inf);
                 *base++ = '/';
             }
             item = roll;
             while (*item) {
                 strncpy(base, item, sizeof(g.inf) - (base - g.inf));
                 if (g.inf[sizeof(g.inf) - 1]) {
                     strcpy(g.inf + (sizeof(g.inf) - 4), ""..."");
                     bail(""path too long: "", g.inf);
                 }
                 process(g.inf);
                 item += strlen(item) + 1;
             }
             *cut = 0;
 
              
             FREE(roll);
             return;
         }
 
          
         if (!(g.force || g.list || g.decode) && len >= strlen(g.sufx) &&
                 strcmp(g.inf + len - strlen(g.sufx), g.sufx) == 0) {
             complain(""%s ends with %s -- skipping"", g.inf, g.sufx);
             return;
         }
 
          
         if (g.decode == 1 && !g.pipeout && !g.list) {
             int suf = compressed_suffix(g.inf);
             if (suf == 0) {
                 complain(""%s does not have compressed suffix -- skipping"",
                          g.inf);
                 return;
             }
             len -= suf;
         }
 
          
         g.ind = open(g.inf, O_RDONLY, 0);
         if (g.ind < 0)
             bail(""read error on "", g.inf);
 
          
         g.name = g.headis & 1 ? justname(g.inf) : NULL;
         g.mtime = g.headis & 2 ? st.st_mtime : 0;
     }
     SET_BINARY_MODE(g.ind);
 
      
     g.hname = NULL;
     if (g.decode) {
         in_init();
         method = get_header(1);
         if (method != 8 && method != 257 &&
                  
                 !(method == -2 && g.force && g.pipeout && g.decode != 2 &&
                   !g.list)) {
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             if (method != -1)
                 complain(method < 0 ? ""%s is not compressed -- skipping"" :
                          ""%s has unknown compression method -- skipping"",
                          g.inf);
             return;
         }
 
          
         if (g.decode == 2) {
             if (method == 8)
                 infchk();
             else {
                 unlzw();
                 if (g.list) {
                     g.in_tot -= 3;
                     show_info(method, 0, g.out_tot, 0);
                 }
             }
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             return;
         }
     }
 
      
     if (g.list) {
         list_info();
         RELEASE(g.hname);
         if (g.ind != 0)
             close(g.ind);
         return;
     }
 
      
     if (path == NULL || g.pipeout) {
          
         g.outf = MALLOC(strlen(""<stdout>"") + 1);
         if (g.outf == NULL)
             bail(""not enough memory"", """");
         strcpy(g.outf, ""<stdout>"");
         g.outd = 1;
         if (!g.decode && !g.force && isatty(g.outd))
             bail(""trying to write compressed data to a terminal"",
                   "" (use -f to force)"");
      }
      else {
        char *to, *repl;
         char *to = g.inf, *sufx = """";
         size_t pre = 0;
 
          
        to = g.inf;
        if (g.decode && (g.headis & 1) != 0 && g.hname != NULL) {
            to = g.hname;
            len = strlen(g.hname);
         if (g.decode) {
              
             if ((g.headis & 1) != 0 && g.hname != NULL) {
                 pre = justname(g.inf) - g.inf;
                 to = justname(g.hname);
                 len = strlen(to);
             }
              
             else if (strcmp(to + len, "".tgz"") == 0)
                 sufx = "".tar"";
          }
         
        repl = g.decode && strcmp(to + len, "".tgz"") ? """" : "".tar"";
         else
              
             sufx = g.sufx;
  
           
        g.outf = MALLOC(len + (g.decode ? strlen(repl) : strlen(g.sufx)) + 1);
         g.outf = MALLOC(pre + len + strlen(sufx) + 1);
          if (g.outf == NULL)
              bail(""not enough memory"", """");
        memcpy(g.outf, to, len);
        strcpy(g.outf + len, g.decode ? repl : g.sufx);
         memcpy(g.outf, g.inf, pre);
         memcpy(g.outf + pre, to, len);
         strcpy(g.outf + pre + len, sufx);
          g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY |
                             (g.force ? 0 : O_EXCL), 0600);
                               (g.force ? 0 : O_EXCL), 0600);
  
           
          if (g.outd < 0 && errno == EEXIST && isatty(0) && g.verbosity) {
             int ch, reply;
 
             fprintf(stderr, ""%s exists -- overwrite (y/n)? "", g.outf);
             fflush(stderr);
             reply = -1;
             do {
                 ch = getchar();
                 if (reply < 0 && ch != ' ' && ch != '\t')
                     reply = ch == 'y' || ch == 'Y' ? 1 : 0;
             } while (ch != EOF && ch != '\n' && ch != '\r');
             if (reply == 1)
                 g.outd = open(g.outf, O_CREAT | O_TRUNC | O_WRONLY,
                               0600);
         }
 
          
         if (g.outd < 0 && errno == EEXIST) {
             complain(""%s exists -- skipping"", g.outf);
             RELEASE(g.outf);
             RELEASE(g.hname);
             if (g.ind != 0)
                 close(g.ind);
             return;
         }
 
          
         if (g.outd < 0)
             bail(""write error on "", g.outf);
     }
     SET_BINARY_MODE(g.outd);
     RELEASE(g.hname);
 
      
     if (g.verbosity > 1)
         fprintf(stderr, ""%s to %s "", g.inf, g.outf);
     if (g.decode) {
         if (method == 8)
             infchk();
         else if (method == 257)
             unlzw();
         else
             cat();
     }
 #ifndef NOTHREAD
     else if (g.procs > 1)
         parallel_compress();
 #endif
     else
         single_compress(0);
     if (g.verbosity > 1) {
         putc('\n', stderr);
         fflush(stderr);
     }
 
      
     if (g.ind != 0)
         close(g.ind);
     if (g.outd != 1) {
         if (close(g.outd))
             bail(""write error on "", g.outf);
         g.outd = -1;             
         if (g.ind != 0) {
             copymeta(g.inf, g.outf);
             if (!g.keep)
                 unlink(g.inf);
         }
         if (g.decode && (g.headis & 2) != 0 && g.stamp)
             touch(g.outf, g.stamp);
     }
     RELEASE(g.outf);
 }","[222, 223, 224, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 243, 244, 245, 249, 254, 255, 256, 259, 221, 226, 227, 228, 229, 241, 242, 248, 252, 253, 258]",Multiple directory traversal vulnerabilities in pigz 2.3.1 allow remote attackers to write to arbitrary files via a (1) full pathname or (2) .. (dot dot) in an archive.
206129," png_convert_to_rfc1123(png_structp png_ptr, png_timep ptime)
 {
    static PNG_CONST char short_months[12][4] =
         {""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
          ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""};
  
     if (png_ptr == NULL)
        return (NULL);
 
     if (png_ptr->time_buffer == NULL)
     {
        png_ptr->time_buffer = (png_charp)png_malloc(png_ptr, (png_uint_32)(29*
          png_sizeof(char)));
    }
 
 #ifdef _WIN32_WCE
     {
        wchar_t time_buf[29];
        wsprintf(time_buf, TEXT(""%d %S %d %02d:%02d:%02d +0000""),
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
           ptime->day % 32, short_months[(ptime->month - 1U) % 12],
          ptime->year, ptime->hour % 24, ptime->minute % 60,
            ptime->second % 61);
        WideCharToMultiByte(CP_ACP, 0, time_buf, -1, png_ptr->time_buffer,
           29, NULL, NULL);
    }
 #else
 #ifdef USE_FAR_KEYWORD
     {
        char near_time_buf[29];
        png_snprintf6(near_time_buf, 29, ""%d %s %d %02d:%02d:%02d +0000"",
          ptime->day % 32, short_months[(ptime->month - 1) % 12],
           ptime->day % 32, short_months[(ptime->month - 1U) % 12],
            ptime->year, ptime->hour % 24, ptime->minute % 60,
            ptime->second % 61);
        png_memcpy(png_ptr->time_buffer, near_time_buf,
            29*png_sizeof(char));
     }
  #else
     png_snprintf6(png_ptr->time_buffer, 29, ""%d %s %d %02d:%02d:%02d +0000"",
       ptime->day % 32, short_months[(ptime->month - 1) % 12],
        ptime->day % 32, short_months[(ptime->month - 1U) % 12],
         ptime->year, ptime->hour % 24, ptime->minute % 60,
         ptime->second % 61);
  #endif
 #endif  
    return ((png_charp)png_ptr->time_buffer);
 }","[9, 21, 33, 42, 20, 32, 41]","Multiple buffer overflows in the (1) png_set_PLTE and (2) png_get_PLTE functions in libpng before 1.0.64, 1.1.x and 1.2.x before 1.2.54, 1.3.x and 1.4.x before 1.4.17, 1.5.x before 1.5.24, and 1.6.x before 1.6.19 allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a small bit-depth value in an IHDR (aka image header) chunk in a PNG image."
205990," v8::Local<v8::Value> PrivateScriptRunner::runDOMMethod(ScriptState* scriptState, ScriptState* scriptStateInUserScript, const char* className, const char* methodName, v8::Local<v8::Value> holder, int argc, v8::Local<v8::Value> argv[])
 {
     v8::Local<v8::Object> classObject = classObjectOfPrivateScript(scriptState, className);
     v8::Local<v8::Value> method;
     if (!classObject->Get(scriptState->context(), v8String(scriptState->isolate(), methodName)).ToLocal(&method) || !method->IsFunction()) {
         fprintf(stderr, ""Private script error: Target DOM method was not found. (Class name = %s, Method name = %s)\n"", className, methodName);
         RELEASE_NOTREACHED();
     }
      initializeHolderIfNeeded(scriptState, classObject, holder);
      v8::TryCatch block(scriptState->isolate());
      v8::Local<v8::Value> result;
    if (!V8ScriptRunner::callFunction(v8::Local<v8::Function>::Cast(method), scriptState->getExecutionContext(), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
     if (!V8ScriptRunner::callInternalFunction(v8::Local<v8::Function>::Cast(method), holder, argc, argv, scriptState->isolate()).ToLocal(&result)) {
          rethrowExceptionInPrivateScript(scriptState->isolate(), block, scriptStateInUserScript, ExceptionState::ExecutionContext, methodName, className);
          block.ReThrow();
          return v8::Local<v8::Value>();
     }
     return result;
 }","[13, 12]","Blink in Google Chrome prior to 54.0.2840.59 for Windows, Mac, and Linux; 54.0.2840.85 for Android permitted execution of v8 microtasks while the DOM was in an inconsistent state, which allowed a remote attacker to inject arbitrary scripts or HTML (UXSS) via crafted HTML pages."
202252," static int read_private_key(RSA *rsa)
 {
 	int r;
 	sc_path_t path;
 	sc_file_t *file;
 	const sc_acl_entry_t *e;
 
 	u8 buf[2048], *p = buf;
 	size_t bufsize, keysize;
 
 	r = select_app_df();
 	if (r)
 		return 1;
 	sc_format_path(""I0012"", &path);
 	r = sc_select_file(card, &path, &file);
 	if (r) {
 		fprintf(stderr, ""Unable to select private key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
  	e = sc_file_get_acl_entry(file, SC_AC_OP_READ);
  	if (e == NULL || e->method == SC_AC_NEVER)
  		return 10;
	bufsize = file->size;
 	bufsize = MIN(file->size, sizeof buf);
  	sc_file_free(file);
  	r = sc_read_binary(card, 0, buf, bufsize, 0);
  	if (r < 0) {
 		fprintf(stderr, ""Unable to read private key file: %s\n"", sc_strerror(r));
 		return 2;
 	}
 	bufsize = r;
 	do {
 		if (bufsize < 4)
 			return 3;
 		keysize = (p[0] << 8) | p[1];
 		if (keysize == 0)
 			break;
 		if (keysize < 3)
 			return 3;
 		if (p[2] == opt_key_num)
 			break;
 		p += keysize;
 		bufsize -= keysize;
 	} while (1);
 	if (keysize == 0) {
 		printf(""Key number %d not found.\n"", opt_key_num);
 		return 2;
 	}
 	return parse_private_key(p, keysize, rsa);
 }","[24, 23]",A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
199795," void ping_unhash(struct sock *sk)
 {
 	struct inet_sock *isk = inet_sk(sk);
 	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
  	if (sk_hashed(sk)) {
  		write_lock_bh(&ping_table.lock);
  		hlist_nulls_del(&sk->sk_nulls_node);
 		sk_nulls_node_init(&sk->sk_nulls_node);
  		sock_put(sk);
  		isk->inet_num = 0;
  		isk->inet_sport = 0;
 		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
 		write_unlock_bh(&ping_table.lock);
 	}
 }",[8],"The ping_unhash function in net/ipv4/ping.c in the Linux kernel before 4.0.3 does not initialize a certain list data structure during an unhash operation, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) by leveraging the ability to make a SOCK_DGRAM socket system call for the IPPROTO_ICMP or IPPROTO_ICMPV6 protocol, and then making a connect system call after a disconnect."
206731," void NetworkHandler::ContinueInterceptedRequest(
     const std::string& interception_id,
     Maybe<std::string> error_reason,
     Maybe<std::string> base64_raw_response,
     Maybe<std::string> url,
     Maybe<std::string> method,
     Maybe<std::string> post_data,
     Maybe<protocol::Network::Headers> headers,
      Maybe<protocol::Network::AuthChallengeResponse> auth_challenge_response,
      std::unique_ptr<ContinueInterceptedRequestCallback> callback) {
    DevToolsInterceptorController* interceptor =
      DevToolsInterceptorController::FromBrowserContext(
          process_->GetBrowserContext());
       DevToolsInterceptorController::FromBrowserContext(browser_context_);
    if (!interceptor) {
      callback->sendFailure(Response::InternalError());
      return;
   }
 
   base::Optional<std::string> raw_response;
   if (base64_raw_response.isJust()) {
     std::string decoded;
     if (!base::Base64Decode(base64_raw_response.fromJust(), &decoded)) {
       callback->sendFailure(Response::InvalidParams(""Invalid rawResponse.""));
       return;
     }
     raw_response = decoded;
   }
 
   base::Optional<net::Error> error;
   bool mark_as_canceled = false;
   if (error_reason.isJust()) {
     bool ok;
     error = NetErrorFromString(error_reason.fromJust(), &ok);
     if (!ok) {
       callback->sendFailure(Response::InvalidParams(""Invalid errorReason.""));
       return;
     }
 
     mark_as_canceled = true;
   }
 
   interceptor->ContinueInterceptedRequest(
       interception_id,
       std::make_unique<DevToolsURLRequestInterceptor::Modifications>(
           std::move(error), std::move(raw_response), std::move(url),
           std::move(method), std::move(post_data), std::move(headers),
           std::move(auth_challenge_response), mark_as_canceled),
       std::move(callback));
 }","[14, 12, 13]",An object lifetime issue in the developer tools network handler in Google Chrome prior to 66.0.3359.117 allowed a local attacker to execute arbitrary code via a crafted HTML page.
197805," static void coroutine_fn v9fs_wstat(void *opaque)
 {
     int32_t fid;
     int err = 0;
     int16_t unused;
     V9fsStat v9stat;
     size_t offset = 7;
      struct stat stbuf;
      V9fsFidState *fidp;
      V9fsPDU *pdu = opaque;
     V9fsState *s = pdu->s;
  
      v9fs_stat_init(&v9stat);
      err = pdu_unmarshal(pdu, offset, ""dwS"", &fid, &unused, &v9stat);
         goto out_nofid;
     }",[11],v9fs_wstat in hw/9pfs/9p.c in QEMU allows guest OS users to cause a denial of service (crash) because of a race condition during file renaming.
206377," bool ClientControlledShellSurface::OnPreWidgetCommit() {
   if (!widget_) {
     if (!pending_geometry_.IsEmpty())
       origin_ = pending_geometry_.origin();
     CreateShellSurfaceWidget(ash::ToWindowShowState(pending_window_state_));
   }
 
   ash::wm::WindowState* window_state = GetWindowState();
   if (window_state->GetStateType() == pending_window_state_) {
     if (window_state->IsPip() && !window_state->is_dragged()) {
       client_controlled_state_->set_next_bounds_change_animation_type(
           ash::wm::ClientControlledState::kAnimationAnimated);
     }
 
     return true;
   }
 
   if (IsPinned(window_state)) {
     VLOG(1) << ""State change was requested while pinned"";
     return true;
   }
 
   auto animation_type = ash::wm::ClientControlledState::kAnimationNone;
   switch (pending_window_state_) {
     case ash::WindowStateType::kNormal:
       if (widget_->IsMaximized() || widget_->IsFullscreen()) {
         animation_type = ash::wm::ClientControlledState::kAnimationCrossFade;
       }
       break;
 
     case ash::WindowStateType::kMaximized:
     case ash::WindowStateType::kFullscreen:
       if (!window_state->IsPip())
         animation_type = ash::wm::ClientControlledState::kAnimationCrossFade;
       break;
 
     default:
       break;
   }
 
   if (pending_window_state_ == ash::WindowStateType::kPip) {
     if (ash::features::IsPipRoundedCornersEnabled()) {
       decorator_ = std::make_unique<ash::RoundedCornerDecorator>(
           window_state->window(), host_window(), host_window()->layer(),
           ash::kPipRoundedCornerRadius);
     }
   } else {
     decorator_.reset();   
   }
  
    bool wasPip = window_state->IsPip();
  
    
    
   base::AutoReset<bool> resetter(&ignore_bounds_change_request_, true);
    if (client_controlled_state_->EnterNextState(window_state,
                                                 pending_window_state_)) {
      client_controlled_state_->set_next_bounds_change_animation_type(
         animation_type);
   }
 
   if (wasPip && !window_state->IsMinimized()) {
     ash::Shell::Get()->split_view_controller()->EndSplitView(
         ash::SplitViewController::EndReason::kPipExpanded);
     window_state->Activate();
   }
 
   return true;
 }","[53, 54, 55]","PDFium in Google Chrome prior to 57.0.2987.98 for Windows could be made to increment off the end of a buffer, which allowed a remote attacker to potentially exploit heap corruption via a crafted PDF file."
9948,"TEST_F(RequantizeTest, InvalidOutputMin) {
ConfigureRequantize();
const int value_count = 3;

AddInputFromArray<qint32>(TensorShape({value_count}),
{-(1 << 23), 0, (1 << 23)});
AddInputFromArray<float>(TensorShape({1}), {-256.0f});
AddInputFromArray<float>(TensorShape({1}), {256.0f});
AddInputFromArray<float>(TensorShape({1}), {0.01f});
AddInputFromArray<float>(TensorShape({1}), {1.0f});
EXPECT_EQ(""requested_output_min must be <= 0, but got 0.01"",
RunOpKernel().error_message());
}","[7, 8, 9, 10]","TensorFlow is an open source platform for machine learning. If `QuantizedInstanceNorm` is given `x_min` or `x_max` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 785d67a78a1d533759fcd2f5e8d6ef778de849e0. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."
199721," int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			  const struct tcphdr *th, unsigned int len)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	int queued = 0;
 	int res;
 
 	tp->rx_opt.saw_tstamp = 0;
 
 	switch (sk->sk_state) {
 	case TCP_CLOSE:
 		goto discard;
 
 	case TCP_LISTEN:
 		if (th->ack)
 			return 1;
 
 		if (th->rst)
  			goto discard;
  
  		if (th->syn) {
 			if (th->fin)
 				goto discard;
  			if (icsk->icsk_af_ops->conn_request(sk, skb) < 0)
  				return 1;
  
 			 
 			kfree_skb(skb);
 			return 0;
 		}
 		goto discard;
 
 	case TCP_SYN_SENT:
 		queued = tcp_rcv_synsent_state_process(sk, skb, th, len);
 		if (queued >= 0)
 			return queued;
 
 		 
 		tcp_urg(sk, skb, th);
 		__kfree_skb(skb);
 		tcp_data_snd_check(sk);
 		return 0;
 	}
 
 	res = tcp_validate_incoming(sk, skb, th, 0);
 	if (res <= 0)
 		return -res;
 
 	 
 	if (th->ack) {
 		int acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH) > 0;
 
 		switch (sk->sk_state) {
 		case TCP_SYN_RECV:
 			if (acceptable) {
 				tp->copied_seq = tp->rcv_nxt;
 				smp_mb();
 				tcp_set_state(sk, TCP_ESTABLISHED);
 				sk->sk_state_change(sk);
 
 				 
 				if (sk->sk_socket)
 					sk_wake_async(sk,
 						      SOCK_WAKE_IO, POLL_OUT);
 
 				tp->snd_una = TCP_SKB_CB(skb)->ack_seq;
 				tp->snd_wnd = ntohs(th->window) <<
 					      tp->rx_opt.snd_wscale;
 				tcp_init_wl(tp, TCP_SKB_CB(skb)->seq);
 
 				if (tp->rx_opt.tstamp_ok)
 					tp->advmss -= TCPOLEN_TSTAMP_ALIGNED;
 
 				 
 				icsk->icsk_af_ops->rebuild_header(sk);
 
 				tcp_init_metrics(sk);
 
 				tcp_init_congestion_control(sk);
 
 				 
 				tp->lsndtime = tcp_time_stamp;
 
 				tcp_mtup_init(sk);
 				tcp_initialize_rcv_mss(sk);
 				tcp_init_buffer_space(sk);
 				tcp_fast_path_on(tp);
 			} else {
 				return 1;
 			}
 			break;
 
 		case TCP_FIN_WAIT1:
 			if (tp->snd_una == tp->write_seq) {
 				tcp_set_state(sk, TCP_FIN_WAIT2);
 				sk->sk_shutdown |= SEND_SHUTDOWN;
 				dst_confirm(__sk_dst_get(sk));
 
 				if (!sock_flag(sk, SOCK_DEAD))
 					 
 					sk->sk_state_change(sk);
 				else {
 					int tmo;
 
 					if (tp->linger2 < 0 ||
 					    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
 					     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {
 						tcp_done(sk);
 						NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
 						return 1;
 					}
 
 					tmo = tcp_fin_time(sk);
 					if (tmo > TCP_TIMEWAIT_LEN) {
 						inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);
 					} else if (th->fin || sock_owned_by_user(sk)) {
 						 
 						inet_csk_reset_keepalive_timer(sk, tmo);
 					} else {
 						tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);
 						goto discard;
 					}
 				}
 			}
 			break;
 
 		case TCP_CLOSING:
 			if (tp->snd_una == tp->write_seq) {
 				tcp_time_wait(sk, TCP_TIME_WAIT, 0);
 				goto discard;
 			}
 			break;
 
 		case TCP_LAST_ACK:
 			if (tp->snd_una == tp->write_seq) {
 				tcp_update_metrics(sk);
 				tcp_done(sk);
 				goto discard;
 			}
 			break;
 		}
 	} else
 		goto discard;
 
 	 
 	tcp_urg(sk, skb, th);
 
 	 
 	switch (sk->sk_state) {
 	case TCP_CLOSE_WAIT:
 	case TCP_CLOSING:
 	case TCP_LAST_ACK:
 		if (!before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt))
 			break;
 	case TCP_FIN_WAIT1:
 	case TCP_FIN_WAIT2:
 		 
 		if (sk->sk_shutdown & RCV_SHUTDOWN) {
 			if (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
 			    after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt)) {
 				NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
 				tcp_reset(sk);
 				return 1;
 			}
 		}
 		 
 	case TCP_ESTABLISHED:
 		tcp_data_queue(sk, skb);
 		queued = 1;
 		break;
 	}
 
 	 
 	if (sk->sk_state != TCP_CLOSE) {
 		tcp_data_snd_check(sk);
 		tcp_ack_snd_check(sk);
 	}
 
 	if (!queued) {
 discard:
 		__kfree_skb(skb);
 	}
 	return 0;
 }","[23, 24]","The tcp_rcv_state_process function in net/ipv4/tcp_input.c in the Linux kernel before 3.2.24 allows remote attackers to cause a denial of service (kernel resource consumption) via a flood of SYN+FIN TCP packets, a different vulnerability than CVE-2012-2663."
2347,"int pam_sm_acct_mgmt (pam_handle_t * pamh, int flags,
int argc, const char **argv) {

int retval, ctrl, status=PAM_AUTH_ERR;
char *user;
char *tty;
char *r_addr;
struct areply arep;
struct tac_attrib *attr = NULL;
int tac_fd;

user = tty = r_addr = NULL;






ctrl = _pam_parse (argc, argv);

if (ctrl & PAM_TAC_DEBUG)
syslog (LOG_DEBUG, ""%s: called (pam_tacplus v%u.%u.%u)""
, __FUNCTION__, PAM_TAC_VMAJ, PAM_TAC_VMIN, PAM_TAC_VPAT);

if ((user = _pam_get_user(pamh)) == NULL)
return PAM_USER_UNKNOWN;

if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: username obtained [%s]"", __FUNCTION__, user);

tty = _pam_get_terminal(pamh);
if(!strncmp(tty, ""/dev/"", 5))
tty += 5;
if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: tty obtained [%s]"", __FUNCTION__, tty);

r_addr = _pam_get_rhost(pamh);
if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: rhost obtained [%s]"", __FUNCTION__, r_addr);





if(active_server.addr == NULL) {
_pam_log (LOG_ERR, ""user not authenticated by TACACS+"");
return PAM_AUTH_ERR;
}
if (ctrl & PAM_TAC_DEBUG)
syslog (LOG_DEBUG, ""%s: active server is [%s]"", __FUNCTION__,
tac_ntop(active_server.addr->ai_addr));



if(!*tac_service) {
_pam_log (LOG_ERR, ""SM: TACACS+ service type not configured"");
return PAM_AUTH_ERR;
}
if(!*tac_protocol) {
_pam_log (LOG_ERR, ""SM: TACACS+ protocol type not configured (IGNORED)"");
}

tac_add_attrib(&attr, ""service"", tac_service);
if(tac_protocol[0] != '\0')
tac_add_attrib(&attr, ""protocol"", tac_protocol);

tac_fd = tac_connect_single(active_server.addr, active_server.key, NULL, tac_timeout);
if(tac_fd < 0) {
_pam_log (LOG_ERR, ""TACACS+ server unavailable"");
if(arep.msg != NULL)
free (arep.msg);
return PAM_AUTH_ERR;
}

retval = tac_author_send(tac_fd, user, tty, r_addr, attr);

tac_free_attrib(&attr);

if(retval < 0) {
_pam_log (LOG_ERR, ""error getting authorization"");
if(arep.msg != NULL)
free (arep.msg);

close(tac_fd);
return PAM_AUTH_ERR;
}

if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: sent authorization request"", __FUNCTION__);

tac_author_read(tac_fd, &arep);

if(arep.status != AUTHOR_STATUS_PASS_ADD &&
arep.status != AUTHOR_STATUS_PASS_REPL) {

_pam_log (LOG_ERR, ""TACACS+ authorisation failed for [%s]"", user);
if(arep.msg != NULL)
free (arep.msg);

close(tac_fd);
return PAM_PERM_DENIED;
}

if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: user [%s] successfully authorized"", __FUNCTION__, user);

status = PAM_SUCCESS;

attr = arep.attr;
while (attr != NULL)  {
char attribute[attr->attr_len];
char value[attr->attr_len];
char *sep;

sep = index(attr->attr, '=');
if(sep == NULL)
sep = index(attr->attr, '*');
if(sep != NULL) {
bcopy(attr->attr, attribute, attr->attr_len-strlen(sep));
attribute[attr->attr_len-strlen(sep)] = '\0';
bcopy(sep, value, strlen(sep));
value[strlen(sep)] = '\0';

size_t i;
for (i = 0; attribute[i] != '\0'; i++) {
attribute[i] = toupper(attribute[i]);
if (attribute[i] == '-')
attribute[i] = '_';
}

if (ctrl & PAM_TAC_DEBUG)
syslog(LOG_DEBUG, ""%s: returned attribute `%s%s' from server"", __FUNCTION__, attribute, value);


if (pam_putenv(pamh, strncat(attribute, value, strlen(value))) != PAM_SUCCESS)
syslog(LOG_WARNING, ""%s: unable to set PAM environment"", __FUNCTION__);

} else {
syslog(LOG_WARNING, ""%s: invalid attribute `%s', no separator"", __FUNCTION__, attr->attr);
}
attr = attr->next;
}


if(arep.attr != NULL)
tac_free_attrib(&arep.attr);

if(arep.msg != NULL)
free (arep.msg);

close(tac_fd);

return status;
}",[19],"In pam_tacplus.c in pam_tacplus before 1.4.1, pam_sm_acct_mgmt does not zero out the arep data structure."
204596," void BluetoothOptionsHandler::DeviceFound(const std::string& adapter_id,
                                            chromeos::BluetoothDevice* device) {
    VLOG(2) << ""Device found on "" << adapter_id;
    DCHECK(device);
  web_ui_->CallJavascriptFunction(
      ""options.SystemOptions.addBluetoothDevice"", device->AsDictionary());
   SendDeviceNotification(device, NULL);
  }","[7, 5, 6]","Google Chrome before 17.0.963.46 does not properly handle PDF FAX images, which allows remote attackers to cause a denial of service (out-of-bounds read) via unspecified vectors."
206289,"  void RenderFrameHostManager::EnsureRenderFrameHostVisibilityConsistent() {
  if (render_frame_host_->GetView() &&
      render_frame_host_->render_view_host()->GetWidget()->is_hidden() !=
          delegate_->IsHidden()) {
   RenderWidgetHostView* view = GetRenderWidgetHostView();
   if (view && static_cast<RenderWidgetHostImpl*>(view->GetRenderWidgetHost())
                       ->is_hidden() != delegate_->IsHidden()) {
      if (delegate_->IsHidden()) {
      render_frame_host_->GetView()->Hide();
       view->Hide();
      } else {
      render_frame_host_->GetView()->Show();
       view->Show();
      }
    }
  }","[5, 6, 7, 10, 13, 2, 3, 4, 9, 12]",Inappropriate implementation in interstitials in Google Chrome prior to 60.0.3112.78 for Mac allowed a remote attacker to spoof the contents of the omnibox via a crafted HTML page.
200388," static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 					     struct xt_table_info *newinfo,
 					     const unsigned char *base,
 					     const unsigned char *limit,
 					     const unsigned int *hook_entries,
 					     const unsigned int *underflows,
 					     unsigned int valid_hooks)
 {
 	unsigned int h;
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
 	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
 	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}
 
 	if (e->next_offset
 	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
 		duprintf(""checking: element %p size %u\n"",
 			 e, e->next_offset);
 		return -EINVAL;
 	}
 
  	if (!arp_checkentry(&e->arp))
  		return -EINVAL;
  
	err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
 	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
 				     e->next_offset);
  	if (err)
  		return err;
  
 	 
 	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
 		if (!(valid_hooks & (1 << h)))
 			continue;
 		if ((unsigned char *)e - base == hook_entries[h])
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
 				pr_debug(""Underflows must be unconditional and ""
 					 ""use the STANDARD target with ""
 					 ""ACCEPT/DROP\n"");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];
 		}
 	}
 
 	 
 	e->counters = ((struct xt_counters) { 0, 0 });
 	e->comefrom = 0;
 	return 0;
 }","[30, 31, 29]",The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.
208189," void InputDispatcher::enqueueDispatchEntryLocked(
  const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,
  int32_t dispatchMode) {
  int32_t inputTargetFlags = inputTarget->flags;
  if (!(inputTargetFlags & dispatchMode)) {
  return;
  }
     inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;
 
  DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry,  
             inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,
             inputTarget->scaleFactor);
 
  switch (eventEntry->type) {
  case EventEntry::TYPE_KEY: {
  KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);
         dispatchEntry->resolvedAction = keyEntry->action;
         dispatchEntry->resolvedFlags = keyEntry->flags;
 
  if (!connection->inputState.trackKey(keyEntry,
                 dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {
 #if DEBUG_DISPATCH_CYCLE
             ALOGD(""channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event"",
                     connection->getInputChannelName());
 #endif
  delete dispatchEntry;
  return;  
  }
  break;
  }
 
  case EventEntry::TYPE_MOTION: {
  MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);
  if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;
  } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;
  } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;
  } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;
  } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;
  } else {
             dispatchEntry->resolvedAction = motionEntry->action;
  }
  if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE
  && !connection->inputState.isHovering(
                         motionEntry->deviceId, motionEntry->source, motionEntry->displayId)) {
 #if DEBUG_DISPATCH_CYCLE
         ALOGD(""channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event"",
                 connection->getInputChannelName());
 #endif
             dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;
  }
 
         dispatchEntry->resolvedFlags = motionEntry->flags;
 
          if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {
              dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;
          }
         if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) {
             dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
         }
  
          if (!connection->inputState.trackMotion(motionEntry,
                  dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {
 #if DEBUG_DISPATCH_CYCLE
             ALOGD(""channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event"",
                     connection->getInputChannelName());
 #endif
  delete dispatchEntry;
  return;  
  }
  break;
  }
  }
 
  if (dispatchEntry->hasForegroundTarget()) {
         incrementPendingForegroundDispatchesLocked(eventEntry);
  }
 
     connection->outboundQueue.enqueueAtTail(dispatchEntry);
     traceOutboundQueueLengthLocked(connection);
 }","[62, 63, 64]","The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796."
205933," void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)
 {
     if (!name->IsString())
         return;
 
     auto nameString = name.As<v8::String>();
     LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));
     if (!window)
         return;
 
     LocalFrame* frame = window->frame();
     if (!frame)
         return;
 
     AtomicString propName = toCoreAtomicString(nameString);
     Frame* child = frame->tree().scopedChild(propName);
     if (child) {
         v8SetReturnValueFast(info, child->domWindow(), window);
         return;
     }
 
      if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())
          return;
  
      
     frame = window->frame();
      
     if (!frame)
         return;
 
      Document* doc = frame->document();
  
     if (doc && doc->isHTMLDocument()) {
         if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {
             RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);
             if (!items->isEmpty()) {
                 if (items->hasExactlyOneItem()) {
                     v8SetReturnValueFast(info, items->item(0), window);
                     return;
                 }
                 v8SetReturnValueFast(info, items.release(), window);
                 return;
             }
         }
     }
 }","[25, 26, 27, 28, 29, 30]","Use-after-free vulnerability in the V8Window::namedPropertyGetterCustom function in bindings/core/v8/custom/V8WindowCustom.cpp in the V8 bindings in Blink, as used in Google Chrome before 41.0.2272.76, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger a frame detachment."
198353," void rng_backend_request_entropy(RngBackend *s, size_t size,
                                  EntropyReceiveFunc *receive_entropy,
                                   void *opaque)
  {
      RngBackendClass *k = RNG_BACKEND_GET_CLASS(s);
     RngRequest *req;
  
      if (k->request_entropy) {
        k->request_entropy(s, size, receive_entropy, opaque);
         req = g_malloc(sizeof(*req));
 
         req->offset = 0;
         req->size = size;
         req->receive_entropy = receive_entropy;
         req->opaque = opaque;
         req->data = g_malloc(req->size);
 
         k->request_entropy(s, req);
 
         s->requests = g_slist_append(s->requests, req);
      }
  }","[6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 9]","QEMU, when built with the Pseudo Random Number Generator (PRNG) back-end support, allows local guest OS users to cause a denial of service (process crash) via an entropy request, which triggers arbitrary stack based allocation and memory corruption."
207929," WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec)
 {
  dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
  dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds;
  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
     WORD32 j;
     UWORD8 u1_buf_mode;
  struct MMCParams *ps_mmc_params;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst;
 
     ps_slice->u1_mmco_equalto5 = 0;
  {
  if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
  {
             ps_slice->u1_no_output_of_prior_pics_flag =
                             ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"",
                             ps_slice->u1_no_output_of_prior_pics_flag);
             ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264(
                             ps_bitstrm);
             COPYTHECONTEXT(""SH: long_term_reference_flag"",
                             ps_slice->u1_long_term_reference_flag);
             ps_dpb_cmds->u1_idr_pic = 1;
             ps_dpb_cmds->u1_no_output_of_prior_pics_flag =
                             ps_slice->u1_no_output_of_prior_pics_flag;
             ps_dpb_cmds->u1_long_term_reference_flag =
                             ps_slice->u1_long_term_reference_flag;
  }
  else
  {
             u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm);  
             COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode);
             ps_dpb_cmds->u1_buf_mode = u1_buf_mode;
             j = 0;
 
  if(u1_buf_mode == 1)
  {
                 UWORD32 u4_mmco;
                 UWORD32 u4_diff_pic_num;
                 UWORD32 u4_lt_idx, u4_max_lt_idx;
 
                 u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
 
                                       pu4_bitstrm_buf);
                  while(u4_mmco != END_OF_MMCO)
                  {
                     if (j >= MAX_REF_BUFS)
                     {
                         ALOGE(""b/25818142"");
                         android_errorWriteLog(0x534e4554, ""25818142"");
                         ps_dpb_cmds->u1_num_of_commands = 0;
                         return -1;
                     }
                      ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j];
                      ps_mmc_params->u4_mmco = u4_mmco;
                      switch(u4_mmco)
  {
  case MARK_ST_PICNUM_AS_NONREF:
                             u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                          pu4_bitstrm_buf);
                             ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
  break;
 
  case MARK_LT_INDEX_AS_NONREF:
                             u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                    pu4_bitstrm_buf);
                             ps_mmc_params->u4_lt_idx = u4_lt_idx;
  break;
 
  case MARK_ST_PICNUM_AS_LT_INDEX:
                             u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst,
                                                          pu4_bitstrm_buf);
                             ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num;
                             u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                    pu4_bitstrm_buf);
                             ps_mmc_params->u4_lt_idx = u4_lt_idx;
  break;
 
  case SET_MAX_LT_INDEX:
  {
                             u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                        pu4_bitstrm_buf);
                             ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx;
  break;
  }
  case RESET_REF_PICTURES:
  {
                             ps_slice->u1_mmco_equalto5 = 1;
  break;
  }
 
  case SET_LT_INDEX:
                             u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst,
                                                    pu4_bitstrm_buf);
                             ps_mmc_params->u4_lt_idx = u4_lt_idx;
  break;
 
  default:
  break;
  }
                     u4_mmco = ih264d_uev(pu4_bitstrm_ofst,
                                          pu4_bitstrm_buf);
 
                     j++;
  }
                 ps_dpb_cmds->u1_num_of_commands = j;
 
  }
  }
         ps_dpb_cmds->u1_dpb_commands_read = 1;
         ps_dpb_cmds->u1_dpb_commands_read_slc = 1;
 
  }
     u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst;
  return u4_bit_ofst;
 }","[49, 50, 51, 52, 53, 54, 55]","The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142."
205889," void Editor::Transpose() {
  if (!CanEdit())
  
  
 void Transpose(LocalFrame& frame) {
   Editor& editor = frame.GetEditor();
   if (!editor.CanEdit())
      return;
  
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
   Document* const document = frame.GetDocument();
 
   document->UpdateStyleAndLayoutIgnorePendingStylesheets();
  
  const EphemeralRange& range = ComputeRangeForTranspose(GetFrame());
   const EphemeralRange& range = ComputeRangeForTranspose(frame);
    if (range.IsNull())
      return;
  
   const String& text = PlainText(range);
   if (text.length() != 2)
     return;
    const String& transposed = text.Right(1) + text.Left(1);
  
    if (DispatchBeforeInputInsertText(
          EventTargetNodeForDocument(GetFrame().GetDocument()), transposed,
           EventTargetNodeForDocument(document), transposed,
            InputEvent::InputType::kInsertTranspose,
            new StaticRangeVector(1, StaticRange::Create(range))) !=
        DispatchEventResult::kNotCanceled)
      return;
  
  if (frame_->GetDocument()->GetFrame() != frame_)
    
   if (frame.GetDocument() != document)
      return;
  
  GetFrame().GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();
   document->UpdateStyleAndLayoutIgnorePendingStylesheets();
  
  const EphemeralRange& new_range = ComputeRangeForTranspose(GetFrame());
   const EphemeralRange& new_range = ComputeRangeForTranspose(frame);
    if (new_range.IsNull())
      return;
  
   const String& new_text = PlainText(new_range);
   if (new_text.length() != 2)
     return;
   const String& new_transposed = new_text.Right(1) + new_text.Left(1);
 
   const SelectionInDOMTree& new_selection =
       SelectionInDOMTree::Builder().SetBaseAndExtent(new_range).Build();
  
    if (CreateVisibleSelection(new_selection) !=
      GetFrame().Selection().ComputeVisibleSelectionInDOMTree())
    GetFrame().Selection().SetSelection(new_selection);
       frame.Selection().ComputeVisibleSelectionInDOMTree())
     frame.Selection().SetSelection(new_selection);
  
  ReplaceSelectionWithText(new_transposed, false, false,
                           InputEvent::InputType::kInsertTranspose);
   editor.ReplaceSelectionWithText(new_transposed, false, false,
                                   InputEvent::InputType::kInsertTranspose);
  }","[5, 6, 7, 11, 12, 13, 16, 27, 34, 35, 39, 42, 57, 58, 62, 63, 2, 10, 15, 26, 33, 38, 41, 55, 56, 60, 61]",Multiple unspecified vulnerabilities in Google Chrome before 43.0.2357.65 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.
2554,"TEST(LibRadosCmd, MonDescribe) {
rados_t cluster;
ASSERT_EQ("""", connect_cluster(&cluster));

char *buf, *st;
size_t buflen, stlen;
char *cmd[2];

cmd[1] = NULL;

cmd[0] = (char *)""{\""prefix\"":\""get_command_descriptions\""}"";
ASSERT_EQ(0, rados_mon_command(cluster, (const char **)cmd, 1, """", 0, &buf, &buflen, &st, &stlen));
ASSERT_LT(0u, buflen);
rados_buffer_free(buf);
rados_buffer_free(st);

cmd[0] = (char *)""get_command_descriptions"";
ASSERT_EQ(-EINVAL, rados_mon_command(cluster, (const char **)cmd, 1, """", 0, &buf, &buflen, &st, &stlen));
rados_buffer_free(buf);
rados_buffer_free(st);

cmd[0] = (char *)""asdfqwer"";
ASSERT_EQ(-EINVAL, rados_mon_command(cluster, (const char **)cmd, 1, ""{}"", 2, &buf, &buflen, &st, &stlen));
rados_buffer_free(buf);
rados_buffer_free(st);

cmd[0] = (char *)""{\""prefix\"":\""mon_status\""}"";
ASSERT_EQ(0, rados_mon_command(cluster, (const char **)cmd, 1, """", 0, &buf, &buflen, &st, &stlen));
ASSERT_LT(0u, buflen);

rados_buffer_free(buf);
rados_buffer_free(st);
rados_shutdown(cluster);
}",[27],The handle_command function in mon/Monitor.cc in Ceph allows remote authenticated users to cause a denial of service (segmentation fault and ceph monitor crash) via an (1) empty or (2) crafted prefix.
7598,"agoo_ws_create_req(agooCon c, long mlen) {
uint8_t op = 0x0F & *c->buf;

if (NULL == (c->req = agoo_req_create(mlen))) {
agoo_log_cat(&agoo_error_cat, ""Out of memory attempting to allocate request."");
return true;
}
if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {
return true;
}
memset(c->req, 0, sizeof(struct _agooReq));
if ((long)c->bcnt <= mlen) {
memcpy(c->req->msg, c->buf, c->bcnt);
if ((long)c->bcnt < mlen) {
memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);
}
} else {
memcpy(c->req->msg, c->buf, mlen);
}
c->req->msg[mlen] = '\0';
c->req->mlen = mlen;
c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;
c->req->upgrade = AGOO_UP_NONE;
c->req->up = c->up;
c->req->res = NULL;
if (c->up->on_msg) {
c->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);
}
return false;
}",[25],agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.
8292,"void UncompressElementOp::Compute(OpKernelContext* ctx) {
Tensor tensor = ctx->input(0);
const Variant& variant = tensor.scalar<Variant>()();
const CompressedElement* compressed = variant.get<CompressedElement>();

std::vector<Tensor> components;
OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));
OP_REQUIRES(ctx, components.size() == output_types_.size(),
errors::FailedPrecondition(""Expected "", output_types_.size(),
"" outputs from uncompress, but got "",
components.size()));
for (int i = 0; i < components.size(); ++i) {
OP_REQUIRES(
ctx, components[i].dtype() == output_types_[i],
errors::FailedPrecondition(""Expected a tensor of type "",
DataTypeString(output_types_[i]),
"" but got a tensor of type "",
DataTypeString(components[i].dtype())));
ctx->set_output(i, components[i]);
}
}",[6],"TensorFlow is an end-to-end open source platform for machine learning. The code for `tf.raw_ops.UncompressElement` can be made to trigger a null pointer dereference. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/data/experimental/compression_ops.cc#L50-L53) obtains a pointer to a `CompressedElement` from a `Variant` tensor and then proceeds to dereference it for decompressing. There is no check that the `Variant` tensor contained a `CompressedElement`, so the pointer is actually `nullptr`. We have patched the issue in GitHub commit 7bdf50bb4f5c54a4997c379092888546c97c3ebd. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range."
208203," void SoftHEVC::onQueueFilled(OMX_U32 portIndex) {
     UNUSED(portIndex);
 
  if (mSignalledError) {
  return;
  }
  if (mOutputPortSettingsChange != NONE) {
  return;
  }
 
  if (NULL == mCodecCtx) {
  if (OK != initDecoder()) {
  return;
  }
  }
  if (outputBufferWidth() != mStride) {
   
         mStride = outputBufferWidth();
         setParams(mStride);
  }
 
  List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex);
  List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);
 
   
 
  if (mReceivedEOS && !mIsInFlush) {
         setFlushMode();
  }
 
  while (!outQueue.empty()) {
  BufferInfo *inInfo;
         OMX_BUFFERHEADERTYPE *inHeader;
 
  BufferInfo *outInfo;
         OMX_BUFFERHEADERTYPE *outHeader;
  size_t timeStampIx;
 
         inInfo = NULL;
         inHeader = NULL;
 
  if (!mIsInFlush) {
  if (!inQueue.empty()) {
                 inInfo = *inQueue.begin();
                 inHeader = inInfo->mHeader;
  } else {
  break;
  }
  }
 
         outInfo = *outQueue.begin();
         outHeader = outInfo->mHeader;
         outHeader->nFlags = 0;
         outHeader->nTimeStamp = 0;
         outHeader->nOffset = 0;
 
  if (inHeader != NULL && (inHeader->nFlags & OMX_BUFFERFLAG_EOS)) {
             mReceivedEOS = true;
  if (inHeader->nFilledLen == 0) {
                 inQueue.erase(inQueue.begin());
                 inInfo->mOwnedByUs = false;
                 notifyEmptyBufferDone(inHeader);
                 inHeader = NULL;
                 setFlushMode();
  }
  }
 
   
  {
  size_t i;
             timeStampIx = 0;
  for (i = 0; i < MAX_TIME_STAMPS; i++) {
  if (!mTimeStampsValid[i]) {
                     timeStampIx = i;
  break;
  }
  }
  if (inHeader != NULL) {
                 mTimeStampsValid[timeStampIx] = true;
                 mTimeStamps[timeStampIx] = inHeader->nTimeStamp;
  }
  }
 
  {
  ivd_video_decode_ip_t s_dec_ip;
  ivd_video_decode_op_t s_dec_op;
 
              WORD32 timeDelay, timeTaken;
              size_t sizeY, sizeUV;
  
            setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx);
             if (!setDecodeArgs(&s_dec_ip, &s_dec_op, inHeader, outHeader, timeStampIx)) {
                 ALOGE(""Decoder arg setup failed"");
                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                 mSignalledError = true;
                 return;
             }
  
              GETTIME(&mTimeStart, NULL);
               
             TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);
 
             IV_API_CALL_STATUS_T status;
             status = ivdec_api_function(mCodecCtx, (void *)&s_dec_ip, (void *)&s_dec_op);
 
  bool resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code & 0xFF));
 
             GETTIME(&mTimeEnd, NULL);
   
             TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);
 
             ALOGV(""timeTaken=%6d delay=%6d numBytes=%6d"", timeTaken, timeDelay,
                    s_dec_op.u4_num_bytes_consumed);
  if (s_dec_op.u4_frame_decoded_flag && !mFlushNeeded) {
                 mFlushNeeded = true;
  }
 
  if ((inHeader != NULL) && (1 != s_dec_op.u4_frame_decoded_flag)) {
   
                 mTimeStampsValid[timeStampIx] = false;
  }
 
  if (mChangingResolution && !s_dec_op.u4_output_present) {
                 mChangingResolution = false;
                 resetDecoder();
                 resetPlugin();
  continue;
  }
 
  if (resChanged) {
                 mChangingResolution = true;
  if (mFlushNeeded) {
                     setFlushMode();
  }
  continue;
  }
 
  if ((0 < s_dec_op.u4_pic_wd) && (0 < s_dec_op.u4_pic_ht)) {
  uint32_t width = s_dec_op.u4_pic_wd;
  uint32_t height = s_dec_op.u4_pic_ht;
  bool portWillReset = false;
                 handlePortSettingsChange(&portWillReset, width, height);
 
  if (portWillReset) {
                     resetDecoder();
  return;
  }
  }
 
  if (s_dec_op.u4_output_present) {
                 outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2;
 
                 outHeader->nTimeStamp = mTimeStamps[s_dec_op.u4_ts];
                 mTimeStampsValid[s_dec_op.u4_ts] = false;
 
                 outInfo->mOwnedByUs = false;
                 outQueue.erase(outQueue.begin());
                 outInfo = NULL;
                 notifyFillBufferDone(outHeader);
                 outHeader = NULL;
  } else {
   
                 mIsInFlush = false;
 
   
  if (mReceivedEOS) {
                     outHeader->nFilledLen = 0;
                     outHeader->nFlags |= OMX_BUFFERFLAG_EOS;
 
                     outInfo->mOwnedByUs = false;
                     outQueue.erase(outQueue.begin());
                     outInfo = NULL;
                     notifyFillBufferDone(outHeader);
                     outHeader = NULL;
                     resetPlugin();
  }
  }
  }
 
  if (inHeader != NULL) {
             inInfo->mOwnedByUs = false;
             inQueue.erase(inQueue.begin());
             inInfo = NULL;
             notifyEmptyBufferDone(inHeader);
             inHeader = NULL;
  }
  }
 }","[92, 93, 94, 95, 96, 97, 91]","libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27833616."
207704," perform_gamma_threshold_tests(png_modifier *pm)
 {
    png_byte colour_type = 0;
    png_byte bit_depth = 0;
  unsigned int palette_number = 0;
 
 
      
   while (next_format(&colour_type, &bit_depth, &palette_number, 1 ))
      if (palette_number == 0)
    while (next_format(&colour_type, &bit_depth, &palette_number,
                       pm->test_lbg_gamma_threshold, pm->test_tRNS))
       if (palette_number < 2)
     {
        double test_gamma = 1.0;
        while (test_gamma >= .4)
  {
   
          gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
             test_gamma, 1/test_gamma);
          test_gamma *= .95;
  }
 
   
       gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
  .45455, 2.2);
 
  if (fail(pm))
  return;
  }
 
  }","[11, 12, 13, 9, 10]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
205109,"    QuicConnectionHelperTest()
      : framer_(QuicDecrypter::Create(kNULL), QuicEncrypter::Create(kNULL)),
       : guid_(0),
         framer_(QuicDecrypter::Create(kNULL), QuicEncrypter::Create(kNULL)),
          creator_(guid_, &framer_),
          net_log_(BoundNetLog()),
          scheduler_(new MockScheduler()),
         socket_(&empty_data_, net_log_.net_log()),
         runner_(new TestTaskRunner(&clock_)),
         helper_(new TestConnectionHelper(runner_.get(), &clock_, &socket_)),
         connection_(guid_, IPEndPoint(), helper_),
         frame1_(1, false, 0, data1) {
     connection_.set_visitor(&visitor_);
     connection_.SetScheduler(scheduler_);
   }","[3, 4, 2]","Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, does not properly manage memory during message handling for plug-ins, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
198450," static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,
         int *need_next_header, int *new_frame_start)
 {
     GetBitContext bits;
     AACADTSHeaderInfo hdr;
      int size;
      union {
          uint64_t u64;
        uint8_t  u8[8];
         uint8_t  u8[8 + FF_INPUT_BUFFER_PADDING_SIZE];
      } tmp;
  
      tmp.u64 = av_be2ne64(state);
     init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);
 
     if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)
         return 0;
     *need_next_header = 0;
     *new_frame_start  = 1;
     hdr_info->sample_rate = hdr.sample_rate;
     hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];
     hdr_info->samples     = hdr.samples;
     hdr_info->bit_rate    = hdr.bit_rate;
     return size;
 }","[10, 9]",Stack-based buffer overflow in the aac_sync function in aac_parser.c in Libav before 11.5 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted file.
207659," image_transform_png_set_gray_to_rgb_set(PNG_CONST image_transform *this,
 image_transform_png_set_gray_to_rgb_set(const image_transform *this,
      transform_display *that, png_structp pp, png_infop pi)
  {
     png_set_gray_to_rgb(pp);
     
     this->next->set(this->next, that, pp, pi);
  }","[2, 6]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
204028," EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionDispatchEvent(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
     if (!thisValue.inherits(&JSTestEventTarget::s_info))
         return throwVMTypeError(exec);
     JSTestEventTarget* castedThis = jsCast<JSTestEventTarget*>(asObject(thisValue));
      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);
      TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());
      if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
         return throwVMError(exec, createNotEnoughArgumentsError(exec));
      ExceptionCode ec = 0;
      Event* evt(toEvent(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
      if (exec->hadException())
         return JSValue::encode(jsUndefined());
 
     JSC::JSValue result = jsBoolean(impl->dispatchEvent(evt, ec));
     setDOMException(exec, ec);
     return JSValue::encode(result);
 }","[11, 10]","The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors."
207628,"  chrm_modification_init(chrm_modification *me, png_modifier *pm,
   PNG_CONST color_encoding *encoding)
    const color_encoding *encoding)
  {
     CIE_color white = white_point(encoding);
  
   
    me->encoding = encoding;
 
   
    me->wx = fix(chromaticity_x(white));
    me->wy = fix(chromaticity_y(white));
 
    me->rx = fix(chromaticity_x(encoding->red));
    me->ry = fix(chromaticity_y(encoding->red));
    me->gx = fix(chromaticity_x(encoding->green));
    me->gy = fix(chromaticity_y(encoding->green));
    me->bx = fix(chromaticity_x(encoding->blue));
    me->by = fix(chromaticity_y(encoding->blue));
 
    modification_init(&me->this);
    me->this.chunk = CHUNK_cHRM;
    me->this.modify_fn = chrm_modify;
    me->this.add = CHUNK_PLTE;
    me->this.next = pm->modifications;
    pm->modifications = &me->this;
 }","[3, 2]","Unspecified vulnerability in libpng before 1.6.20, as used in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01, allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 23265085."
202354," static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)
 {
 	struct k_itimer *timr;
 	unsigned long flags;
 	int si_private = 0;
 	enum hrtimer_restart ret = HRTIMER_NORESTART;
 
 	timr = container_of(timer, struct k_itimer, it.real.timer);
 	spin_lock_irqsave(&timr->it_lock, flags);
 
 	timr->it_active = 0;
 	if (timr->it_interval != 0)
 		si_private = ++timr->it_requeue_pending;
 
 	if (posix_timer_event(timr, si_private)) {
 		 
 		if (timr->it_interval != 0) {
 			ktime_t now = hrtimer_cb_get_time(timer);
 
 			 
 #ifdef CONFIG_HIGH_RES_TIMERS
 			{
 				ktime_t kj = NSEC_PER_SEC / HZ;
 
 				if (timr->it_interval < kj)
  					now = ktime_add(now, kj);
  			}
  #endif
			timr->it_overrun += (unsigned int)
				hrtimer_forward(timer, now,
						timr->it_interval);
 			timr->it_overrun += hrtimer_forward(timer, now,
 							    timr->it_interval);
  			ret = HRTIMER_RESTART;
  			++timr->it_requeue_pending;
  			timr->it_active = 1;
 		}
 	}
 
 	unlock_timer(timr, flags);
 	return ret;
 }","[32, 33, 29, 30, 31]","An issue was discovered in the Linux kernel through 4.17.3. An Integer Overflow in kernel/time/posix-timers.c in the POSIX timer code is caused by the way the overrun accounting works. Depending on interval and expiry time values, the overrun can be larger than INT_MAX, but the accounting is int based. This basically makes the accounting values, which are visible to user space via timer_getoverrun(2) and siginfo::si_overrun, random. For example, a local user can cause a denial of service (signed integer overflow) via crafted mmap, futex, timer_create, and timer_settime system calls."
