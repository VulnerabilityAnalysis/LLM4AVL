{"tokens": ["   t42_parse_sfnts( T42_Face    face,", "                    T42_Loader  loader )", "   {", "     T42_Parser  parser = &loader->parser;", "     FT_Memory   memory = parser->root.memory;", "     FT_Byte*    cur;", "      FT_Byte*    limit  = parser->root.limit;", "      FT_Error    error;", "      FT_Int      num_tables = 0;", "    FT_ULong    count, ttf_size = 0;", "     FT_ULong    count;", "  ", "      FT_Long     n, string_size, old_string_size, real_size;", "      FT_Byte*    string_buf = NULL;", "     FT_Bool     allocated  = 0;", " ", "     T42_Load_Status  status;", " ", " ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", "      ", " ", "     T1_Skip_Spaces( parser );", " ", "     if ( parser->root.cursor >= limit || *parser->root.cursor++ != '[' )", "     {", "       FT_ERROR(( \"t42_parse_sfnts: can't find begin of sfnts vector\\n\" ));", "       error = FT_THROW( Invalid_File_Format );", "       goto Fail;", "     }", " ", "     T1_Skip_Spaces( parser );", "     status          = BEFORE_START;", "     string_size     = 0;", "     old_string_size = 0;", "     count           = 0;", " ", "     while ( parser->root.cursor < limit )", "     {", "       cur = parser->root.cursor;", " ", "       if ( *cur == ']' )", "       {", "         parser->root.cursor++;", "         goto Exit;", "       }", " ", "       else if ( *cur == '<' )", "       {", "         T1_Skip_PS_Token( parser );", "         if ( parser->root.error )", "           goto Exit;", " ", "          ", "         string_size = (FT_Long)( ( parser->root.cursor - cur - 2 + 1 ) / 2 );", "         if ( FT_REALLOC( string_buf, old_string_size, string_size ) )", "           goto Fail;", " ", "         allocated = 1;", " ", "         parser->root.cursor = cur;", "         (void)T1_ToBytes( parser, string_buf, string_size, &real_size, 1 );", "         old_string_size = string_size;", "         string_size = real_size;", "       }", " ", "       else if ( ft_isdigit( *cur ) )", "       {", "         if ( allocated )", "         {", "           FT_ERROR(( \"t42_parse_sfnts: \"", "                      \"can't handle mixed binary and hex strings\\n\" ));", "           error = FT_THROW( Invalid_File_Format );", "           goto Fail;", "         }", " ", "         string_size = T1_ToInt( parser );", "         if ( string_size < 0 )", "         {", "           FT_ERROR(( \"t42_parse_sfnts: invalid string size\\n\" ));", "           error = FT_THROW( Invalid_File_Format );", "           goto Fail;", "         }", " ", "         T1_Skip_PS_Token( parser );              ", "         if ( parser->root.error )", "           return;", " ", "         string_buf = parser->root.cursor + 1;    ", "  ", "          if ( limit - parser->root.cursor < string_size )", "          {", "          FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));", "           FT_ERROR(( \"t42_parse_sfnts: too much binary data\\n\" ));", "            error = FT_THROW( Invalid_File_Format );", "            goto Fail;", "          }", "         else", "           parser->root.cursor += string_size + 1;", "       }", " ", "       if ( !string_buf )", "       {", "         FT_ERROR(( \"t42_parse_sfnts: invalid data in sfnts array\\n\" ));", "         error = FT_THROW( Invalid_File_Format );", "         goto Fail;", "       }", " ", "        ", "        ", "       if ( ( string_size & 1 ) && string_buf[string_size - 1] == 0 )", "         string_size--;", " ", "       if ( !string_size )", "       {", "         FT_ERROR(( \"t42_parse_sfnts: invalid string\\n\" ));", "         error = FT_THROW( Invalid_File_Format );", "         goto Fail;", "       }", " ", "       for ( n = 0; n < string_size; n++ )", "       {", "         switch ( status )", "         {", "         case BEFORE_START:", "            ", "           if ( count < 12 )", "           {", "             face->ttf_data[count++] = string_buf[n];", "             continue;", "            }", "            else", "            {", "            num_tables = 16 * face->ttf_data[4] + face->ttf_data[5];", "            status     = BEFORE_TABLE_DIR;", "            ttf_size   = 12 + 16 * num_tables;", "             num_tables     = 16 * face->ttf_data[4] + face->ttf_data[5];", "             status         = BEFORE_TABLE_DIR;", "             face->ttf_size = 12 + 16 * num_tables;", "  ", "            if ( FT_REALLOC( face->ttf_data, 12, ttf_size ) )", "             if ( FT_REALLOC( face->ttf_data, 12, face->ttf_size ) )", "                goto Fail;", "            }", "             ", "  ", "          case BEFORE_TABLE_DIR:", "             ", "          if ( count < ttf_size )", "           if ( count < face->ttf_size )", "            {", "              face->ttf_data[count++] = string_buf[n];", "              continue;", "           }", "           else", "           {", "             int       i;", "             FT_ULong  len;", " ", " ", "             for ( i = 0; i < num_tables; i++ )", "             {", "               FT_Byte*  p = face->ttf_data + 12 + 16 * i + 12;", " ", " ", "                len = FT_PEEK_ULONG( p );", "  ", "                 ", "              ttf_size += ( len + 3 ) & ~3;", "               face->ttf_size += ( len + 3 ) & ~3;", "              }", "  ", "            status         = OTHER_TABLES;", "            face->ttf_size = ttf_size;", "             status = OTHER_TABLES;", "  ", "               ", "              if ( FT_REALLOC( face->ttf_data, 12 + 16 * num_tables,", "                             ttf_size + 1 ) )", "                              face->ttf_size + 1 ) )", "                goto Fail;", "            }", "             ", "  ", "          case OTHER_TABLES:", "             ", "          if ( count >= ttf_size )", "           if ( count >= face->ttf_size )", "            {", "            FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));", "             FT_ERROR(( \"t42_parse_sfnts: too much binary data\\n\" ));", "              error = FT_THROW( Invalid_File_Format );", "              goto Fail;", "            }", "           }", "           face->ttf_data[count++] = string_buf[n];", "         }", "       }", " ", "       T1_Skip_Spaces( parser );", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void impeg2d_dec_hdr(void *pv_dec,impeg2d_video_decode_ip_t *ps_ip,", "  impeg2d_video_decode_op_t *ps_op)", " {", " ", "     UWORD32 u4_bits_read;", "  dec_state_t *ps_dec;", " ", "     ps_dec = (dec_state_t *)pv_dec;", "     ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;", " ", "     impeg2d_bit_stream_init(&(ps_dec->s_bit_stream),ps_ip->s_ivd_video_decode_ip_t.pv_stream_buffer,", "         ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes);", " ", "  {", "  {", "             IMPEG2D_ERROR_CODES_T e_error;", "             e_error = impeg2d_process_video_header(ps_dec);", "  if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)", "  {", "                 ps_op->s_ivd_video_decode_op_t.u4_error_code    = e_error;", " ", "                 u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);", " ", "                 ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;", "  if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)", "  {", "                     ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;", "  }", " ", "                  if(ps_op->s_ivd_video_decode_op_t.u4_error_code == 0)", "                      ps_op->s_ivd_video_decode_op_t.u4_error_code = e_error;", "  ", "                 if (IMPEG2D_UNSUPPORTED_DIMENSIONS == e_error)", "                 {", "                     ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;", "                     ps_dec->u2_header_done = 0;", "  ", "                     ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_reinit_max_height;", "                     ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_reinit_max_width;", "                 }", "                  impeg2d_next_code(ps_dec, SEQUENCE_HEADER_CODE);", "                  return;", "              }", "  }", "         ps_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec->u2_vertical_size;", "         ps_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec->u2_horizontal_size;", " ", "         ps_op->s_ivd_video_decode_op_t.e_pic_type            = IV_NA_FRAME;", "         ps_op->s_ivd_video_decode_op_t.u4_error_code        = IV_SUCCESS;", " ", "         u4_bits_read     = impeg2d_bit_stream_num_bits_read(&ps_dec->s_bit_stream);", "         ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = u4_bits_read>> 3;", "  if(ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed > ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes)", "  {", "             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;", "  }", "         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;", "   ", "         ps_dec->u2_header_done = 1;", " ", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TPM2B_PROOF_Marshal(TPM2B_PROOF *source, BYTE **buffer, INT32 *size)", "{", "UINT16 written = 0;", "written += TPM2B_Marshal(&source->b, buffer, size);", "return written;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": [" static void send(node_t *node, node_t *child, byte *fout) {", " static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {", "  \tif (node->parent) {", "\t\tsend(node->parent, node, fout);", " \t\tsend(node->parent, node, fout, maxoffset);", "  \t}", "  \tif (child) {", " \t\tif (bloc >= maxoffset) {", " \t\t\tbloc = maxoffset + 1;", " \t\t\treturn;", " \t\t}", "  \t\tif (node->right == child) {", "  \t\t\tadd_bit(1, fout);", "  \t\t} else {", " \t\t\tadd_bit(0, fout);", " \t\t}", " \t}", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long video_ioctl2(struct file *file,", "\t       unsigned int cmd, unsigned long arg)", " long", " video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,", " \t       v4l2_kioctl func)", "  {", "  \tchar\tsbuf[128];", "  \tvoid    *mbuf = NULL;", " \tvoid\t*parg = (void *)arg;", " \tlong\terr  = -EINVAL;", " \tbool\thas_array_args;", " \tsize_t  array_size = 0;", " \tvoid __user *user_ptr = NULL;", " \tvoid\t**kernel_ptr = NULL;", " ", " \t ", " \tif (_IOC_DIR(cmd) != _IOC_NONE) {", " \t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {", " \t\t\tparg = sbuf;", " \t\t} else {", " \t\t\t ", " \t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);", " \t\t\tif (NULL == mbuf)", " \t\t\t\treturn -ENOMEM;", " \t\t\tparg = mbuf;", " \t\t}", " ", " \t\terr = -EFAULT;", " \t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {", " \t\t\tunsigned long n = cmd_input_size(cmd);", " ", " \t\t\tif (copy_from_user(parg, (void __user *)arg, n))", " \t\t\t\tgoto out;", " ", " \t\t\t ", " \t\t\tif (n < _IOC_SIZE(cmd))", " \t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);", " \t\t} else {", " \t\t\t ", " \t\t\tmemset(parg, 0, _IOC_SIZE(cmd));", " \t\t}", " \t}", " ", " \terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);", " \tif (err < 0)", " \t\tgoto out;", " \thas_array_args = err;", " ", " \tif (has_array_args) {", " \t\t ", " \t\tmbuf = kmalloc(array_size, GFP_KERNEL);", " \t\terr = -ENOMEM;", " \t\tif (NULL == mbuf)", " \t\t\tgoto out_array_args;", " \t\terr = -EFAULT;", " \t\tif (copy_from_user(mbuf, user_ptr, array_size))", " \t\t\tgoto out_array_args;", " \t\t*kernel_ptr = mbuf;", "  \t}", "  ", "  \t ", "\terr = __video_do_ioctl(file, cmd, parg);", " \terr = func(file, cmd, parg);", "  \tif (err == -ENOIOCTLCMD)", "  \t\terr = -EINVAL;", "  ", " \tif (has_array_args) {", " \t\t*kernel_ptr = user_ptr;", " \t\tif (copy_to_user(user_ptr, mbuf, array_size))", " \t\t\terr = -EFAULT;", " \t\tgoto out_array_args;", " \t}", " \tif (err < 0)", " \t\tgoto out;", " ", " out_array_args:", " \t ", " \tswitch (_IOC_DIR(cmd)) {", " \tcase _IOC_READ:", " \tcase (_IOC_WRITE | _IOC_READ):", " \t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))", " \t\t\terr = -EFAULT;", " \t\tbreak;", " \t}", " ", " out:", "  \tkfree(mbuf);", "  \treturn err;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,", " \t\t\t\t\t    struct pluto_crypto_req *r,", " \t\t\t\t\t    err_t ugh)", " {", " \tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;", " \tstruct msg_digest *md = dh->md;", " \tstruct state *const st = md->st;", " \tstf_status e;", " ", " \tDBG(DBG_CONTROLMORE,", " \t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));", " ", " \tif (st == NULL) {", " \t\tloglog(RC_LOG_SERIOUS,", " \t\t       \"%s: Request was disconnected from state\",", " \t\t       __FUNCTION__);", " \t\tif (dh->md)", " \t\t\trelease_md(dh->md);", " \t\treturn;", " \t}", " ", " \t ", " \tpassert(ugh == NULL);", " \tpassert(cur_state == NULL);", " \tpassert(st != NULL);", " ", " \tpassert(st->st_suspended_md == dh->md);", " \tset_suspended(st, NULL);  ", " ", " \tset_cur_state(st);", " ", " \tst->st_calculating = FALSE;", " ", " \te = ikev2_parent_inI2outR2_tail(pcrc, r);", " \tif ( e > STF_FAIL) {", " \t\t ", " \t\tint v2_notify_num = e - STF_FAIL;", " \t\tDBG_log(", " \t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",", " \t\t\tenum_name(&ikev2_notify_names, v2_notify_num));", " \t} else if ( e != STF_OK) {", " \t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",", " \t\t\tenum_name(&stfstatus_name, e));", " \t}", " ", " \tif (dh->md != NULL) {", " \t\tcomplete_v2_state_transition(&dh->md, e);", " \t\tif (dh->md)", "  \t\t\trelease_md(dh->md);", "  \t}", "  \treset_globals();", "\tpassert(GLOBALS_ARE_RESET());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" status_t MPEG4Source::fragmentedRead(", "  MediaBuffer **out, const ReadOptions *options) {", " ", "     ALOGV(\"MPEG4Source::fragmentedRead\");", " ", "     CHECK(mStarted);", " ", "  *out = NULL;", " ", "  int64_t targetSampleTimeUs = -1;", " ", "  int64_t seekTimeUs;", "  ReadOptions::SeekMode mode;", "  if (options && options->getSeekTo(&seekTimeUs, &mode)) {", " ", "  int numSidxEntries = mSegments.size();", "  if (numSidxEntries != 0) {", "  int64_t totalTime = 0;", "  off64_t totalOffset = mFirstMoofOffset;", "  for (int i = 0; i < numSidxEntries; i++) {", "  const SidxEntry *se = &mSegments[i];", "  if (totalTime + se->mDurationUs > seekTimeUs) {", "  if ((mode == ReadOptions::SEEK_NEXT_SYNC) ||", "  (mode == ReadOptions::SEEK_CLOSEST_SYNC &&", "  (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {", "                         totalTime += se->mDurationUs;", "                         totalOffset += se->mSize;", "  }", "  break;", "  }", "                 totalTime += se->mDurationUs;", "                 totalOffset += se->mSize;", "  }", "         mCurrentMoofOffset = totalOffset;", "         mCurrentSamples.clear();", "         mCurrentSampleIndex = 0;", "         parseChunk(&totalOffset);", "         mCurrentTime = totalTime * mTimescale / 1000000ll;", "  }", " ", "  if (mBuffer != NULL) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  }", " ", "  off64_t offset = 0;", "  size_t size;", "  uint32_t cts = 0;", "  bool isSyncSample = false;", "  bool newBuffer = false;", "  if (mBuffer == NULL) {", "         newBuffer = true;", " ", "  if (mCurrentSampleIndex >= mCurrentSamples.size()) {", "  Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1];", "  off64_t nextMoof = mNextMoofOffset;  ", "             mCurrentMoofOffset = nextMoof;", "             mCurrentSamples.clear();", "             mCurrentSampleIndex = 0;", "             parseChunk(&nextMoof);", "  if (mCurrentSampleIndex >= mCurrentSamples.size()) {", "  return ERROR_END_OF_STREAM;", "  }", "  }", " ", "  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];", "         offset = smpl->offset;", "         size = smpl->size;", "         cts = mCurrentTime;", "         mCurrentTime += smpl->duration;", "         isSyncSample = (mCurrentSampleIndex == 0);  ", " ", "  status_t err = mGroup->acquire_buffer(&mBuffer);", " ", "  if (err != OK) {", "             CHECK(mBuffer == NULL);", "             ALOGV(\"acquire_buffer returned %d\", err);", "  return err;", "  }", "  if (size > mBuffer->size()) {", "             ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());", "  return ERROR_BUFFER_TOO_SMALL;", "  }", "  }", " ", "  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];", "  const sp<MetaData> bufmeta = mBuffer->meta_data();", "     bufmeta->clear();", "  if (smpl->encryptedsizes.size()) {", "         bufmeta->setData(kKeyPlainSizes, 0,", "                 smpl->clearsizes.array(), smpl->clearsizes.size() * 4);", "         bufmeta->setData(kKeyEncryptedSizes, 0,", "                 smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);", "         bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16);  ", "         bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);", "         bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);", "         bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);", "  }", " ", "  if (!mIsAVC || mWantsNALFragments) {", "  if (newBuffer) {", "  if (!isInRange((size_t)0u, mBuffer->size(), size)) {", "                 mBuffer->release();", "                 mBuffer = NULL;", " ", "                 ALOGE(\"fragmentedRead ERROR_MALFORMED size %zu\", size);", "  return ERROR_MALFORMED;", "  }", " ", "  ssize_t num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);", " ", "  if (num_bytes_read < (ssize_t)size) {", "                 mBuffer->release();", "                 mBuffer = NULL;", " ", "                 ALOGE(\"i/o error\");", "  return ERROR_IO;", "  }", " ", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", "             mBuffer->meta_data()->setInt64(", "                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "                 mBuffer->meta_data()->setInt64(", "                         kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", "  }", " ", "  if (!mIsAVC) {", "  *out = mBuffer;", "             mBuffer = NULL;", " ", "  return OK;", "  }", " ", " ", "         CHECK(mBuffer->range_length() >= mNALLengthSize);", " ", "  const uint8_t *src =", "  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();", " ", "  size_t nal_size = parseNALSize(src);", "  if (mNALLengthSize > SIZE_MAX - nal_size) {", "             ALOGE(\"b/24441553, b/24445122\");", "  }", " ", "  if (mBuffer->range_length() - mNALLengthSize < nal_size) {", "             ALOGE(\"incomplete NAL unit.\");", " ", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_MALFORMED;", "  }", " ", "  MediaBuffer *clone = mBuffer->clone();", "         CHECK(clone != NULL);", "         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);", " ", "         CHECK(mBuffer != NULL);", "         mBuffer->set_range(", "                 mBuffer->range_offset() + mNALLengthSize + nal_size,", "                 mBuffer->range_length() - mNALLengthSize - nal_size);", " ", "  if (mBuffer->range_length() == 0) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  *out = clone;", " ", "  return OK;", "  } else {", "         ALOGV(\"whole NAL\");", "  ssize_t num_bytes_read = 0;", "  int32_t drm = 0;", "  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);", "  void *data = NULL;", "  bool isMalFormed = false;", "  if (usesDRM) {", "  if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {", "                 isMalFormed = true;", "  } else {", "                 data = mBuffer->data();", "  }", "  } else {", "  int32_t max_size;", "  if (mFormat == NULL", "  || !mFormat->findInt32(kKeyMaxInputSize, &max_size)", "  || !isInRange((size_t)0u, (size_t)max_size, size)) {", "                 isMalFormed = true;", "  } else {", "                 data = mSrcBuffer;", "  }", "  }", " ", "  if (isMalFormed || data == NULL) {", "             ALOGE(\"isMalFormed size %zu\", size);", "  if (mBuffer != NULL) {", "                 mBuffer->release();", "                 mBuffer = NULL;", "  }", "  return ERROR_MALFORMED;", "  }", "         num_bytes_read = mDataSource->readAt(offset, data, size);", " ", "  if (num_bytes_read < (ssize_t)size) {", "             mBuffer->release();", "             mBuffer = NULL;", " ", "             ALOGE(\"i/o error\");", "  return ERROR_IO;", "  }", " ", "  if (usesDRM) {", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", " ", "  } else {", "  uint8_t *dstData = (uint8_t *)mBuffer->data();", "  size_t srcOffset = 0;", "  size_t dstOffset = 0;", " ", "  while (srcOffset < size) {", "                 isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);", "  size_t nalLength = 0;", "  if (!isMalFormed) {", "                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);", "                     srcOffset += mNALLengthSize;", "                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)", "  || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)", "  || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);", "  }", " ", "  if (isMalFormed) {", "                     ALOGE(\"Video is malformed; nalLength %zu\", nalLength);", "                     mBuffer->release();", "                     mBuffer = NULL;", "  return ERROR_MALFORMED;", "  }", " ", "  if (nalLength == 0) {", " ", "                      continue;", "                  }", "  ", "                CHECK(dstOffset + 4 <= mBuffer->size());", "                 if (dstOffset > SIZE_MAX - 4 ||", "                         dstOffset + 4 > SIZE_MAX - nalLength ||", "                         dstOffset + 4 + nalLength > mBuffer->size()) {", "                     ALOGE(\"b/26365349 : %zu %zu\", dstOffset, mBuffer->size());", "                     android_errorWriteLog(0x534e4554, \"26365349\");", "                     mBuffer->release();", "                     mBuffer = NULL;", "                     return ERROR_MALFORMED;", "                 }", "  ", "                  dstData[dstOffset++] = 0;", "                  dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 1;", "                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);", "                 srcOffset += nalLength;", "                 dstOffset += nalLength;", "  }", "             CHECK_EQ(srcOffset, size);", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, dstOffset);", "  }", " ", "         mBuffer->meta_data()->setInt64(", "                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "             mBuffer->meta_data()->setInt64(", "                     kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", " ", "  *out = mBuffer;", "         mBuffer = NULL;", " ", "  return OK;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int install_process_keyring(void)", "  {", " \tstruct cred *new;", " \tint ret;", " ", " \tnew = prepare_creds();", " \tif (!new)", " \t\treturn -ENOMEM;", " ", "  \tret = install_process_keyring_to_cred(new);", "  \tif (ret < 0) {", "  \t\tabort_creds(new);", "\t\treturn ret != -EEXIST ? ret : 0;", " \t\treturn ret;", "  \t}", "  ", "  \treturn commit_creds(new);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  void Document::detach(const AttachContext& context)", "  {", "      TRACE_EVENT0(\"blink\", \"Document::detach\");", "    ASSERT(!m_frame || m_frame->tree().childCount() == 0);", "     RELEASE_ASSERT(!m_frame || m_frame->tree().childCount() == 0);", "      if (!isActive())", "          return;", "  ", "     FrameNavigationDisabler navigationDisabler(*m_frame);", "     HTMLFrameOwnerElement::UpdateSuspendScope suspendWidgetHierarchyUpdates;", "     ScriptForbiddenScope forbidScript;", "     view()->dispose();", "     m_markers->prepareForDestruction();", "     if (LocalDOMWindow* window = this->domWindow())", "         window->willDetachDocumentFromFrame();", " ", "     m_lifecycle.advanceTo(DocumentLifecycle::Stopping);", " ", "     if (page())", "         page()->documentDetached(this);", "     InspectorInstrumentation::documentDetached(this);", " ", "     if (m_frame->loader().client()->sharedWorkerRepositoryClient())", "         m_frame->loader().client()->sharedWorkerRepositoryClient()->documentDetached(this);", " ", "     stopActiveDOMObjects();", " ", "     if (m_scriptedAnimationController)", "         m_scriptedAnimationController->clearDocumentPointer();", "     m_scriptedAnimationController.clear();", " ", "     m_scriptedIdleTaskController.clear();", " ", "     if (svgExtensions())", "         accessSVGExtensions().pauseAnimations();", " ", "     if (m_domWindow)", "         m_domWindow->clearEventQueue();", " ", "     if (m_layoutView)", "         m_layoutView->setIsInWindow(false);", " ", "     if (registrationContext())", "         registrationContext()->documentWasDetached();", " ", "     m_hoverNode = nullptr;", "     m_activeHoverElement = nullptr;", "     m_autofocusElement = nullptr;", " ", "     if (m_focusedElement.get()) {", "         RefPtrWillBeRawPtr<Element> oldFocusedElement = m_focusedElement;", "         m_focusedElement = nullptr;", "         if (frameHost())", "             frameHost()->chromeClient().focusedNodeChanged(oldFocusedElement.get(), nullptr);", "     }", " ", "     if (this == &axObjectCacheOwner())", "         clearAXObjectCache();", " ", "     m_layoutView = nullptr;", "     ContainerNode::detach(context);", " ", "     if (this != &axObjectCacheOwner()) {", "         if (AXObjectCache* cache = existingAXObjectCache()) {", "             for (Node& node : NodeTraversal::descendantsOf(*this)) {", "                 cache->remove(&node);", "             }", "         }", "     }", " ", "     styleEngine().didDetach();", " ", "     frameHost()->eventHandlerRegistry().documentDetached(*this);", " ", "     m_frame->inputMethodController().documentDetached();", " ", "     if (!loader())", "         m_fetcher->clearContext();", "     if (m_importsController)", "         HTMLImportsController::removeFrom(*this);", " ", "     m_timers.setTimerTaskRunner(", "         Platform::current()->currentThread()->scheduler()->timerTaskRunner()->adoptClone());", " ", "     m_frame = nullptr;", " ", "     if (m_mediaQueryMatcher)", "         m_mediaQueryMatcher->documentDetached();", " ", "     DocumentLifecycleNotifier::notifyDocumentWasDetached();", "     m_lifecycle.advanceTo(DocumentLifecycle::Stopped);", " ", "     DocumentLifecycleNotifier::notifyContextDestroyed();", "     ExecutionContext::notifyContextDestroyed();", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,", " \t\t\tint cpu_id)", " {", " \tstruct ring_buffer_per_cpu *cpu_buffer;", " \tunsigned long nr_pages;", " \tint cpu, err = 0;", " ", " \t ", " \tif (!buffer)", " \t\treturn size;", " ", " \t ", " \tif (cpu_id != RING_BUFFER_ALL_CPUS &&", "  \t    !cpumask_test_cpu(cpu_id, buffer->cpumask))", "  \t\treturn size;", "  ", "\tsize = DIV_ROUND_UP(size, BUF_PAGE_SIZE);", "\tsize *= BUF_PAGE_SIZE;", " \tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);", "  ", "  \t ", "\tif (size < BUF_PAGE_SIZE * 2)", "\t\tsize = BUF_PAGE_SIZE * 2;", " \tif (nr_pages < 2)", " \t\tnr_pages = 2;", "  ", "\tnr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);", " \tsize = nr_pages * BUF_PAGE_SIZE;", "  ", "  \t ", " \tif (atomic_read(&buffer->resize_disabled))", " \t\treturn -EBUSY;", " ", " \t ", " \tmutex_lock(&buffer->mutex);", " ", " \tif (cpu_id == RING_BUFFER_ALL_CPUS) {", " \t\t ", " \t\tfor_each_buffer_cpu(buffer, cpu) {", " \t\t\tcpu_buffer = buffer->buffers[cpu];", " ", " \t\t\tcpu_buffer->nr_pages_to_update = nr_pages -", " \t\t\t\t\t\t\tcpu_buffer->nr_pages;", " \t\t\t ", " \t\t\tif (cpu_buffer->nr_pages_to_update <= 0)", " \t\t\t\tcontinue;", " \t\t\t ", " \t\t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);", " \t\t\tif (__rb_allocate_pages(cpu_buffer->nr_pages_to_update,", " \t\t\t\t\t\t&cpu_buffer->new_pages, cpu)) {", " \t\t\t\t ", " \t\t\t\terr = -ENOMEM;", " \t\t\t\tgoto out_err;", " \t\t\t}", " \t\t}", " ", " \t\tget_online_cpus();", " \t\t ", " \t\tfor_each_buffer_cpu(buffer, cpu) {", " \t\t\tcpu_buffer = buffer->buffers[cpu];", " \t\t\tif (!cpu_buffer->nr_pages_to_update)", " \t\t\t\tcontinue;", " ", " \t\t\t ", " \t\t\tif (!cpu_online(cpu)) {", " \t\t\t\trb_update_pages(cpu_buffer);", " \t\t\t\tcpu_buffer->nr_pages_to_update = 0;", " \t\t\t} else {", " \t\t\t\tschedule_work_on(cpu,", " \t\t\t\t\t\t&cpu_buffer->update_pages_work);", " \t\t\t}", " \t\t}", " ", " \t\t ", " \t\tfor_each_buffer_cpu(buffer, cpu) {", " \t\t\tcpu_buffer = buffer->buffers[cpu];", " \t\t\tif (!cpu_buffer->nr_pages_to_update)", " \t\t\t\tcontinue;", " ", " \t\t\tif (cpu_online(cpu))", " \t\t\t\twait_for_completion(&cpu_buffer->update_done);", " \t\t\tcpu_buffer->nr_pages_to_update = 0;", " \t\t}", " ", " \t\tput_online_cpus();", " \t} else {", " \t\t ", " \t\tif (!cpumask_test_cpu(cpu_id, buffer->cpumask))", " \t\t\tgoto out;", " ", " \t\tcpu_buffer = buffer->buffers[cpu_id];", " ", " \t\tif (nr_pages == cpu_buffer->nr_pages)", " \t\t\tgoto out;", " ", " \t\tcpu_buffer->nr_pages_to_update = nr_pages -", " \t\t\t\t\t\tcpu_buffer->nr_pages;", " ", " \t\tINIT_LIST_HEAD(&cpu_buffer->new_pages);", " \t\tif (cpu_buffer->nr_pages_to_update > 0 &&", " \t\t\t__rb_allocate_pages(cpu_buffer->nr_pages_to_update,", " \t\t\t\t\t    &cpu_buffer->new_pages, cpu_id)) {", " \t\t\terr = -ENOMEM;", " \t\t\tgoto out_err;", " \t\t}", " ", " \t\tget_online_cpus();", " ", " \t\t ", " \t\tif (!cpu_online(cpu_id))", " \t\t\trb_update_pages(cpu_buffer);", " \t\telse {", " \t\t\tschedule_work_on(cpu_id,", " \t\t\t\t\t &cpu_buffer->update_pages_work);", " \t\t\twait_for_completion(&cpu_buffer->update_done);", " \t\t}", " ", " \t\tcpu_buffer->nr_pages_to_update = 0;", " \t\tput_online_cpus();", " \t}", " ", "  out:", " \t ", " \tif (atomic_read(&buffer->record_disabled)) {", " \t\tatomic_inc(&buffer->record_disabled);", " \t\t ", " \t\tsynchronize_sched();", " \t\tfor_each_buffer_cpu(buffer, cpu) {", " \t\t\tcpu_buffer = buffer->buffers[cpu];", " \t\t\trb_check_pages(cpu_buffer);", " \t\t}", " \t\tatomic_dec(&buffer->record_disabled);", " \t}", " ", " \tmutex_unlock(&buffer->mutex);", " \treturn size;", " ", "  out_err:", " \tfor_each_buffer_cpu(buffer, cpu) {", " \t\tstruct buffer_page *bpage, *tmp;", " ", " \t\tcpu_buffer = buffer->buffers[cpu];", " \t\tcpu_buffer->nr_pages_to_update = 0;", " ", " \t\tif (list_empty(&cpu_buffer->new_pages))", " \t\t\tcontinue;", " ", " \t\tlist_for_each_entry_safe(bpage, tmp, &cpu_buffer->new_pages,", " \t\t\t\t\tlist) {", " \t\t\tlist_del_init(&bpage->list);", " \t\t\tfree_buffer_page(bpage);", " \t\t}", " \t}", " \tmutex_unlock(&buffer->mutex);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" network_init ()", " {", " #ifdef HAVE_GNUTLS", "     char *ca_path, *ca_path2;", " ", "     gnutls_global_init ();", "     gnutls_certificate_allocate_credentials (&gnutls_xcred);", "     ", "     ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));", "     if (ca_path)", "     {", "         ca_path2 = string_replace (ca_path, \"%h\", weechat_home);", "         if (ca_path2)", "         {", "             gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,", "                                                     GNUTLS_X509_FMT_PEM);", "             free (ca_path2);", "          }", "          free (ca_path);", "      }", "     gnutls_certificate_set_verify_function (gnutls_xcred,", "                                             &hook_connect_gnutls_verify_certificates);", "      gnutls_certificate_client_set_retrieve_function (gnutls_xcred,", "                                                       &hook_connect_gnutls_set_certificates);", "      network_init_ok = 1;", "     gcry_check_version (GCRYPT_VERSION);", "     gcry_control (GCRYCTL_DISABLE_SECMEM, 0);", "     gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);", " #endif", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,", " \t\t\t   struct msghdr *msg, size_t len)", " {", " \tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);", " \tstruct sock *sk = sock->sk;", " \tstruct netlink_sock *nlk = nlk_sk(sk);", " \tstruct sockaddr_nl *addr = msg->msg_name;", " \tu32 dst_pid;", " \tu32 dst_group;", " \tstruct sk_buff *skb;", " \tint err;", " \tstruct scm_cookie scm;", " ", " \tif (msg->msg_flags&MSG_OOB)", " \t\treturn -EOPNOTSUPP;", " ", " \tif (NULL == siocb->scm)", " \t\tsiocb->scm = &scm;", " ", " \terr = scm_send(sock, msg, siocb->scm, true);", " \tif (err < 0)", " \t\treturn err;", " ", " \tif (msg->msg_namelen) {", " \t\terr = -EINVAL;", " \t\tif (addr->nl_family != AF_NETLINK)", " \t\t\tgoto out;", "  \t\tdst_pid = addr->nl_pid;", "  \t\tdst_group = ffs(addr->nl_groups);", "  \t\terr =  -EPERM;", "\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))", " \t\tif ((dst_group || dst_pid) &&", " \t\t    !netlink_capable(sock, NL_NONROOT_SEND))", "  \t\t\tgoto out;", "  \t} else {", "  \t\tdst_pid = nlk->dst_pid;", " \t\tdst_group = nlk->dst_group;", " \t}", " ", " \tif (!nlk->pid) {", " \t\terr = netlink_autobind(sock);", " \t\tif (err)", " \t\t\tgoto out;", " \t}", " ", " \terr = -EMSGSIZE;", " \tif (len > sk->sk_sndbuf - 32)", " \t\tgoto out;", " \terr = -ENOBUFS;", " \tskb = alloc_skb(len, GFP_KERNEL);", " \tif (skb == NULL)", " \t\tgoto out;", " ", " \tNETLINK_CB(skb).pid\t= nlk->pid;", " \tNETLINK_CB(skb).dst_group = dst_group;", " \tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));", " ", " \terr = -EFAULT;", " \tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {", " \t\tkfree_skb(skb);", " \t\tgoto out;", " \t}", " ", " \terr = security_netlink_send(sk, skb);", " \tif (err) {", " \t\tkfree_skb(skb);", " \t\tgoto out;", " \t}", " ", " \tif (dst_group) {", " \t\tatomic_inc(&skb->users);", " \t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);", " \t}", " \terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);", " ", " out:", " \tscm_destroy(siocb->scm);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,", " \t\tsize_t size, int flags)", " {", " \tstruct sock *sk = sock->sk;", " \tstruct atm_vcc *vcc;", "  \tstruct sk_buff *skb;", "  \tint copied, error = -EINVAL;", "  ", "\tmsg->msg_namelen = 0;", "  \tif (sock->state != SS_CONNECTED)", "  \t\treturn -ENOTCONN;", "  ", " \t ", " \tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))", " \t\treturn -EOPNOTSUPP;", " ", " \tvcc = ATM_SD(sock);", " \tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||", " \t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||", " \t    !test_bit(ATM_VF_READY, &vcc->flags))", " \t\treturn 0;", " ", " \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);", " \tif (!skb)", " \t\treturn error;", " ", " \tcopied = skb->len;", " \tif (copied > size) {", " \t\tcopied = size;", " \t\tmsg->msg_flags |= MSG_TRUNC;", " \t}", " ", " \terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);", " \tif (error)", " \t\treturn error;", " \tsock_recv_ts_and_drops(msg, sk, skb);", " ", " \tif (!(flags & MSG_PEEK)) {", " \t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),", " \t\t\t skb->truesize);", " \t\tatm_return(vcc, skb->truesize);", " \t}", " ", " \tskb_free_datagram(sk, skb);", " \treturn copied;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)", " {", " \tstruct nfs_server *server = NFS_SERVER(state->inode);", " \tstruct nfs4_closedata *calldata;", " \tstruct nfs4_state_owner *sp = state->owner;", " \tstruct rpc_task *task;", " \tstruct rpc_message msg = {", " \t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],", " \t\t.rpc_cred = state->owner->so_cred,", " \t};", " \tstruct rpc_task_setup task_setup_data = {", " \t\t.rpc_client = server->client,", " \t\t.rpc_message = &msg,", " \t\t.callback_ops = &nfs4_close_ops,", " \t\t.workqueue = nfsiod_workqueue,", " \t\t.flags = RPC_TASK_ASYNC,", " \t};", " \tint status = -ENOMEM;", " ", " \tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);", " \tif (calldata == NULL)", " \t\tgoto out;", " \tcalldata->inode = state->inode;", " \tcalldata->state = state;", " \tcalldata->arg.fh = NFS_FH(state->inode);", " \tcalldata->arg.stateid = &state->open_stateid;", " \t ", "  \tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);", "  \tif (calldata->arg.seqid == NULL)", "  \t\tgoto out_free_calldata;", "\tcalldata->arg.open_flags = 0;", " \tcalldata->arg.fmode = 0;", "  \tcalldata->arg.bitmask = server->attr_bitmask;", "  \tcalldata->res.fattr = &calldata->fattr;", "  \tcalldata->res.seqid = calldata->arg.seqid;", " \tcalldata->res.server = server;", " \tcalldata->path.mnt = mntget(path->mnt);", " \tcalldata->path.dentry = dget(path->dentry);", " ", " \tmsg.rpc_argp = &calldata->arg,", " \tmsg.rpc_resp = &calldata->res,", " \ttask_setup_data.callback_data = calldata;", " \ttask = rpc_run_task(&task_setup_data);", " \tif (IS_ERR(task))", " \t\treturn PTR_ERR(task);", " \tstatus = 0;", " \tif (wait)", " \t\tstatus = rpc_wait_for_completion_task(task);", " \trpc_put_task(task);", " \treturn status;", " out_free_calldata:", " \tkfree(calldata);", " out:", " \tnfs4_put_open_state(state);", " \tnfs4_put_state_owner(sp);", "  \treturn status;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {", "     return BasicClient::dump(fd, args);", " }", " ", " status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {", "      String8 result;", "      result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\",", "              mCameraId,", "             getRemoteCallback()->asBinder().get(),", "             mClientPid);", "     result.append(\"  State: \");", " ", "     mFrameProcessor->dump(fd, args);", " ", "  return dumpDevice(fd, args);", " }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void WebGL2RenderingContextBase::texSubImage3D(GLenum target,", "                                                GLint level,", "                                                GLint xoffset,", "                                                GLint yoffset,", "                                                GLint zoffset,", "                                                GLsizei width,", "                                                GLsizei height,", "                                                GLsizei depth,", "                                                GLenum format,", "                                                GLenum type,", "                                                GLintptr offset) {", "   if (isContextLost())", "     return;", "   if (!ValidateTexture3DBinding(\"texSubImage3D\", target))", "     return;", "   if (!bound_pixel_unpack_buffer_) {", "     SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage3D\",", "                        \"no bound PIXEL_UNPACK_BUFFER\");", "      return;", "    }", "   if (unpack_flip_y_ || unpack_premultiply_alpha_) {", "     SynthesizeGLError(", "         GL_INVALID_OPERATION, \"texSubImage3D\",", "         \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures\");", "     return;", "   }", "    if (!ValidateTexFunc(\"texSubImage3D\", kTexSubImage, kSourceUnpackBuffer,", "                         target, level, 0, width, height, depth, 0, format, type,", "                         xoffset, yoffset, zoffset))", "     return;", "   if (!ValidateValueFitNonNegInt32(\"texSubImage3D\", \"offset\", offset))", "     return;", " ", "   ContextGL()->TexSubImage3D(target, level, xoffset, yoffset, zoffset, width,", "                              height, depth, format, type,", "                              reinterpret_cast<const void*>(offset));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,", "                                           const unsigned char *end )", " {", "     int ret = 0;", "     size_t n;", " ", "     if( ssl->conf->f_psk == NULL &&", "         ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||", "           ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );", "         return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );", "     }", " ", "       ", "    if( *p + 2 > end )", "     if( end - *p < 2 )", "      {", "          MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );", "          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );", "     }", " ", "      n = ( (*p)[0] << 8 ) | (*p)[1];", "      *p += 2;", "  ", "    if( n < 1 || n > 65535 || *p + n > end )", "     if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )", "      {", "          MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );", "          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );", "     }", " ", "     if( ssl->conf->f_psk != NULL )", "     {", "         if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )", "             ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;", "     }", "     else", "     {", "          ", "         if( n != ssl->conf->psk_identity_len ||", "             mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )", "         {", "             ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;", "         }", "     }", " ", "     if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )", "     {", "         MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );", "         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                         MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );", "         return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );", "     }", " ", "     *p += n;", " ", "     return( 0 );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int mk_request_error(int http_status, struct client_session *cs,", "                      struct session_request *sr) {", "     int ret, fd;", "     mk_ptr_t message, *page = 0;", "     struct error_page *entry;", "     struct mk_list *head;", "     struct file_info finfo;", " ", "     mk_header_set_http_status(sr, http_status);", " ", "      ", "     if (http_status != MK_CLIENT_LENGTH_REQUIRED &&", "         http_status != MK_CLIENT_BAD_REQUEST &&", "         http_status != MK_CLIENT_REQUEST_ENTITY_TOO_LARGE) {", " ", "          ", "         mk_list_foreach(head, &sr->host_conf->error_pages) {", "             entry = mk_list_entry(head, struct error_page, _head);", "             if (entry->status != http_status) {", "                 continue;", "             }", " ", "              ", "             ret = mk_file_get_info(entry->real_path, &finfo);", "             if (ret == -1) {", "                 break;", "             }", " ", "              ", "             fd = open(entry->real_path, config->open_flags);", "             if (fd == -1) {", "                  break;", "              }", "  ", "            sr->fd_file = fd;", "             sr->fd_file   = fd;", "             sr->fd_is_fdt = MK_FALSE;", "              sr->bytes_to_send = finfo.size;", "              sr->headers.content_length = finfo.size;", "              sr->headers.real_length    = finfo.size;", " ", "             memcpy(&sr->file_info, &finfo, sizeof(struct file_info));", " ", "             mk_header_send(cs->socket, cs, sr);", "             return mk_http_send_file(cs, sr);", "         }", "     }", " ", "     mk_ptr_reset(&message);", " ", "     switch (http_status) {", "     case MK_CLIENT_BAD_REQUEST:", "         page = mk_request_set_default_page(\"Bad Request\",", "                                            sr->uri,", "                                            sr->host_conf->host_signature);", "         break;", " ", "     case MK_CLIENT_FORBIDDEN:", "         page = mk_request_set_default_page(\"Forbidden\",", "                                            sr->uri,", "                                            sr->host_conf->host_signature);", "         break;", " ", "     case MK_CLIENT_NOT_FOUND:", "         mk_string_build(&message.data, &message.len,", "                         \"The requested URL was not found on this server.\");", "         page = mk_request_set_default_page(\"Not Found\",", "                                            message,", "                                            sr->host_conf->host_signature);", "         mk_ptr_free(&message);", "         break;", " ", "     case MK_CLIENT_REQUEST_ENTITY_TOO_LARGE:", "         mk_string_build(&message.data, &message.len,", "                         \"The request entity is too large.\");", "         page = mk_request_set_default_page(\"Entity too large\",", "                                            message,", "                                            sr->host_conf->host_signature);", "         mk_ptr_free(&message);", "         break;", " ", "     case MK_CLIENT_METHOD_NOT_ALLOWED:", "         page = mk_request_set_default_page(\"Method Not Allowed\",", "                                            sr->uri,", "                                            sr->host_conf->host_signature);", "         break;", " ", "     case MK_CLIENT_REQUEST_TIMEOUT:", "     case MK_CLIENT_LENGTH_REQUIRED:", "         break;", " ", "     case MK_SERVER_NOT_IMPLEMENTED:", "         page = mk_request_set_default_page(\"Method Not Implemented\",", "                                            sr->uri,", "                                            sr->host_conf->host_signature);", "         break;", " ", "     case MK_SERVER_INTERNAL_ERROR:", "         page = mk_request_set_default_page(\"Internal Server Error\",", "                                            sr->uri,", "                                            sr->host_conf->host_signature);", "         break;", " ", "     case MK_SERVER_HTTP_VERSION_UNSUP:", "         mk_ptr_reset(&message);", "         page = mk_request_set_default_page(\"HTTP Version Not Supported\",", "                                            message,", "                                            sr->host_conf->host_signature);", "         break;", "     }", " ", "     if (page) {", "         sr->headers.content_length = page->len;", "     }", " ", "     sr->headers.location = NULL;", "     sr->headers.cgi = SH_NOCGI;", "     sr->headers.pconnections_left = 0;", "     sr->headers.last_modified = -1;", " ", "     if (!page) {", "         mk_ptr_reset(&sr->headers.content_type);", "     }", "     else {", "         mk_ptr_set(&sr->headers.content_type, \"text/html\\r\\n\");", "     }", " ", "     mk_header_send(cs->socket, cs, sr);", " ", "     if (page) {", "         if (sr->method != MK_HTTP_METHOD_HEAD)", "             mk_socket_send(cs->socket, page->data, page->len);", " ", "         mk_ptr_free(page);", "         mk_mem_free(page);", "     }", " ", "      ", "     mk_server_cork_flag(cs->socket, TCP_CORK_OFF);", "     return EXIT_ERROR;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void initServerConfig() {", "server.port = REDIS_SERVERPORT;", "server.bindaddr = NULL;", "server.unixsocket = NULL;", "server.ipfd = -1;", "server.sofd = -1;", "server.dbnum = REDIS_DEFAULT_DBNUM;", "server.verbosity = REDIS_VERBOSE;", "server.maxidletime = REDIS_MAXIDLETIME;", "server.saveparams = NULL;", "server.loading = 0;", "server.logfile = NULL;", "server.syslog_enabled = 0;", "server.syslog_ident = zstrdup(\"redis\");", "server.syslog_facility = LOG_LOCAL0;", "server.glueoutputbuf = 1;", "server.daemonize = 0;", "server.appendonly = 0;", "server.appendfsync = APPENDFSYNC_EVERYSEC;", "server.no_appendfsync_on_rewrite = 0;", "server.lastfsync = time(NULL);", "server.appendfd = -1;", "server.appendseldb = -1;", "server.pidfile = zstrdup(\"/var/run/redis.pid\");", "server.dbfilename = zstrdup(\"dump.rdb\");", "server.appendfilename = zstrdup(\"appendonly.aof\");", "server.requirepass = NULL;", "server.rdbcompression = 1;", "server.activerehashing = 1;", "server.maxclients = 0;", "server.bpop_blocked_clients = 0;", "server.maxmemory = 0;", "server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU;", "server.maxmemory_samples = 3;", "server.vm_enabled = 0;", "server.vm_swap_file = zstrdup(\"/tmp/redis-%p.vm\");", "server.vm_page_size = 256;", "server.vm_pages = 1024*1024*100;", "server.vm_max_memory = 1024LL*1024*1024*1;", "server.vm_max_threads = 4;", "server.vm_blocked_clients = 0;", "server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES;", "server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE;", "server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES;", "server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE;", "server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES;", "server.shutdown_asap = 0;", "", "updateLRUClock();", "resetServerSaveParams();", "", "appendServerSaveParams(60*60,1);", "appendServerSaveParams(300,100);", "appendServerSaveParams(60,10000);", "", "server.isslave = 0;", "server.masterauth = NULL;", "server.masterhost = NULL;", "server.masterport = 6379;", "server.master = NULL;", "server.replstate = REDIS_REPL_NONE;", "server.repl_serve_stale_data = 1;", "", "", "R_Zero = 0.0;", "R_PosInf = 1.0/R_Zero;", "R_NegInf = -1.0/R_Zero;", "R_Nan = R_Zero/R_Zero;", "", "", "", "", "server.commands = dictCreate(&commandTableDictType,NULL);", "populateCommandTable();", "server.delCommand = lookupCommandByCString(\"del\");", "server.multiCommand = lookupCommandByCString(\"multi\");", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long Cluster::ParseSimpleBlock(long long block_size, long long& pos,", "  long& len) {", "  const long long block_start = pos;", "  const long long block_stop = pos + block_size;", " ", "  IMkvReader* const pReader = m_pSegment->m_pReader;", " ", "  long long total, avail;", " ", "  long status = pReader->Length(&total, &avail);", " ", "  if (status < 0)  ", "  return status;", " ", "   assert((total < 0) || (avail <= total));", " ", " ", "  if ((pos + 1) > avail) {", "     len = 1;", "  return E_BUFFER_NOT_FULL;", "  }", " ", "  long long result = GetUIntLength(pReader, pos, len);", " ", "  if (result < 0)  ", "  return static_cast<long>(result);", " ", "  if (result > 0)  ", "  return E_BUFFER_NOT_FULL;", " ", "  if ((pos + len) > block_stop)", "  return E_FILE_FORMAT_INVALID;", " ", "  if ((pos + len) > avail)", "  return E_BUFFER_NOT_FULL;", " ", "  const long long track = ReadUInt(pReader, pos, len);", " ", "  if (track < 0)  ", "  return static_cast<long>(track);", " ", " ", "    if (track == 0)", "      return E_FILE_FORMAT_INVALID;", "  ", "#if 0", "    const Tracks* const pTracks = m_pSegment->GetTracks();", "    assert(pTracks);", "    const long tn = static_cast<long>(track);", "    const Track* const pTrack = pTracks->GetTrackByNumber(tn);", "    if (pTrack == NULL)", "        return E_FILE_FORMAT_INVALID;", "#endif", "    pos += len;   ", "  ", "    if ((pos + 2) > block_stop)", "  return E_FILE_FORMAT_INVALID;", " ", "  if ((pos + 2) > avail) {", "     len = 2;", "  return E_BUFFER_NOT_FULL;", "  }", " ", "   pos += 2;  ", " ", "  if ((pos + 1) > block_stop)", "  return E_FILE_FORMAT_INVALID;", " ", "  if ((pos + 1) > avail) {", "     len = 1;", "  return E_BUFFER_NOT_FULL;", "  }", " ", "  unsigned char flags;", " ", "   status = pReader->Read(pos, 1, &flags);", " ", "  if (status < 0) {  ", "     len = 1;", "  return status;", "  }", " ", "  ++pos;  ", "   assert(pos <= avail);", " ", "  if (pos >= block_stop)", "  return E_FILE_FORMAT_INVALID;", " ", "  const int lacing = int(flags & 0x06) >> 1;", " ", "  if ((lacing != 0) && (block_stop > avail)) {", "     len = static_cast<long>(block_stop - pos);", "  return E_BUFFER_NOT_FULL;", "  }", " ", "   status = CreateBlock(0x23,  ", "                        block_start, block_size,", "  0);  ", " ", "  if (status != 0)", "  return status;", " ", "   m_pos = block_stop;", " ", "  return 0;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,", " \t\t\t       struct msghdr *msg, size_t len)", " {", " \tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);", " \tstruct sock *sk = sock->sk;", " \tstruct sock *other = NULL;", " \tint err, size;", " \tstruct sk_buff *skb;", " \tint sent = 0;", " \tstruct scm_cookie tmp_scm;", " \tbool fds_sent = false;", " \tint max_level;", " ", "  \tif (NULL == siocb->scm)", "  \t\tsiocb->scm = &tmp_scm;", "  \twait_for_unix_gc();", "\terr = scm_send(sock, msg, siocb->scm);", " \terr = scm_send(sock, msg, siocb->scm, false);", "  \tif (err < 0)", "  \t\treturn err;", "  ", " \terr = -EOPNOTSUPP;", " \tif (msg->msg_flags&MSG_OOB)", " \t\tgoto out_err;", " ", " \tif (msg->msg_namelen) {", " \t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;", " \t\tgoto out_err;", " \t} else {", " \t\terr = -ENOTCONN;", " \t\tother = unix_peer(sk);", " \t\tif (!other)", " \t\t\tgoto out_err;", " \t}", " ", " \tif (sk->sk_shutdown & SEND_SHUTDOWN)", " \t\tgoto pipe_err;", " ", " \twhile (sent < len) {", " \t\t ", " ", " \t\tsize = len-sent;", " ", " \t\t ", " \t\tif (size > ((sk->sk_sndbuf >> 1) - 64))", " \t\t\tsize = (sk->sk_sndbuf >> 1) - 64;", " ", " \t\tif (size > SKB_MAX_ALLOC)", " \t\t\tsize = SKB_MAX_ALLOC;", " ", " \t\t ", " ", " \t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,", " \t\t\t\t\t  &err);", " ", " \t\tif (skb == NULL)", " \t\t\tgoto out_err;", " ", " \t\t ", " \t\tsize = min_t(int, size, skb_tailroom(skb));", " ", " ", " \t\t ", " \t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);", " \t\tif (err < 0) {", " \t\t\tkfree_skb(skb);", " \t\t\tgoto out_err;", " \t\t}", " \t\tmax_level = err + 1;", " \t\tfds_sent = true;", " ", " \t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);", " \t\tif (err) {", " \t\t\tkfree_skb(skb);", " \t\t\tgoto out_err;", " \t\t}", " ", " \t\tunix_state_lock(other);", " ", " \t\tif (sock_flag(other, SOCK_DEAD) ||", " \t\t    (other->sk_shutdown & RCV_SHUTDOWN))", " \t\t\tgoto pipe_err_free;", " ", " \t\tmaybe_add_creds(skb, sock, other);", " \t\tskb_queue_tail(&other->sk_receive_queue, skb);", " \t\tif (max_level > unix_sk(other)->recursion_level)", " \t\t\tunix_sk(other)->recursion_level = max_level;", " \t\tunix_state_unlock(other);", " \t\tother->sk_data_ready(other, size);", " \t\tsent += size;", " \t}", " ", " \tscm_destroy(siocb->scm);", " \tsiocb->scm = NULL;", " ", " \treturn sent;", " ", " pipe_err_free:", " \tunix_state_unlock(other);", " \tkfree_skb(skb);", " pipe_err:", " \tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))", " \t\tsend_sig(SIGPIPE, current, 0);", " \terr = -EPIPE;", " out_err:", " \tscm_destroy(siocb->scm);", " \tsiocb->scm = NULL;", " \treturn sent ? : err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,", "    PNG_CONST char *name)", "     const char *name)", "  {", "      ", "    pm->state = modifier_start;", "    pm->bit_depth = 0;", "    pm->colour_type = 255;", " ", "    pm->pending_len = 0;", "    pm->pending_chunk = 0;", "    pm->flush = 0;", "    pm->buffer_count = 0;", "    pm->buffer_position = 0;", " ", "  return set_store_for_read(&pm->this, ppi, id, name);", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool GLSurfaceEGLSurfaceControl::ScheduleOverlayPlane(", "     int z_order,", "     gfx::OverlayTransform transform,", "     GLImage* image,", "     const gfx::Rect& bounds_rect,", "     const gfx::RectF& crop_rect,", "     bool enable_blend,", "     std::unique_ptr<gfx::GpuFence> gpu_fence) {", "   if (!pending_transaction_)", "     pending_transaction_.emplace();", " ", "   bool uninitialized = false;", "   if (pending_surfaces_count_ == surface_list_.size()) {", "     uninitialized = true;", "     surface_list_.emplace_back(*root_surface_);", "   }", "   pending_surfaces_count_++;", "   auto& surface_state = surface_list_.at(pending_surfaces_count_ - 1);", " ", "   if (uninitialized || surface_state.z_order != z_order) {", "     surface_state.z_order = z_order;", "     pending_transaction_->SetZOrder(*surface_state.surface, z_order);", "   }", " ", "   AHardwareBuffer* hardware_buffer = nullptr;", "   base::ScopedFD fence_fd;", "   auto scoped_hardware_buffer = image->GetAHardwareBuffer();", "   if (scoped_hardware_buffer) {", "     hardware_buffer = scoped_hardware_buffer->buffer();", "     fence_fd = scoped_hardware_buffer->TakeFence();", " ", "     auto* a_surface = surface_state.surface->surface();", "     DCHECK_EQ(pending_frame_resources_.count(a_surface), 0u);", " ", "     auto& resource_ref = pending_frame_resources_[a_surface];", "     resource_ref.surface = surface_state.surface;", "      resource_ref.scoped_buffer = std::move(scoped_hardware_buffer);", "    }", "  ", "  if (uninitialized || surface_state.hardware_buffer != hardware_buffer) {", "   surface_state.buffer_updated_in_pending_transaction =", "       uninitialized || surface_state.hardware_buffer != hardware_buffer;", "   if (surface_state.buffer_updated_in_pending_transaction) {", "      surface_state.hardware_buffer = hardware_buffer;", "  ", "      if (!fence_fd.is_valid() && gpu_fence && surface_state.hardware_buffer) {", "       auto fence_handle =", "           gfx::CloneHandleForIPC(gpu_fence->GetGpuFenceHandle());", "       DCHECK(!fence_handle.is_null());", "       fence_fd = base::ScopedFD(fence_handle.native_fd.fd);", "     }", " ", "     pending_transaction_->SetBuffer(*surface_state.surface,", "                                     surface_state.hardware_buffer,", "                                     std::move(fence_fd));", "   }", " ", "   if (hardware_buffer) {", "     gfx::Rect dst = bounds_rect;", " ", "     gfx::Size buffer_size = GetBufferSize(hardware_buffer);", "     gfx::RectF scaled_rect =", "         gfx::RectF(crop_rect.x() * buffer_size.width(),", "                    crop_rect.y() * buffer_size.height(),", "                    crop_rect.width() * buffer_size.width(),", "                    crop_rect.height() * buffer_size.height());", "     gfx::Rect src = gfx::ToEnclosedRect(scaled_rect);", " ", "     if (uninitialized || surface_state.src != src || surface_state.dst != dst ||", "         surface_state.transform != transform) {", "       surface_state.src = src;", "       surface_state.dst = dst;", "       surface_state.transform = transform;", "       pending_transaction_->SetGeometry(*surface_state.surface, src, dst,", "                                         transform);", "     }", "   }", " ", "   bool opaque = !enable_blend;", "   if (uninitialized || surface_state.opaque != opaque) {", "     surface_state.opaque = opaque;", "     pending_transaction_->SetOpaque(*surface_state.surface, opaque);", "   }", " ", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CredentialManagerImpl::OnProvisionalSaveComplete() {", "   DCHECK(form_manager_);", "   DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());", "   const autofill::PasswordForm& form = form_manager_->pending_credentials();", " ", "   if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {", "     form_manager_->Save();", "     return;", "   }", " ", "   if (!form.federation_origin.unique()) {", "     for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {", "       if (match->username_value == form.username_value &&", "           match->federation_origin.IsSameOriginWith(form.federation_origin)) {", "         form_manager_->Update(*match);", "         return;", "       }", "     }", "   } else if (!form_manager_->IsNewLogin()) {", "    form_manager_->Update(*form_manager_->preferred_match());", "     auto best_match = form_manager_->best_matches().find(form.username_value);", "      ", "      ", "     DCHECK(best_match != form_manager_->best_matches().end());", "     form_manager_->Update(*best_match->second);", "      return;", "    }", "  ", "   client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)", " {", " \tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;", " \tu16 scid, flags, result;", " \tstruct sock *sk;", " ", " \tscid   = __le16_to_cpu(rsp->scid);", " \tflags  = __le16_to_cpu(rsp->flags);", " \tresult = __le16_to_cpu(rsp->result);", " ", " \tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",", " \t\t\tscid, flags, result);", " ", " \tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);", " \tif (!sk)", " \t\treturn 0;", " ", " \tswitch (result) {", " \tcase L2CAP_CONF_SUCCESS:", "  \t\tbreak;", "  ", "  \tcase L2CAP_CONF_UNACCEPT:", "\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {", "\t\t\tchar req[128];", " \t\tif (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {", " \t\t\tint len = cmd->len - sizeof(*rsp);", " \t\t\tchar req[64];", " ", " \t\t\t ", "\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,", "\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);", "\t\t\tgoto done;", " \t\t\tresult = L2CAP_CONF_SUCCESS;", " \t\t\tlen = l2cap_parse_conf_rsp(sk, rsp->data,", " \t\t\t\t\t\t\tlen, req, &result);", " \t\t\tif (len < 0) {", " \t\t\t\tstruct l2cap_disconn_req req;", " \t\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);", " \t\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);", " \t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),", " \t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);", " \t\t\t\tgoto done;", " \t\t\t}", " ", " \t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),", " \t\t\t\t\t\tL2CAP_CONF_REQ, len, req);", " \t\t\tl2cap_pi(sk)->num_conf_req++;", " \t\t\tif (result != L2CAP_CONF_SUCCESS)", " \t\t\t\tgoto done;", " \t\t\tbreak;", "  \t\t}", "  ", "  \tdefault:", " \t\tsk->sk_state = BT_DISCONN;", " \t\tsk->sk_err = ECONNRESET;", " \t\tl2cap_sock_set_timer(sk, HZ * 5);", " \t\t{", " \t\t\tstruct l2cap_disconn_req req;", " \t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);", " \t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);", " \t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),", " \t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);", " \t\t}", " \t\tgoto done;", " \t}", " ", " \tif (flags & 0x01)", " \t\tgoto done;", " ", " \tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;", " ", " \tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {", " \t\tsk->sk_state = BT_CONNECTED;", " \t\tl2cap_chan_ready(sk);", " \t}", " ", " done:", " \tbh_unlock_sock(sk);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void SerializedScriptValue::transferArrayBuffers(v8::Isolate* isolate, const ArrayBufferArray& arrayBuffers, ExceptionState& exceptionState)", " {", "     if (!arrayBuffers.size())", "         return;", " ", "     for (size_t i = 0; i < arrayBuffers.size(); ++i) {", "         if (arrayBuffers[i]->isNeutered()) {", "             exceptionState.throwDOMException(DataCloneError, \"ArrayBuffer at index \" + String::number(i) + \" is already neutered.\");", "             return;", "         }", "     }", " ", "     OwnPtr<ArrayBufferContentsArray> contents = adoptPtr(new ArrayBufferContentsArray(arrayBuffers.size()));", " ", "     HeapHashSet<Member<DOMArrayBufferBase>> visited;", "     for (size_t i = 0; i < arrayBuffers.size(); ++i) {", "         if (visited.contains(arrayBuffers[i]))", "             continue;", "         visited.add(arrayBuffers[i]);", " ", "         if (arrayBuffers[i]->isShared()) {", "             bool result = arrayBuffers[i]->shareContentsWith(contents->at(i));", "             if (!result) {", "                 exceptionState.throwDOMException(DataCloneError, \"SharedArrayBuffer at index \" + String::number(i) + \" could not be transferred.\");", "                 return;", "             }", "         } else {", "             Vector<v8::Local<v8::ArrayBuffer>, 4> bufferHandles;", "             v8::HandleScope handleScope(isolate);", "             acculumateArrayBuffersForAllWorlds(isolate, static_cast<DOMArrayBuffer*>(arrayBuffers[i].get()), bufferHandles);", "             bool isNeuterable = true;", "             for (size_t j = 0; j < bufferHandles.size(); ++j)", "                 isNeuterable &= bufferHandles[j]->IsNeuterable();", "  ", "              DOMArrayBufferBase* toTransfer = arrayBuffers[i];", "              if (!isNeuterable)", "                toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer());", "                 toTransfer = DOMArrayBuffer::create(arrayBuffers[i]->buffer()->data(), arrayBuffers[i]->buffer()->byteLength());", "              bool result = toTransfer->transfer(contents->at(i));", "              if (!result) {", "                  exceptionState.throwDOMException(DataCloneError, \"ArrayBuffer at index \" + String::number(i) + \" could not be transferred.\");", "                 return;", "             }", " ", "             if (isNeuterable)", "                 for (size_t j = 0; j < bufferHandles.size(); ++j)", "                     bufferHandles[j]->Neuter();", "         }", " ", "     }", "     m_arrayBufferContentsArray = contents.release();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int nfc_dev_up(struct nfc_dev *dev)", "{", "int rc = 0;", "", "pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));", "", "device_lock(&dev->dev);", "", "if (!device_is_registered(&dev->dev)) {", "rc = -ENODEV;", "goto error;", "}", "", "if (dev->rfkill && rfkill_blocked(dev->rfkill)) {", "rc = -ERFKILL;", "goto error;", "}", "", "if (dev->fw_download_in_progress) {", "rc = -EBUSY;", "goto error;", "}", "", "if (dev->dev_up) {", "rc = -EALREADY;", "goto error;", "}", "", "if (dev->ops->dev_up)", "rc = dev->ops->dev_up(dev);", "", "if (!rc)", "dev->dev_up = true;", "", "", "if (dev->ops->discover_se && dev->ops->discover_se(dev))", "pr_err(\"SE discovery failed\\n\");", "", "error:", "device_unlock(&dev->dev);", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sysapi_translate_arch( const char *machine, const char *)", " {", " \tchar tmp[64];", " \tchar *tmparch;", " ", " #if defined(AIX)", " \t ", " \tstruct utsname buf;", " ", " \tif( uname(&buf) < 0 ) {", " \t\treturn NULL;", " \t}", " ", " \treturn( get_aix_arch( &buf ) );", " ", " #elif defined(HPUX)", " ", " \treturn( get_hpux_arch( ) );", " #else", " ", " \tif( !strcmp(machine, \"alpha\") ) {", " \t\tsprintf( tmp, \"ALPHA\" );", " \t}", " \telse if( !strcmp(machine, \"i86pc\") ) {", " \t\tsprintf( tmp, \"INTEL\" );", " \t}", " \telse if( !strcmp(machine, \"i686\") ) {", " \t\tsprintf( tmp, \"INTEL\" );", " \t}", " \telse if( !strcmp(machine, \"i586\") ) {", " \t\tsprintf( tmp, \"INTEL\" );", " \t}", " \telse if( !strcmp(machine, \"i486\") ) {", " \t\tsprintf( tmp, \"INTEL\" );", " \t}", " \telse if( !strcmp(machine, \"i386\") ) {  ", " #if defined(Darwin)", " \t\t ", " \t\tint ret;", " \t\tchar val[32];", " \t\tsize_t len = sizeof(val);", " ", " \t\t ", " \t\tsprintf( tmp, \"INTEL\" );", " \t\tret = sysctlbyname(\"kern.osrelease\", &val, &len, NULL, 0);", " \t\tif (ret == 0 && strncmp(val, \"10.\", 3) == 0) {", " \t\t\t ", " \t\t\tsprintf( tmp, \"X86_64\" );", " \t\t}", " #else", " \t\tsprintf( tmp, \"INTEL\" );", " #endif", " \t}", " \telse if( !strcmp(machine, \"ia64\") ) {", " \t\tsprintf( tmp, \"IA64\" );", " \t}", " \telse if( !strcmp(machine, \"x86_64\") ) {", " \t\tsprintf( tmp, \"X86_64\" );", " \t}", " \telse if( !strcmp(machine, \"amd64\") ) {", " \t\tsprintf( tmp, \"X86_64\" );", " \t}", " \telse if( !strcmp(machine, \"sun4u\") ) {", " \t\tsprintf( tmp, \"SUN4u\" );", " \t}", " \telse if( !strcmp(machine, \"sun4m\") ) {", " \t\tsprintf( tmp, \"SUN4x\" );", " \t}", " \telse if( !strcmp(machine, \"sun4c\") ) {", " \t\tsprintf( tmp, \"SUN4x\" );", " \t}", " \telse if( !strcmp(machine, \"sparc\") ) {  ", " \t\tsprintf( tmp, \"SUN4x\" );", " \t}", " \telse if( !strcmp(machine, \"Power Macintosh\") ) {  ", " \t\tsprintf( tmp, \"PPC\" );", " \t}", " \telse if( !strcmp(machine, \"ppc\") ) {", " \t\tsprintf( tmp, \"PPC\" );", " \t}", " \telse if( !strcmp(machine, \"ppc32\") ) {", " \t\tsprintf( tmp, \"PPC\" );", " \t}", " \telse if( !strcmp(machine, \"ppc64\") ) {", " \t\tsprintf( tmp, \"PPC64\" );", "         }", "         else {", "               sprintf( tmp, machine );", "                sprintf( tmp, \"%s\", machine );", "         }", "  ", "         tmparch = strdup( tmp );", " \tif( !tmparch ) {", " \t\tEXCEPT( \"Out of memory!\" );", " \t}", " \treturn( tmparch );", " #endif  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  tiffcp(TIFF* in, TIFF* out)", "  {", "\tuint16 bitspersample, samplesperpixel = 1;", " \tuint16 bitspersample = 1, samplesperpixel = 1;", "  \tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;", "  \tcopyFunc cf;", "  \tuint32 width, length;", " \tstruct cpTag* p;", " ", " \tCopyField(TIFFTAG_IMAGEWIDTH, width);", " \tCopyField(TIFFTAG_IMAGELENGTH, length);", " \tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);", " \tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);", " \tif (compression != (uint16)-1)", " \t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);", " \telse", " \t\tCopyField(TIFFTAG_COMPRESSION, compression);", " \tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);", " \tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);", " \tif (input_compression == COMPRESSION_JPEG) {", " \t\t ", " \t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);", " \t} else if (input_photometric == PHOTOMETRIC_YCBCR) {", " \t\t ", " \t\tuint16 subsamplinghor,subsamplingver;", " ", " \t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,", " \t\t\t\t      &subsamplinghor, &subsamplingver);", " \t\tif (subsamplinghor!=1 || subsamplingver!=1) {", " \t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",", " \t\t\t\tTIFFFileName(in));", " \t\t\treturn FALSE;", " \t\t}", " \t}", " \tif (compression == COMPRESSION_JPEG) {", " \t\tif (input_photometric == PHOTOMETRIC_RGB &&", " \t\t    jpegcolormode == JPEGCOLORMODE_RGB)", " \t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);", " \t\telse", " \t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);", " \t}", " \telse if (compression == COMPRESSION_SGILOG", " \t    || compression == COMPRESSION_SGILOG24)", " \t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,", " \t\t    samplesperpixel == 1 ?", " \t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);", " \telse if (input_compression == COMPRESSION_JPEG &&", " \t\t\t samplesperpixel == 3 ) {", " \t\t ", " \t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);", " \t}", " \telse", " \t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);", " \tif (fillorder != 0)", " \t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);", " \telse", " \t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);", " \t ", " \tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);", " \tswitch (orientation) {", " \t\tcase ORIENTATION_BOTRIGHT:", " \t\tcase ORIENTATION_RIGHTBOT:\t ", " \t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");", " \t\t\torientation = ORIENTATION_BOTLEFT;", " \t\t ", " \t\tcase ORIENTATION_LEFTBOT:\t ", " \t\tcase ORIENTATION_BOTLEFT:", " \t\t\tbreak;", " \t\tcase ORIENTATION_TOPRIGHT:", " \t\tcase ORIENTATION_RIGHTTOP:\t ", " \t\tdefault:", " \t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");", " \t\t\torientation = ORIENTATION_TOPLEFT;", " \t\t ", " \t\tcase ORIENTATION_LEFTTOP:\t ", " \t\tcase ORIENTATION_TOPLEFT:", " \t\t\tbreak;", " \t}", " \tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);", " \t ", " \tif (outtiled == -1)", " \t\touttiled = TIFFIsTiled(in);", " \tif (outtiled) {", " \t\t ", " \t\tif (tilewidth == (uint32) -1)", " \t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);", " \t\tif (tilelength == (uint32) -1)", " \t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);", " \t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);", " \t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);", " \t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);", " \t} else {", " \t\t ", " \t\tif (rowsperstrip == (uint32) 0) {", " \t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,", " \t\t\t    &rowsperstrip)) {", " \t\t\t\trowsperstrip =", " \t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);", " \t\t\t}", " \t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)", " \t\t\t\trowsperstrip = length;", " \t\t}", " \t\telse if (rowsperstrip == (uint32) -1)", " \t\t\trowsperstrip = length;", " \t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);", " \t}", " \tif (config != (uint16) -1)", " \t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);", " \telse", " \t\tCopyField(TIFFTAG_PLANARCONFIG, config);", " \tif (samplesperpixel <= 4)", " \t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);", " \tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);", "  ", " \tswitch (compression) {", " \t\tcase COMPRESSION_JPEG:", " \t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);", " \t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);", " \t\t\tbreak;", " \t\tcase COMPRESSION_JBIG:", " \t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);", " \t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);", " \t\t\tbreak;", " \t\tcase COMPRESSION_LZW:", " \t\tcase COMPRESSION_ADOBE_DEFLATE:", " \t\tcase COMPRESSION_DEFLATE:", "                 case COMPRESSION_LZMA:", " \t\t\tif (predictor != (uint16)-1)", " \t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);", " \t\t\telse", " \t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);", " \t\t\tif (preset != -1) {", "                                 if (compression == COMPRESSION_ADOBE_DEFLATE", "                                          || compression == COMPRESSION_DEFLATE)", "                                         TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);", " \t\t\t\telse if (compression == COMPRESSION_LZMA)", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);", "                         }", " \t\t\tbreak;", " \t\tcase COMPRESSION_CCITTFAX3:", " \t\tcase COMPRESSION_CCITTFAX4:", " \t\t\tif (compression == COMPRESSION_CCITTFAX3) {", " \t\t\t\tif (g3opts != (uint32) -1)", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,", " \t\t\t\t\t    g3opts);", " \t\t\t\telse", " \t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);", " \t\t\t} else", " \t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);", " \t\t\tbreak;", " \t}", " \t{", " \t\tuint32 len32;", " \t\tvoid** data;", " \t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))", " \t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);", " \t}", " \t{", " \t\tuint16 ninks;", " \t\tconst char* inknames;", " \t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {", " \t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);", " \t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {", " \t\t\t\tint inknameslen = strlen(inknames) + 1;", " \t\t\t\tconst char* cp = inknames;", " \t\t\t\twhile (ninks > 1) {", " \t\t\t\t\tcp = strchr(cp, '\\0');", "                                         cp++;", "                                         inknameslen += (strlen(cp) + 1);", " \t\t\t\t\tninks--;", " \t\t\t\t}", " \t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);", " \t\t\t}", " \t\t}", " \t}", " \t{", " \t\tunsigned short pg0, pg1;", " ", " \t\tif (pageInSeq == 1) {", " \t\t\tif (pageNum < 0)   {", " \t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);", " \t\t\t} else", " \t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);", " ", " \t\t} else {", " \t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {", " \t\t\t\tif (pageNum < 0)  ", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);", " \t\t\t\telse", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);", " \t\t\t}", " \t\t}", " \t}", " ", " \tfor (p = tags; p < &tags[NTAGS]; p++)", " \t\tCopyTag(p->tag, p->count, p->type);", " ", " \tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);", " \treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int Equalizer_getParameter(EffectContext *pContext,", "  void *pParam,", "  uint32_t *pValueSize,", "  void *pValue){", "  int status = 0;", "  int bMute = 0;", "  int32_t *pParamTemp = (int32_t *)pParam;", "  int32_t param = *pParamTemp++;", "  int32_t param2;", "  char *name;", " ", " ", "  switch (param) {", "  case EQ_PARAM_NUM_BANDS:", "  case EQ_PARAM_CUR_PRESET:", "  case EQ_PARAM_GET_NUM_OF_PRESETS:", "  case EQ_PARAM_BAND_LEVEL:", "  case EQ_PARAM_GET_BAND:", "  if (*pValueSize < sizeof(int16_t)) {", "             ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = sizeof(int16_t);", "  break;", " ", "  case EQ_PARAM_LEVEL_RANGE:", "  if (*pValueSize < 2 * sizeof(int16_t)) {", "             ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = 2 * sizeof(int16_t);", "  break;", "  case EQ_PARAM_BAND_FREQ_RANGE:", "  if (*pValueSize < 2 * sizeof(int32_t)) {", "             ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = 2 * sizeof(int32_t);", "  break;", " ", "  case EQ_PARAM_CENTER_FREQ:", "  if (*pValueSize < sizeof(int32_t)) {", "             ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = sizeof(int32_t);", "  break;", " ", "  case EQ_PARAM_GET_PRESET_NAME:", "  break;", " ", "  case EQ_PARAM_PROPERTIES:", "  if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) {", "             ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t);", "  break;", " ", "  default:", "         ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter unknown param %d\", param);", "  return -EINVAL;", "  }", " ", "  switch (param) {", "  case EQ_PARAM_NUM_BANDS:", "  *(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS;", "  break;", " ", "  case EQ_PARAM_LEVEL_RANGE:", "  *(int16_t *)pValue = -1500;", "  *((int16_t *)pValue + 1) = 1500;", "  break;", " ", "  ", "      case EQ_PARAM_BAND_LEVEL:", "          param2 = *pParamTemp;", "        if (param2 >= FIVEBAND_NUMBANDS) {", "         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {", "              status = -EINVAL;", "             if (param2 < 0) {", "                 android_errorWriteLog(0x534e4554, \"32438598\");", "                 ALOGW(\"\\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d\", param2);", "             }", "              break;", "          }", "          *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2);", "  break;", " ", "  ", "      case EQ_PARAM_CENTER_FREQ:", "          param2 = *pParamTemp;", "        if (param2 >= FIVEBAND_NUMBANDS) {", "         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {", "              status = -EINVAL;", "             if (param2 < 0) {", "                 android_errorWriteLog(0x534e4554, \"32436341\");", "                 ALOGW(\"\\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d\", param2);", "             }", "              break;", "          }", "          *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2);", "  break;", " ", "  ", "      case EQ_PARAM_BAND_FREQ_RANGE:", "          param2 = *pParamTemp;", "        if (param2 >= FIVEBAND_NUMBANDS) {", "         if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) {", "              status = -EINVAL;", "             if (param2 < 0) {", "                 android_errorWriteLog(0x534e4554, \"32247948\");", "                 ALOGW(\"\\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d\", param2);", "             }", "              break;", "          }", "          EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1));", "  break;", " ", "  case EQ_PARAM_GET_BAND:", "         param2 = *pParamTemp;", "  *(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2);", "  break;", " ", "  case EQ_PARAM_CUR_PRESET:", "  *(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext);", "  break;", " ", "  case EQ_PARAM_GET_NUM_OF_PRESETS:", "  *(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets();", "  break;", " ", "  case EQ_PARAM_GET_PRESET_NAME:", "         param2 = *pParamTemp;", "  if (param2 >= EqualizerGetNumPresets()) {", "             status = -EINVAL;", "  break;", "  }", "         name = (char *)pValue;", "         strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1);", "         name[*pValueSize - 1] = 0;", "  *pValueSize = strlen(name) + 1;", "  break;", " ", "  case EQ_PARAM_PROPERTIES: {", "  int16_t *p = (int16_t *)pValue;", "         ALOGV(\"\\tEqualizer_getParameter() EQ_PARAM_PROPERTIES\");", "         p[0] = (int16_t)EqualizerGetPreset(pContext);", "         p[1] = (int16_t)FIVEBAND_NUMBANDS;", "  for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {", "             p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i);", "  }", "  } break;", " ", "  default:", "         ALOGV(\"\\tLVM_ERROR : Equalizer_getParameter() invalid param %d\", param);", "         status = -EINVAL;", "  break;", "  }", " ", "  return status;", " }  ", " ", " int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){", "  int status = 0;", "  int32_t preset;", "  int32_t band;", "  int32_t level;", "  int32_t *pParamTemp = (int32_t *)pParam;", "  int32_t param = *pParamTemp++;", " ", " ", "  switch (param) {", "  case EQ_PARAM_CUR_PRESET:", "         preset = (int32_t)(*(uint16_t *)pValue);", " ", "  if ((preset >= EqualizerGetNumPresets())||(preset < 0)) {", "             status = -EINVAL;", "  break;", "  }", "  EqualizerSetPreset(pContext, preset);", "  break;", "  case EQ_PARAM_BAND_LEVEL:", "         band = *pParamTemp;", "         level = (int32_t)(*(int16_t *)pValue);", "  if (band >= FIVEBAND_NUMBANDS) {", "             status = -EINVAL;", "  break;", "  }", "  EqualizerSetBandLevel(pContext, band, level);", "  break;", "  case EQ_PARAM_PROPERTIES: {", "  int16_t *p = (int16_t *)pValue;", "  if ((int)p[0] >= EqualizerGetNumPresets()) {", "             status = -EINVAL;", "  break;", "  }", "  if (p[0] >= 0) {", "  EqualizerSetPreset(pContext, (int)p[0]);", "  } else {", "  if ((int)p[1] != FIVEBAND_NUMBANDS) {", "                 status = -EINVAL;", "  break;", "  }", "  for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {", "  EqualizerSetBandLevel(pContext, i, (int)p[2 + i]);", "  }", "  }", "  } break;", "  default:", "         ALOGV(\"\\tLVM_ERROR : Equalizer_setParameter() invalid param %d\", param);", "         status = -EINVAL;", "  break;", "  }", " ", "  return status;", " }  ", " ", " ", " int Volume_getParameter(EffectContext *pContext,", "  void *pParam,", "  uint32_t *pValueSize,", "  void *pValue){", "  int status = 0;", "  int bMute = 0;", "  int32_t *pParamTemp = (int32_t *)pParam;", "  int32_t param = *pParamTemp++;;", "  char *name;", " ", " ", "  switch (param){", "  case VOLUME_PARAM_LEVEL:", "  case VOLUME_PARAM_MAXLEVEL:", "  case VOLUME_PARAM_STEREOPOSITION:", "  if (*pValueSize != sizeof(int16_t)){", "                 ALOGV(\"\\tLVM_ERROR : Volume_getParameter() invalid pValueSize 1  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = sizeof(int16_t);", "  break;", " ", "  case VOLUME_PARAM_MUTE:", "  case VOLUME_PARAM_ENABLESTEREOPOSITION:", "  if (*pValueSize < sizeof(int32_t)){", "                 ALOGV(\"\\tLVM_ERROR : Volume_getParameter() invalid pValueSize 2  %d\", *pValueSize);", "  return -EINVAL;", "  }", "  *pValueSize = sizeof(int32_t);", "  break;", " ", "  default:", "             ALOGV(\"\\tLVM_ERROR : Volume_getParameter unknown param %d\", param);", "  return -EINVAL;", "  }", " ", "  switch (param){", "  case VOLUME_PARAM_LEVEL:", "             status = VolumeGetVolumeLevel(pContext, (int16_t *)(pValue));", "  break;", " ", "  case VOLUME_PARAM_MAXLEVEL:", "  *(int16_t *)pValue = 0;", "  break;", " ", "  case VOLUME_PARAM_STEREOPOSITION:", "  VolumeGetStereoPosition(pContext, (int16_t *)pValue);", "  break;", " ", "  case VOLUME_PARAM_MUTE:", "             status = VolumeGetMute(pContext, (uint32_t *)pValue);", "             ALOGV(\"\\tVolume_getParameter() VOLUME_PARAM_MUTE Value is %d\",", "  *(uint32_t *)pValue);", "  break;", " ", "  case VOLUME_PARAM_ENABLESTEREOPOSITION:", "  *(int32_t *)pValue = pContext->pBundledContext->bStereoPositionEnabled;", "  break;", " ", "  default:", "             ALOGV(\"\\tLVM_ERROR : Volume_getParameter() invalid param %d\", param);", "             status = -EINVAL;", "  break;", "  }", " ", "  return status;", " }  ", " ", " ", " ", " int Volume_setParameter (EffectContext *pContext, void *pParam, void *pValue){", "  int      status = 0;", "  int16_t  level;", "  int16_t  position;", "  uint32_t mute;", "  uint32_t positionEnabled;", "  int32_t *pParamTemp = (int32_t *)pParam;", "  int32_t param = *pParamTemp++;", " ", " ", "  switch (param){", "  case VOLUME_PARAM_LEVEL:", "             level = *(int16_t *)pValue;", "             status = VolumeSetVolumeLevel(pContext, (int16_t)level);", "  break;", " ", "  case VOLUME_PARAM_MUTE:", "             mute = *(uint32_t *)pValue;", "             status = VolumeSetMute(pContext, mute);", "  break;", " ", "  case VOLUME_PARAM_ENABLESTEREOPOSITION:", "             positionEnabled = *(uint32_t *)pValue;", "             status = VolumeEnableStereoPosition(pContext, positionEnabled);", "             status = VolumeSetStereoPosition(pContext, pContext->pBundledContext->positionSaved);", "  break;", " ", "  case VOLUME_PARAM_STEREOPOSITION:", "             position = *(int16_t *)pValue;", "             status = VolumeSetStereoPosition(pContext, (int16_t)position);", "  break;", " ", "  default:", "             ALOGV(\"\\tLVM_ERROR : Volume_setParameter() invalid param %d\", param);", "  break;", "  }", " ", "  return status;", " }  ", " ", "  ", " ", " LVM_INT16 LVC_ToDB_s32Tos16(LVM_INT32 Lin_fix)", " {", "     LVM_INT16   db_fix;", "     LVM_INT16   Shift;", "     LVM_INT16   SmallRemainder;", "     LVM_UINT32  Remainder = (LVM_UINT32)Lin_fix;", " ", "   ", "  for (Shift = 0; Shift<32; Shift++)", "  {", "  if ((Remainder & 0x80000000U)!=0)", "  {", "  break;", "  }", "  Remainder = Remainder << 1;", "  }", " ", "   ", "     db_fix    = (LVM_INT16)(-96 * Shift);  ", "  SmallRemainder = (LVM_INT16)((Remainder & 0x7fffffff) >> 24);", "     db_fix = (LVM_INT16)(db_fix + SmallRemainder );", "  SmallRemainder = (LVM_INT16)(SmallRemainder * SmallRemainder);", "     db_fix = (LVM_INT16)(db_fix - (LVM_INT16)((LVM_UINT16)SmallRemainder >> 9));", " ", "   ", "     db_fix = (LVM_INT16)(db_fix - 5);", " ", "  return db_fix;", " }", " ", " ", " int Effect_setEnabled(EffectContext *pContext, bool enabled)", " {", "     ALOGV(\"\\tEffect_setEnabled() type %d, enabled %d\", pContext->EffectType, enabled);", " ", "  if (enabled) {", "  bool tempDisabled = false;", "  switch (pContext->EffectType) {", "  case LVM_BASS_BOOST:", "  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {", "                      ALOGV(\"\\tEffect_setEnabled() LVM_BASS_BOOST is already enabled\");", "  return -EINVAL;", "  }", "  if(pContext->pBundledContext->SamplesToExitCountBb <= 0){", "                     pContext->pBundledContext->NumberEffectsEnabled++;", "  }", "                 pContext->pBundledContext->SamplesToExitCountBb =", "  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);", "                 pContext->pBundledContext->bBassEnabled = LVM_TRUE;", "                 tempDisabled = pContext->pBundledContext->bBassTempDisabled;", "  break;", "  case LVM_EQUALIZER:", "  if (pContext->pBundledContext->bEqualizerEnabled == LVM_TRUE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_EQUALIZER is already enabled\");", "  return -EINVAL;", "  }", "  if(pContext->pBundledContext->SamplesToExitCountEq <= 0){", "                     pContext->pBundledContext->NumberEffectsEnabled++;", "  }", "                 pContext->pBundledContext->SamplesToExitCountEq =", "  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);", "                 pContext->pBundledContext->bEqualizerEnabled = LVM_TRUE;", "  break;", "  case LVM_VIRTUALIZER:", "  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_VIRTUALIZER is already enabled\");", "  return -EINVAL;", "  }", "  if(pContext->pBundledContext->SamplesToExitCountVirt <= 0){", "                     pContext->pBundledContext->NumberEffectsEnabled++;", "  }", "                 pContext->pBundledContext->SamplesToExitCountVirt =", "  (LVM_INT32)(pContext->pBundledContext->SamplesPerSecond*0.1);", "                 pContext->pBundledContext->bVirtualizerEnabled = LVM_TRUE;", "                 tempDisabled = pContext->pBundledContext->bVirtualizerTempDisabled;", "  break;", "  case LVM_VOLUME:", "  if (pContext->pBundledContext->bVolumeEnabled == LVM_TRUE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_VOLUME is already enabled\");", "  return -EINVAL;", "  }", "                 pContext->pBundledContext->NumberEffectsEnabled++;", "                 pContext->pBundledContext->bVolumeEnabled = LVM_TRUE;", "  break;", "  default:", "                 ALOGV(\"\\tEffect_setEnabled() invalid effect type\");", "  return -EINVAL;", "  }", "  if (!tempDisabled) {", "  LvmEffect_enable(pContext);", "  }", "  } else {", "  switch (pContext->EffectType) {", "  case LVM_BASS_BOOST:", "  if (pContext->pBundledContext->bBassEnabled == LVM_FALSE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_BASS_BOOST is already disabled\");", "  return -EINVAL;", "  }", "                 pContext->pBundledContext->bBassEnabled = LVM_FALSE;", "  break;", "  case LVM_EQUALIZER:", "  if (pContext->pBundledContext->bEqualizerEnabled == LVM_FALSE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_EQUALIZER is already disabled\");", "  return -EINVAL;", "  }", "                 pContext->pBundledContext->bEqualizerEnabled = LVM_FALSE;", "  break;", "  case LVM_VIRTUALIZER:", "  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_FALSE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_VIRTUALIZER is already disabled\");", "  return -EINVAL;", "  }", "                 pContext->pBundledContext->bVirtualizerEnabled = LVM_FALSE;", "  break;", "  case LVM_VOLUME:", "  if (pContext->pBundledContext->bVolumeEnabled == LVM_FALSE) {", "                     ALOGV(\"\\tEffect_setEnabled() LVM_VOLUME is already disabled\");", "  return -EINVAL;", "  }", "                 pContext->pBundledContext->bVolumeEnabled = LVM_FALSE;", "  break;", "  default:", "                 ALOGV(\"\\tEffect_setEnabled() invalid effect type\");", "  return -EINVAL;", "  }", "  LvmEffect_disable(pContext);", "  }", " ", "  return 0;", " }", " ", " ", " int16_t LVC_Convert_VolToDb(uint32_t vol){", "  int16_t  dB;", " ", "     dB = LVC_ToDB_s32Tos16(vol <<7);", "     dB = (dB +8)>>4;", "     dB = (dB <-96) ? -96 : dB ;", " ", "  return dB;", " }", " ", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   void AddChunk(const TransformPaintPropertyNode* t,", "                const ClipPaintPropertyNode* c,", "                const EffectPaintPropertyNode* e,", "   void AddChunk(const TransformPaintPropertyNode& t,", "                 const ClipPaintPropertyNode& c,", "                 const EffectPaintPropertyNode& e,", "                  const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {", "      auto record = sk_make_sp<PaintRecord>();", "      record->push<cc::DrawRectOp>(bounds, cc::PaintFlags());", "     AddChunk(std::move(record), t, c, e, bounds);", "   }"], "ner_tags": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" MagickExport MagickBooleanType SetQuantumDepth(const Image *image,", "   QuantumInfo *quantum_info,const size_t depth)", " {", "   size_t", "     extent,", "     quantum;", " ", "    ", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickCoreSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   assert(quantum_info != (QuantumInfo *) NULL);", "   assert(quantum_info->signature == MagickCoreSignature);", "   quantum_info->depth=depth;", "   if (quantum_info->format == FloatingPointQuantumFormat)", "     {", "       if (quantum_info->depth > 32)", "         quantum_info->depth=64;", "       else", "         if (quantum_info->depth > 16)", "           quantum_info->depth=32;", "         else", "           quantum_info->depth=16;", "     }", "    if (quantum_info->pixels != (unsigned char **) NULL)", "      DestroyQuantumPixels(quantum_info);", "    quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8;", "  extent=image->columns*quantum;", "  if ((image->columns != 0) && (quantum != (extent/image->columns)))", "   extent=MagickMax(image->columns,image->rows)*quantum;", "   if ((MagickMax(image->columns,image->rows) != 0) &&", "       (quantum != (extent/MagickMax(image->columns,image->rows))))", "      return(MagickFalse);", "    return(AcquireQuantumPixels(quantum_info,extent));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" _bson_iter_next_internal (bson_iter_t *iter,     ", "                           uint32_t next_keylen,  ", "                           const char **key,      ", "                           uint32_t *bson_type,   ", "                           bool *unsupported)     ", " {", "    const uint8_t *data;", "    uint32_t o;", "    unsigned int len;", " ", "    BSON_ASSERT (iter);", " ", "    *unsupported = false;", " ", "    if (!iter->raw) {", "       *key = NULL;", "       *bson_type = BSON_TYPE_EOD;", "       return false;", "    }", " ", "    data = iter->raw;", "    len = iter->len;", " ", "    iter->off = iter->next_off;", "    iter->type = iter->off;", "    iter->key = iter->off + 1;", "    iter->d1 = 0;", "    iter->d2 = 0;", "    iter->d3 = 0;", "    iter->d4 = 0;", " ", "    if (next_keylen == 0) {", "        ", "       for (o = iter->key; o < len; o++) {", "          if (!data[o]) {", "             iter->d1 = ++o;", "             goto fill_data_fields;", "          }", "       }", "    } else {", "       o = iter->key + next_keylen + 1;", "       iter->d1 = o;", "       goto fill_data_fields;", "    }", " ", "    goto mark_invalid;", " ", " fill_data_fields:", " ", "    *key = bson_iter_key_unsafe (iter);", "    *bson_type = ITER_TYPE (iter);", " ", "    switch (*bson_type) {", "    case BSON_TYPE_DATE_TIME:", "    case BSON_TYPE_DOUBLE:", "    case BSON_TYPE_INT64:", "    case BSON_TYPE_TIMESTAMP:", "       iter->next_off = o + 8;", "       break;", "    case BSON_TYPE_CODE:", "    case BSON_TYPE_SYMBOL:", "    case BSON_TYPE_UTF8: {", "       uint32_t l;", " ", "       if ((o + 4) >= len) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->d2 = o + 4;", "       memcpy (&l, iter->raw + iter->d1, sizeof (l));", "       l = BSON_UINT32_FROM_LE (l);", " ", "       if (l > (len - (o + 4))) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->next_off = o + 4 + l;", " ", "        ", "       if (BSON_UNLIKELY ((l == 0) || (iter->next_off >= len))) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "        ", "       if (BSON_UNLIKELY ((iter->raw + iter->d2)[l - 1] != '\\0')) {", "          iter->err_off = o + 4 + l - 1;", "          goto mark_invalid;", "       }", "    } break;", "    case BSON_TYPE_BINARY: {", "       bson_subtype_t subtype;", "       uint32_t l;", " ", "       if (o >= (len - 4)) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->d2 = o + 4;", "       iter->d3 = o + 5;", " ", "        memcpy (&l, iter->raw + iter->d1, sizeof (l));", "        l = BSON_UINT32_FROM_LE (l);", "  ", "      if (l >= (len - o)) {", "       if (l >= (len - o - 4)) {", "           iter->err_off = o;", "           goto mark_invalid;", "        }", " ", "       subtype = *(iter->raw + iter->d2);", " ", "       if (subtype == BSON_SUBTYPE_BINARY_DEPRECATED) {", "          int32_t binary_len;", " ", "          if (l < 4) {", "             iter->err_off = o;", "             goto mark_invalid;", "          }", " ", "           ", "          memcpy (&binary_len, (iter->raw + iter->d3), sizeof (binary_len));", "          binary_len = BSON_UINT32_FROM_LE (binary_len);", "          if (binary_len + 4 != l) {", "             iter->err_off = iter->d3;", "             goto mark_invalid;", "          }", "       }", " ", "       iter->next_off = o + 5 + l;", "    } break;", "    case BSON_TYPE_ARRAY:", "    case BSON_TYPE_DOCUMENT: {", "       uint32_t l;", " ", "       if (o >= (len - 4)) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       memcpy (&l, iter->raw + iter->d1, sizeof (l));", "       l = BSON_UINT32_FROM_LE (l);", " ", "       if ((l > len) || (l > (len - o))) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->next_off = o + l;", "    } break;", "    case BSON_TYPE_OID:", "       iter->next_off = o + 12;", "       break;", "    case BSON_TYPE_BOOL: {", "       char val;", " ", "       if (iter->d1 >= len) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       memcpy (&val, iter->raw + iter->d1, 1);", "       if (val != 0x00 && val != 0x01) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->next_off = o + 1;", "    } break;", "    case BSON_TYPE_REGEX: {", "       bool eor = false;", "       bool eoo = false;", " ", "       for (; o < len; o++) {", "          if (!data[o]) {", "             iter->d2 = ++o;", "             eor = true;", "             break;", "          }", "       }", " ", "       if (!eor) {", "          iter->err_off = iter->next_off;", "          goto mark_invalid;", "       }", " ", "       for (; o < len; o++) {", "          if (!data[o]) {", "             eoo = true;", "             break;", "          }", "       }", " ", "       if (!eoo) {", "          iter->err_off = iter->next_off;", "          goto mark_invalid;", "       }", " ", "       iter->next_off = o + 1;", "    } break;", "    case BSON_TYPE_DBPOINTER: {", "       uint32_t l;", " ", "       if (o >= (len - 4)) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->d2 = o + 4;", "       memcpy (&l, iter->raw + iter->d1, sizeof (l));", "       l = BSON_UINT32_FROM_LE (l);", " ", "        ", "       if (l == 0 || l > (len - o - 4)) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       if (*(iter->raw + o + l + 3)) {", "           ", "          iter->err_off = o + l + 3;", "          goto mark_invalid;", "       }", " ", "       iter->d3 = o + 4 + l;", "       iter->next_off = o + 4 + l + 12;", "    } break;", "    case BSON_TYPE_CODEWSCOPE: {", "       uint32_t l;", "       uint32_t doclen;", " ", "       if ((len < 19) || (o >= (len - 14))) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->d2 = o + 4;", "       iter->d3 = o + 8;", " ", "       memcpy (&l, iter->raw + iter->d1, sizeof (l));", "       l = BSON_UINT32_FROM_LE (l);", " ", "       if ((l < 14) || (l >= (len - o))) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       iter->next_off = o + l;", " ", "       if (iter->next_off >= len) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       memcpy (&l, iter->raw + iter->d2, sizeof (l));", "       l = BSON_UINT32_FROM_LE (l);", " ", "       if (l == 0 || l >= (len - o - 4 - 4)) {", "          iter->err_off = o;", "          goto mark_invalid;", "       }", " ", "       if ((o + 4 + 4 + l + 4) >= iter->next_off) {", "          iter->err_off = o + 4;", "          goto mark_invalid;", "       }", " ", "       iter->d4 = o + 4 + 4 + l;", "       memcpy (&doclen, iter->raw + iter->d4, sizeof (doclen));", "       doclen = BSON_UINT32_FROM_LE (doclen);", " ", "       if ((o + 4 + 4 + l + doclen) != iter->next_off) {", "          iter->err_off = o + 4 + 4 + l;", "          goto mark_invalid;", "       }", "    } break;", "    case BSON_TYPE_INT32:", "       iter->next_off = o + 4;", "       break;", "    case BSON_TYPE_DECIMAL128:", "       iter->next_off = o + 16;", "       break;", "    case BSON_TYPE_MAXKEY:", "    case BSON_TYPE_MINKEY:", "    case BSON_TYPE_NULL:", "    case BSON_TYPE_UNDEFINED:", "       iter->next_off = o;", "       break;", "    default:", "       *unsupported = true;", "     ", "    case BSON_TYPE_EOD:", "       iter->err_off = o;", "       goto mark_invalid;", "    }", " ", "     ", "    if (iter->next_off >= len) {", "       iter->err_off = o;", "       goto mark_invalid;", "    }", " ", "    iter->err_off = 0;", " ", "    return true;", " ", " mark_invalid:", "    iter->raw = NULL;", "    iter->len = 0;", "    iter->next_off = 0;", " ", "    return false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)", " {", "   MagickBooleanType", "     status;", " ", "   register const IndexPacket", "     *indexes;", " ", "   register const PixelPacket", "     *p;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register unsigned char", "     *q;", " ", "   size_t", "     depth,", "     packet_size;", " ", "   ssize_t", "     y;", " ", "   unsigned char", "     *colormap,", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);", "   if (status == MagickFalse)", "     return(status);", "   (void) TransformImageColorspace(image,sRGBColorspace);", "    ", "   if (IsPaletteImage(image,&image->exception) == MagickFalse)", "     (void) SetImageType(image,PaletteType);", "   depth=GetImageQuantumDepth(image,MagickTrue);", "   packet_size=(size_t) (depth/8);", "   pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*", "     sizeof(*pixels));", "   packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);", "   colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*", "      sizeof(*colormap));", "    if ((pixels == (unsigned char *) NULL) ||", "        (colormap == (unsigned char *) NULL))", "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "     {", "       if (colormap != (unsigned char *) NULL)", "         colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "       if (pixels != (unsigned char *) NULL)", "         pixels=(unsigned char *) RelinquishMagickMemory(pixels);", "       ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "     }", "     ", "    q=colormap;", "  q=colormap;", "    if (image->colors <= 256)", "      for (i=0; i < (ssize_t) image->colors; i++)", "      {", "       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);", "       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);", "       *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);", "     }", "   else", "     for (i=0; i < (ssize_t) image->colors; i++)", "     {", "        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);", "        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);", "        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);", "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;", "       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &", "         0xff);", "        *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);", "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);", "       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &", "         0xff);", "      }", "    (void) WriteBlob(image,packet_size*image->colors,colormap);", "    colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "    ", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "     if (p == (const PixelPacket *) NULL)", "       break;", "     indexes=GetVirtualIndexQueue(image);", "     q=pixels;", "     for (x=0; x < (ssize_t) image->columns; x++)", "     {", "       if (image->colors > 256)", "         *q++=(unsigned char) ((size_t) GetPixelIndex(indexes+x) >> 8);", "       *q++=(unsigned char) GetPixelIndex(indexes+x);", "     }", "     (void) WriteBlob(image,(size_t) (q-pixels),pixels);", "   }", "   pixels=(unsigned char *) RelinquishMagickMemory(pixels);", "   (void) CloseBlob(image);", "   return(status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void AcceleratedStaticBitmapImage::Draw(cc::PaintCanvas* canvas,", "                                         const cc::PaintFlags& flags,", "                                         const FloatRect& dst_rect,", "                                         const FloatRect& src_rect,", "                                          RespectImageOrientationEnum,", "                                          ImageClampingMode image_clamping_mode,", "                                          ImageDecodingMode decode_mode) {", "   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);", "    auto paint_image = PaintImageForCurrentFrame();", "    if (!paint_image)", "      return;", "   auto paint_image_decoding_mode = ToPaintImageDecodingMode(decode_mode);", "   if (paint_image.decoding_mode() != paint_image_decoding_mode) {", "     paint_image = PaintImageBuilder::WithCopy(std::move(paint_image))", "                       .set_decoding_mode(paint_image_decoding_mode)", "                       .TakePaintImage();", "   }", "   StaticBitmapImage::DrawHelper(canvas, flags, dst_rect, src_rect,", "                                 image_clamping_mode, paint_image);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["flatpak_context_merge (FlatpakContext *context,", "FlatpakContext *other)", "{", "GHashTableIter iter;", "gpointer key, value;", "", "context->shares &= ~other->shares_valid;", "context->shares |= other->shares;", "context->shares_valid |= other->shares_valid;", "context->sockets &= ~other->sockets_valid;", "context->sockets |= other->sockets;", "context->sockets_valid |= other->sockets_valid;", "context->devices &= ~other->devices_valid;", "context->devices |= other->devices;", "context->devices_valid |= other->devices_valid;", "context->features &= ~other->features_valid;", "context->features |= other->features;", "context->features_valid |= other->features_valid;", "", "g_hash_table_iter_init (&iter, other->env_vars);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value));", "", "g_hash_table_iter_init (&iter, other->persistent);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->persistent, g_strdup (key), value);", "", "g_hash_table_iter_init (&iter, other->filesystems);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->filesystems, g_strdup (key), value);", "", "g_hash_table_iter_init (&iter, other->session_bus_policy);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->session_bus_policy, g_strdup (key), value);", "", "g_hash_table_iter_init (&iter, other->system_bus_policy);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);", "", "g_hash_table_iter_init (&iter, other->system_bus_policy);", "while (g_hash_table_iter_next (&iter, &key, &value))", "g_hash_table_insert (context->system_bus_policy, g_strdup (key), value);", "", "g_hash_table_iter_init (&iter, other->generic_policy);", "while (g_hash_table_iter_next (&iter, &key, &value))", "{", "const char **policy_values = (const char **) value;", "int i;", "", "for (i = 0; policy_values[i] != NULL; i++)", "flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...)  ", " {", " \tva_list va;", " \tchar *message = NULL;", " ", " \tva_start(va, format);", "  \tzend_vspprintf(&message, 0, format, va);", "  ", "  \tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {", "\t\tzend_throw_error(exception_ce, message);", " \t\tzend_throw_error(exception_ce, \"%s\", message);", "  \t} else {", "  \t\tzend_error(E_ERROR, \"%s\", message);", "  \t}", " ", " \tefree(message);", " \tva_end(va);", " }", "  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE  omx_video::use_input_buffer(", "         OMX_IN OMX_HANDLETYPE            hComp,", "         OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,", "         OMX_IN OMX_U32                   port,", "         OMX_IN OMX_PTR                   appData,", "         OMX_IN OMX_U32                   bytes,", "         OMX_IN OMX_U8*                   buffer)", " {", "  (void) hComp;", "     OMX_ERRORTYPE eRet = OMX_ErrorNone;", " ", "  unsigned   i = 0;", "  unsigned char *buf_addr = NULL;", " ", "     DEBUG_PRINT_HIGH(\"use_input_buffer: port = %u appData = %p bytes = %u buffer = %p\",(unsigned int)port,appData,(unsigned int)bytes,buffer);", "  if (bytes != m_sInPortDef.nBufferSize) {", "         DEBUG_PRINT_ERROR(\"ERROR: use_input_buffer: Size Mismatch!! \"", "  \"bytes[%u] != Port.nBufferSize[%u]\", (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);", "  return OMX_ErrorBadParameter;", "  }", " ", "  if (!m_inp_mem_ptr) {", "         input_use_buffer = true;", "         m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\", "                         calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);", "  if (m_inp_mem_ptr == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");", "  return OMX_ErrorInsufficientResources;", "  }", "         DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);", " ", " ", "         m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);", "  if (m_pInput_pmem == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");", "  return OMX_ErrorInsufficientResources;", "  }", " #ifdef USE_ION", "         m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);", "  if (m_pInput_ion == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");", "  return OMX_ErrorInsufficientResources;", "  }", " #endif", " ", "  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {", "             m_pInput_pmem[i].fd = -1;", " #ifdef USE_ION", "             m_pInput_ion[i].ion_device_fd =-1;", "             m_pInput_ion[i].fd_ion_data.fd =-1;", "             m_pInput_ion[i].ion_alloc_data.handle = 0;", " #endif", "  }", " ", "  }", " ", "  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {", "  if (BITMASK_ABSENT(&m_inp_bm_count,i)) {", "  break;", "  }", "  }", " ", "  if (i < m_sInPortDef.nBufferCountActual) {", " ", "  *bufferHdr = (m_inp_mem_ptr + i);", "         BITMASK_SET(&m_inp_bm_count,i);", " ", "  (*bufferHdr)->pBuffer           = (OMX_U8 *)buffer;", "  (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);", "  (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;", "  (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;", "  (*bufferHdr)->pAppPrivate       = appData;", "  (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;", " ", "  if (!m_use_input_pmem) {", " #ifdef USE_ION", " #ifdef _MSM8974_", "             m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,", "  &m_pInput_ion[i].ion_alloc_data,", "  &m_pInput_ion[i].fd_ion_data,0);", " #else", "             m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,", "  &m_pInput_ion[i].ion_alloc_data,", "  &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);", " #endif", "  if (m_pInput_ion[i].ion_device_fd < 0) {", "                 DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");", "  return OMX_ErrorInsufficientResources;", "  }", "             m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;", " #else", "             m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);", "  if (m_pInput_pmem[i].fd == 0) {", "                 m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);", "  }", " ", "  if (m_pInput_pmem[i] .fd < 0) {", "                 DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");", "  return OMX_ErrorInsufficientResources;", "  }", " #endif", " ", "              m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;", "              m_pInput_pmem[i].offset = 0;", "  ", "            m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;", "             m_pInput_pmem[i].buffer = NULL;", "              if(!secure_session) {", "                  m_pInput_pmem[i].buffer = (unsigned char *)mmap(", "                      NULL,m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,", "                     MAP_SHARED,m_pInput_pmem[i].fd,0);", " ", "  ", "              if (m_pInput_pmem[i].buffer == MAP_FAILED) {", "                      DEBUG_PRINT_ERROR(\"ERROR: mmap() Failed\");", "                 m_pInput_pmem[i].buffer = NULL;", "                  close(m_pInput_pmem[i].fd);", "  #ifdef USE_ION", "                  free_ion_memory(&m_pInput_ion[i]);", " #endif", "  return OMX_ErrorInsufficientResources;", "  }", "  }", " ", "  } else {", "             OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *pParam = reinterpret_cast<OMX_QCOM_PLATFORM_PRIVATE_PMEM_INFO *>((*bufferHdr)->pAppPrivate);", "             DEBUG_PRINT_LOW(\"Inside qcom_ext with luma:(fd:%lu,offset:0x%x)\", pParam->pmem_fd, (unsigned)pParam->offset);", " ", "  if (pParam) {", "                 m_pInput_pmem[i].fd = pParam->pmem_fd;", "                 m_pInput_pmem[i].offset = pParam->offset;", "                 m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;", "                 m_pInput_pmem[i].buffer = (unsigned char *)buffer;", "                 DEBUG_PRINT_LOW(\"DBG:: pParam->pmem_fd = %u, pParam->offset = %u\",", "  (unsigned int)pParam->pmem_fd, (unsigned int)pParam->offset);", "  } else {", "                 DEBUG_PRINT_ERROR(\"ERROR: Invalid AppData given for PMEM i/p UseBuffer case\");", "  return OMX_ErrorBadParameter;", "  }", "  }", " ", "         DEBUG_PRINT_LOW(\"use_inp:: bufhdr = %p, pBuffer = %p, m_pInput_pmem[i].buffer = %p\",", "  (*bufferHdr), (*bufferHdr)->pBuffer, m_pInput_pmem[i].buffer);", "  if ( dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true) {", "             DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf() Failed for i/p buf\");", "  return OMX_ErrorInsufficientResources;", "  }", "  } else {", "         DEBUG_PRINT_ERROR(\"ERROR: All buffers are already used, invalid use_buf call for \"", "  \"index = %u\", i);", "         eRet = OMX_ErrorInsufficientResources;", "  }", " ", "  return eRet;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  logger_get_mask_expanded (struct t_gui_buffer *buffer, const char *mask)", "  {", "    char *mask2, *mask_decoded, *mask_decoded2, *mask_decoded3, *mask_decoded4;", "    char *mask_decoded5;", "     char *mask2, *mask3, *mask4, *mask5, *mask6, *mask7;", "      const char *dir_separator;", "      int length;", "      time_t seconds;", "      struct tm *date_tmp;", "  ", "      mask2 = NULL;", "    mask_decoded = NULL;", "    mask_decoded2 = NULL;", "    mask_decoded3 = NULL;", "    mask_decoded4 = NULL;", "    mask_decoded5 = NULL;", "     mask3 = NULL;", "     mask4 = NULL;", "     mask5 = NULL;", "     mask6 = NULL;", "     mask7 = NULL;", "  ", "      dir_separator = weechat_info_get (\"dir_separator\", \"\");", "      if (!dir_separator)", "          return NULL;", "  ", "      ", "    mask2 = weechat_string_replace (mask, dir_separator, \"\\01\");", "      ", "     length = strlen (mask) + 256 + 1;", "     mask2 = malloc (length);", "     if (!mask2)", "         goto end;", "     seconds = time (NULL);", "     date_tmp = localtime (&seconds);", "     mask2[0] = '\\0';", "     if (strftime (mask2, length - 1, mask, date_tmp) == 0)", "         mask2[0] = '\\0';", " ", "       ", "     mask3 = weechat_string_replace (mask2, dir_separator, \"\\01\");", "     if (!mask3)", "          goto end;", "  ", "    mask_decoded = weechat_buffer_string_replace_local_var (buffer, mask2);", "    if (!mask_decoded)", "     mask4 = weechat_buffer_string_replace_local_var (buffer, mask3);", "     if (!mask4)", "          goto end;", "  ", "    mask_decoded2 = weechat_string_replace (mask_decoded,", "                                            dir_separator,", "                                            weechat_config_string (logger_config_file_replacement_char));", "    if (!mask_decoded2)", "     mask5 = weechat_string_replace (mask4,", "                                     dir_separator,", "                                     weechat_config_string (logger_config_file_replacement_char));", "     if (!mask5)", "          goto end;", "  ", "  #ifdef __CYGWIN__", "    mask_decoded3 = weechat_string_replace (mask_decoded2, \"\\\\\",", "                                            weechat_config_string (logger_config_file_replacement_char));", "     mask6 = weechat_string_replace (mask5, \"\\\\\",", "                                     weechat_config_string (logger_config_file_replacement_char));", "  #else", "    mask_decoded3 = strdup (mask_decoded2);", "     mask6 = strdup (mask5);", "  #endif  ", "    if (!mask_decoded3)", "     if (!mask6)", "          goto end;", "  ", "       ", "    mask_decoded4 = weechat_string_replace (mask_decoded3,", "                                            \"\\01\", dir_separator);", "    if (!mask_decoded4)", "        goto end;", "     ", "    length = strlen (mask_decoded4) + 256 + 1;", "    mask_decoded5 = malloc (length);", "    if (!mask_decoded5)", "     mask7 = weechat_string_replace (mask6,", "                                     \"\\01\", dir_separator);", "     if (!mask7)", "          goto end;", "    seconds = time (NULL);", "    date_tmp = localtime (&seconds);", "    mask_decoded5[0] = '\\0';", "    strftime (mask_decoded5, length - 1, mask_decoded4, date_tmp);", "  ", "       ", "      if (weechat_config_boolean (logger_config_file_name_lower_case))", "        weechat_string_tolower (mask_decoded5);", "         weechat_string_tolower (mask7);", "  ", "      if (weechat_logger_plugin->debug)", "      {", "         weechat_printf_date_tags (NULL, 0, \"no_log\",", "                                   \"%s: buffer = \\\"%s\\\", mask = \\\"%s\\\", \"", "                                    \"decoded mask = \\\"%s\\\"\",", "                                    LOGGER_PLUGIN_NAME,", "                                    weechat_buffer_get_string (buffer, \"name\"),", "                                  mask, mask_decoded5);", "                                   mask, mask7);", "      }", "  ", "  end:", "      if (mask2)", "          free (mask2);", "    if (mask_decoded)", "        free (mask_decoded);", "    if (mask_decoded2)", "        free (mask_decoded2);", "    if (mask_decoded3)", "        free (mask_decoded3);", "    if (mask_decoded4)", "        free (mask_decoded4);", "    return mask_decoded5;", "     if (mask3)", "         free (mask3);", "     if (mask4)", "         free (mask4);", "     if (mask5)", "         free (mask5);", "     if (mask6)", "         free (mask6);", " ", "     return mask7;", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "", "OpInputList params_nested_splits_in;", "OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",", "&params_nested_splits_in));", "const Tensor& params_dense_values_in =", "context->input(params_nested_splits_in.size());", "const Tensor& indices_in =", "context->input(params_nested_splits_in.size() + 1);", "", "DCHECK_GT(params_nested_splits_in.size(), 0);", "SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;", "OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));", "", "OP_REQUIRES(context, params_dense_values_in.dims() > 0,", "errors::InvalidArgument(\"params.rank must be nonzero\"));", "SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);", "", "", "", "std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;", "SPLITS_TYPE num_values = 0;", "std::vector<std::vector<SPLITS_TYPE>> out_splits;", "OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,", "num_params_dense_values, &out_splits,", "&value_slices, &num_values));", "", "", "OP_REQUIRES_OK(context, WriteSplits(out_splits, context));", "OP_REQUIRES_OK(context,", "WriteValues(params_dense_values_in, value_slices,", "out_splits.size(), num_values, context));", "}"], "ner_tags": [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void BluetoothDeviceChooserController::PostErrorCallback(", "    blink::mojom::WebBluetoothResult error) {", "     WebBluetoothResult error) {", "    if (!base::ThreadTaskRunnerHandle::Get()->PostTask(", "            FROM_HERE, base::BindOnce(error_callback_, error))) {", "      LOG(WARNING) << \"No TaskRunner.\";", "   }", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" views::View* CardUnmaskPromptViews::CreateFootnoteView() {", "   if (!controller_->CanStoreLocally())", "     return nullptr;", " ", "   storage_row_ = new FadeOutView();", "   views::BoxLayout* storage_row_layout = new views::BoxLayout(", "       views::BoxLayout::kHorizontal, kEdgePadding, kEdgePadding, 0);", "   storage_row_->SetLayoutManager(storage_row_layout);", "    storage_row_->SetBorder(", "        views::Border::CreateSolidSidedBorder(1, 0, 0, 0, kSubtleBorderColor));", "    storage_row_->set_background(", "      views::Background::CreateSolidBackground(kShadingColor));", "       views::Background::CreateSolidBackground(kLightShadingColor));", "  ", "    storage_checkbox_ = new views::Checkbox(l10n_util::GetStringUTF16(", "        IDS_AUTOFILL_CARD_UNMASK_PROMPT_STORAGE_CHECKBOX));", "   storage_checkbox_->SetChecked(controller_->GetStoreLocallyStartState());", "   storage_row_->AddChildView(storage_checkbox_);", "   storage_row_layout->SetFlexForView(storage_checkbox_, 1);", " ", "   storage_row_->AddChildView(new TooltipIcon(l10n_util::GetStringUTF16(", "       IDS_AUTOFILL_CARD_UNMASK_PROMPT_STORAGE_TOOLTIP)));", " ", "   return storage_row_;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void xen_netbk_tx_submit(struct xen_netbk *netbk)", " {", " \tstruct gnttab_copy *gop = netbk->tx_copy_ops;", " \tstruct sk_buff *skb;", " ", " \twhile ((skb = __skb_dequeue(&netbk->tx_queue)) != NULL) {", " \t\tstruct xen_netif_tx_request *txp;", " \t\tstruct xenvif *vif;", " \t\tu16 pending_idx;", " \t\tunsigned data_len;", " ", " \t\tpending_idx = *((u16 *)skb->data);", " \t\tvif = netbk->pending_tx_info[pending_idx].vif;", " \t\ttxp = &netbk->pending_tx_info[pending_idx].req;", " ", " \t\t ", " \t\tif (unlikely(xen_netbk_tx_check_gop(netbk, skb, &gop))) {", " \t\t\tnetdev_dbg(vif->dev, \"netback grant failed.\\n\");", " \t\t\tskb_shinfo(skb)->nr_frags = 0;", " \t\t\tkfree_skb(skb);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tdata_len = skb->len;", " \t\tmemcpy(skb->data,", " \t\t       (void *)(idx_to_kaddr(netbk, pending_idx)|txp->offset),", " \t\t       data_len);", " \t\tif (data_len < txp->size) {", " \t\t\t ", " \t\t\ttxp->offset += data_len;", "  \t\t\ttxp->size -= data_len;", "  \t\t} else {", "  \t\t\t ", "\t\t\txen_netbk_idx_release(netbk, pending_idx);", " \t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);", "  \t\t}", "  ", "  \t\tif (txp->flags & XEN_NETTXF_csum_blank)", " \t\t\tskb->ip_summed = CHECKSUM_PARTIAL;", " \t\telse if (txp->flags & XEN_NETTXF_data_validated)", " \t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;", " ", " \t\txen_netbk_fill_frags(netbk, skb);", " ", " \t\t ", " \t\tif (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {", " \t\t\tint target = min_t(int, skb->len, PKT_PROT_LEN);", " \t\t\t__pskb_pull_tail(skb, target - skb_headlen(skb));", " \t\t}", " ", " \t\tskb->dev      = vif->dev;", " \t\tskb->protocol = eth_type_trans(skb, skb->dev);", " ", " \t\tif (checksum_setup(vif, skb)) {", " \t\t\tnetdev_dbg(vif->dev,", " \t\t\t\t   \"Can't setup checksum in net_tx_action\\n\");", " \t\t\tkfree_skb(skb);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tvif->dev->stats.rx_bytes += skb->len;", " \t\tvif->dev->stats.rx_packets++;", " ", " \t\txenvif_receive_skb(vif, skb);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void PropertyTreeManager::SetupRootEffectNode() {", "   cc::EffectTree& effect_tree = property_trees_.effect_tree;", "   effect_tree.clear();", "   property_trees_.element_id_to_effect_node_index.clear();", "   cc::EffectNode& effect_node =", "       *effect_tree.Node(effect_tree.Insert(cc::EffectNode(), kInvalidNodeId));", "   DCHECK_EQ(effect_node.id, kSecondaryRootNodeId);", " ", "   static UniqueObjectId unique_id = NewUniqueObjectId();", " ", "   effect_node.stable_id =", "       CompositorElementIdFromUniqueObjectId(unique_id).ToInternalValue();", "   effect_node.transform_id = kRealRootNodeId;", "   effect_node.clip_id = kSecondaryRootNodeId;", "   effect_node.has_render_surface = true;", "   root_layer_->SetEffectTreeIndex(effect_node.id);", "  ", "    current_effect_id_ = effect_node.id;", "    current_effect_type_ = CcEffectType::kEffect;", "  current_effect_ = EffectPaintPropertyNode::Root();", "   current_effect_ = &EffectPaintPropertyNode::Root();", "    current_clip_ = current_effect_->OutputClip();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["TEST_F(QuantizedMatMulTest, Small_NoParams) {", "TF_ASSERT_OK(NodeDefBuilder(\"quantized_mat_mul_op\", \"QuantizedMatMul\")", ".Input(FakeInput(DT_QUINT8))", ".Input(FakeInput(DT_QUINT8))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Attr(\"Toutput\", DataTypeToEnum<qint32>::v())", ".Finalize(node_def()));", "TF_ASSERT_OK(InitOp());", "", "", "", "AddInputFromArray<quint8>(TensorShape({2, 3}), {1, 2, 3, 4, 5, 6});", "", "", "", "", "AddInputFromArray<quint8>(TensorShape({3, 4}),", "{7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18});", "AddInputFromArray<float>(TensorShape({1}), {0});", "AddInputFromArray<float>(TensorShape({1}), {255.0f});", "AddInputFromArray<float>(TensorShape({1}), {0});", "AddInputFromArray<float>(TensorShape({1}), {255.0f});", "", "TF_ASSERT_OK(RunOpKernel());", "", "", "", "", "", "", "", "", "", "Tensor expected(allocator(), DT_QINT32, TensorShape({2, 4}));", "test::FillValues<qint32>(&expected, {74, 80, 86, 92, 173, 188, 203, 218});", "test::ExpectTensorEqual<qint32>(expected, *GetOutput(0));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void HostCache::RecordSet(SetOutcome outcome,", "                            base::TimeTicks now,", "                            const Entry* old_entry,", "                          const Entry& new_entry) {", "                           const Entry& new_entry,", "                           AddressListDeltaType delta) {", "    CACHE_HISTOGRAM_ENUM(\"Set\", outcome, MAX_SET_OUTCOME);", "    switch (outcome) {", "      case SET_INSERT:", "     case SET_UPDATE_VALID:", "       break;", "     case SET_UPDATE_STALE: {", "       EntryStaleness stale;", "       old_entry->GetStaleness(now, network_changes_, &stale);", "       CACHE_HISTOGRAM_TIME(\"UpdateStale.ExpiredBy\", stale.expired_by);", "       CACHE_HISTOGRAM_COUNT(\"UpdateStale.NetworkChanges\",", "                              stale.network_changes);", "        CACHE_HISTOGRAM_COUNT(\"UpdateStale.StaleHits\", stale.stale_hits);", "        if (old_entry->error() == OK && new_entry.error() == OK) {", "        AddressListDeltaType delta = FindAddressListDeltaType(", "            old_entry->addresses(), new_entry.addresses());", "          RecordUpdateStale(delta, stale);", "        }", "        break;", "     }", "     case MAX_SET_OUTCOME:", "       NOTREACHED();", "       break;", "   }", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void do_perf_sw_event(enum perf_type_id type, u32 event_id,", "\t\t\t\t    u64 nr, int nmi,", " \t\t\t\t    u64 nr,", "  \t\t\t\t    struct perf_sample_data *data,", "  \t\t\t\t    struct pt_regs *regs)", "  {", " \tstruct swevent_htable *swhash = &__get_cpu_var(swevent_htable);", " \tstruct perf_event *event;", " \tstruct hlist_node *node;", " \tstruct hlist_head *head;", " ", " \trcu_read_lock();", " \thead = find_swevent_head_rcu(swhash, type, event_id);", " \tif (!head)", " \t\tgoto end;", "  ", "  \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {", "  \t\tif (perf_swevent_match(event, type, event_id, data, regs))", "\t\t\tperf_swevent_event(event, nr, nmi, data, regs);", " \t\t\tperf_swevent_event(event, nr, data, regs);", "  \t}", "  end:", "  \trcu_read_unlock();", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int tls1_cbc_remove_padding(const SSL* s,", " \t\t\t    SSL3_RECORD *rec,", " \t\t\t    unsigned block_size,", " \t\t\t    unsigned mac_size)", " \t{", " \tunsigned padding_length, good, to_check, i;", " \tconst char has_explicit_iv =", " \t\ts->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;", " \tconst unsigned overhead = 1   +", " \t\t\t\t  mac_size +", " \t\t\t\t  (has_explicit_iv ? block_size : 0);", " ", " \t ", "         if (overhead > rec->length)", "                 return 0;", "  ", "         ", "        if (has_explicit_iv)", "                {", "                rec->data += block_size;", "                rec->input += block_size;", "                rec->length -= block_size;", "                }", " ", "         padding_length = rec->data[rec->length-1];", "  ", "         /* NB: if compression is in operation the first packet may not be of", " \t\t\tpadding_length--;", " \t\t\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd, sector_t logical,", " \t\t\t\t struct buffer_head *exbh)", " {", " \tstruct inode *inode = mpd->inode;", " \tstruct address_space *mapping = inode->i_mapping;", " \tint blocks = exbh->b_size >> inode->i_blkbits;", " \tsector_t pblock = exbh->b_blocknr, cur_logical;", " \tstruct buffer_head *head, *bh;", " \tpgoff_t index, end;", " \tstruct pagevec pvec;", " \tint nr_pages, i;", " ", " \tindex = logical >> (PAGE_CACHE_SHIFT - inode->i_blkbits);", " \tend = (logical + blocks - 1) >> (PAGE_CACHE_SHIFT - inode->i_blkbits);", " \tcur_logical = index << (PAGE_CACHE_SHIFT - inode->i_blkbits);", " ", " \tpagevec_init(&pvec, 0);", " ", " \twhile (index <= end) {", " \t\t ", " \t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);", " \t\tif (nr_pages == 0)", " \t\t\tbreak;", " \t\tfor (i = 0; i < nr_pages; i++) {", " \t\t\tstruct page *page = pvec.pages[i];", " ", " \t\t\tindex = page->index;", " \t\t\tif (index > end)", " \t\t\t\tbreak;", " \t\t\tindex++;", " ", " \t\t\tBUG_ON(!PageLocked(page));", " \t\t\tBUG_ON(PageWriteback(page));", " \t\t\tBUG_ON(!page_has_buffers(page));", " ", " \t\t\tbh = page_buffers(page);", " \t\t\thead = bh;", " ", " \t\t\t ", " \t\t\tdo {", " \t\t\t\tif (cur_logical >= logical)", " \t\t\t\t\tbreak;", " \t\t\t\tcur_logical++;", " \t\t\t} while ((bh = bh->b_this_page) != head);", " ", " \t\t\tdo {", " \t\t\t\tif (cur_logical >= logical + blocks)", " \t\t\t\t\tbreak;", " ", " \t\t\t\tif (buffer_delay(bh) ||", " \t\t\t\t\t\tbuffer_unwritten(bh)) {", " ", " \t\t\t\t\tBUG_ON(bh->b_bdev != inode->i_sb->s_bdev);", " ", " \t\t\t\t\tif (buffer_delay(bh)) {", " \t\t\t\t\t\tclear_buffer_delay(bh);", " \t\t\t\t\t\tbh->b_blocknr = pblock;", " \t\t\t\t\t} else {", " \t\t\t\t\t\t ", " \t\t\t\t\t\tclear_buffer_unwritten(bh);", " \t\t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);", " \t\t\t\t\t}", " ", "  \t\t\t\t} else if (buffer_mapped(bh))", "  \t\t\t\t\tBUG_ON(bh->b_blocknr != pblock);", "  ", " \t\t\t\tif (buffer_uninit(exbh))", " \t\t\t\t\tset_buffer_uninit(bh);", "  \t\t\t\tcur_logical++;", "  \t\t\t\tpblock++;", "  \t\t\t} while ((bh = bh->b_this_page) != head);", " \t\t}", " \t\tpagevec_release(&pvec);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_isom_oinf_read_entry(void *entry, GF_BitStream *bs)", "{", "GF_OperatingPointsInformation* ptr = (GF_OperatingPointsInformation *)entry;", "u32 i, j, count;", "", "if (!ptr) return GF_BAD_PARAM;", "ptr->scalability_mask = gf_bs_read_u16(bs);", "gf_bs_read_int(bs, 2);", "count = gf_bs_read_int(bs, 6);", "for (i = 0; i < count; i++) {", "LHEVC_ProfileTierLevel *ptl;", "GF_SAFEALLOC(ptl, LHEVC_ProfileTierLevel);", "if (!ptl) return GF_OUT_OF_MEM;", "ptl->general_profile_space = gf_bs_read_int(bs, 2);", "ptl->general_tier_flag= gf_bs_read_int(bs, 1);", "ptl->general_profile_idc = gf_bs_read_int(bs, 5);", "ptl->general_profile_compatibility_flags = gf_bs_read_u32(bs);", "ptl->general_constraint_indicator_flags = gf_bs_read_long_int(bs, 48);", "ptl->general_level_idc = gf_bs_read_u8(bs);", "gf_list_add(ptr->profile_tier_levels, ptl);", "}", "count = gf_bs_read_u16(bs);", "for (i = 0; i < count; i++) {", "LHEVC_OperatingPoint *op;", "GF_SAFEALLOC(op, LHEVC_OperatingPoint);", "if (!op) return GF_OUT_OF_MEM;", "op->output_layer_set_idx = gf_bs_read_u16(bs);", "op->max_temporal_id = gf_bs_read_u8(bs);", "op->layer_count = gf_bs_read_u8(bs);", "if (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))", "return GF_NON_COMPLIANT_BITSTREAM;", "for (j = 0; j < op->layer_count; j++) {", "op->layers_info[j].ptl_idx = gf_bs_read_u8(bs);", "op->layers_info[j].layer_id = gf_bs_read_int(bs, 6);", "op->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "op->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "}", "op->minPicWidth = gf_bs_read_u16(bs);", "op->minPicHeight = gf_bs_read_u16(bs);", "op->maxPicWidth = gf_bs_read_u16(bs);", "op->maxPicHeight = gf_bs_read_u16(bs);", "op->maxChromaFormat = gf_bs_read_int(bs, 2);", "op->maxBitDepth = gf_bs_read_int(bs, 3) + 8;", "gf_bs_read_int(bs, 1);", "op->frame_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "op->bit_rate_info_flag = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;", "if (op->frame_rate_info_flag) {", "op->avgFrameRate = gf_bs_read_u16(bs);", "gf_bs_read_int(bs, 6);", "op->constantFrameRate = gf_bs_read_int(bs, 2);", "}", "if (op->bit_rate_info_flag) {", "op->maxBitRate = gf_bs_read_u32(bs);", "op->avgBitRate = gf_bs_read_u32(bs);", "}", "gf_list_add(ptr->operating_points, op);", "}", "count = gf_bs_read_u8(bs);", "for (i = 0; i < count; i++) {", "LHEVC_DependentLayer *dep;", "GF_SAFEALLOC(dep, LHEVC_DependentLayer);", "if (!dep) return GF_OUT_OF_MEM;", "dep->dependent_layerID = gf_bs_read_u8(bs);", "dep->num_layers_dependent_on = gf_bs_read_u8(bs);", "if (dep->num_layers_dependent_on > GF_ARRAY_LENGTH(dep->dependent_on_layerID)) {", "gf_free(dep);", "return GF_NON_COMPLIANT_BITSTREAM;", "}", "for (j = 0; j < dep->num_layers_dependent_on; j++)", "dep->dependent_on_layerID[j] = gf_bs_read_u8(bs);", "for (j = 0; j < 16; j++) {", "if (ptr->scalability_mask & (1 << j))", "dep->dimension_identifier[j] = gf_bs_read_u8(bs);", "}", "gf_list_add(ptr->dependency_layers, dep);", "}", "", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,", "const void *pdu, uint16_t length,", "void *user_data)", "{", "struct bt_gatt_server *server = user_data;", "uint16_t handle = 0;", "uint16_t offset;", "struct gatt_db_attribute *attr;", "struct prep_write_complete_data *pwcd;", "uint8_t ecode, status;", "", "if (length < 4) {", "ecode = BT_ATT_ERROR_INVALID_PDU;", "goto error;", "}", "", "if (queue_length(server->prep_queue) >= server->max_prep_queue_len) {", "ecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;", "goto error;", "}", "", "handle = get_le16(pdu);", "offset = get_le16(pdu + 2);", "", "attr = gatt_db_get_attribute(server->db, handle);", "if (!attr) {", "ecode = BT_ATT_ERROR_INVALID_HANDLE;", "goto error;", "}", "", "util_debug(server->debug_callback, server->debug_data,", "\"Prep Write Req - handle: 0x%04x\", handle);", "", "ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);", "if (ecode)", "goto error;", "", "pwcd = new0(struct prep_write_complete_data, 1);", "pwcd->chan = chan;", "pwcd->pdu = malloc(length);", "memcpy(pwcd->pdu, pdu, length);", "pwcd->length = length;", "pwcd->server = server;", "", "status = gatt_db_attribute_write(attr, offset, NULL, 0,", "BT_ATT_OP_PREP_WRITE_REQ,", "server->att,", "prep_write_complete_cb, pwcd);", "", "if (status)", "return;", "", "ecode = BT_ATT_ERROR_UNLIKELY;", "", "error:", "bt_att_chan_send_error_rsp(chan, opcode, handle, ecode);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TEST_P(WasmTest, DivByZero) {", "Stats::IsolatedStoreImpl stats_store;", "Api::ApiPtr api = Api::createApiForTest(stats_store);", "Upstream::MockClusterManager cluster_manager;", "Event::DispatcherPtr dispatcher(api->allocateDispatcher());", "auto scope = Stats::ScopeSharedPtr(stats_store.createScope(\"wasm.\"));", "NiceMock<LocalInfo::MockLocalInfo> local_info;", "auto name = \"\";", "auto root_id = \"\";", "auto vm_id = \"\";", "auto vm_configuration = \"\";", "auto plugin = std::make_shared<Extensions::Common::Wasm::Plugin>(", "name, root_id, vm_id, envoy::api::v2::core::TrafficDirection::UNSPECIFIED, local_info,", "nullptr);", "auto wasm = std::make_unique<Extensions::Common::Wasm::Wasm>(", "absl::StrCat(\"envoy.wasm.runtime.\", GetParam()), vm_id, vm_configuration, plugin, scope,", "cluster_manager, *dispatcher);", "EXPECT_NE(wasm, nullptr);", "const auto code = TestEnvironment::readFileToStringForTest(TestEnvironment::substitute(", "\"{{ test_rundir }}/test/extensions/wasm/test_data/segv_cpp.wasm\"));", "EXPECT_FALSE(code.empty());", "auto context = std::make_unique<TestContext>(wasm.get());", "EXPECT_CALL(*context, scriptLog_(spdlog::level::err, Eq(\"before div by zero\")));", "EXPECT_TRUE(wasm->initialize(code, false));", "wasm->setContext(context.get());", "", "if (GetParam() == \"v8\") {", "EXPECT_THROW_WITH_MESSAGE(", "context->onLog(), Extensions::Common::Wasm::WasmException,", "\"Function: proxy_onLog failed: Uncaught RuntimeError: divide by zero\");", "} else if (GetParam() == \"wavm\") {", "EXPECT_THROW_WITH_REGEX(context->onLog(), Extensions::Common::Wasm::WasmException,", "\"Function: proxy_onLog failed: wavm.integerDivideByZeroOrOverflow.*\");", "} else {", "ASSERT_FALSE(true);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)", " {", " \tint r;", " \tsize_t i;", " \tstatic struct {", " \t\tint match_mask;", " \t\tint match_flag;", " \t\tconst char *source;", " \t\tconst char *destination;", " \t\tconst char *fstype;", " \t\tunsigned long flags;", " \t\tconst char *options;", " \t} default_mounts[] = {", " \t\t ", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },", "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },", " \t\t ", " \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },", "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },", " \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },", "  \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },", " \t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },", " \t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }", " \t};", " ", " \tfor (i = 0; default_mounts[i].match_mask; i++) {", " \t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {", " \t\t\tchar *source = NULL;", " \t\t\tchar *destination = NULL;", " \t\t\tint saved_errno;", " \t\t\tunsigned long mflags;", " ", " \t\t\tif (default_mounts[i].source) {", " \t\t\t\t ", " \t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);", " \t\t\t\tif (!source) {", " \t\t\t\t\tSYSERROR(\"memory allocation error\");", " \t\t\t\t\treturn -1;", " \t\t\t\t}", " \t\t\t}", " \t\t\tif (default_mounts[i].destination) {", " \t\t\t\t ", " \t\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);", " \t\t\t\tif (!destination) {", " \t\t\t\t\tsaved_errno = errno;", " \t\t\t\t\tSYSERROR(\"memory allocation error\");", " \t\t\t\t\tfree(source);", " \t\t\t\t\terrno = saved_errno;", " \t\t\t\t\treturn -1;", " \t\t\t\t}", "  \t\t\t}", "  \t\t\tmflags = add_required_remount_flags(source, destination,", "  \t\t\t\t\tdefault_mounts[i].flags);", "\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);", " \t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);", "  \t\t\tsaved_errno = errno;", "  \t\t\tif (r < 0 && errno == ENOENT) {", "  \t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);", " \t\t\t\tr = 0;", " \t\t\t}", " \t\t\telse if (r < 0)", " \t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);", " ", " \t\t\tfree(source);", " \t\t\tfree(destination);", " \t\t\tif (r < 0) {", " \t\t\t\terrno = saved_errno;", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t}", " \t}", " ", " \tif (flags & LXC_AUTO_CGROUP_MASK) {", " \t\tint cg_flags;", " ", " \t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;", " \t\t ", " \t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {", " \t\t\tint has_sys_admin = 0;", " \t\t\tif (!lxc_list_empty(&conf->keepcaps)) {", " \t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);", " \t\t\t} else {", " \t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);", " \t\t\t}", " \t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {", " \t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;", " \t\t\t} else {", " \t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;", " \t\t\t}", " \t\t}", " ", " \t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {", " \t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");", " \t\t\treturn -1;", " \t\t}", " \t}", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void GM2TabStyle::PaintTabBackgroundFill(gfx::Canvas* canvas,", "                                         bool active,", "                                          TabState active_state,", "                                           bool paint_hover_effect,", "                                         SkColor active_color,", "                                         SkColor inactive_color,", "                                           int fill_id,", "                                           int y_inset) const {", "  const SkPath fill_path =", "      GetPath(PathType::kFill, canvas->image_scale(), active);", "   const SkPath fill_path = GetPath(PathType::kFill, canvas->image_scale(),", "                                    active_state == TAB_ACTIVE);", "    gfx::ScopedCanvas scoped_canvas(canvas);", "    const float scale = canvas->UndoDeviceScaleFactor();", "  ", "    canvas->ClipPath(fill_path, true);", "  ", "  if (active || !fill_id) {", "   if (ShouldPaintTabBackgroundColor(active_state, fill_id)) {", "      cc::PaintFlags flags;", "      flags.setAntiAlias(true);", "    flags.setColor(active ? active_color : inactive_color);", "     flags.setColor(GetTabBackgroundColor(active_state));", "      canvas->DrawRect(gfx::ScaleToEnclosingRect(tab_->GetLocalBounds(), scale),", "                       flags);", "    }", " ", "   if (fill_id) {", "     gfx::ScopedCanvas scale_scoper(canvas);", "     canvas->sk_canvas()->scale(scale, scale);", "     canvas->TileImageInt(*tab_->GetThemeProvider()->GetImageSkiaNamed(fill_id),", "                          tab_->GetMirroredX() + tab_->background_offset(), 0, 0,", "                          y_inset, tab_->width(), tab_->height());", "   }", " ", "   if (paint_hover_effect) {", "     SkPoint hover_location(gfx::PointToSkPoint(hover_controller_->location()));", "     hover_location.scale(SkFloatToScalar(scale));", "     const SkScalar kMinHoverRadius = 16;", "      const SkScalar radius =", "          std::max(SkFloatToScalar(tab_->width() / 4.f), kMinHoverRadius);", "      DrawHighlight(canvas, hover_location, radius * scale,", "                  SkColorSetA(active_color, hover_controller_->GetAlpha()));", "                   SkColorSetA(GetTabBackgroundColor(TAB_ACTIVE),", "                               hover_controller_->GetAlpha()));", "    }", "  }"], "ner_tags": [0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["static int lookup1_values(int entries, int dim)", "{", "int r = (int) floor(exp((float) log((float) entries) / dim));", "if ((int) floor(pow((float) r+1, dim)) <= entries)", "++r;", "assert(pow((float) r+1, dim) > entries);", "assert((int) floor(pow((float) r, dim)) <= entries);", "return r;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,", "   ExceptionInfo *exception)", " {", "   DDSColors", "     colors;", " ", "   PixelPacket", "     *q;", " ", "   register ssize_t", "     i,", "     x;", " ", "   size_t", "     bits;", " ", "   ssize_t", "     j,", "     y;", " ", "   unsigned char", "     code;", " ", "   unsigned short", "     c0,", "     c1;", " ", "   for (y = 0; y < (ssize_t) dds_info->height; y += 4)", "   {", "      for (x = 0; x < (ssize_t) dds_info->width; x += 4)", "      {", "         ", "      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),", "        Min(4, dds_info->height - y),exception);", "       q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),", "         MagickMin(4, dds_info->height - y),exception);", "  ", "        if (q == (PixelPacket *) NULL)", "          return MagickFalse;", " ", "        ", "       c0 = ReadBlobLSBShort(image);", "       c1 = ReadBlobLSBShort(image);", "       bits = ReadBlobLSBLong(image);", " ", "       CalculateColors(c0, c1, &colors, MagickFalse);", " ", "        ", "       for (j = 0; j < 4; j++)", "       {", "         for (i = 0; i < 4; i++)", "         {", "           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)", "             {", "               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);", "               SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));", "               SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));", "               SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));", "               SetPixelOpacity(q,ScaleCharToQuantum(colors.a[code]));", "               if (colors.a[code] && image->matte == MagickFalse)", "                  ", "                 image->matte = MagickTrue;", "               q++;", "             }", "         }", "       }", " ", "       if (SyncAuthenticPixels(image,exception) == MagickFalse)", "         return MagickFalse;", "      }", "    }", "  ", "  SkipDXTMipmaps(image, dds_info, 8);", "  return MagickTrue;", "   return(SkipDXTMipmaps(image,dds_info,8,exception));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,", "     struct zip_entry *rsrc)", " {", " \tstruct zip *zip = (struct zip *)a->format->data;", " \tunsigned char *metadata, *mp;", " \tint64_t offset = archive_filter_bytes(&a->archive, 0);", " \tsize_t remaining_bytes, metadata_bytes;", " \tssize_t hsize;", " \tint ret = ARCHIVE_OK, eof;", "  ", "  \tswitch(rsrc->compression) {", "  \tcase 0:   ", " \t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {", " \t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Malformed OS X metadata entry: inconsistent size\");", " \t\t\treturn (ARCHIVE_FATAL);", " \t\t}", "  #ifdef HAVE_ZLIB_H", "  \tcase 8:  ", "  #endif", " \t\tbreak;", " \tdefault:  ", " \t\t ", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Unsupported ZIP compression method (%s)\",", " \t\t    compression_name(rsrc->compression));", " \t\t ", " \t\treturn (ARCHIVE_WARN);", " \t}", " ", " \tif (rsrc->uncompressed_size > (4 * 1024 * 1024)) {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Mac metadata is too large: %jd > 4M bytes\",", "  \t\t    (intmax_t)rsrc->uncompressed_size);", "  \t\treturn (ARCHIVE_WARN);", "  \t}", " \tif (rsrc->compressed_size > (4 * 1024 * 1024)) {", " \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t    \"Mac metadata is too large: %jd > 4M bytes\",", " \t\t    (intmax_t)rsrc->compressed_size);", " \t\treturn (ARCHIVE_WARN);", " \t}", "  ", "  \tmetadata = malloc((size_t)rsrc->uncompressed_size);", "  \tif (metadata == NULL) {", " \t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t    \"Can't allocate memory for Mac metadata\");", " \t\treturn (ARCHIVE_FATAL);", " \t}", " ", " \tif (offset < rsrc->local_header_offset)", " \t\t__archive_read_consume(a, rsrc->local_header_offset - offset);", " \telse if (offset != rsrc->local_header_offset) {", " \t\t__archive_read_seek(a, rsrc->local_header_offset, SEEK_SET);", " \t}", " ", " \thsize = zip_get_local_file_header_size(a, 0);", " \t__archive_read_consume(a, hsize);", " ", " \tremaining_bytes = (size_t)rsrc->compressed_size;", " \tmetadata_bytes = (size_t)rsrc->uncompressed_size;", " \tmp = metadata;", " \teof = 0;", " \twhile (!eof && remaining_bytes) {", " \t\tconst unsigned char *p;", " \t\tssize_t bytes_avail;", " \t\tsize_t bytes_used;", " ", " \t\tp = __archive_read_ahead(a, 1, &bytes_avail);", " \t\tif (p == NULL) {", " \t\t\tarchive_set_error(&a->archive,", " \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Truncated ZIP file header\");", " \t\t\tret = ARCHIVE_WARN;", " \t\t\tgoto exit_mac_metadata;", " \t\t}", " \t\tif ((size_t)bytes_avail > remaining_bytes)", "  \t\t\tbytes_avail = remaining_bytes;", "  \t\tswitch(rsrc->compression) {", "  \t\tcase 0:   ", " \t\t\tif ((size_t)bytes_avail > metadata_bytes)", " \t\t\t\tbytes_avail = metadata_bytes;", "  \t\t\tmemcpy(mp, p, bytes_avail);", "  \t\t\tbytes_used = (size_t)bytes_avail;", "  \t\t\tmetadata_bytes -= bytes_used;", " \t\t\tmp += bytes_used;", " \t\t\tif (metadata_bytes == 0)", " \t\t\t\teof = 1;", " \t\t\tbreak;", " #ifdef HAVE_ZLIB_H", " \t\tcase 8:  ", " \t\t{", " \t\t\tint r;", " ", " \t\t\tret = zip_deflate_init(a, zip);", " \t\t\tif (ret != ARCHIVE_OK)", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\tzip->stream.next_in =", " \t\t\t    (Bytef *)(uintptr_t)(const void *)p;", " \t\t\tzip->stream.avail_in = (uInt)bytes_avail;", " \t\t\tzip->stream.total_in = 0;", " \t\t\tzip->stream.next_out = mp;", " \t\t\tzip->stream.avail_out = (uInt)metadata_bytes;", " \t\t\tzip->stream.total_out = 0;", " ", " \t\t\tr = inflate(&zip->stream, 0);", " \t\t\tswitch (r) {", " \t\t\tcase Z_OK:", " \t\t\t\tbreak;", " \t\t\tcase Z_STREAM_END:", " \t\t\t\teof = 1;", " \t\t\t\tbreak;", " \t\t\tcase Z_MEM_ERROR:", " \t\t\t\tarchive_set_error(&a->archive, ENOMEM,", " \t\t\t\t    \"Out of memory for ZIP decompression\");", " \t\t\t\tret = ARCHIVE_FATAL;", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\tdefault:", " \t\t\t\tarchive_set_error(&a->archive,", " \t\t\t\t    ARCHIVE_ERRNO_MISC,", " \t\t\t\t    \"ZIP decompression failed (%d)\", r);", " \t\t\t\tret = ARCHIVE_FATAL;", " \t\t\t\tgoto exit_mac_metadata;", " \t\t\t}", " \t\t\tbytes_used = zip->stream.total_in;", " \t\t\tmetadata_bytes -= zip->stream.total_out;", " \t\t\tmp += zip->stream.total_out;", " \t\t\tbreak;", " \t\t}", " #endif", " \t\tdefault:", " \t\t\tbytes_used = 0;", " \t\t\tbreak;", " \t\t}", " \t\t__archive_read_consume(a, bytes_used);", " \t\tremaining_bytes -= bytes_used;", " \t}", " \tarchive_entry_copy_mac_metadata(entry, metadata,", " \t    (size_t)rsrc->uncompressed_size - metadata_bytes);", " ", " exit_mac_metadata:", " \t__archive_read_seek(a, offset, SEEK_SET);", " \tzip->decompress_init = 0;", " \tfree(metadata);", " \treturn (ret);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void encode_frame(vpx_codec_ctx_t *codec,", "                         vpx_image_t *img,", "                         int frame_index,", "                         VpxVideoWriter *writer) {", " static int encode_frame(vpx_codec_ctx_t *codec,", "                         vpx_image_t *img,", "                         int frame_index,", "                         VpxVideoWriter *writer) {", "   int got_pkts = 0;", "    vpx_codec_iter_t iter = NULL;", "    const vpx_codec_cx_pkt_t *pkt = NULL;", "    const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,", "                                                VPX_DL_GOOD_QUALITY);", "  if (res != VPX_CODEC_OK)", " ", "      die_codec(codec, \"Failed to encode frame\");", "  ", "    while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {", "     got_pkts = 1;", " ", "      if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {", "        const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;", "        if (!vpx_video_writer_write_frame(writer,", "                                         pkt->data.frame.buf,", "                                         pkt->data.frame.sz,", "                                         pkt->data.frame.pts)) {", "         die_codec(codec, \"Failed to write compressed frame\");", "  }", " ", "       printf(keyframe ? \"K\" : \".\");", " ", "        fflush(stdout);", "      }", "    }", " ", "   return got_pkts;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" void InitNavigateParams(FrameHostMsg_DidCommitProvisionalLoad_Params* params,", "                         int nav_entry_id,", "                         bool did_create_new_entry,", "                         const GURL& url,", "                          ui::PageTransition transition) {", "    params->nav_entry_id = nav_entry_id;", "    params->url = url;", "   params->origin = url::Origin(url);", "    params->referrer = Referrer();", "    params->transition = transition;", "    params->redirects = std::vector<GURL>();", "   params->should_update_history = false;", "   params->searchable_form_url = GURL();", "   params->searchable_form_encoding = std::string();", "   params->did_create_new_entry = did_create_new_entry;", "   params->gesture = NavigationGestureUser;", "   params->was_within_same_document = false;", "   params->method = \"GET\";", "   params->page_state = PageState::CreateFromURL(url);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jbig2_decode_symbol_dict(Jbig2Ctx *ctx,", "                          Jbig2Segment *segment,", "                          const Jbig2SymbolDictParams *params, const byte *data, size_t size, Jbig2ArithCx *GB_stats, Jbig2ArithCx *GR_stats)", " {", "     Jbig2SymbolDict *SDNEWSYMS = NULL;", "     Jbig2SymbolDict *SDEXSYMS = NULL;", "     uint32_t HCHEIGHT;", "     uint32_t NSYMSDECODED;", "     uint32_t SYMWIDTH, TOTWIDTH;", "     uint32_t HCFIRSTSYM;", "     uint32_t *SDNEWSYMWIDTHS = NULL;", "     int SBSYMCODELEN = 0;", "     Jbig2WordStream *ws = NULL;", "     Jbig2HuffmanState *hs = NULL;", "     Jbig2HuffmanTable *SDHUFFRDX = NULL;", "     Jbig2HuffmanTable *SBHUFFRSIZE = NULL;", "     Jbig2ArithState *as = NULL;", "     Jbig2ArithIntCtx *IADH = NULL;", "     Jbig2ArithIntCtx *IADW = NULL;", "     Jbig2ArithIntCtx *IAEX = NULL;", "     Jbig2ArithIntCtx *IAAI = NULL;", "     Jbig2ArithIaidCtx *IAID = NULL;", "     Jbig2ArithIntCtx *IARDX = NULL;", "     Jbig2ArithIntCtx *IARDY = NULL;", "     int code = 0;", "     Jbig2SymbolDict **refagg_dicts = NULL;", "     int n_refagg_dicts = 1;", " ", "     Jbig2TextRegionParams *tparams = NULL;", " ", "      ", "     HCHEIGHT = 0;", "     NSYMSDECODED = 0;", " ", "     ws = jbig2_word_stream_buf_new(ctx, data, size);", "     if (ws == NULL) {", "         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate ws in jbig2_decode_symbol_dict\");", "         return NULL;", "     }", " ", "     as = jbig2_arith_new(ctx, ws);", "     if (as == NULL) {", "         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate as in jbig2_decode_symbol_dict\");", "         jbig2_word_stream_buf_free(ctx, ws);", "         return NULL;", "     }", " ", "     if (!params->SDHUFF) {", "         IADH = jbig2_arith_int_ctx_new(ctx);", "         IADW = jbig2_arith_int_ctx_new(ctx);", "         IAEX = jbig2_arith_int_ctx_new(ctx);", "         IAAI = jbig2_arith_int_ctx_new(ctx);", "         if ((IADH == NULL) || (IADW == NULL) || (IAEX == NULL) || (IAAI == NULL)) {", "             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");", "             goto cleanup1;", "         }", "         if (params->SDREFAGG) {", "             int64_t tmp = params->SDNUMINSYMS + params->SDNUMNEWSYMS;", " ", "             for (SBSYMCODELEN = 0; ((int64_t) 1 << SBSYMCODELEN) < tmp; SBSYMCODELEN++);", "             IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);", "             IARDX = jbig2_arith_int_ctx_new(ctx);", "             IARDY = jbig2_arith_int_ctx_new(ctx);", "             if ((IAID == NULL) || (IARDX == NULL) || (IARDY == NULL)) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");", "                 goto cleanup2;", "             }", "         }", "     } else {", "         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"huffman coded symbol dictionary\");", "         hs = jbig2_huffman_new(ctx, ws);", "         SDHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);", "         SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);", "         if ((hs == NULL) || (SDHUFFRDX == NULL) || (SBHUFFRSIZE == NULL)) {", "             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"failed to allocate storage for symbol bitmap\");", "             goto cleanup2;", "         }", "         if (!params->SDREFAGG) {", "             SDNEWSYMWIDTHS = jbig2_new(ctx, uint32_t, params->SDNUMNEWSYMS);", "             if (SDNEWSYMWIDTHS == NULL) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate storage for (%u) symbol widths\", params->SDNUMNEWSYMS);", "                 goto cleanup2;", "             }", "         }", "     }", " ", "     SDNEWSYMS = jbig2_sd_new(ctx, params->SDNUMNEWSYMS);", "     if (SDNEWSYMS == NULL) {", "         jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"could not allocate storage for (%u) new symbols\", params->SDNUMNEWSYMS);", "         goto cleanup2;", "     }", " ", "      ", "     while (NSYMSDECODED < params->SDNUMNEWSYMS) {", "         int32_t HCDH, DW;", " ", "          ", "         if (params->SDHUFF) {", "             HCDH = jbig2_huffman_get(hs, params->SDHUFFDH, &code);", "         } else {", "             code = jbig2_arith_int_decode(IADH, as, &HCDH);", "         }", " ", "         if (code != 0) {", "             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"error or OOB decoding height class delta (%d)\\n\", code);", "         }", " ", "         if (!params->SDHUFF && jbig2_arith_has_reached_marker(as)) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"prevent DOS while decoding height classes\");", "             goto cleanup2;", "         }", " ", "          ", "         HCHEIGHT = HCHEIGHT + HCDH;", "         SYMWIDTH = 0;", "         TOTWIDTH = 0;", "         HCFIRSTSYM = NSYMSDECODED;", " ", "         if ((int32_t) HCHEIGHT < 0) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid HCHEIGHT value\");", "             goto cleanup2;", "         }", " #ifdef JBIG2_DEBUG", "         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"HCHEIGHT = %d\", HCHEIGHT);", " #endif", "         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoding height class %d with %d syms decoded\", HCHEIGHT, NSYMSDECODED);", " ", "         for (;;) {", "              ", "             if (params->SDHUFF) {", "                 DW = jbig2_huffman_get(hs, params->SDHUFFDW, &code);", "             } else {", "                 code = jbig2_arith_int_decode(IADW, as, &DW);", "             }", "             if (code < 0)", "                 goto cleanup4;", " ", "              ", "             if (code == 1) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \" OOB signals end of height class %d\", HCHEIGHT);", "                 break;", "             }", " ", "              ", "             if (NSYMSDECODED >= params->SDNUMNEWSYMS) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"No OOB signalling end of height class %d\", HCHEIGHT);", "                 goto cleanup4;", "             }", " ", "             SYMWIDTH = SYMWIDTH + DW;", "             TOTWIDTH = TOTWIDTH + SYMWIDTH;", "             if ((int32_t) SYMWIDTH < 0) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Invalid SYMWIDTH value (%d) at symbol %d\", SYMWIDTH, NSYMSDECODED + 1);", "                 goto cleanup4;", "             }", " #ifdef JBIG2_DEBUG", "             jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SYMWIDTH = %d TOTWIDTH = %d\", SYMWIDTH, TOTWIDTH);", " #endif", "              ", "             if (!params->SDHUFF || params->SDREFAGG) {", " #ifdef JBIG2_DEBUG", "                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"SDHUFF = %d; SDREFAGG = %d\", params->SDHUFF, params->SDREFAGG);", " #endif", "                  ", "                 if (!params->SDREFAGG) {", "                     Jbig2GenericRegionParams region_params;", "                     int sdat_bytes;", "                     Jbig2Image *image;", " ", "                      ", "                     region_params.MMR = 0;", "                     region_params.GBTEMPLATE = params->SDTEMPLATE;", "                     region_params.TPGDON = 0;", "                     region_params.USESKIP = 0;", "                     sdat_bytes = params->SDTEMPLATE == 0 ? 8 : 2;", "                     memcpy(region_params.gbat, params->sdat, sdat_bytes);", " ", "                     image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);", "                     if (image == NULL) {", "                         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate image in jbig2_decode_symbol_dict\");", "                         goto cleanup4;", "                     }", " ", "                     code = jbig2_decode_generic_region(ctx, segment, &region_params, as, image, GB_stats);", "                     if (code < 0) {", "                         jbig2_image_release(ctx, image);", "                         goto cleanup4;", "                     }", " ", "                     SDNEWSYMS->glyphs[NSYMSDECODED] = image;", "                 } else {", "                      ", "                     uint32_t REFAGGNINST;", " ", "                     if (params->SDHUFF) {", "                         REFAGGNINST = jbig2_huffman_get(hs, params->SDHUFFAGGINST, &code);", "                     } else {", "                         code = jbig2_arith_int_decode(IAAI, as, (int32_t *) & REFAGGNINST);", "                     }", "                     if (code || (int32_t) REFAGGNINST <= 0) {", "                         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"invalid number of symbols or OOB in aggregate glyph\");", "                         goto cleanup4;", "                     }", " ", "                     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"aggregate symbol coding (%d instances)\", REFAGGNINST);", "  ", "                      if (REFAGGNINST > 1) {", "                          Jbig2Image *image;", "                        int i;", "                         uint32_t i;", "  ", "                          if (tparams == NULL) {", "                               ", "                              ", "                              ", "                             refagg_dicts = jbig2_new(ctx, Jbig2SymbolDict *, n_refagg_dicts);", "                             if (refagg_dicts == NULL) {", "                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating dictionary array\");", "                                 goto cleanup4;", "                             }", "                             refagg_dicts[0] = jbig2_sd_new(ctx, params->SDNUMINSYMS + params->SDNUMNEWSYMS);", "                             if (refagg_dicts[0] == NULL) {", "                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory allocating symbol dictionary\");", "                                 jbig2_free(ctx->allocator, refagg_dicts);", "                                 goto cleanup4;", "                             }", "                             for (i = 0; i < params->SDNUMINSYMS; i++) {", "                                 refagg_dicts[0]->glyphs[i] = jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]);", "                             }", " ", "                             tparams = jbig2_new(ctx, Jbig2TextRegionParams, 1);", "                             if (tparams == NULL) {", "                                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating text region params\");", "                                 goto cleanup4;", "                             }", "                             if (!params->SDHUFF) {", "                                  ", "                                 tparams->IADT = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IAFS = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IADS = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IAIT = jbig2_arith_int_ctx_new(ctx);", "                                  ", "                                 for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < (int)(params->SDNUMINSYMS + params->SDNUMNEWSYMS); SBSYMCODELEN++);", "                                 tparams->IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);", "                                 tparams->IARI = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IARDW = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IARDH = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IARDX = jbig2_arith_int_ctx_new(ctx);", "                                 tparams->IARDY = jbig2_arith_int_ctx_new(ctx);", "                             } else {", "                                 tparams->SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);     ", "                                 tparams->SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);     ", "                                 tparams->SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);     ", "                                 tparams->SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    ", "                                 tparams->SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    ", "                                 tparams->SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    ", "                                 tparams->SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);    ", "                             }", "                             tparams->SBHUFF = params->SDHUFF;", "                             tparams->SBREFINE = 1;", "                             tparams->SBSTRIPS = 1;", "                             tparams->SBDEFPIXEL = 0;", "                             tparams->SBCOMBOP = JBIG2_COMPOSE_OR;", "                             tparams->TRANSPOSED = 0;", "                             tparams->REFCORNER = JBIG2_CORNER_TOPLEFT;", "                             tparams->SBDSOFFSET = 0;", "                             tparams->SBRTEMPLATE = params->SDRTEMPLATE;", "                         }", "                         tparams->SBNUMINSTANCES = REFAGGNINST;", " ", "                         image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);", "                         if (image == NULL) {", "                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");", "                             goto cleanup4;", "                         }", " ", "                          ", "                         jbig2_decode_text_region(ctx, segment, tparams, (const Jbig2SymbolDict * const *)refagg_dicts,", "                                                  n_refagg_dicts, image, data, size, GR_stats, as, ws);", " ", "                         SDNEWSYMS->glyphs[NSYMSDECODED] = image;", "                         refagg_dicts[0]->glyphs[params->SDNUMINSYMS + NSYMSDECODED] = jbig2_image_clone(ctx, SDNEWSYMS->glyphs[NSYMSDECODED]);", "                     } else {", "                          ", "                          ", "                         Jbig2RefinementRegionParams rparams;", "                         Jbig2Image *image;", "                          uint32_t ID;", "                          int32_t RDX, RDY;", "                          int BMSIZE = 0;", "                        int ninsyms = params->SDNUMINSYMS;", "                         uint32_t ninsyms = params->SDNUMINSYMS;", "                          int code1 = 0;", "                          int code2 = 0;", "                          int code3 = 0;", "                         int code4 = 0;", " ", "                          ", "                         if (params->SDHUFF) {", "                             ID = jbig2_huffman_get_bits(hs, SBSYMCODELEN, &code4);", "                             RDX = jbig2_huffman_get(hs, SDHUFFRDX, &code1);", "                             RDY = jbig2_huffman_get(hs, SDHUFFRDX, &code2);", "                             BMSIZE = jbig2_huffman_get(hs, SBHUFFRSIZE, &code3);", "                             jbig2_huffman_skip(hs);", "                         } else {", "                             code1 = jbig2_arith_iaid_decode(IAID, as, (int32_t *) & ID);", "                             code2 = jbig2_arith_int_decode(IARDX, as, &RDX);", "                             code3 = jbig2_arith_int_decode(IARDY, as, &RDY);", "                         }", " ", "                         if ((code1 < 0) || (code2 < 0) || (code3 < 0) || (code4 < 0)) {", "                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode data\");", "                             goto cleanup4;", "                         }", " ", "                         if (ID >= ninsyms + NSYMSDECODED) {", "                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"refinement references unknown symbol %d\", ID);", "                             goto cleanup4;", "                         }", " ", "                         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,", "                                     \"symbol is a refinement of id %d with the \" \"refinement applied at (%d,%d)\", ID, RDX, RDY);", " ", "                         image = jbig2_image_new(ctx, SYMWIDTH, HCHEIGHT);", "                         if (image == NULL) {", "                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Out of memory creating symbol image\");", "                             goto cleanup4;", "                         }", " ", "                          ", "                         rparams.GRTEMPLATE = params->SDRTEMPLATE;", "                         rparams.reference = (ID < ninsyms) ? params->SDINSYMS->glyphs[ID] : SDNEWSYMS->glyphs[ID - ninsyms];", "                          ", "                         if (rparams.reference == NULL) {", "                             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"missing glyph %d/%d!\", ID, ninsyms);", "                             jbig2_image_release(ctx, image);", "                             goto cleanup4;", "                         }", "                         rparams.DX = RDX;", "                         rparams.DY = RDY;", "                         rparams.TPGRON = 0;", "                         memcpy(rparams.grat, params->sdrat, 4);", "                         code = jbig2_decode_refinement_region(ctx, segment, &rparams, as, image, GR_stats);", "                         if (code < 0)", "                             goto cleanup4;", " ", "                         SDNEWSYMS->glyphs[NSYMSDECODED] = image;", " ", "                          ", "                         if (params->SDHUFF) {", "                             if (BMSIZE == 0)", "                                 BMSIZE = image->height * image->stride;", "                             jbig2_huffman_advance(hs, BMSIZE);", "                         }", "                     }", "                 }", " ", " #ifdef OUTPUT_PBM", "                 {", "                     char name[64];", "                     FILE *out;", " ", "                     snprintf(name, 64, \"sd.%04d.%04d.pbm\", segment->number, NSYMSDECODED);", "                     out = fopen(name, \"wb\");", "                     jbig2_image_write_pbm(SDNEWSYMS->glyphs[NSYMSDECODED], out);", "                     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"writing out glyph as '%s' ...\", name);", "                     fclose(out);", "                 }", " #endif", " ", "             }", " ", "              ", "             if (params->SDHUFF && !params->SDREFAGG) {", "                 SDNEWSYMWIDTHS[NSYMSDECODED] = SYMWIDTH;", "             }", " ", "              ", "             NSYMSDECODED = NSYMSDECODED + 1;", " ", "             jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"decoded symbol %u of %u (%ux%u)\", NSYMSDECODED, params->SDNUMNEWSYMS, SYMWIDTH, HCHEIGHT);", " ", "         }                        ", " ", "          ", "          if (params->SDHUFF && !params->SDREFAGG) {", "               ", "              Jbig2Image *image;", "            int BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);", "            int j, x;", "             uint32_t BMSIZE = jbig2_huffman_get(hs, params->SDHUFFBMSIZE, &code);", "             uint32_t j;", "             int x;", "  ", "              if (code || (BMSIZE < 0)) {", "                  jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding size of collective bitmap!\");", "             }", " ", "              ", "             jbig2_huffman_skip(hs);", " ", "             image = jbig2_image_new(ctx, TOTWIDTH, HCHEIGHT);", "             if (image == NULL) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate collective bitmap image!\");", "                 goto cleanup4;", "             }", " ", "             if (BMSIZE == 0) {", "                  ", "                 const byte *src = data + jbig2_huffman_offset(hs);", "                 const int stride = (image->width >> 3) + ((image->width & 7) ? 1 : 0);", "                 byte *dst = image->data;", " ", "                  ", "                 if (size - jbig2_huffman_offset(hs) < image->height * stride) {", "                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", image->height * stride,", "                                 size - jbig2_huffman_offset(hs));", "                     jbig2_image_release(ctx, image);", "                     goto cleanup4;", "                 }", " ", "                 BMSIZE = image->height * stride;", "                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,", "                             \"reading %dx%d uncompressed bitmap\" \" for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);", " ", "                 for (j = 0; j < image->height; j++) {", "                     memcpy(dst, src, stride);", "                     dst += image->stride;", "                     src += stride;", "                 }", "             } else {", "                 Jbig2GenericRegionParams rparams;", " ", "                  ", "                 if (size - jbig2_huffman_offset(hs) < BMSIZE) {", "                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"not enough data for decoding (%d/%d)\", BMSIZE, size - jbig2_huffman_offset(hs));", "                     jbig2_image_release(ctx, image);", "                     goto cleanup4;", "                 }", " ", "                 jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,", "                             \"reading %dx%d collective bitmap for %d symbols (%d bytes)\", image->width, image->height, NSYMSDECODED - HCFIRSTSYM, BMSIZE);", " ", "                 rparams.MMR = 1;", "                 code = jbig2_decode_generic_mmr(ctx, segment, &rparams, data + jbig2_huffman_offset(hs), BMSIZE, image);", "                 if (code) {", "                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"error decoding MMR bitmap image!\");", "                     jbig2_image_release(ctx, image);", "                     goto cleanup4;", "                 }", "             }", " ", "              ", "             jbig2_huffman_advance(hs, BMSIZE);", " ", "              ", "             x = 0;", "             for (j = HCFIRSTSYM; j < NSYMSDECODED; j++) {", "                 Jbig2Image *glyph;", " ", "                 glyph = jbig2_image_new(ctx, SDNEWSYMWIDTHS[j], HCHEIGHT);", "                 if (glyph == NULL) {", "                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to copy the collective bitmap into symbol dictionary\");", "                     jbig2_image_release(ctx, image);", "                     goto cleanup4;", "                 }", "                 jbig2_image_compose(ctx, glyph, image, -x, 0, JBIG2_COMPOSE_REPLACE);", "                 x += SDNEWSYMWIDTHS[j];", "                 SDNEWSYMS->glyphs[j] = glyph;", "             }", "             jbig2_image_release(ctx, image);", "         }", " ", "     }                            ", " ", "      ", "     SDEXSYMS = jbig2_sd_new(ctx, params->SDNUMEXSYMS);", "     if (SDEXSYMS == NULL) {", "         jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");", "          jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate symbols exported from symbols dictionary\");", "          goto cleanup4;", "      } else {", "        int i = 0;", "        int j = 0;", "        int k;", "         uint32_t i = 0;", "         uint32_t j = 0;", "         uint32_t k;", "          int exflag = 0;", "        int64_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;", "        int32_t exrunlength;", "         uint32_t limit = params->SDNUMINSYMS + params->SDNUMNEWSYMS;", "         uint32_t exrunlength;", "          int zerolength = 0;", "  ", "          while (i < limit) {", "              if (params->SDHUFF)", "                  exrunlength = jbig2_huffman_get(hs, SBHUFFRSIZE, &code);", "              else", "                code = jbig2_arith_int_decode(IAEX, as, &exrunlength);", "                 code = jbig2_arith_int_decode(IAEX, as, (int32_t *)&exrunlength);", "               ", "              zerolength = exrunlength > 0 ? 0 : zerolength + 1;", "            if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength > params->SDNUMEXSYMS - j))) {", "             if (code || (exrunlength > limit - i) || (exrunlength < 0) || (zerolength > 4) || (exflag && (exrunlength + j > params->SDNUMEXSYMS))) {", "                  if (code)", "                      jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode exrunlength for exported symbols\");", "                  else if (exrunlength <= 0)", "                 else", "                     jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number,", "                                 \"runlength too large in export symbol table (%d > %d - %d)\\n\", exrunlength, params->SDNUMEXSYMS, j);", "                  ", "                 jbig2_sd_release(ctx, SDEXSYMS);", "                 SDEXSYMS = NULL;", "                 break;", "             }", "             for (k = 0; k < exrunlength; k++) {", "                 if (exflag) {", "                     SDEXSYMS->glyphs[j++] = (i < params->SDNUMINSYMS) ?", "                                             jbig2_image_clone(ctx, params->SDINSYMS->glyphs[i]) : jbig2_image_clone(ctx, SDNEWSYMS->glyphs[i - params->SDNUMINSYMS]);", "                 }", "                 i++;", "             }", "             exflag = !exflag;", "         }", "     }", " ", " cleanup4:", "     if (tparams != NULL) {", "         if (!params->SDHUFF) {", "             jbig2_arith_int_ctx_free(ctx, tparams->IADT);", "             jbig2_arith_int_ctx_free(ctx, tparams->IAFS);", "             jbig2_arith_int_ctx_free(ctx, tparams->IADS);", "             jbig2_arith_int_ctx_free(ctx, tparams->IAIT);", "             jbig2_arith_iaid_ctx_free(ctx, tparams->IAID);", "             jbig2_arith_int_ctx_free(ctx, tparams->IARI);", "             jbig2_arith_int_ctx_free(ctx, tparams->IARDW);", "             jbig2_arith_int_ctx_free(ctx, tparams->IARDH);", "             jbig2_arith_int_ctx_free(ctx, tparams->IARDX);", "             jbig2_arith_int_ctx_free(ctx, tparams->IARDY);", "         } else {", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFFS);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFDS);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFDT);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDX);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDY);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDW);", "             jbig2_release_huffman_table(ctx, tparams->SBHUFFRDH);", "         }", "         jbig2_free(ctx->allocator, tparams);", "     }", "     if (refagg_dicts != NULL) {", "         jbig2_sd_release(ctx, refagg_dicts[0]);", "         jbig2_free(ctx->allocator, refagg_dicts);", "     }", " ", " cleanup2:", "     jbig2_sd_release(ctx, SDNEWSYMS);", "     if (params->SDHUFF && !params->SDREFAGG) {", "         jbig2_free(ctx->allocator, SDNEWSYMWIDTHS);", "     }", "     jbig2_release_huffman_table(ctx, SDHUFFRDX);", "     jbig2_release_huffman_table(ctx, SBHUFFRSIZE);", "     jbig2_huffman_free(ctx, hs);", "     jbig2_arith_iaid_ctx_free(ctx, IAID);", "     jbig2_arith_int_ctx_free(ctx, IARDX);", "     jbig2_arith_int_ctx_free(ctx, IARDY);", " ", " cleanup1:", "     jbig2_word_stream_buf_free(ctx, ws);", "     jbig2_free(ctx->allocator, as);", "     jbig2_arith_int_ctx_free(ctx, IADH);", "     jbig2_arith_int_ctx_free(ctx, IADW);", "     jbig2_arith_int_ctx_free(ctx, IAEX);", "     jbig2_arith_int_ctx_free(ctx, IAAI);", " ", "     return SDEXSYMS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TEST_F(RequantizeTest, HandCraftedRequantize) {", "ConfigureRequantize();", "const int value_count = 3;", "", "", "AddInputFromArray<qint32>(TensorShape({value_count}),", "{-(1 << 23), 0, (1 << 23)});", "AddInputFromArray<float>(TensorShape({1}), {-256.0f});", "AddInputFromArray<float>(TensorShape({1}), {256.0f});", "AddInputFromArray<float>(TensorShape({1}), {-1.0f});", "AddInputFromArray<float>(TensorShape({1}), {1.0f});", "TF_ASSERT_OK(RunOpKernel());", "Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));", "test::FillValues<quint8>(&expected, {0, 128, 255});", "test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));", "test::ExpectTensorEqual<float>(test::AsScalar<float>(-1.0f), *GetOutput(1));", "test::ExpectTensorEqual<float>(test::AsScalar<float>(1.0f), *GetOutput(2));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool PermissionsData::CanRunOnPage(const Extension* extension,", "                                    const GURL& document_url,", "                                    const GURL& top_frame_url,", "                                    int tab_id,", "                                    int process_id,", "                                    const URLPatternSet& permitted_url_patterns,", "                                    std::string* error) const {", "   if (g_policy_delegate &&", "       !g_policy_delegate->CanExecuteScriptOnPage(", "           extension, document_url, top_frame_url, tab_id, process_id, error)) {", "      return false;", "    }", "  ", "  bool can_execute_everywhere = CanExecuteScriptEverywhere(extension);", "  if (!can_execute_everywhere &&", "      !ExtensionsClient::Get()->IsScriptableURL(document_url, error)) {", "    return false;", "  }", "  if (!base::CommandLine::ForCurrentProcess()->HasSwitch(", "          switches::kExtensionsOnChromeURLs)) {", "    if (document_url.SchemeIs(content::kChromeUIScheme) &&", "        !can_execute_everywhere) {", "      if (error)", "        *error = manifest_errors::kCannotAccessChromeUrl;", "      return false;", "    }", "  }", "  if (top_frame_url.SchemeIs(kExtensionScheme) &&", "      top_frame_url.GetOrigin() !=", "          Extension::GetBaseURLFromExtensionId(extension->id()).GetOrigin() &&", "      !can_execute_everywhere) {", "    if (error)", "      *error = manifest_errors::kCannotAccessExtensionUrl;", "   if (IsRestrictedUrl(document_url, top_frame_url, extension, error))", "      return false;", "  }", "  ", "    if (HasTabSpecificPermissionToExecuteScript(tab_id, top_frame_url))", "      return true;", " ", "   bool can_access = permitted_url_patterns.MatchesURL(document_url);", " ", "   if (!can_access && error) {", "     *error = ErrorUtils::FormatErrorMessage(manifest_errors::kCannotAccessPage,", "                                             document_url.spec());", "   }", " ", "   return can_access;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["explicit HashContext(const HashContext* ctx) {", "assert(ctx->ops);", "assert(ctx->ops->context_size >= 0);", "ops = ctx->ops;", "context = malloc(ops->context_size);", "ops->hash_copy(context, ctx->context);", "options = ctx->options;", "key = ctx->key ? strdup(ctx->key) : nullptr;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" gss_wrap( OM_uint32 *minor_status,", "           gss_ctx_id_t context_handle,", "           int conf_req_flag,", "           gss_qop_t qop_req,", "           gss_buffer_t input_message_buffer,", "           int *conf_state,", "           gss_buffer_t output_message_buffer)", " {", " ", "      ", " ", "     OM_uint32           status;", "     gss_union_ctx_id_t  ctx;", "     gss_mechanism       mech;", " ", "     status = val_wrap_args(minor_status, context_handle,", "                            conf_req_flag, qop_req,", "                            input_message_buffer, conf_state,", "                            output_message_buffer);", "     if (status != GSS_S_COMPLETE)", "         return (status);", " ", "      ", "  ", "      ctx = (gss_union_ctx_id_t) context_handle;", "     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)", "         return (GSS_S_NO_CONTEXT);", "      mech = gssint_get_mechanism (ctx->mech_type);", "  ", "      if (mech) {", "         if (mech->gss_wrap) {", "             status = mech->gss_wrap(minor_status,", "                                     ctx->internal_ctx_id,", "                                     conf_req_flag,", "                                     qop_req,", "                                     input_message_buffer,", "                                     conf_state,", "                                     output_message_buffer);", "             if (status != GSS_S_COMPLETE)", "                 map_error(minor_status, mech);", "         } else if (mech->gss_wrap_aead ||", "                    (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {", "             status = gssint_wrap_aead(mech,", "                                       minor_status,", "                                       ctx,", "                                       conf_req_flag,", "                                       (gss_qop_t)qop_req,", "                                       GSS_C_NO_BUFFER,", "                                       input_message_buffer,", "                                       conf_state,", "                                       output_message_buffer);", "         } else", "             status = GSS_S_UNAVAILABLE;", " ", "         return(status);", "     }", "      ", " ", "     return (GSS_S_BAD_MECH);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)", " {", "     uint32_t *buf32;", "     uint32_t pix32;", "     int shift[3];", "     int *prev;", "     int here[3], upper[3], left[3], upperleft[3];", "     int prediction;", "     int x, y, c;", " ", "      buf32 = (uint32_t *)buf;", "      memset(vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));", "  ", "    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==", "        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {", "        shift[0] = vs->clientds.pf.rshift;", "        shift[1] = vs->clientds.pf.gshift;", "        shift[2] = vs->clientds.pf.bshift;", "     if (1  ) {", "         shift[0] = vs->client_pf.rshift;", "         shift[1] = vs->client_pf.gshift;", "         shift[2] = vs->client_pf.bshift;", "      } else {", "        shift[0] = 24 - vs->clientds.pf.rshift;", "        shift[1] = 24 - vs->clientds.pf.gshift;", "        shift[2] = 24 - vs->clientds.pf.bshift;", "         shift[0] = 24 - vs->client_pf.rshift;", "         shift[1] = 24 - vs->client_pf.gshift;", "         shift[2] = 24 - vs->client_pf.bshift;", "      }", "  ", "      for (y = 0; y < h; y++) {", "         for (c = 0; c < 3; c++) {", "             upper[c] = 0;", "             here[c] = 0;", "         }", "         prev = (int *)vs->tight.gradient.buffer;", "         for (x = 0; x < w; x++) {", "             pix32 = *buf32++;", "             for (c = 0; c < 3; c++) {", "                 upperleft[c] = upper[c];", "                 left[c] = here[c];", "                 upper[c] = *prev;", "                 here[c] = (int)(pix32 >> shift[c] & 0xFF);", "                 *prev++ = here[c];", " ", "                 prediction = left[c] + upper[c] - upperleft[c];", "                 if (prediction < 0) {", "                     prediction = 0;", "                 } else if (prediction > 0xFF) {", "                     prediction = 0xFF;", "                 }", "                 *buf++ = (char)(here[c] - prediction);", "             }", "         }", "     }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SPL_METHOD(Array, unserialize)", " {", " \tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);", " ", " \tchar *buf;", " \tint buf_len;", " \tconst unsigned char *p, *s;", " \tphp_unserialize_data_t var_hash;", " \tzval *pmembers, *pflags = NULL;", " \tlong flags;", " \t", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tif (buf_len == 0) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Empty serialized string cannot be empty\");", " \t\treturn;", " \t}", " ", " \t ", " \ts = p = (const unsigned char*)buf;", " \tPHP_VAR_UNSERIALIZE_INIT(var_hash);", " ", " \tif (*p!= 'x' || *++p != ':') {", " \t\tgoto outexcept;", " \t}", " \t++p;", " ", " \tALLOC_INIT_ZVAL(pflags);", " \tif (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) {", " \t\tzval_ptr_dtor(&pflags);", " \t\tgoto outexcept;", " \t}", " ", " \t--p;  ", " \tflags = Z_LVAL_P(pflags);", " \tzval_ptr_dtor(&pflags);", " \t ", " ", " \tif (*p != ';') {", " \t\tgoto outexcept;", " \t}", " \t++p;", " ", " \tif (*p!='m') {", " \t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {", " \t\t\tgoto outexcept;", " \t\t}", " \t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;", " \t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;", " \t\tzval_ptr_dtor(&intern->array);", " \t\tALLOC_INIT_ZVAL(intern->array);", " \t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {", " \t\t\tgoto outexcept;", " \t\t}", " \t}", " \tif (*p != ';') {", " \t\tgoto outexcept;", " \t}", " \t++p;", " ", " \t ", " \tif (*p!= 'm' || *++p != ':') {", " \t\tgoto outexcept;", " \t}", "         ++p;", "  ", "         ALLOC_INIT_ZVAL(pmembers);", "       if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC)) {", "        if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {", "                 zval_ptr_dtor(&pmembers);", "                 goto outexcept;", "         }", " ", " \t ", " \tif (!intern->std.properties) {", " \t\trebuild_object_properties(&intern->std);", " \t}", " \tzend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *));", " \tzval_ptr_dtor(&pmembers);", " ", " \t ", " ", " \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);", " \treturn;", " ", " outexcept:", " \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);", " \tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);", " \treturn;", " ", " }  ", " ", "  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ssize_t socket_bytes_available(const socket_t *socket) {", " ", "    assert(socket != NULL);", "  ", "    int size = 0;", "  if (ioctl(socket->fd, FIONREAD, &size) == -1)", "   if (TEMP_FAILURE_RETRY(ioctl(socket->fd, FIONREAD, &size)) == -1)", "      return -1;", "    return size;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["  void BaseMultipleFieldsDateAndTimeInputType::didBlurFromControl()", "  {", "  ", "     if (containsFocusedShadowElement())", "         return;", "      RefPtr<HTMLInputElement> protector(element());", "      element()->setFocus(false);", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> overloadedMethod6Callback(const v8::Arguments& args)", "  {", "      INC_STATS(\"DOM.TestObj.overloadedMethod6\");", "      if (args.Length() < 1)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "      TestObj* imp = V8TestObj::toNative(args.Holder());", "      EXCEPTION_BLOCK(RefPtr<DOMStringList>, listArg, v8ValueToWebCoreDOMStringList(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));", "      imp->overloadedMethod(listArg);", "     return v8::Handle<v8::Value>();", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict)", " {", " \tpdf_obj *obj;", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_LW);", " \tif (pdf_is_number(ctx, obj) && proc->op_w)", " \t\tproc->op_w(ctx, proc, pdf_to_real(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_LC);", " \tif (pdf_is_int(ctx, obj) && proc->op_J)", " \t\tproc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_LJ);", " \tif (pdf_is_int(ctx, obj) && proc->op_j)", " \t\tproc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_ML);", " \tif (pdf_is_number(ctx, obj) && proc->op_M)", " \t\tproc->op_M(ctx, proc, pdf_to_real(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_D);", " \tif (pdf_is_array(ctx, obj) && proc->op_d)", " \t{", " \t\tpdf_obj *dash_array = pdf_array_get(ctx, obj, 0);", " \t\tpdf_obj *dash_phase = pdf_array_get(ctx, obj, 1);", " \t\tproc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase));", " \t}", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_RI);", " \tif (pdf_is_name(ctx, obj) && proc->op_ri)", " \t\tproc->op_ri(ctx, proc, pdf_to_name(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_FL);", " \tif (pdf_is_number(ctx, obj) && proc->op_i)", " \t\tproc->op_i(ctx, proc, pdf_to_real(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_Font);", " \tif (pdf_is_array(ctx, obj) && proc->op_Tf)", " \t{", " \t\tpdf_obj *font_ref = pdf_array_get(ctx, obj, 0);", " \t\tpdf_obj *font_size = pdf_array_get(ctx, obj, 1);", " \t\tpdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie);", " \t\tfz_try(ctx)", " \t\t\tproc->op_Tf(ctx, proc, \"ExtGState\", font, pdf_to_real(ctx, font_size));", " \t\tfz_always(ctx)", " \t\t\tpdf_drop_font(ctx, font);", " \t\tfz_catch(ctx)", " \t\t\tfz_rethrow(ctx);", " \t}", " ", " \t ", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_OP);", " \tif (pdf_is_bool(ctx, obj) && proc->op_gs_OP)", " \t\tproc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_op);", " \tif (pdf_is_bool(ctx, obj) && proc->op_gs_op)", " \t\tproc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_OPM);", " \tif (pdf_is_int(ctx, obj) && proc->op_gs_OPM)", " \t\tproc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp);", " \tif (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp)", " \t\tproc->op_gs_UseBlackPtComp(ctx, proc, obj);", " ", " \t ", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_TR2);", " \tif (pdf_is_name(ctx, obj))", " \t\tif (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default))", " \t\t\tfz_warn(ctx, \"ignoring transfer function\");", " \tif (!obj)  ", " \t{", " \t\tpdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR);", " \t\tif (pdf_is_name(ctx, tr))", " \t\t\tif (!pdf_name_eq(ctx, tr, PDF_NAME_Identity))", " \t\t\t\tfz_warn(ctx, \"ignoring transfer function\");", " \t}", " ", " \t ", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_CA);", " \tif (pdf_is_number(ctx, obj) && proc->op_gs_CA)", " \t\tproc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_ca);", " \tif (pdf_is_number(ctx, obj) && proc->op_gs_ca)", " \t\tproc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_BM);", " \tif (pdf_is_array(ctx, obj))", " \t\tobj = pdf_array_get(ctx, obj, 0);", " \tif (pdf_is_name(ctx, obj) && proc->op_gs_BM)", " \t\tproc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj));", " ", " \tobj = pdf_dict_get(ctx, dict, PDF_NAME_SMask);", " \tif (proc->op_gs_SMask)", " \t{", " \t\tif (pdf_is_dict(ctx, obj))", " \t\t{", " \t\t\tpdf_xobject *xobj;", " \t\t\tpdf_obj *group, *s, *bc, *tr;", " \t\t\tfloat softmask_bc[FZ_MAX_COLORS];", " \t\t\tfz_colorspace *colorspace;", " \t\t\tint colorspace_n = 1;", " \t\t\tint k, luminosity;", " ", "                         fz_var(xobj);", "  ", "                         group = pdf_dict_get(ctx, obj, PDF_NAME_G);", "                       if (!group)", "                               fz_throw(ctx, FZ_ERROR_SYNTAX, \"cannot load softmask xobject (%d 0 R)\", pdf_to_num(ctx, obj));", "                         xobj = pdf_load_xobject(ctx, csi->doc, group);", "  ", " ", " \t\t\tfz_try(ctx)", " \t\t\t{", " \t\t\t\tcolorspace = pdf_xobject_colorspace(ctx, xobj);", " \t\t\t\tif (colorspace)", " \t\t\t\t\tcolorspace_n = fz_colorspace_n(ctx, colorspace);", " ", " \t\t\t\t ", " \t\t\t\tfor (k = 0; k < colorspace_n; k++)", " \t\t\t\t\tsoftmask_bc[k] = 0;", " \t\t\t\t ", " \t\t\t\tif (fz_colorspace_is_cmyk(ctx, colorspace))", " \t\t\t\t\tsoftmask_bc[3] = 1.0f;", " \t\t\t\tfz_drop_colorspace(ctx, colorspace);", " ", " \t\t\t\tbc = pdf_dict_get(ctx, obj, PDF_NAME_BC);", " \t\t\t\tif (pdf_is_array(ctx, bc))", " \t\t\t\t{", " \t\t\t\t\tfor (k = 0; k < colorspace_n; k++)", " \t\t\t\t\t\tsoftmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k));", " \t\t\t\t}", " ", " \t\t\t\ts = pdf_dict_get(ctx, obj, PDF_NAME_S);", " \t\t\t\tif (pdf_name_eq(ctx, s, PDF_NAME_Luminosity))", " \t\t\t\t\tluminosity = 1;", " \t\t\t\telse", " \t\t\t\t\tluminosity = 0;", " ", " \t\t\t\ttr = pdf_dict_get(ctx, obj, PDF_NAME_TR);", " \t\t\t\tif (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity))", " \t\t\t\t\tfz_warn(ctx, \"ignoring transfer function\");", " ", " \t\t\t\tproc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity);", " \t\t\t}", " \t\t\tfz_always(ctx)", " \t\t\t{", " \t\t\t\tpdf_drop_xobject(ctx, xobj);", " \t\t\t}", " \t\t\tfz_catch(ctx)", " \t\t\t{", " \t\t\t\tfz_rethrow(ctx);", " \t\t\t}", " \t\t}", " \t\telse if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None))", " \t\t{", " \t\t\tproc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0);", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)", " {", "     JSValue thisValue = exec->hostThisValue();", "     if (!thisValue.inherits(&JSTestObj::s_info))", "         return throwVMTypeError(exec);", "     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));", "      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);", "      TestObj* impl = static_cast<TestObj*>(castedThis->impl());", "      if (exec->argumentCount() < 1)", "        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));", "         return throwVMError(exec, createNotEnoughArgumentsError(exec));", "      d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));", "      if (exec->hadException())", "          return JSValue::encode(jsUndefined());", "     impl->convert4();", "     return JSValue::encode(jsUndefined());", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" UseCounterPageLoadMetricsObserver::GetAllowedUkmFeatures() {", "   static base::NoDestructor<UseCounterPageLoadMetricsObserver::UkmFeatureList>", "       opt_in_features(std::initializer_list<WebFeature>({", "           WebFeature::kNavigatorVibrate,", "           WebFeature::kNavigatorVibrateSubFrame,", "           WebFeature::kTouchEventPreventedNoTouchAction,", "           WebFeature::kTouchEventPreventedForcedDocumentPassiveNoTouchAction,", "           WebFeature::kDataUriHasOctothorpe,", "           WebFeature::kApplicationCacheManifestSelectInsecureOrigin,", "           WebFeature::kApplicationCacheManifestSelectSecureOrigin,", "           WebFeature::kMixedContentAudio,", "           WebFeature::kMixedContentImage,", "           WebFeature::kMixedContentVideo,", "           WebFeature::kMixedContentPlugin,", "           WebFeature::kOpenerNavigationWithoutGesture,", "           WebFeature::kUsbRequestDevice,", "           WebFeature::kXMLHttpRequestSynchronous,", "           WebFeature::kPaymentHandler,", "           WebFeature::kPaymentRequestShowWithoutGesture,", "           WebFeature::kHTMLImports,", "           WebFeature::kHTMLImportsHasStyleSheets,", "           WebFeature::kElementCreateShadowRoot,", "           WebFeature::kDocumentRegisterElement,", "           WebFeature::kCredentialManagerCreatePublicKeyCredential,", "           WebFeature::kCredentialManagerGetPublicKeyCredential,", "           WebFeature::kCredentialManagerMakePublicKeyCredentialSuccess,", "           WebFeature::kCredentialManagerGetPublicKeyCredentialSuccess,", "           WebFeature::kV8AudioContext_Constructor,", "           WebFeature::kElementAttachShadow,", "           WebFeature::kElementAttachShadowOpen,", "           WebFeature::kElementAttachShadowClosed,", "           WebFeature::kCustomElementRegistryDefine,", "           WebFeature::kTextToSpeech_Speak,", "           WebFeature::kTextToSpeech_SpeakDisallowedByAutoplay,", "           WebFeature::kCSSEnvironmentVariable,", "           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetTop,", "           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetLeft,", "           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetRight,", "           WebFeature::kCSSEnvironmentVariable_SafeAreaInsetBottom,", "           WebFeature::kMediaControlsDisplayCutoutGesture,", "           WebFeature::kPolymerV1Detected,", "           WebFeature::kPolymerV2Detected,", "           WebFeature::kFullscreenSecureOrigin,", "           WebFeature::kFullscreenInsecureOrigin,", "           WebFeature::kPrefixedVideoEnterFullscreen,", "           WebFeature::kPrefixedVideoExitFullscreen,", "           WebFeature::kPrefixedVideoEnterFullScreen,", "           WebFeature::kPrefixedVideoExitFullScreen,", "           WebFeature::kDocumentLevelPassiveDefaultEventListenerPreventedWheel,", "           WebFeature::kDocumentDomainBlockedCrossOriginAccess,", "           WebFeature::kDocumentDomainEnabledCrossOriginAccess,", "           WebFeature::kSuppressHistoryEntryWithoutUserGesture,", "           WebFeature::kCursorImageGT32x32,", "           WebFeature::kCursorImageLE32x32,", "           WebFeature::kHistoryPushState,", "           WebFeature::kHistoryReplaceState,", "           WebFeature::kCursorImageGT64x64,", "           WebFeature::kAdClick,", "           WebFeature::kUpdateWithoutShippingOptionOnShippingAddressChange,", "           WebFeature::kUpdateWithoutShippingOptionOnShippingOptionChange,", "           WebFeature::kSignedExchangeInnerResponseInMainFrame,", "           WebFeature::kSignedExchangeInnerResponseInSubFrame,", "           WebFeature::kWebShareShare,", "           WebFeature::kHTMLAnchorElementDownloadInSandboxWithUserGesture,", "           WebFeature::kHTMLAnchorElementDownloadInSandboxWithoutUserGesture,", "           WebFeature::kNavigationDownloadInSandboxWithUserGesture,", "           WebFeature::kNavigationDownloadInSandboxWithoutUserGesture,", "           WebFeature::kDownloadInAdFrameWithUserGesture,", "            WebFeature::kDownloadInAdFrameWithoutUserGesture,", "            WebFeature::kOpenWebDatabase,", "            WebFeature::kV8MediaCapabilities_DecodingInfo_Method,", "           WebFeature::kOpenerNavigationDownloadCrossOriginNoGesture,", "        }));", "    return *opt_in_features;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  static void vmxnet3_activate_device(VMXNET3State *s)", "  {", "      int i;", "     VMW_CFPRN(\"MTU is %u\", s->mtu);", " ", "     s->max_rx_frags =", "         VMXNET3_READ_DRV_SHARED16(s->drv_shmem, devRead.misc.maxNumRxSG);", " ", "     if (s->max_rx_frags == 0) {", "         s->max_rx_frags = 1;", "     }", " ", "     VMW_CFPRN(\"Max RX fragments is %u\", s->max_rx_frags);", " ", "     s->event_int_idx =", "         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.eventIntrIdx);", "     assert(vmxnet3_verify_intx(s, s->event_int_idx));", "     VMW_CFPRN(\"Events interrupt line is %u\", s->event_int_idx);", " ", "     s->auto_int_masking =", "         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.intrConf.autoMask);", "     VMW_CFPRN(\"Automatic interrupt masking is %d\", (int)s->auto_int_masking);", " ", "     s->txq_num =", "         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numTxQueues);", "     s->rxq_num =", "         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);", " ", "     VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);", "     assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);", " ", "     qdescr_table_pa =", "         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);", "     VMW_CFPRN(\"TX queues descriptors table is at 0x%\" PRIx64, qdescr_table_pa);", " ", "      ", "     s->max_tx_frags = 0;", " ", "      ", "     for (i = 0; i < s->txq_num; i++) {", "          VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);", "  ", "      VMW_CFPRN(\"Number of TX/RX queues %u/%u\", s->txq_num, s->rxq_num);", "    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);", "     vmxnet3_validate_queues(s);", "  ", "      qdescr_table_pa =", "          VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);", " ", "         VMW_CFPRN(\"TX Queue %d interrupt: %d\", i, s->txq_descr[i].intr_idx);", " ", "          ", "         pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.txRingBasePA);", "         size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.txRingSize);", " ", "         vmxnet3_ring_init(&s->txq_descr[i].tx_ring, pa, size,", "                           sizeof(struct Vmxnet3_TxDesc), false);", "         VMXNET3_RING_DUMP(VMW_CFPRN, \"TX\", i, &s->txq_descr[i].tx_ring);", " ", "         s->max_tx_frags += size;", " ", "          ", "         pa = VMXNET3_READ_TX_QUEUE_DESCR64(qdescr_pa, conf.compRingBasePA);", "         size = VMXNET3_READ_TX_QUEUE_DESCR32(qdescr_pa, conf.compRingSize);", "         vmxnet3_ring_init(&s->txq_descr[i].comp_ring, pa, size,", "                           sizeof(struct Vmxnet3_TxCompDesc), true);", "         VMXNET3_RING_DUMP(VMW_CFPRN, \"TXC\", i, &s->txq_descr[i].comp_ring);", " ", "         s->txq_descr[i].tx_stats_pa =", "             qdescr_pa + offsetof(struct Vmxnet3_TxQueueDesc, stats);", " ", "         memset(&s->txq_descr[i].txq_stats, 0,", "                sizeof(s->txq_descr[i].txq_stats));", " ", "          ", "         VMXNET3_WRITE_TX_QUEUE_DESCR32(qdescr_pa,", "                                        ctrl.txThreshold,", "                                        VMXNET3_DEF_TX_THRESHOLD);", "     }", " ", "      ", "     VMW_CFPRN(\"Max TX fragments is %u\", s->max_tx_frags);", "     vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);", "     vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);", " ", "      ", "     for (i = 0; i < s->rxq_num; i++) {", "         int j;", "         hwaddr qd_pa =", "             qdescr_table_pa + s->txq_num * sizeof(struct Vmxnet3_TxQueueDesc) +", "             i * sizeof(struct Vmxnet3_RxQueueDesc);", " ", "          ", "         s->rxq_descr[i].intr_idx =", "             VMXNET3_READ_TX_QUEUE_DESCR8(qd_pa, conf.intrIdx);", "         assert(vmxnet3_verify_intx(s, s->rxq_descr[i].intr_idx));", " ", "         VMW_CFPRN(\"RX Queue %d interrupt: %d\", i, s->rxq_descr[i].intr_idx);", " ", "          ", "         for (j = 0; j < VMXNET3_RX_RINGS_PER_QUEUE; j++) {", "              ", "             pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.rxRingBasePA[j]);", "             size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.rxRingSize[j]);", "             vmxnet3_ring_init(&s->rxq_descr[i].rx_ring[j], pa, size,", "                               sizeof(struct Vmxnet3_RxDesc), false);", "             VMW_CFPRN(\"RX queue %d:%d: Base: %\" PRIx64 \", Size: %d\",", "                       i, j, pa, size);", "         }", " ", "          ", "         pa = VMXNET3_READ_RX_QUEUE_DESCR64(qd_pa, conf.compRingBasePA);", "         size = VMXNET3_READ_RX_QUEUE_DESCR32(qd_pa, conf.compRingSize);", "         vmxnet3_ring_init(&s->rxq_descr[i].comp_ring, pa, size,", "                           sizeof(struct Vmxnet3_RxCompDesc), true);", "         VMW_CFPRN(\"RXC queue %d: Base: %\" PRIx64 \", Size: %d\", i, pa, size);", " ", "         s->rxq_descr[i].rx_stats_pa =", "             qd_pa + offsetof(struct Vmxnet3_RxQueueDesc, stats);", "         memset(&s->rxq_descr[i].rxq_stats, 0,", "                sizeof(s->rxq_descr[i].rxq_stats));", "     }", " ", "     vmxnet3_validate_interrupts(s);", " ", "      ", "     smp_wmb();", " ", "     vmxnet3_reset_mac(s);", " ", "     s->device_active = true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,", " \t\t\tstruct msghdr *msg, size_t size, int flags)", "  {", "  \tstruct sock *sk = sock->sk;", "  \tstruct rose_sock *rose = rose_sk(sk);", "\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;", "  \tsize_t copied;", "  \tunsigned char *asmptr;", "  \tstruct sk_buff *skb;", " \tint n, er, qbit;", " ", " \t ", " \tif (sk->sk_state != TCP_ESTABLISHED)", " \t\treturn -ENOTCONN;", " ", " \t ", " \tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)", " \t\treturn er;", " ", " \tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;", " ", " \tskb_pull(skb, ROSE_MIN_LEN);", " ", " \tif (rose->qbitincl) {", " \t\tasmptr  = skb_push(skb, 1);", " \t\t*asmptr = qbit;", " \t}", " ", " \tskb_reset_transport_header(skb);", " \tcopied     = skb->len;", " ", " \tif (copied > size) {", " \t\tcopied = size;", " \t\tmsg->msg_flags |= MSG_TRUNC;", " \t}", "  ", "  \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);", "  ", "\tif (srose != NULL) {", "\t\tmemset(srose, 0, msg->msg_namelen);", " \tif (msg->msg_name) {", " \t\tstruct sockaddr_rose *srose;", " ", " \t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));", " \t\tsrose = msg->msg_name;", "  \t\tsrose->srose_family = AF_ROSE;", "  \t\tsrose->srose_addr   = rose->dest_addr;", "  \t\tsrose->srose_call   = rose->dest_call;", " \t\tsrose->srose_ndigis = rose->dest_ndigis;", " \t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {", " \t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;", " \t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)", " \t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];", " \t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);", " \t\t} else {", " \t\t\tif (rose->dest_ndigis >= 1) {", " \t\t\t\tsrose->srose_ndigis = 1;", " \t\t\t\tsrose->srose_digi = rose->dest_digis[0];", " \t\t\t}", " \t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);", " \t\t}", " \t}", " ", " \tskb_free_datagram(sk, skb);", " ", " \treturn copied;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "const Tensor& splits = context->input(0);", "const Tensor& values = context->input(1);", "const Tensor& weights = context->input(2);", "bool use_weights = weights.NumElements() > 0;", "bool is_1d = false;", "", "const auto splits_values = splits.flat<int64>();", "const auto values_values = values.flat<T>();", "const auto weight_values = weights.flat<W>();", "int num_batches = splits.NumElements() - 1;", "int num_values = values.NumElements();", "", "auto per_batch_counts = BatchedMap<W>(num_batches);", "T max_value = 0;", "int batch_idx = 0;", "", "for (int idx = 0; idx < num_values; ++idx) {", "while (idx >= splits_values(batch_idx)) {", "batch_idx++;", "}", "const auto& value = values_values(idx);", "if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {", "if (binary_output_) {", "per_batch_counts[batch_idx - 1][value] = 1;", "} else if (use_weights) {", "per_batch_counts[batch_idx - 1][value] += weight_values(idx);", "} else {", "per_batch_counts[batch_idx - 1][value]++;", "}", "if (value > max_value) {", "max_value = value;", "}", "}", "}", "", "int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);", "OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,", "is_1d, context));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void NavigationControllerImpl::RendererDidNavigateToExistingPage(", "     RenderFrameHostImpl* rfh,", "     const FrameHostMsg_DidCommitProvisionalLoad_Params& params,", "     bool is_in_page,", "     bool was_restored,", "     NavigationHandleImpl* handle) {", "   DCHECK(!rfh->GetParent());", " ", " ", "   NavigationEntryImpl* entry;", "   if (params.intended_as_new_entry) {", "      entry = GetLastCommittedEntry();", "     MaybeDumpCopiedNonSameOriginEntry(\"Existing page navigation\", params,", "                                       is_in_page, entry);", "    } else if (params.nav_entry_id) {", "      entry = GetEntryWithUniqueID(params.nav_entry_id);", " ", "     if (is_in_page) {", "       NavigationEntryImpl* last_entry = GetLastCommittedEntry();", "       if (entry->GetURL().GetOrigin() == last_entry->GetURL().GetOrigin() &&", "           last_entry->GetSSL().initialized && !entry->GetSSL().initialized &&", "           was_restored) {", "         entry->GetSSL() = last_entry->GetSSL();", "       }", "     } else {", "       entry->GetSSL() = handle->ssl_status();", "     }", "   } else {", "     entry = GetLastCommittedEntry();", " ", "     if (!is_in_page)", "       entry->GetSSL() = handle->ssl_status();", "   }", "   DCHECK(entry);", " ", "   entry->set_page_type(params.url_is_unreachable ? PAGE_TYPE_ERROR", "                                                  : PAGE_TYPE_NORMAL);", "   entry->SetURL(params.url);", "   entry->SetReferrer(params.referrer);", "   if (entry->update_virtual_url_with_url())", "     UpdateVirtualURLToURL(entry, params.url);", " ", "   DCHECK(entry->site_instance() == nullptr ||", "          !entry->GetRedirectChain().empty() ||", "          entry->site_instance() == rfh->GetSiteInstance());", " ", "   entry->AddOrUpdateFrameEntry(", "       rfh->frame_tree_node(), params.item_sequence_number,", "       params.document_sequence_number, rfh->GetSiteInstance(), nullptr,", "       params.url, params.referrer, params.redirects, params.page_state,", "       params.method, params.post_id);", " ", "   if (ui::PageTransitionIsRedirect(params.transition) && !is_in_page)", "     entry->GetFavicon() = FaviconStatus();", " ", "   DiscardNonCommittedEntriesInternal();", " ", "   last_committed_entry_index_ = GetIndexOfEntry(entry);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,", "                                       unsigned char **p,", "                                       unsigned char *end )", " {", "     int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;", "     size_t  len;", "     ((void) ssl);", " ", "      ", "     if( (*p) > end - 2 )", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"", "                                     \"(psk_identity_hint length)\" ) );", "         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "     }", "      len = (*p)[0] << 8 | (*p)[1];", "      *p += 2;", "  ", "     if( (*p) + len > end )", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"", "                                     \"(psk_identity_hint length)\" ) );", "         return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "     }", " ", "      ", "     *p += len;", "     ret = 0;", " ", "     return( ret );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static sk_sp<SkImage> newSkImageFromRaster(const SkImageInfo& info,", "                                             PassRefPtr<Uint8Array> imagePixels,", "                                           size_t imageRowBytes) {", "                                            unsigned imageRowBytes) {", "    SkPixmap pixmap(info, imagePixels->data(), imageRowBytes);", "    return SkImage::MakeFromRaster(pixmap,", "                                   [](const void*, void* pixels) {", "                                    static_cast<Uint8Array*>(pixels)->deref();", "                                  },", "                                  imagePixels.leakRef());", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  GLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer) {", "  if (!buffer || isContextLost())", "   if (!buffer || isContextLost() || !buffer->Validate(ContextGroup(), this))", "      return 0;", "  ", "    if (!buffer->HasEverBeenBound())", "     return 0;", "   if (buffer->IsDeleted())", "     return 0;", " ", "   return ContextGL()->IsBuffer(buffer->Object());", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadLABELImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   char", "     geometry[MaxTextExtent],", "     *property;", " ", "   const char", "     *label;", " ", "   DrawInfo", "     *draw_info;", " ", "   Image", "     *image;", " ", "   MagickBooleanType", "     status;", " ", "   TypeMetric", "     metrics;", " ", "   size_t", "     height,", "     width;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   (void) ResetImagePage(image,\"0x0+0+0\");", "   property=InterpretImageProperties(image_info,image,image_info->filename);", "   (void) SetImageProperty(image,\"label\",property);", "   property=DestroyString(property);", "   label=GetImageProperty(image,\"label\");", "   draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);", "   draw_info->text=ConstantString(label);", "   metrics.width=0;", "   metrics.ascent=0.0;", "   status=GetMultilineTypeMetrics(image,draw_info,&metrics);", "   if ((image->columns == 0) && (image->rows == 0))", "     {", "       image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);", "       image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);", "     }", "   else", "     if (((image->columns == 0) || (image->rows == 0)) ||", "         (fabs(image_info->pointsize) < MagickEpsilon))", "       {", "         double", "           high,", "           low;", " ", "          ", "         for ( ; ; draw_info->pointsize*=2.0)", "         {", "           (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",", "             -metrics.bounds.x1,metrics.ascent);", "           if (draw_info->gravity == UndefinedGravity)", "             (void) CloneString(&draw_info->geometry,geometry);", "           status=GetMultilineTypeMetrics(image,draw_info,&metrics);", "           (void) status;", "           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);", "           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);", "           if ((image->columns != 0) && (image->rows != 0))", "             {", "               if ((width >= image->columns) && (height >= image->rows))", "                 break;", "             }", "           else", "             if (((image->columns != 0) && (width >= image->columns)) ||", "                 ((image->rows != 0) && (height >= image->rows)))", "               break;", "         }", "         high=draw_info->pointsize;", "         for (low=1.0; (high-low) > 0.5; )", "         {", "           draw_info->pointsize=(low+high)/2.0;", "           (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",", "             -metrics.bounds.x1,metrics.ascent);", "           if (draw_info->gravity == UndefinedGravity)", "             (void) CloneString(&draw_info->geometry,geometry);", "           status=GetMultilineTypeMetrics(image,draw_info,&metrics);", "           width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);", "           height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);", "           if ((image->columns != 0) && (image->rows != 0))", "             {", "               if ((width < image->columns) && (height < image->rows))", "                 low=draw_info->pointsize+0.5;", "               else", "                 high=draw_info->pointsize-0.5;", "             }", "           else", "             if (((image->columns != 0) && (width < image->columns)) ||", "                 ((image->rows != 0) && (height < image->rows)))", "               low=draw_info->pointsize+0.5;", "             else", "               high=draw_info->pointsize-0.5;", "         }", "         draw_info->pointsize=(low+high)/2.0-0.5;", "       }", "   status=GetMultilineTypeMetrics(image,draw_info,&metrics);", "   if (status == MagickFalse)", "     {", "       InheritException(exception,&image->exception);", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   if (image->columns == 0)", "     image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5);", "   if (image->columns == 0)", "     image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);", "   if (image->rows == 0)", "     image->rows=(size_t) (metrics.ascent-metrics.descent+", "        draw_info->stroke_width+0.5);", "    if (image->rows == 0)", "      image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5);", "   status=SetImageExtent(image,image->columns,image->rows);", "   if (status == MagickFalse)", "     {", "       InheritException(exception,&image->exception);", "       return(DestroyImageList(image));", "     }", "    if (draw_info->gravity == UndefinedGravity)", "      {", "        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",", "         -metrics.bounds.x1+draw_info->stroke_width/2.0,metrics.ascent+", "         draw_info->stroke_width/2.0);", "       (void) CloneString(&draw_info->geometry,geometry);", "     }", "   if (draw_info->direction == RightToLeftDirection)", "     {", "       if (draw_info->direction == RightToLeftDirection)", "         (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",", "           image->columns-(metrics.bounds.x2+draw_info->stroke_width/2.0),", "           metrics.ascent+draw_info->stroke_width/2.0);", "       (void) CloneString(&draw_info->geometry,geometry);", "     }", "   if (SetImageBackgroundColor(image) == MagickFalse)", "     {", "       InheritException(exception,&image->exception);", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   (void) AnnotateImage(image,draw_info);", "   if (image_info->pointsize == 0.0)", "     {", "       char", "         pointsize[MaxTextExtent];", " ", "       (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",", "         draw_info->pointsize);", "       (void) SetImageProperty(image,\"label:pointsize\",pointsize);", "     }", "   draw_info=DestroyDrawInfo(draw_info);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int log_statement_ex(const struct connection_info *cn,", "time_t ev_time, unsigned long thd_id,", "const char *query, unsigned int query_len,", "int error_code, const char *type, int take_lock)", "{", "size_t csize;", "char message_loc[1024];", "char *message= message_loc;", "size_t message_size= sizeof(message_loc);", "char *uh_buffer;", "size_t uh_buffer_size;", "const char *db;", "unsigned int db_length;", "long long query_id;", "int result;", "", "if ((db= cn->db))", "db_length= cn->db_length;", "else", "{", "db= \"\";", "db_length= 0;", "}", "", "if (!(query_id= cn->query_id))", "query_id= query_counter++;", "", "if (query == 0)", "{", "", "query= cn->query;", "query_len= cn->query_length;", "if (query == 0 || query_len == 0)", "return 0;", "}", "", "if (query && !(events & EVENT_QUERY_ALL) &&", "(events & EVENT_QUERY && !cn->log_always))", "{", "const char *orig_query= query;", "", "if (filter_query_type(query, keywords_to_skip))", "{", "char fword[MAX_KEYWORD + 1];", "int len;", "do", "{", "len= get_next_word(query, fword);", "query+= len ? len : 1;", "if (len == 3 && strncmp(fword, \"FOR\", 3) == 0)", "break;", "} while (*query);", "", "if (*query == 0)", "return 0;", "}", "", "if (events & EVENT_QUERY_DDL)", "{", "if (!filter_query_type(query, not_ddl_keywords) &&", "filter_query_type(query, ddl_keywords))", "goto do_log_query;", "}", "if (events & EVENT_QUERY_DML)", "{", "if (filter_query_type(query, dml_keywords))", "goto do_log_query;", "}", "if (events & EVENT_QUERY_DML_NO_SELECT)", "{", "if (filter_query_type(query, dml_no_select_keywords))", "goto do_log_query;", "}", "if (events & EVENT_QUERY_DCL)", "{", "if (filter_query_type(query, dcl_keywords))", "goto do_log_query;", "}", "", "return 0;", "do_log_query:", "query= orig_query;", "}", "", "csize= log_header(message, message_size-1, &ev_time,", "servhost, servhost_len,", "cn->user, cn->user_length,cn->host, cn->host_length,", "cn->ip, cn->ip_length, thd_id, query_id, type);", "", "csize+= my_snprintf(message+csize, message_size - 1 - csize,", "\",%.*s,\\'\", db_length, db);", "", "if (query_log_limit > 0 && query_len > query_log_limit)", "query_len= query_log_limit;", "", "if (query_len > (message_size - csize)/2)", "{", "flogger_mutex_lock(&lock_bigbuffer);", "if (big_buffer_alloced < (query_len * 2 + csize))", "{", "big_buffer_alloced= (query_len * 2 + csize + 4095) & ~4095L;", "big_buffer= realloc(big_buffer, big_buffer_alloced);", "if (big_buffer == NULL)", "{", "big_buffer_alloced= 0;", "return 0;", "}", "}", "", "memcpy(big_buffer, message, csize);", "message= big_buffer;", "message_size= big_buffer_alloced;", "}", "", "uh_buffer= message + csize;", "uh_buffer_size= message_size - csize;", "if (query_log_limit > 0 && uh_buffer_size > query_log_limit+2)", "uh_buffer_size= query_log_limit+2;", "", "switch (filter_query_type(query, passwd_keywords))", "{", "case SQLCOM_GRANT:", "case SQLCOM_CREATE_USER:", "csize+= escape_string_hide_passwords(query, query_len,", "uh_buffer, uh_buffer_size,", "\"IDENTIFIED\", 10, \"BY\", 2, 0);", "break;", "case SQLCOM_CHANGE_MASTER:", "csize+= escape_string_hide_passwords(query, query_len,", "uh_buffer, uh_buffer_size,", "\"MASTER_PASSWORD\", 15, \"=\", 1, 0);", "break;", "case SQLCOM_CREATE_SERVER:", "case SQLCOM_ALTER_SERVER:", "csize+= escape_string_hide_passwords(query, query_len,", "uh_buffer, uh_buffer_size,", "\"PASSWORD\", 8, NULL, 0, 0);", "break;", "case SQLCOM_SET_OPTION:", "csize+= escape_string_hide_passwords(query, query_len,", "uh_buffer, uh_buffer_size,", "\"=\", 1, NULL, 0, 1);", "break;", "default:", "csize+= escape_string(query, query_len,", "uh_buffer, uh_buffer_size);", "break;", "}", "csize+= my_snprintf(message+csize, message_size - 1 - csize,", "\"\\',%d\", error_code);", "message[csize]= '\\n';", "result= write_log(message, csize + 1, take_lock);", "if (message == big_buffer)", "flogger_mutex_unlock(&lock_bigbuffer);", "", "return result;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void ProcessHeap::Init() {", "   total_allocated_space_ = 0;", "    total_allocated_object_size_ = 0;", "    total_marked_object_size_ = 0;", "  ", "  GCInfoTable::Init();", "    base::SamplingHeapProfiler::SetHooksInstallCallback([]() {", "      HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);", "      HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);", "   });", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,", " \t\t\t\t     int off_pitch, int bytesperline,", " \t\t\t\t     int lines)", " {", "     int y;", "      int off_cur;", "      int off_cur_end;", "  ", "     if (off_pitch < 0) {", "         off_begin -= bytesperline - 1;", "     }", " ", "      for (y = 0; y < lines; y++) {", "         off_cur = off_begin;", "         off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;", "         assert(off_cur_end >= off_cur);", "          memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);", "         off_begin += off_pitch;", "      }", "     uint8_t *dst;", " ", "     dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);", " ", "     if (blit_is_unsafe(s, false))", "         return 0;", " ", "     (*s->cirrus_rop) (s, dst, src,", "                       s->cirrus_blt_dstpitch, 0,", "                       s->cirrus_blt_width, s->cirrus_blt_height);", "     cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,", "                              s->cirrus_blt_dstpitch, s->cirrus_blt_width,", "                              s->cirrus_blt_height);", "     return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,", " \t\t\t    int bpf_size, enum bpf_access_type t,", " \t\t\t    int value_regno)", " {", " \tstruct bpf_verifier_state *state = env->cur_state;", " \tstruct bpf_reg_state *regs = cur_regs(env);", " \tstruct bpf_reg_state *reg = regs + regno;", " \tint size, err = 0;", " ", " \tsize = bpf_size_to_bytes(bpf_size);", " \tif (size < 0)", " \t\treturn size;", " ", " \t ", " \terr = check_ptr_alignment(env, reg, off, size);", " \tif (err)", " \t\treturn err;", " ", " \t ", " \toff += reg->off;", " ", " \tif (reg->type == PTR_TO_MAP_VALUE) {", " \t\tif (t == BPF_WRITE && value_regno >= 0 &&", " \t\t    is_pointer_value(env, value_regno)) {", " \t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);", " \t\t\treturn -EACCES;", " \t\t}", " ", " \t\terr = check_map_access(env, regno, off, size, false);", " \t\tif (!err && t == BPF_READ && value_regno >= 0)", " \t\t\tmark_reg_unknown(env, regs, value_regno);", " ", " \t} else if (reg->type == PTR_TO_CTX) {", " \t\tenum bpf_reg_type reg_type = SCALAR_VALUE;", " ", " \t\tif (t == BPF_WRITE && value_regno >= 0 &&", " \t\t    is_pointer_value(env, value_regno)) {", " \t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);", " \t\t\treturn -EACCES;", " \t\t}", " \t\t ", " \t\tif (reg->off) {", " \t\t\tverbose(env,", " \t\t\t\t\"dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\\n\",", " \t\t\t\tregno, reg->off, off - reg->off);", " \t\t\treturn -EACCES;", " \t\t}", " \t\tif (!tnum_is_const(reg->var_off) || reg->var_off.value) {", " \t\t\tchar tn_buf[48];", " ", " \t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);", " \t\t\tverbose(env,", " \t\t\t\t\"variable ctx access var_off=%s off=%d size=%d\",", " \t\t\t\ttn_buf, off, size);", " \t\t\treturn -EACCES;", " \t\t}", " \t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type);", " \t\tif (!err && t == BPF_READ && value_regno >= 0) {", " \t\t\t ", " \t\t\tif (reg_type == SCALAR_VALUE)", " \t\t\t\tmark_reg_unknown(env, regs, value_regno);", " \t\t\telse", " \t\t\t\tmark_reg_known_zero(env, regs,", " \t\t\t\t\t\t    value_regno);", " \t\t\tregs[value_regno].id = 0;", " \t\t\tregs[value_regno].off = 0;", " \t\t\tregs[value_regno].range = 0;", " \t\t\tregs[value_regno].type = reg_type;", " \t\t}", " ", " \t} else if (reg->type == PTR_TO_STACK) {", " \t\t ", " \t\tif (!tnum_is_const(reg->var_off)) {", " \t\t\tchar tn_buf[48];", " ", " \t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);", " \t\t\tverbose(env, \"variable stack access var_off=%s off=%d size=%d\",", " \t\t\t\ttn_buf, off, size);", " \t\t\treturn -EACCES;", " \t\t}", " \t\toff += reg->var_off.value;", " \t\tif (off >= 0 || off < -MAX_BPF_STACK) {", " \t\t\tverbose(env, \"invalid stack off=%d size=%d\\n\", off,", " \t\t\t\tsize);", " \t\t\treturn -EACCES;", " \t\t}", " ", " \t\tif (env->prog->aux->stack_depth < -off)", " \t\t\tenv->prog->aux->stack_depth = -off;", " ", " \t\tif (t == BPF_WRITE)", " \t\t\terr = check_stack_write(env, state, off, size,", " \t\t\t\t\t\tvalue_regno);", " \t\telse", " \t\t\terr = check_stack_read(env, state, off, size,", " \t\t\t\t\t       value_regno);", " \t} else if (reg_is_pkt_pointer(reg)) {", " \t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {", " \t\t\tverbose(env, \"cannot write into packet\\n\");", " \t\t\treturn -EACCES;", " \t\t}", " \t\tif (t == BPF_WRITE && value_regno >= 0 &&", " \t\t    is_pointer_value(env, value_regno)) {", " \t\t\tverbose(env, \"R%d leaks addr into packet\\n\",", " \t\t\t\tvalue_regno);", " \t\t\treturn -EACCES;", " \t\t}", " \t\terr = check_packet_access(env, regno, off, size, false);", " \t\tif (!err && t == BPF_READ && value_regno >= 0)", " \t\t\tmark_reg_unknown(env, regs, value_regno);", " \t} else {", " \t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,", " \t\t\treg_type_str[reg->type]);", " \t\treturn -EACCES;", " \t}", " ", "  \tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&", "  \t    regs[value_regno].type == SCALAR_VALUE) {", "  \t\t ", "\t\tregs[value_regno].var_off =", "\t\t\ttnum_cast(regs[value_regno].var_off, size);", "\t\t__update_reg_bounds(&regs[value_regno]);", " \t\tcoerce_reg_to_size(&regs[value_regno], size);", "  \t}", "  \treturn err;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {", "     int len = 0, l;", "     int c;", "     int count = 0;", " ", " #ifdef DEBUG", "     nbParseNCNameComplex++;", " #endif", " ", "      ", "     GROW;", "     c = CUR_CHAR(l);", "     if ((c == ' ') || (c == '>') || (c == '/') ||  ", " \t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {", " \treturn(NULL);", "     }", " ", "     while ((c != ' ') && (c != '>') && (c != '/') &&  ", " \t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {", "  \tif (count++ > 100) {", "  \t    count = 0;", "  \t    GROW;", "             if (ctxt->instate == XML_PARSER_EOF)", "                 return(NULL);", "  \t}", "  \tlen += l;", "  \tNEXTL(l);", " \tc = CUR_CHAR(l);", "     }", "     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int init_nss_hash(struct crypto_instance *instance)", " {", " \tPK11SlotInfo*\thash_slot = NULL;", " \tSECItem\t\thash_param;", " ", " \tif (!hash_to_nss[instance->crypto_hash_type]) {", " \t\treturn 0;", "  \t}", "  ", "  \thash_param.type = siBuffer;", "\thash_param.data = 0;", "\thash_param.len = 0;", " \thash_param.data = instance->private_key;", " \thash_param.len = instance->private_key_len;", "  ", "  \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);", "  \tif (hash_slot == NULL) {", " \t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",", " \t\t\t   PR_GetError());", " \t\treturn -1;", " \t}", " ", " \tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,", " \t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],", " \t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,", " \t\t\t\t\t\t       &hash_param, NULL);", " \tif (instance->nss_sym_key_sign == NULL) {", " \t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",", " \t\t\t   PR_GetError());", " \t\treturn -1;", " \t}", " ", " \tPK11_FreeSlot(hash_slot);", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool LauncherView::IsShowingMenu() const {", "  #if !defined(OS_MACOSX)", "  return (overflow_menu_runner_.get() &&", "          overflow_menu_runner_->IsRunning()) ||", "      (launcher_menu_runner_.get() &&", "   return (launcher_menu_runner_.get() &&", "         launcher_menu_runner_->IsRunning());", "  #endif", "    return false;", "  }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  cosine_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr,", "  \tBuffer *buf, int *err, gchar **err_info)", "  {", "\tint\tpkt_len;", "  \tchar\tline[COSINE_LINE_LENGTH];", "  ", "  \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)", " \t\treturn FALSE;", " ", " \tif (file_gets(line, COSINE_LINE_LENGTH, wth->random_fh) == NULL) {", " \t\t*err = file_error(wth->random_fh, err_info);", " \t\tif (*err == 0) {", " \t\t\t*err = WTAP_ERR_SHORT_READ;", " \t\t}", "  \t\treturn FALSE;", "  \t}", "  ", " \t ", "\tpkt_len = parse_cosine_rec_hdr(phdr, line, err, err_info);", "\tif (pkt_len == -1)", "\t\treturn FALSE;", "\t ", "\treturn parse_cosine_hex_dump(wth->random_fh, phdr, pkt_len, buf, err,", " \treturn parse_cosine_packet(wth->random_fh, phdr, buf, line, err,", "  \t    err_info);", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" nfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)", " {", "  \tp = decode_fh(p, &args->fh);", "  \tif (!p)", "  \t\treturn 0;", " \tif (!xdr_argsize_check(rqstp, p))", " \t\treturn 0;", "  \targs->buffer = page_address(*(rqstp->rq_next_page++));", "  ", "\treturn xdr_argsize_check(rqstp, p);", " \treturn 1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0]}
{"tokens": [" static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){", "     long i;", " #if !HAVE_FAST_UNALIGNED", "     if((long)src2 & (sizeof(long)-1)){", "         for(i=0; i+7<w; i+=8){", "             dst[i+0] = src1[i+0]-src2[i+0];", "             dst[i+1] = src1[i+1]-src2[i+1];", "             dst[i+2] = src1[i+2]-src2[i+2];", "             dst[i+3] = src1[i+3]-src2[i+3];", "             dst[i+4] = src1[i+4]-src2[i+4];", "             dst[i+5] = src1[i+5]-src2[i+5];", "             dst[i+6] = src1[i+6]-src2[i+6];", "             dst[i+7] = src1[i+7]-src2[i+7];", "          }", "      }else", "  #endif", "    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){", "     for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){", "          long a = *(long*)(src1+i);", "          long b = *(long*)(src2+i);", "          *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);", "     }", "     for(; i<w; i++)", "         dst[i+0] = src1[i+0]-src2[i+0];", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" linkaddr_string(netdissect_options *ndo, const u_char *ep,", " \t\tconst unsigned int type, const unsigned int len)", "  {", "  \tregister u_int i;", "  \tregister char *cp;", "\tregister struct enamemem *tp;", " \tregister struct bsnamemem *tp;", "  ", "  \tif (len == 0)", "  \t\treturn (\"<empty>\");", " ", " \tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)", " \t\treturn (etheraddr_string(ndo, ep));", " ", " \tif (type == LINKADDR_FRELAY)", "  \t\treturn (q922_string(ndo, ep, len));", "  ", "  \ttp = lookup_bytestring(ndo, ep, len);", "\tif (tp->e_name)", "\t\treturn (tp->e_name);", " \tif (tp->bs_name)", " \t\treturn (tp->bs_name);", "  ", "\ttp->e_name = cp = (char *)malloc(len*3);", "\tif (tp->e_name == NULL)", " \ttp->bs_name = cp = (char *)malloc(len*3);", " \tif (tp->bs_name == NULL)", "  \t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");", "  \t*cp++ = hex[*ep >> 4];", "  \t*cp++ = hex[*ep++ & 0xf];", " \tfor (i = len-1; i > 0 ; --i) {", " \t\t*cp++ = ':';", " \t\t*cp++ = hex[*ep >> 4];", "  \t\t*cp++ = hex[*ep++ & 0xf];", "  \t}", "  \t*cp = '\\0';", "\treturn (tp->e_name);", " \treturn (tp->bs_name);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["getlogin_r (name, name_len)", "char *name;", "size_t name_len;", "{", "char tty_pathname[2 + 2 * NAME_MAX];", "char *real_tty_path = tty_pathname;", "int result = 0;", "struct utmp *ut, line, buffer;", "", "{", "int d = __open (\"/dev/tty\", 0);", "if (d < 0)", "return errno;", "", "result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));", "(void) __close (d);", "", "if (result != 0)", "{", "__set_errno (result);", "return result;", "}", "}", "", "real_tty_path += 5;", "", "__setutent ();", "strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);", "if (__getutline_r (&line, &buffer, &ut) < 0)", "{", "if (errno == ESRCH)", "", "result = ENOENT;", "else", "result = errno;", "}", "else", "{", "size_t needed = strlen (ut->ut_line) + 1;", "", "if (needed < name_len)", "{", "__set_errno (ERANGE);", "result = ERANGE;", "}", "else", "{", "memcpy (name, ut->ut_line, needed);", "result = 0;", "}", "}", "__endutent ();", "", "return result;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["char *url_canonize2(char *d, char const * const s, size_t n,", "unsigned syn33,", "unsigned m32, unsigned m64, unsigned m96)", "{", "size_t i = 0;", "", "if (d == s)", "for (;s[i] && i < n; d++, i++)", "if (s[i] == '%')", "break;", "", "for (;s[i] && i < n; d++, i++) {", "unsigned char c = s[i], h1, h2;", "", "if (c != '%') {", "if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))", "return NULL;", "*d = c;", "continue;", "}", "", "h1 = s[i + 1], h2 = s[i + 2];", "", "if (!IS_HEX(h1) || !IS_HEX(h2)) {", "*d = '\\0';", "return NULL;", "}", "", "#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))", "c = (UNHEX(h1) << 4) | UNHEX(h2);", "", "if (!IS_EXCLUDED(c, m32, m64, m96)) {", "", "*d = c, i += 2;", "continue;", "}", "", "", "if (h1 >= 'a'                   )", "h1 = h1 - 'a' + 'A';", "if (h2 >= 'a'                   )", "h2 = h2 - 'a' + 'A';", "", "d[0] = '%', d[1] = h1, d[2] = h2;", "", "d +=2, i += 2;", "#undef    UNHEX", "}", "", "*d = '\\0';", "", "return d;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,", "   const ImageInfo *image_info,Image *image,Image *next_image,", "   const MagickBooleanType separate,ExceptionInfo *exception)", " {", "   size_t", "     channels,", "     packet_size;", " ", "   unsigned char", "     *compact_pixels;", " ", "    ", "   channels=1;", "   packet_size=next_image->depth > 8UL ? 2UL : 1UL;", "    compact_pixels=(unsigned char *) NULL;", "    if (next_image->compression == RLECompression)", "      {", "      compact_pixels=(unsigned char *) AcquireQuantumMemory(2*channels*", "        next_image->columns,packet_size*sizeof(*compact_pixels));", "       compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*", "         next_image->columns)+1,packet_size*sizeof(*compact_pixels));", "        if (compact_pixels == (unsigned char *) NULL)", "          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "      }", "   if (IsImageGray(next_image) != MagickFalse)", "     {", "       if (next_image->compression == RLECompression)", "         {", "            ", "           (void) WriteBlobMSBShort(image,1);", "           WritePackbitsLength(psd_info,image_info,image,next_image,", "             compact_pixels,GrayQuantum,exception);", "           if (next_image->alpha_trait != UndefinedPixelTrait)", "             WritePackbitsLength(psd_info,image_info,image,next_image,", "               compact_pixels,AlphaQuantum,exception);", "         }", "       WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "         GrayQuantum,MagickTrue,exception);", "       if (next_image->alpha_trait != UndefinedPixelTrait)", "         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "           AlphaQuantum,separate,exception);", "       (void) SetImageProgress(image,SaveImagesTag,0,1);", "     }", "   else", "     if (next_image->storage_class == PseudoClass)", "       {", "         if (next_image->compression == RLECompression)", "           {", "              ", "             (void) WriteBlobMSBShort(image,1);", "             WritePackbitsLength(psd_info,image_info,image,next_image,", "               compact_pixels,IndexQuantum,exception);", "             if (next_image->alpha_trait != UndefinedPixelTrait)", "               WritePackbitsLength(psd_info,image_info,image,next_image,", "                 compact_pixels,AlphaQuantum,exception);", "           }", "         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "           IndexQuantum,MagickTrue,exception);", "         if (next_image->alpha_trait != UndefinedPixelTrait)", "           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "             AlphaQuantum,separate,exception);", "         (void) SetImageProgress(image,SaveImagesTag,0,1);", "       }", "     else", "       {", "         if (next_image->colorspace == CMYKColorspace)", "           (void) NegateCMYK(next_image,exception);", "         if (next_image->compression == RLECompression)", "           {", "              ", "             (void) WriteBlobMSBShort(image,1);", "             WritePackbitsLength(psd_info,image_info,image,next_image,", "               compact_pixels,RedQuantum,exception);", "             WritePackbitsLength(psd_info,image_info,image,next_image,", "               compact_pixels,GreenQuantum,exception);", "             WritePackbitsLength(psd_info,image_info,image,next_image,", "               compact_pixels,BlueQuantum,exception);", "             if (next_image->colorspace == CMYKColorspace)", "               WritePackbitsLength(psd_info,image_info,image,next_image,", "                 compact_pixels,BlackQuantum,exception);", "             if (next_image->alpha_trait != UndefinedPixelTrait)", "               WritePackbitsLength(psd_info,image_info,image,next_image,", "                 compact_pixels,AlphaQuantum,exception);", "           }", "         (void) SetImageProgress(image,SaveImagesTag,0,6);", "         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "           RedQuantum,MagickTrue,exception);", "         (void) SetImageProgress(image,SaveImagesTag,1,6);", "         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "           GreenQuantum,separate,exception);", "         (void) SetImageProgress(image,SaveImagesTag,2,6);", "         WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "           BlueQuantum,separate,exception);", "         (void) SetImageProgress(image,SaveImagesTag,3,6);", "         if (next_image->colorspace == CMYKColorspace)", "           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "             BlackQuantum,separate,exception);", "         (void) SetImageProgress(image,SaveImagesTag,4,6);", "         if (next_image->alpha_trait != UndefinedPixelTrait)", "           WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels,", "             AlphaQuantum,separate,exception);", "         (void) SetImageProgress(image,SaveImagesTag,5,6);", "         if (next_image->colorspace == CMYKColorspace)", "           (void) NegateCMYK(next_image,exception);", "       }", "   if (next_image->compression == RLECompression)", "     compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "const Tensor& in_grads = context->input(0);", "const Tensor& in_image = context->input(1);", "const Tensor& out_image = context->input(2);", "", "OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,", "errors::InvalidArgument(\"inputs must be 4-dimensional\"));", "const int64_t batch = in_grads.dim_size(0);", "const int64_t rows = in_grads.dim_size(1);", "const int64_t cols = in_grads.dim_size(2);", "const int64_t depth = in_grads.dim_size(3);", "OP_REQUIRES(", "context,", "in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&", "in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&", "out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&", "out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,", "errors::InvalidArgument(", "\"input_grads, input_image, and out_image should have the same \"", "\"shape\"));", "", "Tensor* output = nullptr;", "OP_REQUIRES_OK(context,", "context->allocate_output(", "0, TensorShape({batch, rows, cols, depth}), &output));", "", "LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);", "launcher.launch(context, this, in_grads, in_image, out_image, output);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["const char * util_acl_to_str(const sc_acl_entry_t *e)", "{", "static char line[80], buf[20];", "unsigned int acl;", "", "if (e == NULL)", "return \"N/A\";", "line[0] = 0;", "while (e != NULL) {", "acl = e->method;", "", "switch (acl) {", "case SC_AC_UNKNOWN:", "return \"N/A\";", "case SC_AC_NEVER:", "return \"NEVR\";", "case SC_AC_NONE:", "return \"NONE\";", "case SC_AC_CHV:", "strcpy(buf, \"CHV\");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"%d\", e->key_ref);", "break;", "case SC_AC_TERM:", "strcpy(buf, \"TERM\");", "break;", "case SC_AC_PRO:", "strcpy(buf, \"PROT\");", "break;", "case SC_AC_AUT:", "strcpy(buf, \"AUTH\");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 4, \"%d\", e->key_ref);", "break;", "case SC_AC_SEN:", "strcpy(buf, \"Sec.Env. \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"#%d\", e->key_ref);", "break;", "case SC_AC_SCB:", "strcpy(buf, \"Sec.ControlByte \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"Ox%X\", e->key_ref);", "break;", "case SC_AC_IDA:", "strcpy(buf, \"PKCS#15 AuthID \");", "if (e->key_ref != SC_AC_KEY_REF_NONE)", "sprintf(buf + 3, \"#%d\", e->key_ref);", "break;", "default:", "strcpy(buf, \"????\");", "break;", "}", "strcat(line, buf);", "strcat(line, \" \");", "e = e->next;", "}", "line[strlen(line)-1] = 0;", "return line;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": [" void TypingCommand::insertText(Document& document,", "                                const String& text,", "                                Options options,", "                                TextCompositionType composition,", "                                const bool isIncrementalInsertion) {", "   LocalFrame* frame = document.frame();", "   DCHECK(frame);", " ", "   if (!text.isEmpty())", "      document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(", "          isSpaceOrNewline(text[0]));", "  ", "  insertText(document, text,", "             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),", "             options, composition, isIncrementalInsertion);", "   insertText(document, text, frame->selection().selectionInDOMTree(), options,", "              composition, isIncrementalInsertion);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": [" void PageSerializer::serializeFrame(Frame* frame)", " {", "     Document* document = frame->document();", "     KURL url = document->url();", "     if (!url.isValid() || url.isBlankURL()) {", "         url = urlForBlankFrame(frame);", "     }", " ", "     if (m_resourceURLs.contains(url)) {", "          return;", "      }", "  ", "    if (document->isImageDocument()) {", "        ImageDocument* imageDocument = toImageDocument(document);", "        addImageToResources(imageDocument->cachedImage(), imageDocument->imageElement()->renderer(), url);", "        return;", "    }", "      Vector<Node*> nodes;", "    OwnPtr<SerializerMarkupAccumulator> accumulator;", "    if (m_URLs)", "        accumulator = adoptPtr(new LinkChangeSerializerMarkupAccumulator(this, document, &nodes, m_URLs, m_directory));", "    else", "        accumulator = adoptPtr(new SerializerMarkupAccumulator(this, document, &nodes));", "    String text = accumulator->serializeNodes(document, IncludeNode);", "     SerializerMarkupAccumulator accumulator(this, document, &nodes);", "      WTF::TextEncoding textEncoding(document->charset());", "     CString data;", "     if (!textEncoding.isValid()) {", "          ", "         return;", "     }", "     String text = accumulator.serializeNodes(document, IncludeNode);", "      CString frameHTML = textEncoding.normalizeAndEncode(text, WTF::EntitiesForUnencodables);", "      m_resources->append(SerializedResource(url, document->suggestedMIMEType(), SharedBuffer::create(frameHTML.data(), frameHTML.length())));", "      m_resourceURLs.add(url);", " ", "     for (Vector<Node*>::iterator iter = nodes.begin(); iter != nodes.end(); ++iter) {", "         Node* node = *iter;", "         if (!node->isElementNode())", "             continue;", "  ", "          Element* element = toElement(node);", "        if (element->isStyledElement()) {", "         if (element->isStyledElement())", "              retrieveResourcesForProperties(element->inlineStyle(), document);", "            retrieveResourcesForProperties(element->presentationAttributeStyle(), document);", "        }", "  ", "          if (element->hasTagName(HTMLNames::imgTag)) {", "              HTMLImageElement* imageElement = toHTMLImageElement(element);", "             KURL url = document->completeURL(imageElement->getAttribute(HTMLNames::srcAttr));", "             ImageResource* cachedImage = imageElement->cachedImage();", "             addImageToResources(cachedImage, imageElement->renderer(), url);", "         } else if (element->hasTagName(HTMLNames::inputTag)) {", "             HTMLInputElement* inputElement = toHTMLInputElement(element);", "             if (inputElement->isImageButton() && inputElement->hasImageLoader()) {", "                 KURL url = inputElement->src();", "                 ImageResource* cachedImage = inputElement->imageLoader()->image();", "                 addImageToResources(cachedImage, inputElement->renderer(), url);", "             }", "         } else if (element->hasTagName(HTMLNames::linkTag)) {", "             HTMLLinkElement* linkElement = toHTMLLinkElement(element);", "             if (CSSStyleSheet* sheet = linkElement->sheet()) {", "                 KURL url = document->completeURL(linkElement->getAttribute(HTMLNames::hrefAttr));", "                 serializeCSSStyleSheet(sheet, url);", "                 ASSERT(m_resourceURLs.contains(url));", "             }", "         } else if (element->hasTagName(HTMLNames::styleTag)) {", "             HTMLStyleElement* styleElement = toHTMLStyleElement(element);", "             if (CSSStyleSheet* sheet = styleElement->sheet())", "                 serializeCSSStyleSheet(sheet, KURL());", "         }", "     }", " ", "     for (Frame* childFrame = frame->tree().firstChild(); childFrame; childFrame = childFrame->tree().nextSibling())", "         serializeFrame(childFrame);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static ssize_t aio_setup_single_vector(struct kiocb *kiocb)", " static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)", "  {", " \tint bytes;", " ", " \tbytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);", " \tif (bytes < 0)", " \t\treturn bytes;", " ", "  \tkiocb->ki_iovec = &kiocb->ki_inline_vec;", "  \tkiocb->ki_iovec->iov_base = kiocb->ki_buf;", "\tkiocb->ki_iovec->iov_len = kiocb->ki_left;", " \tkiocb->ki_iovec->iov_len = bytes;", "  \tkiocb->ki_nr_segs = 1;", "  \tkiocb->ki_cur_seg = 0;", "  \treturn 0;", " }"], "ner_tags": [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,", "const TfLiteTensor* input,", "const TfLiteTensor* size_splits,", "const TfLiteTensor* axis) {", "int axis_value = GetTensorData<int>(axis)[0];", "if (axis_value < 0) {", "axis_value += NumDimensions(input);", "}", "", "std::vector<int64_t> size_splits_vector;", "if (size_splits->type == kTfLiteInt32) {", "GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);", "} else if (size_splits->type == kTfLiteInt64) {", "GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);", "} else {", "context->ReportError(context, \"size_splits only support type int32|int64.\");", "return kTfLiteError;", "}", "", "int minus_one_index = -1;", "int64_t size_splits_sum = 0;", "", "for (int i = 0; i < size_splits_vector.size(); ++i) {", "if (size_splits_vector.at(i) == -1) {", "if (minus_one_index == -1) {", "minus_one_index = i;", "} else {", "context->ReportError(context,", "\"The size_splits contains more than one -1.\");", "}", "} else {", "size_splits_sum += size_splits_vector.at(i);", "}", "}", "", "const int input_size = SizeOfDimension(input, axis_value);", "", "if (minus_one_index != -1) {", "if (size_splits_sum > input_size) {", "context->ReportError(", "context,", "\"The sum of size_splits must be less than the dimension of value.\");", "} else {", "size_splits_vector[minus_one_index] = input_size - size_splits_sum;", "}", "} else if (size_splits_sum != input_size) {", "context->ReportError(", "context,", "\"The size_splits must sum to the dimension of value along axis.\");", "}", "", "for (int i = 0; i < NumOutputs(node); ++i) {", "TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);", "output_dims->data[axis_value] = size_splits_vector.at(i);", "TfLiteTensor* output;", "TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));", "TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));", "}", "", "return kTfLiteOk;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,", "u8 event, struct sk_buff *skb)", "{", "int r = 0;", "struct device *dev = &hdev->ndev->dev;", "struct nfc_evt_transaction *transaction;", "", "pr_debug(\"connectivity gate event: %x\\n\", event);", "", "switch (event) {", "case ST21NFCA_EVT_CONNECTIVITY:", "r = nfc_se_connectivity(hdev->ndev, host);", "break;", "case ST21NFCA_EVT_TRANSACTION:", "", "", "", "", "", "", "", "if (skb->len < NFC_MIN_AID_LENGTH + 2 &&", "skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)", "return -EPROTO;", "", "transaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);", "if (!transaction)", "return -ENOMEM;", "", "transaction->aid_len = skb->data[1];", "memcpy(transaction->aid, &skb->data[2],", "transaction->aid_len);", "", "", "if (skb->data[transaction->aid_len + 2] !=", "NFC_EVT_TRANSACTION_PARAMS_TAG)", "return -EPROTO;", "", "transaction->params_len = skb->data[transaction->aid_len + 3];", "memcpy(transaction->params, skb->data +", "transaction->aid_len + 4, transaction->params_len);", "", "r = nfc_se_transaction(hdev->ndev, host, transaction);", "break;", "default:", "nfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");", "return 1;", "}", "kfree_skb(skb);", "return r;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  base::string16 GetAppForProtocolUsingAssocQuery(const GURL& url) {", "  base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());", "  if (url_scheme.empty())", "   const base::string16 url_scheme = base::ASCIIToUTF16(url.scheme());", "   if (!IsValidCustomProtocol(url_scheme))", "      return base::string16();", "  ", "    wchar_t out_buffer[1024];", "    DWORD buffer_size = arraysize(out_buffer);", "  HRESULT hr = AssocQueryString(ASSOCF_IS_PROTOCOL,", "                                ASSOCSTR_FRIENDLYAPPNAME,", "                                url_scheme.c_str(),", "                                NULL,", "                                out_buffer,", "                                &buffer_size);", "   HRESULT hr =", "       AssocQueryString(ASSOCF_IS_PROTOCOL, ASSOCSTR_FRIENDLYAPPNAME,", "                        url_scheme.c_str(), NULL, out_buffer, &buffer_size);", "    if (FAILED(hr)) {", "      DLOG(WARNING) << \"AssocQueryString failed!\";", "      return base::string16();", "   }", "   return base::string16(out_buffer);", "  }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void singlevar (LexState *ls, expdesc *var) {", "TString *varname = str_checkname(ls);", "FuncState *fs = ls->fs;", "singlevaraux(fs, varname, var, 1);", "if (var->k == VVOID) {", "expdesc key;", "singlevaraux(fs, ls->envn, var, 1);", "lua_assert(var->k != VVOID);", "codestring(&key, varname);", "luaK_indexed(fs, var, &key);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)", "{", "int rc;", "unsigned char key2[8];", "struct crypto_skcipher *tfm_des;", "struct scatterlist sgin, sgout;", "struct skcipher_request *req;", "", "str_to_key(key, key2);", "", "tfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);", "if (IS_ERR(tfm_des)) {", "rc = PTR_ERR(tfm_des);", "cifs_dbg(VFS, \"could not allocate des crypto API\\n\");", "goto smbhash_err;", "}", "", "req = skcipher_request_alloc(tfm_des, GFP_KERNEL);", "if (!req) {", "rc = -ENOMEM;", "cifs_dbg(VFS, \"could not allocate des crypto API\\n\");", "goto smbhash_free_skcipher;", "}", "", "crypto_skcipher_setkey(tfm_des, key2, 8);", "", "sg_init_one(&sgin, in, 8);", "sg_init_one(&sgout, out, 8);", "", "skcipher_request_set_callback(req, 0, NULL, NULL);", "skcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);", "", "rc = crypto_skcipher_encrypt(req);", "if (rc)", "cifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);", "", "skcipher_request_free(req);", "", "smbhash_free_skcipher:", "crypto_free_skcipher(tfm_des);", "smbhash_err:", "return rc;", "}"], "ner_tags": [0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0]}
{"tokens": ["free_link_refs(struct link_ref **references)", "{", "size_t i;", "", "for (i = 0; i < REF_TABLE_SIZE; ++i) {", "struct link_ref *r = references[i];", "struct link_ref *next;", "", "while (r) {", "next = r->next;", "bufrelease(r->link);", "bufrelease(r->title);", "free(r);", "r = next;", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void PropertyTreeManager::SetupRootTransformNode() {", "   cc::TransformTree& transform_tree = property_trees_.transform_tree;", "   transform_tree.clear();", "   property_trees_.element_id_to_transform_node_index.clear();", "   cc::TransformNode& transform_node = *transform_tree.Node(", "       transform_tree.Insert(cc::TransformNode(), kRealRootNodeId));", "   DCHECK_EQ(transform_node.id, kSecondaryRootNodeId);", "   transform_node.source_node_id = transform_node.parent_id;", " ", "   float device_scale_factor =", "       root_layer_->layer_tree_host()->device_scale_factor();", "   gfx::Transform to_screen;", "   to_screen.Scale(device_scale_factor, device_scale_factor);", "   transform_tree.SetToScreen(kRealRootNodeId, to_screen);", "   gfx::Transform from_screen;", "   bool invertible = to_screen.GetInverse(&from_screen);", "   DCHECK(invertible);", "    transform_tree.SetFromScreen(kRealRootNodeId, from_screen);", "    transform_tree.set_needs_update(true);", "  ", "  transform_node_map_.Set(TransformPaintPropertyNode::Root(),", "   transform_node_map_.Set(&TransformPaintPropertyNode::Root(),", "                            transform_node.id);", "    root_layer_->SetTransformTreeIndex(transform_node.id);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["static void rose_idletimer_expiry(struct timer_list *t)", "{", "struct rose_sock *rose = from_timer(rose, t, idletimer);", "struct sock *sk = &rose->sock;", "", "bh_lock_sock(sk);", "rose_clear_queues(sk);", "", "rose_write_internal(sk, ROSE_CLEAR_REQUEST);", "rose_sk(sk)->state = ROSE_STATE_2;", "", "rose_start_t3timer(sk);", "", "sk->sk_state     = TCP_CLOSE;", "sk->sk_err       = 0;", "sk->sk_shutdown |= SEND_SHUTDOWN;", "", "if (!sock_flag(sk, SOCK_DEAD)) {", "sk->sk_state_change(sk);", "sock_set_flag(sk, SOCK_DEAD);", "}", "bh_unlock_sock(sk);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)", " static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,", "   int pixel_size,ExceptionInfo *exception)", "  {", "    MagickOffsetType", "      offset;", " ", "   register ssize_t", "     i;", " ", "   size_t", "     h,", "     w;", " ", "    ", "   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP", "        && (dds_info->ddscaps1 & DDSCAPS_TEXTURE", "            || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))", "      {", "       if (EOFBlob(image) != MagickFalse)", "         {", "           ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "             image->filename);", "           return(MagickFalse);", "         }", "        w = DIV2(dds_info->width);", "        h = DIV2(dds_info->height);", "  ", "        ", "       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)", "       {", "         offset = (MagickOffsetType) w * h * pixel_size;", "         (void) SeekBlob(image, offset, SEEK_CUR);", " ", "         w = DIV2(w);", "          h = DIV2(h);", "        }", "      }", "   return(MagickTrue);", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["  void ForeignSessionHelper::TriggerSessionSync(", "      JNIEnv* env,", "      const JavaParamRef<jobject>& obj) {", "  browser_sync::ProfileSyncService* service =", "      ProfileSyncServiceFactory::GetInstance()->GetForProfile(profile_);", "   syncer::SyncService* service =", "       ProfileSyncServiceFactory::GetSyncServiceForProfile(profile_);", "    if (!service)", "      return;", "  ", "  const syncer::ModelTypeSet types(syncer::SESSIONS);", "  service->TriggerRefresh(types);", "   service->TriggerRefresh({syncer::SESSIONS});", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" void ContainerNode::removeChildren()", " {", "     if (!m_firstChild)", "         return;", " ", "     RefPtr<ContainerNode> protect(this);", " ", "     if (FullscreenElementStack* fullscreen = FullscreenElementStack::fromIfExists(&document()))", "         fullscreen->removeFullScreenElementOfSubtree(this, true);", " ", "     willRemoveChildren(protect.get());", " ", "     {", "         SubframeLoadingDisabler disabler(this);", " ", "          document().removeFocusedElementOfSubtree(this, true);", "      }", "  ", "     document().nodeChildrenWillBeRemoved(this);", " ", "      NodeVector removedChildren;", "      {", "          RenderWidget::UpdateSuspendScope suspendWidgetHierarchyUpdates;", "         {", "             NoEventDispatchAssertion assertNoEventDispatch;", "             removedChildren.reserveInitialCapacity(childNodeCount());", "             while (m_firstChild) {", "                 removedChildren.append(m_firstChild);", "                 removeBetween(0, m_firstChild->nextSibling(), m_firstChild);", "             }", "         }", " ", "         childrenChanged(false, 0, 0, -static_cast<int>(removedChildren.size()));", " ", "         for (size_t i = 0; i < removedChildren.size(); ++i)", "             ChildNodeRemovalNotifier(this).notify(removedChildren[i].get());", "     }", " ", "     dispatchSubtreeModifiedEvent();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["     virtual void runTest()", "     void runTest()", "      {", "        if (m_settings.enableCompositorThread)", "            CCLayerTreeHostTest::runTest();", "         CCLayerTreeHostTest::runTest(true);", "      }"], "ner_tags": [0, 1, 0, 1, 1, 1, 0]}
{"tokens": [" long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,", "  long long size) {", "  const long long stop = pos + size;", " ", "  while (pos < stop) {", "  long long id, size;", " ", "  long status = ParseElementHeader(pReader, pos, stop, id, size);", " ", "  if (status < 0)  ", "  return status;", " ", "  if (size == 0)  ", "  continue;", " ", "  if (id == 0x36) {  ", "       status = ParseAtom(pReader, pos, size);", " ", "  if (status < 0)  ", "  return status;", " ", "      }", "  ", "      pos += size;", "    assert(pos <= stop);", "     if (pos > stop)", "       return E_FILE_FORMAT_INVALID;", "    }", "  ", "  assert(pos == stop);", "   if (pos != stop)", "     return E_FILE_FORMAT_INVALID;", "    return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["PJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf *vid_conf,", "pj_pool_t *parent_pool,", "pjmedia_port *port,", "const pj_str_t *name,", "void *opt,", "unsigned *p_slot)", "{", "pj_pool_t *pool;", "vconf_port *cport;", "unsigned index;", "", "PJ_ASSERT_RETURN(vid_conf && parent_pool && port, PJ_EINVAL);", "PJ_ASSERT_RETURN(port->info.fmt.type==PJMEDIA_TYPE_VIDEO &&", "port->info.fmt.detail_type==PJMEDIA_FORMAT_DETAIL_VIDEO,", "PJ_EINVAL);", "PJ_UNUSED_ARG(opt);", "", "", "if (!name)", "name = &port->info.name;", "", "pj_mutex_lock(vid_conf->mutex);", "", "if (vid_conf->port_cnt >= vid_conf->opt.max_slot_cnt) {", "pj_assert(!\"Too many ports\");", "pj_mutex_unlock(vid_conf->mutex);", "return PJ_ETOOMANY;", "}", "", "", "for (index=0; index < vid_conf->opt.max_slot_cnt; ++index) {", "if (vid_conf->ports[index] == NULL)", "break;", "}", "pj_assert(index != vid_conf->opt.max_slot_cnt);", "", "", "pool = pj_pool_create(parent_pool->factory, name->ptr, 500, 500, NULL);", "PJ_ASSERT_RETURN(pool, PJ_ENOMEM);", "", "", "cport = PJ_POOL_ZALLOC_T(pool, vconf_port);", "PJ_ASSERT_RETURN(cport, PJ_ENOMEM);", "", "", "cport->pool = pool;", "cport->port = port;", "cport->format = port->info.fmt;", "cport->idx  = index;", "pj_strdup_with_null(pool, &cport->name, name);", "", "", "{", "pjmedia_ratio *fps = &port->info.fmt.det.vid.fps;", "pj_uint32_t vconf_interval = (pj_uint32_t)", "(TS_CLOCK_RATE * 1.0 /", "vid_conf->opt.frame_rate);", "cport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /", "fps->num * fps->denum);", "", "", "if (cport->ts_interval < vconf_interval) {", "cport->ts_interval = vconf_interval;", "PJ_LOG(3,(THIS_FILE, \"Warning: frame rate of port %s is higher \"", "\"than video conference bridge (%d > %d)\",", "name->ptr, (int)(fps->num/fps->denum),", "vid_conf->opt.frame_rate));", "}", "}", "", "", "{", "const pjmedia_video_format_info *vfi;", "pjmedia_video_apply_fmt_param vafp;", "pj_status_t status;", "", "vfi = pjmedia_get_video_format_info(NULL, port->info.fmt.id);", "if (!vfi) {", "PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"", "\"unrecognized format %04X\",", "port->info.fmt.id));", "return PJMEDIA_EBADFMT;", "}", "", "pj_bzero(&vafp, sizeof(vafp));", "vafp.size = port->info.fmt.det.vid.size;", "status = (*vfi->apply_fmt)(vfi, &vafp);", "if (status != PJ_SUCCESS) {", "PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"", "\"Failed to apply format %04X\",", "port->info.fmt.id));", "return status;", "}", "if (port->put_frame) {", "cport->put_buf_size = vafp.framebytes;", "cport->put_buf = pj_pool_zalloc(cport->pool, cport->put_buf_size);", "}", "if (port->get_frame) {", "cport->get_buf_size = vafp.framebytes;", "cport->get_buf = pj_pool_zalloc(cport->pool, cport->get_buf_size);", "}", "}", "", "", "cport->listener_slots = (unsigned*)", "pj_pool_zalloc(pool,", "vid_conf->opt.max_slot_cnt *", "sizeof(unsigned));", "PJ_ASSERT_RETURN(cport->listener_slots, PJ_ENOMEM);", "", "", "cport->transmitter_slots = (unsigned*)", "pj_pool_zalloc(pool,", "vid_conf->opt.max_slot_cnt *", "sizeof(unsigned));", "PJ_ASSERT_RETURN(cport->transmitter_slots, PJ_ENOMEM);", "", "", "cport->render_states = (render_state**)", "pj_pool_zalloc(pool,", "vid_conf->opt.max_slot_cnt *", "sizeof(render_state*));", "PJ_ASSERT_RETURN(cport->render_states, PJ_ENOMEM);", "", "", "cport->render_pool = (pj_pool_t**)", "pj_pool_zalloc(pool,", "vid_conf->opt.max_slot_cnt *", "sizeof(pj_pool_t*));", "PJ_ASSERT_RETURN(cport->render_pool, PJ_ENOMEM);", "", "", "vid_conf->ports[index] = cport;", "vid_conf->port_cnt++;", "", "PJ_LOG(4,(THIS_FILE,\"Added port %d (%.*s)\",", "index, (int)cport->name.slen, cport->name.ptr));", "", "pj_mutex_unlock(vid_conf->mutex);", "", "", "if (p_slot) {", "*p_slot = index;", "}", "", "return PJ_SUCCESS;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE omx_vdec::update_portdef(OMX_PARAM_PORTDEFINITIONTYPE *portDefn)", " {", "     OMX_ERRORTYPE eRet = OMX_ErrorNone;", "  struct v4l2_format fmt;", "  if (!portDefn) {", "  return OMX_ErrorBadParameter;", " ", "      }", "      DEBUG_PRINT_LOW(\"omx_vdec::update_portdef\");", "      portDefn->nVersion.nVersion = OMX_SPEC_VERSION;", "    portDefn->nSize = sizeof(portDefn);", "     portDefn->nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE);", "      portDefn->eDomain    = OMX_PortDomainVideo;", "      if (drv_ctx.frame_rate.fps_denominator > 0)", "          portDefn->format.video.xFramerate = (drv_ctx.frame_rate.fps_numerator /", "             drv_ctx.frame_rate.fps_denominator) << 16;  ", "  else {", "         DEBUG_PRINT_ERROR(\"Error: Divide by zero\");", "  return OMX_ErrorBadParameter;", "  }", "     memset(&fmt, 0x0, sizeof(struct v4l2_format));", "  if (0 == portDefn->nPortIndex) {", "         portDefn->eDir =  OMX_DirInput;", "         portDefn->nBufferCountActual = drv_ctx.ip_buf.actualcount;", "         portDefn->nBufferCountMin    = drv_ctx.ip_buf.mincount;", "         portDefn->nBufferSize        = drv_ctx.ip_buf.buffer_size;", "         portDefn->format.video.eColorFormat = OMX_COLOR_FormatUnused;", "         portDefn->format.video.eCompressionFormat = eCompressionFormat;", "         portDefn->bEnabled   = m_inp_bEnabled;", "         portDefn->bPopulated = m_inp_bPopulated;", " ", "         fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;", "         fmt.fmt.pix_mp.pixelformat = output_capability;", "  } else if (1 == portDefn->nPortIndex) {", "  unsigned int buf_size = 0;", "  if (!client_buffers.update_buffer_req()) {", "             DEBUG_PRINT_ERROR(\"client_buffers.update_buffer_req Failed\");", "  return OMX_ErrorHardware;", "  }", "  if (!client_buffers.get_buffer_req(buf_size)) {", "             DEBUG_PRINT_ERROR(\"update buffer requirements\");", "  return OMX_ErrorHardware;", "  }", "         portDefn->nBufferSize = buf_size;", "         portDefn->eDir =  OMX_DirOutput;", "         portDefn->nBufferCountActual = drv_ctx.op_buf.actualcount;", "         portDefn->nBufferCountMin    = drv_ctx.op_buf.mincount;", "         portDefn->format.video.eCompressionFormat = OMX_VIDEO_CodingUnused;", "         portDefn->bEnabled   = m_out_bEnabled;", "         portDefn->bPopulated = m_out_bPopulated;", "  if (!client_buffers.get_color_format(portDefn->format.video.eColorFormat)) {", "             DEBUG_PRINT_ERROR(\"Error in getting color format\");", "  return OMX_ErrorHardware;", "  }", "         fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;", "         fmt.fmt.pix_mp.pixelformat = capture_capability;", "  } else {", "         portDefn->eDir = OMX_DirMax;", "         DEBUG_PRINT_LOW(\" get_parameter: Bad Port idx %d\",", "  (int)portDefn->nPortIndex);", "         eRet = OMX_ErrorBadPortIndex;", "  }", "  if (is_down_scalar_enabled) {", "  int ret = 0;", "         ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_G_FMT, &fmt);", "  if (ret) {", "             DEBUG_PRINT_ERROR(\"update_portdef : Error in getting port resolution\");", "  return OMX_ErrorHardware;", "  } else {", "             portDefn->format.video.nFrameWidth = fmt.fmt.pix_mp.width;", "             portDefn->format.video.nFrameHeight = fmt.fmt.pix_mp.height;", "             portDefn->format.video.nStride = fmt.fmt.pix_mp.plane_fmt[0].bytesperline;", "             portDefn->format.video.nSliceHeight = fmt.fmt.pix_mp.plane_fmt[0].reserved[0];", "  }", "  } else {", "     portDefn->format.video.nFrameHeight =  drv_ctx.video_resolution.frame_height;", "     portDefn->format.video.nFrameWidth  =  drv_ctx.video_resolution.frame_width;", "     portDefn->format.video.nStride = drv_ctx.video_resolution.stride;", "     portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.scan_lines;", "  }", " ", "  if ((portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar) ||", "  (portDefn->format.video.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar)) {", "            portDefn->format.video.nStride = ALIGN(drv_ctx.video_resolution.frame_width, 16);", "         portDefn->format.video.nSliceHeight = drv_ctx.video_resolution.frame_height;", "  }", "     DEBUG_PRINT_HIGH(\"update_portdef(%u): Width = %u Height = %u Stride = %d \"", "  \"SliceHeight = %u eColorFormat = %d nBufSize %u nBufCnt %u\",", "  (unsigned int)portDefn->nPortIndex,", "  (unsigned int)portDefn->format.video.nFrameWidth,", "  (unsigned int)portDefn->format.video.nFrameHeight,", "  (int)portDefn->format.video.nStride,", "  (unsigned int)portDefn->format.video.nSliceHeight,", "  (unsigned int)portDefn->format.video.eColorFormat,", "  (unsigned int)portDefn->nBufferSize,", "  (unsigned int)portDefn->nBufferCountActual);", " ", "  return eRet;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,", " \t\tunsigned long, nbytes, int __user *, start, void __user *, arg)", " {", " \tunsigned long w;", " \tstruct percpu_struct *cpu;", " ", " \tswitch (op) {", " \tcase GSI_IEEE_FP_CONTROL:", " \t\t ", " \t\t ", " ", "  \t\tw = current_thread_info()->ieee_state & IEEE_SW_MASK;", "  \t\tw = swcr_update_status(w, rdfpcr());", " \t\tif (put_user(w, (unsigned long __user *) buffer))", " \t\t\treturn -EFAULT;", " \t\treturn 0;", " ", " \tcase GSI_IEEE_STATE_AT_SIGNAL:", " \t\t ", " \t\tbreak;", " ", "  \tcase GSI_UACPROC:", " \t\tif (nbytes < sizeof(unsigned int))", " \t\t\treturn -EINVAL;", "  \t\tw = (current_thread_info()->flags >> UAC_SHIFT) & UAC_BITMASK;", "  \t\tif (put_user(w, (unsigned int __user *)buffer))", "  \t\t\treturn -EFAULT;", "  \t\treturn 1;", " ", " \tcase GSI_PROC_TYPE:", " \t\tif (nbytes < sizeof(unsigned long))", " \t\t\treturn -EINVAL;", " \t\tcpu = (struct percpu_struct*)", " \t\t  ((char*)hwrpb + hwrpb->processor_offset);", " \t\tw = cpu->type;", " \t\tif (put_user(w, (unsigned long  __user*)buffer))", " \t\t\treturn -EFAULT;", "  \t\treturn 1;", "  ", "  \tcase GSI_GET_HWRPB:", "\t\tif (nbytes < sizeof(*hwrpb))", " \t\tif (nbytes > sizeof(*hwrpb))", "  \t\t\treturn -EINVAL;", "  \t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)", "  \t\t\treturn -EFAULT;", " \t\treturn 1;", " ", " \tdefault:", " \t\tbreak;", " \t}", " ", " \treturn -EOPNOTSUPP;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)", " {", "     int64_t total_samples = 0, infilesize;", "     Wave64ChunkHeader chunk_header;", "     Wave64FileHeader filehdr;", "     WaveHeader WaveHeader;", "     uint32_t bcount;", " ", "     infilesize = DoGetFileSize (infile);", "     memcpy (&filehdr, fourcc, 4);", " ", "     if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) ||", "         bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) ||", "         memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) {", "             error_line (\"%s is not a valid .W64 file!\", infilename);", "             return WAVPACK_SOFT_ERROR;", "     }", "     else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "         !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) {", "             error_line (\"%s\", WavpackGetErrorMessage (wpc));", "             return WAVPACK_SOFT_ERROR;", "     }", " ", " #if 1    ", "     WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat);", " ", "     if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) &&", "         filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) {", "             error_line (\"%s is not a valid .W64 file!\", infilename);", "             return WAVPACK_SOFT_ERROR;", "     }", " #endif", " ", " ", "     while (1) {", "         if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) ||", "             bcount != sizeof (Wave64ChunkHeader)) {", "                 error_line (\"%s is not a valid .W64 file!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "         }", "         else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "             !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) {", "                 error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                 return WAVPACK_SOFT_ERROR;", "         }", " ", "         WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat);", "         chunk_header.ckSize -= sizeof (chunk_header);", " ", " ", "         if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) {", "             int supported = TRUE, format;", " ", "             chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L;", " ", "             if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) ||", "                 !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) ||", "                 bcount != chunk_header.ckSize) {", "                     error_line (\"%s is not a valid .W64 file!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "             }", "             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat);", " ", "             if (debug_logging_mode) {", "                 error_line (\"format tag size = %d\", chunk_header.ckSize);", "                 error_line (\"FormatTag = %x, NumChannels = %d, BitsPerSample = %d\",", "                     WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample);", "                 error_line (\"BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d\",", "                     WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond);", " ", "                 if (chunk_header.ckSize > 16)", "                     error_line (\"cbSize = %d, ValidBitsPerSample = %d\", WaveHeader.cbSize,", "                         WaveHeader.ValidBitsPerSample);", " ", "                 if (chunk_header.ckSize > 20)", "                     error_line (\"ChannelMask = %x, SubFormat = %d\",", "                         WaveHeader.ChannelMask, WaveHeader.SubFormat);", "             }", " ", "             if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2)", "                 config->qmode |= QMODE_ADOBE_MODE;", " ", "             format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ?", "                 WaveHeader.SubFormat : WaveHeader.FormatTag;", " ", "             config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ?", "                 WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample;", " ", "             if (format != 1 && format != 3)", "                 supported = FALSE;", " ", "             if (format == 3 && config->bits_per_sample != 32)", "                 supported = FALSE;", " ", "             if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 ||", "                 WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 ||", "                 WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 ||", "                 WaveHeader.BlockAlign % WaveHeader.NumChannels)", "                     supported = FALSE;", " ", "             if (config->bits_per_sample < 1 || config->bits_per_sample > 32)", "                 supported = FALSE;", " ", "             if (!supported) {", "                 error_line (\"%s is an unsupported .W64 format!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             if (chunk_header.ckSize < 40) {", "                 if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) {", "                     if (WaveHeader.NumChannels <= 2)", "                         config->channel_mask = 0x5 - WaveHeader.NumChannels;", "                     else if (WaveHeader.NumChannels <= 18)", "                         config->channel_mask = (1 << WaveHeader.NumChannels) - 1;", "                     else", "                         config->channel_mask = 0x3ffff;", "                 }", "             }", "             else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) {", "                 error_line (\"this W64 file already has channel order information!\");", "                 return WAVPACK_SOFT_ERROR;", "             }", "             else if (WaveHeader.ChannelMask)", "                 config->channel_mask = WaveHeader.ChannelMask;", " ", "             if (format == 3)", "                 config->float_norm_exp = 127;", "             else if ((config->qmode & QMODE_ADOBE_MODE) &&", "                 WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) {", "                     if (WaveHeader.BitsPerSample == 24)", "                         config->float_norm_exp = 127 + 23;", "                     else if (WaveHeader.BitsPerSample == 32)", "                         config->float_norm_exp = 127 + 15;", "             }", " ", "             if (debug_logging_mode) {", "                 if (config->float_norm_exp == 127)", "                     error_line (\"data format: normalized 32-bit floating point\");", "                 else", "                     error_line (\"data format: %d-bit integers stored in %d byte(s)\",", "                         config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels);", "             }", "         }", "         else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) {  ", " ", "             if (!WaveHeader.NumChannels) {           ", "                 error_line (\"%s is not a valid .W64 file!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) {", "                 config->qmode |= QMODE_IGNORE_LENGTH;", " ", "                 if (infilesize && DoGetFilePosition (infile) != -1)", "                     total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign;", "                 else", "                     total_samples = -1;", "             }", "             else {", "                 if (infilesize && infilesize - chunk_header.ckSize > 16777216) {", "                     error_line (\"this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!\");", "                     return WAVPACK_SOFT_ERROR;", "                 }", " ", "                 total_samples = chunk_header.ckSize / WaveHeader.BlockAlign;", " ", "                 if (!total_samples) {", "                     error_line (\"this .W64 file has no audio samples, probably is corrupt!\");", "                     return WAVPACK_SOFT_ERROR;", "                 }", " ", "                 if (total_samples > MAX_WAVPACK_SAMPLES) {", "                     error_line (\"%s has too many samples for WavPack!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "                 }", "             }", " ", "             config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;", "             config->num_channels = WaveHeader.NumChannels;", "             config->sample_rate = WaveHeader.SampleRate;", "             break;", "          }", "          else {           ", "              int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;", "            char *buff = malloc (bytes_to_copy);", "             char *buff;", " ", "             if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {", "                 error_line (\"%s is not a valid .W64 file!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             buff = malloc (bytes_to_copy);", "  ", "              if (debug_logging_mode)", "                  error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",", "                     chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],", "                     chunk_header.ckID [3], chunk_header.ckSize);", " ", "             if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||", "                 bcount != bytes_to_copy ||", "                 (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     free (buff);", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             free (buff);", "         }", "     }", " ", "     if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) {", "         error_line (\"%s: %s\", infilename, WavpackGetErrorMessage (wpc));", "         return WAVPACK_SOFT_ERROR;", "     }", " ", "     return WAVPACK_NO_ERROR;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out,", "const uint8_t **contents_out, size_t *clen_out,", "const uint8_t **remainder_out, size_t *rlen_out)", "{", "krb5_error_code ret;", "uint8_t o;", "const uint8_t *c, *p, *tag_start = asn1;", "size_t clen, llen, i;", "taginfo t;", "", "*contents_out = *remainder_out = NULL;", "*clen_out = *rlen_out = 0;", "if (len == 0)", "return ASN1_OVERRUN;", "o = *asn1++;", "len--;", "tag_out->asn1class = o & 0xC0;", "tag_out->construction = o & 0x20;", "if ((o & 0x1F) != 0x1F) {", "tag_out->tagnum = o & 0x1F;", "} else {", "tag_out->tagnum = 0;", "do {", "if (len == 0)", "return ASN1_OVERRUN;", "o = *asn1++;", "len--;", "tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F);", "} while (o & 0x80);", "}", "", "if (len == 0)", "return ASN1_OVERRUN;", "o = *asn1++;", "len--;", "", "if (o == 0x80) {", "", "if (tag_out->construction != CONSTRUCTED)", "return ASN1_MISMATCH_INDEF;", "p = asn1;", "while (!(len >= 2 && p[0] == 0 && p[1] == 0)) {", "ret = get_tag(p, len, &t, &c, &clen, &p, &len);", "if (ret)", "return ret;", "}", "tag_out->tag_end_len = 2;", "*contents_out = asn1;", "*clen_out = p - asn1;", "*remainder_out = p + 2;", "*rlen_out = len - 2;", "} else if ((o & 0x80) == 0) {", "", "if (o > len)", "return ASN1_OVERRUN;", "tag_out->tag_end_len = 0;", "*contents_out = asn1;", "*clen_out = o;", "*remainder_out = asn1 + *clen_out;", "*rlen_out = len - (*remainder_out - asn1);", "} else {", "", "llen = o & 0x7F;", "if (llen > len)", "return ASN1_OVERRUN;", "if (llen > sizeof(*clen_out))", "return ASN1_OVERFLOW;", "for (i = 0, clen = 0; i < llen; i++)", "clen = (clen << 8) | asn1[i];", "if (clen > len - llen)", "return ASN1_OVERRUN;", "tag_out->tag_end_len = 0;", "*contents_out = asn1 + llen;", "*clen_out = clen;", "*remainder_out = *contents_out + clen;", "*rlen_out = len - (*remainder_out - asn1);", "}", "tag_out->tag_len = *contents_out - tag_start;", "return 0;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["njs_vmcode_await(njs_vm_t *vm, njs_vmcode_await_t *await)", "{", "size_t              size;", "njs_int_t           ret;", "njs_frame_t         *frame;", "njs_value_t         ctor, val, on_fulfilled, on_rejected, *value;", "njs_promise_t       *promise;", "njs_function_t      *fulfilled, *rejected;", "njs_async_ctx_t     *ctx;", "njs_native_frame_t  *active;", "", "active = &vm->active_frame->native;", "", "value = njs_scope_valid_value(vm, await->retval);", "if (njs_slow_path(value == NULL)) {", "return NJS_ERROR;", "}", "", "njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);", "", "promise = njs_promise_resolve(vm, &ctor, value);", "if (njs_slow_path(promise == NULL)) {", "return NJS_ERROR;", "}", "", "ctx = active->function->await;", "", "if (ctx == NULL) {", "ctx = njs_mp_alloc(vm->mem_pool, sizeof(njs_async_ctx_t));", "if (njs_slow_path(ctx == NULL)) {", "njs_memory_error(vm);", "return NJS_ERROR;", "}", "", "size = njs_function_frame_size(active);", "", "fulfilled = njs_promise_create_function(vm, size);", "if (njs_slow_path(fulfilled == NULL)) {", "return NJS_ERROR;", "}", "", "ctx->await = fulfilled->context;", "ctx->capability = active->function->context;", "", "active->function->context = NULL;", "", "ret = njs_function_frame_save(vm, ctx->await, NULL);", "if (njs_slow_path(ret != NJS_OK)) {", "return NJS_ERROR;", "}", "", "} else {", "fulfilled = njs_promise_create_function(vm, 0);", "if (njs_slow_path(fulfilled == NULL)) {", "return NJS_ERROR;", "}", "}", "", "ctx->pc = (u_char *) await + sizeof(njs_vmcode_await_t);", "ctx->index = await->retval;", "", "frame = (njs_frame_t *) active;", "", "if (frame->exception.catch != NULL) {", "ctx->await->native.pc = frame->exception.catch;", "", "} else {", "ctx->await->native.pc = ctx->pc;", "}", "", "fulfilled->context = ctx;", "fulfilled->args_count = 1;", "fulfilled->u.native = njs_await_fulfilled;", "", "rejected = njs_promise_create_function(vm, 0);", "if (njs_slow_path(rejected == NULL)) {", "return NJS_ERROR;", "}", "", "rejected->context = ctx;", "rejected->args_count = 1;", "rejected->u.native = njs_await_rejected;", "", "njs_set_promise(&val, promise);", "njs_set_function(&on_fulfilled, fulfilled);", "njs_set_function(&on_rejected, rejected);", "", "ret = njs_promise_perform_then(vm, &val, &on_fulfilled, &on_rejected, NULL);", "if (njs_slow_path(ret != NJS_OK)) {", "return NJS_ERROR;", "}", "", "(void) njs_vmcode_return(vm, NULL, &vm->retval);", "", "return NJS_AGAIN;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)", " {", "    struct virgl_gl_ctx_param ctx_params;", "    int i;", "    if (blit_ctx->initialised) {", "       vrend_clicbs->make_current(0, blit_ctx->gl_context);", "        return;", "     }", "  ", "    blit_ctx->initialised = true;", "     ctx_params.shared = true;", "     ctx_params.major_ver = VREND_GL_VER_MAJOR;", "     ctx_params.minor_ver = VREND_GL_VER_MINOR;", " ", "    vrend_clicbs->make_current(0, blit_ctx->gl_context);", "    glGenVertexArrays(1, &blit_ctx->vaoid);", "    glGenFramebuffers(1, &blit_ctx->fb_id);", " ", "    glGenBuffers(1, &blit_ctx->vbo_id);", "    blit_build_vs_passthrough(blit_ctx);", " ", "    for (i = 0; i < 4; i++)", "       blit_ctx->vertices[i][0][3] = 1;  ", "    glBindVertexArray(blit_ctx->vaoid);", "    glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void RenderFrameHostImpl::RegisterMojoInterfaces() {", " #if !defined(OS_ANDROID)", "   registry_->AddInterface(base::Bind(&InstalledAppProviderImplDefault::Create));", " #endif   ", " ", "   PermissionControllerImpl* permission_controller =", "       PermissionControllerImpl::FromBrowserContext(", "           GetProcess()->GetBrowserContext());", "   if (delegate_) {", "     auto* geolocation_context = delegate_->GetGeolocationContext();", "     if (geolocation_context) {", "       geolocation_service_.reset(new GeolocationServiceImpl(", "           geolocation_context, permission_controller, this));", "       registry_->AddInterface(", "           base::Bind(&GeolocationServiceImpl::Bind,", "                      base::Unretained(geolocation_service_.get())));", "     }", "   }", " ", "   registry_->AddInterface<device::mojom::WakeLock>(base::Bind(", "       &RenderFrameHostImpl::BindWakeLockRequest, base::Unretained(this)));", " ", " #if defined(OS_ANDROID)", "   if (base::FeatureList::IsEnabled(features::kWebNfc)) {", "     registry_->AddInterface<device::mojom::NFC>(base::Bind(", "         &RenderFrameHostImpl::BindNFCRequest, base::Unretained(this)));", "   }", " #endif", " ", "   if (!permission_service_context_)", "     permission_service_context_.reset(new PermissionServiceContext(this));", " ", "   registry_->AddInterface(", "       base::Bind(&PermissionServiceContext::CreateService,", "                  base::Unretained(permission_service_context_.get())));", " ", "   registry_->AddInterface(", "       base::Bind(&RenderFrameHostImpl::BindPresentationServiceRequest,", "                  base::Unretained(this)));", " ", "   registry_->AddInterface(", "       base::Bind(&MediaSessionServiceImpl::Create, base::Unretained(this)));", " ", "   registry_->AddInterface(base::Bind(", "       base::IgnoreResult(&RenderFrameHostImpl::CreateWebBluetoothService),", "       base::Unretained(this)));", " ", "   registry_->AddInterface(base::BindRepeating(", "       &RenderFrameHostImpl::CreateWebUsbService, base::Unretained(this)));", " ", "   registry_->AddInterface<media::mojom::InterfaceFactory>(", "       base::Bind(&RenderFrameHostImpl::BindMediaInterfaceFactoryRequest,", "                  base::Unretained(this)));", " ", "   registry_->AddInterface(base::BindRepeating(", "       &RenderFrameHostImpl::CreateWebSocket, base::Unretained(this)));", " ", "   registry_->AddInterface(base::BindRepeating(", "       &RenderFrameHostImpl::CreateDedicatedWorkerHostFactory,", "       base::Unretained(this)));", " ", "   registry_->AddInterface(base::Bind(&SharedWorkerConnectorImpl::Create,", "                                      process_->GetID(), routing_id_));", " ", "   registry_->AddInterface(base::BindRepeating(&device::GamepadMonitor::Create));", " ", "   registry_->AddInterface<device::mojom::VRService>(base::Bind(", "       &WebvrServiceProvider::BindWebvrService, base::Unretained(this)));", " ", "   registry_->AddInterface(", "       base::BindRepeating(&RenderFrameHostImpl::CreateAudioInputStreamFactory,", "                           base::Unretained(this)));", " ", "   registry_->AddInterface(", "       base::BindRepeating(&RenderFrameHostImpl::CreateAudioOutputStreamFactory,", "                           base::Unretained(this)));", " ", "   registry_->AddInterface(", "       base::Bind(&CreateFrameResourceCoordinator, base::Unretained(this)));", " ", "   if (BrowserMainLoop::GetInstance()) {", "     MediaStreamManager* media_stream_manager =", "         BrowserMainLoop::GetInstance()->media_stream_manager();", "     registry_->AddInterface(", "         base::Bind(&MediaDevicesDispatcherHost::Create, GetProcess()->GetID(),", "                    GetRoutingID(), base::Unretained(media_stream_manager)),", "          base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));", "  ", "      registry_->AddInterface(", "        base::BindRepeating(", "            &RenderFrameHostImpl::CreateMediaStreamDispatcherHost,", "            base::Unretained(this), base::Unretained(media_stream_manager)),", "         base::BindRepeating(&MediaStreamDispatcherHost::Create,", "                             GetProcess()->GetID(), GetRoutingID(),", "                             base::Unretained(media_stream_manager)),", "          base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));", "    }", "  ", " #if BUILDFLAG(ENABLE_MEDIA_REMOTING)", "   registry_->AddInterface(base::Bind(&RemoterFactoryImpl::Bind,", "                                      GetProcess()->GetID(), GetRoutingID()));", " #endif   ", " ", "   registry_->AddInterface(base::BindRepeating(", "       &KeyboardLockServiceImpl::CreateMojoService, base::Unretained(this)));", " ", "   registry_->AddInterface(base::Bind(&ImageCaptureImpl::Create));", " ", " #if !defined(OS_ANDROID)", "   if (base::FeatureList::IsEnabled(features::kWebAuth)) {", "     registry_->AddInterface(", "         base::Bind(&RenderFrameHostImpl::BindAuthenticatorRequest,", "                    base::Unretained(this)));", "     if (base::CommandLine::ForCurrentProcess()->HasSwitch(", "             switches::kEnableWebAuthTestingAPI)) {", "       auto* environment_singleton =", "           ScopedVirtualAuthenticatorEnvironment::GetInstance();", "       registry_->AddInterface(base::BindRepeating(", "           &ScopedVirtualAuthenticatorEnvironment::AddBinding,", "           base::Unretained(environment_singleton)));", "     }", "   }", " #endif   ", " ", "   sensor_provider_proxy_.reset(", "       new SensorProviderProxyImpl(permission_controller, this));", "   registry_->AddInterface(", "       base::Bind(&SensorProviderProxyImpl::Bind,", "                  base::Unretained(sensor_provider_proxy_.get())));", " ", "   media::VideoDecodePerfHistory::SaveCallback save_stats_cb;", "   if (GetSiteInstance()->GetBrowserContext()->GetVideoDecodePerfHistory()) {", "     save_stats_cb = GetSiteInstance()", "                         ->GetBrowserContext()", "                         ->GetVideoDecodePerfHistory()", "                         ->GetSaveCallback();", "   }", " ", "   registry_->AddInterface(base::BindRepeating(", "       &media::MediaMetricsProvider::Create, frame_tree_node_->IsMainFrame(),", "       base::BindRepeating(", "           &RenderFrameHostDelegate::GetUkmSourceIdForLastCommittedSource,", "           base::Unretained(delegate_)),", "       std::move(save_stats_cb)));", " ", "   if (base::CommandLine::ForCurrentProcess()->HasSwitch(", "           cc::switches::kEnableGpuBenchmarking)) {", "     registry_->AddInterface(", "         base::Bind(&InputInjectorImpl::Create, weak_ptr_factory_.GetWeakPtr()));", "   }", " ", "   registry_->AddInterface(base::BindRepeating(", "       &QuotaDispatcherHost::CreateForFrame, GetProcess(), routing_id_));", " ", "   registry_->AddInterface(", "       base::BindRepeating(SpeechRecognitionDispatcherHost::Create,", "                           GetProcess()->GetID(), routing_id_),", "       base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));", " ", "   file_system_manager_.reset(new FileSystemManagerImpl(", "       GetProcess()->GetID(), routing_id_,", "       GetProcess()->GetStoragePartition()->GetFileSystemContext(),", "       ChromeBlobStorageContext::GetFor(GetProcess()->GetBrowserContext())));", "   registry_->AddInterface(", "       base::BindRepeating(&FileSystemManagerImpl::BindRequest,", "                           base::Unretained(file_system_manager_.get())),", "       base::CreateSingleThreadTaskRunnerWithTraits({BrowserThread::IO}));", " ", "   if (Portal::IsEnabled()) {", "     registry_->AddInterface(base::BindRepeating(IgnoreResult(&Portal::Create),", "                                                 base::Unretained(this)));", "   }", " ", "   registry_->AddInterface(base::BindRepeating(", "       &BackgroundFetchServiceImpl::CreateForFrame, GetProcess(), routing_id_));", " ", "   registry_->AddInterface(base::BindRepeating(&ContactsManagerImpl::Create));", " ", "   registry_->AddInterface(", "       base::BindRepeating(&FileChooserImpl::Create, base::Unretained(this)));", " ", "   registry_->AddInterface(base::BindRepeating(&AudioContextManagerImpl::Create,", "                                               base::Unretained(this)));", " ", "   registry_->AddInterface(base::BindRepeating(&WakeLockServiceImpl::Create,", "                                               base::Unretained(this)));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,", "      const cdf_header_t *h, cdf_secid_t id)", "  {", "\tassert((size_t)CDF_SEC_SIZE(h) == len);", "\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),", "\t    ((char *)buf) + offs, len);", " \tsize_t ss = CDF_SEC_SIZE(h);", " \tsize_t pos = CDF_SEC_POS(h, id);", " \tassert(ss == len);", " \treturn cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)", " {", "     AC3HeaderInfo *hdr = NULL;", "     struct eac3_info *info;", "     int num_blocks, ret;", " ", "     if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info))))", "         return AVERROR(ENOMEM);", "     info = track->eac3_priv;", " ", "     if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) {", "          ", "         if (!track->entry) {", "             av_log(mov, AV_LOG_WARNING, \"Dropping invalid packet from start of the stream\\n\");", "             ret = 0;", "         } else", "             ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", " ", "     info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000);", "     num_blocks = hdr->num_blocks;", " ", "     if (!info->ec3_done) {", "          ", "         if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) {", "             ret = AVERROR(EINVAL);", "             goto end;", "         }", " ", "          ", "         if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) {", "              ", "             if (hdr->substreamid > info->num_ind_sub + 1) {", "                 ret = AVERROR(EINVAL);", "                 goto end;", "             }", " ", "             if (hdr->substreamid == info->num_ind_sub + 1) {", "                 avpriv_request_sample(track->par, \"Multiple independent substreams\");", "                 ret = AVERROR_PATCHWELCOME;", "                 goto end;", "             } else if (hdr->substreamid < info->num_ind_sub ||", "                        hdr->substreamid == 0 && info->substream[0].bsid) {", "                  info->ec3_done = 1;", "                  goto concatenate;", "              }", "         } else {", "             if (hdr->substreamid != 0) {", "                 avpriv_request_sample(mov->fc, \"Multiple non EAC3 independent substreams\");", "                 ret = AVERROR_PATCHWELCOME;", "                 goto end;", "             }", "          }", "  ", "           ", "         info->substream[hdr->substreamid].fscod = hdr->sr_code;", "         info->substream[hdr->substreamid].bsid  = hdr->bitstream_id;", "         info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode;", "         info->substream[hdr->substreamid].acmod = hdr->channel_mode;", "         info->substream[hdr->substreamid].lfeon = hdr->lfe_on;", " ", "          ", "         if (pkt->size != hdr->frame_size) {", "             int cumul_size = hdr->frame_size;", "             int parent = hdr->substreamid;", " ", "             while (cumul_size != pkt->size) {", "                 GetBitContext gbc;", "                 int i;", "                 ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size);", "                 if (ret < 0)", "                     goto end;", "                 if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) {", "                     ret = AVERROR(EINVAL);", "                     goto end;", "                 }", "                 info->substream[parent].num_dep_sub++;", "                 ret /= 8;", " ", "                  ", "                 init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret);", "                  ", "                 skip_bits(&gbc, 5);", "                  ", "                 for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) {", "                     skip_bits(&gbc, 5);  ", "                     if (get_bits1(&gbc)) {", "                         skip_bits(&gbc, 8);  ", "                     }", "                 }", "                  ", "                 if (get_bits1(&gbc))", "                     info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f;", "                 else", "                     info->substream[parent].chan_loc |= hdr->channel_mode;", "                 cumul_size += hdr->frame_size;", "             }", "         }", "     }", " ", " concatenate:", "     if (!info->num_blocks && num_blocks == 6) {", "         ret = pkt->size;", "         goto end;", "     }", "     else if (info->num_blocks + num_blocks > 6) {", "         ret = AVERROR_INVALIDDATA;", "         goto end;", "     }", " ", "     if (!info->num_blocks) {", "         ret = av_packet_ref(&info->pkt, pkt);", "         if (!ret)", "             info->num_blocks = num_blocks;", "         goto end;", "     } else {", "         if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0)", "             goto end;", "         memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size);", "         info->num_blocks += num_blocks;", "         info->pkt.duration += pkt->duration;", "         if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0)", "             goto end;", "         if (info->num_blocks != 6)", "             goto end;", "         av_packet_unref(pkt);", "         av_packet_move_ref(pkt, &info->pkt);", "         info->num_blocks = 0;", "     }", "     ret = pkt->size;", " ", " end:", "     av_free(hdr);", " ", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {", "", "if (first == NULL || *first == NULL || second == NULL || *second == NULL)", "return NULL;", "", "", "if (*first == *second)", "return NULL;", "", "size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));", "size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));", "", "size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));", "size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));", "", "int append;", "unsigned char *source, *target;", "size_t target_bytes, source_bytes;", "", "", "", "if (first_len >= second_len) {", "", "target = *first;", "target_bytes = first_bytes;", "source = *second;", "source_bytes = second_bytes;", "append = 1;", "} else {", "", "target = *second;", "target_bytes = second_bytes;", "source = *first;", "source_bytes = first_bytes;", "append = 0;", "}", "", "", "size_t zlbytes = first_bytes + second_bytes -", "ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;", "size_t zllength = first_len + second_len;", "", "", "zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;", "", "", "size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));", "size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));", "", "", "target = zrealloc(target, zlbytes);", "if (append) {", "", "", "", "memcpy(target + target_bytes - ZIPLIST_END_SIZE,", "source + ZIPLIST_HEADER_SIZE,", "source_bytes - ZIPLIST_HEADER_SIZE);", "} else {", "", "", "", "", "memmove(target + source_bytes - ZIPLIST_END_SIZE,", "target + ZIPLIST_HEADER_SIZE,", "target_bytes - ZIPLIST_HEADER_SIZE);", "memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);", "}", "", "", "ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);", "ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);", "", "", "", "", "", "ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(", "(first_bytes - ZIPLIST_END_SIZE) +", "(second_offset - ZIPLIST_HEADER_SIZE));", "", "", "", "", "", "target = __ziplistCascadeUpdate(target, target+first_offset);", "", "", "if (append) {", "zfree(*second);", "*second = NULL;", "*first = target;", "} else {", "zfree(*first);", "*first = NULL;", "*second = target;", "}", "return target;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadYCBCRImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   const unsigned char", "     *pixels;", " ", "   Image", "     *canvas_image,", "     *image;", " ", "   MagickBooleanType", "     status;", " ", "   MagickOffsetType", "     scene;", " ", "   QuantumInfo", "     *quantum_info;", " ", "   QuantumType", "     quantum_type;", " ", "   register const Quantum", "     *p;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register Quantum", "     *q;", " ", "   size_t", "     length;", " ", "   ssize_t", "     count,", "     y;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   image=AcquireImage(image_info,exception);", "   if ((image->columns == 0) || (image->rows == 0))", "     ThrowReaderException(OptionError,\"MustSpecifyImageSize\");", "   status=SetImageExtent(image,image->columns,image->rows,exception);", "   if (status == MagickFalse)", "     return(DestroyImageList(image));", "   SetImageColorspace(image,YCbCrColorspace,exception);", "   if (image_info->interlace != PartitionInterlace)", "     {", "       status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "       if (status == MagickFalse)", "         {", "           image=DestroyImageList(image);", "           return((Image *) NULL);", "         }", "       if (DiscardBlobBytes(image,image->offset) == MagickFalse)", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "     }", "    ", "   canvas_image=CloneImage(image,image->extract_info.width,1,MagickFalse,", "     exception);", "   (void) SetImageVirtualPixelMethod(canvas_image,BlackVirtualPixelMethod,", "     exception);", "   quantum_info=AcquireQuantumInfo(image_info,canvas_image);", "   if (quantum_info == (QuantumInfo *) NULL)", "     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "   quantum_type=RGBQuantum;", "   if (LocaleCompare(image_info->magick,\"YCbCrA\") == 0)", "     {", "       quantum_type=RGBAQuantum;", "       image->alpha_trait=BlendPixelTrait;", "     }", "   pixels=(const unsigned char *) NULL;", "   if (image_info->number_scenes != 0)", "     while (image->scene < image_info->scene)", "     {", "        ", "       image->scene++;", "       length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);", "       for (y=0; y < (ssize_t) image->rows; y++)", "       {", "         pixels=(const unsigned char *) ReadBlobStream(image,length,", "           GetQuantumPixels(quantum_info),&count);", "         if (count != (ssize_t) length)", "           break;", "       }", "     }", "   count=0;", "   length=0;", "   scene=0;", "   do", "   {", "      ", "     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     status=SetImageExtent(image,image->columns,image->rows,exception);", "      if (status == MagickFalse)", "      {", "        quantum_info=DestroyQuantumInfo(quantum_info);", "       canvas_image=DestroyImage(canvas_image);", "        return(DestroyImageList(image));", "      }", "      SetImageColorspace(image,YCbCrColorspace,exception);", "     switch (image_info->interlace)", "     {", "       case NoInterlace:", "       default:", "       {", "          ", "         if (scene == 0)", "           {", "             length=GetQuantumExtent(canvas_image,quantum_info,quantum_type);", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "           }", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,quantum_type,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=QueueAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);", "                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);", "                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);", "                 if (image->alpha_trait != UndefinedPixelTrait)", "                   SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "             }", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         break;", "       }", "       case LineInterlace:", "       {", "         static QuantumType", "           quantum_types[4] =", "           {", "             RedQuantum,", "             GreenQuantum,", "             BlueQuantum,", "             OpacityQuantum", "           };", " ", "          ", "         if (scene == 0)", "           {", "             length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "           }", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           for (i=0; i < (image->alpha_trait != UndefinedPixelTrait ? 4 : 3); i++)", "           {", "             if (count != (ssize_t) length)", "               {", "                 ThrowFileException(exception,CorruptImageError,", "                   \"UnexpectedEndOfFile\",image->filename);", "                 break;", "               }", "             quantum_type=quantum_types[i];", "             q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "               exception);", "             if (q == (Quantum *) NULL)", "               break;", "             length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "               quantum_info,quantum_type,pixels,exception);", "             if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "               break;", "             if (((y-image->extract_info.y) >= 0) && ", "                 ((y-image->extract_info.y) < (ssize_t) image->rows))", "               {", "                 p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,", "                   0,canvas_image->columns,1,exception);", "                 q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                   image->columns,1,exception);", "                 if ((p == (const Quantum *) NULL) ||", "                     (q == (Quantum *) NULL))", "                   break;", "                 for (x=0; x < (ssize_t) image->columns; x++)", "                 {", "                   switch (quantum_type)", "                   {", "                     case RedQuantum:", "                     {", "                       SetPixelRed(image,GetPixelRed(canvas_image,p),q);", "                       break;", "                     }", "                     case GreenQuantum:", "                     {", "                       SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);", "                       break;", "                     }", "                     case BlueQuantum:", "                     {", "                       SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);", "                       break;", "                     }", "                     case OpacityQuantum:", "                     {", "                       SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);", "                       break;", "                     }", "                     default:", "                       break;", "                   }", "                   p+=GetPixelChannels(canvas_image);", "                   q+=GetPixelChannels(image);", "                 }", "                 if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                   break;", "               }", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "           }", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case PlaneInterlace:", "       {", "          ", "         if (scene == 0)", "           {", "             length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "           }", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,RedQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "             }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,1,5);", "             if (status == MagickFalse)", "               break;", "           }", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,GreenQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "            }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,2,5);", "             if (status == MagickFalse)", "               break;", "           }", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,BlueQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "             }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,3,5);", "             if (status == MagickFalse)", "               break;", "           }", "         if (image->alpha_trait != UndefinedPixelTrait)", "           {", "             for (y=0; y < (ssize_t) image->extract_info.height; y++)", "             {", "               if (count != (ssize_t) length)", "                 {", "                   ThrowFileException(exception,CorruptImageError,", "                     \"UnexpectedEndOfFile\",image->filename);", "                   break;", "                 }", "               q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "                 exception);", "               if (q == (Quantum *) NULL)", "                 break;", "               length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "                 quantum_info,AlphaQuantum,pixels,exception);", "               if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "                 break;", "               if (((y-image->extract_info.y) >= 0) && ", "                   ((y-image->extract_info.y) < (ssize_t) image->rows))", "                 {", "                   p=GetVirtualPixels(canvas_image,", "                     canvas_image->extract_info.x,0,canvas_image->columns,1,", "                     exception);", "                   q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                     image->columns,1,exception);", "                   if ((p == (const Quantum *) NULL) ||", "                       (q == (Quantum *) NULL))", "                     break;", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);", "                     p+=GetPixelChannels(canvas_image);", "                     q+=GetPixelChannels(image);", "                   }", "                   if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                     break;", "                 }", "               pixels=(const unsigned char *) ReadBlobStream(image,length,", "                 GetQuantumPixels(quantum_info),&count);", "             }", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,4,5);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,5,5);", "             if (status == MagickFalse)", "               break;", "           }", "         break;", "       }", "       case PartitionInterlace:", "       {", "          ", "         AppendImageFormat(\"Y\",image->filename);", "         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "         if (status == MagickFalse)", "           {", "             canvas_image=DestroyImageList(canvas_image);", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         if (DiscardBlobBytes(image,image->offset) == MagickFalse)", "           ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "             image->filename);", "         length=GetQuantumExtent(canvas_image,quantum_info,RedQuantum);", "         for (i=0; i < (ssize_t) scene; i++)", "           for (y=0; y < (ssize_t) image->extract_info.height; y++)", "           {", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "             if (count != (ssize_t) length)", "               {", "                 ThrowFileException(exception,CorruptImageError,", "                   \"UnexpectedEndOfFile\",image->filename);", "                 break;", "               }", "           }", "         pixels=(const unsigned char *) ReadBlobStream(image,length,", "           GetQuantumPixels(quantum_info),&count);", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,RedQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelRed(image,GetPixelRed(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "             }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,1,5);", "             if (status == MagickFalse)", "               break;", "           }", "         (void) CloseBlob(image);", "         AppendImageFormat(\"Cb\",image->filename);", "         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "         if (status == MagickFalse)", "           {", "             canvas_image=DestroyImageList(canvas_image);", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         length=GetQuantumExtent(canvas_image,quantum_info,GreenQuantum);", "         for (i=0; i < (ssize_t) scene; i++)", "           for (y=0; y < (ssize_t) image->extract_info.height; y++)", "           {", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "             if (count != (ssize_t) length)", "               {", "                 ThrowFileException(exception,CorruptImageError,", "                   \"UnexpectedEndOfFile\",image->filename);", "                 break;", "               }", "           }", "         pixels=(const unsigned char *) ReadBlobStream(image,length,", "           GetQuantumPixels(quantum_info),&count);", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,GreenQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelGreen(image,GetPixelGreen(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "            }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,2,5);", "             if (status == MagickFalse)", "               break;", "           }", "         (void) CloseBlob(image);", "         AppendImageFormat(\"Cr\",image->filename);", "         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "         if (status == MagickFalse)", "           {", "             canvas_image=DestroyImageList(canvas_image);", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         length=GetQuantumExtent(canvas_image,quantum_info,BlueQuantum);", "         for (i=0; i < (ssize_t) scene; i++)", "           for (y=0; y < (ssize_t) image->extract_info.height; y++)", "           {", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "             if (count != (ssize_t) length)", "               {", "                 ThrowFileException(exception,CorruptImageError,", "                   \"UnexpectedEndOfFile\",image->filename);", "                 break;", "               }", "           }", "         pixels=(const unsigned char *) ReadBlobStream(image,length,", "           GetQuantumPixels(quantum_info),&count);", "         for (y=0; y < (ssize_t) image->extract_info.height; y++)", "         {", "           if (count != (ssize_t) length)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "             exception);", "           if (q == (Quantum *) NULL)", "             break;", "           length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "             quantum_info,BlueQuantum,pixels,exception);", "           if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "             break;", "           if (((y-image->extract_info.y) >= 0) && ", "               ((y-image->extract_info.y) < (ssize_t) image->rows))", "             {", "               p=GetVirtualPixels(canvas_image,canvas_image->extract_info.x,0,", "                 canvas_image->columns,1,exception);", "               q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                 image->columns,1,exception);", "               if ((p == (const Quantum *) NULL) ||", "                   (q == (Quantum *) NULL))", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelBlue(image,GetPixelBlue(canvas_image,p),q);", "                 p+=GetPixelChannels(canvas_image);", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "            }", "           pixels=(const unsigned char *) ReadBlobStream(image,length,", "             GetQuantumPixels(quantum_info),&count);", "         }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,3,5);", "             if (status == MagickFalse)", "               break;", "           }", "         if (image->alpha_trait != UndefinedPixelTrait)", "           {", "             (void) CloseBlob(image);", "             AppendImageFormat(\"A\",image->filename);", "             status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "             if (status == MagickFalse)", "               {", "                 canvas_image=DestroyImageList(canvas_image);", "                 image=DestroyImageList(image);", "                 return((Image *) NULL);", "               }", "             length=GetQuantumExtent(canvas_image,quantum_info,AlphaQuantum);", "             for (i=0; i < (ssize_t) scene; i++)", "               for (y=0; y < (ssize_t) image->extract_info.height; y++)", "               {", "                 pixels=(const unsigned char *) ReadBlobStream(image,length,", "                   GetQuantumPixels(quantum_info),&count);", "                 if (count != (ssize_t) length)", "                   {", "                     ThrowFileException(exception,CorruptImageError,", "                       \"UnexpectedEndOfFile\",image->filename);", "                     break;", "                   }", "               }", "             pixels=(const unsigned char *) ReadBlobStream(image,length,", "               GetQuantumPixels(quantum_info),&count);", "             for (y=0; y < (ssize_t) image->extract_info.height; y++)", "             {", "               if (count != (ssize_t) length)", "                 {", "                   ThrowFileException(exception,CorruptImageError,", "                     \"UnexpectedEndOfFile\",image->filename);", "                   break;", "                 }", "               q=GetAuthenticPixels(canvas_image,0,0,canvas_image->columns,1,", "                 exception);", "               if (q == (Quantum *) NULL)", "                 break;", "               length=ImportQuantumPixels(canvas_image,(CacheView *) NULL,", "                 quantum_info,BlueQuantum,pixels,exception);", "               if (SyncAuthenticPixels(canvas_image,exception) == MagickFalse)", "                 break;", "               if (((y-image->extract_info.y) >= 0) && ", "                   ((y-image->extract_info.y) < (ssize_t) image->rows))", "                 {", "                   p=GetVirtualPixels(canvas_image,", "                     canvas_image->extract_info.x,0,canvas_image->columns,1,", "                     exception);", "                   q=GetAuthenticPixels(image,0,y-image->extract_info.y,", "                     image->columns,1,exception);", "                   if ((p == (const Quantum *) NULL) ||", "                       (q == (Quantum *) NULL))", "                     break;", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     SetPixelAlpha(image,GetPixelAlpha(canvas_image,p),q);", "                     p+=GetPixelChannels(canvas_image);", "                     q+=GetPixelChannels(image);", "                   }", "                   if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                     break;", "                }", "               pixels=(const unsigned char *) ReadBlobStream(image,length,", "                 GetQuantumPixels(quantum_info),&count);", "             }", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,4,5);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,5,5);", "             if (status == MagickFalse)", "               break;", "           }", "         break;", "       }", "     }", "     SetQuantumImageType(image,quantum_type);", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     if (count == (ssize_t) length)", "       {", "          ", "         AcquireNextImage(image_info,image,exception);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "     scene++;", "   } while (count == (ssize_t) length);", "   quantum_info=DestroyQuantumInfo(quantum_info);", "   canvas_image=DestroyImage(canvas_image);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)", "  \t{", "\tBN_ULONG t1,t2;", "  \tBN_ULONG c1,c2,c3;", "  ", "  \tc1=0;", " \tc2=0;", " \tc3=0;", " \tsqr_add_c(a,0,c1,c2,c3);", " \tr[0]=c1;", " \tc1=0;", " \tsqr_add_c2(a,1,0,c2,c3,c1);", " \tr[1]=c2;", " \tc2=0;", " \tsqr_add_c(a,1,c3,c1,c2);", " \tsqr_add_c2(a,2,0,c3,c1,c2);", " \tr[2]=c3;", " \tc3=0;", " \tsqr_add_c2(a,3,0,c1,c2,c3);", " \tsqr_add_c2(a,2,1,c1,c2,c3);", " \tr[3]=c1;", " \tc1=0;", " \tsqr_add_c(a,2,c2,c3,c1);", " \tsqr_add_c2(a,3,1,c2,c3,c1);", " \tr[4]=c2;", " \tc2=0;", " \tsqr_add_c2(a,3,2,c3,c1,c2);", " \tr[5]=c3;", " \tc3=0;", " \tsqr_add_c(a,3,c1,c2,c3);", " \tr[6]=c1;", " \tr[7]=c2;", " \t}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void LocalFileSystem::resolveURL(ExecutionContext* context, const KURL& fileSystemURL, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)", "  {", "      RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);", "    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));", "     CallbackWrapper* wrapper = new CallbackWrapper(callbacks);", "      requestFileSystemAccessInternal(context,", "          bind(&LocalFileSystem::resolveURLInternal, this, contextPtr, fileSystemURL, wrapper),", "          bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" IDNSpoofChecker::IDNSpoofChecker() {", "   UErrorCode status = U_ZERO_ERROR;", "   checker_ = uspoof_open(&status);", "   if (U_FAILURE(status)) {", "     checker_ = nullptr;", "     return;", "   }", " ", " ", "   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);", " ", "   SetAllowedUnicodeSet(&status);", " ", "   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;", "   uspoof_setChecks(checker_, checks, &status);", " ", "   deviation_characters_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);", "   deviation_characters_.freeze();", " ", "   non_ascii_latin_letters_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);", "   non_ascii_latin_letters_.freeze();", " ", "   kana_letters_exceptions_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),", "       status);", "   kana_letters_exceptions_.freeze();", "   combining_diacritics_exceptions_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);", "   combining_diacritics_exceptions_.freeze();", " ", "    cyrillic_letters_latin_alike_ = icu::UnicodeSet(", "      icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);", "       icu::UnicodeString::fromUTF8(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u0517\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);", "    cyrillic_letters_latin_alike_.freeze();", "  ", "    cyrillic_letters_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);", "   cyrillic_letters_.freeze();", " ", "   DCHECK(U_SUCCESS(status));", "   lgc_letters_n_ascii_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"", "                             \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),", "       status);", "   lgc_letters_n_ascii_.freeze();", " ", "   UParseError parse_error;", "   diacritic_remover_.reset(icu::Transliterator::createFromRules(", "       UNICODE_STRING_SIMPLE(\"DropAcc\"),", "       icu::UnicodeString::fromUTF8(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"", "                                    \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),", "       UTRANS_FORWARD, parse_error, status));", " ", "   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(", "       UNICODE_STRING_SIMPLE(\"ExtraConf\"),", "       icu::UnicodeString::fromUTF8(", "           \"[\u00e6\u04d5] > ae; [\u00fe\u03fc\u048f] > p; [\u0127\u043d\u045b\u04a3\u04a5\u04c8\u04ca\u050b\u0527\u0529] > h;\"", "           \"[\u0138\u03ba\u043a\u049b\u049d\u049f\u04a1\u04c4\u051f] > k; [\u014b\u043f\u0525\u0e01] > n; \u0153 > ce;\"", "           \"[\u0167\u0442\u04ad\u050f] > t; [\u0185\u044c\u048d\u0432] > b;  [\u03c9\u0448\u0449\u0e1e\u0e1f\u0e9e\u0e9f] > w;\"", "           \"[\u043c\u04ce] > m; [\u0454\u04bd\u04bf\u1054] > e; \u0491 > r; [\u0493\u04fb] > f;\"", "           \"[\u04ab\u1004] > c; \u04b1 > y; [\u03c7\u04b3\u04fd\u04ff] > x;\"", "           \"\u0503  > d; [\u050d\u100c] > g; [\u0d1f\u0e23\u0ea3\u0eae] > s; \u1042 > j;\"", "           \"[\u0437\u0499\u04e1\u0909\u0993\u1012\u10d5\u10de] > 3; [\u0e1a\u0e9a] > u\"),", "       UTRANS_FORWARD, parse_error, status));", "   DCHECK(U_SUCCESS(status))", "       << \"Spoofchecker initalization failed due to an error: \"", "       << u_errorName(status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PHP_FUNCTION(imagecrop)", "{", "zval *IM;", "gdImagePtr im;", "gdImagePtr im_crop;", "gdRect rect;", "zval *z_rect;", "zval **tmp;", "", "if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {", "return;", "}", "", "ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);", "", "if (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {", "rect.x = Z_LVAL_PP(tmp);", "} else {", "php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");", "RETURN_FALSE;", "}", "", "if (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {", "rect.y = Z_LVAL_PP(tmp);", "} else {", "php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");", "RETURN_FALSE;", "}", "", "if (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {", "rect.width = Z_LVAL_PP(tmp);", "} else {", "php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");", "RETURN_FALSE;", "}", "", "if (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {", "rect.height = Z_LVAL_PP(tmp);", "} else {", "php_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");", "RETURN_FALSE;", "}", "", "im_crop = gdImageCrop(im, &rect);", "", "if (im_crop == NULL) {", "RETURN_FALSE;", "} else {", "ZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool ldb_dn_explode(struct ldb_dn *dn)", " {", " \tchar *p, *ex_name = NULL, *ex_value = NULL, *data, *d, *dt, *t;", " \tbool trim = true;", " \tbool in_extended = true;", " \tbool in_ex_name = false;", " \tbool in_ex_value = false;", " \tbool in_attr = false;", " \tbool in_value = false;", " \tbool in_quote = false;", " \tbool is_oid = false;", " \tbool escape = false;", " \tunsigned int x;", " \tsize_t l = 0;", " \tint ret;", " \tchar *parse_dn;", " \tbool is_index;", " ", " \tif ( ! dn || dn->invalid) return false;", " ", " \tif (dn->components) {", " \t\treturn true;", " \t}", " ", " \tif (dn->ext_linearized) {", " \t\tparse_dn = dn->ext_linearized;", " \t} else {", " \t\tparse_dn = dn->linearized;", " \t}", " ", " \tif ( ! parse_dn ) {", " \t\treturn false;", " \t}", " ", " \tis_index = (strncmp(parse_dn, \"DN=@INDEX:\", 10) == 0);", " ", " \t ", " \tif (parse_dn[0] == '\\0') {", " \t\treturn true;", " \t}", " ", " \t ", " \tif (dn->special) {", " \t\treturn true;", " \t}", " ", " \t ", " \tLDB_FREE(dn->components);", " \tdn->comp_num = 0;", " ", " \tLDB_FREE(dn->ext_components);", " \tdn->ext_comp_num = 0;", " ", " \t ", " \t ", " \tdn->components = talloc_zero_array(dn, struct ldb_dn_component, 3);", " \tif ( ! dn->components) {", " \t\treturn false;", " \t}", " ", " \t ", " \tdata = talloc_array(dn->components, char, strlen(parse_dn) + 1);", " \tif (!data) {", " \t\treturn false;", " \t}", " ", " \tp = parse_dn;", " \tt = NULL;", " \td = dt = data;", " ", " \twhile (*p) {", " \t\tif (in_extended) {", " ", " \t\t\tif (!in_ex_name && !in_ex_value) {", " ", " \t\t\t\tif (p[0] == '<') {", " \t\t\t\t\tp++;", " \t\t\t\t\tex_name = d;", " \t\t\t\t\tin_ex_name = true;", " \t\t\t\t\tcontinue;", " \t\t\t\t} else if (p[0] == '\\0') {", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t} else {", " \t\t\t\t\tin_extended = false;", " \t\t\t\t\tin_attr = true;", " \t\t\t\t\tdt = d;", " ", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tif (in_ex_name && *p == '=') {", " \t\t\t\t*d++ = '\\0';", " \t\t\t\tp++;", " \t\t\t\tex_value = d;", " \t\t\t\tin_ex_name = false;", " \t\t\t\tin_ex_value = true;", " \t\t\t\tcontinue;", " \t\t\t}", " ", " \t\t\tif (in_ex_value && *p == '>') {", " \t\t\t\tconst struct ldb_dn_extended_syntax *ext_syntax;", " \t\t\t\tstruct ldb_val ex_val = {", " \t\t\t\t\t.data = (uint8_t *)ex_value,", " \t\t\t\t\t.length = d - ex_value", " \t\t\t\t};", " ", " \t\t\t\t*d++ = '\\0';", " \t\t\t\tp++;", " \t\t\t\tin_ex_value = false;", " ", " \t\t\t\t ", " ", " \t\t\t\tdn->ext_components = talloc_realloc(dn,", " \t\t\t\t\t\t\t\t    dn->ext_components,", " \t\t\t\t\t\t\t\t    struct ldb_dn_ext_component,", " \t\t\t\t\t\t\t\t    dn->ext_comp_num + 1);", " \t\t\t\tif ( ! dn->ext_components) {", " \t\t\t\t\t ", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\text_syntax = ldb_dn_extended_syntax_by_name(dn->ldb, ex_name);", " \t\t\t\tif (!ext_syntax) {", " \t\t\t\t\t ", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\tdn->ext_components[dn->ext_comp_num].name = talloc_strdup(dn->ext_components, ex_name);", " \t\t\t\tif (!dn->ext_components[dn->ext_comp_num].name) {", " \t\t\t\t\t ", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " \t\t\t\tret = ext_syntax->read_fn(dn->ldb, dn->ext_components,", " \t\t\t\t\t\t\t  &ex_val, &dn->ext_components[dn->ext_comp_num].value);", " \t\t\t\tif (ret != LDB_SUCCESS) {", " \t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\tdn->ext_comp_num++;", " ", " \t\t\t\tif (*p == '\\0') {", " \t\t\t\t\t ", " \t\t\t\t\ttalloc_free(data);", " \t\t\t\t\treturn true;", " ", " \t\t\t\t} else if (*p == ';') {", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t} else {", " \t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\t*d++ = *p++;", " \t\t\tcontinue;", " \t\t}", " \t\tif (in_attr) {", " \t\t\tif (trim) {", " \t\t\t\tif (*p == ' ') {", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\ttrim = false;", " ", " \t\t\t\tif (!isascii(*p)) {", " \t\t\t\t\t ", " \t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\tif (isdigit(*p)) {", " \t\t\t\t\tis_oid = true;", " \t\t\t\t} else", " \t\t\t\tif ( ! isalpha(*p)) {", " \t\t\t\t\t ", " \t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\t*d++ = *p++;", " \t\t\t\tcontinue;", " \t\t\t}", " ", " \t\t\tif (*p == ' ') {", " \t\t\t\tp++;", " \t\t\t\t ", " \t\t\t\ttrim = true;", " \t\t\t\tcontinue;", " \t\t\t}", " ", " \t\t\tif (trim && (*p != '=')) {", " \t\t\t\t ", " \t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\tgoto failed;", " \t\t\t}", " ", " \t\t\tif (*p == '=') {", " \t\t\t\t ", " \t\t\t\tin_attr = false;", " \t\t\t\tin_value = true;", " \t\t\t\ttrim = true;", " \t\t\t\tl = 0;", " ", " \t\t\t\t ", " \t\t\t\t*d++ = '\\0';", " \t\t\t\tdn->components[dn->comp_num].name = talloc_strdup(dn->components, dt);", " \t\t\t\tif ( ! dn->components[dn->comp_num].name) {", " \t\t\t\t\t ", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " ", " \t\t\t\tdt = d;", " ", " \t\t\t\tp++;", " \t\t\t\tcontinue;", " \t\t\t}", " ", " \t\t\tif (!isascii(*p)) {", " \t\t\t\t ", " \t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\tgoto failed;", " \t\t\t}", " ", " \t\t\tif (is_oid && ( ! (isdigit(*p) || (*p == '.')))) {", " \t\t\t\t ", " \t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\tgoto failed;", " \t\t\t} else", " \t\t\tif ( ! (isalpha(*p) || isdigit(*p) || (*p == '-'))) {", " \t\t\t\t ", " \t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\tgoto failed;", " \t\t\t}", " ", " \t\t\t*d++ = *p++;", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (in_value) {", " \t\t\tif (in_quote) {", " \t\t\t\tif (*p == '\\\"') {", " \t\t\t\t\tif (p[-1] != '\\\\') {", " \t\t\t\t\t\tp++;", " \t\t\t\t\t\tin_quote = false;", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\t*d++ = *p++;", " \t\t\t\tl++;", " \t\t\t\tcontinue;", " \t\t\t}", " ", " \t\t\tif (trim) {", " \t\t\t\tif (*p == ' ') {", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\ttrim = false;", " ", " \t\t\t\tif (*p == '\\\"') {", " \t\t\t\t\tin_quote = true;", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tswitch (*p) {", " ", " \t\t\t ", " ", " \t\t\tcase ',':", " \t\t\t\tif (escape) {", " \t\t\t\t\t*d++ = *p++;", " \t\t\t\t\tl++;", " \t\t\t\t\tescape = false;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\t ", " ", " \t\t\t\tif ( t ) {", " \t\t\t\t\t ", " \t\t\t\t\td -= (p - t);", " \t\t\t\t\tl -= (p - t);", " \t\t\t\t}", " ", " \t\t\t\tin_attr = true;", " \t\t\t\tin_value = false;", " \t\t\t\ttrim = true;", "  ", "                                 p++;", "                                 *d++ = '\\0';", "                               dn->components[dn->comp_num].value.data = (uint8_t *)talloc_strdup(dn->components, dt);", "                                dn->components[dn->comp_num].value.data = \\", "                                        (uint8_t *)talloc_memdup(dn->components, dt, l + 1);", "                                 dn->components[dn->comp_num].value.length = l;", "                                 if ( ! dn->components[dn->comp_num].value.data) {", "                                          ", "                                         goto failed;", "                                 }", "                                talloc_set_name_const(dn->components[dn->comp_num].value.data,", "                                                      (const char *)dn->components[dn->comp_num].value.data);", "  ", "                                 dt = d;", "  ", " \t\t\t\t\t\t\t\t\tdn->components,", " \t\t\t\t\t\t\t\t\tstruct ldb_dn_component,", " \t\t\t\t\t\t\t\t\tdn->comp_num + 1);", " \t\t\t\t\tif ( ! dn->components) {", " \t\t\t\t\t\t ", " \t\t\t\t\t\tgoto failed;", " \t\t\t\t\t}", " \t\t\t\t\t ", " \t\t\t\t\tmemset(&dn->components[dn->comp_num], '\\0', sizeof(struct ldb_dn_component));", " \t\t\t\t}", " ", " \t\t\t\tcontinue;", " ", " \t\t\tcase '+':", " \t\t\tcase '=':", " \t\t\t\t ", " \t\t\t\tif (is_index) {", " \t\t\t\t\tif ( t ) t = NULL;", " \t\t\t\t\t*d++ = *p++;", " \t\t\t\t\tl++;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\t ", " \t\t\tcase '\\\"':", " \t\t\tcase '<':", " \t\t\tcase '>':", " \t\t\tcase ';':", " \t\t\t\t ", " \t\t\t\tif ( ! escape) {", " \t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\tgoto failed;", " \t\t\t\t}", " \t\t\t\tescape = false;", " ", " \t\t\t\t*d++ = *p++;", " \t\t\t\tl++;", " ", " \t\t\t\tif ( t ) t = NULL;", " \t\t\t\tbreak;", " ", " \t\t\tcase '\\\\':", " \t\t\t\tif ( ! escape) {", " \t\t\t\t\tescape = true;", " \t\t\t\t\tp++;", " \t\t\t\t\tcontinue;", " \t\t\t\t}", " \t\t\t\tescape = false;", " ", " \t\t\t\t*d++ = *p++;", " \t\t\t\tl++;", " ", " \t\t\t\tif ( t ) t = NULL;", " \t\t\t\tbreak;", " ", " \t\t\tdefault:", " \t\t\t\tif (escape) {", " \t\t\t\t\tif (isxdigit(p[0]) && isxdigit(p[1])) {", " \t\t\t\t\t\tif (sscanf(p, \"%02x\", &x) != 1) {", " \t\t\t\t\t\t\t ", " \t\t\t\t\t\t\tldb_dn_mark_invalid(dn);", " \t\t\t\t\t\t\tgoto failed;", " \t\t\t\t\t\t}", " \t\t\t\t\t\tp += 2;", " \t\t\t\t\t\t*d++ = (unsigned char)x;", " \t\t\t\t\t} else {", " \t\t\t\t\t\t*d++ = *p++;", " \t\t\t\t\t}", " ", " \t\t\t\t\tescape = false;", " \t\t\t\t\tl++;", " \t\t\t\t\tif ( t ) t = NULL;", " \t\t\t\t\tbreak;", " \t\t\t\t}", " ", " \t\t\t\tif (*p == ' ') {", " \t\t\t\t\tif ( ! t) t = p;", " \t\t\t\t} else {", " \t\t\t\t\tif ( t ) t = NULL;", " \t\t\t\t}", " ", " \t\t\t\t*d++ = *p++;", " \t\t\t\tl++;", " ", " \t\t\t\tbreak;", " \t\t\t}", " ", " \t\t}", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)", " \t{", " \tunsigned char wire[DTLS1_HM_HEADER_LENGTH];", " \tunsigned long len, frag_off, frag_len;", "         int i,al;", "         struct hm_header_st msg_hdr;", "  ", "        redo:", "          ", "         if ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)", "                 {", " \t\treturn frag_len;", " \t\t}", " ", " \t ", " \ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,wire,", " \t\tDTLS1_HM_HEADER_LENGTH, 0);", " \tif (i <= 0) \t ", " \t\t{", " \t\ts->rwstate=SSL_READING;", " \t\t*ok = 0;", " \t\treturn i;", " \t\t}", " \t ", " \tif (i != DTLS1_HM_HEADER_LENGTH)", " \t\t{", " \t\tal=SSL_AD_UNEXPECTED_MESSAGE;", " \t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);", " \t\tgoto f_err;", " \t\t}", " ", " \t ", " \tdtls1_get_message_header(wire, &msg_hdr);", " ", " \t ", " \tif (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))", " \t\treturn dtls1_process_out_of_seq_message(s, &msg_hdr, ok);", " ", " \tlen = msg_hdr.msg_len;", " \tfrag_off = msg_hdr.frag_off;", " \tfrag_len = msg_hdr.frag_len;", " ", " \tif (frag_len && frag_len < len)", " \t\treturn dtls1_reassemble_fragment(s, &msg_hdr, ok);", " ", " \tif (!s->server && s->d1->r_msg_hdr.frag_off == 0 &&", " \t\twire[0] == SSL3_MT_HELLO_REQUEST)", " \t\t{", " \t\t ", " \t\tif (wire[1] == 0 && wire[2] == 0 && wire[3] == 0)", " \t\t\t{", " \t\t\tif (s->msg_callback)", " \t\t\t\ts->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, ", " \t\t\t\t\twire, DTLS1_HM_HEADER_LENGTH, s, ", " \t\t\t\t\ts->msg_callback_arg);", "                                         s->msg_callback_arg);", "                         ", "                         s->init_num = 0;", "                       return dtls1_get_message_fragment(s, st1, stn,", "                               max, ok);", "                        goto redo;", "                         }", "                 else  ", "                         {", " \t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;", " \t\t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL_R_UNEXPECTED_MESSAGE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " ", " \tif ((al=dtls1_preprocess_fragment(s,&msg_hdr,max)))", " \t\tgoto f_err;", " ", " \t ", " \ts->state=stn;", " ", " \tif ( frag_len > 0)", " \t\t{", " \t\tunsigned char *p=(unsigned char *)s->init_buf->data+DTLS1_HM_HEADER_LENGTH;", " ", " \t\ti=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,", " \t\t\t&p[frag_off],frag_len,0);", " \t\t ", " \t\tif (i <= 0)", " \t\t\t{", " \t\t\ts->rwstate=SSL_READING;", " \t\t\t*ok = 0;", " \t\t\treturn i;", " \t\t\t}", " \t\t}", " \telse", " \t\ti = 0;", " ", " \t ", " \tif (i != (int)frag_len)", " \t\t{", " \t\tal=SSL3_AD_ILLEGAL_PARAMETER;", " \t\tSSLerr(SSL_F_DTLS1_GET_MESSAGE_FRAGMENT,SSL3_AD_ILLEGAL_PARAMETER);", " \t\tgoto f_err;", " \t\t}", " ", " \t*ok = 1;", " ", " \t ", " \ts->init_num = frag_len;", " \treturn frag_len;", " ", " f_err:", " \tssl3_send_alert(s,SSL3_AL_FATAL,al);", " \ts->init_num = 0;", " ", " \t*ok=0;", " \treturn(-1);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static pyc_object *get_list_object(RBuffer *buffer) {", "pyc_object *ret = NULL;", "bool error = false;", "ut32 n = 0;", "", "n = get_ut32 (buffer, &error);", "if (n > ST32_MAX) {", "eprintf (\"bad marshal data (list size out of range)\\n\");", "return NULL;", "}", "if (error) {", "return NULL;", "}", "ret = get_array_object_generic (buffer, n);", "if (ret) {", "ret->type = TYPE_LIST;", "return ret;", "}", "return NULL;", "}"], "ner_tags": [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)", " {", " \tTIFFPredictorState *sp = PredictorState(tif);", " ", " \tassert(sp != NULL);", " \tassert(sp->decoderow != NULL);", "  \tassert(sp->decodepfunc != NULL);  ", "  ", "  \tif ((*sp->decoderow)(tif, op0, occ0, s)) {", "\t\t(*sp->decodepfunc)(tif, op0, occ0);", "\t\treturn 1;", " \t\treturn (*sp->decodepfunc)(tif, op0, occ0);", "  \t} else", "  \t\treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" pdf_t *pdf_new(const char *name)", " {", "      const char *n;", "      pdf_t      *pdf;", "     ", "    pdf = calloc(1, sizeof(pdf_t));", "     pdf = safe_calloc(sizeof(pdf_t));", "  ", "      if (name)", "      {", "          ", "         if ((n = strrchr(name, '/')))", "           ++n;", "          else", "            n = name;", "  ", "        pdf->name = malloc(strlen(n) + 1);", "         pdf->name = safe_calloc(strlen(n) + 1);", "          strcpy(pdf->name, n);", "      }", "      else  ", "      {", "        pdf->name = malloc(strlen(\"Unknown\") + 1);", "         pdf->name = safe_calloc(strlen(\"Unknown\") + 1);", "          strcpy(pdf->name, \"Unknown\");", "      }", "  ", "     return pdf;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,", "  \t\t   unsigned int len)", "  {", "  \tstruct inet_sock *inet = inet_sk(sk);", "\tstruct {", "\t\tstruct ip_options\topt;", "\t\tchar\t\t\tdata[40];", "\t} replyopts;", " \tstruct ip_options_data replyopts;", "  \tstruct ipcm_cookie ipc;", "  \t__be32 daddr;", "  \tstruct rtable *rt = skb_rtable(skb);", "  ", "\tif (ip_options_echo(&replyopts.opt, skb))", " \tif (ip_options_echo(&replyopts.opt.opt, skb))", "  \t\treturn;", "  ", "  \tdaddr = ipc.addr = rt->rt_src;", "  \tipc.opt = NULL;", "  \tipc.tx_flags = 0;", "  ", "\tif (replyopts.opt.optlen) {", " \tif (replyopts.opt.opt.optlen) {", "  \t\tipc.opt = &replyopts.opt;", "  ", "\t\tif (ipc.opt->srr)", "\t\t\tdaddr = replyopts.opt.faddr;", " \t\tif (replyopts.opt.opt.srr)", " \t\t\tdaddr = replyopts.opt.opt.faddr;", "  \t}", "  ", "  \t{", " \t\tstruct flowi4 fl4;", " ", " \t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,", " \t\t\t\t   RT_TOS(ip_hdr(skb)->tos),", " \t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,", " \t\t\t\t   ip_reply_arg_flowi_flags(arg),", " \t\t\t\t   daddr, rt->rt_spec_dst,", " \t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);", " \t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));", " \t\trt = ip_route_output_key(sock_net(sk), &fl4);", " \t\tif (IS_ERR(rt))", " \t\t\treturn;", " \t}", " ", " \t ", " \tbh_lock_sock(sk);", " \tinet->tos = ip_hdr(skb)->tos;", " \tsk->sk_priority = skb->priority;", " \tsk->sk_protocol = ip_hdr(skb)->protocol;", " \tsk->sk_bound_dev_if = arg->bound_dev_if;", " \tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,", " \t\t       &ipc, &rt, MSG_DONTWAIT);", " \tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {", " \t\tif (arg->csumoffset >= 0)", " \t\t\t*((__sum16 *)skb_transport_header(skb) +", " \t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,", " \t\t\t\t\t\t\t\targ->csum));", " \t\tskb->ip_summed = CHECKSUM_NONE;", " \t\tip_push_pending_frames(sk);", " \t}", " ", " \tbh_unlock_sock(sk);", " ", " \tip_rt_put(rt);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" _rsvg_io_get_file_path (const gchar * filename,", "                         const gchar * base_uri)", "  {", "      gchar *absolute_filename;", "  ", "    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {", "     if (g_path_is_absolute (filename)) {", "          absolute_filename = g_strdup (filename);", "      } else {", "          gchar *tmpcdir;", "         gchar *base_filename;", " ", "         if (base_uri) {", "             base_filename = g_filename_from_uri (base_uri, NULL, NULL);", "             if (base_filename != NULL) {", "                 tmpcdir = g_path_get_dirname (base_filename);", "                 g_free (base_filename);", "             } else ", "                 return NULL;", "         } else", "             tmpcdir = g_get_current_dir ();", " ", "         absolute_filename = g_build_filename (tmpcdir, filename, NULL);", "         g_free (tmpcdir);", "     }", " ", "     return absolute_filename;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" IDNSpoofChecker::IDNSpoofChecker() {", "   UErrorCode status = U_ZERO_ERROR;", "   checker_ = uspoof_open(&status);", "   if (U_FAILURE(status)) {", "     checker_ = nullptr;", "     return;", "   }", " ", " ", "   uspoof_setRestrictionLevel(checker_, USPOOF_HIGHLY_RESTRICTIVE);", " ", "   SetAllowedUnicodeSet(&status);", " ", "   int32_t checks = uspoof_getChecks(checker_, &status) | USPOOF_AUX_INFO;", "   uspoof_setChecks(checker_, checks, &status);", " ", "   deviation_characters_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[\\\\u00df\\\\u03c2\\\\u200c\\\\u200d]\"), status);", "   deviation_characters_.freeze();", " ", "   non_ascii_latin_letters_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Latin:] - [a-zA-Z]]\"), status);", "   non_ascii_latin_letters_.freeze();", " ", "   kana_letters_exceptions_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[\\\\u3078-\\\\u307a\\\\u30d8-\\\\u30da\\\\u30fb-\\\\u30fe]\"),", "       status);", "   kana_letters_exceptions_.freeze();", "   combining_diacritics_exceptions_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[\\\\u0300-\\\\u0339]\"), status);", "   combining_diacritics_exceptions_.freeze();", " ", "   cyrillic_letters_latin_alike_ =", "       icu::UnicodeSet(icu::UnicodeString(\"[\u0430\u0441\u0501\u0435\u04bb\u0456\u0458\u04cf\u043e\u0440\u051b\u0455\u051d\u0445\u0443\u044a\u042c\u04bd\u043f\u0433\u0475\u0461]\"), status);", "   cyrillic_letters_latin_alike_.freeze();", " ", "   cyrillic_letters_ =", "       icu::UnicodeSet(UNICODE_STRING_SIMPLE(\"[[:Cyrl:]]\"), status);", "   cyrillic_letters_.freeze();", " ", "   DCHECK(U_SUCCESS(status));", "   lgc_letters_n_ascii_ = icu::UnicodeSet(", "       UNICODE_STRING_SIMPLE(\"[[:Latin:][:Greek:][:Cyrillic:][0-9\\\\u002e_\"", "                             \"\\\\u002d][\\\\u0300-\\\\u0339]]\"),", "       status);", "   lgc_letters_n_ascii_.freeze();", "  ", "    ", "    UParseError parse_error;", "  transliterator_.reset(icu::Transliterator::createFromRules(", "   diacritic_remover_.reset(icu::Transliterator::createFromRules(", "        UNICODE_STRING_SIMPLE(\"DropAcc\"),", "        icu::UnicodeString(\"::NFD; ::[:Nonspacing Mark:] Remove; ::NFC;\"", "                         \" \u0142 > l; \u00f8 > o; \u0111 > d; \u04cf > l; [\u043a\u0138\u03ba] > k; \u043f > n;\"),", "                          \" \u0142 > l; \u00f8 > o; \u0111 > d;\"),", "       UTRANS_FORWARD, parse_error, status));", " ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "   extra_confusable_mapper_.reset(icu::Transliterator::createFromRules(", "       UNICODE_STRING_SIMPLE(\"ExtraConf\"),", "       icu::UnicodeString(", "           \"\u04cf > l; [\u043a\u0138\u03ba] > k; \u043f > n; [\u0185\u044c] > b; \u0432 > b; \u043c > m; \u043d > h; \"", "           \"\u0442 > t; [\u0448\u0449] > w; \u0d1f > s;\"),", "        UTRANS_FORWARD, parse_error, status));", "    DCHECK(U_SUCCESS(status))", "        << \"Spoofchecker initalization failed due to an error: \"", "       << u_errorName(status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows(ExecState* exec)", " {", "     JSValue thisValue = exec->hostThisValue();", "     if (!thisValue.inherits(&JSTestObj::s_info))", "         return throwVMTypeError(exec);", "     JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));", "      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);", "      TestObj* impl = static_cast<TestObj*>(castedThis->impl());", "      if (exec->argumentCount() < 2)", "        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));", "         return throwVMError(exec, createNotEnoughArgumentsError(exec));", "      ExceptionCode ec = 0;", "      const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));", "      if (exec->hadException())", "         return JSValue::encode(jsUndefined());", "     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));", "     if (exec->hadException())", "         return JSValue::encode(jsUndefined());", " ", "     JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(impl->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec)));", "     setDOMException(exec, ec);", "     return JSValue::encode(result);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const", "  {", "      USHORT Res;", "      auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),", "                                       GetDataLength(), __FUNCTION__);", "                                        GetDataLength(), FALSE, __FUNCTION__);", "      if (ppr.ipStatus != ppresNotIP)", "      {", "          Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);", "     }", "     else", "     {", "         DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));", "         Res = 0;", "     }", "     return Res;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" _handle_carbons(xmpp_stanza_t *const stanza)", " {", "     xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);", "     if (!carbons) {", "         return FALSE;", "     }", " ", "     const char *name = xmpp_stanza_get_name(carbons);", "     if (!name) {", "         log_error(\"Unable to retrieve stanza name for Carbon\");", "         return TRUE;", "     }", " ", "     if (g_strcmp0(name, \"private\") == 0) {", "         log_info(\"Carbon received with private element.\");", "         return FALSE;", "     }", " ", "     if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {", "         log_warning(\"Carbon received with unrecognised stanza name: %s\", name);", "         return TRUE;", "     }", " ", "     xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);", "     if (!forwarded) {", "         log_warning(\"Carbon received with no forwarded element\");", "         return TRUE;", "     }", " ", "     xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);", "     if (!message) {", "         log_warning(\"Carbon received with no message element\");", "         return TRUE;", "     }", " ", "     char *message_txt = xmpp_message_get_body(message);", "     if (!message_txt) {", "         log_warning(\"Carbon received with no message.\");", "          return TRUE;", "      }", "  ", "     Jid *my_jid = jid_create(connection_get_fulljid());", "     const char *const stanza_from = xmpp_stanza_get_from(stanza);", "     Jid *msg_jid = jid_create(stanza_from);", "     if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {", "         log_warning(\"Invalid carbon received, from: %s\", stanza_from);", "         return TRUE;", "     }", " ", "      const gchar *to = xmpp_stanza_get_to(message);", "      const gchar *from = xmpp_stanza_get_from(message);", "  ", "     if (!to) to = from;", "  ", "      Jid *jid_from = jid_create(from);", "      Jid *jid_to = jid_create(to);", "    Jid *my_jid = jid_create(connection_get_fulljid());", "  ", "      char *enc_message = NULL;", "     xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);", "     if (x) {", "         enc_message = xmpp_stanza_get_text(x);", "     }", " ", "     if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {", "         sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);", " ", "     } else {", "         sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);", "     }", " ", "     xmpp_ctx_t *ctx = connection_get_ctx();", "     xmpp_free(ctx, message_txt);", "     xmpp_free(ctx, enc_message);", " ", "     jid_destroy(jid_from);", "     jid_destroy(jid_to);", "     jid_destroy(my_jid);", " ", "     return TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void FormAssociatedElement::formRemovedFromTree(const Node* formRoot)", "  {", "      ASSERT(m_form);", "    if (toHTMLElement(this)->highestAncestor() != formRoot)", "        setForm(0);", "     if (toHTMLElement(this)->highestAncestor() == formRoot)", "         return;", "     RefPtr<HTMLElement> protector(toHTMLElement(this));", "     setForm(0);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" void RequestSender::OnNetworkFetcherComplete(", "     const GURL& original_url,", "     std::unique_ptr<std::string> response_body,", "     int net_error,", "     const std::string& header_etag,", "     int64_t xheader_retry_after_sec) {", "   DCHECK(thread_checker_.CalledOnValidThread());", " ", "    VLOG(1) << \"request completed from url: \" << original_url.spec();", "  ", "    int error = -1;", "  if (response_body && response_code_ == 200) {", "    DCHECK_EQ(0, net_error);", "   if (!net_error && response_code_ == 200)", "      error = 0;", "  } else if (response_code_ != -1) {", "   else if (response_code_ != -1)", "      error = response_code_;", "  } else {", "   else", "      error = net_error;", "  }", "  ", "    int retry_after_sec = -1;", "    if (original_url.SchemeIsCryptographic() && error > 0)", "     retry_after_sec = base::saturated_cast<int>(xheader_retry_after_sec);", " ", "   base::ThreadTaskRunnerHandle::Get()->PostTask(", "       FROM_HERE, base::BindOnce(&RequestSender::SendInternalComplete,", "                                 base::Unretained(this), error,", "                                 response_body ? *response_body : std::string(),", "                                 header_etag, retry_after_sec));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)", "  {", "  \tstruct crypto_report_cipher rcipher;", "  ", "\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));", " \tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));", "  ", "  \trcipher.blocksize = alg->cra_blocksize;", "  \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;", " \trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;", " ", " \tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,", " \t\t    sizeof(struct crypto_report_cipher), &rcipher))", " \t\tgoto nla_put_failure;", " \treturn 0;", " ", " nla_put_failure:", " \treturn -EMSGSIZE;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void Com_WriteConfig_f( void ) {", " \tchar filename[MAX_QPATH];", " ", " \tif ( Cmd_Argc() != 2 ) {", " \t\tCom_Printf( \"Usage: writeconfig <filename>\\n\" );", "  \t\treturn;", "  \t}", "  ", " \tif (!COM_CompareExtension(filename, \".cfg\"))", " \t{", " \t\tCom_Printf(\"Com_WriteConfig_f: Only the \\\".cfg\\\" extension is supported by this command!\\n\");", " \t\treturn;", " \t}", " ", "  \tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );", "  \tCOM_DefaultExtension( filename, sizeof( filename ), \".cfg\" );", "  \tCom_Printf( \"Writing %s.\\n\", filename );", " \tCom_WriteConfigToFile( filename );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)", " {", " \tvoid __user *p = (void __user *)arg;", " \tint __user *ip = p;", " \tint result, val, read_only;", " \tSg_device *sdp;", " \tSg_fd *sfp;", " \tSg_request *srp;", " \tunsigned long iflags;", " ", " \tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))", " \t\treturn -ENXIO;", " ", " \tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,", " \t\t\t\t   \"sg_ioctl: cmd=0x%x\\n\", (int) cmd_in));", " \tread_only = (O_RDWR != (filp->f_flags & O_ACCMODE));", " ", " \tswitch (cmd_in) {", " \tcase SG_IO:", " \t\tif (atomic_read(&sdp->detaching))", " \t\t\treturn -ENODEV;", " \t\tif (!scsi_block_when_processing_errors(sdp->device))", " \t\t\treturn -ENXIO;", " \t\tif (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))", " \t\t\treturn -EFAULT;", " \t\tresult = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,", " \t\t\t\t 1, read_only, 1, &srp);", " \t\tif (result < 0)", " \t\t\treturn result;", " \t\tresult = wait_event_interruptible(sfp->read_wait,", " \t\t\t(srp_done(sfp, srp) || atomic_read(&sdp->detaching)));", " \t\tif (atomic_read(&sdp->detaching))", " \t\t\treturn -ENODEV;", " \t\twrite_lock_irq(&sfp->rq_list_lock);", " \t\tif (srp->done) {", " \t\t\tsrp->done = 2;", " \t\t\twrite_unlock_irq(&sfp->rq_list_lock);", " \t\t\tresult = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp);", " \t\t\treturn (result < 0) ? result : 0;", " \t\t}", " \t\tsrp->orphan = 1;", " \t\twrite_unlock_irq(&sfp->rq_list_lock);", " \t\treturn result;\t ", " \tcase SG_SET_TIMEOUT:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tif (val < 0)", " \t\t\treturn -EIO;", " \t\tif (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ))", " \t\t\tval = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ),", " \t\t\t\t    INT_MAX);", " \t\tsfp->timeout_user = val;", " \t\tsfp->timeout = mult_frac(val, HZ, USER_HZ);", " ", " \t\treturn 0;", " \tcase SG_GET_TIMEOUT:\t ", " \t\t\t\t ", " \t\treturn sfp->timeout_user;", " \tcase SG_SET_FORCE_LOW_DMA:", " \t\t ", " \t\treturn 0;", " \tcase SG_GET_LOW_DMA:", " \t\treturn put_user((int) sdp->device->host->unchecked_isa_dma, ip);", " \tcase SG_GET_SCSI_ID:", " \t\tif (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t)))", " \t\t\treturn -EFAULT;", " \t\telse {", " \t\t\tsg_scsi_id_t __user *sg_idp = p;", " ", " \t\t\tif (atomic_read(&sdp->detaching))", " \t\t\t\treturn -ENODEV;", " \t\t\t__put_user((int) sdp->device->host->host_no,", " \t\t\t\t   &sg_idp->host_no);", " \t\t\t__put_user((int) sdp->device->channel,", " \t\t\t\t   &sg_idp->channel);", " \t\t\t__put_user((int) sdp->device->id, &sg_idp->scsi_id);", " \t\t\t__put_user((int) sdp->device->lun, &sg_idp->lun);", " \t\t\t__put_user((int) sdp->device->type, &sg_idp->scsi_type);", " \t\t\t__put_user((short) sdp->device->host->cmd_per_lun,", " \t\t\t\t   &sg_idp->h_cmd_per_lun);", " \t\t\t__put_user((short) sdp->device->queue_depth,", " \t\t\t\t   &sg_idp->d_queue_depth);", " \t\t\t__put_user(0, &sg_idp->unused[0]);", " \t\t\t__put_user(0, &sg_idp->unused[1]);", " \t\t\treturn 0;", " \t\t}", " \tcase SG_SET_FORCE_PACK_ID:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tsfp->force_packid = val ? 1 : 0;", " \t\treturn 0;", " \tcase SG_GET_PACK_ID:", " \t\tif (!access_ok(VERIFY_WRITE, ip, sizeof (int)))", " \t\t\treturn -EFAULT;", " \t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);", " \t\tlist_for_each_entry(srp, &sfp->rq_list, entry) {", " \t\t\tif ((1 == srp->done) && (!srp->sg_io_owned)) {", " \t\t\t\tread_unlock_irqrestore(&sfp->rq_list_lock,", " \t\t\t\t\t\t       iflags);", " \t\t\t\t__put_user(srp->header.pack_id, ip);", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t}", " \t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);", " \t\t__put_user(-1, ip);", " \t\treturn 0;", " \tcase SG_GET_NUM_WAITING:", " \t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);", " \t\tval = 0;", " \t\tlist_for_each_entry(srp, &sfp->rq_list, entry) {", " \t\t\tif ((1 == srp->done) && (!srp->sg_io_owned))", " \t\t\t\t++val;", " \t\t}", " \t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);", " \t\treturn put_user(val, ip);", " \tcase SG_GET_SG_TABLESIZE:", " \t\treturn put_user(sdp->sg_tablesize, ip);", " \tcase SG_SET_RESERVED_SIZE:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", "                 if (val < 0)", "                         return -EINVAL;", " \t\tval = min_t(int, val,", " \t\t\t    max_sectors_bytes(sdp->device->request_queue));", " \t\tmutex_lock(&sfp->f_mutex);", " \t\tif (val != sfp->reserve.bufflen) {", " \t\t\tif (sfp->mmap_called ||", " \t\t\t    sfp->res_in_use) {", " \t\t\t\tmutex_unlock(&sfp->f_mutex);", " \t\t\t\treturn -EBUSY;", " \t\t\t}", " ", " \t\t\tsg_remove_scat(sfp, &sfp->reserve);", " \t\t\tsg_build_reserve(sfp, val);", " \t\t}", " \t\tmutex_unlock(&sfp->f_mutex);", " \t\treturn 0;", " \tcase SG_GET_RESERVED_SIZE:", " \t\tval = min_t(int, sfp->reserve.bufflen,", " \t\t\t    max_sectors_bytes(sdp->device->request_queue));", " \t\treturn put_user(val, ip);", " \tcase SG_SET_COMMAND_Q:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tsfp->cmd_q = val ? 1 : 0;", " \t\treturn 0;", " \tcase SG_GET_COMMAND_Q:", " \t\treturn put_user((int) sfp->cmd_q, ip);", " \tcase SG_SET_KEEP_ORPHAN:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tsfp->keep_orphan = val;", " \t\treturn 0;", " \tcase SG_GET_KEEP_ORPHAN:", " \t\treturn put_user((int) sfp->keep_orphan, ip);", " \tcase SG_NEXT_CMD_LEN:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tif (val > SG_MAX_CDB_SIZE)", " \t\t\treturn -ENOMEM;", " \t\tsfp->next_cmd_len = (val > 0) ? val : 0;", " \t\treturn 0;", " \tcase SG_GET_VERSION_NUM:", " \t\treturn put_user(sg_version_num, ip);", " \tcase SG_GET_ACCESS_COUNT:", " \t\t ", " \t\tval = (sdp->device ? 1 : 0);", " \t\treturn put_user(val, ip);", " \tcase SG_GET_REQUEST_TABLE:", " \t\tif (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE))", " \t\t\treturn -EFAULT;", "  \t\telse {", "  \t\t\tsg_req_info_t *rinfo;", "  ", "\t\t\trinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,", "\t\t\t\t\t\t\t\tGFP_KERNEL);", " \t\t\trinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,", " \t\t\t\t\tGFP_KERNEL);", "  \t\t\tif (!rinfo)", "  \t\t\t\treturn -ENOMEM;", "  \t\t\tread_lock_irqsave(&sfp->rq_list_lock, iflags);", " \t\t\tsg_fill_request_table(sfp, rinfo);", " \t\t\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);", " \t\t\tresult = __copy_to_user(p, rinfo,", " \t\t\t\t\t\tSZ_SG_REQ_INFO * SG_MAX_QUEUE);", " \t\t\tresult = result ? -EFAULT : 0;", " \t\t\tkfree(rinfo);", " \t\t\treturn result;", " \t\t}", " \tcase SG_EMULATED_HOST:", " \t\tif (atomic_read(&sdp->detaching))", " \t\t\treturn -ENODEV;", " \t\treturn put_user(sdp->device->host->hostt->emulated, ip);", " \tcase SCSI_IOCTL_SEND_COMMAND:", " \t\tif (atomic_read(&sdp->detaching))", " \t\t\treturn -ENODEV;", " \t\tif (read_only) {", " \t\t\tunsigned char opcode = WRITE_6;", " \t\t\tScsi_Ioctl_Command __user *siocp = p;", " ", " \t\t\tif (copy_from_user(&opcode, siocp->data, 1))", " \t\t\t\treturn -EFAULT;", " \t\t\tif (sg_allow_access(filp, &opcode))", " \t\t\t\treturn -EPERM;", " \t\t}", " \t\treturn sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p);", " \tcase SG_SET_DEBUG:", " \t\tresult = get_user(val, ip);", " \t\tif (result)", " \t\t\treturn result;", " \t\tsdp->sgdebug = (char) val;", " \t\treturn 0;", " \tcase BLKSECTGET:", " \t\treturn put_user(max_sectors_bytes(sdp->device->request_queue),", " \t\t\t\tip);", " \tcase BLKTRACESETUP:", " \t\treturn blk_trace_setup(sdp->device->request_queue,", " \t\t\t\t       sdp->disk->disk_name,", " \t\t\t\t       MKDEV(SCSI_GENERIC_MAJOR, sdp->index),", " \t\t\t\t       NULL, p);", " \tcase BLKTRACESTART:", " \t\treturn blk_trace_startstop(sdp->device->request_queue, 1);", " \tcase BLKTRACESTOP:", " \t\treturn blk_trace_startstop(sdp->device->request_queue, 0);", " \tcase BLKTRACETEARDOWN:", " \t\treturn blk_trace_remove(sdp->device->request_queue);", " \tcase SCSI_IOCTL_GET_IDLUN:", " \tcase SCSI_IOCTL_GET_BUS_NUMBER:", " \tcase SCSI_IOCTL_PROBE_HOST:", " \tcase SG_GET_TRANSFORM:", " \tcase SG_SCSI_RESET:", " \t\tif (atomic_read(&sdp->detaching))", " \t\t\treturn -ENODEV;", " \t\tbreak;", " \tdefault:", " \t\tif (read_only)", " \t\t\treturn -EPERM;\t ", " \t\tbreak;", " \t}", " ", " \tresult = scsi_ioctl_block_when_processing_errors(sdp->device,", " \t\t\tcmd_in, filp->f_flags & O_NDELAY);", " \tif (result)", " \t\treturn result;", " \treturn scsi_ioctl(sdp->device, cmd_in, p);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,", "                       X509 **pissuer, int *pscore, unsigned int *preasons,", "                       STACK_OF(X509_CRL) *crls)", " {", "     int i, crl_score, best_score = *pscore;", "     unsigned int reasons, best_reasons = 0;", "     X509 *x = ctx->current_cert;", "     X509_CRL *crl, *best_crl = NULL;", "     X509 *crl_issuer = NULL, *best_crl_issuer = NULL;", " ", "     for (i = 0; i < sk_X509_CRL_num(crls); i++) {", "          crl = sk_X509_CRL_value(crls, i);", "          reasons = *preasons;", "          crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);", "        if (crl_score < best_score)", "         if (crl_score < best_score || crl_score == 0)", "              continue;", "           ", "        if (crl_score == best_score) {", "         if (crl_score == best_score && best_crl != NULL) {", "              int day, sec;", "              if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),", "                                 X509_CRL_get_lastUpdate(crl)) == 0)", "                 continue;", "              ", "             if (day <= 0 && sec <= 0)", "                 continue;", "         }", "         best_crl = crl;", "         best_crl_issuer = crl_issuer;", "         best_score = crl_score;", "         best_reasons = reasons;", "     }", " ", "     if (best_crl) {", "         if (*pcrl)", "             X509_CRL_free(*pcrl);", "         *pcrl = best_crl;", "         *pissuer = best_crl_issuer;", "         *pscore = best_score;", "         *preasons = best_reasons;", "         CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);", "         if (*pdcrl) {", "             X509_CRL_free(*pdcrl);", "             *pdcrl = NULL;", "         }", "         get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);", "     }", " ", "     if (best_score >= CRL_SCORE_VALID)", "         return 1;", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["testHuf (const std::string&)", "{", "try", "{", "cout << \"Testing Huffman encoder\" << endl;", "", "IMATH_NAMESPACE::Rand48 rand48 (0);", "", "const int N = 1000000;", "Array <unsigned short> raw (N);", "", "fill1 (raw, N, 1, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill1 (raw, N, 10, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill1 (raw, N, 100, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill1 (raw, N, 1000, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "", "fill2 (raw, N, 1, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill2 (raw, N, 10, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill2 (raw, N, 100, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill2 (raw, N, 1000, rand48);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "", "fill3 (raw, N, 0);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill3 (raw, N, 1);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill3 (raw, N, USHRT_MAX - 1);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "fill3 (raw, N, USHRT_MAX);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "", "fill4 (raw, USHRT_MAX + 1);", "compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);", "compressUncompress (raw, USHRT_MAX + 1);", "compressUncompressSubset (raw, USHRT_MAX + 1);", "fill4 (raw, N);", "compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "", "fill4 (raw, 0);", "compressUncompress (raw, 0);", "fill4 (raw, 1);", "compressUncompress (raw, 1);", "fill4 (raw, 2);", "compressUncompress (raw, 2);", "fill4 (raw, 3);", "compressUncompress (raw, 3);", "", "fill5 (raw, N);", "compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);", "compressUncompress (raw, N);", "compressUncompressSubset (raw, N);", "", "cout << \"ok\\n\" << endl;", "}", "catch (const std::exception &e)", "{", "cerr << \"ERROR -- caught exception: \" << e.what() << endl;", "assert (false);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void RemoteFsDevice::unmount()", "{", "if (details.isLocalFile()) {", "return;", "}", "", "if (!isConnected() || proc) {", "return;", "}", "", "if (messageSent) {", "return;", "}", "if (constSambaProtocol==details.url.scheme() || constSambaAvahiProtocol==details.url.scheme()) {", "mounter()->umount(mountPoint(details, false), getpid());", "setStatusMessage(tr(\"Disconnecting...\"));", "messageSent=true;", "return;", "}", "", "QString cmd;", "QStringList args;", "if (!details.isLocalFile()) {", "QString mp=mountPoint(details, false);", "if (!mp.isEmpty()) {", "cmd=Utils::findExe(\"fusermount\");", "if (!cmd.isEmpty()) {", "args << QLatin1String(\"-u\") << QLatin1String(\"-z\") << mp;", "} else {", "emit error(tr(\"\\\"fusermount\\\" is not installed!\"));", "}", "}", "}", "", "if (!cmd.isEmpty()) {", "setStatusMessage(tr(\"Disconnecting...\"));", "proc=new QProcess(this);", "proc->setProperty(\"unmount\", true);", "connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));", "proc->start(cmd, args, QIODevice::ReadOnly);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void SoftMPEG4::onQueueFilled(OMX_U32  ) {", "  if (mSignalledError || mOutputPortSettingsChange != NONE) {", "  return;", "  }", " ", "  List<BufferInfo *> &inQueue = getPortQueue(0);", "  List<BufferInfo *> &outQueue = getPortQueue(1);", " ", "  while (!inQueue.empty() && outQueue.size() == kNumOutputBuffers) {", "  BufferInfo *inInfo = *inQueue.begin();", "         OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader;", "  if (inHeader == NULL) {", "             inQueue.erase(inQueue.begin());", "             inInfo->mOwnedByUs = false;", "  continue;", "  }", " ", "  PortInfo *port = editPortInfo(1);", " ", "         OMX_BUFFERHEADERTYPE *outHeader =", "             port->mBuffers.editItemAt(mNumSamplesOutput & 1).mHeader;", " ", "  if (inHeader->nFilledLen == 0) {", "             inQueue.erase(inQueue.begin());", "             inInfo->mOwnedByUs = false;", "             notifyEmptyBufferDone(inHeader);", " ", "  ++mInputBufferCount;", " ", "  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {", "                 outHeader->nFilledLen = 0;", "                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;", " ", "  List<BufferInfo *>::iterator it = outQueue.begin();", "  while ((*it)->mHeader != outHeader) {", "  ++it;", "  }", " ", "  BufferInfo *outInfo = *it;", "                 outInfo->mOwnedByUs = false;", "                 outQueue.erase(it);", "                 outInfo = NULL;", " ", "                 notifyFillBufferDone(outHeader);", "                 outHeader = NULL;", "  }", "  return;", "  }", " ", "  uint8_t *bitstream = inHeader->pBuffer + inHeader->nOffset;", "  uint32_t *start_code = (uint32_t *)bitstream;", "  bool volHeader = *start_code == 0xB0010000;", "  if (volHeader) {", "  PVCleanUpVideoDecoder(mHandle);", "             mInitialized = false;", "  }", " ", "  if (!mInitialized) {", "  uint8_t *vol_data[1];", "  int32_t vol_size = 0;", " ", "             vol_data[0] = NULL;", " ", "  if ((inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) || volHeader) {", "                 vol_data[0] = bitstream;", "                 vol_size = inHeader->nFilledLen;", "  }", " ", "             MP4DecodingMode mode =", "  (mMode == MODE_MPEG4) ? MPEG4_MODE : H263_MODE;", " ", "  Bool success = PVInitVideoDecoder(", "                     mHandle, vol_data, &vol_size, 1,", "                     outputBufferWidth(), outputBufferHeight(), mode);", " ", "  if (!success) {", "                 ALOGW(\"PVInitVideoDecoder failed. Unsupported content?\");", " ", "                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "                 mSignalledError = true;", "  return;", "  }", " ", "             MP4DecodingMode actualMode = PVGetDecBitstreamMode(mHandle);", "  if (mode != actualMode) {", "                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "                 mSignalledError = true;", "  return;", "  }", " ", "  PVSetPostProcType((VideoDecControls *) mHandle, 0);", " ", "  bool hasFrameData = false;", "  if (inHeader->nFlags & OMX_BUFFERFLAG_CODECCONFIG) {", "                 inInfo->mOwnedByUs = false;", "                 inQueue.erase(inQueue.begin());", "                 inInfo = NULL;", "                 notifyEmptyBufferDone(inHeader);", "                 inHeader = NULL;", "  } else if (volHeader) {", "                 hasFrameData = true;", "  }", " ", "             mInitialized = true;", " ", "  if (mode == MPEG4_MODE && handlePortSettingsChange()) {", "  return;", "  }", " ", "  if (!hasFrameData) {", "  continue;", "  }", "  }", " ", "  if (!mFramesConfigured) {", " ", "              PortInfo *port = editPortInfo(1);", "              OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;", "  ", "             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;", "             if ((outHeader->nAllocLen < yFrameSize) ||", "                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {", "                 ALOGE(\"Too small output buffer for reference frame: %zu bytes\",", "                         outHeader->nAllocLen);", "                 android_errorWriteLog(0x534e4554, \"30033990\");", "                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "                 mSignalledError = true;", "                 return;", "             }", "              PVSetReferenceYUV(mHandle, outHeader->pBuffer);", "              mFramesConfigured = true;", "          }", "  ", "  uint32_t useExtTimestamp = (inHeader->nOffset == 0);", " ", "  uint32_t timestamp = 0xFFFFFFFF;", "  if (useExtTimestamp) {", "             mPvToOmxTimeMap.add(mPvTime, inHeader->nTimeStamp);", "             timestamp = mPvTime;", "             mPvTime++;", "  }", " ", " ", "          int32_t bufferSize = inHeader->nFilledLen;", "          int32_t tmp = bufferSize;", "  ", "        OMX_U32 frameSize = (mWidth * mHeight * 3) / 2;", "         OMX_U32 frameSize;", "         OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;", "         if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {", "             ALOGE(\"Frame size too large\");", "             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "             mSignalledError = true;", "             return;", "         }", "         frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));", " ", "          if (outHeader->nAllocLen < frameSize) {", "              android_errorWriteLog(0x534e4554, \"27833616\");", "              ALOGE(\"Insufficient output buffer size\");", "             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "             mSignalledError = true;", "  return;", "  }", "  if (PVDecodeVideoFrame(", "                     mHandle, &bitstream, &timestamp, &tmp,", "  &useExtTimestamp,", "                     outHeader->pBuffer) != PV_TRUE) {", "             ALOGE(\"failed to decode video frame.\");", " ", "             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);", "             mSignalledError = true;", "  return;", "  }", " ", "  if (handlePortSettingsChange()) {", "  return;", "  }", " ", "         outHeader->nTimeStamp = mPvToOmxTimeMap.valueFor(timestamp);", "         mPvToOmxTimeMap.removeItem(timestamp);", " ", "         inHeader->nOffset += bufferSize;", "         inHeader->nFilledLen = 0;", "  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {", "             outHeader->nFlags = OMX_BUFFERFLAG_EOS;", "  } else {", "             outHeader->nFlags = 0;", "  }", " ", "  if (inHeader->nFilledLen == 0) {", "             inInfo->mOwnedByUs = false;", "             inQueue.erase(inQueue.begin());", "             inInfo = NULL;", "             notifyEmptyBufferDone(inHeader);", "             inHeader = NULL;", "  }", " ", "  ++mInputBufferCount;", " ", "         outHeader->nOffset = 0;", "         outHeader->nFilledLen = frameSize;", " ", "  List<BufferInfo *>::iterator it = outQueue.begin();", "  while ((*it)->mHeader != outHeader) {", "  ++it;", "  }", " ", "  BufferInfo *outInfo = *it;", "         outInfo->mOwnedByUs = false;", "         outQueue.erase(it);", "         outInfo = NULL;", " ", "         notifyFillBufferDone(outHeader);", "         outHeader = NULL;", " ", "  ++mNumSamplesOutput;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)", " {", "   char q_user[SHORT_STRING], q_pass[SHORT_STRING];", "   char buf[STRING];", "   int rc;", " ", "   if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))", "   {", "     mutt_message(_(\"LOGIN disabled on this server.\"));", "     return IMAP_AUTH_UNAVAIL;", "   }", " ", "   if (mutt_account_getuser(&idata->conn->account) < 0)", "     return IMAP_AUTH_FAILURE;", "   if (mutt_account_getpass(&idata->conn->account) < 0)", "     return IMAP_AUTH_FAILURE;", "  ", "    mutt_message(_(\"Logging in...\"));", "  ", "  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);", "  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);", "   imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);", "   imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);", "  ", "     ", " ", "   if (DebugLevel < IMAP_LOG_PASS)", "     mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);", " ", "   snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);", "   rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);", " ", "   if (!rc)", "   {", "     mutt_clear_error();  ", "     return IMAP_AUTH_SUCCESS;", "   }", " ", "   mutt_error(_(\"Login failed.\"));", "   return IMAP_AUTH_FAILURE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void HierarchicalBitmapRequester::PrepareForDecoding(void)", "{", "#if ACCUSOFT_CODE", "", "UBYTE i;", "", "BuildCommon();", "", "if (m_ppDecodingMCU == NULL) {", "m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);", "memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);", "}", "", "if (m_ppUpsampler == NULL) {", "m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);", "memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);", "", "for(i = 0;i < m_ucCount;i++) {", "class Component *comp = m_pFrame->ComponentOf(i);", "UBYTE sx = comp->SubXOf();", "UBYTE sy = comp->SubYOf();", "", "if (sx > 1 || sy > 1) {", "m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,", "m_ulPixelWidth,m_ulPixelHeight,", "m_pFrame->TablesOf()->isChromaCentered());", "m_bSubsampling   = true;", "}", "}", "}", "", "if (m_pLargestScale)", "m_pLargestScale->PrepareForDecoding();", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["generate_loadvar(", "cctx_T  *cctx,", "assign_dest_T dest,", "char_u  *name,", "lvar_T  *lvar,", "type_T  *type)", "{", "switch (dest)", "{", "case dest_option:", "case dest_func_option:", "generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);", "break;", "case dest_global:", "if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)", "{", "if (name[2] == NUL)", "generate_instr_type(cctx, ISN_LOADGDICT, &t_dict_any);", "else", "generate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);", "}", "else", "generate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);", "break;", "case dest_buffer:", "generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);", "break;", "case dest_window:", "generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);", "break;", "case dest_tab:", "generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);", "break;", "case dest_script:", "compile_load_scriptvar(cctx,", "name + (name[1] == ':' ? 2 : 0), NULL, NULL);", "break;", "case dest_env:", "", "generate_LOAD(cctx, ISN_LOADENV, 0, name, type);", "break;", "case dest_reg:", "generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);", "break;", "case dest_vimvar:", "generate_LOADV(cctx, name + 2);", "break;", "case dest_local:", "if (lvar->lv_from_outer > 0)", "generate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,", "type);", "else", "generate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);", "break;", "case dest_expr:", "", "break;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  tiffcp(TIFF* in, TIFF* out)", "  {", "\tuint16 bitspersample, samplesperpixel;", "\tuint16 input_compression, input_photometric;", " \tuint16 bitspersample, samplesperpixel = 1;", " \tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;", "  \tcopyFunc cf;", "  \tuint32 width, length;", "  \tstruct cpTag* p;", " ", " \tCopyField(TIFFTAG_IMAGEWIDTH, width);", " \tCopyField(TIFFTAG_IMAGELENGTH, length);", " \tCopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);", " \tCopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);", " \tif (compression != (uint16)-1)", " \t\tTIFFSetField(out, TIFFTAG_COMPRESSION, compression);", " \telse", " \t\tCopyField(TIFFTAG_COMPRESSION, compression);", " \tTIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);", " \tTIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);", " \tif (input_compression == COMPRESSION_JPEG) {", " \t\t ", " \t\tTIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);", " \t} else if (input_photometric == PHOTOMETRIC_YCBCR) {", " \t\t ", " \t\tuint16 subsamplinghor,subsamplingver;", " ", " \t\tTIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,", " \t\t\t\t      &subsamplinghor, &subsamplingver);", " \t\tif (subsamplinghor!=1 || subsamplingver!=1) {", " \t\t\tfprintf(stderr, \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",", " \t\t\t\tTIFFFileName(in));", " \t\t\treturn FALSE;", " \t\t}", " \t}", " \tif (compression == COMPRESSION_JPEG) {", " \t\tif (input_photometric == PHOTOMETRIC_RGB &&", " \t\t    jpegcolormode == JPEGCOLORMODE_RGB)", " \t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);", " \t\telse", " \t\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);", " \t}", " \telse if (compression == COMPRESSION_SGILOG", " \t    || compression == COMPRESSION_SGILOG24)", " \t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC,", " \t\t    samplesperpixel == 1 ?", " \t\t    PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);", " \telse if (input_compression == COMPRESSION_JPEG &&", " \t\t\t samplesperpixel == 3 ) {", " \t\t ", " \t\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);", " \t}", " \telse", " \t\tCopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);", " \tif (fillorder != 0)", " \t\tTIFFSetField(out, TIFFTAG_FILLORDER, fillorder);", " \telse", " \t\tCopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);", " \t ", " \tTIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);", " \tswitch (orientation) {", " \t\tcase ORIENTATION_BOTRIGHT:", " \t\tcase ORIENTATION_RIGHTBOT:\t ", " \t\t\tTIFFWarning(TIFFFileName(in), \"using bottom-left orientation\");", " \t\t\torientation = ORIENTATION_BOTLEFT;", " \t\t ", " \t\tcase ORIENTATION_LEFTBOT:\t ", " \t\tcase ORIENTATION_BOTLEFT:", " \t\t\tbreak;", " \t\tcase ORIENTATION_TOPRIGHT:", " \t\tcase ORIENTATION_RIGHTTOP:\t ", " \t\tdefault:", " \t\t\tTIFFWarning(TIFFFileName(in), \"using top-left orientation\");", " \t\t\torientation = ORIENTATION_TOPLEFT;", " \t\t ", " \t\tcase ORIENTATION_LEFTTOP:\t ", " \t\tcase ORIENTATION_TOPLEFT:", " \t\t\tbreak;", " \t}", " \tTIFFSetField(out, TIFFTAG_ORIENTATION, orientation);", " \t ", " \tif (outtiled == -1)", " \t\touttiled = TIFFIsTiled(in);", " \tif (outtiled) {", " \t\t ", " \t\tif (tilewidth == (uint32) -1)", " \t\t\tTIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);", " \t\tif (tilelength == (uint32) -1)", " \t\t\tTIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);", " \t\tTIFFDefaultTileSize(out, &tilewidth, &tilelength);", " \t\tTIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);", " \t\tTIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);", " \t} else {", " \t\t ", " \t\tif (rowsperstrip == (uint32) 0) {", " \t\t\tif (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,", " \t\t\t    &rowsperstrip)) {", " \t\t\t\trowsperstrip =", " \t\t\t\t    TIFFDefaultStripSize(out, rowsperstrip);", " \t\t\t}", " \t\t\tif (rowsperstrip > length && rowsperstrip != (uint32)-1)", " \t\t\t\trowsperstrip = length;", " \t\t}", " \t\telse if (rowsperstrip == (uint32) -1)", " \t\t\trowsperstrip = length;", " \t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);", " \t}", " \tif (config != (uint16) -1)", " \t\tTIFFSetField(out, TIFFTAG_PLANARCONFIG, config);", " \telse", " \t\tCopyField(TIFFTAG_PLANARCONFIG, config);", " \tif (samplesperpixel <= 4)", " \t\tCopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);", " \tCopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);", "  ", " \tswitch (compression) {", " \t\tcase COMPRESSION_JPEG:", " \t\t\tTIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);", " \t\t\tTIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);", " \t\t\tbreak;", " \t\tcase COMPRESSION_JBIG:", " \t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);", " \t\t\tCopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);", " \t\t\tbreak;", " \t\tcase COMPRESSION_LZW:", " \t\tcase COMPRESSION_ADOBE_DEFLATE:", " \t\tcase COMPRESSION_DEFLATE:", "                 case COMPRESSION_LZMA:", " \t\t\tif (predictor != (uint16)-1)", " \t\t\t\tTIFFSetField(out, TIFFTAG_PREDICTOR, predictor);", " \t\t\telse", " \t\t\t\tCopyField(TIFFTAG_PREDICTOR, predictor);", " \t\t\tif (preset != -1) {", "                                 if (compression == COMPRESSION_ADOBE_DEFLATE", "                                          || compression == COMPRESSION_DEFLATE)", "                                         TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);", " \t\t\t\telse if (compression == COMPRESSION_LZMA)", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_LZMAPRESET, preset);", "                         }", " \t\t\tbreak;", " \t\tcase COMPRESSION_CCITTFAX3:", " \t\tcase COMPRESSION_CCITTFAX4:", " \t\t\tif (compression == COMPRESSION_CCITTFAX3) {", " \t\t\t\tif (g3opts != (uint32) -1)", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_GROUP3OPTIONS,", " \t\t\t\t\t    g3opts);", " \t\t\t\telse", " \t\t\t\t\tCopyField(TIFFTAG_GROUP3OPTIONS, g3opts);", " \t\t\t} else", " \t\t\t\tCopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);", " \t\t\tCopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);", " \t\t\tbreak;", " \t}", " \t{", " \t\tuint32 len32;", " \t\tvoid** data;", " \t\tif (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))", " \t\t\tTIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);", " \t}", " \t{", " \t\tuint16 ninks;", " \t\tconst char* inknames;", " \t\tif (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {", " \t\t\tTIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);", " \t\t\tif (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {", " \t\t\t\tint inknameslen = strlen(inknames) + 1;", " \t\t\t\tconst char* cp = inknames;", " \t\t\t\twhile (ninks > 1) {", " \t\t\t\t\tcp = strchr(cp, '\\0');", "                                         cp++;", "                                         inknameslen += (strlen(cp) + 1);", " \t\t\t\t\tninks--;", " \t\t\t\t}", " \t\t\t\tTIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);", " \t\t\t}", " \t\t}", " \t}", " \t{", " \t\tunsigned short pg0, pg1;", " ", " \t\tif (pageInSeq == 1) {", " \t\t\tif (pageNum < 0)   {", " \t\t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);", " \t\t\t} else", " \t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);", " ", " \t\t} else {", " \t\t\tif (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {", " \t\t\t\tif (pageNum < 0)  ", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);", " \t\t\t\telse", " \t\t\t\t\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);", " \t\t\t}", " \t\t}", " \t}", " ", " \tfor (p = tags; p < &tags[NTAGS]; p++)", " \t\tCopyTag(p->tag, p->count, p->type);", " ", " \tcf = pickCopyFunc(in, out, bitspersample, samplesperpixel);", " \treturn (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,", " \t\t\t\t     unsigned long data_len, int noblock,", " \t\t\t\t     int *errcode)", " {", " \tstruct sk_buff *skb;", "  \tgfp_t gfp_mask;", "  \tlong timeo;", "  \tint err;", " \tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;", " ", " \terr = -EMSGSIZE;", " \tif (npages > MAX_SKB_FRAGS)", " \t\tgoto failure;", "  ", "  \tgfp_mask = sk->sk_allocation;", "  \tif (gfp_mask & __GFP_WAIT)", " \t\tgfp_mask |= __GFP_REPEAT;", " ", " \ttimeo = sock_sndtimeo(sk, noblock);", " \twhile (1) {", " \t\terr = sock_error(sk);", " \t\tif (err != 0)", " \t\t\tgoto failure;", " ", " \t\terr = -EPIPE;", " \t\tif (sk->sk_shutdown & SEND_SHUTDOWN)", " \t\t\tgoto failure;", " ", "  \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {", "  \t\t\tskb = alloc_skb(header_len, gfp_mask);", "  \t\t\tif (skb) {", "\t\t\t\tint npages;", "  \t\t\t\tint i;", "  ", "  \t\t\t\t ", "  \t\t\t\tif (!data_len)", "  \t\t\t\t\tbreak;", "  ", "\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;", "  \t\t\t\tskb->truesize += data_len;", "  \t\t\t\tskb_shinfo(skb)->nr_frags = npages;", "  \t\t\t\tfor (i = 0; i < npages; i++) {", " \t\t\t\t\tstruct page *page;", " ", " \t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);", " \t\t\t\t\tif (!page) {", " \t\t\t\t\t\terr = -ENOBUFS;", " \t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;", " \t\t\t\t\t\tkfree_skb(skb);", " \t\t\t\t\t\tgoto failure;", " \t\t\t\t\t}", " ", " \t\t\t\t\t__skb_fill_page_desc(skb, i,", " \t\t\t\t\t\t\tpage, 0,", " \t\t\t\t\t\t\t(data_len >= PAGE_SIZE ?", " \t\t\t\t\t\t\t PAGE_SIZE :", " \t\t\t\t\t\t\t data_len));", " \t\t\t\t\tdata_len -= PAGE_SIZE;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\terr = -ENOBUFS;", " \t\t\tgoto failure;", " \t\t}", " \t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);", " \t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);", " \t\terr = -EAGAIN;", " \t\tif (!timeo)", " \t\t\tgoto failure;", " \t\tif (signal_pending(current))", " \t\t\tgoto interrupted;", " \t\ttimeo = sock_wait_for_wmem(sk, timeo);", " \t}", " ", " \tskb_set_owner_w(skb, sk);", " \treturn skb;", " ", " interrupted:", " \terr = sock_intr_errno(timeo);", " failure:", " \t*errcode = err;", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,", "char *name) {", "", "XImage *xim;", "static int reported_flip = 0;", "int db = 0;", "", "shm->shmid = -1;", "shm->shmaddr = (char *) -1;", "*ximg_ptr = NULL;", "", "if (nofb) {", "return 1;", "}", "", "X_LOCK;", "", "if (! using_shm || xform24to32 || raw_fb) {", "", "xim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,", "0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);", "", "X_UNLOCK;", "", "if (xim == NULL) {", "rfbErr(\"XCreateImage(%s) failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XCreateImage(%s) failed.\\n\",", "name);", "}", "return 0;", "}", "if (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);", "xim->data = (char *) malloc(xim->bytes_per_line * xim->height);", "if (xim->data == NULL) {", "rfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XCreateImage(%s) data malloc\"", "\" failed.\\n\", name);", "}", "return 0;", "}", "if (flip_byte_order) {", "char *order = flip_ximage_byte_order(xim);", "if (! reported_flip && ! quiet) {", "rfbLog(\"Changing XImage byte order\"", "\" to %s\\n\", order);", "reported_flip = 1;", "}", "}", "", "*ximg_ptr = xim;", "return 1;", "}", "", "if (! dpy) {", "X_UNLOCK;", "return 0;", "}", "", "xim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,", "shm, w, h);", "", "if (xim == NULL) {", "rfbErr(\"XShmCreateImage(%s) failed.\\n\", name);", "if (quiet) {", "fprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);", "}", "X_UNLOCK;", "return 0;", "}", "", "*ximg_ptr = xim;", "", "#if HAVE_XSHM", "shm->shmid = shmget(IPC_PRIVATE,", "xim->bytes_per_line * xim->height, IPC_CREAT | 0777);", "", "if (shm->shmid == -1) {", "rfbErr(\"shmget(%s) failed.\\n\", name);", "rfbLogPerror(\"shmget\");", "", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "", "X_UNLOCK;", "return 0;", "}", "", "shm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);", "", "if (shm->shmaddr == (char *)-1) {", "rfbErr(\"shmat(%s) failed.\\n\", name);", "rfbLogPerror(\"shmat\");", "", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "", "shmctl(shm->shmid, IPC_RMID, 0);", "shm->shmid = -1;", "", "X_UNLOCK;", "return 0;", "}", "", "shm->readOnly = False;", "", "if (! XShmAttach_wr(dpy, shm)) {", "rfbErr(\"XShmAttach(%s) failed.\\n\", name);", "XDestroyImage(xim);", "*ximg_ptr = NULL;", "", "shmdt(shm->shmaddr);", "shm->shmaddr = (char *) -1;", "", "shmctl(shm->shmid, IPC_RMID, 0);", "shm->shmid = -1;", "", "X_UNLOCK;", "return 0;", "}", "#endif", "", "X_UNLOCK;", "return 1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool RenderViewHostManager::ShouldSwapProcessesForNavigation(", "     const NavigationEntry* curr_entry,", "     const NavigationEntryImpl* new_entry) const {", "   DCHECK(new_entry);", " ", " ", "   const GURL& current_url = (curr_entry) ? curr_entry->GetURL() :", "       render_view_host_->GetSiteInstance()->GetSiteURL();", "   BrowserContext* browser_context =", "       delegate_->GetControllerForRenderManager().GetBrowserContext();", "   if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(", "           browser_context, current_url)) {", "     if (!WebUIControllerFactoryRegistry::GetInstance()->IsURLAcceptableForWebUI(", "             browser_context, new_entry->GetURL(), false)) {", "       return true;", "     }", "   } else {", "     if (WebUIControllerFactoryRegistry::GetInstance()->UseWebUIForURL(", "             browser_context, new_entry->GetURL())) {", "       return true;", "     }", "    }", "  ", "    if (GetContentClient()->browser()->ShouldSwapProcessesForNavigation(", "          curr_entry ? curr_entry->GetURL() : GURL(), new_entry->GetURL())) {", "           render_view_host_->GetSiteInstance(),", "           curr_entry ? curr_entry->GetURL() : GURL(),", "           new_entry->GetURL())) {", "      return true;", "    }", "  ", "   if (!curr_entry)", "     return false;", " ", "   if (curr_entry->IsViewSourceMode() != new_entry->IsViewSourceMode())", "     return true;", " ", "   return false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" KeyedService* LogoServiceFactory::BuildServiceInstanceFor(", "     content::BrowserContext* context) const {", "   Profile* profile = static_cast<Profile*>(context);", "   DCHECK(!profile->IsOffTheRecord());", " #if defined(OS_ANDROID)", "   bool use_gray_background = !GetIsChromeHomeEnabled();", "  #else", "    bool use_gray_background = false;", "  #endif", "  return new LogoService(profile->GetPath().Append(kCachedLogoDirectory),", "                         TemplateURLServiceFactory::GetForProfile(profile),", "                         base::MakeUnique<suggestions::ImageDecoderImpl>(),", "                         profile->GetRequestContext(), use_gray_background);", "   return new LogoServiceImpl(profile->GetPath().Append(kCachedLogoDirectory),", "                              TemplateURLServiceFactory::GetForProfile(profile),", "                              base::MakeUnique<suggestions::ImageDecoderImpl>(),", "                              profile->GetRequestContext(), use_gray_background);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" static int jas_iccputsint(jas_stream_t *out, int n, longlong val)", " static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \ttmp = (val < 0) ? (abort(), 0) : val;", "  \treturn jas_iccputuint(out, n, tmp);", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void PageSerializer::addImageToResources(ImageResource* image, RenderObject* imageRenderer, const KURL& url)", " {", "      if (!shouldAddURL(url))", "          return;", "  ", "    if (!image || !image->hasImage() || image->image() == Image::nullImage())", "     if (!image || image->image() == Image::nullImage())", "          return;", "  ", "      RefPtr<SharedBuffer> data = imageRenderer ? image->imageForRenderer(imageRenderer)->data() : 0;", "     if (!data)", "         data = image->image()->data();", " ", "     addToResources(image, data, url);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["s32 gf_avc_parse_nalu(GF_BitStream *bs, AVCState *avc)", "{", "u8 idr_flag;", "s32 slice, ret;", "u32 nal_hdr;", "AVCSliceInfo n_state;", "", "gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);", "", "nal_hdr = gf_bs_read_u8(bs);", "", "slice = 0;", "memcpy(&n_state, &avc->s_info, sizeof(AVCSliceInfo));", "avc->last_nal_type_parsed = n_state.nal_unit_type = nal_hdr & 0x1F;", "n_state.nal_ref_idc = (nal_hdr >> 5) & 0x3;", "", "idr_flag = 0;", "", "switch (n_state.nal_unit_type) {", "case GF_AVC_NALU_ACCESS_UNIT:", "case GF_AVC_NALU_END_OF_SEQ:", "case GF_AVC_NALU_END_OF_STREAM:", "ret = 1;", "break;", "", "case GF_AVC_NALU_SVC_SLICE:", "SVC_ReadNal_header_extension(bs, &n_state.NalHeader);", "", "svc_parse_slice(bs, avc, &n_state);", "if (avc->s_info.nal_ref_idc) {", "n_state.poc_lsb_prev = avc->s_info.poc_lsb;", "n_state.poc_msb_prev = avc->s_info.poc_msb;", "}", "avc_compute_poc(&n_state);", "", "if (avc->s_info.poc != n_state.poc) {", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return 1;", "}", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return 0;", "", "case GF_AVC_NALU_SVC_PREFIX_NALU:", "SVC_ReadNal_header_extension(bs, &n_state.NalHeader);", "return 0;", "", "case GF_AVC_NALU_IDR_SLICE:", "case GF_AVC_NALU_NON_IDR_SLICE:", "case GF_AVC_NALU_DP_A_SLICE:", "case GF_AVC_NALU_DP_B_SLICE:", "case GF_AVC_NALU_DP_C_SLICE:", "slice = 1;", "", "ret = avc_parse_slice(bs, avc, idr_flag, &n_state);", "if (ret < 0) return ret;", "ret = 0;", "if (", "((avc->s_info.nal_unit_type > GF_AVC_NALU_IDR_SLICE) || (avc->s_info.nal_unit_type < GF_AVC_NALU_NON_IDR_SLICE))", "&& (avc->s_info.nal_unit_type != GF_AVC_NALU_SVC_SLICE)", ") {", "break;", "}", "if (avc->s_info.frame_num != n_state.frame_num) {", "ret = 1;", "break;", "}", "", "if (avc->s_info.field_pic_flag != n_state.field_pic_flag) {", "ret = 1;", "break;", "}", "if ((avc->s_info.nal_ref_idc != n_state.nal_ref_idc) &&", "(!avc->s_info.nal_ref_idc || !n_state.nal_ref_idc)) {", "ret = 1;", "break;", "}", "assert(avc->s_info.sps);", "", "if (avc->s_info.sps->poc_type == n_state.sps->poc_type) {", "if (!avc->s_info.sps->poc_type) {", "if (!n_state.bottom_field_flag && (avc->s_info.poc_lsb != n_state.poc_lsb)) {", "ret = 1;", "break;", "}", "if (avc->s_info.delta_poc_bottom != n_state.delta_poc_bottom) {", "ret = 1;", "break;", "}", "}", "else if (avc->s_info.sps->poc_type == 1) {", "if (avc->s_info.delta_poc[0] != n_state.delta_poc[0]) {", "ret = 1;", "break;", "}", "if (avc->s_info.delta_poc[1] != n_state.delta_poc[1]) {", "ret = 1;", "break;", "}", "}", "}", "", "if (n_state.nal_unit_type == GF_AVC_NALU_IDR_SLICE) {", "if (avc->s_info.nal_unit_type != GF_AVC_NALU_IDR_SLICE) {", "ret = 1;", "break;", "}", "else if (avc->s_info.idr_pic_id != n_state.idr_pic_id) {", "ret = 1;", "break;", "}", "}", "break;", "case GF_AVC_NALU_SEQ_PARAM:", "avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "", "case GF_AVC_NALU_PIC_PARAM:", "avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_SVC_SUBSEQ_PARAM:", "avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "case GF_AVC_NALU_SEQ_PARAM_EXT:", "avc->last_ps_idx = (s32) gf_bs_read_ue(bs);", "if (avc->last_ps_idx < 0) return -1;", "return 0;", "", "case GF_AVC_NALU_SEI:", "case GF_AVC_NALU_FILLER_DATA:", "return 0;", "", "default:", "if (avc->s_info.nal_unit_type <= GF_AVC_NALU_IDR_SLICE) ret = 1;", "", "else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEI && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)", "ret = 1;", "else if ((nal_hdr & 0x1F) == GF_AVC_NALU_SEQ_PARAM && avc->s_info.nal_unit_type == GF_AVC_NALU_SVC_SLICE)", "ret = 1;", "else", "ret = 0;", "break;", "}", "", "", "if (ret && avc->s_info.sps) {", "n_state.frame_num_offset_prev = avc->s_info.frame_num_offset;", "if ((avc->s_info.sps->poc_type != 2) || (avc->s_info.nal_ref_idc != 0))", "n_state.frame_num_prev = avc->s_info.frame_num;", "if (avc->s_info.nal_ref_idc) {", "n_state.poc_lsb_prev = avc->s_info.poc_lsb;", "n_state.poc_msb_prev = avc->s_info.poc_msb;", "}", "}", "if (slice)", "avc_compute_poc(&n_state);", "memcpy(&avc->s_info, &n_state, sizeof(AVCSliceInfo));", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void MSG_WriteBits( msg_t *msg, int value, int bits ) {", " \tint\ti;", "  ", "  \toldsize += bits;", "  ", "\tif ( msg->maxsize - msg->cursize < 4 ) {", "\t\tmsg->overflowed = qtrue;", " \tif ( msg->overflowed ) {", "  \t\treturn;", "  \t}", "  ", " \tif ( bits == 0 || bits < -31 || bits > 32 ) {", " \t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );", " \t}", " ", " \tif ( bits < 0 ) {", " \t\tbits = -bits;", "  \t}", "  ", "  \tif ( msg->oob ) {", " \t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {", " \t\t\tmsg->overflowed = qtrue;", " \t\t\treturn;", " \t\t}", " ", "  \t\tif ( bits == 8 ) {", "  \t\t\tmsg->data[msg->cursize] = value;", "  \t\t\tmsg->cursize += 1;", " \t\t\tmsg->bit += 8;", " \t\t} else if ( bits == 16 ) {", " \t\t\tshort temp = value;", " ", " \t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );", " \t\t\tmsg->cursize += 2;", " \t\t\tmsg->bit += 16;", " \t\t} else if ( bits==32 ) {", " \t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );", " \t\t\tmsg->cursize += 4;", " \t\t\tmsg->bit += 32;", " \t\t} else {", " \t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );", " \t\t}", " \t} else {", " \t\tvalue &= (0xffffffff >> (32 - bits));", "  \t\tif ( bits&7 ) {", "  \t\t\tint nbits;", "  \t\t\tnbits = bits&7;", " \t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {", " \t\t\t\tmsg->overflowed = qtrue;", " \t\t\t\treturn;", " \t\t\t}", "  \t\t\tfor( i = 0; i < nbits; i++ ) {", "  \t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );", "  \t\t\t\tvalue = (value >> 1);", " \t\t\t}", " \t\t\tbits = bits - nbits;", "  \t\t}", "  \t\tif ( bits ) {", "  \t\t\tfor( i = 0; i < bits; i += 8 ) {", "\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );", " \t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );", "  \t\t\t\tvalue = (value >> 8);", " ", " \t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {", " \t\t\t\t\tmsg->overflowed = qtrue;", " \t\t\t\t\treturn;", " \t\t\t\t}", "  \t\t\t}", "  \t\t}", "  \t\tmsg->cursize = (msg->bit >> 3) + 1;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_public_key(RSA *rsa)", " {", " \tint r;", " \tsc_path_t path;", " \tsc_file_t *file;", " \tu8 buf[2048], *p = buf;", " \tsize_t bufsize, keysize;", " ", " \tr = select_app_df();", " \tif (r)", " \t\treturn 1;", " \tsc_format_path(\"I1012\", &path);", " \tr = sc_select_file(card, &path, &file);", " \tif (r) {", "  \t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));", "  \t\treturn 2;", "  \t}", "\tbufsize = file->size;", " \tbufsize = MIN(file->size, sizeof buf);", "  \tsc_file_free(file);", "  \tr = sc_read_binary(card, 0, buf, bufsize, 0);", "  \tif (r < 0) {", " \t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));", " \t\treturn 2;", " \t}", " \tbufsize = r;", " \tdo {", " \t\tif (bufsize < 4)", " \t\t\treturn 3;", " \t\tkeysize = (p[0] << 8) | p[1];", " \t\tif (keysize == 0)", " \t\t\tbreak;", " \t\tif (keysize < 3)", " \t\t\treturn 3;", " \t\tif (p[2] == opt_key_num)", " \t\t\tbreak;", " \t\tp += keysize;", " \t\tbufsize -= keysize;", " \t} while (1);", " \tif (keysize == 0) {", " \t\tprintf(\"Key number %d not found.\\n\", opt_key_num);", " \t\treturn 2;", " \t}", " \treturn parse_public_key(p, keysize, rsa);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool TextTrackCueList::Add(TextTrackCue* cue) {", "  DCHECK_GE(cue->startTime(), 0);", "  DCHECK_GE(cue->endTime(), 0);", "    size_t index = FindInsertionIndex(cue);", " ", "   if (!list_.IsEmpty() && (index > 0) && (list_[index - 1].Get() == cue))", "     return false;", " ", "   list_.insert(index, cue);", "   InvalidateCueIndex(index);", "   return true;", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void UpdateTargetInfoAvPairs(bool is_mic_enabled,", "                              bool is_epa_enabled,", "                              const std::string& channel_bindings,", "                              const std::string& spn,", "                              std::vector<AvPair>* av_pairs,", "                              uint64_t* server_timestamp,", "                              size_t* target_info_len) {", "   *server_timestamp = UINT64_MAX;", "   *target_info_len = 0;", " ", "   bool need_flags_added = is_mic_enabled;", "   for (AvPair& pair : *av_pairs) {", "     *target_info_len += pair.avlen + kAvPairHeaderLen;", "     switch (pair.avid) {", "       case TargetInfoAvId::kFlags:", "         if (is_mic_enabled) {", "           pair.flags = pair.flags | TargetInfoAvFlags::kMicPresent;", "         }", " ", "         need_flags_added = false;", "         break;", "       case TargetInfoAvId::kTimestamp:", "         *server_timestamp = pair.timestamp;", "         break;", "       case TargetInfoAvId::kEol:", "       case TargetInfoAvId::kChannelBindings:", "       case TargetInfoAvId::kTargetName:", "         NOTREACHED();", "         break;", "       default:", "         break;", "     }", "   }", " ", "   if (need_flags_added) {", "     DCHECK(is_mic_enabled);", "     AvPair flags_pair(TargetInfoAvId::kFlags, sizeof(uint32_t));", "     flags_pair.flags = TargetInfoAvFlags::kMicPresent;", " ", "     av_pairs->push_back(flags_pair);", "     *target_info_len += kAvPairHeaderLen + flags_pair.avlen;", "   }", " ", "   if (is_epa_enabled) {", "     std::vector<uint8_t> channel_bindings_hash(kChannelBindingsHashLen, 0);", "  ", "      if (!channel_bindings.empty()) {", "      GenerateChannelBindingHashV2(channel_bindings, channel_bindings_hash);", "       GenerateChannelBindingHashV2(", "           channel_bindings,", "           base::make_span<kChannelBindingsHashLen>(channel_bindings_hash));", "      }", "  ", "      av_pairs->emplace_back(TargetInfoAvId::kChannelBindings,", "                            std::move(channel_bindings_hash));", " ", "     base::string16 spn16 = base::UTF8ToUTF16(spn);", "     NtlmBufferWriter spn_writer(spn16.length() * 2);", "     bool spn_writer_result =", "         spn_writer.WriteUtf16String(spn16) && spn_writer.IsEndOfBuffer();", "     DCHECK(spn_writer_result);", " ", "     av_pairs->emplace_back(TargetInfoAvId::kTargetName, spn_writer.Pass());", " ", "     *target_info_len +=", "         (2 * kAvPairHeaderLen) + kChannelBindingsHashLen + (spn16.length() * 2);", "   }", " ", "   *target_info_len += kAvPairHeaderLen;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int mainloop(CLIENT *client) {", " \tstruct nbd_request request;", " \tstruct nbd_reply reply;", " \tgboolean go_on=TRUE;", " #ifdef DODBG", " \tint i = 0;", " #endif", " \tnegotiate(client->net, client, NULL);", " \tDEBUG(\"Entering request loop!\\n\");", " \treply.magic = htonl(NBD_REPLY_MAGIC);", " \treply.error = 0;", " \twhile (go_on) {", " \t\tchar buf[BUFSIZE];", " \t\tsize_t len;", " #ifdef DODBG", " \t\ti++;", " \t\tprintf(\"%d: \", i);", " #endif", " \t\treadit(client->net, &request, sizeof(request));", " \t\trequest.from = ntohll(request.from);", " \t\trequest.type = ntohl(request.type);", " ", " \t\tif (request.type==NBD_CMD_DISC) {", " \t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");", "                 \tif (client->server->flags & F_COPYONWRITE) { ", " \t\t\t\tif (client->difmap) g_free(client->difmap) ;", "                 \t\tclose(client->difffile);", " \t\t\t\tunlink(client->difffilename);", " \t\t\t\tfree(client->difffilename);", " \t\t\t}", " \t\t\tgo_on=FALSE;", " \t\t\tcontinue;", " \t\t}", " ", " \t\tlen = ntohl(request.len);", "  ", "  \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))", "  \t\t\terr(\"Not enough magic.\");", "\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))", " \t\tif (len > BUFSIZE - sizeof(struct nbd_reply))", "  \t\t\terr(\"Request too big!\");", "  #ifdef DODBG", "  \t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :", " \t\t\t\t\"READ\", (unsigned long long)request.from,", " \t\t\t\t(unsigned long long)request.from / 512, len);", " #endif", " \t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));", " \t\tif ((request.from + len) > (OFFT_MAX)) {", " \t\t\tDEBUG(\"[Number too large!]\");", " \t\t\tERROR(client, reply, EINVAL);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {", " \t\t\tDEBUG(\"[RANGE!]\");", " \t\t\tERROR(client, reply, EINVAL);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (request.type==NBD_CMD_WRITE) {", " \t\t\tDEBUG(\"wr: net->buf, \");", " \t\t\treadit(client->net, buf, len);", " \t\t\tDEBUG(\"buf->exp, \");", " \t\t\tif ((client->server->flags & F_READONLY) ||", " \t\t\t    (client->server->flags & F_AUTOREADONLY)) {", " \t\t\t\tDEBUG(\"[WRITE to READONLY!]\");", " \t\t\t\tERROR(client, reply, EPERM);", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tif (expwrite(request.from, buf, len, client)) {", " \t\t\t\tDEBUG(\"Write failed: %m\" );", " \t\t\t\tERROR(client, reply, errno);", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tSEND(client->net, reply);", " \t\t\tDEBUG(\"OK!\\n\");", " \t\t\tcontinue;", " \t\t}", " \t\t ", " ", " \t\tDEBUG(\"exp->buf, \");", " \t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {", " \t\t\tDEBUG(\"Read failed: %m\");", " \t\t\tERROR(client, reply, errno);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tDEBUG(\"buf->net, \");", " \t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));", " \t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));", " \t\tDEBUG(\"OK!\\n\");", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool MediaControlsProgressView::OnMousePressed(const ui::MouseEvent& event) {", "  gfx::Point location_in_bar(event.location());", "  ConvertPointToTarget(this, this->progress_bar_, &location_in_bar);", "  if (!event.IsOnlyLeftMouseButton() ||", "      !progress_bar_->GetLocalBounds().Contains(location_in_bar)) {", "   if (!event.IsOnlyLeftMouseButton() || event.y() < kMinClickHeight ||", "       event.y() > kMaxClickHeight) {", "      return false;", "    }", "  ", "  HandleSeeking(location_in_bar);", "   HandleSeeking(event.location());", "    return true;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" OMX_ERRORTYPE SoftAMRWBEncoder::internalGetParameter(", "         OMX_INDEXTYPE index, OMX_PTR params) {", "  switch (index) {", "  case OMX_IndexParamAudioPortFormat:", "  {", " ", "              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =", "                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;", "  ", "             if (!isValidOMXParam(formatParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (formatParams->nPortIndex > 1) {", "                  return OMX_ErrorUndefined;", "              }", " ", "  if (formatParams->nIndex > 0) {", "  return OMX_ErrorNoMore;", "  }", " ", "             formatParams->eEncoding =", "  (formatParams->nPortIndex == 0)", "  ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAMR;", " ", "  return OMX_ErrorNone;", "  }", " ", "  case OMX_IndexParamAudioAmr:", "  {", " ", "              OMX_AUDIO_PARAM_AMRTYPE *amrParams =", "                  (OMX_AUDIO_PARAM_AMRTYPE *)params;", "  ", "             if (!isValidOMXParam(amrParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (amrParams->nPortIndex != 1) {", "                  return OMX_ErrorUndefined;", "              }", " ", "             amrParams->nChannels = 1;", "             amrParams->nBitRate = mBitRate;", " ", "             amrParams->eAMRBandMode =", "  (OMX_AUDIO_AMRBANDMODETYPE)(mMode + OMX_AUDIO_AMRBandModeWB0);", " ", "             amrParams->eAMRDTXMode = OMX_AUDIO_AMRDTXModeOff;", "             amrParams->eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;", " ", "  return OMX_ErrorNone;", "  }", " ", "  case OMX_IndexParamAudioPcm:", "  {", " ", "              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =", "                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;", "  ", "             if (!isValidOMXParam(pcmParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (pcmParams->nPortIndex != 0) {", "                  return OMX_ErrorUndefined;", "              }", " ", "             pcmParams->eNumData = OMX_NumericalDataSigned;", "             pcmParams->eEndian = OMX_EndianBig;", "             pcmParams->bInterleaved = OMX_TRUE;", "             pcmParams->nBitPerSample = 16;", "             pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;", "             pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelCF;", " ", "             pcmParams->nChannels = 1;", "             pcmParams->nSamplingRate = kSampleRate;", " ", "  return OMX_ErrorNone;", "  }", " ", "  default:", "  return SimpleSoftOMXComponent::internalGetParameter(index, params);", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  media::interfaces::ServiceFactory* RenderFrameImpl::GetMediaServiceFactory() {", "    if (!media_service_factory_) {", "    mojo::InterfacePtr<mojo::Shell> shell_ptr;", "    GetServiceRegistry()->ConnectToRemoteService(mojo::GetProxy(&shell_ptr));", "    mojo::ServiceProviderPtr service_provider;", "    mojo::URLRequestPtr request(mojo::URLRequest::New());", "    request->url = mojo::String::From(\"mojo:media\");", "    shell_ptr->ConnectToApplication(request.Pass(), GetProxy(&service_provider),", "                                    nullptr, nullptr);", "     mojo::ServiceProviderPtr service_provider =", "         ConnectToApplication(GURL(\"mojo:media\"));", "      mojo::ConnectToService(service_provider.get(), &media_service_factory_);", "      media_service_factory_.set_connection_error_handler(", "          base::Bind(&RenderFrameImpl::OnMediaServiceFactoryConnectionError,", "                     base::Unretained(this)));", "   }", " ", "   return media_service_factory_.get();", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sec_recv(RD_BOOL * is_fastpath)", "{", "uint8 fastpath_hdr, fastpath_flags;", "uint16 sec_flags;", "uint16 channel;", "STREAM s;", "", "while ((s = mcs_recv(&channel, is_fastpath, &fastpath_hdr)) != NULL)", "{", "if (*is_fastpath == True)", "{", "", "", "", "fastpath_flags = (fastpath_hdr & 0xC0) >> 6;", "if (fastpath_flags & FASTPATH_OUTPUT_ENCRYPTED)", "{", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "}", "return s;", "}", "", "if (g_encryption || (!g_licence_issued && !g_licence_error_result))", "{", "", "in_uint16_le(s, sec_flags);", "in_uint8s(s, 2);", "", "if (g_encryption)", "{", "if (sec_flags & SEC_ENCRYPT)", "{", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "}", "", "if (sec_flags & SEC_LICENSE_PKT)", "{", "licence_process(s);", "continue;", "}", "", "if (sec_flags & SEC_REDIRECTION_PKT)", "{", "uint8 swapbyte;", "", "in_uint8s(s, 8);", "sec_decrypt(s->p, s->end - s->p);", "", "", "if (s->p[0] == 0 && s->p[1] == 4)", "{", "", "", "", "", "", "", "swapbyte = s->p[0];", "s->p[0] = s->p[2];", "s->p[2] = swapbyte;", "", "swapbyte = s->p[1];", "s->p[1] = s->p[3];", "s->p[3] = swapbyte;", "", "swapbyte = s->p[2];", "s->p[2] = s->p[3];", "s->p[3] = swapbyte;", "}", "}", "}", "else", "{", "if (sec_flags & SEC_LICENSE_PKT)", "{", "licence_process(s);", "continue;", "}", "s->p -= 4;", "}", "}", "", "if (channel != MCS_GLOBAL_CHANNEL)", "{", "channel_process(s, channel);", "continue;", "}", "", "return s;", "}", "", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void LockScreenMediaControlsView::SetArtwork(", "     base::Optional<gfx::ImageSkia> img) {", "   if (!img.has_value()) {", "     session_artwork_->SetImage(nullptr);", "      return;", "    }", "  ", "  session_artwork_->SetImageSize(ScaleSizeToFitView(", "      img->size(), gfx::Size(kArtworkViewWidth, kArtworkViewHeight)));", "   session_artwork_->SetImageSize(ScaleSizeToFitView(img->size(), kArtworkSize));", "    session_artwork_->SetImage(*img);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {", "auto* params =", "reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data);", "OpData* data = reinterpret_cast<OpData*>(node->user_data);", "", "bool has_bias = NumInputs(node) == 3;", "", "TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2);", "const TfLiteTensor* input;", "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));", "const TfLiteTensor* filter;", "TF_LITE_ENSURE_OK(context,", "GetInputSafe(context, node, kFilterTensor, &filter));", "const TfLiteTensor* bias = nullptr;", "", "TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);", "TfLiteTensor* output;", "TF_LITE_ENSURE_OK(context,", "GetOutputSafe(context, node, kOutputTensor, &output));", "", "TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);", "TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4);", "", "const TfLiteType data_type = input->type;", "", "const TfLiteType filter_type = filter->type;", "const bool is_hybrid =", "data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8;", "TF_LITE_ENSURE(context,", "data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||", "data_type == kTfLiteInt8 || data_type == kTfLiteInt16);", "TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type);", "if (!is_hybrid) {", "TF_LITE_ENSURE(context,", "filter->type == data_type || data_type == kTfLiteInt16);", "}", "", "if (data_type == kTfLiteInt16) {", "TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0);", "TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);", "}", "", "", "TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1);", "", "if (has_bias) {", "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias));", "if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) {", "TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32);", "TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);", "} else if (data_type == kTfLiteInt16) {", "TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64);", "TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0);", "} else {", "TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type);", "}", "TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1);", "TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3),", "SizeOfDimension(bias, 0));", "}", "", "int channels_out = SizeOfDimension(filter, 3);", "int width = SizeOfDimension(input, 2);", "int height = SizeOfDimension(input, 1);", "int filter_width = SizeOfDimension(filter, 2);", "int filter_height = SizeOfDimension(filter, 1);", "int batches = SizeOfDimension(input, 0);", "", "", "auto padding = params->padding;", "int out_width, out_height;", "", "data->padding = ComputePaddingHeightWidth(", "params->stride_height, params->stride_width,", "params->dilation_height_factor, params->dilation_width_factor, height,", "width, filter_height, filter_width, padding, &out_height, &out_width);", "", "", "", "", "if (data_type != kTfLiteFloat32) {", "TF_LITE_ENSURE_EQ(context, filter->quantization.type,", "kTfLiteAffineQuantization);", "TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);", "const auto* affine_quantization =", "reinterpret_cast<TfLiteAffineQuantization*>(", "filter->quantization.params);", "TF_LITE_ENSURE(context, affine_quantization);", "TF_LITE_ENSURE(context, affine_quantization->scale);", "TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 ||", "affine_quantization->scale->size == channels_out));", "", "data->per_channel_output_multiplier.resize(channels_out);", "data->per_channel_output_shift.resize(channels_out);", "TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(", "context, input, filter, bias, output, params->activation,", "&data->output_multiplier, &data->output_shift,", "&data->output_activation_min, &data->output_activation_max,", "data->per_channel_output_multiplier.data(),", "data->per_channel_output_shift.data(), channels_out));", "}", "", "if (is_hybrid) {", "TF_LITE_ENSURE(context, filter->quantization.type != kTfLiteNoQuantization);", "const auto* affine_quantization =", "reinterpret_cast<TfLiteAffineQuantization*>(", "filter->quantization.params);", "TF_LITE_ENSURE(context, affine_quantization);", "TF_LITE_ENSURE(context, affine_quantization->scale);", "TF_LITE_ENSURE_EQ(", "context, affine_quantization->scale->size,", "filter->dims->data[affine_quantization->quantized_dimension]);", "", "int temporaries_count = 0;", "data->input_quantized_index = temporaries_count;", "if (data->input_quantized_id == kTensorNotAllocated) {", "TF_LITE_ENSURE_OK(", "context, context->AddTensors(context, 1, &data->input_quantized_id));", "}", "++temporaries_count;", "data->scaling_factors_index = temporaries_count;", "if (data->scaling_factors_id == kTensorNotAllocated) {", "TF_LITE_ENSURE_OK(", "context, context->AddTensors(context, 1, &data->scaling_factors_id));", "}", "++temporaries_count;", "data->input_offset_index = temporaries_count;", "if (data->input_offset_id == kTensorNotAllocated) {", "TF_LITE_ENSURE_OK(", "context, context->AddTensors(context, 1, &data->input_offset_id));", "}", "++temporaries_count;", "", "TfLiteIntArrayFree(node->temporaries);", "node->temporaries = TfLiteIntArrayCreate(temporaries_count);", "", "node->temporaries->data[data->input_quantized_index] =", "data->input_quantized_id;", "TfLiteTensor* input_quantized;", "TF_LITE_ENSURE_OK(", "context, GetTemporarySafe(context, node, data->input_quantized_index,", "&input_quantized));", "input_quantized->type = kTfLiteInt8;", "input_quantized->allocation_type = kTfLiteArenaRw;", "if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {", "TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);", "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,", "input_quantized_size));", "}", "node->temporaries->data[data->scaling_factors_index] =", "data->scaling_factors_id;", "TfLiteTensor* scaling_factors;", "TF_LITE_ENSURE_OK(", "context, GetTemporarySafe(context, node, data->scaling_factors_index,", "&scaling_factors));", "scaling_factors->type = kTfLiteFloat32;", "scaling_factors->allocation_type = kTfLiteArenaRw;", "const int batch_size = SizeOfDimension(input, 0);", "int scaling_dims[1] = {batch_size};", "if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {", "TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);", "scaling_factors_size->data[0] = batch_size;", "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,", "scaling_factors_size));", "}", "node->temporaries->data[data->input_offset_index] = data->input_offset_id;", "TfLiteTensor* input_offsets;", "TF_LITE_ENSURE_OK(context,", "GetTemporarySafe(context, node, data->input_offset_index,", "&input_offsets));", "input_offsets->type = kTfLiteInt32;", "input_offsets->allocation_type = kTfLiteArenaRw;", "if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) {", "TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1);", "input_offsets_size->data[0] = batch_size;", "TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets,", "input_offsets_size));", "}", "}", "", "TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4);", "outputSize->data[0] = batches;", "outputSize->data[1] = out_height;", "outputSize->data[2] = out_width;", "outputSize->data[3] = channels_out;", "return context->ResizeTensor(context, output, outputSize);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {", " \tconst char *symstr;", " \tstruct symbol_t *symbols;", " \tint from, to, i, j, s, stridx, symbols_size, symbols_count;", " \tSdbHash *hash;", " ", " \tif (!bin || !bin->symtab || !bin->symstr) {", " \t\treturn NULL;", " \t}", " \t ", " \t ", " \tsymbols_count = (bin->dysymtab.nextdefsym + \\", " \t\t\tbin->dysymtab.nlocalsym + \\", " \t\t\tbin->dysymtab.nundefsym );", " \tsymbols_count += bin->nsymtab;", " \tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);", " ", " \tif (symbols_size < 1) {", " \t\treturn NULL;", " \t}", " \tif (!(symbols = calloc (1, symbols_size))) {", " \t\treturn NULL;", " \t}", " \thash = sdb_ht_new ();", " \tj = 0;  ", " \tfor (s = 0; s < 2; s++) {", " \t\tswitch (s) {", " \t\tcase 0:", " \t\t\tfrom = bin->dysymtab.iextdefsym;", " \t\t\tto = from + bin->dysymtab.nextdefsym;", " \t\t\tbreak;", " \t\tcase 1:", " \t\t\tfrom = bin->dysymtab.ilocalsym;", " \t\t\tto = from + bin->dysymtab.nlocalsym;", " \t\t\tbreak;", " #if NOT_USED", " \t\tcase 2:", " \t\t\tfrom = bin->dysymtab.iundefsym;", " \t\t\tto = from + bin->dysymtab.nundefsym;", " \t\t\tbreak;", " #endif", " \t\t}", " \t\tif (from == to) {", " \t\t\tcontinue;", " \t\t}", " #define OLD 1", " #if OLD", " \t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));", " \t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));", " \t\tto = R_MIN (to, bin->nsymtab);", " #else", " \t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof (struct symbol_t));", " \t\tto = symbols_count;  ", " #endif", " \t\tint maxsymbols = symbols_size / sizeof (struct symbol_t);", " \t\tif (to > 0x500000) {", " \t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);", " \t\t\tfree (symbols);", " \t\t\tsdb_ht_free (hash);", " \t\t\treturn NULL;", " \t\t}", " \t\tif (symbols_count >= maxsymbols) {", " \t\t\tsymbols_count = maxsymbols - 1;", " \t\t}", " \t\tfor (i = from; i < to && j < symbols_count; i++, j++) {", " \t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);", " \t\t\tsymbols[j].addr = bin->symtab[i].n_value;", " \t\t\tsymbols[j].size = 0;  ", " \t\t\tif (bin->symtab[i].n_type & N_EXT) {", " \t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;", " \t\t\t} else {", " \t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;", " \t\t\t}", " \t\t\tstridx = bin->symtab[i].n_strx;", " \t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {", " \t\t\t\tsymstr = (char*)bin->symstr + stridx;", " \t\t\t} else {", " \t\t\t\tsymstr = \"???\";", " \t\t\t}", " \t\t\t{", " \t\t\t\tint i = 0;", " \t\t\t\tint len = 0;", " \t\t\t\tlen = bin->symstrlen - stridx;", " \t\t\t\tif (len > 0) {", " \t\t\t\t\tfor (i = 0; i < len; i++) {", " \t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {", " \t\t\t\t\t\t\tlen = i;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t\tchar *symstr_dup = NULL;", " \t\t\t\t\tif (len > 0) {", " \t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);", " \t\t\t\t\t}", " \t\t\t\t\tif (!symstr_dup) {", " \t\t\t\t\t\tsymbols[j].name[0] = 0;", " \t\t\t\t\t} else {", " \t\t\t\t\t\tr_str_ncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);", " \t\t\t\t\t\tr_str_filter (symbols[j].name, -1);", " \t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;", " \t\t\t\t\t}", " \t\t\t\t\tfree (symstr_dup);", " \t\t\t\t} else {", " \t\t\t\t\tsymbols[j].name[0] = 0;", " \t\t\t\t}", " \t\t\t\tsymbols[j].last = 0;", " \t\t\t}", " \t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {", " \t\t\t\tsymbols[j].name[0] = 0;", " \t\t\t\tj--;", " \t\t\t}", " \t\t}", " \t}", " \tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);", " \tfor (i = bin->dysymtab.iundefsym; i < to; i++) {", " \t\tif (j > symbols_count) {", "  \t\t\tbprintf (\"mach0-get-symbols: error\\n\");", "  \t\t\tbreak;", "  \t\t}", "\t\tif (parse_import_stub(bin, &symbols[j], i))", " \t\tif (parse_import_stub(bin, &symbols[j], i)) {", "  \t\t\tsymbols[j++].last = 0;", " \t\t}", "  \t}", "  ", "  #if 1", " \tfor (i = 0; i < bin->nsymtab; i++) {", " \t\tstruct MACH0_(nlist) *st = &bin->symtab[i];", " #if 0", " \t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",", " \t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);", " #endif", " \t\tstridx = st->n_strx;", " \t\tif (stridx >= 0 && stridx < bin->symstrlen) {", " \t\t\tsymstr = (char*)bin->symstr + stridx;", " \t\t} else {", " \t\t\tsymstr = \"???\";", " \t\t}", " \t\tint section = st->n_sect;", " \t\tif (section == 1 && j < symbols_count) {  ", " \t\t\t ", " \t\t\tsymbols[j].addr = st->n_value;  ", " \t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);", " \t\t\tsymbols[j].size = 0;  ", " \t\t\tif (st->n_type & N_EXT) {", " \t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;", " \t\t\t} else {", " \t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;", " \t\t\t}", " \t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);", " \t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;", " \t\t\tsymbols[j].last = 0;", " \t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {", " \t\t\t\tsymbols[j].name[0] = 0;", " \t\t\t} else {", " \t\t\t\tj++;", " \t\t\t}", " \t\t}", " \t}", " #endif", " \tsdb_ht_free (hash);", " \tsymbols[j].last = 1;", " \treturn symbols;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)", "  {", "\tu16 offset = sizeof(struct ipv6hdr);", " \tunsigned int offset = sizeof(struct ipv6hdr);", "  \tunsigned int packet_len = skb_tail_pointer(skb) -", "  \t\tskb_network_header(skb);", "  \tint found_rhdr = 0;", "  \t*nexthdr = &ipv6_hdr(skb)->nexthdr;", "  ", "  \twhile (offset <= packet_len) {", "  \t\tstruct ipv6_opt_hdr *exthdr;", " \t\tunsigned int len;", "  ", "  \t\tswitch (**nexthdr) {", "  ", " \t\tcase NEXTHDR_HOP:", " \t\t\tbreak;", " \t\tcase NEXTHDR_ROUTING:", " \t\t\tfound_rhdr = 1;", " \t\t\tbreak;", " \t\tcase NEXTHDR_DEST:", " #if IS_ENABLED(CONFIG_IPV6_MIP6)", " \t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)", " \t\t\t\tbreak;", " #endif", " \t\t\tif (found_rhdr)", " \t\t\t\treturn offset;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\treturn offset;", " \t\t}", " ", " \t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)", " \t\t\treturn -EINVAL;", "  ", "  \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +", "  \t\t\t\t\t\t offset);", "\t\toffset += ipv6_optlen(exthdr);", " \t\tlen = ipv6_optlen(exthdr);", " \t\tif (len + offset >= IPV6_MAXPLEN)", " \t\t\treturn -EINVAL;", " \t\toffset += len;", "  \t\t*nexthdr = &exthdr->nexthdr;", "  \t}", "  ", " \treturn -EINVAL;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  void GCInfoTable::EnsureGCInfoIndex(const GCInfo* gc_info,", "                                      size_t* gc_info_index_slot) {", "    DCHECK(gc_info);", "    DCHECK(gc_info_index_slot);", "  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());", "  MutexLocker locker(mutex);", " ", "    ", "    ", "    ", "   MutexLocker locker(table_mutex_);", "  ", "    if (*gc_info_index_slot)", "      return;", "  ", "  int index = ++gc_info_index_;", "   int index = ++current_index_;", "    size_t gc_info_index = static_cast<size_t>(index);", "    CHECK(gc_info_index < GCInfoTable::kMaxIndex);", "  if (gc_info_index >= gc_info_table_size_)", "   if (current_index_ >= limit_)", "      Resize();", "  ", "  g_gc_info_table[gc_info_index] = gc_info;", "   table_[gc_info_index] = gc_info;", "    ReleaseStore(reinterpret_cast<int*>(gc_info_index_slot), index);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]}
{"tokens": [" bool DebuggerDetachFunction::RunAsync() {", "   std::unique_ptr<Detach::Params> params(Detach::Params::Create(*args_));", "   EXTENSION_FUNCTION_VALIDATE(params.get());", " ", "   CopyDebuggee(&debuggee_, params->target);", "    if (!InitClientHost())", "      return false;", "  ", "   client_host_->RespondDetachedToPendingRequests();", "    client_host_->Close();", "    SendResponse(true);", "    return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", " #define SkipLinesOp  0x01", " #define SetColorOp  0x02", " #define SkipPixelsOp  0x03", "  #define ByteDataOp  0x05", "  #define RunDataOp  0x06", "  #define EOFOp  0x07", " #define ThrowRLEException(exception,message) \\", " { \\", "   if (colormap != (unsigned char *) NULL) \\", "     colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\", "   if (pixel_info != (MemoryInfo *) NULL) \\", "     pixel_info=RelinquishVirtualMemory(pixel_info); \\", "   ThrowReaderException((exception),(message)); \\", " }", " ", "  ", "    char", "      magick[12];", " ", "   Image", "     *image;", " ", "   IndexPacket", "     index;", " ", "   int", "     opcode,", "     operand,", "     status;", " ", "   MagickStatusType", "     flags;", " ", "   MagickSizeType", "     number_pixels;", " ", "   MemoryInfo", "     *pixel_info;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   register ssize_t", "     i;", " ", "   register unsigned char", "     *p;", " ", "   size_t", "     bits_per_pixel,", "     map_length,", "     number_colormaps,", "     number_planes,", "     number_planes_filled,", "     one,", "     pixel_info_length;", " ", "   ssize_t", "     count,", "     offset,", "     y;", " ", "   unsigned char", "     background_color[256],", "     *colormap,", "     pixel,", "     plane,", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     return(DestroyImageList(image));", "     ", "   colormap=(unsigned char *) NULL;", "   pixel_info=(MemoryInfo *) NULL;", "    count=ReadBlob(image,2,(unsigned char *) magick);", "    if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))", "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   do", "   {", "       ", "    image->page.x=ReadBlobLSBShort(image);", "    image->page.y=ReadBlobLSBShort(image);", "     image->page.x=(ssize_t) ReadBlobLSBShort(image);", "     image->page.y=(ssize_t) ReadBlobLSBShort(image);", "      image->columns=ReadBlobLSBShort(image);", "      image->rows=ReadBlobLSBShort(image);", "      flags=(MagickStatusType) ReadBlobByte(image);", "     image->matte=flags & 0x04 ? MagickTrue : MagickFalse;", "     number_planes=(size_t) ReadBlobByte(image);", "     bits_per_pixel=(size_t) ReadBlobByte(image);", "     number_colormaps=(size_t) ReadBlobByte(image);", "      map_length=(unsigned char) ReadBlobByte(image);", "      if (map_length >= 22)", "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if (EOFBlob(image) != MagickFalse)", "       ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "      one=1;", "      map_length=one << map_length;", "      if ((number_planes == 0) || (number_planes == 2) ||", "         ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||", "         (image->columns == 0))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if (flags & 0x02)", "       {", "          ", "         for (i=0; i < (ssize_t) number_planes; i++)", "           background_color[i]=0;", "         (void) ReadBlobByte(image);", "       }", "     else", "       {", "          ", "         p=background_color;", "         for (i=0; i < (ssize_t) number_planes; i++)", "           *p++=(unsigned char) ReadBlobByte(image);", "       }", "      if ((number_planes & 0x01) == 0)", "        (void) ReadBlobByte(image);", "      if (EOFBlob(image) != MagickFalse)", "      {", "        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "          image->filename);", "        break;", "      }", "       ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "      colormap=(unsigned char *) NULL;", "      if (number_colormaps != 0)", "        {", "          ", "         colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,", "           3*map_length*sizeof(*colormap));", "         if (colormap == (unsigned char *) NULL)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "          p=colormap;", "          for (i=0; i < (ssize_t) number_colormaps; i++)", "            for (x=0; x < (ssize_t) map_length; x++)", "           {", "              *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(", "                ReadBlobLSBShort(image)));", "             if (EOFBlob(image) != MagickFalse)", "               ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "           }", "        }", "      if ((flags & 0x08) != 0)", "        {", "         char", "           *comment;", " ", "         size_t", "           length;", " ", "          ", "         length=ReadBlobLSBShort(image);", "         if (length != 0)", "           {", "             comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));", "             if (comment == (char *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             (void) ReadBlob(image,length-1,(unsigned char *) comment);", "             comment[length-1]='\\0';", "             (void) SetImageProperty(image,\"comment\",comment);", "             comment=DestroyString(comment);", "             if ((length & 0x01) == 0)", "               (void) ReadBlobByte(image);", "            }", "        }", "      if (EOFBlob(image) != MagickFalse)", "      {", "        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "          image->filename);", "        break;", "      }", "       ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "      if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))", "        if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "          break;", "     status=SetImageExtent(image,image->columns,image->rows);", "     if (status == MagickFalse)", "       {", "         InheritException(exception,&image->exception);", "         return(DestroyImageList(image));", "       }", "      ", "     if (image->matte != MagickFalse)", "       number_planes++;", "     number_pixels=(MagickSizeType) image->columns*image->rows;", "     number_planes_filled=(number_planes % 2 == 0) ? number_planes :", "       number_planes+1;", "     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*", "          number_planes_filled))", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     pixel_info=AcquireVirtualMemory(image->columns,image->rows*", "       MagickMax(number_planes_filled,4)*sizeof(*pixels));", "     if (pixel_info == (MemoryInfo *) NULL)", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     pixel_info_length=image->columns*image->rows*", "       MagickMax(number_planes_filled,4);", "     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);", "     (void) ResetMagickMemory(pixels,0,pixel_info_length);", "     if ((flags & 0x01) && !(flags & 0x02))", "       {", "         ssize_t", "           j;", " ", "          ", "         p=pixels;", "         for (i=0; i < (ssize_t) number_pixels; i++)", "         {", "           if (image->matte == MagickFalse)", "             for (j=0; j < (ssize_t) number_planes; j++)", "               *p++=background_color[j];", "           else", "             {", "               for (j=0; j < (ssize_t) (number_planes-1); j++)", "                 *p++=background_color[j];", "               *p++=0;   ", "             }", "         }", "       }", "      ", "     plane=0;", "      x=0;", "      y=0;", "      opcode=ReadBlobByte(image);", "     if (opcode == EOF)", "       ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "      do", "      {", "        switch (opcode & 0x3f)", "        {", "          case SkipLinesOp:", "          {", "            operand=ReadBlobByte(image);", "           if (opcode == EOF)", "             ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "            if (opcode & 0x40)", "            operand=ReadBlobLSBSignedShort(image);", "             {", "               operand=ReadBlobLSBSignedShort(image);", "               if (opcode == EOF)", "                 ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "             }", "            x=0;", "            y+=operand;", "            break;", "          }", "          case SetColorOp:", "          {", "            operand=ReadBlobByte(image);", "           if (opcode == EOF)", "             ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "            plane=(unsigned char) operand;", "            if (plane == 255)", "              plane=(unsigned char) (number_planes-1);", "           x=0;", "           break;", "         }", "          case SkipPixelsOp:", "          {", "            operand=ReadBlobByte(image);", "           if (opcode == EOF)", "             ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "            if (opcode & 0x40)", "            operand=ReadBlobLSBSignedShort(image);", "             {", "               operand=ReadBlobLSBSignedShort(image);", "               if (opcode == EOF)", "                 ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "             }", "            x+=operand;", "            break;", "          }", "          case ByteDataOp:", "          {", "            operand=ReadBlobByte(image);", "           if (opcode == EOF)", "             ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "            if (opcode & 0x40)", "            operand=ReadBlobLSBSignedShort(image);", "          offset=((image->rows-y-1)*image->columns*number_planes)+x*", "            number_planes+plane;", "             {", "               operand=ReadBlobLSBSignedShort(image);", "               if (opcode == EOF)", "                 ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "             }", "           offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*", "             number_planes+plane);", "            operand++;", "            if ((offset < 0) ||", "              (offset+((size_t) operand*number_planes) > pixel_info_length))", "               ((offset+operand*number_planes) > (ssize_t) pixel_info_length))", "              {", "                if (number_colormaps != 0)", "                  colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "               pixel_info=RelinquishVirtualMemory(pixel_info);", "               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "             }", "           p=pixels+offset;", "           for (i=0; i < (ssize_t) operand; i++)", "           {", "             pixel=(unsigned char) ReadBlobByte(image);", "             if ((y < (ssize_t) image->rows) &&", "                 ((x+i) < (ssize_t) image->columns))", "               *p=pixel;", "             p+=number_planes;", "           }", "           if (operand & 0x01)", "             (void) ReadBlobByte(image);", "           x+=operand;", "           break;", "         }", "          case RunDataOp:", "          {", "            operand=ReadBlobByte(image);", "           if (opcode == EOF)", "             ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "            if (opcode & 0x40)", "            operand=ReadBlobLSBSignedShort(image);", "             {", "               operand=ReadBlobLSBSignedShort(image);", "               if (opcode == EOF)", "                 ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "             }", "            pixel=(unsigned char) ReadBlobByte(image);", "            (void) ReadBlobByte(image);", "            operand++;", "          offset=((image->rows-y-1)*image->columns*number_planes)+x*", "            number_planes+plane;", "           offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*", "             number_planes+plane);", "            if ((offset < 0) ||", "              (offset+((size_t) operand*number_planes) > pixel_info_length))", "               ((offset+operand*number_planes) > (ssize_t) pixel_info_length))", "              {", "                if (number_colormaps != 0)", "                  colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "               pixel_info=RelinquishVirtualMemory(pixel_info);", "               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "             }", "           p=pixels+offset;", "           for (i=0; i < (ssize_t) operand; i++)", "           {", "             if ((y < (ssize_t) image->rows) &&", "                 ((x+i) < (ssize_t) image->columns))", "               *p=pixel;", "             p+=number_planes;", "           }", "           x+=operand;", "           break;", "         }", "         default:", "            break;", "        }", "        opcode=ReadBlobByte(image);", "       if (opcode == EOF)", "         ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");", "      } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));", "      if (number_colormaps != 0)", "        {", "         MagickStatusType", "           mask;", " ", "          ", "         mask=(MagickStatusType) (map_length-1);", "         p=pixels;", "         x=(ssize_t) number_planes;", "          if (number_colormaps == 1)", "            for (i=0; i < (ssize_t) number_pixels; i++)", "            {", "            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==", "             if (IsValidColormapIndex(image,(ssize_t) (*p & mask),&index,exception) ==", "                  MagickFalse)", "                break;", "              *p=colormap[(ssize_t) index];", "             p++;", "           }", "         else", "           if ((number_planes >= 3) && (number_colormaps >= 3))", "              for (i=0; i < (ssize_t) number_pixels; i++)", "                for (x=0; x < (ssize_t) number_planes; x++)", "                {", "                if (IsValidColormapIndex(image,(size_t) (x*map_length+", "                 if (IsValidColormapIndex(image,(ssize_t) (x*map_length+", "                      (*p & mask)),&index,exception) == MagickFalse)", "                    break;", "                  *p=colormap[(ssize_t) index];", "                 p++;", "               }", "         if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))", "           {", "             colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "             pixel_info=RelinquishVirtualMemory(pixel_info);", "             ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "           }", "       }", "      ", "     if (number_planes >= 3)", "       {", "          ", "         p=pixels;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (PixelPacket *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelRed(q,ScaleCharToQuantum(*p++));", "             SetPixelGreen(q,ScaleCharToQuantum(*p++));", "             SetPixelBlue(q,ScaleCharToQuantum(*p++));", "             if (image->matte != MagickFalse)", "               SetPixelAlpha(q,ScaleCharToQuantum(*p++));", "             q++;", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "       }", "     else", "       {", "          ", "         if (number_colormaps == 0)", "           map_length=256;", "         if (AcquireImageColormap(image,map_length) == MagickFalse)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         p=colormap;", "         if (number_colormaps == 1)", "           for (i=0; i < (ssize_t) image->colors; i++)", "           {", "              ", "             image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);", "             image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);", "             image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);", "           }", "         else", "           if (number_colormaps > 1)", "             for (i=0; i < (ssize_t) image->colors; i++)", "             {", "               image->colormap[i].red=ScaleCharToQuantum(*p);", "               image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));", "               image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));", "               p++;", "             }", "         p=pixels;", "         if (image->matte == MagickFalse)", "           {", "              ", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (PixelPacket *) NULL)", "                 break;", "               indexes=GetAuthenticIndexQueue(image);", "               for (x=0; x < (ssize_t) image->columns; x++)", "                 SetPixelIndex(indexes+x,*p++);", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "             (void) SyncImage(image);", "           }", "         else", "           {", "              ", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (PixelPacket *) NULL)", "                  break;", "                for (x=0; x < (ssize_t) image->columns; x++)", "                {", "                if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==", "                      MagickFalse)", "                    break;", "                  SetPixelRed(q,image->colormap[(ssize_t) index].red);", "                if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==", "                      MagickFalse)", "                    break;", "                  SetPixelGreen(q,image->colormap[(ssize_t) index].green);", "                if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                 if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==", "                      MagickFalse)", "                    break;", "                  SetPixelBlue(q,image->colormap[(ssize_t) index].blue);", "                 SetPixelAlpha(q,ScaleCharToQuantum(*p++));", "                 q++;", "               }", "               if (x < (ssize_t) image->columns)", "                 break;", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "             image->colormap=(PixelPacket *) RelinquishMagickMemory(", "               image->colormap);", "             image->storage_class=DirectClass;", "             image->colors=0;", "           }", "       }", "     if (number_colormaps != 0)", "       colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "     pixel_info=RelinquishVirtualMemory(pixel_info);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     (void) ReadBlobByte(image);", "     count=ReadBlob(image,2,(unsigned char *) magick);", "     if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))", "       {", "          ", "         AcquireNextImage(image_info,image);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void BaseRenderingContext2D::Reset() {", "   ValidateStateStack();", "   UnwindStateStack();", "   state_stack_.resize(1);", "   state_stack_.front() = CanvasRenderingContext2DState::Create();", "   path_.Clear();", "   if (PaintCanvas* c = ExistingDrawingCanvas()) {", "     DCHECK_EQ(c->getSaveCount(), 2);", "     c->restore();", "     c->save();", "     DCHECK(c->getTotalMatrix().isIdentity());", " #if DCHECK_IS_ON()", "     SkIRect clip_bounds;", "     DCHECK(c->getDeviceClipBounds(&clip_bounds));", "     DCHECK(clip_bounds == c->imageInfo().bounds());", "  #endif", "    }", "    ValidateStateStack();", "   origin_tainted_by_content_ = false;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void RenderLayerCompositor::frameViewDidScroll()", " {", "     FrameView* frameView = m_renderView->frameView();", "     IntPoint scrollPosition = frameView->scrollPosition();", " ", "     if (!m_scrollLayer)", "         return;", " ", "     bool scrollingCoordinatorHandlesOffset = false;", "     if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {", "         if (Settings* settings = m_renderView->document().settings()) {", "             if (isMainFrame() || settings->compositedScrollingForFramesEnabled())", "                 scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);", "         }", "     }", " ", "     if (scrollingCoordinatorHandlesOffset)", "         m_scrollLayer->setPosition(-frameView->minimumScrollPosition());", "     else", "         m_scrollLayer->setPosition(-scrollPosition);", " ", " ", "     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",", "         ScrolledMainFrameBucket,", "         AcceleratedFixedRootBackgroundHistogramMax);", " ", "      if (!m_renderView->rootBackgroundIsEntirelyFixed())", "          return;", "  ", "      ", "      ", "     DisableCompositingQueryAsserts disabler;", " ", "      blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",", "          !!fixedRootBackgroundLayer()", "              ? ScrolledMainFrameWithAcceleratedFixedRootBackground", "             : ScrolledMainFrameWithUnacceleratedFixedRootBackground,", "         AcceleratedFixedRootBackgroundHistogramMax);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int fill_autodev(const struct lxc_rootfs *rootfs)", " {", " \tint ret;", " \tchar path[MAXPATHLEN];", " \tint i;", " \tmode_t cmask;", " ", " \tINFO(\"Creating initial consoles under container /dev\");", " ", " \tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");", " \tif (ret < 0 || ret >= MAXPATHLEN) {", " \t\tERROR(\"Error calculating container /dev location\");", " \t\treturn -1;", " \t}", " ", " \tif (!dir_exists(path))   ", " \t\treturn 0;", " ", " \tINFO(\"Populating container /dev\");", " \tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);", " \tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {", " \t\tconst struct lxc_devs *d = &lxc_devs[i];", " \t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);", " \t\tif (ret < 0 || ret >= MAXPATHLEN)", " \t\t\treturn -1;", " \t\tret = mknod(path, d->mode, makedev(d->maj, d->min));", " \t\tif (ret && errno != EEXIST) {", " \t\t\tchar hostpath[MAXPATHLEN];", " \t\t\tFILE *pathfile;", " ", " \t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);", " \t\t\tif (ret < 0 || ret >= MAXPATHLEN)", " \t\t\t\treturn -1;", " \t\t\tpathfile = fopen(path, \"wb\");", " \t\t\tif (!pathfile) {", " \t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);", "  \t\t\t\treturn -1;", "  \t\t\t}", "  \t\t\tfclose(pathfile);", "\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {", " \t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,", " \t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {", "  \t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",", "  \t\t\t\t\td->name);", "  \t\t\t\treturn -1;", " \t\t\t}", " \t\t}", " \t}", " \tumask(cmask);", " ", " \tINFO(\"Populated container /dev\");", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {", "xmlIDTablePtr table;", "xmlIDPtr id;", "xmlChar *ID;", "", "if (doc == NULL) return(-1);", "if (attr == NULL) return(-1);", "", "table = (xmlIDTablePtr) doc->ids;", "if (table == NULL)", "return(-1);", "", "ID = xmlNodeListGetString(doc, attr->children, 1);", "if (ID == NULL)", "return(-1);", "", "id = xmlHashLookup(table, ID);", "if (id == NULL || id->attr != attr) {", "xmlFree(ID);", "return(-1);", "}", "", "xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);", "xmlFree(ID);", "attr->atype = 0;", "return(0);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" MagickBooleanType sixel_decode(unsigned char                 *p,          ", "                                unsigned char                **pixels,    ", "                                size_t                       *pwidth,     ", "                                size_t                       *pheight,    ", "                                unsigned char                **palette,   ", "                                size_t                       *ncolors     )", " {", "     int n, i, r, g, b, sixel_vertical_mask, c;", "     int posision_x, posision_y;", "     int max_x, max_y;", "     int attributed_pan, attributed_pad;", "     int attributed_ph, attributed_pv;", "     int repeat_count, color_index, max_color_index = 2, background_color_index;", "     int param[10];", "     int sixel_palet[SIXEL_PALETTE_MAX];", "     unsigned char *imbuf, *dmbuf;", "     int imsx, imsy;", "     int dmsx, dmsy;", "     int y;", " ", "     posision_x = posision_y = 0;", "     max_x = max_y = 0;", "     attributed_pan = 2;", "     attributed_pad = 1;", "     attributed_ph = attributed_pv = 0;", "     repeat_count = 1;", "     color_index = 0;", "     background_color_index = 0;", "  ", "      imsx = 2048;", "      imsy = 2048;", "    imbuf = (unsigned char *) AcquireQuantumMemory(imsx * imsy,1);", "     imbuf = (unsigned char *) AcquireQuantumMemory(imsx , imsy);", "  ", "      if (imbuf == NULL) {", "          return(MagickFalse);", "     }", " ", "     for (n = 0; n < 16; n++) {", "         sixel_palet[n] = sixel_default_color_table[n];", "     }", " ", "      ", "     for (r = 0; r < 6; r++) {", "         for (g = 0; g < 6; g++) {", "             for (b = 0; b < 6; b++) {", "                 sixel_palet[n++] = SIXEL_RGB(r * 51, g * 51, b * 51);", "             }", "         }", "     }", "      ", "     for (i = 0; i < 24; i++) {", "         sixel_palet[n++] = SIXEL_RGB(i * 11, i * 11, i * 11);", "     }", " ", "     for (; n < SIXEL_PALETTE_MAX; n++) {", "          sixel_palet[n] = SIXEL_RGB(255, 255, 255);", "      }", "  ", "    (void) ResetMagickMemory(imbuf, background_color_index, imsx * imsy);", "     (void) ResetMagickMemory(imbuf, background_color_index, (size_t) imsx * imsy);", "  ", "      while (*p != '\\0') {", "          if ((p[0] == '\\033' && p[1] == 'P') || *p == 0x90) {", "             if (*p == '\\033') {", "                 p++;", "             }", " ", "             p = get_params(++p, param, &n);", " ", "             if (*p == 'q') {", "                 p++;", " ", "                 if (n > 0) {         ", "                     switch(param[0]) {", "                     case 0:", "                     case 1:", "                         attributed_pad = 2;", "                         break;", "                     case 2:", "                         attributed_pad = 5;", "                         break;", "                     case 3:", "                         attributed_pad = 4;", "                         break;", "                     case 4:", "                         attributed_pad = 4;", "                         break;", "                     case 5:", "                         attributed_pad = 3;", "                         break;", "                     case 6:", "                         attributed_pad = 3;", "                         break;", "                     case 7:", "                         attributed_pad = 2;", "                         break;", "                     case 8:", "                         attributed_pad = 2;", "                         break;", "                     case 9:", "                         attributed_pad = 1;", "                         break;", "                     }", "                 }", " ", "                 if (n > 2) {         ", "                     if (param[2] == 0) {", "                         param[2] = 10;", "                     }", "                     attributed_pan = attributed_pan * param[2] / 10;", "                     attributed_pad = attributed_pad * param[2] / 10;", "                     if (attributed_pan <= 0) attributed_pan = 1;", "                     if (attributed_pad <= 0) attributed_pad = 1;", "                 }", "             }", " ", "         } else if ((p[0] == '\\033' && p[1] == '\\\\') || *p == 0x9C) {", "             break;", "         } else if (*p == '\"') {", "              ", "             p = get_params(++p, param, &n);", " ", "             if (n > 0) attributed_pad = param[0];", "             if (n > 1) attributed_pan = param[1];", "             if (n > 2 && param[2] > 0) attributed_ph = param[2];", "             if (n > 3 && param[3] > 0) attributed_pv = param[3];", " ", "             if (attributed_pan <= 0) attributed_pan = 1;", "             if (attributed_pad <= 0) attributed_pad = 1;", " ", "              if (imsx < attributed_ph || imsy < attributed_pv) {", "                  dmsx = imsx > attributed_ph ? imsx : attributed_ph;", "                  dmsy = imsy > attributed_pv ? imsy : attributed_pv;", "                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);", "                 dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);", "                  if (dmbuf == (unsigned char *) NULL) {", "                      imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "                      return (MagickFalse);", "                  }", "                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);", "                 (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);", "                  for (y = 0; y < imsy; ++y) {", "                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);", "                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + (size_t) imsx * y, imsx);", "                  }", "                  imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "                  imsx = dmsx;", "                 imsy = dmsy;", "                 imbuf = dmbuf;", "             }", " ", "         } else if (*p == '!') {", "              ", "             p = get_params(++p, param, &n);", " ", "             if (n > 0) {", "                 repeat_count = param[0];", "             }", " ", "         } else if (*p == '#') {", "              ", "             p = get_params(++p, param, &n);", " ", "             if (n > 0) {", "                 if ((color_index = param[0]) < 0) {", "                     color_index = 0;", "                 } else if (color_index >= SIXEL_PALETTE_MAX) {", "                     color_index = SIXEL_PALETTE_MAX - 1;", "                 }", "             }", " ", "             if (n > 4) {", "                 if (param[1] == 1) {             ", "                     if (param[2] > 360) param[2] = 360;", "                     if (param[3] > 100) param[3] = 100;", "                     if (param[4] > 100) param[4] = 100;", "                     sixel_palet[color_index] = hls_to_rgb(param[2] * 100 / 360, param[3], param[4]);", "                 } else if (param[1] == 2) {     ", "                     if (param[2] > 100) param[2] = 100;", "                     if (param[3] > 100) param[3] = 100;", "                     if (param[4] > 100) param[4] = 100;", "                     sixel_palet[color_index] = SIXEL_XRGB(param[2], param[3], param[4]);", "                 }", "             }", " ", "         } else if (*p == '$') {", "              ", "             p++;", "             posision_x = 0;", "             repeat_count = 1;", " ", "         } else if (*p == '-') {", "              ", "             p++;", "             posision_x  = 0;", "             posision_y += 6;", "             repeat_count = 1;", " ", "         } else if (*p >= '?' && *p <= '\\177') {", "             if (imsx < (posision_x + repeat_count) || imsy < (posision_y + 6)) {", "                 int nx = imsx * 2;", "                 int ny = imsy * 2;", " ", "                 while (nx < (posision_x + repeat_count) || ny < (posision_y + 6)) {", "                     nx *= 2;", "                     ny *= 2;", "                 }", "  ", "                  dmsx = nx;", "                  dmsy = ny;", "                dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1);", "                 dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy);", "                  if (dmbuf == (unsigned char *) NULL) {", "                      imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "                      return (MagickFalse);", "                  }", "                (void) ResetMagickMemory(dmbuf, background_color_index, dmsx * dmsy);", "                 (void) ResetMagickMemory(dmbuf, background_color_index, (size_t) dmsx * dmsy);", "                  for (y = 0; y < imsy; ++y) {", "                    (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, imsx);", "                     (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + (size_t) imsx * y, imsx);", "                  }", "                  imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "                  imsx = dmsx;", "                 imsy = dmsy;", "                 imbuf = dmbuf;", "             }", " ", "             if (color_index > max_color_index) {", "                 max_color_index = color_index;", "             }", "             if ((b = *(p++) - '?') == 0) {", "                 posision_x += repeat_count;", " ", "             } else {", "                 sixel_vertical_mask = 0x01;", " ", "                 if (repeat_count <= 1) {", "                     for (i = 0; i < 6; i++) {", "                         if ((b & sixel_vertical_mask) != 0) {", "                             imbuf[imsx * (posision_y + i) + posision_x] = color_index;", "                             if (max_x < posision_x) {", "                                 max_x = posision_x;", "                             }", "                             if (max_y < (posision_y + i)) {", "                                 max_y = posision_y + i;", "                             }", "                         }", "                         sixel_vertical_mask <<= 1;", "                     }", "                     posision_x += 1;", " ", "                 } else {  ", "                     for (i = 0; i < 6; i++) {", "                         if ((b & sixel_vertical_mask) != 0) {", "                             c = sixel_vertical_mask << 1;", "                             for (n = 1; (i + n) < 6; n++) {", "                                 if ((b & c) == 0) {", "                                     break;", "                                 }", "                                  c <<= 1;", "                              }", "                              for (y = posision_y + i; y < posision_y + i + n; ++y) {", "                                (void) ResetMagickMemory(imbuf + imsx * y + posision_x, color_index, repeat_count);", "                                 (void) ResetMagickMemory(imbuf + (size_t) imsx * y + posision_x, color_index, repeat_count);", "                              }", "                              if (max_x < (posision_x + repeat_count - 1)) {", "                                  max_x = posision_x + repeat_count - 1;", "                             }", "                             if (max_y < (posision_y + i + n - 1)) {", "                                 max_y = posision_y + i + n - 1;", "                             }", " ", "                             i += (n - 1);", "                             sixel_vertical_mask <<= (n - 1);", "                         }", "                         sixel_vertical_mask <<= 1;", "                     }", "                     posision_x += repeat_count;", "                 }", "             }", "             repeat_count = 1;", "         } else {", "             p++;", "         }", "     }", " ", "     if (++max_x < attributed_ph) {", "         max_x = attributed_ph;", "     }", "     if (++max_y < attributed_pv) {", "         max_y = attributed_pv;", "     }", " ", "      if (imsx > max_x || imsy > max_y) {", "          dmsx = max_x;", "          dmsy = max_y;", "        if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx * dmsy,1)) == NULL) {", "         if ((dmbuf = (unsigned char *) AcquireQuantumMemory(dmsx , dmsy)) == NULL) {", "              imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "              return (MagickFalse);", "          }", "         for (y = 0; y < dmsy; ++y) {", "             (void) CopyMagickMemory(dmbuf + dmsx * y, imbuf + imsx * y, dmsx);", "         }", "         imbuf = (unsigned char *) RelinquishMagickMemory(imbuf);", "         imsx = dmsx;", "         imsy = dmsy;", "         imbuf = dmbuf;", "     }", " ", "     *pixels = imbuf;", "     *pwidth = imsx;", "     *pheight = imsy;", "     *ncolors = max_color_index + 1;", "     *palette = (unsigned char *) AcquireQuantumMemory(*ncolors,4);", "     for (n = 0; n < (ssize_t) *ncolors; ++n) {", "         (*palette)[n * 4 + 0] = sixel_palet[n] >> 16 & 0xff;", "         (*palette)[n * 4 + 1] = sixel_palet[n] >> 8 & 0xff;", "         (*palette)[n * 4 + 2] = sixel_palet[n] & 0xff;", "         (*palette)[n * 4 + 3] = 0xff;", "     }", "     return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  ExtensionsGuestViewMessageFilter::ExtensionsGuestViewMessageFilter(", "      int render_process_id,", "     BrowserContext* context)", "     : GuestViewMessageFilter(kFilteredMessageClasses,", "                              base::size(kFilteredMessageClasses),", "                               render_process_id,", "                               context),", "        content::BrowserAssociatedInterface<mojom::GuestView>(this, this) {", "  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static int key_notify_policy_flush(const struct km_event *c)", " {", " \tstruct sk_buff *skb_out;", " \tstruct sadb_msg *hdr;", " ", " \tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);", " \tif (!skb_out)", " \t\treturn -ENOBUFS;", " \thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));", " \thdr->sadb_msg_type = SADB_X_SPDFLUSH;", " \thdr->sadb_msg_seq = c->seq;", " \thdr->sadb_msg_pid = c->portid;", " \thdr->sadb_msg_version = PF_KEY_V2;", "  \thdr->sadb_msg_errno = (uint8_t) 0;", "  \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;", "  \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));", " \thdr->sadb_msg_reserved = 0;", "  \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);", "  \treturn 0;", "  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["repodata_schema2id(Repodata *data, Id *schema, int create)", "{", "int h, len, i;", "Id *sp, cid;", "Id *schematahash;", "", "if (!*schema)", "return 0;", "if ((schematahash = data->schematahash) == 0)", "{", "data->schematahash = schematahash = solv_calloc(256, sizeof(Id));", "for (i = 1; i < data->nschemata; i++)", "{", "for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)", "h = h * 7 + *sp++;", "h &= 255;", "schematahash[h] = i;", "}", "data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);", "data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);", "}", "", "for (sp = schema, len = 0, h = 0; *sp; len++)", "h = h * 7 + *sp++;", "h &= 255;", "len++;", "", "cid = schematahash[h];", "if (cid)", "{", "if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))", "return cid;", "", "for (cid = 1; cid < data->nschemata; cid++)", "if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))", "return cid;", "}", "", "if (!create)", "return 0;", "data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);", "data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);", "", "memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));", "data->schemata[data->nschemata] = data->schemadatalen;", "data->schemadatalen += len;", "schematahash[h] = data->nschemata;", "#if 0", "fprintf(stderr, \"schema2id: new schema\\n\");", "#endif", "return data->nschemata++;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int hashtable_do_del(hashtable_t *hashtable,", "                             const char *key, size_t hash)", " {", "     pair_t *pair;", "      bucket_t *bucket;", "      size_t index;", "  ", "    index = hash % num_buckets(hashtable);", "     index = hash & hashmask(hashtable->order);", "      bucket = &hashtable->buckets[index];", "  ", "      pair = hashtable_find_pair(hashtable, bucket, key, hash);", "     if(!pair)", "         return -1;", " ", "     if(&pair->list == bucket->first && &pair->list == bucket->last)", "         bucket->first = bucket->last = &hashtable->list;", " ", "     else if(&pair->list == bucket->first)", "         bucket->first = pair->list.next;", " ", "     else if(&pair->list == bucket->last)", "         bucket->last = pair->list.prev;", " ", "     list_remove(&pair->list);", "     json_decref(pair->value);", " ", "     jsonp_free(pair);", "     hashtable->size--;", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" asmlinkage void __sched schedule(void)", " {", " \tstruct task_struct *prev, *next;", " \tunsigned long *switch_count;", " \tstruct rq *rq;", " \tint cpu;", " ", " need_resched:", " \tpreempt_disable();", " \tcpu = smp_processor_id();", " \trq = cpu_rq(cpu);", " \trcu_note_context_switch(cpu);", " \tprev = rq->curr;", " ", " \trelease_kernel_lock(prev);", " need_resched_nonpreemptible:", " ", " \tschedule_debug(prev);", " ", " \tif (sched_feat(HRTICK))", "  \t\thrtick_clear(rq);", "  ", "  \traw_spin_lock_irq(&rq->lock);", "\tclear_tsk_need_resched(prev);", "  ", "  \tswitch_count = &prev->nivcsw;", "  \tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {", " \t\tif (unlikely(signal_pending_state(prev->state, prev))) {", " \t\t\tprev->state = TASK_RUNNING;", " \t\t} else {", " \t\t\t ", " \t\t\tif (prev->flags & PF_WQ_WORKER) {", " \t\t\t\tstruct task_struct *to_wakeup;", " ", " \t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);", " \t\t\t\tif (to_wakeup)", " \t\t\t\t\ttry_to_wake_up_local(to_wakeup);", " \t\t\t}", " \t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);", " \t\t}", " \t\tswitch_count = &prev->nvcsw;", " \t}", " ", " \tpre_schedule(rq, prev);", " ", " \tif (unlikely(!rq->nr_running))", " \t\tidle_balance(cpu, rq);", "  ", "  \tput_prev_task(rq, prev);", "  \tnext = pick_next_task(rq);", " \tclear_tsk_need_resched(prev);", " \trq->skip_clock_update = 0;", "  ", "  \tif (likely(prev != next)) {", "  \t\tsched_info_switch(prev, next);", " \t\tperf_event_task_sched_out(prev, next);", " ", "  \t\trq->nr_switches++;", "  \t\trq->curr = next;", "  \t\t++*switch_count;", " \t\tWARN_ON_ONCE(test_tsk_need_resched(next));", "  ", "  \t\tcontext_switch(rq, prev, next);  ", "  \t\t ", " \t\tcpu = smp_processor_id();", " \t\trq = cpu_rq(cpu);", " \t} else", " \t\traw_spin_unlock_irq(&rq->lock);", " ", " \tpost_schedule(rq);", " ", " \tif (unlikely(reacquire_kernel_lock(prev)))", " \t\tgoto need_resched_nonpreemptible;", " ", " \tpreempt_enable_no_resched();", " \tif (need_resched())", " \t\tgoto need_resched;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {", "assert(sxe->instanceof(SimpleXMLElement_classof()));", "auto data = Native::data<SimpleXMLElement>(sxe.get());", "return php_sxe_get_first_node(data, data->nodep());", "}"], "ner_tags": [0, 1, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE SoftMPEG4Encoder::initEncParams() {", "     CHECK(mHandle != NULL);", "     memset(mHandle, 0, sizeof(tagvideoEncControls));", " ", "     CHECK(mEncParams != NULL);", "     memset(mEncParams, 0, sizeof(tagvideoEncOptions));", "  if (!PVGetDefaultEncOption(mEncParams, 0)) {", "         ALOGE(\"Failed to get default encoding parameters\");", "  return OMX_ErrorUndefined;", "  }", "     mEncParams->encMode = mEncodeMode;", "     mEncParams->encWidth[0] = mWidth;", "     mEncParams->encHeight[0] = mHeight;", "     mEncParams->encFrameRate[0] = mFramerate >> 16;  ", "     mEncParams->rcType = VBR_1;", "     mEncParams->vbvDelay = 5.0f;", " ", "     mEncParams->profile_level = CORE_PROFILE_LEVEL2;", "     mEncParams->packetSize = 32;", "     mEncParams->rvlcEnable = PV_OFF;", "     mEncParams->numLayers = 1;", "     mEncParams->timeIncRes = 1000;", "     mEncParams->tickPerSrc = ((int64_t)mEncParams->timeIncRes << 16) / mFramerate;", " ", "     mEncParams->bitRate[0] = mBitrate;", "     mEncParams->iQuant[0] = 15;", "     mEncParams->pQuant[0] = 12;", "     mEncParams->quantType[0] = 0;", "     mEncParams->noFrameSkipped = PV_OFF;", " ", " ", "      if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) {", "          free(mInputFrameData);", "         mInputFrameData = NULL;", "         if (((uint64_t)mWidth * mHeight) > ((uint64_t)INT32_MAX / 3)) {", "             ALOGE(\"b/25812794, Buffer size is too big.\");", "             return OMX_ErrorBadParameter;", "         }", "          mInputFrameData =", "              (uint8_t *) malloc((mWidth * mHeight * 3 ) >> 1);", "          CHECK(mInputFrameData != NULL);", "  }", " ", "  if (mWidth % 16 != 0 || mHeight % 16 != 0) {", "         ALOGE(\"Video frame size %dx%d must be a multiple of 16\",", "             mWidth, mHeight);", "  return OMX_ErrorBadParameter;", "  }", " ", "  if (mIDRFrameRefreshIntervalInSec < 0) {", "         mEncParams->intraPeriod = -1;", "  } else if (mIDRFrameRefreshIntervalInSec == 0) {", "         mEncParams->intraPeriod = 1;  ", "  } else {", "         mEncParams->intraPeriod =", "  (mIDRFrameRefreshIntervalInSec * mFramerate) >> 16;", "  }", " ", "     mEncParams->numIntraMB = 0;", "     mEncParams->sceneDetect = PV_ON;", "     mEncParams->searchRange = 16;", "     mEncParams->mv8x8Enable = PV_OFF;", "     mEncParams->gobHeaderInterval = 0;", "     mEncParams->useACPred = PV_ON;", "     mEncParams->intraDCVlcTh = 0;", " ", "  return OMX_ErrorNone;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int __net_init sit_init_net(struct net *net)", " {", " \tstruct sit_net *sitn = net_generic(net, sit_net_id);", " \tstruct ip_tunnel *t;", " \tint err;", " ", " \tsitn->tunnels[0] = sitn->tunnels_wc;", " \tsitn->tunnels[1] = sitn->tunnels_l;", " \tsitn->tunnels[2] = sitn->tunnels_r;", " \tsitn->tunnels[3] = sitn->tunnels_r_l;", " ", " \tif (!net_has_fallback_tunnels(net))", " \t\treturn 0;", " ", " \tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",", " \t\t\t\t\t   NET_NAME_UNKNOWN,", " \t\t\t\t\t   ipip6_tunnel_setup);", " \tif (!sitn->fb_tunnel_dev) {", " \t\terr = -ENOMEM;", " \t\tgoto err_alloc_dev;", " \t}", " \tdev_net_set(sitn->fb_tunnel_dev, net);", " \tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;", " \t ", " \tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;", " ", " \terr = register_netdev(sitn->fb_tunnel_dev);", " \tif (err)", " \t\tgoto err_reg_dev;", " ", " \tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);", " \tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);", " ", " \tt = netdev_priv(sitn->fb_tunnel_dev);", " ", " \tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);", " \treturn 0;", "  ", "  err_reg_dev:", "  \tipip6_dev_free(sitn->fb_tunnel_dev);", " \tfree_netdev(sitn->fb_tunnel_dev);", "  err_alloc_dev:", "  \treturn err;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static int ssl_scan_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al)", " \t{", " \tunsigned short length;", " \tunsigned short type;", " \tunsigned short size;", " \tunsigned char *data = *p;", " \tint tlsext_servername = 0;", " \tint renegotiate_seen = 0;", " ", " #ifndef OPENSSL_NO_NEXTPROTONEG", " \ts->s3->next_proto_neg_seen = 0;", " #endif", " ", " \tif (s->s3->alpn_selected)", " \t\t{", " \t\tOPENSSL_free(s->s3->alpn_selected);", " \t\ts->s3->alpn_selected = NULL;", " \t\t}", " ", " #ifndef OPENSSL_NO_HEARTBEATS", " \ts->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED |", " \t                       SSL_TLSEXT_HB_DONT_SEND_REQUESTS);", " #endif", " ", " #ifdef TLSEXT_TYPE_encrypt_then_mac", " \ts->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;", " #endif", " ", " \tif (data >= (d+n-2))", " \t\tgoto ri_check;", " ", " \tn2s(data,length);", " \tif (data+length != d+n)", " \t\t{", " \t\t*al = SSL_AD_DECODE_ERROR;", " \t\treturn 0;", " \t\t}", " ", " \twhile(data <= (d+n-4))", " \t\t{", " \t\tn2s(data,type);", " \t\tn2s(data,size);", " ", " \t\tif (data+size > (d+n))", " \t   \t\tgoto ri_check;", " ", " \t\tif (s->tlsext_debug_cb)", " \t\t\ts->tlsext_debug_cb(s, 1, type, data, size,", " \t\t\t\t\t\ts->tlsext_debug_arg);", " ", " \t\tif (type == TLSEXT_TYPE_server_name)", " \t\t\t{", " \t\t\tif (s->tlsext_hostname == NULL || size > 0)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_UNRECOGNIZED_NAME;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\ttlsext_servername = 1;   ", " \t\t\t}", " ", " #ifndef OPENSSL_NO_EC", " \t\telse if (type == TLSEXT_TYPE_ec_point_formats)", " \t\t\t{", " \t\t\tunsigned char *sdata = data;", " \t\t\tint ecpointformatlist_length = *(sdata++);", " ", " \t\t\tif (ecpointformatlist_length != size - 1)", " \t\t\t\t{", "                                 *al = TLS1_AD_DECODE_ERROR;", "                                 return 0;", "                                 }", "                       s->session->tlsext_ecpointformatlist_length = 0;", "                       if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);", "                       if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)", "                        if (!s->hit)", "                                 {", "                               *al = TLS1_AD_INTERNAL_ERROR;", "                               return 0;", "                                s->session->tlsext_ecpointformatlist_length = 0;", "                                if (s->session->tlsext_ecpointformatlist != NULL) OPENSSL_free(s->session->tlsext_ecpointformatlist);", "                                if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL)", "                                        {", "                                        *al = TLS1_AD_INTERNAL_ERROR;", "                                        return 0;", "                                        }", "                                s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;", "                                memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);", "                                 }", "                       s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length;", "                       memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length);", "  #if 0", "                         fprintf(stderr,\"ssl_parse_serverhello_tlsext s->session->tlsext_ecpointformatlist \");", "                         sdata = s->session->tlsext_ecpointformatlist;", " #endif", " \t\t\t}", " #endif  ", " ", " \t\telse if (type == TLSEXT_TYPE_session_ticket)", " \t\t\t{", " \t\t\tif (s->tls_session_ticket_ext_cb &&", " \t\t\t    !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg))", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tif (!tls_use_ticket(s) || (size > 0))", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_UNSUPPORTED_EXTENSION;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\ts->tlsext_ticket_expected = 1;", " \t\t\t}", " #ifdef TLSEXT_TYPE_opaque_prf_input", " \t\telse if (type == TLSEXT_TYPE_opaque_prf_input)", " \t\t\t{", " \t\t\tunsigned char *sdata = data;", " ", " \t\t\tif (size < 2)", " \t\t\t\t{", " \t\t\t\t*al = SSL_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tn2s(sdata, s->s3->server_opaque_prf_input_len);", " \t\t\tif (s->s3->server_opaque_prf_input_len != size - 2)", " \t\t\t\t{", " \t\t\t\t*al = SSL_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t", " \t\t\tif (s->s3->server_opaque_prf_input != NULL)  ", " \t\t\t\tOPENSSL_free(s->s3->server_opaque_prf_input);", " \t\t\tif (s->s3->server_opaque_prf_input_len == 0)", " \t\t\t\ts->s3->server_opaque_prf_input = OPENSSL_malloc(1);  ", " \t\t\telse", " \t\t\t\ts->s3->server_opaque_prf_input = BUF_memdup(sdata, s->s3->server_opaque_prf_input_len);", " ", " \t\t\tif (s->s3->server_opaque_prf_input == NULL)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t}", " #endif", " \t\telse if (type == TLSEXT_TYPE_status_request)", " \t\t\t{", " \t\t\t  ", " \t\t\tif ((s->tlsext_status_type == -1) || (size > 0))", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_UNSUPPORTED_EXTENSION;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t ", " \t\t\ts->tlsext_status_expected = 1;", " \t\t\t}", " #ifndef OPENSSL_NO_NEXTPROTONEG", " \t\telse if (type == TLSEXT_TYPE_next_proto_neg &&", " \t\t\t s->s3->tmp.finish_md_len == 0)", " \t\t\t{", " \t\t\tunsigned char *selected;", " \t\t\tunsigned char selected_len;", " ", " \t\t\t ", " \t\t\tif (s->ctx->next_proto_select_cb == NULL)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_UNSUPPORTED_EXTENSION;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t ", " \t\t\tif (!ssl_next_proto_validate(data, size))", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tif (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s->ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\ts->next_proto_negotiated = OPENSSL_malloc(selected_len);", " \t\t\tif (!s->next_proto_negotiated)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tmemcpy(s->next_proto_negotiated, selected, selected_len);", " \t\t\ts->next_proto_negotiated_len = selected_len;", " \t\t\ts->s3->next_proto_neg_seen = 1;", " \t\t\t}", " #endif", " ", " \t\telse if (type == TLSEXT_TYPE_application_layer_protocol_negotiation)", " \t\t\t{", " \t\t\tunsigned len;", " ", " \t\t\t ", " \t\t\tif (s->alpn_client_proto_list == NULL)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_UNSUPPORTED_EXTENSION;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tif (size < 4)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t ", " \t\t\tlen = data[0];", " \t\t\tlen <<= 8;", " \t\t\tlen |= data[1];", " \t\t\tif (len != (unsigned) size - 2)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tlen = data[2];", " \t\t\tif (len != (unsigned) size - 3)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tif (s->s3->alpn_selected)", " \t\t\t\tOPENSSL_free(s->s3->alpn_selected);", " \t\t\ts->s3->alpn_selected = OPENSSL_malloc(len);", " \t\t\tif (!s->s3->alpn_selected)", " \t\t\t\t{", " \t\t\t\t*al = TLS1_AD_INTERNAL_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\tmemcpy(s->s3->alpn_selected, data + 3, len);", " \t\t\ts->s3->alpn_selected_len = len;", " \t\t\t}", " ", " \t\telse if (type == TLSEXT_TYPE_renegotiate)", " \t\t\t{", " \t\t\tif(!ssl_parse_serverhello_renegotiate_ext(s, data, size, al))", " \t\t\t\treturn 0;", " \t\t\trenegotiate_seen = 1;", " \t\t\t}", " #ifndef OPENSSL_NO_HEARTBEATS", " \t\telse if (type == TLSEXT_TYPE_heartbeat)", " \t\t\t{", " \t\t\tswitch(data[0])", " \t\t\t\t{", " \t\t\t\tcase 0x01:\t ", " \t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\tcase 0x02:\t ", " \t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED;", " \t\t\t\t\t\t\ts->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\tdefault:\t*al = SSL_AD_ILLEGAL_PARAMETER;", " \t\t\t\t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t}", " #endif", " \t\telse if (type == TLSEXT_TYPE_use_srtp)", "                         {", "                         if(ssl_parse_serverhello_use_srtp_ext(s, data, size,", " \t\t\t\t\t\t\t      al))", "                                 return 0;", "                         }", " \t\t ", " \t\telse if (s->ctx->custom_cli_ext_records_count)", " \t\t\t{", " \t\t\tsize_t i;", " \t\t\tcustom_cli_ext_record* record;", " ", " \t\t\tfor (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)", " \t\t\t\t{", " \t\t\t\trecord = &s->ctx->custom_cli_ext_records[i];", " \t\t\t\tif (record->ext_type == type)", " \t\t\t\t\t{", " \t\t\t\t\tif (record->fn2 && !record->fn2(s, type, data, size, al, record->arg))", " \t\t\t\t\t\treturn 0;", " \t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t}\t\t\t", " \t\t\t}", " #ifdef TLSEXT_TYPE_encrypt_then_mac", " \t\telse if (type == TLSEXT_TYPE_encrypt_then_mac)", " \t\t\t{", " \t\t\t ", " \t\t\tif (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD)", " \t\t\t\ts->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;", " \t\t\t}", " #endif", "  ", " \t\tdata += size;", " \t\t}", " ", " \tif (data != d+n)", " \t\t{", " \t\t*al = SSL_AD_DECODE_ERROR;", " \t\treturn 0;", " \t\t}", " ", " \tif (!s->hit && tlsext_servername == 1)", " \t\t{", "  \t\tif (s->tlsext_hostname)", " \t\t\t{", " \t\t\tif (s->session->tlsext_hostname == NULL)", " \t\t\t\t{", " \t\t\t\ts->session->tlsext_hostname = BUF_strdup(s->tlsext_hostname);\t", " \t\t\t\tif (!s->session->tlsext_hostname)", " \t\t\t\t\t{", " \t\t\t\t\t*al = SSL_AD_UNRECOGNIZED_NAME;", " \t\t\t\t\treturn 0;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\telse ", " \t\t\t\t{", " \t\t\t\t*al = SSL_AD_DECODE_ERROR;", " \t\t\t\treturn 0;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " ", " \t*p = data;", " ", " \tri_check:", " ", " \t ", " \tif (!renegotiate_seen", " \t\t&& !(s->options & SSL_OP_LEGACY_SERVER_CONNECT)", " \t\t&& !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))", " \t\t{", " \t\t*al = SSL_AD_HANDSHAKE_FAILURE;", " \t\tSSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT,", " \t\t\t\tSSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);", " \t\treturn 0;", " \t\t}", " ", " \treturn 1;", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int __init ipip_init(void)", " {", " \tint err;", "  ", "  \tprintk(banner);", "  ", "\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {", " \terr = register_pernet_device(&ipip_net_ops);", " \tif (err < 0)", " \t\treturn err;", " \terr = xfrm4_tunnel_register(&ipip_handler, AF_INET);", " \tif (err < 0) {", " \t\tunregister_pernet_device(&ipip_net_ops);", "  \t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");", "\t\treturn -EAGAIN;", "  \t}", "\terr = register_pernet_device(&ipip_net_ops);", "\tif (err)", "\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);", "  \treturn err;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0]}
{"tokens": ["  unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,", "  \t\t      const nodemask_t *nodemask, unsigned long totalpages)", "  {", "\tint points;", " \tlong points;", "  ", "  \tif (oom_unkillable_task(p, mem, nodemask))", "  \t\treturn 0;", " ", " \tp = find_lock_task_mm(p);", " \tif (!p)", " \t\treturn 0;", " ", " \t ", " \tif (atomic_read(&p->mm->oom_disable_count)) {", " \t\ttask_unlock(p);", " \t\treturn 0;", " \t}", " ", " \t ", " \tif (!totalpages)", " \t\ttotalpages = 1;", " ", " \t ", " \tpoints = get_mm_rss(p->mm) + p->mm->nr_ptes;", " \tpoints += get_mm_counter(p->mm, MM_SWAPENTS);", " ", " \tpoints *= 1000;", " \tpoints /= totalpages;", " \ttask_unlock(p);", " ", " \t ", " \tif (has_capability_noaudit(p, CAP_SYS_ADMIN))", " \t\tpoints -= 30;", " ", " \t ", " \tpoints += p->signal->oom_score_adj;", " ", " \t ", " \tif (points <= 0)", " \t\treturn 1;", " \treturn (points < 1000) ? points : 1000;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)", "{", "u64 runtime = 0, slice = sched_cfs_bandwidth_slice();", "unsigned long flags;", "u64 expires;", "", "", "raw_spin_lock_irqsave(&cfs_b->lock, flags);", "cfs_b->slack_started = false;", "if (cfs_b->distribute_running) {", "raw_spin_unlock_irqrestore(&cfs_b->lock, flags);", "return;", "}", "", "if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {", "raw_spin_unlock_irqrestore(&cfs_b->lock, flags);", "return;", "}", "", "if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)", "runtime = cfs_b->runtime;", "", "expires = cfs_b->runtime_expires;", "if (runtime)", "cfs_b->distribute_running = 1;", "", "raw_spin_unlock_irqrestore(&cfs_b->lock, flags);", "", "if (!runtime)", "return;", "", "runtime = distribute_cfs_runtime(cfs_b, runtime, expires);", "", "raw_spin_lock_irqsave(&cfs_b->lock, flags);", "if (expires == cfs_b->runtime_expires)", "lsub_positive(&cfs_b->runtime, runtime);", "cfs_b->distribute_running = 0;", "raw_spin_unlock_irqrestore(&cfs_b->lock, flags);", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,", " \t\t\t\t xmlNodePtr node,", "  \t\t\t\t xsltCompMatchPtr countPat,", "  \t\t\t\t xsltCompMatchPtr fromPat,", "  \t\t\t\t double *array,", "\t\t\t\t int max,", "\t\t\t\t xmlDocPtr doc,", "\t\t\t\t xmlNodePtr elem)", " \t\t\t\t int max)", "  {", "      int amount = 0;", "      int cnt;", "     xmlNodePtr ancestor;", "     xmlNodePtr preceding;", "     xmlXPathParserContextPtr parser;", " ", "     context->xpathCtxt->node = node;", "     parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);", "     if (parser) {", " \t ", " \tfor (ancestor = node;", " \t     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);", " \t     ancestor = xmlXPathNextAncestor(parser, ancestor)) {", " ", " \t    if ((fromPat != NULL) &&", "  \t\txsltTestCompMatchList(context, ancestor, fromPat))", "  \t\tbreak;  ", "  ", "\t    if ((countPat == NULL && node->type == ancestor->type &&", "\t\txmlStrEqual(node->name, ancestor->name)) ||", "\t\txsltTestCompMatchList(context, ancestor, countPat)) {", " \t    if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {", "  \t\t ", "\t\tcnt = 0;", "\t\tfor (preceding = ancestor;", " \t\tcnt = 1;", " \t\tfor (preceding =", "                         xmlXPathNextPrecedingSibling(parser, ancestor);", "  \t\t     preceding != NULL;", "  \t\t     preceding =", "  \t\t        xmlXPathNextPrecedingSibling(parser, preceding)) {", "\t\t    if (countPat == NULL) {", "\t\t\tif ((preceding->type == ancestor->type) &&", "\t\t\t    xmlStrEqual(preceding->name, ancestor->name)){", "\t\t\t    if ((preceding->ns == ancestor->ns) ||", "\t\t\t        ((preceding->ns != NULL) &&", "\t\t\t\t (ancestor->ns != NULL) &&", "\t\t\t         (xmlStrEqual(preceding->ns->href,", "\t\t\t             ancestor->ns->href) )))", "\t\t\t        cnt++;", "\t\t\t}", "\t\t    } else {", "\t\t\tif (xsltTestCompMatchList(context, preceding,", "\t\t\t\t                  countPat))", "\t\t\t    cnt++;", "\t\t    }", " ", " \t            if (xsltTestCompMatchCount(context, preceding, countPat,", "                                                node))", " \t\t\tcnt++;", "  \t\t}", "  \t\tarray[amount++] = (double)cnt;", "  \t\tif (amount >= max)", " \t\t    break;  ", " \t    }", " \t}", " \txmlXPathFreeParserContext(parser);", "     }", "     return amount;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" HTMLTreeBuilderSimulator::SimulatedToken HTMLTreeBuilderSimulator::Simulate(", "     const CompactHTMLToken& token,", "     HTMLTokenizer* tokenizer) {", "   SimulatedToken simulated_token = kOtherToken;", " ", "   if (token.GetType() == HTMLToken::kStartTag) {", "     const String& tag_name = token.Data();", "     if (ThreadSafeMatch(tag_name, SVGNames::svgTag))", "       namespace_stack_.push_back(SVG);", "     if (ThreadSafeMatch(tag_name, MathMLNames::mathTag))", "        namespace_stack_.push_back(kMathML);", "      if (InForeignContent() && TokenExitsForeignContent(token))", "        namespace_stack_.pop_back();", "    if ((namespace_stack_.back() == SVG && TokenExitsSVG(token)) ||", "        (namespace_stack_.back() == kMathML && TokenExitsMath(token)))", "     if (IsHTMLIntegrationPointForStartTag(token) ||", "         (namespace_stack_.back() == kMathML && TokenExitsMath(token))) {", "        namespace_stack_.push_back(HTML);", "    if (!InForeignContent()) {", "     } else if (!InForeignContent()) {", "        if (ThreadSafeMatch(tag_name, textareaTag) ||", "           ThreadSafeMatch(tag_name, titleTag)) {", "         tokenizer->SetState(HTMLTokenizer::kRCDATAState);", "       } else if (ThreadSafeMatch(tag_name, scriptTag)) {", "         tokenizer->SetState(HTMLTokenizer::kScriptDataState);", "         simulated_token = kScriptStart;", "       } else if (ThreadSafeMatch(tag_name, linkTag)) {", "         simulated_token = kLink;", "       } else if (!in_select_insertion_mode_) {", "         if (ThreadSafeMatch(tag_name, plaintextTag) &&", "             !in_select_insertion_mode_) {", "           tokenizer->SetState(HTMLTokenizer::kPLAINTEXTState);", "         } else if (ThreadSafeMatch(tag_name, styleTag) ||", "                    ThreadSafeMatch(tag_name, iframeTag) ||", "                    ThreadSafeMatch(tag_name, xmpTag) ||", "                    (ThreadSafeMatch(tag_name, noembedTag) &&", "                     options_.plugins_enabled) ||", "                    ThreadSafeMatch(tag_name, noframesTag) ||", "                    (ThreadSafeMatch(tag_name, noscriptTag) &&", "                     options_.script_enabled)) {", "           tokenizer->SetState(HTMLTokenizer::kRAWTEXTState);", "         }", "       }", " ", "       if (ThreadSafeMatch(tag_name, selectTag)) {", "         in_select_insertion_mode_ = true;", "       } else if (in_select_insertion_mode_ && TokenExitsInSelect(token)) {", "         in_select_insertion_mode_ = false;", "       }", "     }", "   }", " ", "   if (token.GetType() == HTMLToken::kEndTag ||", "       (token.GetType() == HTMLToken::kStartTag && token.SelfClosing() &&", "        InForeignContent())) {", "     const String& tag_name = token.Data();", "     if ((namespace_stack_.back() == SVG &&", "           ThreadSafeMatch(tag_name, SVGNames::svgTag)) ||", "          (namespace_stack_.back() == kMathML &&", "           ThreadSafeMatch(tag_name, MathMLNames::mathTag)) ||", "        (namespace_stack_.Contains(SVG) && namespace_stack_.back() == HTML &&", "         TokenExitsSVG(token)) ||", "         IsHTMLIntegrationPointForEndTag(token) ||", "          (namespace_stack_.Contains(kMathML) &&", "           namespace_stack_.back() == HTML && TokenExitsMath(token))) {", "        namespace_stack_.pop_back();", "     }", "     if (ThreadSafeMatch(tag_name, scriptTag)) {", "       if (!InForeignContent())", "         tokenizer->SetState(HTMLTokenizer::kDataState);", "       return kScriptEnd;", "     } else if (ThreadSafeMatch(tag_name, selectTag)) {", "       in_select_insertion_mode_ = false;", "     }", "     if (ThreadSafeMatch(tag_name, styleTag))", "       simulated_token = kStyleEnd;", "   }", " ", "   tokenizer->SetForceNullCharacterReplacement(InForeignContent());", "   tokenizer->SetShouldAllowCDATA(InForeignContent());", "    return simulated_token;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod12(ExecState* exec)", "  {", "      if (exec->argumentCount() < 1)", "        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));", "         return throwVMError(exec, createNotEnoughArgumentsError(exec));", "      const String& type(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));", "      if (exec->hadException())", "          return JSValue::encode(jsUndefined());", "     TestObj::overloadedMethod1(type);", "     return JSValue::encode(jsUndefined());", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" png_set_IHDR(png_structp png_ptr, png_infop info_ptr,", "    png_uint_32 width, png_uint_32 height, int bit_depth,", "    int color_type, int interlace_type, int compression_type,", "    int filter_type)", " {", "    png_debug1(1, \"in %s storage function\", \"IHDR\");", " ", "    if (png_ptr == NULL || info_ptr == NULL)", "       return;", " ", "    info_ptr->width = width;", "    info_ptr->height = height;", "    info_ptr->bit_depth = (png_byte)bit_depth;", "    info_ptr->color_type = (png_byte)color_type;", "    info_ptr->compression_type = (png_byte)compression_type;", "    info_ptr->filter_type = (png_byte)filter_type;", "    info_ptr->interlace_type = (png_byte)interlace_type;", " ", "    png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,", "        info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,", "        info_ptr->compression_type, info_ptr->filter_type);", " ", "    if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)", "       info_ptr->channels = 1;", "    else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)", "       info_ptr->channels = 3;", "    else", "       info_ptr->channels = 1;", "    if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)", "       info_ptr->channels++;", "    info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);", " ", "     ", "    if (width > (PNG_UINT_32_MAX", "                  >> 3)       ", "                  - 64        ", "                   - 1         ", "                   - 7*8       ", "                   - 8)        ", "    {", "        info_ptr->rowbytes = (png_size_t)0;", "       png_error(png_ptr, \"Image width is too large for this architecture\");", "    }", "     else", "        info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" int ipmi_si_mem_setup(struct si_sm_io *io)", " {", " \tunsigned long addr = io->addr_data;", " \tint           mapsize, idx;", " ", "  \tif (!addr)", "  \t\treturn -ENODEV;", "  ", "\tio->io_cleanup = mem_cleanup;", "  \t ", " \tswitch (io->regsize) {", " \tcase 1:", " \t\tio->inputb = intf_mem_inb;", " \t\tio->outputb = intf_mem_outb;", " \t\tbreak;", " \tcase 2:", " \t\tio->inputb = intf_mem_inw;", " \t\tio->outputb = intf_mem_outw;", " \t\tbreak;", " \tcase 4:", " \t\tio->inputb = intf_mem_inl;", " \t\tio->outputb = intf_mem_outl;", " \t\tbreak;", " #ifdef readq", " \tcase 8:", " \t\tio->inputb = mem_inq;", " \t\tio->outputb = mem_outq;", " \t\tbreak;", " #endif", " \tdefault:", " \t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",", " \t\t\t io->regsize);", " \t\treturn -EINVAL;", " \t}", " ", " \t ", " \tfor (idx = 0; idx < io->io_size; idx++) {", " \t\tif (request_mem_region(addr + idx * io->regspacing,", " \t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {", " \t\t\t ", " \t\t\tmem_region_cleanup(io, idx);", " \t\t\treturn -EIO;", " \t\t}", " \t}", " ", " \t ", " \tmapsize = ((io->io_size * io->regspacing)", " \t\t   - (io->regspacing - io->regsize));", " \tio->addr = ioremap(addr, mapsize);", " \tif (io->addr == NULL) {", "  \t\tmem_region_cleanup(io, io->io_size);", "  \t\treturn -EIO;", "  \t}", " ", " \tio->io_cleanup = mem_cleanup;", " ", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["  cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,", "    const cdf_stream_t *sst, const uint64_t clsid[2])", "     const cdf_stream_t *sst, const cdf_directory_t *root_storage)", "  {", "          cdf_summary_info_header_t si;", "          cdf_property_info_t *info;", "         size_t count;", "         int m;", " ", "         if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)", "                 return -1;", " ", "         if (NOTMIME(ms)) {", " \t\tconst char *str;", " ", "                 if (file_printf(ms, \"Composite Document File V2 Document\")", " \t\t    == -1)", "                         return -1;", " ", "                 if (file_printf(ms, \", %s Endian\",", "                     si.si_byte_order == 0xfffe ?  \"Little\" : \"Big\") == -1)", "                         return -2;", "                 switch (si.si_os) {", "                 case 2:", "                         if (file_printf(ms, \", Os: Windows, Version %d.%d\",", "                             si.si_os_version & 0xff,", "                             (uint32_t)si.si_os_version >> 8) == -1)", "                                 return -2;", "                         break;", "                 case 1:", "                         if (file_printf(ms, \", Os: MacOS, Version %d.%d\",", "                             (uint32_t)si.si_os_version >> 8,", "                             si.si_os_version & 0xff) == -1)", "                                 return -2;", "                         break;", "                 default:", "                         if (file_printf(ms, \", Os %d, Version: %d.%d\", si.si_os,", "                             si.si_os_version & 0xff,", "                             (uint32_t)si.si_os_version >> 8) == -1)", "                                  return -2;", "                          break;", "                  }", "\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);", "\t\tif (str)", "                        if (file_printf(ms, \", %s\", str) == -1)", "\t\t\t\treturn -2;", "        }", " \t\tif (root_storage) {", " \t\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2desc);", " \t\t\tif (str)", " \t\t\t\tif (file_printf(ms, \", %s\", str) == -1)", " \t\t\t\t\treturn -2;", " \t\t\t}", " \t\t}", "  ", "        m = cdf_file_property_info(ms, info, count, clsid);", "         m = cdf_file_property_info(ms, info, count, root_storage);", "          free(info);", "  ", "          return m == -1 ? -2 : m;", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)", "  {", "  \tint start = 0;", " \tint i;", "  \tu32 prev_legacy, cur_legacy;", "  \tmutex_lock(&kvm->arch.vpit->pit_state.lock);", "  \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;", " \tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;", " \tif (!prev_legacy && cur_legacy)", " \t\tstart = 1;", "  \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,", "  \t       sizeof(kvm->arch.vpit->pit_state.channels));", "  \tkvm->arch.vpit->pit_state.flags = ps->flags;", "\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);", " \tfor (i = 0; i < 3; i++)", " \t\tkvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);", "  \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  void UserSelectionScreen::FillMultiProfileUserPrefs(", "    user_manager::User* user,", "     const user_manager::User* user,", "      base::DictionaryValue* user_dict,", "      bool is_signin_to_add) {", "    if (!is_signin_to_add) {", "     user_dict->SetBoolean(kKeyMultiProfilesAllowed, true);", "     return;", "   }", " ", "   bool is_user_allowed;", "   ash::mojom::MultiProfileUserBehavior policy;", "   GetMultiProfilePolicy(user, &is_user_allowed, &policy);", "   user_dict->SetBoolean(kKeyMultiProfilesAllowed, is_user_allowed);", "   user_dict->SetInteger(kKeyMultiProfilesPolicy, static_cast<int>(policy));", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void copy_asoundrc(void) {", " \tchar *src = RUN_ASOUNDRC_FILE ;", " \tchar *dest;", " \tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)", " \t\terrExit(\"asprintf\");", " \t", " \tif (is_link(dest)) {", " \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);", "  \t\texit(1);", "  \t}", "  ", "\tpid_t child = fork();", "\tif (child < 0)", "\t\terrExit(\"fork\");", "\tif (child == 0) {", "\t\tdrop_privs(0);", "\t\tint rv = copy_file(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);", "\t\tif (rv)", "\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");", "\t\telse {", "\t\t\tfs_logger2(\"clone\", dest);", "\t\t}", "\t\t_exit(0);", "\t}", "\twaitpid(child, NULL, 0);", " \tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);", " \tfs_logger2(\"clone\", dest);", "  ", "  \tunlink(src);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" void perf_event_enable(struct perf_event *event)", " static void _perf_event_enable(struct perf_event *event)", "  {", "  \tstruct perf_event_context *ctx = event->ctx;", "  \tstruct task_struct *task = ctx->task;", " ", " \tif (!task) {", " \t\t ", " \t\tcpu_function_call(event->cpu, __perf_event_enable, event);", " \t\treturn;", " \t}", " ", " \traw_spin_lock_irq(&ctx->lock);", " \tif (event->state >= PERF_EVENT_STATE_INACTIVE)", " \t\tgoto out;", " ", " \t ", " \tif (event->state == PERF_EVENT_STATE_ERROR)", " \t\tevent->state = PERF_EVENT_STATE_OFF;", " ", " retry:", " \tif (!ctx->is_active) {", " \t\t__perf_event_mark_enabled(event);", " \t\tgoto out;", " \t}", " ", " \traw_spin_unlock_irq(&ctx->lock);", " ", " \tif (!task_function_call(task, __perf_event_enable, event))", " \t\treturn;", " ", " \traw_spin_lock_irq(&ctx->lock);", " ", " \t ", " \tif (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {", " \t\t ", " \t\ttask = ctx->task;", " \t\tgoto retry;", " \t}", " ", "  out:", "  \traw_spin_unlock_irq(&ctx->lock);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)", " {", "     if (!attrNode) {", "         ec = TYPE_MISMATCH_ERR;", "         return 0;", "     }", " ", "     RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());", "     if (oldAttrNode.get() == attrNode)", "         return attrNode;  ", " ", "     if (attrNode->ownerElement()) {", "         ec = INUSE_ATTRIBUTE_ERR;", "         return 0;", "     }", " ", "     synchronizeAllAttributes();", "     UniqueElementData* elementData = ensureUniqueElementData();", " ", "     size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());", "     if (index != notFound) {", "         if (oldAttrNode)", "             detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());", "         else", "             oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());", "     }", " ", "      setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);", "  ", "      attrNode->attachToElement(this);", "     treeScope()->adoptIfNeeded(attrNode);", "      ensureAttrNodeListForElement(this)->append(attrNode);", "  ", "      return oldAttrNode.release();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {", " \tstruct reloc_t *relocs;", " \tint i = 0, len;", " \tulebr ur = {NULL};", " \tint wordsize = MACH0_(get_bits)(bin) / 8;", " \tif (bin->dyld_info) {", " \t\tut8 *opcodes,*end, type = 0, rel_type = 0;", " \t\tint lib_ord, seg_idx = -1, sym_ord = -1;", " \t\tsize_t j, count, skip, bind_size, lazy_size;", " \t\tst64 addend = 0;", " \t\tut64 segmentAddress = 0LL;", " \t\tut64 addr = 0LL;", " \t\tut8 done = 0;", " ", " #define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break", " \t\tswitch (wordsize) {", " \t\tCASE(8);", " \t\tCASE(16);", " \t\tCASE(32);", " \t\tCASE(64);", " \t\tdefault: return NULL;", " \t\t}", " #undef CASE", " \t\tbind_size = bin->dyld_info->bind_size;", " \t\tlazy_size = bin->dyld_info->lazy_bind_size;", " ", " \t\tif (!bind_size || !lazy_size) {", " \t\t\treturn NULL;", " \t\t}", " ", "  \t\tif ((bind_size + lazy_size)<1) {", "  \t\t\treturn NULL;", "  \t\t}", "\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)", " \t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {", "  \t\t\treturn NULL;", " \t\t}", "  \t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\", "\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)", " \t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {", "  \t\t\treturn NULL;", "\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)", " \t\t}", " \t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {", "  \t\t\treturn NULL;", "\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))", " \t\t}", " \t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {", "  \t\t\treturn NULL;", " \t\t}", "  \t\topcodes = calloc (1, bind_size + lazy_size + 1);", "  \t\tif (!opcodes) {", "  \t\t\tfree (relocs);", " \t\t\treturn NULL;", " \t\t}", " \t\tlen = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);", " \t\ti = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);", " \t\tif (len < 1 || i < 1) {", " \t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",", " \t\t\t(ut64)(size_t)bin->dyld_info->bind_off);", " \t\t\tfree (opcodes);", " \t\t\trelocs[i].last = 1;", " \t\t\treturn relocs;", " \t\t}", " \t\ti = 0;", " \t\tfor (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {", " \t\t\tut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;", " \t\t\t++ur.p;", " \t\t\tswitch (op) {", " #define ULEB() read_uleb128 (&ur,end)", " #define SLEB() read_sleb128 (&ur,end)", " \t\t\tcase BIND_OPCODE_DONE:", " \t\t\t\tdone = 1;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:", " \t\t\t\tlib_ord = imm;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:", " \t\t\t\tlib_ord = ULEB();", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:", " \t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {", " \t\t\t\tchar *sym_name = (char*)ur.p;", " \t\t\t\twhile (*ur.p++ && ur.p<end) {", " \t\t\t\t\t ", " \t\t\t\t}", " \t\t\t\tsym_ord = -1;", " \t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < 0xffff)", " \t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {", " \t\t\t\t\tint stridx = 0;", " \t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;", " \t\t\t\t\tif (iundefsym>=0 && iundefsym < bin->nsymtab) {", " \t\t\t\t\t\tint sidx = iundefsym +j;", " \t\t\t\t\t\tif (sidx<0 || sidx>= bin->nsymtab)", " \t\t\t\t\t\t\tcontinue;", " \t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;", " \t\t\t\t\t\tif (stridx < 0 || stridx >= bin->symstrlen)", " \t\t\t\t\t\t\tcontinue;", " \t\t\t\t\t}", " \t\t\t\t\tif (!strcmp ((char *)bin->symstr + stridx, sym_name)) {", " \t\t\t\t\t\tsym_ord = j;", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tcase BIND_OPCODE_SET_TYPE_IMM:", " \t\t\t\ttype = imm;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:", " \t\t\t\taddend = SLEB();", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:", " \t\t\t\tseg_idx = imm;", " \t\t\t\tif (seg_idx < 0 || seg_idx >= bin->nsegs) {", " \t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"", " \t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);", " \t\t\t\t\taddr = 0LL;", " \t\t\t\t\treturn 0;  ", " \t\t\t\t} else {", " \t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + ULEB();", " \t\t\t\t\tsegmentAddress = bin->segs[seg_idx].vmaddr \\", " \t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:", " \t\t\t\taddr += ULEB();", " \t\t\t\tbreak;", " #define DO_BIND() do {\\", " if (sym_ord < 0 || seg_idx < 0 ) break;\\", " if (i >= (bind_size + lazy_size)) break;\\", " relocs[i].addr = addr;\\", " relocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\", " if (type == BIND_TYPE_TEXT_PCREL32)\\", " \trelocs[i].addend = addend - (bin->baddr + addr);\\", " else relocs[i].addend = addend;\\", "   \\", " relocs[i].ord = lib_ord;\\", " relocs[i].ord = sym_ord;\\", " relocs[i].type = rel_type;\\", " relocs[i++].last = 0;\\", " } while (0)", " \t\t\tcase BIND_OPCODE_DO_BIND:", " \t\t\t\tif (addr >= segmentAddress) {", " \t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode\\n\");", " \t\t\t\t\tgoto beach;", " \t\t\t\t}", " \t\t\t\tDO_BIND();", " \t\t\t\taddr += wordsize;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:", " \t\t\t\tif (addr >= segmentAddress) {", " \t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");", " \t\t\t\t\tgoto beach;", " \t\t\t\t}", " \t\t\t\tDO_BIND();", " \t\t\t\taddr += ULEB() + wordsize;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:", " \t\t\t\tif (addr >= segmentAddress) {", " \t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");", " \t\t\t\t\tgoto beach;", " \t\t\t\t}", " \t\t\t\tDO_BIND();", " \t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;", " \t\t\t\tbreak;", " \t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:", " \t\t\t\tcount = ULEB();", " \t\t\t\tskip = ULEB();", " \t\t\t\tfor (j = 0; j < count; j++) {", " \t\t\t\t\tif (addr >= segmentAddress) {", " \t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");", " \t\t\t\t\t\tgoto beach;", " \t\t\t\t\t}", " \t\t\t\t\tDO_BIND();", " \t\t\t\t\taddr += skip + wordsize;", " \t\t\t\t}", " \t\t\t\tbreak;", " #undef DO_BIND", " #undef ULEB", " #undef SLEB", " \t\t\tdefault:", " \t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);", " \t\t\t\tfree (opcodes);", " \t\t\t\trelocs[i].last = 1;", " \t\t\t\treturn relocs;", " \t\t\t}", " \t\t}", "  \t\tfree (opcodes);", "  \t} else {", "  \t\tint j;", "\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)", " \t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {", "  \t\t\treturn NULL;", "\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))", " \t\t}", " \t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {", "  \t\t\treturn NULL;", " \t\t}", "  \t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {", "\t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {", " \t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {", "  \t\t\t\trelocs[i].ord = j;", "  \t\t\t\trelocs[i++].last = 0;", "  \t\t\t}", " \t\t}", " \t}", " beach:", " \trelocs[i].last = 1;", " ", " \treturn relocs;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)", "{", "", "", "ASSERT(!(n < 4));", "auto predecessor = n.minus({ 1 });", "auto d = predecessor;", "size_t r = 0;", "", "{", "auto div_result = d.divided_by(2);", "while (div_result.remainder == 0) {", "d = div_result.quotient;", "div_result = d.divided_by(2);", "++r;", "}", "}", "if (r == 0) {", "", "return n == 2;", "}", "", "for (auto a : tests) {", "", "ASSERT(a < n);", "auto x = ModularPower(a, d, n);", "if (x == 1 || x == predecessor)", "continue;", "bool skip_this_witness = false;", "", "for (size_t i = 0; i < r - 1; ++i) {", "x = ModularPower(x, 2, n);", "if (x == predecessor) {", "skip_this_witness = true;", "break;", "}", "}", "if (skip_this_witness)", "continue;", "return false;", "}", "", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ThreadableBlobRegistry::registerStreamURL(const KURL& url, const String& type)", " void BlobRegistry::registerStreamURL(const KURL& url, const String& type)", "  {", "      if (isMainThread()) {", "        blobRegistry().registerStreamURL(url, type);", "         if (WebBlobRegistry* registry = blobRegistry())", "             registry->registerStreamURL(url, type);", "      } else {", "          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, type));", "          callOnMainThread(&registerStreamURLTask, context.leakPtr());", "     }", " }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int mailimf_group_parse(const char * message, size_t length,", " \t\t\t       size_t * indx,", " \t\t\t       struct mailimf_group ** result)", " {", "   size_t cur_token;", "   char * display_name;", "   struct mailimf_mailbox_list * mailbox_list;", "    struct mailimf_group * group;", "    int r;", "    int res;", "   clist * list;", "  ", "    cur_token = * indx;", "  ", "   mailbox_list = NULL;", " ", "   r = mailimf_display_name_parse(message, length, &cur_token, &display_name);", "   if (r != MAILIMF_NO_ERROR) {", "     res = r;", "     goto err;", "   }", " ", "   r = mailimf_colon_parse(message, length, &cur_token);", "   if (r != MAILIMF_NO_ERROR) {", "     res = r;", "     goto free_display_name;", "   }", " ", "   r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);", "   switch (r) {", "   case MAILIMF_NO_ERROR:", "     break;", "   case MAILIMF_ERROR_PARSE:", "     r = mailimf_cfws_parse(message, length, &cur_token);", "     if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {", "        res = r;", "        goto free_display_name;", "      }", "     list = clist_new();", "     if (list == NULL) {", "       res = MAILIMF_ERROR_MEMORY;", "       goto free_display_name;", "     }", "     mailbox_list = mailimf_mailbox_list_new(list);", "     if (mailbox_list == NULL) {", "       res = MAILIMF_ERROR_MEMORY;", "       clist_free(list);", "       goto free_display_name;", "     }", "      break;", "    default:", "      res = r;", "     goto free_display_name;", "   }", " ", "   r = mailimf_semi_colon_parse(message, length, &cur_token);", "   if (r != MAILIMF_NO_ERROR) {", "     res = r;", "     goto free_mailbox_list;", "   }", " ", "   group = mailimf_group_new(display_name, mailbox_list);", "   if (group == NULL) {", "     res = MAILIMF_ERROR_MEMORY;", "     goto free_mailbox_list;", "   }", " ", "   * indx = cur_token;", "   * result = group;", " ", "   return MAILIMF_NO_ERROR;", " ", "  free_mailbox_list:", "   if (mailbox_list != NULL) {", "     mailimf_mailbox_list_free(mailbox_list);", "   }", "  free_display_name:", "   mailimf_display_name_free(display_name);", "  err:", "   return res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)", " static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)", "  {", "  \tint i;", "  \tint c;", " \tfor (i = n; i > 0; --i) {", " \t\tc = (val >> (8 * (i - 1))) & 0xff;", " \t\tif (jas_stream_putc(out, c) == EOF)", " \t\t\treturn -1;", " \t}", "  \treturn 0;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static X509_ALGOR *rsa_mgf1_decode(X509_ALGOR *alg)", "  {", "      const unsigned char *p;", "      int plen;", "    if (alg == NULL)", "     if (alg == NULL || alg->parameter == NULL)", "          return NULL;", "      if (OBJ_obj2nid(alg->algorithm) != NID_mgf1)", "          return NULL;", "     if (alg->parameter->type != V_ASN1_SEQUENCE)", "         return NULL;", " ", "     p = alg->parameter->value.sequence->data;", "     plen = alg->parameter->value.sequence->length;", "     return d2i_X509_ALGOR(NULL, &p, plen);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)", " {", "     uint32_t flags, bps = 0;", "     uint32_t chan_mask = config->channel_mask;", "      int num_chans = config->num_channels;", "      int i;", "  ", "     if (!config->sample_rate) {", "         strcpy (wpc->error_message, \"sample rate cannot be zero!\");", "         return FALSE;", "     }", " ", "      wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;", "  ", "      if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {", " #ifdef ENABLE_DSD", "         wpc->dsd_multiplier = 1;", "         flags = DSD_FLAG;", " ", "         for (i = 14; i >= 0; --i)", "             if (config->sample_rate % sample_rates [i] == 0) {", "                 int divisor = config->sample_rate / sample_rates [i];", " ", "                 if (divisor && (divisor & (divisor - 1)) == 0) {", "                     config->sample_rate /= divisor;", "                     wpc->dsd_multiplier = divisor;", "                     break;", "                 }", "             }", " ", "         if (config->flags & CONFIG_HYBRID_FLAG) {", "             strcpy (wpc->error_message, \"hybrid mode not available for DSD!\");", "             return FALSE;", "         }", " ", "         config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);", "         config->float_norm_exp = config->xmode = 0;", " #else", "         strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");", "         return FALSE;", " #endif", "     }", "     else", "         flags = config->bytes_per_sample - 1;", " ", "     wpc->total_samples = total_samples;", "     wpc->config.sample_rate = config->sample_rate;", "     wpc->config.num_channels = config->num_channels;", "     wpc->config.channel_mask = config->channel_mask;", "     wpc->config.bits_per_sample = config->bits_per_sample;", "     wpc->config.bytes_per_sample = config->bytes_per_sample;", "     wpc->config.block_samples = config->block_samples;", "     wpc->config.flags = config->flags;", "     wpc->config.qmode = config->qmode;", " ", "     if (config->flags & CONFIG_VERY_HIGH_FLAG)", "         wpc->config.flags |= CONFIG_HIGH_FLAG;", " ", "     for (i = 0; i < 15; ++i)", "         if (wpc->config.sample_rate == sample_rates [i])", "             break;", " ", "     flags |= i << SRATE_LSB;", " ", " ", "     if (!(flags & DSD_FLAG)) {", "         if (config->float_norm_exp) {", "             wpc->config.float_norm_exp = config->float_norm_exp;", "             wpc->config.flags |= CONFIG_FLOAT_DATA;", "             flags |= FLOAT_DATA;", "         }", "         else", "             flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;", " ", "         if (config->flags & CONFIG_HYBRID_FLAG) {", "             flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;", " ", "             if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {", "                 wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;", "                 flags |= HYBRID_SHAPE | NEW_SHAPING;", "             }", "             else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {", "                 wpc->config.shaping_weight = config->shaping_weight;", "                 flags |= HYBRID_SHAPE | NEW_SHAPING;", "             }", " ", "             if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))", "                 flags |= CROSS_DECORR;", " ", "             if (config->flags & CONFIG_BITRATE_KBPS) {", "                 bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);", " ", "                 if (bps > (64 << 8))", "                     bps = 64 << 8;", "             }", "             else", "                 bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);", "         }", "         else", "             flags |= CROSS_DECORR;", " ", "         if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))", "             flags |= JOINT_STEREO;", " ", "         if (config->flags & CONFIG_CREATE_WVC)", "             wpc->wvc_flag = TRUE;", "     }", " ", " ", "     if (chan_ids) {", "         int lastchan = 0, mask_copy = chan_mask;", " ", "         if ((int) strlen ((char *) chan_ids) > num_chans) {           ", "             strcpy (wpc->error_message, \"chan_ids longer than num channels!\");", "             return FALSE;", "         }", " ", " ", "         while (*chan_ids)", "             if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {", "                 mask_copy &= ~(1 << (*chan_ids-1));", "                 lastchan = *chan_ids++;", "             }", "             else", "                 break;", " ", " ", "         for (i = 0; chan_ids [i]; i++)", "             if (chan_ids [i] != 0xff) {", "                 wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);", "                 break;", "             }", "     }", " ", " ", "     for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {", "         WavpackStream *wps = malloc (sizeof (WavpackStream));", "         unsigned char left_chan_id = 0, right_chan_id = 0;", "         int pos, chans = 1;", " ", "         wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));", "         wpc->streams [wpc->current_stream] = wps;", "         CLEAR (*wps);", " ", "         if (chan_mask)", "             for (pos = 0; pos < 32; ++pos)", "                 if (chan_mask & (1 << pos)) {", "                     if (left_chan_id) {", "                         right_chan_id = pos + 1;", "                         break;", "                     }", "                     else {", "                         chan_mask &= ~(1 << pos);", "                         left_chan_id = pos + 1;", "                     }", "                 }", " ", "         while (!right_chan_id && chan_ids && *chan_ids)", "             if (left_chan_id)", "                 right_chan_id = *chan_ids;", "             else", "                 left_chan_id = *chan_ids++;", " ", "         if (!left_chan_id)", "             left_chan_id = right_chan_id = 0xff;", "         else if (!right_chan_id)", "             right_chan_id = 0xff;", " ", "         if (num_chans >= 2) {", "             if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)", "                 chans = 2;", "             else", "                 for (i = 0; i < NUM_STEREO_PAIRS; ++i)", "                     if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||", "                         (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {", "                             if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))", "                                 chan_mask &= ~(1 << (right_chan_id-1));", "                             else if (chan_ids && *chan_ids == right_chan_id)", "                                 chan_ids++;", " ", "                             chans = 2;", "                             break;", "                         }", "         }", " ", "         num_chans -= chans;", " ", "         if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)", "             break;", " ", "         memcpy (wps->wphdr.ckID, \"wvpk\", 4);", "         wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;", "         SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);", "         wps->wphdr.version = wpc->stream_version;", "         wps->wphdr.flags = flags;", "         wps->bits = bps;", " ", "         if (!wpc->current_stream)", "             wps->wphdr.flags |= INITIAL_BLOCK;", " ", "         if (!num_chans)", "             wps->wphdr.flags |= FINAL_BLOCK;", " ", "         if (chans == 1) {", "             wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);", "             wps->wphdr.flags |= MONO_FLAG;", "         }", "     }", " ", "     wpc->num_streams = wpc->current_stream;", "     wpc->current_stream = 0;", " ", "     if (num_chans) {", "         strcpy (wpc->error_message, \"too many channels!\");", "         return FALSE;", "     }", " ", "     if (config->flags & CONFIG_EXTRA_MODE)", "         wpc->config.xmode = config->xmode ? config->xmode : 1;", " ", "     return TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" initpyfribidi (void)", " init_pyfribidi (void)", "  {", "\tPyObject *module;", "\t ", "\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,", "\t\t\t\t _pyfribidi__doc__);", "         PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);", "  \tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);", "  \tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);", "  \tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);", "\tPyModule_AddStringConstant (module, \"__author__\",", "\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");", "  }"], "ner_tags": [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0]}
{"tokens": [" void AppLauncherHandler::FillAppDictionary(base::DictionaryValue* dictionary) {", "   base::AutoReset<bool> auto_reset(&ignore_changes_, true);", " ", "   base::ListValue* list = new base::ListValue();", "   Profile* profile = Profile::FromWebUI(web_ui());", "   PrefService* prefs = profile->GetPrefs();", " ", "   for (std::set<std::string>::iterator it = visible_apps_.begin();", "        it != visible_apps_.end(); ++it) {", "     const Extension* extension = extension_service_->GetInstalledExtension(*it);", "     if (extension && extensions::ui_util::ShouldDisplayInNewTabPage(", "             extension, profile)) {", "       base::DictionaryValue* app_info = GetAppInfo(extension);", "       list->Append(app_info);", "     }", "   }", "  ", "    dictionary->Set(\"apps\", list);", "  ", "#if defined(OS_MACOSX)", "  dictionary->SetBoolean(\"disableAppWindowLaunch\", true);", "  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);", "#endif", "#if defined(OS_CHROMEOS)", "  dictionary->SetBoolean(\"disableCreateAppShortcut\", true);", "#endif", "    const base::ListValue* app_page_names =", "        prefs->GetList(prefs::kNtpAppPageNames);", "    if (!app_page_names || !app_page_names->GetSize()) {", "     ListPrefUpdate update(prefs, prefs::kNtpAppPageNames);", "     base::ListValue* list = update.Get();", "     list->Set(0, new base::StringValue(", "         l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME)));", "     dictionary->Set(\"appPageNames\",", "                     static_cast<base::ListValue*>(list->DeepCopy()));", "   } else {", "     dictionary->Set(\"appPageNames\",", "                     static_cast<base::ListValue*>(app_page_names->DeepCopy()));", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["explicit DataFormatDimMapOp(OpKernelConstruction* context)", ": OpKernel(context) {", "string src_format;", "OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));", "string dst_format;", "OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));", "OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,", "errors::InvalidArgument(strings::StrCat(", "\"Source format must of length 4 or 5, received \"", "\"src_format = \",", "src_format)));", "OP_REQUIRES(", "context, dst_format.size() == 4 || dst_format.size() == 5,", "errors::InvalidArgument(strings::StrCat(", "\"Destination format must of length 4 or 5, received dst_format = \",", "dst_format)));", "dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});", "for (int i = 0; i < src_format.size(); ++i) {", "for (int j = 0; j < dst_format.size(); ++j) {", "if (dst_format[j] == src_format[i]) {", "dst_idx_.vec<int>()(i) = j;", "break;", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void SocketStream::DoLoop(int result) {", "  if (!context_.get())", "   if (!context_)", "      next_state_ = STATE_CLOSE;", "  ", "    if (next_state_ == STATE_NONE)", "     return;", " ", "   do {", "     State state = next_state_;", "     next_state_ = STATE_NONE;", "     switch (state) {", "       case STATE_BEFORE_CONNECT:", "         DCHECK_EQ(OK, result);", "         result = DoBeforeConnect();", "         break;", "       case STATE_BEFORE_CONNECT_COMPLETE:", "         result = DoBeforeConnectComplete(result);", "         break;", "       case STATE_RESOLVE_PROXY:", "         DCHECK_EQ(OK, result);", "         result = DoResolveProxy();", "         break;", "       case STATE_RESOLVE_PROXY_COMPLETE:", "         result = DoResolveProxyComplete(result);", "         break;", "       case STATE_RESOLVE_HOST:", "         DCHECK_EQ(OK, result);", "         result = DoResolveHost();", "         break;", "       case STATE_RESOLVE_HOST_COMPLETE:", "         result = DoResolveHostComplete(result);", "         break;", "       case STATE_RESOLVE_PROTOCOL:", "         result = DoResolveProtocol(result);", "         break;", "       case STATE_RESOLVE_PROTOCOL_COMPLETE:", "         result = DoResolveProtocolComplete(result);", "         break;", "       case STATE_TCP_CONNECT:", "         result = DoTcpConnect(result);", "         break;", "       case STATE_TCP_CONNECT_COMPLETE:", "         result = DoTcpConnectComplete(result);", "         break;", "       case STATE_GENERATE_PROXY_AUTH_TOKEN:", "         result = DoGenerateProxyAuthToken();", "         break;", "       case STATE_GENERATE_PROXY_AUTH_TOKEN_COMPLETE:", "         result = DoGenerateProxyAuthTokenComplete(result);", "         break;", "       case STATE_WRITE_TUNNEL_HEADERS:", "         DCHECK_EQ(OK, result);", "         result = DoWriteTunnelHeaders();", "         break;", "       case STATE_WRITE_TUNNEL_HEADERS_COMPLETE:", "         result = DoWriteTunnelHeadersComplete(result);", "         break;", "       case STATE_READ_TUNNEL_HEADERS:", "         DCHECK_EQ(OK, result);", "         result = DoReadTunnelHeaders();", "         break;", "       case STATE_READ_TUNNEL_HEADERS_COMPLETE:", "         result = DoReadTunnelHeadersComplete(result);", "         break;", "       case STATE_SOCKS_CONNECT:", "         DCHECK_EQ(OK, result);", "         result = DoSOCKSConnect();", "         break;", "       case STATE_SOCKS_CONNECT_COMPLETE:", "         result = DoSOCKSConnectComplete(result);", "         break;", "       case STATE_SECURE_PROXY_CONNECT:", "         DCHECK_EQ(OK, result);", "         result = DoSecureProxyConnect();", "         break;", "       case STATE_SECURE_PROXY_CONNECT_COMPLETE:", "         result = DoSecureProxyConnectComplete(result);", "         break;", "       case STATE_SECURE_PROXY_HANDLE_CERT_ERROR:", "         result = DoSecureProxyHandleCertError(result);", "         break;", "       case STATE_SECURE_PROXY_HANDLE_CERT_ERROR_COMPLETE:", "         result = DoSecureProxyHandleCertErrorComplete(result);", "         break;", "       case STATE_SSL_CONNECT:", "         DCHECK_EQ(OK, result);", "         result = DoSSLConnect();", "         break;", "       case STATE_SSL_CONNECT_COMPLETE:", "         result = DoSSLConnectComplete(result);", "         break;", "       case STATE_SSL_HANDLE_CERT_ERROR:", "         result = DoSSLHandleCertError(result);", "         break;", "       case STATE_SSL_HANDLE_CERT_ERROR_COMPLETE:", "         result = DoSSLHandleCertErrorComplete(result);", "         break;", "       case STATE_READ_WRITE:", "         result = DoReadWrite(result);", "         break;", "       case STATE_AUTH_REQUIRED:", "         Finish(result);", "         return;", "       case STATE_CLOSE:", "         DCHECK_LE(result, OK);", "         Finish(result);", "         return;", "       default:", "         NOTREACHED() << \"bad state \" << state;", "         Finish(result);", "         return;", "     }", "     if (state == STATE_RESOLVE_PROTOCOL && result == ERR_PROTOCOL_SWITCHED)", "       continue;", "     if (state != STATE_READ_WRITE && result < ERR_IO_PENDING) {", "       net_log_.EndEventWithNetErrorCode(", "           NetLog::TYPE_SOCKET_STREAM_CONNECT, result);", "     }", "   } while (result != ERR_IO_PENDING);", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int digi_startup(struct usb_serial *serial)", "  {", " \tstruct device *dev = &serial->interface->dev;", "  \tstruct digi_serial *serial_priv;", "  \tint ret;", " \tint i;", " ", " \t ", " \tif (serial->num_port_pointers < serial->type->num_ports + 1) {", " \t\tdev_err(dev, \"OOB endpoints missing\\n\");", " \t\treturn -ENODEV;", " \t}", " ", " \tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {", " \t\tif (!serial->port[i]->read_urb) {", " \t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");", " \t\t\treturn -ENODEV;", " \t\t}", " \t\tif (!serial->port[i]->write_urb) {", " \t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");", " \t\t\treturn -ENODEV;", " \t\t}", " \t}", "  ", "  \tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);", "  \tif (!serial_priv)", " \t\treturn -ENOMEM;", " ", " \tspin_lock_init(&serial_priv->ds_serial_lock);", " \tserial_priv->ds_oob_port_num = serial->type->num_ports;", " \tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];", " ", " \tret = digi_port_init(serial_priv->ds_oob_port,", " \t\t\t\t\t\tserial_priv->ds_oob_port_num);", " \tif (ret) {", " \t\tkfree(serial_priv);", " \t\treturn ret;", " \t}", " ", " \tusb_set_serial_data(serial, serial_priv);", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ZEND_API void zend_ts_hash_graceful_destroy(TsHashTable *ht)", " {", " \tbegin_write(ht);", " \tzend_hash_graceful_destroy(TS_HASH(ht));", " \tend_write(ht);", "  ", "  #ifdef ZTS", "         tsrm_mutex_free(ht->mx_reader);", "       tsrm_mutex_free(ht->mx_reader);", "        tsrm_mutex_free(ht->mx_writer);", "  #endif", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["  static void copyTrespass(", "          short *  ,", "        const int *const *  ,", "         const int *[FLACParser::kMaxChannels]  ,", "          unsigned  ,", "          unsigned  ) {", "      TRESPASS();", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int attach_child_main(void* data)", "  {", "  \tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;", "  \tint ipc_socket = payload->ipc_socket;", " \tint procfd = payload->procfd;", "  \tlxc_attach_options_t* options = payload->options;", "  \tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;", "  #if HAVE_SYS_PERSONALITY_H", " \tlong new_personality;", " #endif", " \tint ret;", " \tint status;", " \tint expected;", " \tlong flags;", " \tint fd;", " \tuid_t new_uid;", " \tgid_t new_gid;", " ", " \t ", " \texpected = 0;", " \tstatus = -1;", " \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);", " \tif (ret <= 0) {", " \t\tERROR(\"error using IPC to receive notification from initial process (0)\");", " \t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\trexit(-1);", " \t}", " ", " \t ", " \tif (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {", " \t\tret = lxc_attach_remount_sys_proc();", " \t\tif (ret < 0) {", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " \t}", " ", " \t ", " #if HAVE_SYS_PERSONALITY_H", " \tif (options->personality < 0)", " \t\tnew_personality = init_ctx->personality;", " \telse", " \t\tnew_personality = options->personality;", " ", " \tif (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {", " \t\tret = personality(new_personality);", " \t\tif (ret < 0) {", " \t\t\tSYSERROR(\"could not ensure correct architecture\");", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " \t}", " #endif", " ", " \tif (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {", " \t\tret = lxc_attach_drop_privs(init_ctx);", " \t\tif (ret < 0) {", " \t\t\tERROR(\"could not drop privileges\");", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " \t}", " ", " \t ", " \tret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);", " \tif (ret < 0) {", " \t\tERROR(\"could not set initial environment for attached process\");", " \t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\trexit(-1);", " \t}", " ", " \t ", " \tnew_uid = 0;", " \tnew_gid = 0;", " \t ", " \tif (options->namespaces & CLONE_NEWUSER)", " \t\tlxc_attach_get_init_uidgid(&new_uid, &new_gid);", " ", " \tif (options->uid != (uid_t)-1)", " \t\tnew_uid = options->uid;", " \tif (options->gid != (gid_t)-1)", " \t\tnew_gid = options->gid;", " ", " \t ", " \tif (options->stdin_fd && isatty(options->stdin_fd)) {", " \t\tif (setsid() < 0) {", " \t\t\tSYSERROR(\"unable to setsid\");", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " ", " \t\tif (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {", " \t\t\tSYSERROR(\"unable to TIOCSTTY\");", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " \t}", " ", " \t ", " \tif ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {", " \t\tif (setgid(new_gid) || setgroups(0, NULL)) {", " \t\t\tSYSERROR(\"switching to container gid\");", " \t\t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\t\trexit(-1);", " \t\t}", " \t}", " \tif ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {", " \t\tSYSERROR(\"switching to container uid\");", " \t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\trexit(-1);", " \t}", " ", " \t ", " \tstatus = 1;", " \tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));", " \tif (ret != sizeof(status)) {", " \t\tERROR(\"error using IPC to notify initial process for initialization (1)\");", " \t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\trexit(-1);", " \t}", " ", " \t ", " \texpected = 2;", " \tstatus = -1;", " \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);", " \tif (ret <= 0) {", " \t\tERROR(\"error using IPC to receive final notification from initial process (2)\");", " \t\tshutdown(ipc_socket, SHUT_RDWR);", " \t\trexit(-1);", " \t}", " ", " \tshutdown(ipc_socket, SHUT_RDWR);", "  \tclose(ipc_socket);", "  ", "  \t ", "\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {", " \tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {", "  \t\tint on_exec;", "\t\tint proc_mounted;", "  ", "  \t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;", "\t\tproc_mounted = mount_proc_if_needed(\"/\");", "\t\tif (proc_mounted == -1) {", "\t\t\tERROR(\"Error mounting a sane /proc\");", "\t\t\trexit(-1);", "\t\t}", "\t\tret = lsm_process_label_set(init_ctx->lsm_label,", "\t\t\t\tinit_ctx->container->lxc_conf, 0, on_exec);", "\t\tif (proc_mounted)", "\t\t\tumount(\"/proc\");", "\t\tif (ret < 0) {", " \t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {", "  \t\t\trexit(-1);", "  \t\t}", "  \t}", " ", " \tif (init_ctx->container && init_ctx->container->lxc_conf &&", " \t\t\tlxc_seccomp_load(init_ctx->container->lxc_conf) != 0) {", " \t\tERROR(\"Loading seccomp policy\");", " \t\trexit(-1);", " \t}", " ", " \tlxc_proc_put_context_info(init_ctx);", " ", " \t ", " ", " \t ", " \tif (options->stdin_fd >= 0 && options->stdin_fd != 0)", " \t\tdup2(options->stdin_fd, 0);", " \tif (options->stdout_fd >= 0 && options->stdout_fd != 1)", " \t\tdup2(options->stdout_fd, 1);", " \tif (options->stderr_fd >= 0 && options->stderr_fd != 2)", " \t\tdup2(options->stderr_fd, 2);", " ", " \t ", " \tif (options->stdin_fd > 2)", " \t\tclose(options->stdin_fd);", " \tif (options->stdout_fd > 2)", " \t\tclose(options->stdout_fd);", " \tif (options->stderr_fd > 2)", " \t\tclose(options->stderr_fd);", " ", " \t ", " \tfor (fd = 0; fd <= 2; fd++) {", " \t\tflags = fcntl(fd, F_GETFL);", " \t\tif (flags < 0)", " \t\t\tcontinue;", " \t\tif (flags & FD_CLOEXEC) {", " \t\t\tif (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) {", " \t\t\t\tSYSERROR(\"Unable to clear CLOEXEC from fd\");", " \t\t\t}", "  \t\t}", "  \t}", "  ", " \t ", " \tclose(procfd);", " ", "  \t ", "  \trexit(payload->exec_function(payload->exec_payload));", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" grub_ext2_iterate_dir (grub_fshelp_node_t dir,", " \t\t       int (*hook) (const char *filename,", " \t\t\t\t    enum grub_fshelp_filetype filetype,", " \t\t\t\t    grub_fshelp_node_t node,", " \t\t\t\t    void *closure),", " \t\t       void *closure)", " {", "   unsigned int fpos = 0;", "   struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;", " ", "   if (! diro->inode_read)", "     {", "       grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);", "       if (grub_errno)", " \treturn 0;", "     }", " ", "    ", "   if (hook)", "   while (fpos < grub_le_to_cpu32 (diro->inode.size))", "     {", "       struct ext2_dirent dirent;", " ", "       grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),", " \t\t\t   (char *) &dirent);", "       if (grub_errno)", " \treturn 0;", " ", "       if (dirent.direntlen == 0)", "         return 0;", "  ", "        if (dirent.namelen != 0)", "  \t{", "#ifndef _MSC_VER", "\t  char filename[dirent.namelen + 1]; ", "#else", "  \t  char * filename = grub_malloc (dirent.namelen + 1);", "#endif", "  \t  struct grub_fshelp_node *fdiro;", "  \t  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;", "  ", " if (!filename) {", " break;", " }", "  \t  grub_ext2_read_file (diro, 0, 0, 0,", "  \t\t\t       fpos + sizeof (struct ext2_dirent),", "  \t\t\t       dirent.namelen, filename);", "\t  if (grub_errno)", " \t  if (grub_errno) {", "             free (filename);", "  \t    return 0;", " \t  }", "  ", "  \t  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));", "\t  if (! fdiro)", " \t  if (! fdiro) {", "             free (filename);", "  \t    return 0;", "           }", "  ", "  \t  fdiro->data = diro->data;", "  \t  fdiro->ino = grub_le_to_cpu32 (dirent.inode);", " ", " \t  filename[dirent.namelen] = '\\0';", " ", " \t  if (dirent.filetype != FILETYPE_UNKNOWN)", " \t    {", " \t      fdiro->inode_read = 0;", " ", " \t      if (dirent.filetype == FILETYPE_DIRECTORY)", " \t\ttype = GRUB_FSHELP_DIR;", " \t      else if (dirent.filetype == FILETYPE_SYMLINK)", " \t\ttype = GRUB_FSHELP_SYMLINK;", " \t      else if (dirent.filetype == FILETYPE_REG)", " \t\ttype = GRUB_FSHELP_REG;", " \t    }", " \t  else", " \t    {", " \t       ", "  \t      grub_ext2_read_inode (diro->data,", "                                      grub_le_to_cpu32 (dirent.inode),", "  \t\t\t\t    &fdiro->inode);", "\t      if (grub_errno)", "\t\t{", " \t      if (grub_errno) {", "                   free (filename);", "  \t\t  grub_free (fdiro);", "  \t\t  return 0;", "  \t\t}", " ", " \t      fdiro->inode_read = 1;", " ", " \t      if ((grub_le_to_cpu16 (fdiro->inode.mode)", " \t\t   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)", " \t\ttype = GRUB_FSHELP_DIR;", " \t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)", " \t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)", " \t\ttype = GRUB_FSHELP_SYMLINK;", " \t      else if ((grub_le_to_cpu16 (fdiro->inode.mode)", " \t\t\t& FILETYPE_INO_MASK) == FILETYPE_INO_REG)", "  \t\ttype = GRUB_FSHELP_REG;", "  \t    }", "  ", "\t  if (hook (filename, type, fdiro, closure))", " \t  if (hook (filename, type, fdiro, closure)) {", "             free (filename);", "  \t    return 1;", "           }", "           free (filename);", "  \t}", "  ", "        fpos += grub_le_to_cpu16 (dirent.direntlen);", "     }", " ", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int DefragMfIpv4Test(void)", " {", "     int retval = 0;", "     int ip_id = 9;", "     Packet *p = NULL;", "  ", "      DefragInit();", "  ", "    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);", "    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);", "    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);", "     Packet *p1 = BuildTestPacket(IPPROTO_ICMP, ip_id, 2, 1, 'C', 8);", "     Packet *p2 = BuildTestPacket(IPPROTO_ICMP, ip_id, 0, 1, 'A', 8);", "     Packet *p3 = BuildTestPacket(IPPROTO_ICMP, ip_id, 1, 0, 'B', 8);", "      if (p1 == NULL || p2 == NULL || p3 == NULL) {", "          goto end;", "      }", " ", "     p = Defrag(NULL, NULL, p1, NULL);", "     if (p != NULL) {", "         goto end;", "     }", " ", "     p = Defrag(NULL, NULL, p2, NULL);", "     if (p != NULL) {", "         goto end;", "     }", " ", "      ", "     p = Defrag(NULL, NULL, p3, NULL);", "     if (p == NULL) {", "         goto end;", "     }", " ", "      ", "     if (IPV4_GET_IPLEN(p) != 36) {", "         goto end;", "     }", " ", "     retval = 1;", " end:", "     if (p1 != NULL) {", "         SCFree(p1);", "     }", "     if (p2 != NULL) {", "         SCFree(p2);", "     }", "     if (p3 != NULL) {", "         SCFree(p3);", "     }", "     if (p != NULL) {", "         SCFree(p);", "     }", "     DefragDestroy();", "     return retval;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void pdo_stmt_init(TSRMLS_D)", " {", " \tzend_class_entry ce;", " ", " \tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);", " \tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);", " \tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;", " \tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;", " \tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);", " \tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);", " ", " \tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));", " \tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;", " \tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;", " \tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;", " \tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;", " \tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;", " ", " \tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);", " \tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);", "  \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS;  ", "  \tpdo_row_ce->create_object = pdo_row_new;", "  \tpdo_row_ce->serialize = pdo_row_serialize;", " \tpdo_row_ce->unserialize = zend_class_unserialize_deny;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static void *sock_poll_thread(void *arg)", " {", "  struct pollfd pfds[MAX_POLL];", "     memset(pfds, 0, sizeof(pfds));", "  int h = (intptr_t)arg;", " ", "      for(;;)", "      {", "          prepare_poll_fds(h, pfds);", "        int ret = poll(pfds, ts[h].poll_count, -1);", "         int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));", "          if(ret == -1)", "          {", "              APPL_TRACE_ERROR(\"poll ret -1, exit the thread, errno:%d, err:%s\", errno, strerror(errno));", "  break;", "  }", "  if(ret != 0)", "  {", "  int need_process_data_fd = TRUE;", "  if(pfds[0].revents)  ", "  {", "                 asrt(pfds[0].fd == ts[h].cmd_fdr);", "  if(!process_cmd_sock(h))", "  {", "                     APPL_TRACE_DEBUG(\"h:%d, process_cmd_sock return false, exit...\", h);", "  break;", "  }", "  if(ret == 1)", "                     need_process_data_fd = FALSE;", "  else ret--;  ", "  }", "  if(need_process_data_fd)", "                 process_data_sock(h, pfds, ret);", "  }", "  else {APPL_TRACE_DEBUG(\"no data, select ret: %d\", ret)};", "  }", "     ts[h].thread_id = -1;", "     APPL_TRACE_DEBUG(\"socket poll thread exiting, h:%d\", h);", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)", " {", " \tint ret;", " \tint size;", " ", " \tif (ud->side == USBIP_STUB) {", " \t\t ", " \t\tif (usb_pipein(urb->pipe))", " \t\t\treturn 0;", " ", " \t\tsize = urb->transfer_buffer_length;", " \t} else {", " \t\t ", " \t\tif (usb_pipeout(urb->pipe))", " \t\t\treturn 0;", " ", " \t\tsize = urb->actual_length;", " \t}", " ", " \t ", "  \tif (!(size > 0))", "  \t\treturn 0;", "  ", " \tif (size > urb->transfer_buffer_length) {", " \t\t ", " \t\tif (ud->side == USBIP_STUB) {", " \t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);", " \t\t\treturn 0;", " \t\t} else {", " \t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);", " \t\t\treturn -EPIPE;", " \t\t}", " \t}", " ", "  \tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);", "  \tif (ret != size) {", "  \t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);", " \t\tif (ud->side == USBIP_STUB) {", " \t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);", " \t\t} else {", " \t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);", " \t\t\treturn -EPIPE;", " \t\t}", " \t}", " ", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void Sp_replace_regexp(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *source, *s, *r;", " \tjs_Buffer *sb = NULL;", " \tint n, x;", " \tResub m;", " ", "  \tsource = checkstring(J, 0);", "  \tre = js_toregexp(J, 1);", "  ", "\tif (js_regexec(re->prog, source, &m, 0)) {", " \tif (js_doregexec(J, re->prog, source, &m, 0)) {", "  \t\tjs_copy(J, 0);", "  \t\treturn;", "  \t}", " ", " \tre->last = 0;", " ", " loop:", " \ts = m.sub[0].sp;", " \tn = m.sub[0].ep - m.sub[0].sp;", " ", " \tif (js_iscallable(J, 2)) {", " \t\tjs_copy(J, 2);", " \t\tjs_pushundefined(J);", " \t\tfor (x = 0; m.sub[x].sp; ++x)  ", " \t\t\tjs_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp);", " \t\tjs_pushnumber(J, s - source);  ", " \t\tjs_copy(J, 0);  ", " \t\tjs_call(J, 2 + x);", " \t\tr = js_tostring(J, -1);", " \t\tjs_putm(J, &sb, source, s);", " \t\tjs_puts(J, &sb, r);", " \t\tjs_pop(J, 1);", " \t} else {", " \t\tr = js_tostring(J, 2);", " \t\tjs_putm(J, &sb, source, s);", " \t\twhile (*r) {", " \t\t\tif (*r == '$') {", " \t\t\t\tswitch (*(++r)) {", " \t\t\t\tcase 0: --r;  ", " \t\t\t\t ", " \t\t\t\tcase '$': js_putc(J, &sb, '$'); break;", " \t\t\t\tcase '`': js_putm(J, &sb, source, s); break;", " \t\t\t\tcase '\\'': js_puts(J, &sb, s + n); break;", " \t\t\t\tcase '&':", " \t\t\t\t\tjs_putm(J, &sb, s, s + n);", " \t\t\t\t\tbreak;", " \t\t\t\tcase '0': case '1': case '2': case '3': case '4':", " \t\t\t\tcase '5': case '6': case '7': case '8': case '9':", " \t\t\t\t\tx = *r - '0';", " \t\t\t\t\tif (r[1] >= '0' && r[1] <= '9')", " \t\t\t\t\t\tx = x * 10 + *(++r) - '0';", " \t\t\t\t\tif (x > 0 && x < m.nsub) {", " \t\t\t\t\t\tjs_putm(J, &sb, m.sub[x].sp, m.sub[x].ep);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tjs_putc(J, &sb, '$');", " \t\t\t\t\t\tif (x > 10) {", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x / 10);", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x % 10);", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tjs_putc(J, &sb, '0' + x);", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t\tdefault:", " \t\t\t\t\tjs_putc(J, &sb, '$');", " \t\t\t\t\tjs_putc(J, &sb, *r);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\t++r;", " \t\t\t} else {", " \t\t\t\tjs_putc(J, &sb, *r++);", " \t\t\t}", " \t\t}", " \t}", " ", " \tif (re->flags & JS_REGEXP_G) {", " \t\tsource = m.sub[0].ep;", " \t\tif (n == 0) {", " \t\t\tif (*source)", " \t\t\t\tjs_putc(J, &sb, *source++);", "  \t\t\telse", "  \t\t\t\tgoto end;", "  \t\t}", "\t\tif (!js_regexec(re->prog, source, &m, REG_NOTBOL))", " \t\tif (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))", "  \t\t\tgoto loop;", "  \t}", "  ", " end:", " \tjs_puts(J, &sb, s + n);", " \tjs_putc(J, &sb, 0);", " ", " \tif (js_try(J)) {", " \t\tjs_free(J, sb);", " \t\tjs_throw(J);", " \t}", " \tjs_pushstring(J, sb ? sb->s : \"\");", " \tjs_endtry(J);", " \tjs_free(J, sb);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int git_delta_apply(", " \tvoid **out,", " \tsize_t *out_len,", " \tconst unsigned char *base,", " \tsize_t base_len,", " \tconst unsigned char *delta,", " \tsize_t delta_len)", " {", " \tconst unsigned char *delta_end = delta + delta_len;", " \tsize_t base_sz, res_sz, alloc_sz;", " \tunsigned char *res_dp;", " ", " \t*out = NULL;", " \t*out_len = 0;", " ", " \t ", " \tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {", " \t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");", " \t\treturn -1;", " \t}", " ", " \tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {", " \t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");", " \t\treturn -1;", " \t}", " ", " \tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);", " \tres_dp = git__malloc(alloc_sz);", " \tGITERR_CHECK_ALLOC(res_dp);", " ", " \tres_dp[res_sz] = '\\0';", " \t*out = res_dp;", " \t*out_len = res_sz;", " ", " \twhile (delta < delta_end) {", " \t\tunsigned char cmd = *delta++;", " \t\tif (cmd & 0x80) {", "  \t\t\t ", "  \t\t\tsize_t off = 0, len = 0;", "  ", "\t\t\tif (cmd & 0x01) off = *delta++;", "\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;", "\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;", "\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);", "\t\t\tif (cmd & 0x10) len = *delta++;", "\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;", "\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;", " #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }", " \t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);", " \t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);", " \t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);", " \t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);", " ", " \t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);", " \t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);", " \t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);", "  \t\t\tif (!len)       len = 0x10000;", " #undef ADD_DELTA", "  ", "  \t\t\tif (base_len < off + len || res_sz < len)", "  \t\t\t\tgoto fail;", " \t\t\tmemcpy(res_dp, base + off, len);", " \t\t\tres_dp += len;", " \t\t\tres_sz -= len;", " ", " \t\t} else if (cmd) {", " \t\t\t ", " \t\t\tif (delta_end - delta < cmd || res_sz < cmd)", " \t\t\t\tgoto fail;", " \t\t\tmemcpy(res_dp, delta, cmd);", " \t\t\tdelta += cmd;", " \t\t\tres_dp += cmd;", " \t\t\tres_sz -= cmd;", " ", " \t\t} else {", " \t\t\t ", " \t\t\tgoto fail;", " \t\t}", " \t}", " ", " \tif (delta != delta_end || res_sz)", " \t\tgoto fail;", " \treturn 0;", " ", " fail:", " \tgit__free(*out);", " ", " \t*out = NULL;", " \t*out_len = 0;", " ", " \tgiterr_set(GITERR_INVALID, \"failed to apply delta\");", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,", "  \t\t\t\t struct param_mem *mem)", "  {", " \tsize_t req_size = 0;", "  \tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);", "  ", "  \tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);", " \tif (!mem->mobj)", " \t\treturn TEE_ERROR_BAD_PARAMETERS;", " ", "  \tmem->offs = READ_ONCE(rmem->offs);", "  \tmem->size = READ_ONCE(rmem->size);", "  ", " \t ", " \tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||", " \t    mem->mobj->size < req_size)", " \t\treturn TEE_ERROR_SECURITY;", " ", "  \treturn TEE_SUCCESS;", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" main(int argc, char **argv)", " {", "    int i, valgrind_mode = 0;", "    int valgrind_tool = 0;", "    int valgrind_gdbserver = 0;", "    char buf[16384], **args, *home;", "    char valgrind_path[PATH_MAX] = \"\";", "    const char *valgrind_log = NULL;", "    Eina_Bool really_know = EINA_FALSE;", "    struct sigaction action;", "    pid_t child = -1;", " #ifdef E_CSERVE", "    pid_t cs_child = -1;", "    Eina_Bool cs_use = EINA_FALSE;", " #endif", " #if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \\", "    !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))", "    Eina_Bool restart = EINA_TRUE;", " #endif", " ", "    unsetenv(\"NOTIFY_SOCKET\");", " ", "     ", "    action.sa_sigaction = _sigusr1;", "    action.sa_flags = SA_RESETHAND;", "    sigemptyset(&action.sa_mask);", "    sigaction(SIGUSR1, &action, NULL);", " ", "    eina_init();", " ", "     ", "    if ((!getenv(\"DBUS_SESSION_BUS_ADDRESS\")) &&", "        (!getenv(\"DBUS_LAUNCHD_SESSION_BUS_SOCKET\")))", "      {", "         char **dbus_argv;", " ", "         dbus_argv = alloca((argc + 3) * sizeof (char *));", "         dbus_argv[0] = \"dbus-launch\";", "         dbus_argv[1] = \"--exit-with-session\";", "         copy_args(dbus_argv + 2, argv, argc);", "         dbus_argv[2 + argc] = NULL;", "         execvp(\"dbus-launch\", dbus_argv);", "      }", " ", "    prefix_determine(argv[0]);", " ", "    env_set(\"E_START\", argv[0]);", " ", "    for (i = 1; i < argc; i++)", "      {", "         if (!strcmp(argv[i], \"-valgrind-gdb\"))", "           valgrind_gdbserver = 1;", "         else if (!strncmp(argv[i], \"-valgrind\", sizeof(\"-valgrind\") - 1))", "           {", "              const char *val = argv[i] + sizeof(\"-valgrind\") - 1;", " ", "              if (*val == '\\0') valgrind_mode = 1;", "              else if (*val == '-')", "                {", "                   val++;", "                   if (!strncmp(val, \"log-file=\", sizeof(\"log-file=\") - 1))", "                     {", "                        valgrind_log = val + sizeof(\"log-file=\") - 1;", "                        if (*valgrind_log == '\\0') valgrind_log = NULL;", "                     }", "                }", "              else if (*val == '=')", "                {", "                   val++;", "                   if (!strcmp(val, \"all\")) valgrind_mode = VALGRIND_MODE_ALL;", "                   else valgrind_mode = atoi(val);", "                }", "              else", "                printf(\"Unknown valgrind option: %s\\n\", argv[i]);", "           }", "         else if (!strcmp(argv[i], \"-display\"))", "           {", "              i++;", "              env_set(\"DISPLAY\", argv[i]);", "           }", "         else if (!strcmp(argv[i], \"-massif\"))", "           valgrind_tool = 1;", "         else if (!strcmp(argv[i], \"-callgrind\"))", "           valgrind_tool = 2;", "         else if ((!strcmp(argv[i], \"-h\")) ||", "                  (!strcmp(argv[i], \"-help\")) ||", "                  (!strcmp(argv[i], \"--help\")))", "           {", "              printf", "              (", "                \"Options:\\n\"", "                \"\\t-valgrind[=MODE]\\n\"", "                \"\\t\\tRun enlightenment from inside valgrind, mode is OR of:\\n\"", "                \"\\t\\t   1 = plain valgrind to catch crashes (default)\\n\"", "                \"\\t\\t   2 = trace children (thumbnailer, efm slaves, ...)\\n\"", "                \"\\t\\t   4 = check leak\\n\"", "                \"\\t\\t   8 = show reachable after processes finish.\\n\"", "                \"\\t\\t all = all of above\\n\"", "                \"\\t-massif\\n\"", "                \"\\t\\tRun enlightenment from inside massif valgrind tool.\\n\"", "                \"\\t-callgrind\\n\"", "                \"\\t\\tRun enlightenment from inside callgrind valgrind tool.\\n\"", "                \"\\t-valgrind-log-file=<FILENAME>\\n\"", "                \"\\t\\tSave valgrind log to file, see valgrind's --log-file for details.\\n\"", "                \"\\n\"", "                \"Please run:\\n\"", "                \"\\tenlightenment %s\\n\"", "                \"for more options.\\n\",", "                argv[i]);", "              exit(0);", "           }", "         else if (!strcmp(argv[i], \"-i-really-know-what-i-am-doing-and-accept-full-responsibility-for-it\"))", "           really_know = EINA_TRUE;", "      }", " ", "    if (really_know)", "      _env_path_append(\"PATH\", eina_prefix_bin_get(pfx));", "    else", "      _env_path_prepend(\"PATH\", eina_prefix_bin_get(pfx));", " ", "    if (valgrind_mode || valgrind_tool)", "      {", "         if (!find_valgrind(valgrind_path, sizeof(valgrind_path)))", "           {", "              printf(\"E - valgrind required but no binary found! Ignoring request.\\n\");", "              valgrind_mode = 0;", "           }", "      }", " ", "    printf(\"E - PID=%i, valgrind=%d\", getpid(), valgrind_mode);", "    if (valgrind_mode)", "      {", "         printf(\" valgrind-command='%s'\", valgrind_path);", "         if (valgrind_log) printf(\" valgrind-log-file='%s'\", valgrind_log);", "      }", "    putchar('\\n');", " ", "     ", "    home = getenv(\"HOME\");", "    if (home)", "      {", "         FILE *f;", " ", "          ", "         snprintf(buf, sizeof(buf), \"%s/.e-mtrack\", home);", "         f = fopen(buf, \"r\");", "         if (f)", "           {", "              if (fgets(buf, sizeof(buf), f))", "                {", "                   int len = strlen(buf);", "                   if ((len > 1) && (buf[len - 1] == '\\n'))", "                     {", "                        buf[len - 1] = 0;", "                        len--;", "                     }", "                   env_set(\"LD_PRELOAD\", buf);", "                   env_set(\"MTRACK\", \"track\");", "                   env_set(\"E_START_MTRACK\", \"track\");", "                   snprintf(buf, sizeof(buf), \"%s/.e-mtrack.log\", home);", "                   env_set(\"MTRACK_TRACE_FILE\", buf);", "                }", "              fclose(f);", "           }", "      }", " ", "     ", "    snprintf(buf, sizeof(buf), \"%s/enlightenment\", eina_prefix_bin_get(pfx));", " ", "    args = alloca((argc + 2 + VALGRIND_MAX_ARGS) * sizeof(char *));", "    i = valgrind_append(args, valgrind_gdbserver, valgrind_mode, valgrind_tool, valgrind_path, valgrind_log);", "    args[i++] = buf;", "    copy_args(args + i, argv + 1, argc - 1);", "    args[i + argc - 1] = NULL;", " ", "    if (valgrind_tool || valgrind_mode)", "      really_know = EINA_TRUE;", " ", " #if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || \\", "    defined(__FreeBSD_kernel__) || (defined (__MACH__) && defined (__APPLE__))", "    execv(args[0], args);", " #endif", " ", "     ", " ", " #if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \\", "    !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))", " ", " #ifdef E_CSERVE", "    if (getenv(\"E_CSERVE\"))", "      {", "         cs_use = EINA_TRUE;", "         cs_child = _cserve2_start();", "      }", " #endif", " ", "     ", "    while (restart)", "      {", "         stop_ptrace = EINA_FALSE;", " ", "         child = fork();", " ", "         if (child < 0)  ", "           return -1;", "         else if (child == 0)", "           {", " #ifdef HAVE_SYS_PTRACE_H", "              if (!really_know)", "                 ", "                ptrace(PT_TRACE_ME, 0, NULL, NULL);", " #endif", "              execv(args[0], args);", "              return 0;  ", "           }", "         else", "           {", "              env_set(\"E_RESTART\", \"1\");", "               ", "              pid_t result;", "              int status;", "              Eina_Bool done = EINA_FALSE;", " ", " #ifdef HAVE_SYS_PTRACE_H", "              if (!really_know)", "                ptrace(PT_ATTACH, child, NULL, NULL);", "              result = waitpid(child, &status, 0);", "              if ((!really_know) && (!stop_ptrace))", "                {", "                   if (WIFSTOPPED(status))", "                     ptrace(PT_CONTINUE, child, NULL, NULL);", "                }", " #endif", "              while (!done)", "                {", "                   Eina_Bool remember_sigill = EINA_FALSE;", "                   Eina_Bool remember_sigusr1 = EINA_FALSE;", " ", "                   result = waitpid(child, &status, WNOHANG);", "                   if (!result)", "                     {", "                         ", "                        result = waitpid(-1, &status, 0);", "                     }", " ", "                   if (result == child)", "                     {", "                        if ((WIFSTOPPED(status)) && (!stop_ptrace))", "                          {", "                             char buffer[4096];", "                             char *backtrace_str = NULL;", "                             siginfo_t sig;", "                             int r = 0;", "                             int back;", " ", " #ifdef HAVE_SYS_PTRACE_H", "                             if (!really_know)", "                               r = ptrace(PT_GETSIGINFO, child, NULL, &sig);", " #endif", "                             back = r == 0 &&", "                               sig.si_signo != SIGTRAP ? sig.si_signo : 0;", " ", "                             if (sig.si_signo == SIGUSR1)", "                               {", "                                  if (remember_sigill)", "                                    remember_sigusr1 = EINA_TRUE;", "                               }", "                             else if (sig.si_signo == SIGILL)", "                               {", "                                  remember_sigill = EINA_TRUE;", "                               }", "                             else", "                               {", "                                  remember_sigill = EINA_FALSE;", "                               }", " ", "                             if (r != 0 ||", "                                 (sig.si_signo != SIGSEGV &&", "                                  sig.si_signo != SIGFPE &&", "                                  sig.si_signo != SIGABRT))", "                               {", " #ifdef HAVE_SYS_PTRACE_H", "                                  if (!really_know)", "                                    ptrace(PT_CONTINUE, child, NULL, back);", " #endif", "                                  continue;", "                               }", " #ifdef HAVE_SYS_PTRACE_H", "                             if (!really_know)", "                                ", "                               ptrace(PT_DETACH, child, NULL, back);", " #endif", "                              ", "                             r = 0;", "                             if (home)", "                                {", "                                    ", "                                   snprintf(buffer, 4096,", "                                          \"%s/enlightenment/utils/enlightenment_sys gdb %i %s/.e-crashdump.txt\",", "                                          eina_prefix_lib_get(pfx),", "                                           \"gdb %i %s/.e-crashdump.txt\",", "                                            child,", "                                            home);", "                                   r = system(buffer);", "                                  r = system(buffer);", " ", "                                  fprintf(stderr, \"called gdb with '%s' = %i\\n\",", "                                          buffer, WEXITSTATUS(r));", " ", "                                  snprintf(buffer, 4096,", "                                           \"%s/.e-crashdump.txt\",", "                                           home);", " ", "                                  backtrace_str = strdup(buffer);", "                                  r = WEXITSTATUS(r);", "                               }", " ", "                              ", "                             snprintf(buffer, 4096,", "                                      backtrace_str ?", "                                      \"%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i\" :", "                                      \"%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i\",", "                                      eina_prefix_lib_get(pfx),", "                                      sig.si_signo == SIGSEGV && remember_sigusr1 ? SIGILL : sig.si_signo,", "                                      child,", "                                      backtrace_str,", "                                      r);", "                             r = system(buffer);", " ", "                              ", "                             kill(child, SIGKILL);", " ", "                             if (WEXITSTATUS(r) != 1)", "                               {", "                                  restart = EINA_FALSE;", "                               }", "                          }", "                        else if (!WIFEXITED(status))", "                          {", "                             done = EINA_TRUE;", "                          }", "                        else if (stop_ptrace)", "                          {", "                             done = EINA_TRUE;", "                          }", "                     }", "                   else if (result == -1)", "                     {", "                        if (errno != EINTR)", "                          {", "                             done = EINA_TRUE;", "                             restart = EINA_FALSE;", "                          }", "                        else", "                          {", "                             if (stop_ptrace)", "                               {", "                                  kill(child, SIGSTOP);", "                                  usleep(200000);", " #ifdef HAVE_SYS_PTRACE_H", "                                  if (!really_know)", "                                    ptrace(PT_DETACH, child, NULL, NULL);", " #endif", "                               }", "                          }", "                     }", " #ifdef E_CSERVE", "                   else if (cs_use && (result == cs_child))", "                     {", "                        if (WIFSIGNALED(status))", "                          {", "                             printf(\"E - cserve2 terminated with signal %d\\n\",", "                                    WTERMSIG(status));", "                             cs_child = _cserve2_start();", "                          }", "                        else if (WIFEXITED(status))", "                          {", "                             printf(\"E - cserve2 exited with code %d\\n\",", "                                    WEXITSTATUS(status));", "                             cs_child = -1;", "                          }", "                     }", " #endif", "                }", "           }", "      }", " #endif", " ", " #ifdef E_CSERVE", "    if (cs_child > 0)", "      {", "         pid_t result;", "         int status;", " ", "         alarm(2);", "         kill(cs_child, SIGINT);", "         result = waitpid(cs_child, &status, 0);", "         if (result != cs_child)", "           {", "              printf(\"E - cserve2 did not shutdown in 2 seconds, killing!\\n\");", "              kill(cs_child, SIGKILL);", "           }", "      }", " #endif", " ", "    return -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" MagickExport MagickBooleanType DrawPrimitive(Image *image,", "   const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,", "   ExceptionInfo *exception)", " {", "   CacheView", "     *image_view;", " ", "   MagickStatusType", "     status;", " ", "   register ssize_t", "     i,", "     x;", " ", "   ssize_t", "     y;", " ", "   if (image->debug != MagickFalse)", "     {", "       (void) LogMagickEvent(DrawEvent,GetMagickModule(),", "         \"  begin draw-primitive\");", "       (void) LogMagickEvent(DrawEvent,GetMagickModule(),", "         \"    affine: %g %g %g %g %g %g\",draw_info->affine.sx,", "         draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy,", "         draw_info->affine.tx,draw_info->affine.ty);", "     }", "   if ((IsGrayColorspace(image->colorspace) != MagickFalse) &&", "       ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) ||", "        (IsPixelInfoGray(&draw_info->stroke) == MagickFalse)))", "     (void) SetImageColorspace(image,sRGBColorspace,exception);", "   status=MagickTrue;", "   x=(ssize_t) ceil(primitive_info->point.x-0.5);", "   y=(ssize_t) ceil(primitive_info->point.y-0.5);", "   image_view=AcquireAuthenticCacheView(image,exception);", "   switch (primitive_info->primitive)", "   {", "     case AlphaPrimitive:", "     {", "       if (image->alpha_trait == UndefinedPixelTrait)", "         (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);", "       switch (primitive_info->method)", "       {", "         case PointMethod:", "         default:", "         {", "           PixelInfo", "             pixel;", " ", "           register Quantum", "             *q;", " ", "           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           GetFillColor(draw_info,x,y,&pixel,exception);", "           SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);", "           (void) SyncCacheViewAuthenticPixels(image_view,exception);", "           break;", "         }", "         case ReplaceMethod:", "         {", "           MagickBooleanType", "             sync;", " ", "           PixelInfo", "             pixel,", "             target;", " ", "           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,", "             exception);", "           GetPixelInfo(image,&pixel);", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             register Quantum", "               *magick_restrict q;", " ", "             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,", "               exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               GetPixelInfoPixel(image,q,&pixel);", "               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)", "                 {", "                   q+=GetPixelChannels(image);", "                   continue;", "                 }", "               GetFillColor(draw_info,x,y,&pixel,exception);", "               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);", "               q+=GetPixelChannels(image);", "             }", "             sync=SyncCacheViewAuthenticPixels(image_view,exception);", "             if (sync == MagickFalse)", "               break;", "           }", "           break;", "         }", "         case FloodfillMethod:", "         case FillToBorderMethod:", "         {", "           ChannelType", "             channel_mask;", " ", "           PixelInfo", "             target;", " ", "           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,", "             &target,exception);", "           if (primitive_info->method == FillToBorderMethod)", "             {", "               target.red=(double) draw_info->border_color.red;", "               target.green=(double) draw_info->border_color.green;", "               target.blue=(double) draw_info->border_color.blue;", "             }", "           channel_mask=SetImageChannelMask(image,AlphaChannel);", "           status&=FloodfillPaintImage(image,draw_info,&target,x,y,", "             primitive_info->method == FloodfillMethod ? MagickFalse :", "             MagickTrue,exception);", "           (void) SetImageChannelMask(image,channel_mask);", "           break;", "         }", "         case ResetMethod:", "         {", "           MagickBooleanType", "             sync;", " ", "           PixelInfo", "             pixel;", " ", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             register Quantum", "               *magick_restrict q;", " ", "             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,", "               exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               GetFillColor(draw_info,x,y,&pixel,exception);", "               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);", "               q+=GetPixelChannels(image);", "             }", "             sync=SyncCacheViewAuthenticPixels(image_view,exception);", "             if (sync == MagickFalse)", "               break;", "           }", "           break;", "         }", "       }", "       break;", "     }", "     case ColorPrimitive:", "     {", "       switch (primitive_info->method)", "       {", "         case PointMethod:", "         default:", "         {", "           PixelInfo", "             pixel;", " ", "           register Quantum", "             *q;", " ", "           q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           GetPixelInfo(image,&pixel);", "           GetFillColor(draw_info,x,y,&pixel,exception);", "           SetPixelViaPixelInfo(image,&pixel,q);", "           (void) SyncCacheViewAuthenticPixels(image_view,exception);", "           break;", "         }", "         case ReplaceMethod:", "         {", "           MagickBooleanType", "             sync;", " ", "           PixelInfo", "             pixel,", "             target;", " ", "           (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target,", "             exception);", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             register Quantum", "               *magick_restrict q;", " ", "             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,", "               exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               GetPixelInfoPixel(image,q,&pixel);", "               if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)", "                 {", "                   q+=GetPixelChannels(image);", "                   continue;", "                 }", "               GetFillColor(draw_info,x,y,&pixel,exception);", "               SetPixelViaPixelInfo(image,&pixel,q);", "               q+=GetPixelChannels(image);", "             }", "             sync=SyncCacheViewAuthenticPixels(image_view,exception);", "             if (sync == MagickFalse)", "               break;", "           }", "           break;", "         }", "         case FloodfillMethod:", "         case FillToBorderMethod:", "         {", "           PixelInfo", "             target;", " ", "           (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y,", "             &target,exception);", "           if (primitive_info->method == FillToBorderMethod)", "             {", "               target.red=(double) draw_info->border_color.red;", "               target.green=(double) draw_info->border_color.green;", "               target.blue=(double) draw_info->border_color.blue;", "             }", "           status&=FloodfillPaintImage(image,draw_info,&target,x,y,", "             primitive_info->method == FloodfillMethod ? MagickFalse :", "             MagickTrue,exception);", "           break;", "         }", "         case ResetMethod:", "         {", "           MagickBooleanType", "             sync;", " ", "           PixelInfo", "             pixel;", " ", "           GetPixelInfo(image,&pixel);", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             register Quantum", "               *magick_restrict q;", " ", "             q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,", "               exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               GetFillColor(draw_info,x,y,&pixel,exception);", "               SetPixelViaPixelInfo(image,&pixel,q);", "               q+=GetPixelChannels(image);", "             }", "             sync=SyncCacheViewAuthenticPixels(image_view,exception);", "             if (sync == MagickFalse)", "               break;", "           }", "           break;", "         }", "       }", "       break;", "     }", "     case ImagePrimitive:", "     {", "       AffineMatrix", "         affine;", " ", "       char", "         composite_geometry[MagickPathExtent];", " ", "       Image", "         *composite_image;", " ", "       ImageInfo", "         *clone_info;", " ", "       RectangleInfo", "         geometry;", " ", "       ssize_t", "         x1,", "         y1;", " ", "       if (primitive_info->text == (char *) NULL)", "         break;", "       clone_info=AcquireImageInfo();", "       if (LocaleNCompare(primitive_info->text,\"data:\",5) == 0)", "         composite_image=ReadInlineImage(clone_info,primitive_info->text,", "           exception);", "       else", "         {", "           (void) CopyMagickString(clone_info->filename,primitive_info->text,", "             MagickPathExtent);", "           composite_image=ReadImage(clone_info,exception);", "         }", "       clone_info=DestroyImageInfo(clone_info);", "       if (composite_image == (Image *) NULL)", "         break;", "       (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor)", "         NULL,(void *) NULL);", "       x1=(ssize_t) ceil(primitive_info[1].point.x-0.5);", "       y1=(ssize_t) ceil(primitive_info[1].point.y-0.5);", "       if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) ||", "           ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows)))", "         {", "            ", "           (void) FormatLocaleString(composite_geometry,MagickPathExtent,", "             \"%gx%g!\",primitive_info[1].point.x,primitive_info[1].point.y);", "           composite_image->filter=image->filter;", "           (void) TransformImage(&composite_image,(char *) NULL,", "             composite_geometry,exception);", "         }", "       if (composite_image->alpha_trait == UndefinedPixelTrait)", "         (void) SetImageAlphaChannel(composite_image,OpaqueAlphaChannel,", "           exception);", "       if (draw_info->alpha != OpaqueAlpha)", "         (void) SetImageAlpha(composite_image,draw_info->alpha,exception);", "       SetGeometry(image,&geometry);", "       image->gravity=draw_info->gravity;", "       geometry.x=x;", "       geometry.y=y;", "       (void) FormatLocaleString(composite_geometry,MagickPathExtent,", "         \"%.20gx%.20g%+.20g%+.20g\",(double) composite_image->columns,(double)", "         composite_image->rows,(double) geometry.x,(double) geometry.y);", "       (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception);", "       affine=draw_info->affine;", "       affine.tx=(double) geometry.x;", "       affine.ty=(double) geometry.y;", "       composite_image->interpolate=image->interpolate;", "       if (draw_info->compose == OverCompositeOp)", "         (void) DrawAffineImage(image,composite_image,&affine,exception);", "       else", "         (void) CompositeImage(image,composite_image,draw_info->compose,", "           MagickTrue,geometry.x,geometry.y,exception);", "       composite_image=DestroyImage(composite_image);", "       break;", "     }", "     case PointPrimitive:", "     {", "       PixelInfo", "         fill_color;", " ", "       register Quantum", "         *q;", " ", "       if ((y < 0) || (y >= (ssize_t) image->rows))", "         break;", "       if ((x < 0) || (x >= (ssize_t) image->columns))", "         break;", "       q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception);", "       if (q == (Quantum *) NULL)", "         break;", "       GetFillColor(draw_info,x,y,&fill_color,exception);", "       CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q,", "         (double) GetPixelAlpha(image,q),q);", "       (void) SyncCacheViewAuthenticPixels(image_view,exception);", "       break;", "     }", "     case TextPrimitive:", "     {", "       char", "         geometry[MagickPathExtent];", " ", "       DrawInfo", "         *clone_info;", " ", "       if (primitive_info->text == (char *) NULL)", "         break;", "       clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);", "       (void) CloneString(&clone_info->text,primitive_info->text);", "       (void) FormatLocaleString(geometry,MagickPathExtent,\"%+f%+f\",", "         primitive_info->point.x,primitive_info->point.y);", "       (void) CloneString(&clone_info->geometry,geometry);", "       status&=AnnotateImage(image,clone_info,exception);", "       clone_info=DestroyDrawInfo(clone_info);", "       break;", "     }", "     default:", "     {", "       double", "         mid,", "         scale;", " ", "       DrawInfo", "         *clone_info;", " ", "       if (IsEventLogging() != MagickFalse)", "         LogPrimitiveInfo(primitive_info);", "       scale=ExpandAffine(&draw_info->affine);", "       if ((draw_info->dash_pattern != (double *) NULL) &&", "           (draw_info->dash_pattern[0] != 0.0) &&", "           ((scale*draw_info->stroke_width) >= MagickEpsilon) &&", "           (draw_info->stroke.alpha != (Quantum) TransparentAlpha))", "         {", "            ", "            clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);", "            clone_info->stroke_width=0.0;", "          clone_info->stroke.alpha=(Quantum) TransparentAlpha;", "           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;", "            status&=DrawPolygonPrimitive(image,clone_info,primitive_info,", "              exception);", "            clone_info=DestroyDrawInfo(clone_info);", "           (void) DrawDashPolygon(draw_info,primitive_info,image,exception);", "           break;", "         }", "       mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0;", "       if ((mid > 1.0) &&", "           ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) ||", "            (draw_info->stroke_pattern != (Image *) NULL)))", "         {", "           MagickBooleanType", "             closed_path;", " ", "            ", "           for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;", "           closed_path=", "             (primitive_info[i-1].point.x == primitive_info[0].point.x) &&", "             (primitive_info[i-1].point.y == primitive_info[0].point.y) ?", "             MagickTrue : MagickFalse;", "           i=(ssize_t) primitive_info[0].coordinates;", "           if ((((draw_info->linecap == RoundCap) ||", "                 (closed_path != MagickFalse)) &&", "                (draw_info->linejoin == RoundJoin)) ||", "                (primitive_info[i].primitive != UndefinedPrimitive))", "             {", "               (void) DrawPolygonPrimitive(image,draw_info,primitive_info,", "                 exception);", "               break;", "              }", "            clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);", "            clone_info->stroke_width=0.0;", "          clone_info->stroke.alpha=(Quantum) TransparentAlpha;", "           clone_info->stroke.alpha=(MagickRealType) TransparentAlpha;", "            status&=DrawPolygonPrimitive(image,clone_info,primitive_info,", "              exception);", "            clone_info=DestroyDrawInfo(clone_info);", "           status&=DrawStrokePolygon(image,draw_info,primitive_info,exception);", "           break;", "         }", "       status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception);", "       break;", "     }", "   }", "   image_view=DestroyCacheView(image_view);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"  end draw-primitive\");", "   return(status != 0 ? MagickTrue : MagickFalse);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", " #define SkipLinesOp  0x01", " #define SetColorOp  0x02", " #define SkipPixelsOp  0x03", " #define ByteDataOp  0x05", " #define RunDataOp  0x06", " #define EOFOp  0x07", " ", "   char", "     magick[12];", " ", "   Image", "     *image;", " ", "   IndexPacket", "     index;", " ", "   int", "     opcode,", "     operand,", "     status;", " ", "   MagickStatusType", "     flags;", " ", "   MagickSizeType", "     number_pixels;", " ", "   MemoryInfo", "     *pixel_info;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   register ssize_t", "     i;", " ", "   register unsigned char", "     *p;", " ", "   size_t", "     bits_per_pixel,", "     map_length,", "     number_colormaps,", "     number_planes,", "     number_planes_filled,", "     one,", "     offset,", "     pixel_info_length;", " ", "   ssize_t", "     count,", "     y;", " ", "   unsigned char", "     background_color[256],", "     *colormap,", "     pixel,", "     plane,", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     return(DestroyImageList(image));", "    ", "   count=ReadBlob(image,2,(unsigned char *) magick);", "   if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   do", "   {", "      ", "     image->page.x=ReadBlobLSBShort(image);", "     image->page.y=ReadBlobLSBShort(image);", "     image->columns=ReadBlobLSBShort(image);", "     image->rows=ReadBlobLSBShort(image);", "     flags=(MagickStatusType) ReadBlobByte(image);", "     image->matte=flags & 0x04 ? MagickTrue : MagickFalse;", "     number_planes=(size_t) ReadBlobByte(image);", "     bits_per_pixel=(size_t) ReadBlobByte(image);", "     number_colormaps=(size_t) ReadBlobByte(image);", "     map_length=(unsigned char) ReadBlobByte(image);", "     if (map_length >= 32)", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     one=1;", "     map_length=one << map_length;", "     if ((number_planes == 0) || (number_planes == 2) ||", "         ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||", "         (image->columns == 0))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if (flags & 0x02)", "       {", "          ", "         for (i=0; i < (ssize_t) number_planes; i++)", "           background_color[i]=0;", "         (void) ReadBlobByte(image);", "       }", "     else", "       {", "          ", "         p=background_color;", "         for (i=0; i < (ssize_t) number_planes; i++)", "           *p++=(unsigned char) ReadBlobByte(image);", "       }", "     if ((number_planes & 0x01) == 0)", "       (void) ReadBlobByte(image);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "     colormap=(unsigned char *) NULL;", "     if (number_colormaps != 0)", "       {", "          ", "         colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,", "           3*map_length*sizeof(*colormap));", "         if (colormap == (unsigned char *) NULL)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         p=colormap;", "         for (i=0; i < (ssize_t) number_colormaps; i++)", "           for (x=0; x < (ssize_t) map_length; x++)", "             *p++=(unsigned char) ScaleShortToQuantum(ReadBlobLSBShort(image));", "       }", "     if ((flags & 0x08) != 0)", "       {", "         char", "           *comment;", " ", "         size_t", "           length;", " ", "          ", "         length=ReadBlobLSBShort(image);", "         if (length != 0)", "           {", "             comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));", "             if (comment == (char *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             (void) ReadBlob(image,length-1,(unsigned char *) comment);", "             comment[length-1]='\\0';", "             (void) SetImageProperty(image,\"comment\",comment);", "             comment=DestroyString(comment);", "             if ((length & 0x01) == 0)", "               (void) ReadBlobByte(image);", "           }", "       }", "     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     status=SetImageExtent(image,image->columns,image->rows);", "     if (status == MagickFalse)", "       {", "         InheritException(exception,&image->exception);", "         return(DestroyImageList(image));", "       }", "      ", "     if (image->matte != MagickFalse)", "       number_planes++;", "     number_pixels=(MagickSizeType) image->columns*image->rows;", "     number_planes_filled=(number_planes % 2 == 0) ? number_planes :", "       number_planes+1;", "     if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*", "           number_planes_filled))", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "      pixel_info=AcquireVirtualMemory(image->columns,image->rows*", "      number_planes_filled*sizeof(*pixels));", "       MagickMax(number_planes_filled,4)*sizeof(*pixels));", "      if (pixel_info == (MemoryInfo *) NULL)", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "    pixel_info_length=image->columns*image->rows*number_planes_filled;", "     pixel_info_length=image->columns*image->rows*", "       MagickMax(number_planes_filled,4);", "      pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);", "      if ((flags & 0x01) && !(flags & 0x02))", "        {", "         ssize_t", "           j;", " ", "          ", "         p=pixels;", "         for (i=0; i < (ssize_t) number_pixels; i++)", "         {", "           if (image->matte == MagickFalse)", "             for (j=0; j < (ssize_t) number_planes; j++)", "               *p++=background_color[j];", "           else", "             {", "               for (j=0; j < (ssize_t) (number_planes-1); j++)", "                 *p++=background_color[j];", "               *p++=0;   ", "             }", "         }", "       }", "      ", "     plane=0;", "     x=0;", "     y=0;", "     opcode=ReadBlobByte(image);", "     do", "     {", "       switch (opcode & 0x3f)", "       {", "         case SkipLinesOp:", "         {", "           operand=ReadBlobByte(image);", "           if (opcode & 0x40)", "             operand=ReadBlobLSBSignedShort(image);", "           x=0;", "           y+=operand;", "           break;", "         }", "         case SetColorOp:", "         {", "           operand=ReadBlobByte(image);", "           plane=(unsigned char) operand;", "           if (plane == 255)", "             plane=(unsigned char) (number_planes-1);", "           x=0;", "           break;", "         }", "         case SkipPixelsOp:", "         {", "           operand=ReadBlobByte(image);", "           if (opcode & 0x40)", "             operand=ReadBlobLSBSignedShort(image);", "           x+=operand;", "           break;", "         }", "         case ByteDataOp:", "         {", "           operand=ReadBlobByte(image);", "           if (opcode & 0x40)", "             operand=ReadBlobLSBSignedShort(image);", "           offset=((image->rows-y-1)*image->columns*number_planes)+x*", "             number_planes+plane;", "           operand++;", "           if (offset+((size_t) operand*number_planes) > pixel_info_length)", "             {", "               if (number_colormaps != 0)", "                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "               pixel_info=RelinquishVirtualMemory(pixel_info);", "               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "             }", "           p=pixels+offset;", "           for (i=0; i < (ssize_t) operand; i++)", "           {", "             pixel=(unsigned char) ReadBlobByte(image);", "             if ((y < (ssize_t) image->rows) &&", "                 ((x+i) < (ssize_t) image->columns))", "               *p=pixel;", "             p+=number_planes;", "           }", "           if (operand & 0x01)", "             (void) ReadBlobByte(image);", "           x+=operand;", "           break;", "         }", "         case RunDataOp:", "         {", "           operand=ReadBlobByte(image);", "           if (opcode & 0x40)", "             operand=ReadBlobLSBSignedShort(image);", "           pixel=(unsigned char) ReadBlobByte(image);", "           (void) ReadBlobByte(image);", "           operand++;", "           offset=((image->rows-y-1)*image->columns*number_planes)+x*", "             number_planes+plane;", "           p=pixels+offset;", "           if (offset+((size_t) operand*number_planes) > pixel_info_length)", "             {", "               if (number_colormaps != 0)", "                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "               pixel_info=RelinquishVirtualMemory(pixel_info);", "               ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "             }", "           for (i=0; i < (ssize_t) operand; i++)", "           {", "             if ((y < (ssize_t) image->rows) &&", "                 ((x+i) < (ssize_t) image->columns))", "               *p=pixel;", "             p+=number_planes;", "           }", "           x+=operand;", "           break;", "         }", "         default:", "           break;", "       }", "       opcode=ReadBlobByte(image);", "     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));", "     if (number_colormaps != 0)", "       {", "         MagickStatusType", "           mask;", " ", "          ", "         mask=(MagickStatusType) (map_length-1);", "         p=pixels;", "         x=(ssize_t) number_planes;", "         if (number_colormaps == 1)", "           for (i=0; i < (ssize_t) number_pixels; i++)", "           {", "             if (IsValidColormapIndex(image,*p & mask,&index,exception) ==", "                 MagickFalse)", "               break;", "             *p=colormap[(ssize_t) index];", "             p++;", "           }", "         else", "           if ((number_planes >= 3) && (number_colormaps >= 3))", "             for (i=0; i < (ssize_t) number_pixels; i++)", "               for (x=0; x < (ssize_t) number_planes; x++)", "               {", "                 if (IsValidColormapIndex(image,(size_t) (x*map_length+", "                     (*p & mask)),&index,exception) == MagickFalse)", "                   break;", "                 *p=colormap[(ssize_t) index];", "                 p++;", "               }", "         if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))", "           {", "             colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "             pixel_info=RelinquishVirtualMemory(pixel_info);", "             ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "           }", "       }", "      ", "     if (number_planes >= 3)", "       {", "          ", "         p=pixels;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (PixelPacket *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelRed(q,ScaleCharToQuantum(*p++));", "             SetPixelGreen(q,ScaleCharToQuantum(*p++));", "             SetPixelBlue(q,ScaleCharToQuantum(*p++));", "             if (image->matte != MagickFalse)", "               SetPixelAlpha(q,ScaleCharToQuantum(*p++));", "             q++;", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "       }", "     else", "       {", "          ", "         if (number_colormaps == 0)", "           map_length=256;", "         if (AcquireImageColormap(image,map_length) == MagickFalse)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         p=colormap;", "         if (number_colormaps == 1)", "           for (i=0; i < (ssize_t) image->colors; i++)", "           {", "              ", "             image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);", "             image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);", "             image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);", "           }", "         else", "           if (number_colormaps > 1)", "             for (i=0; i < (ssize_t) image->colors; i++)", "             {", "               image->colormap[i].red=ScaleCharToQuantum(*p);", "               image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));", "               image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));", "               p++;", "             }", "         p=pixels;", "         if (image->matte == MagickFalse)", "           {", "              ", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (PixelPacket *) NULL)", "                 break;", "               indexes=GetAuthenticIndexQueue(image);", "               for (x=0; x < (ssize_t) image->columns; x++)", "                 SetPixelIndex(indexes+x,*p++);", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "             (void) SyncImage(image);", "           }", "         else", "           {", "              ", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (PixelPacket *) NULL)", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                     MagickFalse)", "                   break;", "                 SetPixelRed(q,image->colormap[(ssize_t) index].red);", "                 if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                     MagickFalse)", "                   break;", "                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);", "                 if (IsValidColormapIndex(image,*p++,&index,exception) ==", "                     MagickFalse)", "                   break;", "                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);", "                 SetPixelAlpha(q,ScaleCharToQuantum(*p++));", "                 q++;", "               }", "               if (x < (ssize_t) image->columns)", "                 break;", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "             image->colormap=(PixelPacket *) RelinquishMagickMemory(", "               image->colormap);", "             image->storage_class=DirectClass;", "             image->colors=0;", "           }", "       }", "     if (number_colormaps != 0)", "       colormap=(unsigned char *) RelinquishMagickMemory(colormap);", "     pixel_info=RelinquishVirtualMemory(pixel_info);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     (void) ReadBlobByte(image);", "     count=ReadBlob(image,2,(unsigned char *) magick);", "     if ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0))", "       {", "          ", "         AcquireNextImage(image_info,image);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   } while ((count != 0) && (memcmp(magick,\"\\122\\314\",2) == 0));", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int recv_files(int f_in, int f_out, char *local_name)", " {", " \tint fd1,fd2;", " \tSTRUCT_STAT st;", " \tint iflags, xlen;", " \tchar *fname, fbuf[MAXPATHLEN];", " \tchar xname[MAXPATHLEN];", " \tchar fnametmp[MAXPATHLEN];", " \tchar *fnamecmp, *partialptr;", " \tchar fnamecmpbuf[MAXPATHLEN];", " \tuchar fnamecmp_type;", " \tstruct file_struct *file;", " \tint itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;", " \tenum logcode log_code = log_before_transfer ? FLOG : FINFO;", " \tint max_phase = protocol_version >= 29 ? 2 : 1;", " \tint dflt_perms = (ACCESSPERMS & ~orig_umask);", " #ifdef SUPPORT_ACLS", " \tconst char *parent_dirname = \"\";", " #endif", " \tint ndx, recv_ok;", " ", " \tif (DEBUG_GTE(RECV, 1))", " \t\trprintf(FINFO, \"recv_files(%d) starting\\n\", cur_flist->used);", " ", " \tif (delay_updates)", " \t\tdelayed_bits = bitbag_create(cur_flist->used + 1);", " ", " \twhile (1) {", " \t\tcleanup_disable();", " ", " \t\t ", " \t\tndx = read_ndx_and_attrs(f_in, f_out, &iflags, &fnamecmp_type,", " \t\t\t\t\t xname, &xlen);", " \t\tif (ndx == NDX_DONE) {", " \t\t\tif (!am_server && INFO_GTE(PROGRESS, 2) && cur_flist) {", " \t\t\t\tset_current_file_index(NULL, 0);", " \t\t\t\tend_progress(0);", " \t\t\t}", " \t\t\tif (inc_recurse && first_flist) {", " \t\t\t\tif (read_batch) {", " \t\t\t\t\tndx = first_flist->used + first_flist->ndx_start;", " \t\t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);", " \t\t\t\t}", " \t\t\t\tflist_free(first_flist);", " \t\t\t\tif (first_flist)", " \t\t\t\t\tcontinue;", " \t\t\t} else if (read_batch && first_flist) {", " \t\t\t\tndx = first_flist->used;", " \t\t\t\tgen_wants_ndx(ndx, first_flist->flist_num);", " \t\t\t}", " \t\t\tif (++phase > max_phase)", " \t\t\t\tbreak;", " \t\t\tif (DEBUG_GTE(RECV, 1))", " \t\t\t\trprintf(FINFO, \"recv_files phase=%d\\n\", phase);", " \t\t\tif (phase == 2 && delay_updates)", " \t\t\t\thandle_delayed_updates(local_name);", " \t\t\twrite_int(f_out, NDX_DONE);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (ndx - cur_flist->ndx_start >= 0)", " \t\t\tfile = cur_flist->files[ndx - cur_flist->ndx_start];", " \t\telse", " \t\t\tfile = dir_flist->files[cur_flist->parent_ndx];", " \t\tfname = local_name ? local_name : f_name(file, fbuf);", " ", " \t\tif (daemon_filter_list.head", " \t\t    && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0) {", " \t\t\trprintf(FERROR, \"attempt to hack rsync failed.\\n\");", " \t\t\texit_cleanup(RERR_PROTOCOL);", " \t\t}", " ", " \t\tif (DEBUG_GTE(RECV, 1))", " \t\t\trprintf(FINFO, \"recv_files(%s)\\n\", fname);", " ", " #ifdef SUPPORT_XATTRS", " \t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers", " \t\t && !(want_xattr_optim && BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE)))", " \t\t\trecv_xattr_request(file, f_in);", " #endif", " ", " \t\tif (!(iflags & ITEM_TRANSFER)) {", " \t\t\tmaybe_log_item(file, iflags, itemizing, xname);", " #ifdef SUPPORT_XATTRS", " \t\t\tif (preserve_xattrs && iflags & ITEM_REPORT_XATTR && do_xfers", " \t\t\t && !BITS_SET(iflags, ITEM_XNAME_FOLLOWS|ITEM_LOCAL_CHANGE))", " \t\t\t\tset_file_attrs(fname, file, NULL, fname, 0);", " #endif", " \t\t\tif (iflags & ITEM_IS_NEW) {", " \t\t\t\tstats.created_files++;", " \t\t\t\tif (S_ISREG(file->mode)) {", " \t\t\t\t\t ", " \t\t\t\t} else if (S_ISDIR(file->mode))", " \t\t\t\t\tstats.created_dirs++;", " #ifdef SUPPORT_LINKS", " \t\t\t\telse if (S_ISLNK(file->mode))", " \t\t\t\t\tstats.created_symlinks++;", " #endif", " \t\t\t\telse if (IS_DEVICE(file->mode))", " \t\t\t\t\tstats.created_devices++;", " \t\t\t\telse", " \t\t\t\t\tstats.created_specials++;", " \t\t\t}", " \t\t\tcontinue;", " \t\t}", " \t\tif (phase == 2) {", " \t\t\trprintf(FERROR,", " \t\t\t\t\"got transfer request in phase 2 [%s]\\n\",", " \t\t\t\twho_am_i());", " \t\t\texit_cleanup(RERR_PROTOCOL);", " \t\t}", " ", " \t\tif (file->flags & FLAG_FILE_SENT) {", " \t\t\tif (csum_length == SHORT_SUM_LENGTH) {", " \t\t\t\tif (keep_partial && !partial_dir)", " \t\t\t\t\tmake_backups = -make_backups;  ", " \t\t\t\tif (append_mode)", " \t\t\t\t\tsparse_files = -sparse_files;", " \t\t\t\tappend_mode = -append_mode;", " \t\t\t\tcsum_length = SUM_LENGTH;", " \t\t\t\tredoing = 1;", " \t\t\t}", " \t\t} else {", " \t\t\tif (csum_length != SHORT_SUM_LENGTH) {", " \t\t\t\tif (keep_partial && !partial_dir)", " \t\t\t\t\tmake_backups = -make_backups;", " \t\t\t\tif (append_mode)", " \t\t\t\t\tsparse_files = -sparse_files;", " \t\t\t\tappend_mode = -append_mode;", " \t\t\t\tcsum_length = SHORT_SUM_LENGTH;", " \t\t\t\tredoing = 0;", " \t\t\t}", " \t\t\tif (iflags & ITEM_IS_NEW)", " \t\t\t\tstats.created_files++;", " \t\t}", " ", " \t\tif (!am_server && INFO_GTE(PROGRESS, 1))", " \t\t\tset_current_file_index(file, ndx);", " \t\tstats.xferred_files++;", " \t\tstats.total_transferred_size += F_LENGTH(file);", " ", " \t\tcleanup_got_literal = 0;", " ", " \t\tif (read_batch) {", " \t\t\tint wanted = redoing", " \t\t\t\t   ? we_want_redo(ndx)", " \t\t\t\t   : gen_wants_ndx(ndx, cur_flist->flist_num);", " \t\t\tif (!wanted) {", " \t\t\t\trprintf(FINFO,", " \t\t\t\t\t\"(Skipping batched update for%s \\\"%s\\\")\\n\",", " \t\t\t\t\tredoing ? \" resend of\" : \"\",", " \t\t\t\t\tfname);", " \t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\t\tfile->flags |= FLAG_FILE_SENT;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t}", " ", " \t\tremember_initial_stats();", " ", " \t\tif (!do_xfers) {  ", " \t\t\tlog_item(FCLIENT, file, iflags, NULL);", " \t\t\tif (read_batch)", " \t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\tcontinue;", " \t\t}", " \t\tif (write_batch < 0) {", " \t\t\tlog_item(FCLIENT, file, iflags, NULL);", " \t\t\tif (!am_server)", " \t\t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\tif (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tpartialptr = partial_dir ? partial_dir_fname(fname) : fname;", " ", " \t\tif (protocol_version >= 29) {", " \t\t\tswitch (fnamecmp_type) {", " \t\t\tcase FNAMECMP_FNAME:", " \t\t\t\tfnamecmp = fname;", " \t\t\t\tbreak;", " \t\t\tcase FNAMECMP_PARTIAL_DIR:", " \t\t\t\tfnamecmp = partialptr;", " \t\t\t\tbreak;", " \t\t\tcase FNAMECMP_BACKUP:", " \t\t\t\tfnamecmp = get_backup_name(fname);", " \t\t\t\tbreak;", " \t\t\tcase FNAMECMP_FUZZY:", " \t\t\t\tif (file->dirname) {", " \t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, file->dirname, xname);", " \t\t\t\t\tfnamecmp = fnamecmpbuf;", " \t\t\t\t} else", " \t\t\t\t\tfnamecmp = xname;", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tif (fnamecmp_type > FNAMECMP_FUZZY && fnamecmp_type-FNAMECMP_FUZZY <= basis_dir_cnt) {", " \t\t\t\t\tfnamecmp_type -= FNAMECMP_FUZZY + 1;", " \t\t\t\t\tif (file->dirname) {", " \t\t\t\t\t\tstringjoin(fnamecmpbuf, sizeof fnamecmpbuf,", " \t\t\t\t\t\t\t   basis_dir[fnamecmp_type], \"/\", file->dirname, \"/\", xname, NULL);", " \t\t\t\t\t} else", " \t\t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], xname);", " \t\t\t\t} else if (fnamecmp_type >= basis_dir_cnt) {", " \t\t\t\t\trprintf(FERROR,", " \t\t\t\t\t\t\"invalid basis_dir index: %d.\\n\",", " \t\t\t\t\t\tfnamecmp_type);", " \t\t\t\t\texit_cleanup(RERR_PROTOCOL);", " \t\t\t\t} else", " \t\t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf, basis_dir[fnamecmp_type], fname);", " \t\t\t\tfnamecmp = fnamecmpbuf;", "                                 break;", "                         }", "                         if (!fnamecmp || (daemon_filter_list.head", "                         && check_filter(&daemon_filter_list, FLOG, fname, 0) < 0)) {", "                          && check_filter(&daemon_filter_list, FLOG, fnamecmp, 0) < 0)) {", "                                 fnamecmp = fname;", "                                 fnamecmp_type = FNAMECMP_FNAME;", "                         }", " \t\t} else {", " \t\t\t ", " \t\t\tif (inplace && make_backups > 0) {", " \t\t\t\tif (!(fnamecmp = get_backup_name(fname)))", " \t\t\t\t\tfnamecmp = fname;", " \t\t\t\telse", " \t\t\t\t\tfnamecmp_type = FNAMECMP_BACKUP;", " \t\t\t} else if (partial_dir && partialptr)", " \t\t\t\tfnamecmp = partialptr;", " \t\t\telse", " \t\t\t\tfnamecmp = fname;", " \t\t}", " ", " \t\t ", " \t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);", " ", " \t\tif (fd1 == -1 && protocol_version < 29) {", " \t\t\tif (fnamecmp != fname) {", " \t\t\t\tfnamecmp = fname;", " \t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);", " \t\t\t}", " ", " \t\t\tif (fd1 == -1 && basis_dir[0]) {", " \t\t\t\t ", " \t\t\t\tpathjoin(fnamecmpbuf, sizeof fnamecmpbuf,", " \t\t\t\t\t basis_dir[0], fname);", " \t\t\t\tfnamecmp = fnamecmpbuf;", " \t\t\t\tfd1 = do_open(fnamecmp, O_RDONLY, 0);", " \t\t\t}", " \t\t}", " ", " \t\tupdating_basis_or_equiv = inplace", " \t\t    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);", " ", " \t\tif (fd1 == -1) {", " \t\t\tst.st_mode = 0;", " \t\t\tst.st_size = 0;", " \t\t} else if (do_fstat(fd1,&st) != 0) {", " \t\t\trsyserr(FERROR_XFER, errno, \"fstat %s failed\",", " \t\t\t\tfull_fname(fnamecmp));", " \t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\tclose(fd1);", " \t\t\tif (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {", " \t\t\t ", " \t\t\trprintf(FERROR_XFER, \"recv_files: %s is a directory\\n\",", " \t\t\t\tfull_fname(fnamecmp));", " \t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\tclose(fd1);", " \t\t\tif (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);", " \t\t\tcontinue;", " \t\t}", " ", " \t\tif (fd1 != -1 && !S_ISREG(st.st_mode)) {", " \t\t\tclose(fd1);", " \t\t\tfd1 = -1;", " \t\t}", " ", " \t\t ", " \t\tif (!preserve_perms) {", " \t\t\tint exists = fd1 != -1;", " #ifdef SUPPORT_ACLS", " \t\t\tconst char *dn = file->dirname ? file->dirname : \".\";", " \t\t\tif (parent_dirname != dn", " \t\t\t && strcmp(parent_dirname, dn) != 0) {", " \t\t\t\tdflt_perms = default_perms_for_dir(dn);", " \t\t\t\tparent_dirname = dn;", " \t\t\t}", " #endif", " \t\t\tfile->mode = dest_mode(file->mode, st.st_mode,", " \t\t\t\t\t       dflt_perms, exists);", " \t\t}", " ", " \t\t ", " \t\tif (inplace)  {", " \t\t\tfd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);", " \t\t\tif (fd2 == -1) {", " \t\t\t\trsyserr(FERROR_XFER, errno, \"open %s failed\",", " \t\t\t\t\tfull_fname(fname));", " \t\t\t} else if (updating_basis_or_equiv)", " \t\t\t\tcleanup_set(NULL, NULL, file, fd1, fd2);", " \t\t} else {", " \t\t\tfd2 = open_tmpfile(fnametmp, fname, file);", " \t\t\tif (fd2 != -1)", " \t\t\t\tcleanup_set(fnametmp, partialptr, file, fd1, fd2);", " \t\t}", " ", " \t\tif (fd2 == -1) {", " \t\t\tdiscard_receive_data(f_in, F_LENGTH(file));", " \t\t\tif (fd1 != -1)", " \t\t\t\tclose(fd1);", " \t\t\tif (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);", " \t\t\tcontinue;", " \t\t}", " ", " \t\t ", " \t\tif (log_before_transfer)", " \t\t\tlog_item(FCLIENT, file, iflags, NULL);", " \t\telse if (!am_server && INFO_GTE(NAME, 1) && INFO_EQ(PROGRESS, 1))", " \t\t\trprintf(FINFO, \"%s\\n\", fname);", " ", " \t\t ", " \t\trecv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,", " \t\t\t\t       fname, fd2, F_LENGTH(file));", " ", " \t\tlog_item(log_code, file, iflags, NULL);", " ", " \t\tif (fd1 != -1)", " \t\t\tclose(fd1);", " \t\tif (close(fd2) < 0) {", " \t\t\trsyserr(FERROR, errno, \"close failed on %s\",", " \t\t\t\tfull_fname(fnametmp));", " \t\t\texit_cleanup(RERR_FILEIO);", " \t\t}", " ", " \t\tif ((recv_ok && (!delay_updates || !partialptr)) || inplace) {", " \t\t\tif (partialptr == fname)", " \t\t\t\tpartialptr = NULL;", " \t\t\tif (!finish_transfer(fname, fnametmp, fnamecmp,", " \t\t\t\t\t     partialptr, file, recv_ok, 1))", " \t\t\t\trecv_ok = -1;", " \t\t\telse if (fnamecmp == partialptr) {", " \t\t\t\tdo_unlink(partialptr);", " \t\t\t\thandle_partial_dir(partialptr, PDIR_DELETE);", " \t\t\t}", " \t\t} else if (keep_partial && partialptr) {", " \t\t\tif (!handle_partial_dir(partialptr, PDIR_CREATE)) {", " \t\t\t\trprintf(FERROR,", " \t\t\t\t    \"Unable to create partial-dir for %s -- discarding %s.\\n\",", " \t\t\t\t    local_name ? local_name : f_name(file, NULL),", " \t\t\t\t    recv_ok ? \"completed file\" : \"partial file\");", " \t\t\t\tdo_unlink(fnametmp);", " \t\t\t\trecv_ok = -1;", " \t\t\t} else if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,", " \t\t\t\t\t\t    file, recv_ok, !partial_dir))", " \t\t\t\trecv_ok = -1;", " \t\t\telse if (delay_updates && recv_ok) {", " \t\t\t\tbitbag_set_bit(delayed_bits, ndx);", " \t\t\t\trecv_ok = 2;", " \t\t\t} else", " \t\t\t\tpartialptr = NULL;", " \t\t} else", " \t\t\tdo_unlink(fnametmp);", " ", " \t\tcleanup_disable();", " ", " \t\tif (read_batch)", " \t\t\tfile->flags |= FLAG_FILE_SENT;", " ", " \t\tswitch (recv_ok) {", " \t\tcase 2:", " \t\t\tbreak;", " \t\tcase 1:", " \t\t\tif (remove_source_files || inc_recurse", " \t\t\t || (preserve_hard_links && F_IS_HLINKED(file)))", " \t\t\t\tsend_msg_int(MSG_SUCCESS, ndx);", " \t\t\tbreak;", " \t\tcase 0: {", " \t\t\tenum logcode msgtype = redoing ? FERROR_XFER : FWARNING;", " \t\t\tif (msgtype == FERROR_XFER || INFO_GTE(NAME, 1)) {", " \t\t\t\tchar *errstr, *redostr, *keptstr;", " \t\t\t\tif (!(keep_partial && partialptr) && !inplace)", " \t\t\t\t\tkeptstr = \"discarded\";", " \t\t\t\telse if (partial_dir)", " \t\t\t\t\tkeptstr = \"put into partial-dir\";", " \t\t\t\telse", " \t\t\t\t\tkeptstr = \"retained\";", " \t\t\t\tif (msgtype == FERROR_XFER) {", " \t\t\t\t\terrstr = \"ERROR\";", " \t\t\t\t\tredostr = \"\";", " \t\t\t\t} else {", " \t\t\t\t\terrstr = \"WARNING\";", " \t\t\t\t\tredostr = read_batch ? \" (may try again)\"", " \t\t\t\t\t\t\t     : \" (will try again)\";", " \t\t\t\t}", " \t\t\t\trprintf(msgtype,", " \t\t\t\t\t\"%s: %s failed verification -- update %s%s.\\n\",", " \t\t\t\t\terrstr, local_name ? f_name(file, NULL) : fname,", " \t\t\t\t\tkeptstr, redostr);", " \t\t\t}", " \t\t\tif (!redoing) {", " \t\t\t\tif (read_batch)", " \t\t\t\t\tflist_ndx_push(&batch_redo_list, ndx);", " \t\t\t\tsend_msg_int(MSG_REDO, ndx);", " \t\t\t\tfile->flags |= FLAG_FILE_SENT;", " \t\t\t} else if (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);", " \t\t\tbreak;", " \t\t    }", " \t\tcase -1:", " \t\t\tif (inc_recurse)", " \t\t\t\tsend_msg_int(MSG_NO_SEND, ndx);", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (make_backups < 0)", " \t\tmake_backups = -make_backups;", " ", " \tif (phase == 2 && delay_updates)  ", " \t\thandle_delayed_updates(local_name);", " ", " \tif (DEBUG_GTE(RECV, 1))", " \t\trprintf(FINFO,\"recv_files finished\\n\");", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool inode_capable(const struct inode *inode, int cap)", " bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)", "  {", "  \tstruct user_namespace *ns = current_user_ns();", "  ", "\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);", " \treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&", " \t\tkgid_has_mapping(ns, inode->i_gid);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["local void init_block(s)", "deflate_state *s;", "{", "int n;", "", "", "for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;", "for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;", "for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;", "", "s->dyn_ltree[END_BLOCK].Freq = 1;", "s->opt_len = s->static_len = 0L;", "s->last_lit = s->matches = 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void WebGL2RenderingContextBase::texImage3D(", "     GLenum target,", "     GLint level,", "     GLint internalformat,", "     GLsizei width,", "     GLsizei height,", "     GLsizei depth,", "     GLint border,", "      GLenum format,", "      GLenum type,", "      MaybeShared<DOMArrayBufferView> pixels) {", "   if ((unpack_flip_y_ || unpack_premultiply_alpha_) && pixels) {", "     SynthesizeGLError(", "         GL_INVALID_OPERATION, \"texImage3D\",", "         \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed for uploading 3D textures\");", "     return;", "   }", "    TexImageHelperDOMArrayBufferView(kTexImage3D, target, level, internalformat,", "                                     width, height, depth, border, format, type,", "                                     0, 0, 0, pixels.View(), kNullAllowed, 0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["xfs_agf_verify(", "struct xfs_buf  *bp)", "{", "struct xfs_mount *mp = bp->b_mount;", "struct xfs_agf  *agf = XFS_BUF_TO_AGF(bp);", "", "if (xfs_sb_version_hascrc(&mp->m_sb)) {", "if (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))", "return __this_address;", "if (!xfs_log_check_lsn(mp,", "be64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))", "return __this_address;", "}", "", "if (!xfs_verify_magic(bp, agf->agf_magicnum))", "return __this_address;", "", "if (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&", "be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&", "be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&", "be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&", "be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))", "return __this_address;", "", "if (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||", "be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||", "be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||", "be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)", "return __this_address;", "", "if (xfs_sb_version_hasrmapbt(&mp->m_sb) &&", "(be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||", "be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))", "return __this_address;", "", "", "", "", "", "", "", "if (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)", "return __this_address;", "", "if (xfs_sb_version_haslazysbcount(&mp->m_sb) &&", "be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))", "return __this_address;", "", "if (xfs_sb_version_hasreflink(&mp->m_sb) &&", "(be32_to_cpu(agf->agf_refcount_level) < 1 ||", "be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))", "return __this_address;", "", "return NULL;", "", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {", "if (!getSSLManager()) {", "return Status(ErrorCodes::ProtocolError,", "\"SSL support is required for the MONGODB-X509 mechanism.\");", "}", "if(user.getDB() != \"$external\") {", "return Status(ErrorCodes::ProtocolError,", "\"X.509 authentication must always use the $external database.\");", "}", "", "ClientBasic *client = ClientBasic::getCurrent();", "AuthorizationSession* authorizationSession = client->getAuthorizationSession();", "std::string subjectName = client->port()->getX509SubjectName();", "", "if (user.getUser() != subjectName) {", "return Status(ErrorCodes::AuthenticationFailed,", "\"There is no x.509 client certificate matching the user.\");", "}", "else {", "std::string srvSubjectName = getSSLManager()->getServerSubjectName();", "std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));", "std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));", "", "fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);", "", "", "int clusterAuthMode = serverGlobalParams.clusterAuthMode.load();", "if (srvClusterId == peerClusterId) {", "if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||", "clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {", "return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \"", "\"can only be used for cluster authentication, not client \"", "\"authentication. The current configuration does not allow \"", "\"x.509 cluster authentication, check the --clusterAuthMode flag\");", "}", "authorizationSession->grantInternalAuthorization();", "}", "", "else {", "if (_isX509AuthDisabled) {", "return Status(ErrorCodes::BadValue,", "_x509AuthenticationDisabledMessage);", "}", "Status status = authorizationSession->addAndAuthorizeUser(user);", "if (!status.isOK()) {", "return status;", "}", "}", "return Status::OK();", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)", "  {", "      const char *perm = \"add\";", " ", "     if (uid >= AID_APP) {", "         return 0;  ", "     }", " ", "      return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["std::string queueloader::get_filename(const std::string& str) {", "std::string fn = ctrl->get_dlpath();", "", "if (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])", "fn.append(NEWSBEUTER_PATH_SEP);", "char buf[1024];", "snprintf(buf, sizeof(buf), \"%s\", str.c_str());", "char * base = basename(buf);", "if (!base || strlen(base) == 0) {", "char lbuf[128];", "time_t t = time(nullptr);", "strftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));", "fn.append(lbuf);", "} else {", "fn.append(base);", "}", "return fn;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" bool DoCanonicalizePathComponent(const CHAR* source,", " template <typename CHAR, typename UCHAR>", " void DoCanonicalizePathComponent(const CHAR* source,", "                                   const Component& component,", "                                   char separator,", "                                   CanonOutput* output,", "                                   Component* new_component) {", "  bool success = true;", "    if (component.is_valid()) {", "      if (separator)", "        output->push_back(separator);", "     new_component->begin = output->length();", "     int end = component.end();", "      for (int i = component.begin; i < end; i++) {", "        UCHAR uch = static_cast<UCHAR>(source[i]);", "        if (uch < 0x20 || uch >= 0x80)", "        success &= AppendUTF8EscapedChar(source, &i, end, output);", "         AppendUTF8EscapedChar(source, &i, end, output);", "        else", "          output->push_back(static_cast<char>(uch));", "      }", "     new_component->len = output->length() - new_component->begin;", "   } else {", "      new_component->reset();", "    }", "  return success;", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static int mark_source_chains(const struct xt_table_info *newinfo,", " \t\t\t      unsigned int valid_hooks, void *entry0)", " {", " \tunsigned int hook;", " ", " \t ", " \tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {", " \t\tunsigned int pos = newinfo->hook_entry[hook];", " \t\tstruct arpt_entry *e", " \t\t\t= (struct arpt_entry *)(entry0 + pos);", " ", " \t\tif (!(valid_hooks & (1 << hook)))", " \t\t\tcontinue;", " ", " \t\t ", " \t\te->counters.pcnt = pos;", " ", " \t\tfor (;;) {", " \t\t\tconst struct xt_standard_target *t", " \t\t\t\t= (void *)arpt_get_target_c(e);", " \t\t\tint visited = e->comefrom & (1 << hook);", " ", " \t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {", " \t\t\t\tpr_notice(\"arptables: loop hook %u pos %u %08X.\\n\",", " \t\t\t\t       hook, pos, e->comefrom);", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\te->comefrom", "  \t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));", "  ", "  \t\t\t ", "\t\t\tif ((e->target_offset == sizeof(struct arpt_entry) &&", " \t\t\tif ((unconditional(e) &&", "  \t\t\t     (strcmp(t->target.u.user.name,", "  \t\t\t\t     XT_STANDARD_TARGET) == 0) &&", "\t\t\t     t->verdict < 0 && unconditional(&e->arp)) ||", "\t\t\t    visited) {", " \t\t\t     t->verdict < 0) || visited) {", "  \t\t\t\tunsigned int oldpos, size;", "  ", "  \t\t\t\tif ((strcmp(t->target.u.user.name,", " \t\t\t\t\t    XT_STANDARD_TARGET) == 0) &&", " \t\t\t\t    t->verdict < -NF_MAX_VERDICT - 1) {", " \t\t\t\t\tduprintf(\"mark_source_chains: bad \"", " \t\t\t\t\t\t\"negative verdict (%i)\\n\",", " \t\t\t\t\t\t\t\tt->verdict);", " \t\t\t\t\treturn 0;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\tdo {", " \t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);", " \t\t\t\t\toldpos = pos;", " \t\t\t\t\tpos = e->counters.pcnt;", " \t\t\t\t\te->counters.pcnt = 0;", " ", " \t\t\t\t\t ", " \t\t\t\t\tif (pos == oldpos)", " \t\t\t\t\t\tgoto next;", " ", " \t\t\t\t\te = (struct arpt_entry *)", " \t\t\t\t\t\t(entry0 + pos);", " \t\t\t\t} while (oldpos == pos + e->next_offset);", " ", " \t\t\t\t ", " \t\t\t\tsize = e->next_offset;", " \t\t\t\te = (struct arpt_entry *)", " \t\t\t\t\t(entry0 + pos + size);", " \t\t\t\te->counters.pcnt = pos;", " \t\t\t\tpos += size;", " \t\t\t} else {", " \t\t\t\tint newpos = t->verdict;", " ", " \t\t\t\tif (strcmp(t->target.u.user.name,", " \t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&", " \t\t\t\t    newpos >= 0) {", " \t\t\t\t\tif (newpos > newinfo->size -", " \t\t\t\t\t\tsizeof(struct arpt_entry)) {", " \t\t\t\t\t\tduprintf(\"mark_source_chains: \"", " \t\t\t\t\t\t\t\"bad verdict (%i)\\n\",", " \t\t\t\t\t\t\t\tnewpos);", " \t\t\t\t\t\treturn 0;", " \t\t\t\t\t}", " ", " \t\t\t\t\t ", " \t\t\t\t\tduprintf(\"Jump rule %u -> %u\\n\",", " \t\t\t\t\t\t pos, newpos);", " \t\t\t\t} else {", " \t\t\t\t\t ", " \t\t\t\t\tnewpos = pos + e->next_offset;", " \t\t\t\t}", " \t\t\t\te = (struct arpt_entry *)", " \t\t\t\t\t(entry0 + newpos);", " \t\t\t\te->counters.pcnt = pos;", " \t\t\t\tpos = newpos;", " \t\t\t}", " \t\t}", " next:", " \t\tduprintf(\"Finished chain %u\\n\", hook);", " \t}", " \treturn 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int t220_frontend_attach(struct dvb_usb_adapter *d)", " static int t220_frontend_attach(struct dvb_usb_adapter *adap)", "  {", "\tu8 obuf[3] = { 0xe, 0x87, 0 };", "\tu8 ibuf[] = { 0 };", " \tstruct dvb_usb_device *d = adap->dev;", " \tstruct dw2102_state *state = d->priv;", " ", " \tmutex_lock(&d->data_mutex);", "  ", "\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)", " \tstate->data[0] = 0xe;", " \tstate->data[1] = 0x87;", " \tstate->data[2] = 0x0;", " ", " \tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)", "  \t\terr(\"command 0x0e transfer failed.\");", "  ", "\tobuf[0] = 0xe;", "\tobuf[1] = 0x86;", "\tobuf[2] = 1;", " \tstate->data[0] = 0xe;", " \tstate->data[1] = 0x86;", " \tstate->data[2] = 1;", "  ", "\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)", " \tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)", "  \t\terr(\"command 0x0e transfer failed.\");", "  ", "\tobuf[0] = 0xe;", "\tobuf[1] = 0x80;", "\tobuf[2] = 0;", " \tstate->data[0] = 0xe;", " \tstate->data[1] = 0x80;", " \tstate->data[2] = 0;", "  ", "\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)", " \tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)", "  \t\terr(\"command 0x0e transfer failed.\");", "  ", "  \tmsleep(50);", "  ", "\tobuf[0] = 0xe;", "\tobuf[1] = 0x80;", "\tobuf[2] = 1;", " \tstate->data[0] = 0xe;", " \tstate->data[1] = 0x80;", " \tstate->data[2] = 1;", "  ", "\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)", " \tif (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)", "  \t\terr(\"command 0x0e transfer failed.\");", "  ", "\tobuf[0] = 0x51;", " \tstate->data[0] = 0x51;", "  ", "\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)", " \tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)", "  \t\terr(\"command 0x51 transfer failed.\");", "  ", "\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,", "\t\t\t\t\t&d->dev->i2c_adap, NULL);", "\tif (d->fe_adap[0].fe != NULL) {", "\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,", "\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {", " \tmutex_unlock(&d->data_mutex);", " ", " \tadap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,", " \t\t\t\t\t&d->i2c_adap, NULL);", " \tif (adap->fe_adap[0].fe != NULL) {", " \t\tif (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,", " \t\t\t\t\t&d->i2c_adap, &tda18271_config)) {", "  \t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");", "  \t\t\treturn 0;", "  \t\t}", " \t}", " ", " \tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");", "  \treturn -EIO;", "  }"], "ner_tags": [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xfs_acl_from_disk(struct xfs_acl *aclp)", " {", "  \tstruct posix_acl_entry *acl_e;", "  \tstruct posix_acl *acl;", "  \tstruct xfs_acl_entry *ace;", "\tint count, i;", " \tunsigned int count, i;", "  ", "  \tcount = be32_to_cpu(aclp->acl_cnt);", "  \tif (count > XFS_ACL_MAX_ENTRIES)", " \t\treturn ERR_PTR(-EFSCORRUPTED);", " ", " \tacl = posix_acl_alloc(count, GFP_KERNEL);", " \tif (!acl)", " \t\treturn ERR_PTR(-ENOMEM);", " ", " \tfor (i = 0; i < count; i++) {", " \t\tacl_e = &acl->a_entries[i];", " \t\tace = &aclp->acl_entry[i];", " ", " \t\t ", " \t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);", " \t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);", " ", " \t\tswitch (acl_e->e_tag) {", " \t\tcase ACL_USER:", " \t\tcase ACL_GROUP:", " \t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);", " \t\t\tbreak;", " \t\tcase ACL_USER_OBJ:", " \t\tcase ACL_GROUP_OBJ:", " \t\tcase ACL_MASK:", " \t\tcase ACL_OTHER:", " \t\t\tacl_e->e_id = ACL_UNDEFINED_ID;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tgoto fail;", " \t\t}", " \t}", " \treturn acl;", " ", " fail:", " \tposix_acl_release(acl);", " \treturn ERR_PTR(-EINVAL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,", "string* init_op_name) {", "const auto& sig_def_map = meta_graph_def.signature_def();", "const auto& init_op_sig_it =", "meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);", "if (init_op_sig_it != sig_def_map.end()) {", "*init_op_name = init_op_sig_it->second.outputs()", ".find(kSavedModelInitOpSignatureKey)", "->second.name();", "return Status::OK();", "}", "", "const auto& collection_def_map = meta_graph_def.collection_def();", "string init_op_collection_key;", "if (collection_def_map.find(kSavedModelMainOpKey) !=", "collection_def_map.end()) {", "init_op_collection_key = kSavedModelMainOpKey;", "} else {", "init_op_collection_key = kSavedModelLegacyInitOpKey;", "}", "", "const auto init_op_it = collection_def_map.find(init_op_collection_key);", "if (init_op_it != collection_def_map.end()) {", "if (init_op_it->second.node_list().value_size() != 1) {", "return errors::FailedPrecondition(", "strings::StrCat(\"Expected exactly one main op in : \", export_dir));", "}", "*init_op_name = init_op_it->second.node_list().value(0);", "}", "return Status::OK();", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["gen_hash(codegen_scope *s, node *tree, int val, int limit)", "{", "int slimit = GEN_VAL_STACK_MAX;", "if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;", "int len = 0;", "mrb_bool update = FALSE;", "", "while (tree) {", "if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {", "if (len > 0) {", "pop_n(len*2);", "if (!update) {", "genop_2(s, OP_HASH, cursp(), len);", "}", "else {", "pop();", "genop_2(s, OP_HASHADD, cursp(), len);", "}", "push();", "}", "codegen(s, tree->car->cdr, val);", "if (len > 0 || update) {", "pop(); pop();", "genop_1(s, OP_HASHCAT, cursp());", "push();", "}", "update = TRUE;", "len = 0;", "}", "else {", "codegen(s, tree->car->car, val);", "codegen(s, tree->car->cdr, val);", "len++;", "}", "tree = tree->cdr;", "if (val && cursp() >= slimit) {", "pop_n(len*2);", "if (!update) {", "genop_2(s, OP_HASH, cursp(), len);", "}", "else {", "pop();", "genop_2(s, OP_HASHADD, cursp(), len);", "}", "push();", "update = TRUE;", "len = 0;", "}", "}", "if (update) {", "if (len > 0) {", "pop_n(len*2+1);", "genop_2(s, OP_HASHADD, cursp(), len);", "push();", "}", "return -1;", "}", "if (update) return -1;", "return len;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" ParseNameValue(const char * buffer, int bufsize,", "                 struct NameValueParserData * data)", "  {", "  \tstruct xmlparser parser;", "\tdata->l_head = NULL;", "\tdata->portListing = NULL;", "\tdata->portListingLength = 0;", " \tmemset(data, 0, sizeof(struct NameValueParserData));", "  \t ", "  \tparser.xmlstart = buffer;", "  \tparser.xmlsize = bufsize;", " \tparser.data = data;", " \tparser.starteltfunc = NameValueParserStartElt;", " \tparser.endeltfunc = NameValueParserEndElt;", " \tparser.datafunc = NameValueParserGetData;", " \tparser.attfunc = 0;", " \tparsexml(&parser);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)", " static double abserr(const png_modifier *pm, int in_depth, int out_depth)", "  {", "      ", "  if (pm->assume_16_bit_calculations ||", "  (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)", "  return pm->maxabs16;", "  else", " ", "        return pm->maxabs8;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool AXNodeObject::isModal() const {", "   if (roleValue() != DialogRole && roleValue() != AlertDialogRole)", "     return false;", "  ", "    if (hasAttribute(aria_modalAttr)) {", "      const AtomicString& modal = getAttribute(aria_modalAttr);", "    if (equalIgnoringCase(modal, \"true\"))", "     if (equalIgnoringASCIICase(modal, \"true\"))", "        return true;", "    if (equalIgnoringCase(modal, \"false\"))", "     if (equalIgnoringASCIICase(modal, \"false\"))", "        return false;", "    }", "  ", "   if (getNode() && isHTMLDialogElement(*getNode()))", "     return toElement(getNode())->isInTopLayer();", " ", "   return false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int fsl_lpspi_probe(struct platform_device *pdev)", "{", "struct device_node *np = pdev->dev.of_node;", "struct fsl_lpspi_data *fsl_lpspi;", "struct spi_controller *controller;", "struct spi_imx_master *lpspi_platform_info =", "dev_get_platdata(&pdev->dev);", "struct resource *res;", "int i, ret, irq;", "u32 temp;", "bool is_slave;", "", "is_slave = of_property_read_bool((&pdev->dev)->of_node, \"spi-slave\");", "if (is_slave)", "controller = spi_alloc_slave(&pdev->dev,", "sizeof(struct fsl_lpspi_data));", "else", "controller = spi_alloc_master(&pdev->dev,", "sizeof(struct fsl_lpspi_data));", "", "if (!controller)", "return -ENOMEM;", "", "platform_set_drvdata(pdev, controller);", "", "fsl_lpspi = spi_controller_get_devdata(controller);", "fsl_lpspi->dev = &pdev->dev;", "fsl_lpspi->is_slave = is_slave;", "", "if (!fsl_lpspi->is_slave) {", "for (i = 0; i < controller->num_chipselect; i++) {", "int cs_gpio = of_get_named_gpio(np, \"cs-gpios\", i);", "", "if (!gpio_is_valid(cs_gpio) && lpspi_platform_info)", "cs_gpio = lpspi_platform_info->chipselect[i];", "", "fsl_lpspi->chipselect[i] = cs_gpio;", "if (!gpio_is_valid(cs_gpio))", "continue;", "", "ret = devm_gpio_request(&pdev->dev,", "fsl_lpspi->chipselect[i],", "DRIVER_NAME);", "if (ret) {", "dev_err(&pdev->dev, \"can't get cs gpios\\n\");", "goto out_controller_put;", "}", "}", "controller->cs_gpios = fsl_lpspi->chipselect;", "controller->prepare_message = fsl_lpspi_prepare_message;", "}", "", "controller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32);", "controller->transfer_one = fsl_lpspi_transfer_one;", "controller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware;", "controller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware;", "controller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;", "controller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;", "controller->dev.of_node = pdev->dev.of_node;", "controller->bus_num = pdev->id;", "controller->slave_abort = fsl_lpspi_slave_abort;", "", "init_completion(&fsl_lpspi->xfer_done);", "", "res = platform_get_resource(pdev, IORESOURCE_MEM, 0);", "fsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res);", "if (IS_ERR(fsl_lpspi->base)) {", "ret = PTR_ERR(fsl_lpspi->base);", "goto out_controller_put;", "}", "fsl_lpspi->base_phys = res->start;", "", "irq = platform_get_irq(pdev, 0);", "if (irq < 0) {", "ret = irq;", "goto out_controller_put;", "}", "", "ret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0,", "dev_name(&pdev->dev), fsl_lpspi);", "if (ret) {", "dev_err(&pdev->dev, \"can't get irq%d: %d\\n\", irq, ret);", "goto out_controller_put;", "}", "", "fsl_lpspi->clk_per = devm_clk_get(&pdev->dev, \"per\");", "if (IS_ERR(fsl_lpspi->clk_per)) {", "ret = PTR_ERR(fsl_lpspi->clk_per);", "goto out_controller_put;", "}", "", "fsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");", "if (IS_ERR(fsl_lpspi->clk_ipg)) {", "ret = PTR_ERR(fsl_lpspi->clk_ipg);", "goto out_controller_put;", "}", "", "", "ret = fsl_lpspi_init_rpm(fsl_lpspi);", "if (ret)", "goto out_controller_put;", "", "ret = pm_runtime_get_sync(fsl_lpspi->dev);", "if (ret < 0) {", "dev_err(fsl_lpspi->dev, \"failed to enable clock\\n\");", "return ret;", "}", "", "temp = readl(fsl_lpspi->base + IMX7ULP_PARAM);", "fsl_lpspi->txfifosize = 1 << (temp & 0x0f);", "fsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f);", "", "ret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller);", "if (ret == -EPROBE_DEFER)", "goto out_controller_put;", "", "if (ret < 0)", "dev_err(&pdev->dev, \"dma setup error %d, use pio\\n\", ret);", "", "ret = devm_spi_register_controller(&pdev->dev, controller);", "if (ret < 0) {", "dev_err(&pdev->dev, \"spi_register_controller error.\\n\");", "goto out_controller_put;", "}", "", "return 0;", "", "out_controller_put:", "spi_controller_put(controller);", "", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Element* siblingWithAriaRole(String role, Node* node) {", "   Node* parent = node->parentNode();", "   if (!parent)", "     return 0;", " ", "   for (Element* sibling = ElementTraversal::firstChild(*parent); sibling;", "         sibling = ElementTraversal::nextSibling(*sibling)) {", "      const AtomicString& siblingAriaRole =", "          AccessibleNode::getProperty(sibling, AOMStringProperty::kRole);", "    if (equalIgnoringCase(siblingAriaRole, role))", "     if (equalIgnoringASCIICase(siblingAriaRole, role))", "        return sibling;", "    }", "  ", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void MojoVideoEncodeAcceleratorService::UseOutputBitstreamBuffer(", "     int32_t bitstream_buffer_id,", "     mojo::ScopedSharedBufferHandle buffer) {", "   DVLOG(2) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id;", "   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);", " ", "   if (!encoder_)", "     return;", "   if (!buffer.is_valid()) {", "     DLOG(ERROR) << __func__ << \" invalid |buffer|.\";", "     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);", "     return;", "   }", "   if (bitstream_buffer_id < 0) {", "     DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id", "                 << \" must be >= 0\";", "     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);", "     return;", "   }", "  ", "    base::SharedMemoryHandle handle;", "    size_t memory_size = 0;", "  bool read_only = false;", "    auto result = mojo::UnwrapSharedMemoryHandle(std::move(buffer), &handle,", "                                               &memory_size, &read_only);", "                                                &memory_size, nullptr);", "    if (result != MOJO_RESULT_OK || memory_size == 0u) {", "      DLOG(ERROR) << __func__ << \" mojo::UnwrapSharedMemoryHandle() failed\";", "      NotifyError(::media::VideoEncodeAccelerator::kPlatformFailureError);", "     return;", "   }", " ", "   if (memory_size < output_buffer_size_) {", "     DLOG(ERROR) << __func__ << \" bitstream_buffer_id=\" << bitstream_buffer_id", "                 << \" has a size of \" << memory_size", "                 << \"B, different from expected \" << output_buffer_size_ << \"B\";", "     NotifyError(::media::VideoEncodeAccelerator::kInvalidArgumentError);", "     return;", "   }", " ", "   encoder_->UseOutputBitstreamBuffer(", "       BitstreamBuffer(bitstream_buffer_id, handle, memory_size));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void unix_notinflight(struct file *fp)", "  {", "  \tstruct sock *s = unix_get_socket(fp);", "  ", " \tspin_lock(&unix_gc_lock);", " ", "  \tif (s) {", "  \t\tstruct unix_sock *u = unix_sk(s);", "  ", "\t\tspin_lock(&unix_gc_lock);", "  \t\tBUG_ON(list_empty(&u->link));", "  ", "  \t\tif (atomic_long_dec_and_test(&u->inflight))", "  \t\t\tlist_del_init(&u->link);", "  \t\tunix_tot_inflight--;", "\t\tspin_unlock(&unix_gc_lock);", "  \t}", " \tfp->f_cred->user->unix_inflight--;", " \tspin_unlock(&unix_gc_lock);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}
{"tokens": [" static int php_var_unserialize_internal(UNSERIALIZE_PARAMETER)", " {", " \tconst unsigned char *cursor, *limit, *marker, *start;", " \tzval *rval_ref;", " ", " \tlimit = max;", " \tcursor = *p;", " ", " \tif (YYCURSOR >= YYLIMIT) {", " \t\treturn 0;", " \t}", " ", " \tif (var_hash && (*p)[0] != 'R') {", " \t\tvar_push(var_hash, rval);", " \t}", " ", " \tstart = cursor;", " ", " ", " #line 554 \"ext/standard/var_unserializer.c\"", " {", " \tYYCTYPE yych;", " \tstatic const unsigned char yybm[] = {", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t128, 128, 128, 128, 128, 128, 128, 128, ", " \t\t128, 128,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t\t  0,   0,   0,   0,   0,   0,   0,   0, ", " \t};", " ", " \tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);", " \tyych = *YYCURSOR;", " \tswitch (yych) {", " \tcase 'C':", " \tcase 'O':\tgoto yy13;", " \tcase 'N':\tgoto yy5;", " \tcase 'R':\tgoto yy2;", " \tcase 'S':\tgoto yy10;", " \tcase 'a':\tgoto yy11;", " \tcase 'b':\tgoto yy6;", " \tcase 'd':\tgoto yy8;", " \tcase 'i':\tgoto yy7;", " \tcase 'o':\tgoto yy12;", " \tcase 'r':\tgoto yy4;", " \tcase 's':\tgoto yy9;", " \tcase '}':\tgoto yy14;", " \tdefault:\tgoto yy16;", " \t}", " yy2:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy95;", " yy3:", " #line 884 \"ext/standard/var_unserializer.re\"", " \t{ return 0; }", " #line 580 \"ext/standard/var_unserializer.c\"", " yy4:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy89;", " \tgoto yy3;", " yy5:", " \tyych = *++YYCURSOR;", " \tif (yych == ';') goto yy87;", " \tgoto yy3;", " yy6:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy83;", " \tgoto yy3;", " yy7:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy77;", " \tgoto yy3;", " yy8:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy53;", " \tgoto yy3;", " yy9:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy46;", " \tgoto yy3;", " yy10:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy39;", " \tgoto yy3;", " yy11:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy32;", " \tgoto yy3;", " yy12:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy25;", " \tgoto yy3;", " yy13:", " \tyych = *(YYMARKER = ++YYCURSOR);", " \tif (yych == ':') goto yy17;", " \tgoto yy3;", " yy14:", " \t++YYCURSOR;", " #line 878 \"ext/standard/var_unserializer.re\"", " \t{", " \t ", " \tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");", " \treturn 0;  ", " }", " #line 629 \"ext/standard/var_unserializer.c\"", " yy16:", " \tyych = *++YYCURSOR;", " \tgoto yy3;", " yy17:", " \tyych = *++YYCURSOR;", " \tif (yybm[0+yych] & 128) {", " \t\tgoto yy20;", " \t}", " \tif (yych == '+') goto yy19;", " yy18:", " \tYYCURSOR = YYMARKER;", " \tgoto yy3;", " yy19:", " \tyych = *++YYCURSOR;", " \tif (yybm[0+yych] & 128) {", " \t\tgoto yy20;", " \t}", " \tgoto yy18;", " yy20:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);", " \tyych = *YYCURSOR;", "  \tif (yybm[0+yych] & 128) {", "  \t\tgoto yy20;", "  \t}", "\tif (yych != ':') goto yy18;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ';') goto yy18;", "  \tyych = *++YYCURSOR;", "  \tif (yych != '\"') goto yy18;", "  \t++YYCURSOR;", " #line 733 \"ext/standard/var_unserializer.re\"", " \t{", " \tsize_t len, len2, len3, maxlen;", " \tzend_long elements;", " \tchar *str;", " \tzend_string *class_name;", " \tzend_class_entry *ce;", " \tint incomplete_class = 0;", " ", " \tint custom_object = 0;", " ", " \tzval user_func;", " \tzval retval;", " \tzval args[1];", " ", "     if (!var_hash) return 0;", " \tif (*start == 'C') {", " \t\tcustom_object = 1;", " \t}", " ", " \tlen2 = len = parse_uiv(start + 2);", " \tmaxlen = max - YYCURSOR;", " \tif (maxlen < len || len == 0) {", " \t\t*p = start + 2;", " \t\treturn 0;", " \t}", " ", " \tstr = (char*)YYCURSOR;", " ", " \tYYCURSOR += len;", " ", " \tif (*(YYCURSOR) != '\"') {", " \t\t*p = YYCURSOR;", " \t\treturn 0;", " \t}", " \tif (*(YYCURSOR+1) != ':') {", " \t\t*p = YYCURSOR+1;", " \t\treturn 0;", " \t}", " ", " \tlen3 = strspn(str, \"0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\\");", " \tif (len3 != len)", " \t{", " \t\t*p = YYCURSOR + len3 - len;", " \t\treturn 0;", " \t}", " ", " \tclass_name = zend_string_init(str, len, 0);", " ", " \tdo {", " \t\tif(!unserialize_allowed_class(class_name, classes)) {", " \t\t\tincomplete_class = 1;", " \t\t\tce = PHP_IC_ENTRY;", " \t\t\tbreak;", " \t\t}", " ", " \t\t ", " \t\tBG(serialize_lock)++;", " \t\tce = zend_lookup_class(class_name);", " \t\tif (ce) {", " \t\t\tBG(serialize_lock)--;", " \t\t\tif (EG(exception)) {", " \t\t\t\tzend_string_release(class_name);", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tBG(serialize_lock)--;", " ", " \t\tif (EG(exception)) {", " \t\t\tzend_string_release(class_name);", " \t\t\treturn 0;", " \t\t}", " ", " \t\t ", " \t\tif ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0')) {", " \t\t\tincomplete_class = 1;", " \t\t\tce = PHP_IC_ENTRY;", " \t\t\tbreak;", " \t\t}", " ", " \t\t ", " \t\tZVAL_STRING(&user_func, PG(unserialize_callback_func));", " ", " \t\tZVAL_STR_COPY(&args[0], class_name);", " \t\tBG(serialize_lock)++;", " \t\tif (call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL) != SUCCESS) {", " \t\t\tBG(serialize_lock)--;", " \t\t\tif (EG(exception)) {", " \t\t\t\tzend_string_release(class_name);", " \t\t\t\tzval_ptr_dtor(&user_func);", " \t\t\t\tzval_ptr_dtor(&args[0]);", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\tphp_error_docref(NULL, E_WARNING, \"defined (%s) but not found\", Z_STRVAL(user_func));", " \t\t\tincomplete_class = 1;", " \t\t\tce = PHP_IC_ENTRY;", " \t\t\tzval_ptr_dtor(&user_func);", " \t\t\tzval_ptr_dtor(&args[0]);", " \t\t\tbreak;", " \t\t}", " \t\tBG(serialize_lock)--;", " \t\tzval_ptr_dtor(&retval);", " \t\tif (EG(exception)) {", " \t\t\tzend_string_release(class_name);", " \t\t\tzval_ptr_dtor(&user_func);", " \t\t\tzval_ptr_dtor(&args[0]);", " \t\t\treturn 0;", " \t\t}", " ", " \t\t ", " \t\tif ((ce = zend_lookup_class(class_name)) == NULL) {", " \t\t\tphp_error_docref(NULL, E_WARNING, \"Function %s() hasn't defined the class it was called for\", Z_STRVAL(user_func));", " \t\t\tincomplete_class = 1;", " \t\t\tce = PHP_IC_ENTRY;", " \t\t}", " ", " \t\tzval_ptr_dtor(&user_func);", " \t\tzval_ptr_dtor(&args[0]);", " \t\tbreak;", " \t} while (1);", " ", " \t*p = YYCURSOR;", " ", " \tif (custom_object) {", " \t\tint ret;", " ", " \t\tret = object_custom(UNSERIALIZE_PASSTHRU, ce);", " ", " \t\tif (ret && incomplete_class) {", " \t\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);", " \t\t}", " \t\tzend_string_release(class_name);", " \t\treturn ret;", " \t}", " ", " \telements = object_common1(UNSERIALIZE_PASSTHRU, ce);", " ", " \tif (incomplete_class) {", " \t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);", " \t}", " \tzend_string_release(class_name);", "  ", "  \treturn object_common2(UNSERIALIZE_PASSTHRU, elements);", "  }", "#line 804 \"ext/standard/var_unserializer.c\"", " #line 805 \"ext/standard/var_unserializer.c\"", "  yy25:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= ',') {", " \t\tif (yych != '+') goto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy26;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy27;", " \t\tgoto yy18;", " \t}", " yy26:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy27:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy27;", " \tif (yych >= ';') goto yy18;", " \tyych = *++YYCURSOR;", " \tif (yych != '\"') goto yy18;", " \t++YYCURSOR;", " #line 726 \"ext/standard/var_unserializer.re\"", " \t{", "     if (!var_hash) return 0;", " ", "  \treturn object_common2(UNSERIALIZE_PASSTHRU,", "  \t\t\tobject_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));", "  }", "#line 836 \"ext/standard/var_unserializer.c\"", " #line 837 \"ext/standard/var_unserializer.c\"", "  yy32:", "  \tyych = *++YYCURSOR;", "  \tif (yych == '+') goto yy33;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy34;", " \tgoto yy18;", " yy33:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy34:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy34;", " \tif (yych >= ';') goto yy18;", " \tyych = *++YYCURSOR;", " \tif (yych != '{') goto yy18;", " \t++YYCURSOR;", " #line 702 \"ext/standard/var_unserializer.re\"", " \t{", " \tzend_long elements = parse_iv(start + 2);", " \t ", " \t*p = YYCURSOR;", "     if (!var_hash) return 0;", " ", " \tif (elements < 0) {", " \t\treturn 0;", " \t}", " ", " \tarray_init_size(rval, elements);", " \tif (elements) {", " \t\t ", " \t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);", " \t}", " ", " \tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {", " \t\treturn 0;", " \t}", "  ", "  \treturn finish_nested_data(UNSERIALIZE_PASSTHRU);", "  }", "#line 881 \"ext/standard/var_unserializer.c\"", " #line 882 \"ext/standard/var_unserializer.c\"", "  yy39:", "  \tyych = *++YYCURSOR;", "  \tif (yych == '+') goto yy40;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy41;", " \tgoto yy18;", " yy40:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy41:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy41;", " \tif (yych >= ';') goto yy18;", " \tyych = *++YYCURSOR;", " \tif (yych != '\"') goto yy18;", " \t++YYCURSOR;", " #line 668 \"ext/standard/var_unserializer.re\"", " \t{", " \tsize_t len, maxlen;", " \tzend_string *str;", " ", " \tlen = parse_uiv(start + 2);", " \tmaxlen = max - YYCURSOR;", " \tif (maxlen < len) {", " \t\t*p = start + 2;", " \t\treturn 0;", " \t}", " ", " \tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {", " \t\treturn 0;", " \t}", " ", " \tif (*(YYCURSOR) != '\"') {", " \t\tzend_string_free(str);", " \t\t*p = YYCURSOR;", " \t\treturn 0;", " \t}", " ", " \tif (*(YYCURSOR + 1) != ';') {", " \t\tefree(str);", " \t\t*p = YYCURSOR + 1;", " \t\treturn 0;", " \t}", " ", " \tYYCURSOR += 2;", " \t*p = YYCURSOR;", " ", "  \tZVAL_STR(rval, str);", "  \treturn 1;", "  }", "#line 936 \"ext/standard/var_unserializer.c\"", " #line 937 \"ext/standard/var_unserializer.c\"", "  yy46:", "  \tyych = *++YYCURSOR;", "  \tif (yych == '+') goto yy47;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy48;", " \tgoto yy18;", " yy47:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy48:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy48;", " \tif (yych >= ';') goto yy18;", " \tyych = *++YYCURSOR;", " \tif (yych != '\"') goto yy18;", " \t++YYCURSOR;", " #line 636 \"ext/standard/var_unserializer.re\"", " \t{", " \tsize_t len, maxlen;", " \tchar *str;", " ", " \tlen = parse_uiv(start + 2);", " \tmaxlen = max - YYCURSOR;", " \tif (maxlen < len) {", " \t\t*p = start + 2;", " \t\treturn 0;", " \t}", " ", " \tstr = (char*)YYCURSOR;", " ", " \tYYCURSOR += len;", " ", " \tif (*(YYCURSOR) != '\"') {", " \t\t*p = YYCURSOR;", " \t\treturn 0;", " \t}", " ", " \tif (*(YYCURSOR + 1) != ';') {", " \t\t*p = YYCURSOR + 1;", " \t\treturn 0;", " \t}", " ", " \tYYCURSOR += 2;", " \t*p = YYCURSOR;", " ", "  \tZVAL_STRINGL(rval, str, len);", "  \treturn 1;", "  }", "#line 989 \"ext/standard/var_unserializer.c\"", " #line 990 \"ext/standard/var_unserializer.c\"", "  yy53:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= '/') {", " \t\tif (yych <= ',') {", " \t\t\tif (yych == '+') goto yy57;", " \t\t\tgoto yy18;", " \t\t} else {", " \t\t\tif (yych <= '-') goto yy55;", " \t\t\tif (yych <= '.') goto yy60;", " \t\t\tgoto yy18;", " \t\t}", " \t} else {", " \t\tif (yych <= 'I') {", " \t\t\tif (yych <= '9') goto yy58;", " \t\t\tif (yych <= 'H') goto yy18;", " \t\t\tgoto yy56;", " \t\t} else {", " \t\t\tif (yych != 'N') goto yy18;", " \t\t}", " \t}", " \tyych = *++YYCURSOR;", " \tif (yych == 'A') goto yy76;", " \tgoto yy18;", " yy55:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') {", " \t\tif (yych == '.') goto yy60;", " \t\tgoto yy18;", " \t} else {", " \t\tif (yych <= '9') goto yy58;", " \t\tif (yych != 'I') goto yy18;", " \t}", " yy56:", " \tyych = *++YYCURSOR;", " \tif (yych == 'N') goto yy72;", " \tgoto yy18;", " yy57:", " \tyych = *++YYCURSOR;", " \tif (yych == '.') goto yy60;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy58:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);", " \tyych = *YYCURSOR;", " \tif (yych <= ':') {", " \t\tif (yych <= '.') {", " \t\t\tif (yych <= '-') goto yy18;", " \t\t\tgoto yy70;", " \t\t} else {", " \t\t\tif (yych <= '/') goto yy18;", " \t\t\tif (yych <= '9') goto yy58;", " \t\t\tgoto yy18;", " \t\t}", " \t} else {", " \t\tif (yych <= 'E') {", " \t\t\tif (yych <= ';') goto yy63;", " \t\t\tif (yych <= 'D') goto yy18;", " \t\t\tgoto yy65;", " \t\t} else {", " \t\t\tif (yych == 'e') goto yy65;", " \t\t\tgoto yy18;", " \t\t}", " \t}", " yy60:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy61:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);", " \tyych = *YYCURSOR;", " \tif (yych <= ';') {", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy61;", " \t\tif (yych <= ':') goto yy18;", " \t} else {", " \t\tif (yych <= 'E') {", " \t\t\tif (yych <= 'D') goto yy18;", " \t\t\tgoto yy65;", " \t\t} else {", " \t\t\tif (yych == 'e') goto yy65;", " \t\t\tgoto yy18;", " \t\t}", " \t}", " yy63:", " \t++YYCURSOR;", " #line 627 \"ext/standard/var_unserializer.re\"", " \t{", " #if SIZEOF_ZEND_LONG == 4", " use_double:", " #endif", " \t*p = YYCURSOR;", "  \tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));", "  \treturn 1;", "  }", "#line 1086 \"ext/standard/var_unserializer.c\"", " #line 1087 \"ext/standard/var_unserializer.c\"", "  yy65:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= ',') {", " \t\tif (yych != '+') goto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy66;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy67;", " \t\tgoto yy18;", " \t}", " yy66:", " \tyych = *++YYCURSOR;", " \tif (yych <= ',') {", " \t\tif (yych == '+') goto yy69;", " \t\tgoto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy69;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych >= ':') goto yy18;", " \t}", " yy67:", " \t++YYCURSOR;", " \tif (YYLIMIT <= YYCURSOR) YYFILL(1);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy67;", " \tif (yych == ';') goto yy63;", " \tgoto yy18;", " yy69:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy67;", " \tgoto yy18;", " yy70:", " \t++YYCURSOR;", " \tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);", " \tyych = *YYCURSOR;", " \tif (yych <= ';') {", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy70;", " \t\tif (yych <= ':') goto yy18;", " \t\tgoto yy63;", " \t} else {", " \t\tif (yych <= 'E') {", " \t\t\tif (yych <= 'D') goto yy18;", " \t\t\tgoto yy65;", " \t\t} else {", " \t\t\tif (yych == 'e') goto yy65;", " \t\t\tgoto yy18;", " \t\t}", " \t}", " yy72:", " \tyych = *++YYCURSOR;", " \tif (yych != 'F') goto yy18;", " yy73:", " \tyych = *++YYCURSOR;", " \tif (yych != ';') goto yy18;", " \t++YYCURSOR;", " #line 611 \"ext/standard/var_unserializer.re\"", " \t{", " \t*p = YYCURSOR;", " ", " \tif (!strncmp((char*)start + 2, \"NAN\", 3)) {", " \t\tZVAL_DOUBLE(rval, php_get_nan());", " \t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {", " \t\tZVAL_DOUBLE(rval, php_get_inf());", " \t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {", " \t\tZVAL_DOUBLE(rval, -php_get_inf());", " \t} else {", " \t\tZVAL_NULL(rval);", " \t}", "  ", "  \treturn 1;", "  }", "#line 1161 \"ext/standard/var_unserializer.c\"", " #line 1162 \"ext/standard/var_unserializer.c\"", "  yy76:", "  \tyych = *++YYCURSOR;", "  \tif (yych == 'N') goto yy73;", " \tgoto yy18;", " yy77:", " \tyych = *++YYCURSOR;", " \tif (yych <= ',') {", " \t\tif (yych != '+') goto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy78;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy79;", " \t\tgoto yy18;", " \t}", " yy78:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy79:", " \t++YYCURSOR;", " \tif (YYLIMIT <= YYCURSOR) YYFILL(1);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy79;", " \tif (yych != ';') goto yy18;", " \t++YYCURSOR;", " #line 585 \"ext/standard/var_unserializer.re\"", " \t{", " #if SIZEOF_ZEND_LONG == 4", " \tint digits = YYCURSOR - start - 3;", " ", " \tif (start[2] == '-' || start[2] == '+') {", " \t\tdigits--;", " \t}", " ", " \t ", " \tif (digits >= MAX_LENGTH_OF_LONG - 1) {", " \t\tif (digits == MAX_LENGTH_OF_LONG - 1) {", " \t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);", " ", " \t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {", " \t\t\t\tgoto use_double;", " \t\t\t}", " \t\t} else {", " \t\t\tgoto use_double;", " \t\t}", " \t}", " #endif", " \t*p = YYCURSOR;", "  \tZVAL_LONG(rval, parse_iv(start + 2));", "  \treturn 1;", "  }", "#line 1214 \"ext/standard/var_unserializer.c\"", " #line 1215 \"ext/standard/var_unserializer.c\"", "  yy83:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= '/') goto yy18;", " \tif (yych >= '2') goto yy18;", " \tyych = *++YYCURSOR;", " \tif (yych != ';') goto yy18;", " \t++YYCURSOR;", " #line 579 \"ext/standard/var_unserializer.re\"", " \t{", " \t*p = YYCURSOR;", "  \tZVAL_BOOL(rval, parse_iv(start + 2));", "  \treturn 1;", "  }", "#line 1228 \"ext/standard/var_unserializer.c\"", " #line 1229 \"ext/standard/var_unserializer.c\"", "  yy87:", "  \t++YYCURSOR;", "  #line 573 \"ext/standard/var_unserializer.re\"", " \t{", " \t*p = YYCURSOR;", "  \tZVAL_NULL(rval);", "  \treturn 1;", "  }", "#line 1237 \"ext/standard/var_unserializer.c\"", " #line 1238 \"ext/standard/var_unserializer.c\"", "  yy89:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= ',') {", " \t\tif (yych != '+') goto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy90;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy91;", " \t\tgoto yy18;", " \t}", " yy90:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy91:", " \t++YYCURSOR;", " \tif (YYLIMIT <= YYCURSOR) YYFILL(1);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy91;", " \tif (yych != ';') goto yy18;", " \t++YYCURSOR;", " #line 548 \"ext/standard/var_unserializer.re\"", " \t{", " \tzend_long id;", " ", "  \t*p = YYCURSOR;", " \tif (!var_hash) return 0;", " ", " \tid = parse_iv(start + 2) - 1;", " \tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {", " \t\treturn 0;", " \t}", " ", " \tif (rval_ref == rval) {", " \t\treturn 0;", " \t}", " ", " \tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {", " \t\tZVAL_UNDEF(rval);", " \t\treturn 1;", " \t}", " ", " \tZVAL_COPY(rval, rval_ref);", "  ", "  \treturn 1;", "  }", "#line 1285 \"ext/standard/var_unserializer.c\"", " #line 1286 \"ext/standard/var_unserializer.c\"", "  yy95:", "  \tyych = *++YYCURSOR;", "  \tif (yych <= ',') {", " \t\tif (yych != '+') goto yy18;", " \t} else {", " \t\tif (yych <= '-') goto yy96;", " \t\tif (yych <= '/') goto yy18;", " \t\tif (yych <= '9') goto yy97;", " \t\tgoto yy18;", " \t}", " yy96:", " \tyych = *++YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych >= ':') goto yy18;", " yy97:", " \t++YYCURSOR;", " \tif (YYLIMIT <= YYCURSOR) YYFILL(1);", " \tyych = *YYCURSOR;", " \tif (yych <= '/') goto yy18;", " \tif (yych <= '9') goto yy97;", " \tif (yych != ';') goto yy18;", " \t++YYCURSOR;", " #line 522 \"ext/standard/var_unserializer.re\"", " \t{", " \tzend_long id;", " ", "  \t*p = YYCURSOR;", " \tif (!var_hash) return 0;", " ", " \tid = parse_iv(start + 2) - 1;", " \tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {", " \t\treturn 0;", " \t}", " ", " \tzval_ptr_dtor(rval);", " \tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {", " \t\tZVAL_UNDEF(rval);", " \t\treturn 1;", " \t}", " \tif (Z_ISREF_P(rval_ref)) {", " \t\tZVAL_COPY(rval, rval_ref);", " \t} else {", " \t\tZVAL_NEW_REF(rval_ref, rval_ref);", " \t\tZVAL_COPY(rval, rval_ref);", " \t}", "  ", "  \treturn 1;", "  }", "#line 1334 \"ext/standard/var_unserializer.c\"", " #line 1335 \"ext/standard/var_unserializer.c\"", "  }", "  #line 886 \"ext/standard/var_unserializer.re\"", "  ", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)", " {", "     struct net_device *dev;", "     struct ar_virtual_interface *arApDev;", " ", "     dev = alloc_etherdev(sizeof(struct ar_virtual_interface));", "     if (dev == NULL) {", "         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));", "         return A_ERROR;", "     } ", "      ", "      ether_setup(dev);", "      init_netdev(dev, ap_ifname);", "     dev->priv_flags &= ~IFF_TX_SKB_SHARING;", "  ", "      if (register_netdev(dev)) {", "          AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));", "         return A_ERROR;", "     }", " ", "     arApDev = netdev_priv(dev);", "     arApDev->arDev = ar;", "     arApDev->arNetDev = dev;", "     arApDev->arStaNetDev = ar->arNetDev;", " ", "     ar->arApDev = arApDev;", "     arApNetDev = dev;", " ", "      ", "     memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" char *my_asctime(time_t t)", " {", " \tstruct tm *tm;", " \tchar *str;", "          int len;", "  ", "  \ttm = localtime(&t);", " \tif (tm == NULL)", " \t    return g_strdup(\"???\");", " ", "  \tstr = g_strdup(asctime(tm));", "  ", "  \tlen = strlen(str);", " \tif (len > 0) str[len-1] = '\\0';", "         return str;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    void CallCompositorWithSuccess(mojom::PdfCompositorPtr ptr) {", "      auto handle = CreateMSKPInSharedMemory();", "      ASSERT_TRUE(handle.IsValid());", "    mojo::ScopedSharedBufferHandle buffer_handle =", "        mojo::WrapSharedMemoryHandle(handle, handle.GetSize(), true);", "     mojo::ScopedSharedBufferHandle buffer_handle = mojo::WrapSharedMemoryHandle(", "         handle, handle.GetSize(),", "         mojo::UnwrappedSharedMemoryHandleProtection::kReadOnly);", "      ASSERT_TRUE(buffer_handle->is_valid());", "      EXPECT_CALL(*this, CallbackOnSuccess(testing::_)).Times(1);", "      ptr->CompositePdf(std::move(buffer_handle),", "                       base::BindOnce(&PdfCompositorServiceTest::OnCallback,", "                                      base::Unretained(this)));", "     run_loop_->Run();", "   }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int blkcg_init_queue(struct request_queue *q)", " {", " \tstruct blkcg_gq *new_blkg, *blkg;", " \tbool preloaded;", " \tint ret;", " ", " \tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);", " \tif (!new_blkg)", " \t\treturn -ENOMEM;", " ", " \tpreloaded = !radix_tree_preload(GFP_KERNEL);", " ", " \t ", " \trcu_read_lock();", " \tspin_lock_irq(q->queue_lock);", " \tblkg = blkg_create(&blkcg_root, q, new_blkg);", " \tspin_unlock_irq(q->queue_lock);", " \trcu_read_unlock();", " ", "  \tif (preloaded)", "  \t\tradix_tree_preload_end();", "  ", "\tif (IS_ERR(blkg)) {", "\t\tblkg_free(new_blkg);", " \tif (IS_ERR(blkg))", "  \t\treturn PTR_ERR(blkg);", "\t}", "  ", "  \tq->root_blkg = blkg;", "  \tq->root_rl.blkg = blkg;", " ", " \tret = blk_throtl_init(q);", " \tif (ret) {", " \t\tspin_lock_irq(q->queue_lock);", " \t\tblkg_destroy_all(q);", " \t\tspin_unlock_irq(q->queue_lock);", " \t}", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void request_key_auth_describe(const struct key *key,", " \t\t\t\t      struct seq_file *m)", " {", " \tstruct request_key_auth *rka = key->payload.data[0];", "  ", "  \tseq_puts(m, \"key:\");", "  \tseq_puts(m, key->description);", "\tif (key_is_instantiated(key))", " \tif (key_is_positive(key))", "  \t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["mptctl_replace_fw (unsigned long arg)", "{", "struct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;", "struct mpt_ioctl_replace_fw  karg;", "MPT_ADAPTER   *ioc;", "int    iocnum;", "int    newFwSize;", "", "if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {", "printk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"", "\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",", "__FILE__, __LINE__, uarg);", "return -EFAULT;", "}", "", "if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||", "(ioc == NULL)) {", "printk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",", "__FILE__, __LINE__, iocnum);", "return -ENODEV;", "}", "", "dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",", "ioc->name));", "", "", "if (ioc->cached_fw == NULL)", "return 0;", "", "mpt_free_fw_memory(ioc);", "", "", "", "newFwSize = ALIGN(karg.newImageSize, 4);", "", "mpt_alloc_fw_memory(ioc, newFwSize);", "if (ioc->cached_fw == NULL)", "return -ENOMEM;", "", "", "", "if (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {", "printk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"", "\"Unable to read in mpt_ioctl_replace_fw image \"", "\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);", "mpt_free_fw_memory(ioc);", "return -EFAULT;", "}", "", "", "", "ioc->facts.FWImageSize = newFwSize;", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int bad_format_imginfo(", "char *fmt)", "{", "char     *ptr;", "int       n = 0;", "", "ptr = fmt;", "while (*ptr != '\\0')", "if (*ptr++ == '%') {", "", "", "if (*ptr == '\\0')", "return 1;", "", "if (*ptr == '%')", "ptr++;", "", "else if (*ptr == 's' || *ptr == 'S') {", "n = 1;", "ptr++;", "}", "", "", "else {", "", "if (*ptr == ' ')", "ptr++;", "", "while (*ptr >= '0' && *ptr <= '9')", "ptr++;", "", "if (*ptr++ != 'l')", "return 1;", "if (*ptr == 'u')", "ptr++;", "else", "return 1;", "n++;", "}", "}", "", "return (n != 3);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)", " {", "      int i;", "      VncDisplay *vd = ds->opaque;", "      struct VncSurface *s = &vd->guest;", "     int width = ds_get_width(ds);", "     int height = ds_get_height(ds);", "  ", "      h += y;", "  ", "        two 16-pixel blocks but we only mark the first as dirty", "     */", "     w += (x % 16);", "     x -= (x % 16);", "      w += (x % 16);", "      x -= (x % 16);", "  ", "    x = MIN(x, s->ds->width);", "    y = MIN(y, s->ds->height);", "    w = MIN(x + w, s->ds->width) - x;", "    h = MIN(h, s->ds->height);", "     x = MIN(x, width);", "     y = MIN(y, height);", "     w = MIN(x + w, width) - x;", "     h = MIN(h, height);", "  ", "      for (; y < h; y++)", "          for (i = 0; i < w; i += 16)", " ", " void vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,", "                             int32_t encoding)", " {", "     vnc_write_u16(vs, x);", "     vnc_write_u16(vs, y);", "     vnc_write_u16(vs, w);", "     vnc_write_u16(vs, h);", " ", "     vnc_write_s32(vs, encoding);", " }", " ", " void buffer_reserve(Buffer *buffer, size_t len)", " {", "     if ((buffer->capacity - buffer->offset) < len) {", "         buffer->capacity += (len + 1024);", "         buffer->buffer = g_realloc(buffer->buffer, buffer->capacity);", "         if (buffer->buffer == NULL) {", "             fprintf(stderr, \"vnc: out of memory\\n\");", "             exit(1);", "         }", "     }", " }", " ", " int buffer_empty(Buffer *buffer)", " {", "     return buffer->offset == 0;", " }", " ", " uint8_t *buffer_end(Buffer *buffer)", " {", "     return buffer->buffer + buffer->offset;", " }", " ", " void buffer_reset(Buffer *buffer)", " {", "         buffer->offset = 0;", " }", " ", " void buffer_free(Buffer *buffer)", " {", "     g_free(buffer->buffer);", "     buffer->offset = 0;", "     buffer->capacity = 0;", "     buffer->buffer = NULL;", " }", " ", " void buffer_append(Buffer *buffer, const void *data, size_t len)", " {", "     memcpy(buffer->buffer + buffer->offset, data, len);", "     buffer->offset += len;", " }", " ", " static void vnc_desktop_resize(VncState *vs)", " {", "     DisplayState *ds = vs->ds;", " ", "     if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {", "         return;", "     }", "     if (vs->client_width == ds_get_width(ds) &&", "         vs->client_height == ds_get_height(ds)) {", "         return;", "     }", "     vs->client_width = ds_get_width(ds);", "     vs->client_height = ds_get_height(ds);", "     vnc_lock_output(vs);", "     vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);", "     vnc_write_u8(vs, 0);", "     vnc_write_u16(vs, 1);  ", "     vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,", "                            VNC_ENCODING_DESKTOPRESIZE);", "     vnc_unlock_output(vs);", "     vnc_flush(vs);", " }", " ", " static void vnc_abort_display_jobs(VncDisplay *vd)", " {", "     VncState *vs;", " ", "     QTAILQ_FOREACH(vs, &vd->clients, next) {", "         vnc_lock_output(vs);", "         vs->abort = true;", "         vnc_unlock_output(vs);", "     }", "     QTAILQ_FOREACH(vs, &vd->clients, next) {", "         vnc_jobs_join(vs);", "     }", "     QTAILQ_FOREACH(vs, &vd->clients, next) {", "         vnc_lock_output(vs);", "         vs->abort = false;", "         vnc_unlock_output(vs);", "     }", " }", "      }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)", " {", " \tstruct perf_event_context *src_ctx;", " \tstruct perf_event_context *dst_ctx;", " \tstruct perf_event *event, *tmp;", " \tLIST_HEAD(events);", " ", "  \tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;", "  \tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;", "  ", "\tmutex_lock(&src_ctx->mutex);", " \t ", " \tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);", "  \tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,", "  \t\t\t\t event_entry) {", "  \t\tperf_remove_from_context(event, false);", "  \t\tunaccount_event_cpu(event, src_cpu);", "  \t\tput_ctx(src_ctx);", "  \t\tlist_add(&event->migrate_entry, &events);", "  \t}", "\tmutex_unlock(&src_ctx->mutex);", "  ", "  \tsynchronize_rcu();", "  ", "\tmutex_lock(&dst_ctx->mutex);", "  \tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {", "  \t\tlist_del(&event->migrate_entry);", "  \t\tif (event->state >= PERF_EVENT_STATE_OFF)", " \t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;", " \t\taccount_event_cpu(event, dst_cpu);", " \t\tperf_install_in_context(dst_ctx, event, dst_cpu);", "  \t\tget_ctx(dst_ctx);", "  \t}", "  \tmutex_unlock(&dst_ctx->mutex);", " \tmutex_unlock(&src_ctx->mutex);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)", "  {", "  \tstruct snd_ctl_elem_id id;", "  \tunsigned int idx;", " \tunsigned int count;", "  \tint err = -EINVAL;", "  ", "  \tif (! kcontrol)", " \t\treturn err;", " \tif (snd_BUG_ON(!card || !kcontrol->info))", " \t\tgoto error;", " \tid = kcontrol->id;", " \tdown_write(&card->controls_rwsem);", " \tif (snd_ctl_find_id(card, &id)) {", " \t\tup_write(&card->controls_rwsem);", " \t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",", " \t\t\t\t\tid.iface,", " \t\t\t\t\tid.device,", " \t\t\t\t\tid.subdevice,", " \t\t\t\t\tid.name,", " \t\t\t\t\tid.index);", " \t\terr = -EBUSY;", " \t\tgoto error;", " \t}", " \tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {", " \t\tup_write(&card->controls_rwsem);", " \t\terr = -ENOMEM;", " \t\tgoto error;", " \t}", " \tlist_add_tail(&kcontrol->list, &card->controls);", "  \tcard->controls_count += kcontrol->count;", "  \tkcontrol->id.numid = card->last_numid + 1;", "  \tcard->last_numid += kcontrol->count;", " \tcount = kcontrol->count;", "  \tup_write(&card->controls_rwsem);", "\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)", " \tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)", "  \t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);", "  \treturn 0;", "  ", "  error:", " \tsnd_ctl_free_one(kcontrol);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool InputMethodController::FinishComposingText(", "     ConfirmCompositionBehavior confirm_behavior) {", "   if (!HasComposition())", "     return false;", " ", "   const bool is_too_long = IsTextTooLongAt(composition_range_->StartPosition());", " ", "   const String& composing = ComposingText();", " ", "   if (confirm_behavior == kKeepSelection) {", "     const bool is_handle_visible = GetFrame().Selection().IsHandleVisible();", " ", "     const PlainTextRange& old_offsets = GetSelectionOffsets();", "     Editor::RevealSelectionScope reveal_selection_scope(&GetEditor());", " ", "     if (is_too_long) {", "       ReplaceComposition(ComposingText());", "     } else {", "       Clear();", "       DispatchCompositionEndEvent(GetFrame(), composing);", "     }", " ", "     GetDocument().UpdateStyleAndLayoutIgnorePendingStylesheets();", " ", "     const EphemeralRange& old_selection_range =", "         EphemeralRangeForOffsets(old_offsets);", "     if (old_selection_range.IsNull())", "       return false;", "      const SelectionInDOMTree& selection =", "          SelectionInDOMTree::Builder()", "              .SetBaseAndExtent(old_selection_range)", "            .SetIsHandleVisible(is_handle_visible)", "              .Build();", "      GetFrame().Selection().SetSelection(", "        selection,", "        SetSelectionData::Builder().SetShouldCloseTyping(true).Build());", "         selection, SetSelectionData::Builder()", "                        .SetShouldCloseTyping(true)", "                        .SetShouldShowHandle(is_handle_visible)", "                        .Build());", "      return true;", "    }", "  ", "   Element* root_editable_element =", "       GetFrame()", "           .Selection()", "           .ComputeVisibleSelectionInDOMTreeDeprecated()", "           .RootEditableElement();", "   if (!root_editable_element)", "     return false;", "   PlainTextRange composition_range =", "       PlainTextRange::Create(*root_editable_element, *composition_range_);", "   if (composition_range.IsNull())", "     return false;", " ", "   if (is_too_long) {", "     ReplaceComposition(ComposingText());", "   } else {", "     Clear();", "   }", " ", "   if (!MoveCaret(composition_range.End()))", "     return false;", " ", "   DispatchCompositionEndEvent(GetFrame(), composing);", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {", " \tRBinInfo *info = r_bin_get_info (r->bin);", " \tRList *entries = r_bin_get_entries (r->bin);", " \tRBinSymbol *symbol;", " \tRBinAddr *entry;", " \tRListIter *iter;", " \tbool firstexp = true;", " \tbool printHere = false;", " \tint i = 0, lastfs = 's';", " \tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");", " \tif (!info) {", " \t\treturn 0;", " \t}", " ", " \tif (args && *args == '.') {", " \t\tprintHere = true;", " \t}", " ", " \tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);", " \tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;", " ", " \tRList *symbols = r_bin_get_symbols (r->bin);", " \tr_spaces_push (&r->anal->meta_spaces, \"bin\");", " ", " \tif (IS_MODE_JSON (mode) && !printHere) {", " \t\tr_cons_printf (\"[\");", " \t} else if (IS_MODE_SET (mode)) {", " \t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);", " \t} else if (!at && exponly) {", " \t\tif (IS_MODE_RAD (mode)) {", " \t\t\tr_cons_printf (\"fs exports\\n\");", " \t\t} else if (IS_MODE_NORMAL (mode)) {", " \t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");", " \t\t}", " \t} else if (!at && !exponly) {", " \t\tif (IS_MODE_RAD (mode)) {", " \t\t\tr_cons_printf (\"fs symbols\\n\");", " \t\t} else if (IS_MODE_NORMAL (mode)) {", " \t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");", " \t\t}", " \t}", " \tif (IS_MODE_NORMAL (mode)) {", " \t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");", " \t}", " ", " ", " \tsize_t count = 0;", " \tr_list_foreach (symbols, iter, symbol) {", " \t\tif (!symbol->name) {", " \t\t\tcontinue;", " \t\t}", " \t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);", " \t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);", " \t\tint len = symbol->size ? symbol->size : 32;", " \t\tSymName sn = {0};", " ", " \t\tif (exponly && !isAnExport (symbol)) {", " \t\t\tfree (r_symbol_name);", " \t\t\tcontinue;", " \t\t}", " \t\tif (name && strcmp (r_symbol_name, name)) {", " \t\t\tfree (r_symbol_name);", " \t\t\tcontinue;", " \t\t}", " \t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {", " \t\t\tfree (r_symbol_name);", " \t\t\tcontinue;", " \t\t}", " \t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))", " \t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {", " \t\t\tfree (r_symbol_name);", " \t\t\tcontinue;", " \t\t}", " \t\tcount ++;", " \t\tsnInit (r, &sn, symbol, lang);", " ", " \t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {", " \t\t\t ", " \t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {", " \t\t\tif (is_arm) {", " \t\t\t\thandle_arm_special_symbol (r, symbol, va);", " \t\t\t}", " \t\t} else if (IS_MODE_SET (mode)) {", " \t\t\tif (is_arm) {", " \t\t\t\thandle_arm_symbol (r, symbol, info, va);", " \t\t\t}", " \t\t\tselect_flag_space (r, symbol);", " \t\t\t ", " \t\t\tif (sn.classname) {", " \t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);", " \t\t\t\tif (r->bin->prefix) {", " \t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);", " \t\t\t\t\tr_name_filter (sn.methflag, -1);", " \t\t\t\t\tfree (sn.methflag);", " \t\t\t\t\tsn.methflag = prname;", " \t\t\t\t}", " \t\t\t\tif (fi) {", " \t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);", " \t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {", " \t\t\t\t\t\tr_flag_unset (r->flags, fi);", " \t\t\t\t\t}", " \t\t\t\t} else {", " \t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);", " \t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;", " \t\t\t\t\tif (comment) {", " \t\t\t\t\t\tr_flag_item_set_comment (fi, comment);", " \t\t\t\t\t\tR_FREE (comment);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t} else {", " \t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;", " \t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;", " \t\t\t\tchar *fnp = (r->bin->prefix) ?", " \t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):", " \t\t\t\t\tstrdup (fn);", " \t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);", " \t\t\t\tif (fi) {", " \t\t\t\t\tr_flag_item_set_realname (fi, n);", " \t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;", " \t\t\t\t} else {", " \t\t\t\t\tif (fn) {", " \t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tfree (fnp);", " \t\t\t}", " \t\t\tif (sn.demname) {", " \t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,", " \t\t\t\t\taddr, symbol->size, sn.demname);", " \t\t\t}", " \t\t\tr_flag_space_pop (r->flags);", " \t\t} else if (IS_MODE_JSON (mode)) {", " \t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);", " \t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"", " \t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"", " \t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"", " \t\t\t\t\"\\\"ordinal\\\":%d,\"", " \t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"", " \t\t\t\t\"\\\"size\\\":%d,\"", " \t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"", " \t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"", " \t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",", " \t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),", " \t\t\t\tstr,", " \t\t\t\tsn.demname? sn.demname: \"\",", " \t\t\t\tsn.nameflag,", " \t\t\t\tsymbol->ordinal,", " \t\t\t\tsymbol->bind,", " \t\t\t\t(int)symbol->size,", " \t\t\t\tsymbol->type,", " \t\t\t\t(ut64)addr, (ut64)symbol->paddr);", " \t\t\tfree (str);", " \t\t} else if (IS_MODE_SIMPLE (mode)) {", " \t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;", " \t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",", " \t\t\t\taddr, (int)symbol->size, name);", " \t\t} else if (IS_MODE_SIMPLEST (mode)) {", " \t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;", " \t\t\tr_cons_printf (\"%s\\n\", name);", " \t\t} else if (IS_MODE_RAD (mode)) {", " \t\t\t ", " \t\t\tif (is_special_symbol (symbol)) {", " \t\t\t\tgoto next;", " \t\t\t}", " \t\t\tRBinFile *binfile;", " \t\t\tRBinPlugin *plugin;", " \t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;", " \t\t\tif (!name) {", " \t\t\t\tgoto next;", " \t\t\t}", " \t\t\tif (!strncmp (name, \"imp.\", 4)) {", " \t\t\t\tif (lastfs != 'i') {", " \t\t\t\t\tr_cons_printf (\"fs imports\\n\");", " \t\t\t\t}", " \t\t\t\tlastfs = 'i';", " \t\t\t} else {", " \t\t\t\tif (lastfs != 's') {", " \t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";", " \t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);", " \t\t\t\t}", " \t\t\t\tlastfs = 's';", " \t\t\t}", " \t\t\tif (r->bin->prefix || *name) {  ", " \t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);", " \t\t\t\tif (!flagname) {", " \t\t\t\t\tgoto next;", " \t\t\t\t}", " \t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",", " \t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",", " \t\t\t\t\tflagname, symbol->size, addr);", " \t\t\t\tfree (flagname);", " \t\t\t}", " \t\t\tbinfile = r_bin_cur (r->bin);", " \t\t\tplugin = r_bin_file_cur_plugin (binfile);", " \t\t\tif (plugin && plugin->name) {", " \t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {", " \t\t\t\t\tchar *module = strdup (r_symbol_name);", " \t\t\t\t\tchar *p = strstr (module, \".dll_\");", " \t\t\t\t\tif (p && strstr (module, \"imp.\")) {", " \t\t\t\t\t\tchar *symname = __filterShell (p + 5);", "  \t\t\t\t\t\tchar *m = __filterShell (module);", "  \t\t\t\t\t\t*p = 0;", "  \t\t\t\t\t\tif (r->bin->prefix) {", "\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",", " \t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",", "  \t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);", "  \t\t\t\t\t\t} else {", "\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",", " \t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",", "  \t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);", "  \t\t\t\t\t\t}", "  \t\t\t\t\t\tfree (symname);", " \t\t\t\t\t\tfree (m);", " \t\t\t\t\t}", " \t\t\t\t\tfree (module);", " \t\t\t\t}", " \t\t\t}", " \t\t} else {", " \t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";", " \t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";", " \t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);", " \t\t\tr_cons_printf (\"%03u\", symbol->ordinal);", " \t\t\tif (symbol->paddr == UT64_MAX) {", " \t\t\t\tr_cons_printf (\" ----------\");", " \t\t\t} else {", " \t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);", " \t\t\t}", " \t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",", " \t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);", " \t\t}", " next:", " \t\tsnFini (&sn);", " \t\ti++;", " \t\tfree (r_symbol_name);", " \t\tif (exponly && firstexp) {", " \t\t\tfirstexp = false;", " \t\t}", " \t\tif (printHere) {", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (count == 0 && IS_MODE_JSON (mode)) {", " \t\tr_cons_printf (\"{}\");", " \t}", " ", " ", " \tif (is_arm) {", " \t\tr_list_foreach (entries, iter, entry) {", " \t\t\tif (IS_MODE_SET (mode)) {", " \t\t\t\thandle_arm_entry (r, entry, info, va);", " \t\t\t}", " \t\t}", " \t}", " \tif (IS_MODE_JSON (mode) && !printHere) {", " \t\tr_cons_printf (\"]\");", " \t}", " ", " \tr_spaces_pop (&r->anal->meta_spaces);", " \treturn true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   InternalWebIntentsDispatcherTest() {", "    replied_ = 0;", "   InternalWebIntentsDispatcherTest()", "       : replied_(0),", "         notified_reply_type_(webkit_glue::WEB_INTENT_REPLY_INVALID) {", "    }"], "ner_tags": [0, 1, 1, 1, 1, 0]}
{"tokens": ["  void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {", "    if (SessionByClient(client))", "      return;", "  InnerAttachClient(client);", "   InnerAttachClient(client, false  );", " }", " ", " bool DevToolsAgentHostImpl::AttachRestrictedClient(", "     DevToolsAgentHostClient* client) {", "   if (SessionByClient(client))", "     return false;", "   return InnerAttachClient(client, true  );", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["   PepperDeviceEnumerationHostHelperTest()", "        : ppapi_host_(&sink_, ppapi::PpapiPermissions()),", "          resource_host_(&ppapi_host_, 12345, 67890),", "          device_enumeration_(&resource_host_,", "                            &delegate_,", "                             delegate_.AsWeakPtr(),", "                              PP_DEVICETYPE_DEV_AUDIOCAPTURE,", "                              GURL(\"http:example.com\")) {}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" long long Block::GetTrackNumber() const", "{", "    return m_track;", " bool Block::IsKey() const {", "   return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);", "  }"], "ner_tags": [0, 1, 1, 1, 1, 0]}
{"tokens": [" PHP_METHOD(Phar, webPhar)", " {", " \tzval *mimeoverride = NULL, *rewrite = NULL;", " \tchar *alias = NULL, *error, *index_php = NULL, *f404 = NULL, *ru = NULL;", " \tint alias_len = 0, ret, f404_len = 0, free_pathinfo = 0, ru_len = 0;", " \tchar *fname, *path_info, *mime_type = NULL, *entry, *pt;", " \tconst char *basename;", " \tint fname_len, entry_len, code, index_php_len = 0, not_cgi;", " \tphar_archive_data *phar = NULL;", " \tphar_entry_info *info = NULL;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!s!saz\", &alias, &alias_len, &index_php, &index_php_len, &f404, &f404_len, &mimeoverride, &rewrite) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tphar_request_initialize(TSRMLS_C);", " \tfname = (char*)zend_get_executed_filename(TSRMLS_C);", " \tfname_len = strlen(fname);", " ", " \tif (phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) != SUCCESS) {", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\t\tefree(error);", " \t\t}", " \t\treturn;", " \t}", " ", " \t ", " \tif (!(SG(request_info).request_method && SG(request_info).request_uri && (!strcmp(SG(request_info).request_method, \"GET\") || !strcmp(SG(request_info).request_method, \"POST\")))) {", " \t\treturn;", " \t}", " ", " #ifdef PHP_WIN32", " \tfname = estrndup(fname, fname_len);", " \tphar_unixify_path_separators(fname, fname_len);", " #endif", " \tbasename = zend_memrchr(fname, '/', fname_len);", " ", " \tif (!basename) {", " \t\tbasename = fname;", " \t} else {", " \t\t++basename;", " \t}", " ", " \tif ((strlen(sapi_module.name) == sizeof(\"cgi-fcgi\")-1 && !strncmp(sapi_module.name, \"cgi-fcgi\", sizeof(\"cgi-fcgi\")-1))", " \t\t|| (strlen(sapi_module.name) == sizeof(\"fpm-fcgi\")-1 && !strncmp(sapi_module.name, \"fpm-fcgi\", sizeof(\"fpm-fcgi\")-1))", " \t\t|| (strlen(sapi_module.name) == sizeof(\"cgi\")-1 && !strncmp(sapi_module.name, \"cgi\", sizeof(\"cgi\")-1))) {", " ", " \t\tif (PG(http_globals)[TRACK_VARS_SERVER]) {", " \t\t\tHashTable *_server = Z_ARRVAL_P(PG(http_globals)[TRACK_VARS_SERVER]);", " \t\t\tzval **z_script_name, **z_path_info;", " ", " \t\t\tif (SUCCESS != zend_hash_find(_server, \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\"), (void**)&z_script_name) ||", " \t\t\t\tIS_STRING != Z_TYPE_PP(z_script_name) ||", " \t\t\t\t!strstr(Z_STRVAL_PP(z_script_name), basename)) {", " \t\t\t\treturn;", " \t\t\t}", " ", " \t\t\tif (SUCCESS == zend_hash_find(_server, \"PATH_INFO\", sizeof(\"PATH_INFO\"), (void**)&z_path_info) &&", " \t\t\t\tIS_STRING == Z_TYPE_PP(z_path_info)) {", " \t\t\t\tentry_len = Z_STRLEN_PP(z_path_info);", " \t\t\t\tentry = estrndup(Z_STRVAL_PP(z_path_info), entry_len);", " \t\t\t\tpath_info = emalloc(Z_STRLEN_PP(z_script_name) + entry_len + 1);", " \t\t\t\tmemcpy(path_info, Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));", " \t\t\t\tmemcpy(path_info + Z_STRLEN_PP(z_script_name), entry, entry_len + 1);", " \t\t\t\tfree_pathinfo = 1;", " \t\t\t} else {", " \t\t\t\tentry_len = 0;", " \t\t\t\tentry = estrndup(\"\", 0);", " \t\t\t\tpath_info = Z_STRVAL_PP(z_script_name);", " \t\t\t}", " ", " \t\t\tpt = estrndup(Z_STRVAL_PP(z_script_name), Z_STRLEN_PP(z_script_name));", " ", " \t\t} else {", " \t\t\tchar *testit;", " ", " \t\t\ttestit = sapi_getenv(\"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1 TSRMLS_CC);", " \t\t\tif (!(pt = strstr(testit, basename))) {", " \t\t\t\tefree(testit);", " \t\t\t\treturn;", " \t\t\t}", " ", " \t\t\tpath_info = sapi_getenv(\"PATH_INFO\", sizeof(\"PATH_INFO\")-1 TSRMLS_CC);", " ", " \t\t\tif (path_info) {", " \t\t\t\tentry = path_info;", " \t\t\t\tentry_len = strlen(entry);", " \t\t\t\tspprintf(&path_info, 0, \"%s%s\", testit, path_info);", " \t\t\t\tfree_pathinfo = 1;", " \t\t\t} else {", " \t\t\t\tpath_info = testit;", " \t\t\t\tfree_pathinfo = 1;", " \t\t\t\tentry = estrndup(\"\", 0);", " \t\t\t\tentry_len = 0;", " \t\t\t}", " ", " \t\t\tpt = estrndup(testit, (pt - testit) + (fname_len - (basename - fname)));", " \t\t}", " \t\tnot_cgi = 0;", " \t} else {", " \t\tpath_info = SG(request_info).request_uri;", " ", " \t\tif (!(pt = strstr(path_info, basename))) {", " \t\t\t ", " \t\t\treturn;", " \t\t}", " ", " \t\tentry_len = strlen(path_info);", " \t\tentry_len -= (pt - path_info) + (fname_len - (basename - fname));", " \t\tentry = estrndup(pt + (fname_len - (basename - fname)), entry_len);", " ", " \t\tpt = estrndup(path_info, (pt - path_info) + (fname_len - (basename - fname)));", " \t\tnot_cgi = 1;", " \t}", " ", " \tif (rewrite) {", " \t\tzend_fcall_info fci;", " \t\tzend_fcall_info_cache fcc;", " \t\tzval *params, *retval_ptr, **zp[1];", " ", " \t\tMAKE_STD_ZVAL(params);", " \t\tZVAL_STRINGL(params, entry, entry_len, 1);", " \t\tzp[0] = &params;", " ", " #if PHP_VERSION_ID < 50300", " \t\tif (FAILURE == zend_fcall_info_init(rewrite, &fci, &fcc TSRMLS_CC)) {", " #else", " \t\tif (FAILURE == zend_fcall_info_init(rewrite, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {", " #endif", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: invalid rewrite callback\");", " ", " \t\t\tif (free_pathinfo) {", " \t\t\t\tefree(path_info);", " \t\t\t}", " ", " \t\t\treturn;", " \t\t}", " ", " \t\tfci.param_count = 1;", " \t\tfci.params = zp;", " #if PHP_VERSION_ID < 50300", " \t\t++(params->refcount);", " #else", " \t\tZ_ADDREF_P(params);", " #endif", " \t\tfci.retval_ptr_ptr = &retval_ptr;", " ", " \t\tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {", " \t\t\tif (!EG(exception)) {", " \t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: failed to call rewrite callback\");", " \t\t\t}", " ", " \t\t\tif (free_pathinfo) {", " \t\t\t\tefree(path_info);", " \t\t\t}", " ", " \t\t\treturn;", " \t\t}", " ", " \t\tif (!fci.retval_ptr_ptr || !retval_ptr) {", " \t\t\tif (free_pathinfo) {", " \t\t\t\tefree(path_info);", " \t\t\t}", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");", " \t\t\treturn;", " \t\t}", " ", " \t\tswitch (Z_TYPE_P(retval_ptr)) {", " #if PHP_VERSION_ID >= 60000", " \t\t\tcase IS_UNICODE:", " \t\t\t\tzval_unicode_to_string(retval_ptr TSRMLS_CC);", " \t\t\t\t ", " #endif", " \t\t\tcase IS_STRING:", " \t\t\t\tefree(entry);", " ", " \t\t\t\tif (fci.retval_ptr_ptr != &retval_ptr) {", " \t\t\t\t\tentry = estrndup(Z_STRVAL_PP(fci.retval_ptr_ptr), Z_STRLEN_PP(fci.retval_ptr_ptr));", " \t\t\t\t\tentry_len = Z_STRLEN_PP(fci.retval_ptr_ptr);", " \t\t\t\t} else {", " \t\t\t\t\tentry = Z_STRVAL_P(retval_ptr);", " \t\t\t\t\tentry_len = Z_STRLEN_P(retval_ptr);", " \t\t\t\t}", " ", " \t\t\t\tbreak;", " \t\t\tcase IS_BOOL:", " \t\t\t\tphar_do_403(entry, entry_len TSRMLS_CC);", " ", " \t\t\t\tif (free_pathinfo) {", " \t\t\t\t\tefree(path_info);", " \t\t\t\t}", " ", " \t\t\t\tzend_bailout();", " \t\t\t\treturn;", " \t\t\tdefault:", " \t\t\t\tefree(retval_ptr);", " ", " \t\t\t\tif (free_pathinfo) {", " \t\t\t\t\tefree(path_info);", " \t\t\t\t}", " ", " \t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar error: rewrite callback must return a string or false\");", " \t\t\t\treturn;", " \t\t}", " \t}", " ", " \tif (entry_len) {", " \t\tphar_postprocess_ru_web(fname, fname_len, &entry, &entry_len, &ru, &ru_len TSRMLS_CC);", " \t}", " ", " \tif (!entry_len || (entry_len == 1 && entry[0] == '/')) {", " \t\tefree(entry);", " \t\t ", " \t\tif (index_php_len) {", " \t\t\tentry = index_php;", " \t\t\tentry_len = index_php_len;", " \t\t\tif (entry[0] != '/') {", " \t\t\t\tspprintf(&entry, 0, \"/%s\", index_php);", " \t\t\t\t++entry_len;", " \t\t\t}", " \t\t} else {", " \t\t\t ", " \t\t\tentry = estrndup(\"/index.php\", sizeof(\"/index.php\"));", " \t\t\tentry_len = sizeof(\"/index.php\")-1;", " \t\t}", " ", " \t\tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||", " \t\t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {", " \t\t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);", " ", " \t\t\tif (free_pathinfo) {", " \t\t\t\tefree(path_info);", " \t\t\t}", " ", " \t\t\tzend_bailout();", " \t\t} else {", " \t\t\tchar *tmp = NULL, sa = '\\0';", " \t\t\tsapi_header_line ctr = {0};", " \t\t\tctr.response_code = 301;", " \t\t\tctr.line_len = sizeof(\"HTTP/1.1 301 Moved Permanently\")-1;", " \t\t\tctr.line = \"HTTP/1.1 301 Moved Permanently\";", " \t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);", " ", " \t\t\tif (not_cgi) {", " \t\t\t\ttmp = strstr(path_info, basename) + fname_len;", " \t\t\t\tsa = *tmp;", " \t\t\t\t*tmp = '\\0';", " \t\t\t}", " ", " \t\t\tctr.response_code = 0;", " ", " \t\t\tif (path_info[strlen(path_info)-1] == '/') {", " \t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry + 1);", " \t\t\t} else {", " \t\t\t\tctr.line_len = spprintf(&(ctr.line), 4096, \"Location: %s%s\", path_info, entry);", " \t\t\t}", " ", " \t\t\tif (not_cgi) {", " \t\t\t\t*tmp = sa;", " \t\t\t}", " ", " \t\t\tif (free_pathinfo) {", " \t\t\t\tefree(path_info);", " \t\t\t}", " ", " \t\t\tsapi_header_op(SAPI_HEADER_REPLACE, &ctr TSRMLS_CC);", " \t\t\tsapi_send_headers(TSRMLS_C);", " \t\t\tefree(ctr.line);", " \t\t\tzend_bailout();", " \t\t}", " \t}", " ", " \tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, NULL TSRMLS_CC) ||", " \t\t(info = phar_get_entry_info(phar, entry, entry_len, NULL, 0 TSRMLS_CC)) == NULL) {", " \t\tphar_do_404(phar, fname, fname_len, f404, f404_len, entry, entry_len TSRMLS_CC);", " #ifdef PHP_WIN32", " \t\tefree(fname);", " #endif", " \t\tzend_bailout();", " \t}", " ", " \tif (mimeoverride && zend_hash_num_elements(Z_ARRVAL_P(mimeoverride))) {", " \t\tconst char *ext = zend_memrchr(entry, '.', entry_len);", " \t\tzval **val;", " ", " \t\tif (ext) {", " \t\t\t++ext;", " ", " \t\t\tif (SUCCESS == zend_hash_find(Z_ARRVAL_P(mimeoverride), ext, strlen(ext)+1, (void **) &val)) {", " \t\t\t\tswitch (Z_TYPE_PP(val)) {", " \t\t\t\t\tcase IS_LONG:", " \t\t\t\t\t\tif (Z_LVAL_PP(val) == PHAR_MIME_PHP || Z_LVAL_PP(val) == PHAR_MIME_PHPS) {", " \t\t\t\t\t\t\tmime_type = \"\";", " \t\t\t\t\t\t\tcode = Z_LVAL_PP(val);", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used, only Phar::PHP, Phar::PHPS and a mime type string are allowed\");", " #ifdef PHP_WIN32", " \t\t\t\t\t\t\tefree(fname);", " #endif", " \t\t\t\t\t\t\tRETURN_FALSE;", " \t\t\t\t\t\t}", " \t\t\t\t\t\tbreak;", " \t\t\t\t\tcase IS_STRING:", " \t\t\t\t\t\tmime_type = Z_STRVAL_PP(val);", " \t\t\t\t\t\tcode = PHAR_MIME_OTHER;", " \t\t\t\t\t\tbreak;", " \t\t\t\t\tdefault:", " \t\t\t\t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown mime type specifier used (not a string or int), only Phar::PHP, Phar::PHPS and a mime type string are allowed\");", " #ifdef PHP_WIN32", " \t\t\t\t\t\tefree(fname);", " #endif", " \t\t\t\t\t\tRETURN_FALSE;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " ", " \tif (!mime_type) {", " \t\tcode = phar_file_type(&PHAR_G(mime_types), entry, &mime_type TSRMLS_CC);", " \t}", " \tret = phar_file_action(phar, info, mime_type, code, entry, entry_len, fname, pt, ru, ru_len TSRMLS_CC);", " }", "  ", " ", "  ", " PHP_METHOD(Phar, mungServer)", " {", " \tzval *mungvalues;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &mungvalues) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tif (!zend_hash_num_elements(Z_ARRVAL_P(mungvalues))) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"No values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");", " \t\treturn;", " \t}", " ", " \tif (zend_hash_num_elements(Z_ARRVAL_P(mungvalues)) > 4) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Too many values passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");", " \t\treturn;", " \t}", " ", " \tphar_request_initialize(TSRMLS_C);", " ", " \tfor (zend_hash_internal_pointer_reset(Z_ARRVAL_P(mungvalues)); SUCCESS == zend_hash_has_more_elements(Z_ARRVAL_P(mungvalues)); zend_hash_move_forward(Z_ARRVAL_P(mungvalues))) {", " \t\tzval **data = NULL;", " ", " \t\tif (SUCCESS != zend_hash_get_current_data(Z_ARRVAL_P(mungvalues), (void **) &data)) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to retrieve array value in Phar::mungServer()\");", " \t\t\treturn;", " \t\t}", " ", " \t\tif (Z_TYPE_PP(data) != IS_STRING) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Non-string value passed to Phar::mungServer(), expecting an array of any of these strings: PHP_SELF, REQUEST_URI, SCRIPT_FILENAME, SCRIPT_NAME\");", " \t\t\treturn;", " \t\t}", " ", " \t\tif (Z_STRLEN_PP(data) == sizeof(\"PHP_SELF\")-1 && !strncmp(Z_STRVAL_PP(data), \"PHP_SELF\", sizeof(\"PHP_SELF\")-1)) {", " \t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_PHP_SELF;", " \t\t}", " ", " \t\tif (Z_STRLEN_PP(data) == sizeof(\"REQUEST_URI\")-1) {", " \t\t\tif (!strncmp(Z_STRVAL_PP(data), \"REQUEST_URI\", sizeof(\"REQUEST_URI\")-1)) {", " \t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_REQUEST_URI;", " \t\t\t}", " \t\t\tif (!strncmp(Z_STRVAL_PP(data), \"SCRIPT_NAME\", sizeof(\"SCRIPT_NAME\")-1)) {", " \t\t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_NAME;", " \t\t\t}", " \t\t}", " ", " \t\tif (Z_STRLEN_PP(data) == sizeof(\"SCRIPT_FILENAME\")-1 && !strncmp(Z_STRVAL_PP(data), \"SCRIPT_FILENAME\", sizeof(\"SCRIPT_FILENAME\")-1)) {", " \t\t\tPHAR_GLOBALS->phar_SERVER_mung_list |= PHAR_MUNG_SCRIPT_FILENAME;", " \t\t}", " \t}", " }", "  ", " ", "  ", " PHP_METHOD(Phar, interceptFileFuncs)", " {", " \tif (zend_parse_parameters_none() == FAILURE) {", " \t\treturn;", " \t}", " \tphar_intercept_functions(TSRMLS_C);", " }", "  ", " ", "  ", " PHP_METHOD(Phar, createDefaultStub)", " {", " \tchar *index = NULL, *webindex = NULL, *stub, *error;", " \tint index_len = 0, webindex_len = 0;", " \tsize_t stub_len;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|ss\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tstub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);", " ", " \tif (error) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\tefree(error);", " \t\treturn;", " \t}", " \tRETURN_STRINGL(stub, stub_len, 0);", " }", "  ", " ", "  ", " PHP_METHOD(Phar, mapPhar)", " {", " \tchar *alias = NULL, *error;", " \tint alias_len = 0;", " \tlong dataoffset = 0;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s!l\", &alias, &alias_len, &dataoffset) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tphar_request_initialize(TSRMLS_C);", " ", " \tRETVAL_BOOL(phar_open_executed_filename(alias, alias_len, &error TSRMLS_CC) == SUCCESS);", " ", " \tif (error) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\tefree(error);", " \t}", " }  ", " ", "  ", " PHP_METHOD(Phar, loadPhar)", " {", " \tchar *fname, *alias = NULL, *error;", " \tint fname_len, alias_len = 0;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tphar_request_initialize(TSRMLS_C);", " ", " \tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error TSRMLS_CC) == SUCCESS);", " ", " \tif (error) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\tefree(error);", " \t}", " }  ", " ", "  ", " PHP_METHOD(Phar, apiVersion)", " {", " \tif (zend_parse_parameters_none() == FAILURE) {", " \t\treturn;", " \t}", " \tRETURN_STRINGL(PHP_PHAR_API_VERSION, sizeof(PHP_PHAR_API_VERSION)-1, 1);", " }", "  ", " ", "  ", " PHP_METHOD(Phar, canCompress)", " {", " \tlong method = 0;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &method) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tphar_request_initialize(TSRMLS_C);", " \tswitch (method) {", " \tcase PHAR_ENT_COMPRESSED_GZ:", " \t\tif (PHAR_G(has_zlib)) {", " \t\t\tRETURN_TRUE;", " \t\t} else {", " \t\t\tRETURN_FALSE;", " \t\t}", " \tcase PHAR_ENT_COMPRESSED_BZ2:", " \t\tif (PHAR_G(has_bz2)) {", " \t\t\tRETURN_TRUE;", " \t\t} else {", " \t\t\tRETURN_FALSE;", " \t\t}", " \tdefault:", " \t\tif (PHAR_G(has_zlib) || PHAR_G(has_bz2)) {", " \t\t\tRETURN_TRUE;", " \t\t} else {", " \t\t\tRETURN_FALSE;", " \t\t}", " \t}", " }", "  ", " ", "  ", " PHP_METHOD(Phar, canWrite)", " {", " \tif (zend_parse_parameters_none() == FAILURE) {", " \t\treturn;", " \t}", " \tRETURN_BOOL(!PHAR_G(readonly));", " }", "  ", " ", "  ", " PHP_METHOD(Phar, isValidPharFilename)", " {", " \tchar *fname;", " \tconst char *ext_str;", " \tint fname_len, ext_len, is_executable;", " \tzend_bool executable = 1;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|b\", &fname, &fname_len, &executable) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tis_executable = executable;", " \tRETVAL_BOOL(phar_detect_phar_fname_ext(fname, fname_len, &ext_str, &ext_len, is_executable, 2, 1 TSRMLS_CC) == SUCCESS);", " }", "  ", " ", " #if HAVE_SPL", "  ", " static void phar_spl_foreign_dtor(spl_filesystem_object *object TSRMLS_DC)  ", " {", " \tphar_archive_data *phar = (phar_archive_data *) object->oth;", " ", " \tif (!phar->is_persistent) {", " \t\tphar_archive_delref(phar TSRMLS_CC);", " \t}", " ", " \tobject->oth = NULL;", " }", "  ", " ", "  ", " static void phar_spl_foreign_clone(spl_filesystem_object *src, spl_filesystem_object *dst TSRMLS_DC)  ", " {", " \tphar_archive_data *phar_data = (phar_archive_data *) dst->oth;", " ", " \tif (!phar_data->is_persistent) {", " \t\t++(phar_data->refcount);", " \t}", " }", "  ", " ", " static spl_other_handler phar_spl_foreign_handler = {", " \tphar_spl_foreign_dtor,", " \tphar_spl_foreign_clone", " };", " #endif  ", " ", "  ", " PHP_METHOD(Phar, __construct)", " {", " #if !HAVE_SPL", " \tzend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, \"Cannot instantiate Phar object without SPL extension\");", " #else", " \tchar *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;", " \tint fname_len, alias_len = 0, arch_len, entry_len, is_data;", " #if PHP_VERSION_ID < 50300", " \tlong flags = 0;", " #else", " \tlong flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;", " #endif", " \tlong format = 0;", " \tphar_archive_object *phar_obj;", " \tphar_archive_data   *phar_data;", " \tzval *zobj = getThis(), arg1, arg2;", " ", " \tphar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);", " ", " \tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);", " ", " \tif (is_data) {", " \t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {", " \t\t\treturn;", " \t\t}", " \t} else {", " \t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {", " \t\t\treturn;", " \t\t}", " \t}", " ", " \tif (phar_obj->arc.archive) {", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Cannot call constructor twice\");", " \t\treturn;", " \t}", " ", " \tsave_fname = fname;", " \tif (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {", " \t\t ", " \t\t ", " #ifdef PHP_WIN32", " \t\tphar_unixify_path_separators(arch, arch_len);", " #endif", " \t\tfname = arch;", " \t\tfname_len = arch_len;", " #ifdef PHP_WIN32", " \t} else {", " \t\tarch = estrndup(fname, fname_len);", " \t\tarch_len = fname_len;", " \t\tfname = arch;", " \t\tphar_unixify_path_separators(arch, arch_len);", " #endif", " \t}", " ", " \tif (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {", " ", " \t\tif (fname == arch && fname != save_fname) {", " \t\t\tefree(arch);", " \t\t\tfname = save_fname;", " \t\t}", " ", " \t\tif (entry) {", " \t\t\tefree(entry);", " \t\t}", " ", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"%s\", error);", " \t\t\tefree(error);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Phar creation or opening failed\");", " \t\t}", " ", " \t\treturn;", " \t}", " ", " \tif (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {", " \t\tphar_data->is_zip = 1;", " \t\tphar_data->is_tar = 0;", " \t}", " ", " \tif (fname == arch) {", " \t\tefree(arch);", " \t\tfname = save_fname;", " \t}", " ", " \tif ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {", " \t\tif (is_data) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"PharData class can only be used for non-executable tar and zip archives\");", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Phar class can only be used for executable tar and zip archives\");", " \t\t}", " \t\tefree(entry);", " \t\treturn;", " \t}", " ", " \tis_data = phar_data->is_data;", " ", " \tif (!phar_data->is_persistent) {", " \t\t++(phar_data->refcount);", " \t}", " ", " \tphar_obj->arc.archive = phar_data;", " \tphar_obj->spl.oth_handler = &phar_spl_foreign_handler;", " ", " \tif (entry) {", " \t\tfname_len = spprintf(&fname, 0, \"phar:%s%s\", phar_data->fname, entry);", " \t\tefree(entry);", " \t} else {", " \t\tfname_len = spprintf(&fname, 0, \"phar:%s\", phar_data->fname);", " \t}", " ", " \tINIT_PZVAL(&arg1);", " \tZVAL_STRINGL(&arg1, fname, fname_len, 0);", "         INIT_PZVAL(&arg2);", "         ZVAL_LONG(&arg2, flags);", "  ", "       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), ", "        zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),", "                 &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);", "  ", "         if (!phar_data->is_persistent) {", " \t\tphar_obj->arc.archive->is_data = is_data;", " \t} else if (!EG(exception)) {", " \t\t ", " \t\tzend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);", " \t}", " ", " \tphar_obj->spl.info_class = phar_ce_entry;", " \tefree(fname);", " #endif  ", " }", "  ", " ", "  ", " PHP_METHOD(Phar, getSupportedSignatures)", " {", "         if (zend_parse_parameters_none() == FAILURE) {", "                 return;", "         }", " ", "         array_init(return_value);", "  ", "         add_next_index_stringl(return_value, \"MD5\", 3, 1);", " \tadd_next_index_stringl(return_value, \"SHA-1\", 5, 1);", " #ifdef PHAR_HASH_OK", " \tadd_next_index_stringl(return_value, \"SHA-256\", 7, 1);", " \tadd_next_index_stringl(return_value, \"SHA-512\", 7, 1);", " #endif", " #if PHAR_HAVE_OPENSSL", " \tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);", " #else", " \tif (zend_hash_exists(&module_registry, \"openssl\", sizeof(\"openssl\"))) {", " \t\tadd_next_index_stringl(return_value, \"OpenSSL\", 7, 1);", " \t}", " #endif", " }", "  ", " ", "  ", " PHP_METHOD(Phar, getSupportedCompression)", " {", "         if (zend_parse_parameters_none() == FAILURE) {", "                 return;", "         }", " ", "         array_init(return_value);", "         phar_request_initialize(TSRMLS_C);", "  ", " \tif (PHAR_G(has_zlib)) {", " \t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);", " \t}", " ", " \tif (PHAR_G(has_bz2)) {", " \t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);", " \t}", " }", "  ", " ", "  ", " PHP_METHOD(Phar, unlinkArchive)", " {", " \tchar *fname, *error, *zname, *arch, *entry;", " \tint fname_len, zname_len, arch_len, entry_len;", " \tphar_archive_data *phar;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &fname, &fname_len) == FAILURE) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tif (!fname_len) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"\\\"\");", " \t\treturn;", " \t}", " ", " \tif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error TSRMLS_CC)) {", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);", " \t\t\tefree(error);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown phar archive \\\"%s\\\"\", fname);", " \t\t}", " \t\treturn;", " \t}", " ", " \tzname = (char*)zend_get_executed_filename(TSRMLS_C);", " \tzname_len = strlen(zname);", " ", " \tif (zname_len > 7 && !memcmp(zname, \"phar:\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0 TSRMLS_CC)) {", " \t\tif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);", " \t\t\tefree(arch);", " \t\t\tefree(entry);", " \t\t\treturn;", " \t\t}", " \t\tefree(arch);", " \t\tefree(entry);", " \t}", " ", " \tif (phar->is_persistent) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);", " \t\treturn;", " \t}", " ", " \tif (phar->refcount) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);", " \t\treturn;", " \t}", " ", " \tfname = estrndup(phar->fname, phar->fname_len);", " ", " \t ", " \tPHAR_G(last_phar) = NULL;", " \tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;", " ", " \tphar_archive_delref(phar TSRMLS_CC);", " \tunlink(fname);", " \tefree(fname);", " \tRETURN_TRUE;", " }", "  ", " ", " #if HAVE_SPL", " ", " #define PHAR_ARCHIVE_OBJECT() \\", " \tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\", " \tif (!phar_obj->arc.archive) { \\", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \\", " \t\t\t\"Cannot call method on an uninitialized Phar object\"); \\", " \t\treturn; \\", " \t}", " ", "  ", " PHP_METHOD(Phar, __destruct)", " {", " \tphar_archive_object *phar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);", " ", " \tif (phar_obj->arc.archive && phar_obj->arc.archive->is_persistent) {", " \t\tzend_hash_del(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive));", " \t}", " }", "  ", " ", " struct _phar_t {", " \tphar_archive_object *p;", " \tzend_class_entry *c;", " \tchar *b;", " \tuint l;", " \tzval *ret;", " \tint count;", " \tphp_stream *fp;", " };", " ", " static int phar_build(zend_object_iterator *iter, void *puser TSRMLS_DC)  ", " {", " \tzval **value;", " \tzend_uchar key_type;", " \tzend_bool close_fp = 1;", " \tulong int_key;", " \tstruct _phar_t *p_obj = (struct _phar_t*) puser;", " \tuint str_key_len, base_len = p_obj->l, fname_len;", " \tphar_entry_data *data;", " \tphp_stream *fp;", " \tsize_t contents_len;", " \tchar *fname, *error = NULL, *base = p_obj->b, *opened, *save = NULL, *temp = NULL;", " \tphar_zstr key;", " \tchar *str_key;", " \tzend_class_entry *ce = p_obj->c;", " \tphar_archive_object *phar_obj = p_obj->p;", " \tchar *str = \"[stream]\";", " ", " \titer->funcs->get_current_data(iter, &value TSRMLS_CC);", " ", " \tif (EG(exception)) {", " \t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " ", " \tif (!value) {", " \t\t ", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned no value\", ce->name);", " \t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " ", " \tswitch (Z_TYPE_PP(value)) {", " #if PHP_VERSION_ID >= 60000", " \t\tcase IS_UNICODE:", " \t\t\tzval_unicode_to_string(*(value) TSRMLS_CC);", " \t\t\t ", " #endif", " \t\tcase IS_STRING:", " \t\t\tbreak;", " \t\tcase IS_RESOURCE:", " \t\t\tphp_stream_from_zval_no_verify(fp, value);", " ", " \t\t\tif (!fp) {", " \t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returned an invalid stream handle\", ce->name);", " \t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t}", " ", " \t\t\tif (iter->funcs->get_current_key) {", " \t\t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);", " ", " \t\t\t\tif (EG(exception)) {", " \t\t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t\t}", " ", " \t\t\t\tif (key_type == HASH_KEY_IS_LONG) {", " \t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);", " \t\t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t\t}", " ", " \t\t\t\tif (key_type > 9) {  ", " #if PHP_VERSION_ID < 60000", "  ", " \t\t\t\t\tspprintf(&str_key, 0, \"%s\", key);", " #else", " \t\t\t\t\tspprintf(&str_key, 0, \"%v\", key);", " \t\t\t\t\tezfree(key);", " #endif", " \t\t\t\t} else {", " \t\t\t\t\tPHAR_STR(key, str_key);", " \t\t\t\t}", " ", " \t\t\t\tsave = str_key;", " ", " \t\t\t\tif (str_key[str_key_len - 1] == '\\0') {", " \t\t\t\t\tstr_key_len--;", " \t\t\t\t}", " ", " \t\t\t} else {", " \t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);", " \t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t}", " ", " \t\t\tclose_fp = 0;", " \t\t\topened = (char *) estrndup(str, sizeof(\"[stream]\") - 1);", " \t\t\tgoto after_open_fp;", " \t\tcase IS_OBJECT:", " \t\t\tif (instanceof_function(Z_OBJCE_PP(value), spl_ce_SplFileInfo TSRMLS_CC)) {", " \t\t\t\tchar *test = NULL;", " \t\t\t\tzval dummy;", " \t\t\t\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(*value TSRMLS_CC);", " ", " \t\t\t\tif (!base_len) {", " \t\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Iterator %v returns an SplFileInfo object, so base directory must be specified\", ce->name);", " \t\t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t\t}", " ", " \t\t\t\tswitch (intern->type) {", " \t\t\t\t\tcase SPL_FS_DIR:", " #if PHP_VERSION_ID >= 60000", " \t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL, NULL TSRMLS_CC).s;", " #elif PHP_VERSION_ID >= 50300", " \t\t\t\t\t\ttest = spl_filesystem_object_get_path(intern, NULL TSRMLS_CC);", " #else", " \t\t\t\t\t\ttest = intern->path;", " #endif", " \t\t\t\t\t\tfname_len = spprintf(&fname, 0, \"%s%c%s\", test, DEFAULT_SLASH, intern->u.dir.entry.d_name);", " \t\t\t\t\t\tphp_stat(fname, fname_len, FS_IS_DIR, &dummy TSRMLS_CC);", " ", " \t\t\t\t\t\tif (Z_BVAL(dummy)) {", " \t\t\t\t\t\t\t ", " \t\t\t\t\t\t\tefree(fname);", " \t\t\t\t\t\t\treturn ZEND_HASH_APPLY_KEEP;", " \t\t\t\t\t\t}", " ", " \t\t\t\t\t\ttest = expand_filepath(fname, NULL TSRMLS_CC);", " \t\t\t\t\t\tefree(fname);", " ", " \t\t\t\t\t\tif (test) {", " \t\t\t\t\t\t\tfname = test;", " \t\t\t\t\t\t\tfname_len = strlen(fname);", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");", " \t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t\t\t\t}", " ", " \t\t\t\t\t\tsave = fname;", " \t\t\t\t\t\tgoto phar_spl_fileinfo;", " \t\t\t\t\tcase SPL_FS_INFO:", " \t\t\t\t\tcase SPL_FS_FILE:", " #if PHP_VERSION_ID >= 60000", " \t\t\t\t\t\tif (intern->file_name_type == IS_UNICODE) {", " \t\t\t\t\t\t\tzval zv;", " ", " \t\t\t\t\t\t\tINIT_ZVAL(zv);", " \t\t\t\t\t\t\tZ_UNIVAL(zv) = intern->file_name;", " \t\t\t\t\t\t\tZ_UNILEN(zv) = intern->file_name_len;", " \t\t\t\t\t\t\tZ_TYPE(zv) = IS_UNICODE;", " ", " \t\t\t\t\t\t\tzval_copy_ctor(&zv);", " \t\t\t\t\t\t\tzval_unicode_to_string(&zv TSRMLS_CC);", " \t\t\t\t\t\t\tfname = expand_filepath(Z_STRVAL(zv), NULL TSRMLS_CC);", " \t\t\t\t\t\t\tezfree(Z_UNIVAL(zv));", " \t\t\t\t\t\t} else {", " \t\t\t\t\t\t\tfname = expand_filepath(intern->file_name.s, NULL TSRMLS_CC);", " \t\t\t\t\t\t}", " #else", " \t\t\t\t\t\tfname = expand_filepath(intern->file_name, NULL TSRMLS_CC);", " #endif", " \t\t\t\t\t\tif (!fname) {", " \t\t\t\t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");", " \t\t\t\t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t\t\t\t}", " ", " \t\t\t\t\t\tfname_len = strlen(fname);", " \t\t\t\t\t\tsave = fname;", " \t\t\t\t\t\tgoto phar_spl_fileinfo;", " \t\t\t\t}", " \t\t\t}", " \t\t\t ", " \t\tdefault:", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid value (must return a string)\", ce->name);", " \t\t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " ", " \tfname = Z_STRVAL_PP(value);", " \tfname_len = Z_STRLEN_PP(value);", " ", " phar_spl_fileinfo:", " \tif (base_len) {", " \t\ttemp = expand_filepath(base, NULL TSRMLS_CC);", " \t\tif (!temp) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Could not resolve file path\");", " \t\t\tif (save) {", " \t\t\t\tefree(save);", "                         }", "                         return ZEND_HASH_APPLY_STOP;", "                 }", " ", "                 base = temp;", "                 base_len = strlen(base);", "  ", " \t\tif (strstr(fname, base)) {", " \t\t\tstr_key_len = fname_len - base_len;", " ", " \t\t\tif (str_key_len <= 0) {", " \t\t\t\tif (save) {", " \t\t\t\t\tefree(save);", " \t\t\t\t\tefree(temp);", " \t\t\t\t}", " \t\t\t\treturn ZEND_HASH_APPLY_KEEP;", " \t\t\t}", " ", " \t\t\tstr_key = fname + base_len;", " ", " \t\t\tif (*str_key == '/' || *str_key == '\\\\') {", " \t\t\t\tstr_key++;", " \t\t\t\tstr_key_len--;", " \t\t\t}", " ", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that is not in the base directory \\\"%s\\\"\", ce->name, fname, base);", " ", " \t\t\tif (save) {", " \t\t\t\tefree(save);", " \t\t\t\tefree(temp);", " \t\t\t}", " ", " \t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t}", " \t} else {", " \t\tif (iter->funcs->get_current_key) {", " \t\t\tkey_type = iter->funcs->get_current_key(iter, &key, &str_key_len, &int_key TSRMLS_CC);", " ", " \t\t\tif (EG(exception)) {", " \t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t}", " ", " \t\t\tif (key_type == HASH_KEY_IS_LONG) {", " \t\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);", " \t\t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t\t}", " ", " \t\t\tif (key_type > 9) {  ", " #if PHP_VERSION_ID < 60000", "  ", " \t\t\t\tspprintf(&str_key, 0, \"%s\", key);", " #else", " \t\t\t\tspprintf(&str_key, 0, \"%v\", key);", " \t\t\t\tezfree(key);", " #endif", " \t\t\t} else {", " \t\t\t\tPHAR_STR(key, str_key);", " \t\t\t}", " ", " \t\t\tsave = str_key;", " ", " \t\t\tif (str_key[str_key_len - 1] == '\\0') str_key_len--;", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned an invalid key (must return a string)\", ce->name);", " \t\t\treturn ZEND_HASH_APPLY_STOP;", " \t\t}", " \t}", " #if PHP_API_VERSION < 20100412", " \tif (PG(safe_mode) && (!php_checkuid(fname, NULL, CHECKUID_ALLOW_ONLY_FILE))) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that safe mode prevents opening\", ce->name, fname);", " ", " \t\tif (save) {", " \t\t\tefree(save);", " \t\t}", " ", " \t\tif (temp) {", " \t\t\tefree(temp);", " \t\t}", " ", " \t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " #endif", " ", " \tif (php_check_open_basedir(fname TSRMLS_CC)) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a path \\\"%s\\\" that open_basedir prevents opening\", ce->name, fname);", " ", " \t\tif (save) {", " \t\t\tefree(save);", " \t\t}", " ", " \t\tif (temp) {", " \t\t\tefree(temp);", " \t\t}", " ", " \t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " ", " \t ", " \tfp = php_stream_open_wrapper(fname, \"rb\", STREAM_MUST_SEEK|0, &opened);", " ", " \tif (!fp) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Iterator %v returned a file that could not be opened \\\"%s\\\"\", ce->name, fname);", " ", " \t\tif (save) {", " \t\t\tefree(save);", " \t\t}", " ", " \t\tif (temp) {", " \t\t\tefree(temp);", " \t\t}", " ", " \t\treturn ZEND_HASH_APPLY_STOP;", " \t}", " after_open_fp:", " \tif (str_key_len >= sizeof(\".phar\")-1 && !memcmp(str_key, \".phar\", sizeof(\".phar\")-1)) {", " \t\t ", " \t\tif (save) {", " \t\t\tefree(save);", " \t\t}", " ", " \t\tif (temp) {", " \t\t\tefree(temp);", " \t\t}", " ", " \t\tif (opened) {", " \t\t\tefree(opened);", " \t\t}", " ", " \t\tif (close_fp) {", " \t\t\tphp_stream_close(fp);", " \t\t}", " ", " \t\treturn ZEND_HASH_APPLY_KEEP;", " \t}", " ", " \tif (!(data = phar_get_or_create_entry_data(phar_obj->arc.archive->fname, phar_obj->arc.archive->fname_len, str_key, str_key_len, \"w+b\", 0, &error, 1 TSRMLS_CC))) {", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Entry %s cannot be created: %s\", str_key, error);", " \t\tefree(error);", " ", " \t\tif (save) {", " \t\t\tefree(save);", " \t\t}", " ", " \t\tif (opened) {", " \t\t\tefree(opened);", " \t\t}", " ", " \t\tif (temp) {", " \t\t\tefree(temp);", " \t\t}", " ", " \t\tif (close_fp) {", " \t\t\tphp_stream_close(fp);", " \t\t}", " ", " \t\treturn ZEND_HASH_APPLY_STOP;", " ", " \t} else {", " \t\tif (error) {", " \t\t\tefree(error);", " \t\t}", " \t\t ", " \t\tif (data->internal_file->fp_type == PHAR_MOD) {", " \t\t\tphp_stream_close(data->internal_file->fp);", " \t\t}", " ", " \t\tdata->internal_file->fp = NULL;", " \t\tdata->internal_file->fp_type = PHAR_UFP;", " \t\tdata->internal_file->offset_abs = data->internal_file->offset = php_stream_tell(p_obj->fp);", " \t\tdata->fp = NULL;", " \t\tphar_stream_copy_to_stream(fp, p_obj->fp, PHP_STREAM_COPY_ALL, &contents_len);", " \t\tdata->internal_file->uncompressed_filesize = data->internal_file->compressed_filesize =", " \t\t\tphp_stream_tell(p_obj->fp) - data->internal_file->offset;", " \t}", " ", " \tif (close_fp) {", " \t\tphp_stream_close(fp);", " \t}", " ", " \tadd_assoc_string(p_obj->ret, str_key, opened, 0);", " ", " \tif (save) {", " \t\tefree(save);", " \t}", " ", " \tif (temp) {", " \t\tefree(temp);", " \t}", " ", " \tdata->internal_file->compressed_filesize = data->internal_file->uncompressed_filesize = contents_len;", " \tphar_entry_delref(data TSRMLS_CC);", " ", " \treturn ZEND_HASH_APPLY_KEEP;", " }", "  ", " ", "   ", "  PHP_METHOD(Phar, buildFromDirectory)", " {", " \tchar *dir, *error, *regex = NULL;", " \tint dir_len, regex_len = 0;", " \tzend_bool apply_reg = 0;", " \tzval arg, arg2, *iter, *iteriter, *regexiter = NULL;", " \tstruct _phar_t pass;", " ", " \tPHAR_ARCHIVE_OBJECT();", " ", " \tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\"Cannot write to archive - write operations restricted by INI setting\");", " \t\treturn;", " \t}", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tMAKE_STD_ZVAL(iter);", " ", " \tif (SUCCESS != object_init_ex(iter, spl_ce_RecursiveDirectoryIterator)) {", " \t\tzval_ptr_dtor(&iter);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);", " \t\tRETURN_FALSE;", " \t}", " ", " \tINIT_PZVAL(&arg);", " \tZVAL_STRINGL(&arg, dir, dir_len, 0);", " \tINIT_PZVAL(&arg2);", " #if PHP_VERSION_ID < 50300", " \tZVAL_LONG(&arg2, 0);", " #else", "         ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);", "  #endif", "  ", "       zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, ", "        zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,", "                         &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);", "  ", "         if (EG(exception)) {", " \t\tzval_ptr_dtor(&iter);", " \t\tRETURN_FALSE;", " \t}", " ", " \tMAKE_STD_ZVAL(iteriter);", " ", " \tif (SUCCESS != object_init_ex(iteriter, spl_ce_RecursiveIteratorIterator)) {", " \t\tzval_ptr_dtor(&iter);", " \t\tzval_ptr_dtor(&iteriter);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate directory iterator for %s\", phar_obj->arc.archive->fname);", "                 RETURN_FALSE;", "         }", "  ", "       zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, ", "        zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,", "                         &spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);", "  ", "         if (EG(exception)) {", " \t\tzval_ptr_dtor(&iter);", " \t\tzval_ptr_dtor(&iteriter);", " \t\tRETURN_FALSE;", " \t}", " ", " \tzval_ptr_dtor(&iter);", " ", " \tif (regex_len > 0) {", " \t\tapply_reg = 1;", " \t\tMAKE_STD_ZVAL(regexiter);", " ", " \t\tif (SUCCESS != object_init_ex(regexiter, spl_ce_RegexIterator)) {", " \t\t\tzval_ptr_dtor(&iteriter);", " \t\t\tzval_dtor(regexiter);", " \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate regex iterator for %s\", phar_obj->arc.archive->fname);", " \t\t\tRETURN_FALSE;", " \t\t}", " ", "                 INIT_PZVAL(&arg2);", "                 ZVAL_STRINGL(&arg2, regex, regex_len, 0);", "  ", "               zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, ", "                zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,", "                         &spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);", "         }", "  ", " \tarray_init(return_value);", " ", " \tpass.c = apply_reg ? Z_OBJCE_P(regexiter) : Z_OBJCE_P(iteriter);", " \tpass.p = phar_obj;", " \tpass.b = dir;", " \tpass.l = dir_len;", " \tpass.count = 0;", " \tpass.ret = return_value;", " \tpass.fp = php_stream_fopen_tmpfile();", " \tif (pass.fp == NULL) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" unable to create temporary file\", phar_obj->arc.archive->fname);", " \t\treturn;", " \t}", " ", " \tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {", " \t\tzval_ptr_dtor(&iteriter);", " \t\tif (apply_reg) {", " \t\t\tzval_ptr_dtor(&regexiter);", " \t\t}", " \t\tphp_stream_close(pass.fp);", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);", " \t\treturn;", " \t}", " ", " \tif (SUCCESS == spl_iterator_apply((apply_reg ? regexiter : iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {", " \t\tzval_ptr_dtor(&iteriter);", " ", " \t\tif (apply_reg) {", " \t\t\tzval_ptr_dtor(&regexiter);", " \t\t}", " ", " \t\tphar_obj->arc.archive->ufp = pass.fp;", " \t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);", " ", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\t\tefree(error);", " \t\t}", " ", " \t} else {", " \t\tzval_ptr_dtor(&iteriter);", " \t\tif (apply_reg) {", " \t\t\tzval_ptr_dtor(&regexiter);", " \t\t}", " \t\tphp_stream_close(pass.fp);", " \t}", " }", "  ", " ", "  ", " PHP_METHOD(Phar, buildFromIterator)", " {", " \tzval *obj;", " \tchar *error;", " \tuint base_len = 0;", " \tchar *base = NULL;", " \tstruct _phar_t pass;", " ", " \tPHAR_ARCHIVE_OBJECT();", " ", " \tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\"Cannot write out phar archive, phar is read-only\");", " \t\treturn;", " \t}", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O|s\", &obj, zend_ce_traversable, &base, &base_len) == FAILURE) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\" is persistent, unable to copy on write\", phar_obj->arc.archive->fname);", " \t\treturn;", " \t}", " ", " \tarray_init(return_value);", " ", " \tpass.c = Z_OBJCE_P(obj);", " \tpass.p = phar_obj;", " \tpass.b = base;", " \tpass.l = base_len;", " \tpass.ret = return_value;", " \tpass.count = 0;", " \tpass.fp = php_stream_fopen_tmpfile();", " \tif (pass.fp == NULL) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"phar \\\"%s\\\": unable to create temporary file\", phar_obj->arc.archive->fname);", " \t\treturn;", " \t}", " ", " \tif (SUCCESS == spl_iterator_apply(obj, (spl_iterator_apply_func_t) phar_build, (void *) &pass TSRMLS_CC)) {", " \t\tphar_obj->arc.archive->ufp = pass.fp;", " \t\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"%s\", error);", " \t\t\tefree(error);", " \t\t}", " \t} else {", " \t\tphp_stream_close(pass.fp);", " \t}", " }", "  ", " ", "  ", "  PHP_METHOD(Phar, count)", "  {", "         PHAR_ARCHIVE_OBJECT();", " ", "         if (zend_parse_parameters_none() == FAILURE) {", "                 return;", "         }", " ", " \tRETURN_LONG(zend_hash_num_elements(&phar_obj->arc.archive->manifest));", " }", "  ", " ", "  ", " PHP_METHOD(Phar, isFileFormat)", " {", " \tlong type;", " \tPHAR_ARCHIVE_OBJECT();", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &type) == FAILURE) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tswitch (type) {", " \t\tcase PHAR_FORMAT_TAR:", " \t\t\tRETURN_BOOL(phar_obj->arc.archive->is_tar);", " \t\tcase PHAR_FORMAT_ZIP:", " \t\t\tRETURN_BOOL(phar_obj->arc.archive->is_zip);", " \t\tcase PHAR_FORMAT_PHAR:", " \t\t\tRETURN_BOOL(!phar_obj->arc.archive->is_tar && !phar_obj->arc.archive->is_zip);", " \t\tdefault:", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"Unknown file format specified\");", " \t}", " }", "  ", " ", " static int phar_copy_file_contents(phar_entry_info *entry, php_stream *fp TSRMLS_DC)  ", " {", " \tchar *error;", " \toff_t offset;", " \tphar_entry_info *link;", " ", " \tif (FAILURE == phar_open_entry_fp(entry, &error, 1 TSRMLS_CC)) {", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents: %s\", entry->phar->fname, entry->filename, error);", " \t\t\tefree(error);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to open entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \t ", " \tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);", " \toffset = php_stream_tell(fp);", " \tlink = phar_get_link_source(entry TSRMLS_CC);", " ", " \tif (!link) {", " \t\tlink = entry;", " \t}", " ", " \tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {", " \t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\"Cannot convert phar archive \\\"%s\\\", unable to copy entry \\\"%s\\\" contents\", entry->phar->fname, entry->filename);", " \t\treturn FAILURE;", " \t}", " ", " \tif (entry->fp_type == PHAR_MOD) {", " \t\t ", " \t\tentry->cfp = entry->fp;", " \t\tentry->fp = NULL;", " \t}", " ", " \t ", " \tentry->fp_type = PHAR_FP;", " \tentry->offset = offset;", " \treturn SUCCESS;", " }", "  ", " ", " static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC)  ", " {", " \tconst char *oldname = NULL;", " \tchar *oldpath = NULL;", " \tchar *basename = NULL, *basepath = NULL;", " \tchar *newname = NULL, *newpath = NULL;", " \tzval *ret, arg1;", " \tzend_class_entry *ce;", " \tchar *error;", " \tconst char *pcr_error;", " \tint ext_len = ext ? strlen(ext) : 0;", " \tint oldname_len;", " \tphar_archive_data **pphar = NULL;", " \tphp_stream_statbuf ssb;", " ", " \tif (!ext) {", " \t\tif (phar->is_zip) {", " ", " \t\t\tif (phar->is_data) {", " \t\t\t\text = \"zip\";", " \t\t\t} else {", " \t\t\t\text = \"phar.zip\";", " \t\t\t}", " ", " \t\t} else if (phar->is_tar) {", " ", " \t\t\tswitch (phar->flags) {", " \t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:", " \t\t\t\t\tif (phar->is_data) {", " \t\t\t\t\t\text = \"tar.gz\";", " \t\t\t\t\t} else {", " \t\t\t\t\t\text = \"phar.tar.gz\";", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:", " \t\t\t\t\tif (phar->is_data) {", " \t\t\t\t\t\text = \"tar.bz2\";", " \t\t\t\t\t} else {", " \t\t\t\t\t\text = \"phar.tar.bz2\";", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t\tdefault:", " \t\t\t\t\tif (phar->is_data) {", " \t\t\t\t\t\text = \"tar\";", " \t\t\t\t\t} else {", " \t\t\t\t\t\text = \"phar.tar\";", " \t\t\t\t\t}", " \t\t\t}", " \t\t} else {", " ", " \t\t\tswitch (phar->flags) {", " \t\t\t\tcase PHAR_FILE_COMPRESSED_GZ:", " \t\t\t\t\text = \"phar.gz\";", " \t\t\t\t\tbreak;", " \t\t\t\tcase PHAR_FILE_COMPRESSED_BZ2:", " \t\t\t\t\text = \"phar.bz2\";", " \t\t\t\t\tbreak;", " \t\t\t\tdefault:", " \t\t\t\t\text = \"phar\";", " \t\t\t}", " \t\t}", " \t} else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) {", " ", " \t\tif (phar->is_data) {", " \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar converted from \\\"%s\\\" has invalid extension %s\", phar->fname, ext);", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \tif (ext[0] == '.') {", " \t\t++ext;", " \t}", " ", " \toldpath = estrndup(phar->fname, phar->fname_len);", " \toldname = zend_memrchr(phar->fname, '/', phar->fname_len);", " \t++oldname;", " \toldname_len = strlen(oldname);", " ", " \tbasename = estrndup(oldname, oldname_len);", "         spprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);", "         efree(basename);", "  ", " ", "  ", "         basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));", "         phar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);", " \tphar->fname = newpath;", " \tphar->ext = newpath + phar->fname_len - strlen(ext) - 1;", " \tefree(basepath);", " \tefree(newname);", " ", " \tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) {", " \t\tefree(oldpath);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, new phar name is in phar.cache_list\", phar->fname);", " \t\treturn NULL;", " \t}", " ", " \tif (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) {", " \t\tif ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) {", " \t\t\tif (!zend_hash_num_elements(&phar->manifest)) {", " \t\t\t\t(*pphar)->is_tar = phar->is_tar;", " \t\t\t\t(*pphar)->is_zip = phar->is_zip;", " \t\t\t\t(*pphar)->is_data = phar->is_data;", " \t\t\t\t(*pphar)->flags = phar->flags;", " \t\t\t\t(*pphar)->fp = phar->fp;", " \t\t\t\tphar->fp = NULL;", " \t\t\t\tphar_destroy_phar_data(phar TSRMLS_CC);", " \t\t\t\tphar = *pphar;", " \t\t\t\tphar->refcount++;", " \t\t\t\tnewpath = oldpath;", " \t\t\t\tgoto its_ok;", " \t\t\t}", " \t\t}", " ", " \t\tefree(oldpath);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars, a phar with that name already exists\", phar->fname);", " \t\treturn NULL;", " \t}", " its_ok:", " \tif (SUCCESS == php_stream_stat_path(newpath, &ssb)) {", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" exists and must be unlinked prior to conversion\", newpath);", " \t\tefree(oldpath);", " \t\treturn NULL;", " \t}", " \tif (!phar->is_data) {", " \t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) {", " \t\t\tefree(oldpath);", " \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);", " \t\t\treturn NULL;", " \t\t}", " ", " \t\tif (phar->alias) {", " \t\t\tif (phar->is_temporary_alias) {", " \t\t\t\tphar->alias = NULL;", " \t\t\t\tphar->alias_len = 0;", " \t\t\t} else {", " \t\t\t\tphar->alias = estrndup(newpath, strlen(newpath));", " \t\t\t\tphar->alias_len = strlen(newpath);", " \t\t\t\tphar->is_temporary_alias = 1;", " \t\t\t\tzend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL);", " \t\t\t}", " \t\t}", " ", " \t} else {", " ", " \t\tif (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) {", " \t\t\tefree(oldpath);", " \t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"data phar \\\"%s\\\" has invalid extension %s\", phar->fname, ext);", " \t\t\treturn NULL;", " \t\t}", " ", " \t\tphar->alias = NULL;", " \t\tphar->alias_len = 0;", " \t}", " ", " \tif ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) {", " \t\tefree(oldpath);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to add newly converted phar \\\"%s\\\" to the list of phars\", phar->fname);", " \t\treturn NULL;", " \t}", " ", " \tphar_flush(phar, 0, 0, 1, &error TSRMLS_CC);", " ", " \tif (error) {", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"%s\", error);", " \t\tefree(error);", " \t\tefree(oldpath);", " \t\treturn NULL;", " \t}", " ", " \tefree(oldpath);", " ", " \tif (phar->is_data) {", " \t\tce = phar_ce_data;", " \t} else {", " \t\tce = phar_ce_archive;", " \t}", " ", " \tMAKE_STD_ZVAL(ret);", " ", " \tif (SUCCESS != object_init_ex(ret, ce)) {", " \t\tzval_dtor(ret);", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Unable to instantiate phar object when converting archive \\\"%s\\\"\", phar->fname);", " \t\treturn NULL;", " \t}", " ", " \tINIT_PZVAL(&arg1);", " \tZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0);", " ", " \tzend_call_method_with_1_params(&ret, ce, &ce->constructor, \"__construct\", NULL, &arg1);", " \treturn ret;", " }", "  ", " ", " static zval *phar_convert_to_other(phar_archive_data *source, int convert, char *ext, php_uint32 flags TSRMLS_DC)  ", " {", " \tphar_archive_data *phar;", " \tphar_entry_info *entry, newentry;", " \tzval *ret;", " ", " \t ", " \tPHAR_G(last_phar) = NULL;", " \tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;", " ", " \tphar = (phar_archive_data *) ecalloc(1, sizeof(phar_archive_data));", " \t ", " \tphar->flags = flags;", " \tphar->is_data = source->is_data;", " ", " \tswitch (convert) {", " \t\tcase PHAR_FORMAT_TAR:", " \t\t\tphar->is_tar = 1;", " \t\t\tbreak;", " \t\tcase PHAR_FORMAT_ZIP:", " \t\t\tphar->is_zip = 1;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tphar->is_data = 0;", " \t\t\tbreak;", " \t}", " ", " \tzend_hash_init(&(phar->manifest), sizeof(phar_entry_info),", " \t\tzend_get_hash_value, destroy_phar_manifest_entry, 0);", " \tzend_hash_init(&phar->mounted_dirs, sizeof(char *),", " \t\tzend_get_hash_value, NULL, 0);", " \tzend_hash_init(&phar->virtual_dirs, sizeof(char *),", " \t\tzend_get_hash_value, NULL, 0);", " ", " \tphar->fp = php_stream_fopen_tmpfile();", " \tif (phar->fp == NULL) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"unable to create temporary file\");", " \t\treturn NULL;", " \t}", " \tphar->fname = source->fname;", " \tphar->fname_len = source->fname_len;", " \tphar->is_temporary_alias = source->is_temporary_alias;", " \tphar->alias = source->alias;", " ", " \tif (source->metadata) {", " \t\tzval *t;", " ", " \t\tt = source->metadata;", " \t\tALLOC_ZVAL(phar->metadata);", " \t\t*phar->metadata = *t;", " \t\tzval_copy_ctor(phar->metadata);", " #if PHP_VERSION_ID < 50300", " \t\tphar->metadata->refcount = 1;", " #else", " \t\tZ_SET_REFCOUNT_P(phar->metadata, 1);", " #endif", " ", " \t\tphar->metadata_len = 0;", " \t}", " ", " \t ", " \tfor (zend_hash_internal_pointer_reset(&source->manifest); SUCCESS == zend_hash_has_more_elements(&source->manifest); zend_hash_move_forward(&source->manifest)) {", " ", " \t\tif (FAILURE == zend_hash_get_current_data(&source->manifest, (void **) &entry)) {", " \t\t\tzend_hash_destroy(&(phar->manifest));", " \t\t\tphp_stream_close(phar->fp);", " \t\t\tefree(phar);", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Cannot convert phar archive \\\"%s\\\"\", source->fname);", " \t\t\treturn NULL;", " \t\t}", " ", " \t\tnewentry = *entry;", " ", " \t\tif (newentry.link) {", " \t\t\tnewentry.link = estrdup(newentry.link);", " \t\t\tgoto no_copy;", " \t\t}", " ", " \t\tif (newentry.tmp) {", " \t\t\tnewentry.tmp = estrdup(newentry.tmp);", " \t\t\tgoto no_copy;", " \t\t}", " ", " \t\tnewentry.metadata_str.c = 0;", " ", " \t\tif (FAILURE == phar_copy_file_contents(&newentry, phar->fp TSRMLS_CC)) {", " \t\t\tzend_hash_destroy(&(phar->manifest));", " \t\t\tphp_stream_close(phar->fp);", " \t\t\tefree(phar);", " \t\t\t ", " \t\t\treturn NULL;", " \t\t}", " no_copy:", " \t\tnewentry.filename = estrndup(newentry.filename, newentry.filename_len);", " ", " \t\tif (newentry.metadata) {", " \t\t\tzval *t;", " ", " \t\t\tt = newentry.metadata;", " \t\t\tALLOC_ZVAL(newentry.metadata);", " \t\t\t*newentry.metadata = *t;", " \t\t\tzval_copy_ctor(newentry.metadata);", " #if PHP_VERSION_ID < 50300", " \t\t\tnewentry.metadata->refcount = 1;", " #else", " \t\t\tZ_SET_REFCOUNT_P(newentry.metadata, 1);", " #endif", " ", " \t\t\tnewentry.metadata_str.c = NULL;", " \t\t\tnewentry.metadata_str.len = 0;", " \t\t}", " ", " \t\tnewentry.is_zip = phar->is_zip;", " \t\tnewentry.is_tar = phar->is_tar;", " ", " \t\tif (newentry.is_tar) {", " \t\t\tnewentry.tar_type = (entry->is_dir ? TAR_DIR : TAR_FILE);", " \t\t}", " ", " \t\tnewentry.is_modified = 1;", " \t\tnewentry.phar = phar;", " \t\tnewentry.old_flags = newentry.flags & ~PHAR_ENT_COMPRESSION_MASK;  ", " \t\tphar_set_inode(&newentry TSRMLS_CC);", " \t\tzend_hash_add(&(phar->manifest), newentry.filename, newentry.filename_len, (void*)&newentry, sizeof(phar_entry_info), NULL);", " \t\tphar_add_virtual_dirs(phar, newentry.filename, newentry.filename_len TSRMLS_CC);", " \t}", " ", " \tif ((ret = phar_rename_archive(phar, ext, 0 TSRMLS_CC))) {", " \t\treturn ret;", " \t} else {", "                 zend_hash_destroy(&(phar->manifest));", "                 zend_hash_destroy(&(phar->mounted_dirs));", "                 zend_hash_destroy(&(phar->virtual_dirs));", "               php_stream_close(phar->fp);", "                if (phar->fp) {", "                        php_stream_close(phar->fp);", "                }", "                 efree(phar->fname);", "                 efree(phar);", "                 return NULL;", "  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["static RList *symbols(RBinFile *bf) {", "RList *res = r_list_newf ((RListFree)r_bin_symbol_free);", "r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);", "RCoreSymCacheElement *element = bf->o->bin_obj;", "size_t i;", "HtUU *hash = ht_uu_new0 ();", "if (!hash) {", "return res;", "}", "bool found = false;", "for (i = 0; i < element->hdr->n_lined_symbols; i++) {", "RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];", "if (!sym) {", "break;", "}", "ht_uu_find (hash, sym->paddr, &found);", "if (found) {", "continue;", "}", "RBinSymbol *s = bin_symbol_from_symbol (element, sym);", "if (s) {", "r_list_append (res, s);", "ht_uu_insert (hash, sym->paddr, 1);", "}", "}", "if (element->symbols) {", "for (i = 0; i < element->hdr->n_symbols; i++) {", "RCoreSymCacheElementSymbol *sym = &element->symbols[i];", "ht_uu_find (hash, sym->paddr, &found);", "if (found) {", "continue;", "}", "RBinSymbol *s = bin_symbol_from_symbol (element, sym);", "if (s) {", "r_list_append (res, s);", "}", "}", "}", "ht_uu_free (hash);", "return res;", "}"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dnxhd_find_frame_end(DNXHDParserContext *dctx,", "                                 const uint8_t *buf, int buf_size)", " {", "     ParseContext *pc = &dctx->pc;", "     uint64_t state = pc->state64;", "     int pic_found = pc->frame_start_found;", "     int i = 0;", " ", "     if (!pic_found) {", "         for (i = 0; i < buf_size; i++) {", "             state = (state << 8) | buf[i];", "             if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {", "                 i++;", "                 pic_found = 1;", "                 dctx->cur_byte = 0;", "                 dctx->remaining = 0;", "                 break;", "             }", "         }", "     }", " ", "     if (pic_found && !dctx->remaining) {", "         if (!buf_size)  ", "             return 0;", "         for (; i < buf_size; i++) {", "             dctx->cur_byte++;", "             state = (state << 8) | buf[i];", " ", "             if (dctx->cur_byte == 24) {", "                 dctx->h = (state >> 32) & 0xFFFF;", "             } else if (dctx->cur_byte == 26) {", "                  dctx->w = (state >> 32) & 0xFFFF;", "              } else if (dctx->cur_byte == 42) {", "                  int cid = (state >> 32) & 0xFFFFFFFF;", "                 int remaining;", "  ", "                  if (cid <= 0)", "                      continue;", "  ", "                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);", "                if (dctx->remaining <= 0) {", "                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                    if (dctx->remaining <= 0)", "                        return dctx->remaining;", "                 remaining = avpriv_dnxhd_get_frame_size(cid);", "                 if (remaining <= 0) {", "                     remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);", "                     if (remaining <= 0)", "                         continue;", "                  }", "                 dctx->remaining = remaining;", "                  if (buf_size - i + 47 >= dctx->remaining) {", "                      int remaining = dctx->remaining;", "  ", "                     pc->frame_start_found = 0;", "                     pc->state64 = -1;", "                     dctx->cur_byte = 0;", "                     dctx->remaining = 0;", "                     return remaining;", "                 } else {", "                     dctx->remaining -= buf_size;", "                 }", "             }", "         }", "     } else if (pic_found) {", "         if (dctx->remaining > buf_size) {", "             dctx->remaining -= buf_size;", "         } else {", "             int remaining = dctx->remaining;", " ", "             pc->frame_start_found = 0;", "             pc->state64 = -1;", "             dctx->cur_byte = 0;", "             dctx->remaining = 0;", "             return remaining;", "         }", "     }", "     pc->frame_start_found = pic_found;", "     pc->state64 = state;", "     return END_NOT_FOUND;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long ContentEncoding::ParseCompressionEntry(long long start, long long size,", "  IMkvReader* pReader,", "  ContentCompression* compression) {", "   assert(pReader);", "   assert(compression);", " ", "  long long pos = start;", "  const long long stop = start + size;", " ", "  bool valid = false;", " ", "  while (pos < stop) {", "  long long id, size;", "  const long status = ParseElementHeader(pReader, pos, stop, id, size);", "  if (status < 0)  ", "  return status;", " ", "  if (id == 0x254) {", "  long long algo = UnserializeUInt(pReader, pos, size);", "  if (algo < 0)", "  return E_FILE_FORMAT_INVALID;", "       compression->algo = algo;", "       valid = true;", "  } else if (id == 0x255) {", "  if (size <= 0)", " ", "          return E_FILE_FORMAT_INVALID;", "  ", "        const size_t buflen = static_cast<size_t>(size);", "      typedef unsigned char* buf_t;", "      const buf_t buf = new (std::nothrow) unsigned char[buflen];", "       unsigned char* buf = SafeArrayAlloc<unsigned char>(1, buflen);", "        if (buf == NULL)", "          return -1;", "  ", "  const int read_status =", "           pReader->Read(pos, static_cast<long>(buflen), buf);", "  if (read_status) {", "  delete[] buf;", "  return status;", "  }", " ", "       compression->settings = buf;", "       compression->settings_len = buflen;", " ", "      }", "  ", "      pos += size;   ", "    assert(pos <= stop);", "     if (pos > stop)", "       return E_FILE_FORMAT_INVALID;", "    }", "  ", "  if (!valid)", "  return E_FILE_FORMAT_INVALID;", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,", " \t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,", " \t\t\t\t\t      struct desc_ptr *ptr))", " {", " \tstruct desc_ptr desc_ptr;", " ", " \tif (ctxt->mode == X86EMUL_MODE_PROT64)", " \t\tctxt->op_bytes = 8;", " \tget(ctxt, &desc_ptr);", " \tif (ctxt->op_bytes == 2) {", " \t\tctxt->op_bytes = 4;", " \t\tdesc_ptr.address &= 0x00ffffff;", "  \t}", "  \t ", "  \tctxt->dst.type = OP_NONE;", "\treturn segmented_write(ctxt, ctxt->dst.addr.mem,", "\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);", " \treturn segmented_write_std(ctxt, ctxt->dst.addr.mem,", " \t\t\t\t   &desc_ptr, 2 + ctxt->op_bytes);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["TEST(CudnnRNNOpsTest, ForwardLstm_ShapeFn) {", "int seq_length = 2;", "int batch_size = 3;", "int num_units = 4;", "int num_layers = 5;", "int dir_count = 1;", "std::vector<int> input_shape = {seq_length, batch_size, num_units};", "std::vector<int> input_h_shape = {num_layers * dir_count, batch_size,", "num_units};", "std::vector<int> output_shape = {seq_length, batch_size,", "num_units * dir_count};", "auto shape_to_str = [](const std::vector<int>& v) {", "return strings::StrCat(\"[\", absl::StrJoin(v, \",\"), \"]\");", "};", "string input_shapes_desc = strings::StrCat(", "shape_to_str(input_shape), \";\", shape_to_str(input_h_shape), \";\",", "shape_to_str(input_h_shape), \";\", \"[?]\");", "string output_shapes_desc = \"[d0_0,d0_1,d1_2];in1;in1;?\";", "", "ShapeInferenceTestOp op(\"CudnnRNN\");", "TF_ASSERT_OK(NodeDefBuilder(\"test\", \"CudnnRNN\")", ".Input({\"input\", 0, DT_FLOAT})", ".Input({\"input_h\", 0, DT_FLOAT})", ".Input({\"input_c\", 0, DT_FLOAT})", ".Input({\"params\", 0, DT_FLOAT})", ".Attr(\"rnn_mode\", \"lstm\")", ".Attr(\"input_mode\", \"auto_select\")", ".Attr(\"direction\", \"unidirectional\")", ".Finalize(&op.node_def));", "INFER_OK(op, input_shapes_desc, output_shapes_desc);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)", " {", "   ", " ", "  dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);", " ", "     WORD32 i4_err_status = 0;", "     UWORD8 *pu1_buf = NULL;", "     WORD32 buflen;", "     UWORD32 u4_max_ofst, u4_length_of_start_code = 0;", " ", "     UWORD32 bytes_consumed = 0;", "     UWORD32 cur_slice_is_nonref = 0;", "     UWORD32 u4_next_is_aud;", "     UWORD32 u4_first_start_code_found = 0;", "     WORD32 ret = 0,api_ret_value = IV_SUCCESS;", "     WORD32 header_data_left = 0,frame_data_left = 0;", "     UWORD8 *pu1_bitstrm_buf;", "  ivd_video_decode_ip_t *ps_dec_ip;", "  ivd_video_decode_op_t *ps_dec_op;", " ", "     ithread_set_name((void*)\"Parse_thread\");", " ", "     ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;", "     ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;", " ", "  {", "         UWORD32 u4_size;", "         u4_size = ps_dec_op->u4_size;", "         memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));", "         ps_dec_op->u4_size = u4_size;", "  }", " ", "     ps_dec->pv_dec_out = ps_dec_op;", "  if(ps_dec->init_done != 1)", "  {", "  return IV_FAIL;", "  }", " ", "   ", "     DATA_SYNC();", " ", "  if(0 == ps_dec->u1_flushfrm)", "  {", "  if(ps_dec_ip->pv_stream_buffer == NULL)", "  {", "             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;", "             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;", "  return IV_FAIL;", "  }", "  if(ps_dec_ip->u4_num_Bytes <= 0)", "  {", "             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;", "             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;", "  return IV_FAIL;", " ", "  }", "  }", "     ps_dec->u1_pic_decode_done = 0;", " ", "     ps_dec_op->u4_num_bytes_consumed = 0;", " ", "     ps_dec->ps_out_buffer = NULL;", " ", "  if(ps_dec_ip->u4_size", "  >= offsetof(ivd_video_decode_ip_t, s_out_buffer))", "         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;", " ", "     ps_dec->u4_fmt_conv_cur_row = 0;", " ", "     ps_dec->u4_output_present = 0;", "     ps_dec->s_disp_op.u4_error_code = 1;", "     ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;", "  if(0 == ps_dec->u4_share_disp_buf", "  && ps_dec->i4_decode_header == 0)", "  {", "         UWORD32 i;", "  if(ps_dec->ps_out_buffer->u4_num_bufs == 0)", "  {", "             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;", "             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;", "  return IV_FAIL;", "  }", " ", "  for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)", "  {", "  if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)", "  {", "                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;", "                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;", "  return IV_FAIL;", "  }", " ", "  if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)", "  {", "                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;", "                 ps_dec_op->u4_error_code |=", "                                 IVD_DISP_FRM_ZERO_OP_BUF_SIZE;", "  return IV_FAIL;", "  }", "  }", "  }", " ", "  if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)", "  {", "         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;", "  return IV_FAIL;", "  }", " ", "   ", "     ps_dec->u4_ts = ps_dec_ip->u4_ts;", " ", "     ps_dec_op->u4_error_code = 0;", "     ps_dec_op->e_pic_type = -1;", "     ps_dec_op->u4_output_present = 0;", "     ps_dec_op->u4_frame_decoded_flag = 0;", " ", "     ps_dec->i4_frametype = -1;", "     ps_dec->i4_content_type = -1;", "   ", "  {", "  if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)", "  {", "             ps_dec->u1_top_bottom_decoded = 0;", "  }", "  }", "     ps_dec->u4_slice_start_code_found = 0;", " ", "   ", " ", "  if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1", "  && ps_dec->u1_flushfrm == 0)", "  {", "         UWORD32 i;", " ", "         WORD32 disp_avail = 0, free_id;", " ", "   ", "   ", "  for(i = 0; i < ps_dec->u1_pic_bufs; i++)", "  {", "  if(0 == ps_dec->u4_disp_buf_mapping[i]", "  || 1 == ps_dec->u4_disp_buf_to_be_freed[i])", "  {", "                 disp_avail = 1;", "  break;", "  }", " ", "  }", " ", "  if(0 == disp_avail)", "  {", "   ", " ", "             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;", "             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);", "  return (IV_FAIL);", "  }", " ", "  while(1)", "  {", "  pic_buffer_t *ps_pic_buf;", "             ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(", "  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);", " ", "  if(ps_pic_buf == NULL)", "  {", "                 UWORD32 i, display_queued = 0;", " ", "   ", "  for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)", "  {", "  if(0 != ps_dec->u4_disp_buf_mapping[i])", "  {", "                         display_queued = 1;", "  break;", "  }", "  }", "   ", " ", "  if(1 == display_queued)", "  {", "   ", "                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;", "                     ps_dec_op->u4_error_code |= (1", "  << IVD_UNSUPPORTEDPARAM);", "  return (IV_FAIL);", "  }", "  }", "  else", "  {", "   ", "  if(1 == ps_dec->u4_disp_buf_mapping[free_id])", "  {", "                     ih264_buf_mgr_set_status(", "  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                     free_id,", "                                     BUF_MGR_IO);", "  }", "  else", "  {", "   ", "                     ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                           free_id,", "                                           BUF_MGR_IO);", "  break;", "  }", "  }", "  }", " ", "  }", " ", "  if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)", "  {", " ", "         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,", "  &(ps_dec->s_disp_op));", "  if(0 == ps_dec->s_disp_op.u4_error_code)", "  {", "             ps_dec->u4_fmt_conv_cur_row = 0;", "             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;", "             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),", "                                   ps_dec->u4_fmt_conv_cur_row,", "                                   ps_dec->u4_fmt_conv_num_rows);", "             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;", "             ps_dec->u4_output_present = 1;", " ", "  }", "         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));", " ", "         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;", "         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;", " ", "         ps_dec_op->u4_new_seq = 0;", " ", "         ps_dec_op->u4_output_present = ps_dec->u4_output_present;", "         ps_dec_op->u4_progressive_frame_flag =", "                         ps_dec->s_disp_op.u4_progressive_frame_flag;", "         ps_dec_op->e_output_format =", "                         ps_dec->s_disp_op.e_output_format;", "         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;", "         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;", "         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;", "         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;", " ", "   ", "         ps_dec_op->u4_is_ref_flag = -1;", "         ps_dec_op->e_pic_type = IV_NA_FRAME;", "         ps_dec_op->u4_frame_decoded_flag = 0;", " ", "  if(0 == ps_dec->s_disp_op.u4_error_code)", "  {", "  return (IV_SUCCESS);", "  }", "  else", "  return (IV_FAIL);", " ", "  }", "  if(ps_dec->u1_res_changed == 1)", "  {", "   ", "         ih264d_init_decoder(ps_dec);", "  }", " ", "     ps_dec->u4_prev_nal_skipped = 0;", " ", "     ps_dec->u2_cur_mb_addr = 0;", "     ps_dec->u2_total_mbs_coded = 0;", "     ps_dec->u2_cur_slice_num = 0;", "     ps_dec->cur_dec_mb_num = 0;", "     ps_dec->cur_recon_mb_num = 0;", "     ps_dec->u4_first_slice_in_pic = 2;", "     ps_dec->u1_slice_header_done = 0;", "     ps_dec->u1_dangling_field = 0;", " ", "     ps_dec->u4_dec_thread_created = 0;", "     ps_dec->u4_bs_deblk_thread_created = 0;", "     ps_dec->u4_cur_bs_mb_num = 0;", "     ps_dec->u4_start_recon_deblk  = 0;", " ", "     DEBUG_THREADS_PRINTF(\" Starting process call\\n\");", " ", " ", "     ps_dec->u4_pic_buf_got = 0;", " ", "  do", "  {", "         WORD32 buf_size;", " ", "         pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer", "  + ps_dec_op->u4_num_bytes_consumed;", " ", "         u4_max_ofst = ps_dec_ip->u4_num_Bytes", "  - ps_dec_op->u4_num_bytes_consumed;", " ", "   ", "  if((NULL == ps_dec->pu1_bits_buf_dynamic) &&", "  (ps_dec->i4_header_decoded & 1))", "  {", "             WORD32 size;", " ", "  void *pv_buf;", "  void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;", "             size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);", "             pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);", "             RETURN_IF((NULL == pv_buf), IV_FAIL);", "             ps_dec->pu1_bits_buf_dynamic = pv_buf;", "             ps_dec->u4_dynamic_bits_buf_size = size;", "  }", " ", "  if(ps_dec->pu1_bits_buf_dynamic)", "  {", "             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;", "             buf_size = ps_dec->u4_dynamic_bits_buf_size;", "  }", "  else", "  {", "             pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;", "             buf_size = ps_dec->u4_static_bits_buf_size;", "  }", " ", "         u4_next_is_aud = 0;", " ", "         buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,", "  &u4_length_of_start_code,", "  &u4_next_is_aud);", " ", "  if(buflen == -1)", "             buflen = 0;", "   ", "         buflen = MIN(buflen, buf_size);", " ", "         bytes_consumed = buflen + u4_length_of_start_code;", "         ps_dec_op->u4_num_bytes_consumed += bytes_consumed;", " ", "  {", "             UWORD8 u1_firstbyte, u1_nal_ref_idc;", " ", "  if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)", "  {", "                 u1_firstbyte = *(pu1_buf + u4_length_of_start_code);", "                 u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));", "  if(u1_nal_ref_idc == 0)", "  {", "   ", "                     cur_slice_is_nonref = 1;", "  continue;", "  }", "  else", "  {", "  if(1 == cur_slice_is_nonref)", "  {", "   ", "                         ps_dec_op->u4_num_bytes_consumed -=", "                                         bytes_consumed;", "                         ps_dec_op->e_pic_type = IV_B_FRAME;", "                         ps_dec_op->u4_error_code =", "                                         IVD_DEC_FRM_SKIPPED;", "                         ps_dec_op->u4_error_code |= (1", "  << IVD_UNSUPPORTEDPARAM);", "                         ps_dec_op->u4_frame_decoded_flag = 0;", "                         ps_dec_op->u4_size =", "  sizeof(ivd_video_decode_op_t);", "   ", "                         ih264d_signal_decode_thread(ps_dec);", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "                             ih264d_signal_bs_deblk_thread(ps_dec);", "  }", " ", "  return (IV_FAIL);", "  }", "  }", " ", "  }", " ", "  }", " ", " ", "  if(buflen)", "  {", "             memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,", "                    buflen);", "   ", "  if((buflen + 8) < buf_size)", "  {", "                 memset(pu1_bitstrm_buf + buflen, 0, 8);", "  }", "             u4_first_start_code_found = 1;", " ", "  }", "  else", "  {", "   ", " ", "  if(u4_first_start_code_found == 0)", "  {", "   ", " ", "                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;", "                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;", " ", "  if(ps_dec->u4_pic_buf_got == 0)", "  {", " ", "                     ih264d_fill_output_struct_from_context(ps_dec,", "                                                            ps_dec_op);", " ", "                     ps_dec_op->u4_error_code = ps_dec->i4_error_code;", "                     ps_dec_op->u4_frame_decoded_flag = 0;", " ", "  return (IV_FAIL);", "  }", "  else", "  {", "                     ps_dec->u1_pic_decode_done = 1;", "  continue;", "  }", "  }", "  else", "  {", "   ", "                 frame_data_left = 0;", "  continue;", "  }", " ", "  }", " ", "         ps_dec->u4_return_to_app = 0;", "         ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,", "                               pu1_bitstrm_buf, buflen);", "  if(ret != OK)", "  {", "             UWORD32 error =  ih264d_map_error(ret);", "             ps_dec_op->u4_error_code = error | ret;", "             api_ret_value = IV_FAIL;", " ", " ", "              if((ret == IVD_RES_CHANGED)", "                              || (ret == IVD_MEM_ALLOC_FAILED)", "                              || (ret == ERROR_UNAVAIL_PICBUF_T)", "                            || (ret == ERROR_UNAVAIL_MVBUF_T))", "                             || (ret == ERROR_UNAVAIL_MVBUF_T)", "                             || (ret == ERROR_INV_SPS_PPS_T))", "              {", "                 ps_dec->u4_slice_start_code_found = 0;", "                  break;", "              }", "  ", "  if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))", "  {", "                 ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;", "                 api_ret_value = IV_FAIL;", "  break;", "  }", " ", "  if(ret == ERROR_IN_LAST_SLICE_OF_PIC)", "  {", "                 api_ret_value = IV_FAIL;", "  break;", "  }", " ", "  }", " ", "  if(ps_dec->u4_return_to_app)", "  {", "   ", "             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;", "             ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;", "             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);", "             ps_dec_op->u4_frame_decoded_flag = 0;", "             ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);", "   ", "             ih264d_signal_decode_thread(ps_dec);", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "                 ih264d_signal_bs_deblk_thread(ps_dec);", "  }", "  return (IV_FAIL);", " ", "  }", " ", " ", " ", "         header_data_left = ((ps_dec->i4_decode_header == 1)", "  && (ps_dec->i4_header_decoded != 3)", "  && (ps_dec_op->u4_num_bytes_consumed", "  < ps_dec_ip->u4_num_Bytes));", "         frame_data_left = (((ps_dec->i4_decode_header == 0)", "  && ((ps_dec->u1_pic_decode_done == 0)", "  || (u4_next_is_aud == 1)))", "  && (ps_dec_op->u4_num_bytes_consumed", "  < ps_dec_ip->u4_num_Bytes));", "  }", "  while(( header_data_left == 1)||(frame_data_left == 1));", " ", "  if((ps_dec->u4_slice_start_code_found == 1)", "  && (ret != IVD_MEM_ALLOC_FAILED)", "  && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "         WORD32 num_mb_skipped;", "         WORD32 prev_slice_err;", "  pocstruct_t temp_poc;", "         WORD32 ret1;", " ", "         num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  - ps_dec->u2_total_mbs_coded;", " ", "  if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))", "             prev_slice_err = 1;", "  else", "             prev_slice_err = 2;", " ", "         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,", "  &temp_poc, prev_slice_err);", " ", "  if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))", "  {", "  return IV_FAIL;", "  }", "  }", " ", " ", "      if((ret == IVD_RES_CHANGED)", "                      || (ret == IVD_MEM_ALLOC_FAILED)", "                      || (ret == ERROR_UNAVAIL_PICBUF_T)", "                    || (ret == ERROR_UNAVAIL_MVBUF_T))", "                     || (ret == ERROR_UNAVAIL_MVBUF_T)", "                     || (ret == ERROR_INV_SPS_PPS_T))", "      {", "  ", "           ", "         ih264d_signal_decode_thread(ps_dec);", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "             ih264d_signal_bs_deblk_thread(ps_dec);", "  }", "   ", "  if(ret == IVD_RES_CHANGED)", "  {", "             ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;", "  }", "  return IV_FAIL;", "  }", " ", " ", "  if(ps_dec->u1_separate_parse)", "  {", "   ", "  if(ps_dec->u4_num_cores == 2)", "  {", " ", "   ", "  if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))", "  {", "                 UWORD32 u4_num_mbs,u4_max_addr;", "  tfr_ctxt_t s_tfr_ctxt;", "  tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;", "  pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;", " ", "   ", "                 u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;", "                 ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;", " ", " ", "                 ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,", "                                            ps_dec->u2_frm_wd_in_mbs, 0);", " ", " ", "                 u4_num_mbs = u4_max_addr", "  - ps_dec->u4_cur_deblk_mb_num + 1;", " ", "                 DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);", " ", "  if(u4_num_mbs != 0)", "                     ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,", "                                                    ps_tfr_cxt,1);", " ", "                 ps_dec->u4_start_recon_deblk  = 0;", " ", "  }", " ", "  }", " ", "   ", "         ih264d_signal_decode_thread(ps_dec);", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "             ih264d_signal_bs_deblk_thread(ps_dec);", "  }", "  }", " ", " ", "     DATA_SYNC();", " ", " ", "  if((ps_dec_op->u4_error_code & 0xff)", "  != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)", "  {", "         ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;", "         ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;", "  }", " ", "  if(ps_dec->i4_header_decoded != 3)", "  {", "         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);", " ", "  }", " ", "  if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)", "  {", "         ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);", " ", "  }", "  if(ps_dec->u4_prev_nal_skipped)", "  {", "   ", "         ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;", "         ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);", "         ps_dec_op->u4_frame_decoded_flag = 0;", "         ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "             ih264d_signal_bs_deblk_thread(ps_dec);", "  }", "  return (IV_FAIL);", " ", "  }", " ", "  if((ps_dec->u4_slice_start_code_found == 1)", "  && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))", "  {", "   ", " ", "  if(ps_dec->ps_cur_slice->u1_field_pic_flag)", "  {", "  if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)", "  {", "                 ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;", "  }", "  else", "  {", "                 ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;", "  }", "  }", " ", "   ", "  if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)", "  {", "   ", "             ret = ih264d_deblock_display(ps_dec);", "  if(ret != 0)", "  {", "  return IV_FAIL;", "  }", "  }", " ", " ", "   ", "  if(ps_dec->i4_header_decoded == 3)", "  {", "             ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;", "  }", " ", "   ", "  if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)", "  {", "             ps_dec->i4_frametype = IV_IDR_FRAME;", "  }", "  else if(ps_dec->i4_pic_type == B_SLICE)", "  {", "             ps_dec->i4_frametype = IV_B_FRAME;", "  }", "  else if(ps_dec->i4_pic_type == P_SLICE)", "  {", "             ps_dec->i4_frametype = IV_P_FRAME;", "  }", "  else if(ps_dec->i4_pic_type == I_SLICE)", "  {", "             ps_dec->i4_frametype = IV_I_FRAME;", "  }", "  else", "  {", "             H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");", "  }", " ", "         ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;", " ", "         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;", "         ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded", "  - ps_dec->ps_cur_slice->u1_field_pic_flag;", " ", "  }", " ", "   ", "  if(ps_dec->u4_num_cores == 3)", "  {", "         ih264d_signal_bs_deblk_thread(ps_dec);", "  }", " ", " ", "  {", "   ", " ", "  if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)", "  && ps_dec->u1_init_dec_flag)", "  {", " ", "             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,", "  &(ps_dec->s_disp_op));", "  if(0 == ps_dec->s_disp_op.u4_error_code)", "  {", "                 ps_dec->u4_fmt_conv_cur_row = 0;", "                 ps_dec->u4_output_present = 1;", "  }", "  }", " ", "         ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);", " ", "   ", "  if(ps_dec->u4_output_present &&", "  (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))", "  {", "             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht", "  - ps_dec->u4_fmt_conv_cur_row;", "             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),", "                                   ps_dec->u4_fmt_conv_cur_row,", "                                   ps_dec->u4_fmt_conv_num_rows);", "             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;", "  }", " ", "         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));", "  }", " ", "  if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)", "  {", "         ps_dec_op->u4_progressive_frame_flag = 1;", "  if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))", "  {", "  if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)", "  && (0 == ps_dec->ps_sps->u1_mb_aff_flag))", "                 ps_dec_op->u4_progressive_frame_flag = 0;", " ", "  }", "  }", " ", "   ", "     DATA_SYNC();", " ", "     H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",", "                          ps_dec_op->u4_num_bytes_consumed);", "  return api_ret_value;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(", "     JNIEnv* env,", "     jobject java_website_settings_pop,", "     content::WebContents* web_contents) {", "   content::NavigationEntry* nav_entry =", "       web_contents->GetController().GetVisibleEntry();", "   if (nav_entry == NULL)", "     return;", " ", "   url_ = nav_entry->GetURL();", " ", "   popup_jobject_.Reset(env, java_website_settings_pop);", " ", "   presenter_.reset(new WebsiteSettings(", "        this,", "        Profile::FromBrowserContext(web_contents->GetBrowserContext()),", "        TabSpecificContentSettings::FromWebContents(web_contents),", "      InfoBarService::FromWebContents(web_contents),", "       web_contents,", "        nav_entry->GetURL(),", "        nav_entry->GetSSL(),", "        content::CertStore::GetInstance()));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int vrend_create_shader(struct vrend_context *ctx,", "                         uint32_t handle,", "                         const struct pipe_stream_output_info *so_info,", "                         const char *shd_text, uint32_t offlen, uint32_t num_tokens,", "                         uint32_t type, uint32_t pkt_length)", " {", "    struct vrend_shader_selector *sel = NULL;", "    int ret_handle;", "    bool new_shader = true, long_shader = false;", "    bool finished = false;", "    int ret;", " ", "    if (type > PIPE_SHADER_GEOMETRY)", "       return EINVAL;", " ", "    if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)", "       new_shader = false;", "    else if (((offlen + 3) / 4) > pkt_length)", "       long_shader = true;", " ", "     ", "    if (ctx->sub->long_shader_in_progress_handle[type]) {", "       if (new_shader == true)", "          return EINVAL;", "       if (handle != ctx->sub->long_shader_in_progress_handle[type])", "          return EINVAL;", "    }", " ", "    if (new_shader) {", "      sel = vrend_create_shader_state(ctx, so_info, type);", "      if (sel == NULL)", "        return ENOMEM;", " ", "      if (long_shader) {", "         sel->buf_len = ((offlen + 3) / 4) * 4;  ", "         sel->tmp_buf = malloc(sel->buf_len);", "         if (!sel->tmp_buf) {", "            ret = ENOMEM;", "            goto error;", "         }", "         memcpy(sel->tmp_buf, shd_text, pkt_length * 4);", "         sel->buf_offset = pkt_length * 4;", "         ctx->sub->long_shader_in_progress_handle[type] = handle;", "      } else", "         finished = true;", "    } else {", "       sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);", "       if (!sel) {", "          fprintf(stderr, \"got continuation without original shader %d\\n\", handle);", "          ret = EINVAL;", "          goto error;", "       }", " ", "       offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;", "       if (offlen != sel->buf_offset) {", "          fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",", "                  offlen, sel->buf_offset);", "           ret = EINVAL;", "           goto error;", "        }", " ", "        ", "       if (pkt_length * 4 < pkt_length ||", "           pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||", "           pkt_length * 4 + sel->buf_offset < sel->buf_offset) {", "             ret = EINVAL;", "             goto error;", "           }", " ", "        if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {", "           fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",", "                   pkt_length * 4 + sel->buf_offset, sel->buf_len);", "          shd_text = sel->tmp_buf;", "       }", "    }", " ", "    if (finished) {", "       struct tgsi_token *tokens;", " ", "       tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));", "       if (!tokens) {", "          ret = ENOMEM;", "          goto error;", "       }", " ", "       if (vrend_dump_shaders)", "          fprintf(stderr,\"shader\\n%s\\n\", shd_text);", "       if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {", "          free(tokens);", "          ret = EINVAL;", "          goto error;", "       }", " ", "       if (vrend_finish_shader(ctx, sel, tokens)) {", "          free(tokens);", "          ret = EINVAL;", "          goto error;", "       } else {", "          free(sel->tmp_buf);", "          sel->tmp_buf = NULL;", "       }", "       free(tokens);", "       ctx->sub->long_shader_in_progress_handle[type] = 0;", "    }", " ", "    if (new_shader) {", "       ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);", "       if (ret_handle == 0) {", "          ret = ENOMEM;", "          goto error;", "       }", "    }", " ", "    return 0;", " ", " error:", "    if (new_shader)", "       vrend_destroy_shader_selector(sel);", "    else", "       vrend_renderer_object_destroy(ctx, handle);", " ", "    return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static noinline void key_gc_unused_keys(struct list_head *keys)", " {", " \twhile (!list_empty(keys)) {", " \t\tstruct key *key =", " \t\t\tlist_entry(keys->next, struct key, graveyard_link);", " \t\tlist_del(&key->graveyard_link);", " ", "  \t\tkdebug(\"- %u\", key->serial);", "  \t\tkey_check(key);", "  ", " \t\t ", "\t\tif (key->type->destroy)", " \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&", " \t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&", " \t\t    key->type->destroy)", "  \t\t\tkey->type->destroy(key);", "  ", "  \t\tsecurity_key_free(key);", " ", " \t\t ", " \t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {", " \t\t\tspin_lock(&key->user->lock);", " \t\t\tkey->user->qnkeys--;", " \t\t\tkey->user->qnbytes -= key->quotalen;", " \t\t\tspin_unlock(&key->user->lock);", " \t\t}", " ", " \t\tatomic_dec(&key->user->nkeys);", " \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))", " \t\t\tatomic_dec(&key->user->nikeys);", " ", " \t\tkey_user_put(key->user);", " ", " \t\tkfree(key->description);", " ", " #ifdef KEY_DEBUGGING", " \t\tkey->magic = KEY_DEBUG_MAGIC_X;", " #endif", " \t\tkmem_cache_free(key_jar, key);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" icmp6_nodeinfo_print(netdissect_options *ndo, u_int icmp6len, const u_char *bp, const u_char *ep)", " {", " \tconst struct icmp6_nodeinfo *ni6;", " \tconst struct icmp6_hdr *dp;", " \tconst u_char *cp;", " \tsize_t siz, i;", " \tint needcomma;", " ", " \tif (ep < bp)", " \t\treturn;", " \tdp = (const struct icmp6_hdr *)bp;", " \tni6 = (const struct icmp6_nodeinfo *)bp;", " \tsiz = ep - bp;", " ", " \tswitch (ni6->ni_type) {", " \tcase ICMP6_NI_QUERY:", " \t\tif (siz == sizeof(*dp) + 4) {", " \t\t\t ", " \t\t\tND_PRINT((ndo,\" who-are-you request\"));", " \t\t\tbreak;", " \t\t}", " \t\tND_PRINT((ndo,\" node information query\"));", " ", " \t\tND_TCHECK2(*dp, sizeof(*ni6));", " \t\tni6 = (const struct icmp6_nodeinfo *)dp;", " \t\tND_PRINT((ndo,\" (\"));\t ", " \t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {", " \t\tcase NI_QTYPE_NOOP:", " \t\t\tND_PRINT((ndo,\"noop\"));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_SUPTYPES:", " \t\t\tND_PRINT((ndo,\"supported qtypes\"));", " \t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);", " \t\t\tif (i)", " \t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_FQDN:", " \t\t\tND_PRINT((ndo,\"DNS name\"));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_NODEADDR:", " \t\t\tND_PRINT((ndo,\"node addresses\"));", " \t\t\ti = ni6->ni_flags;", " \t\t\tif (!i)", " \t\t\t\tbreak;", " \t\t\t ", " \t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s]\",", " \t\t\t    (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",", " \t\t\t    (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",", " \t\t\t    (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",", " \t\t\t    (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",", " \t\t\t    (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",", " \t\t\t    (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\"));", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tND_PRINT((ndo,\"unknown\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\tif (ni6->ni_qtype == NI_QTYPE_NOOP ||", " \t\t    ni6->ni_qtype == NI_QTYPE_SUPTYPES) {", " \t\t\tif (siz != sizeof(*ni6))", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid len\"));", " \t\t\t ", " \t\t\tND_PRINT((ndo,\")\"));", " \t\t\tbreak;", " \t\t}", " ", " ", " \t\t ", " \t\tif (siz == sizeof(*ni6)) {", " \t\t\tND_PRINT((ndo,\", 03 draft\"));", " \t\t\t ", " \t\t\tND_PRINT((ndo,\")\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\tswitch (ni6->ni_code) {", " \t\tcase ICMP6_NI_SUBJ_IPV6:", " \t\t\tif (!ND_TTEST2(*dp,", " \t\t\t    sizeof(*ni6) + sizeof(struct in6_addr)))", " \t\t\t\tbreak;", " \t\t\tif (siz != sizeof(*ni6) + sizeof(struct in6_addr)) {", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tND_PRINT((ndo,\", subject=%s\",", "                                   ip6addr_string(ndo, ni6 + 1)));", " \t\t\tbreak;", " \t\tcase ICMP6_NI_SUBJ_FQDN:", " \t\t\tND_PRINT((ndo,\", subject=DNS name\"));", " \t\t\tcp = (const u_char *)(ni6 + 1);", " \t\t\tif (cp[0] == ep - cp - 1) {", " \t\t\t\t ", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));", " \t\t\t\tcp++;", " \t\t\t\tND_PRINT((ndo,\", \\\"\"));", " \t\t\t\twhile (cp < ep) {", " \t\t\t\t\tsafeputchar(ndo, *cp);", " \t\t\t\t\tcp++;", " \t\t\t\t}", " \t\t\t\tND_PRINT((ndo,\"\\\"\"));", " \t\t\t} else", " \t\t\t\tdnsname_print(ndo, cp, ep);", " \t\t\tbreak;", " \t\tcase ICMP6_NI_SUBJ_IPV4:", " \t\t\tif (!ND_TTEST2(*dp, sizeof(*ni6) + sizeof(struct in_addr)))", " \t\t\t\tbreak;", " \t\t\tif (siz != sizeof(*ni6) + sizeof(struct in_addr)) {", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid subject len\"));", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tND_PRINT((ndo,\", subject=%s\",", "                                   ipaddr_string(ndo, ni6 + 1)));", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tND_PRINT((ndo,\", unknown subject\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\t ", " \t\tND_PRINT((ndo,\")\"));", " \t\tbreak;", " ", " \tcase ICMP6_NI_REPLY:", " \t\tif (icmp6len > siz) {", " \t\t\tND_PRINT((ndo,\"[|icmp6: node information reply]\"));", " \t\t\tbreak;", " \t\t}", "  ", "  \t\tneedcomma = 0;", "  ", " \t\tND_TCHECK2(*dp, sizeof(*ni6));", "  \t\tni6 = (const struct icmp6_nodeinfo *)dp;", "  \t\tND_PRINT((ndo,\" node information reply\"));", "  \t\tND_PRINT((ndo,\" (\"));\t ", " \t\tswitch (ni6->ni_code) {", " \t\tcase ICMP6_NI_SUCCESS:", " \t\t\tif (ndo->ndo_vflag) {", " \t\t\t\tND_PRINT((ndo,\"success\"));", " \t\t\t\tneedcomma++;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase ICMP6_NI_REFUSED:", " \t\t\tND_PRINT((ndo,\"refused\"));", " \t\t\tneedcomma++;", " \t\t\tif (siz != sizeof(*ni6))", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid length\"));", " \t\t\tbreak;", " \t\tcase ICMP6_NI_UNKNOWN:", " \t\t\tND_PRINT((ndo,\"unknown\"));", " \t\t\tneedcomma++;", " \t\t\tif (siz != sizeof(*ni6))", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid length\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\tif (ni6->ni_code != ICMP6_NI_SUCCESS) {", " \t\t\t ", " \t\t\tND_PRINT((ndo,\")\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\tswitch (EXTRACT_16BITS(&ni6->ni_qtype)) {", " \t\tcase NI_QTYPE_NOOP:", " \t\t\tif (needcomma)", " \t\t\t\tND_PRINT((ndo,\", \"));", " \t\t\tND_PRINT((ndo,\"noop\"));", " \t\t\tif (siz != sizeof(*ni6))", " \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", invalid length\"));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_SUPTYPES:", " \t\t\tif (needcomma)", " \t\t\t\tND_PRINT((ndo,\", \"));", " \t\t\tND_PRINT((ndo,\"supported qtypes\"));", " \t\t\ti = EXTRACT_16BITS(&ni6->ni_flags);", " \t\t\tif (i)", " \t\t\t\tND_PRINT((ndo,\" [%s]\", (i & 0x01) ? \"C\" : \"\"));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_FQDN:", " \t\t\tif (needcomma)", "  \t\t\t\tND_PRINT((ndo,\", \"));", "  \t\t\tND_PRINT((ndo,\"DNS name\"));", "  \t\t\tcp = (const u_char *)(ni6 + 1) + 4;", " \t\t\tND_TCHECK(cp[0]);", "  \t\t\tif (cp[0] == ep - cp - 1) {", "  \t\t\t\t ", "  \t\t\t\tif (ndo->ndo_vflag)", " \t\t\t\t\tND_PRINT((ndo,\", 03 draft\"));", " \t\t\t\tcp++;", " \t\t\t\tND_PRINT((ndo,\", \\\"\"));", " \t\t\t\twhile (cp < ep) {", " \t\t\t\t\tsafeputchar(ndo, *cp);", " \t\t\t\t\tcp++;", " \t\t\t\t}", " \t\t\t\tND_PRINT((ndo,\"\\\"\"));", " \t\t\t} else", " \t\t\t\tdnsname_print(ndo, cp, ep);", " \t\t\tif ((EXTRACT_16BITS(&ni6->ni_flags) & 0x01) != 0)", " \t\t\t\tND_PRINT((ndo,\" [TTL=%u]\", EXTRACT_32BITS(ni6 + 1)));", " \t\t\tbreak;", " \t\tcase NI_QTYPE_NODEADDR:", " \t\t\tif (needcomma)", " \t\t\t\tND_PRINT((ndo,\", \"));", " \t\t\tND_PRINT((ndo,\"node addresses\"));", " \t\t\ti = sizeof(*ni6);", " \t\t\twhile (i < siz) {", " \t\t\t\tif (i + sizeof(struct in6_addr) + sizeof(int32_t) > siz)", " \t\t\t\t\tbreak;", " \t\t\t\tND_PRINT((ndo,\" %s\", ip6addr_string(ndo, bp + i)));", " \t\t\t\ti += sizeof(struct in6_addr);", " \t\t\t\tND_PRINT((ndo,\"(%d)\", (int32_t)EXTRACT_32BITS(bp + i)));", " \t\t\t\ti += sizeof(int32_t);", " \t\t\t}", " \t\t\ti = ni6->ni_flags;", " \t\t\tif (!i)", " \t\t\t\tbreak;", " \t\t\tND_PRINT((ndo,\" [%s%s%s%s%s%s%s]\",", "                                   (i & NI_NODEADDR_FLAG_ANYCAST) ? \"a\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_GLOBAL) ? \"G\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_SITELOCAL) ? \"S\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_LINKLOCAL) ? \"L\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_COMPAT) ? \"C\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_ALL) ? \"A\" : \"\",", "                                   (i & NI_NODEADDR_FLAG_TRUNCATE) ? \"T\" : \"\"));", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tif (needcomma)", " \t\t\t\tND_PRINT((ndo,\", \"));", " \t\t\tND_PRINT((ndo,\"unknown\"));", " \t\t\tbreak;", " \t\t}", " ", " \t\t ", " \t\tND_PRINT((ndo,\")\"));", " \t\tbreak;", " \t}", " \treturn;", " ", " trunc:", " \tND_PRINT((ndo, \"[|icmp6]\"));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PackLinuxElf64::elf_find_dynamic(unsigned int key) const", "{", "Elf64_Dyn const *dynp= dynseg;", "if (dynp)", "for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg", "&& Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {", "upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));", "if (t) {", "return &((unsigned char const *)file_image)[(size_t)t];", "}", "break;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" mysqlnd_switch_to_ssl_if_needed(", " \t\t\tMYSQLND_CONN_DATA * conn,", " \t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,", " \t\t\tconst MYSQLND_OPTIONS * const options,", " \t\t\tunsigned long mysql_flags", " \t\t\tTSRMLS_DC", " \t\t)", " {", " \tenum_func_status ret = FAIL;", " \tconst MYSQLND_CHARSET * charset;", " \tMYSQLND_PACKET_AUTH * auth_packet;", " \tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");", " ", " \tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);", " \tif (!auth_packet) {", " \t\tSET_OOM_ERROR(*conn->error_info);", " \t\tgoto end;", " \t}", " \tauth_packet->client_flags = mysql_flags;", " \tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;", " ", " \tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {", " \t\tauth_packet->charset_no\t= charset->nr;", " \t} else {", " #if MYSQLND_UNICODE", " \t\tauth_packet->charset_no\t= 200; ", " #else", " \t\tauth_packet->charset_no\t= greet_packet->charset_no;", " #endif", "         }", "  ", "  #ifdef MYSQLND_SSL_SUPPORTED", "       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {", "               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;", "               DBG_INF(\"Switching to SSL\");", "               if (!PACKET_WRITE(auth_packet, conn)) {", "                       CONN_SET_STATE(conn, CONN_QUIT_SENT);", "                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);", "                       goto end;", "               }", "        if (mysql_flags & CLIENT_SSL) {", "                zend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;", "                if (server_has_ssl == FALSE) {", "                        goto close_conn;", "                } else {", "                        zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;", "                        DBG_INF(\"Switching to SSL\");", "                        if (!PACKET_WRITE(auth_packet, conn)) {", "                                goto close_conn;", "                        }", "  ", "               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);", "                        conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);", "  ", "               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {", "                       goto end;", "                        if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {", "                                goto end;", "                        }", "                 }", "         }", " #else", "        auth_packet->client_flags &= ~CLIENT_SSL;", "        if (!PACKET_WRITE(auth_packet, conn)) {", "                goto close_conn;", "        }", "  #endif", "         ret = PASS;", "  end:", "         PACKET_FREE(auth_packet);", "         DBG_RETURN(ret);", " ", " close_conn:", "        CONN_SET_STATE(conn, CONN_QUIT_SENT);", "        conn->m->send_close(conn TSRMLS_CC);", "        SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);", "        PACKET_FREE(auth_packet);", "        DBG_RETURN(ret);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,", " \t\t\t\tstruct stream *s, struct attr *attr,", " \t\t\t\tstruct bpacket_attr_vec_arr *vecarr,", " \t\t\t\tstruct prefix *p, afi_t afi, safi_t safi,", " \t\t\t\tstruct peer *from, struct prefix_rd *prd,", " \t\t\t\tmpls_label_t *label, uint32_t num_labels,", " \t\t\t\tint addpath_encode, uint32_t addpath_tx_id)", " {", " \tsize_t cp;", " \tsize_t aspath_sizep;", " \tstruct aspath *aspath;", " \tint send_as4_path = 0;", " \tint send_as4_aggregator = 0;", " \tint use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0;", " ", " \tif (!bgp)", " \t\tbgp = peer->bgp;", " ", " \t ", " \tcp = stream_get_endp(s);", " ", " \tif (p", " \t    && !((afi == AFI_IP && safi == SAFI_UNICAST)", " \t\t && !peer_cap_enhe(peer, afi, safi))) {", " \t\tsize_t mpattrlen_pos = 0;", " ", " \t\tmpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi,", " \t\t\t\t\t\t\tvecarr, attr);", " \t\tbgp_packet_mpattr_prefix(s, afi, safi, p, prd, label,", " \t\t\t\t\t num_labels, addpath_encode,", " \t\t\t\t\t addpath_tx_id, attr);", " \t\tbgp_packet_mpattr_end(s, mpattrlen_pos);", " \t}", " ", " \t ", " \tstream_putc(s, BGP_ATTR_FLAG_TRANS);", " \tstream_putc(s, BGP_ATTR_ORIGIN);", " \tstream_putc(s, 1);", " \tstream_putc(s, attr->origin);", " ", " \t ", " ", " \t ", " \tif (peer->sort == BGP_PEER_EBGP", " \t    && (!CHECK_FLAG(peer->af_flags[afi][safi],", " \t\t\t    PEER_FLAG_AS_PATH_UNCHANGED)", " \t\t|| attr->aspath->segments == NULL)", " \t    && (!CHECK_FLAG(peer->af_flags[afi][safi],", " \t\t\t    PEER_FLAG_RSERVER_CLIENT))) {", " \t\taspath = aspath_dup(attr->aspath);", " ", " \t\t ", " \t\taspath = aspath_delete_confed_seq(aspath);", " ", " \t\tif (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) {", " \t\t\t ", " \t\t\taspath = aspath_add_seq(aspath, bgp->confed_id);", " \t\t} else {", " \t\t\tif (peer->change_local_as) {", " \t\t\t\t ", " \t\t\t\tif (!CHECK_FLAG(", " \t\t\t\t\t    peer->flags,", " \t\t\t\t\t    PEER_FLAG_LOCAL_AS_REPLACE_AS)) {", " \t\t\t\t\taspath = aspath_add_seq(aspath,", " \t\t\t\t\t\t\t\tpeer->local_as);", " \t\t\t\t}", " \t\t\t\taspath = aspath_add_seq(aspath,", " \t\t\t\t\t\t\tpeer->change_local_as);", " \t\t\t} else {", " \t\t\t\taspath = aspath_add_seq(aspath, peer->local_as);", " \t\t\t}", " \t\t}", " \t} else if (peer->sort == BGP_PEER_CONFED) {", " \t\t ", " \t\taspath = aspath_dup(attr->aspath);", " \t\taspath = aspath_add_confed_seq(aspath, peer->local_as);", " \t} else", " \t\taspath = attr->aspath;", " ", " \t ", " ", " \tstream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN);", " \tstream_putc(s, BGP_ATTR_AS_PATH);", " \taspath_sizep = stream_get_endp(s);", " \tstream_putw(s, 0);", " \tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit));", " ", " \t ", " \tif (!use32bit && aspath_has_as4(aspath))", " \t\tsend_as4_path =", " \t\t\t1;  ", " ", " \t ", " \tif (afi == AFI_IP && safi == SAFI_UNICAST", " \t    && !peer_cap_enhe(peer, afi, safi)) {", " \t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) {", " \t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);", " \t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);", " \t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,", " \t\t\t\t\t\t     attr);", " \t\t\tstream_putc(s, 4);", " \t\t\tstream_put_ipv4(s, attr->nexthop.s_addr);", " \t\t} else if (peer_cap_enhe(from, afi, safi)) {", " \t\t\t ", " \t\t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);", " \t\t\tstream_putc(s, BGP_ATTR_NEXT_HOP);", " \t\t\tbpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s,", " \t\t\t\t\t\t     NULL);", " \t\t\tstream_putc(s, 4);", " \t\t\tstream_put_ipv4(s, 0);", " \t\t}", " \t}", " ", " \t ", " \tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC)", " \t    || bgp->maxmed_active) {", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);", " \t\tstream_putc(s, BGP_ATTR_MULTI_EXIT_DISC);", " \t\tstream_putc(s, 4);", " \t\tstream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value", " \t\t\t\t\t\t   : attr->med));", " \t}", " ", " \t ", " \tif (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) {", " \t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);", " \t\tstream_putc(s, BGP_ATTR_LOCAL_PREF);", " \t\tstream_putc(s, 4);", " \t\tstream_putl(s, attr->local_pref);", " \t}", " ", " \t ", " \tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) {", " \t\tstream_putc(s, BGP_ATTR_FLAG_TRANS);", " \t\tstream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE);", " \t\tstream_putc(s, 0);", " \t}", " ", " \t ", " \tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) {", " \t\t ", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);", " \t\tstream_putc(s, BGP_ATTR_AGGREGATOR);", " ", " \t\tif (use32bit) {", " \t\t\t ", " \t\t\tstream_putc(s, 8);", " \t\t\tstream_putl(s, attr->aggregator_as);", " \t\t} else {", " \t\t\t ", " \t\t\tstream_putc(s, 6);", " ", " \t\t\t ", " \t\t\tif (attr->aggregator_as > 65535) {", " \t\t\t\tstream_putw(s, BGP_AS_TRANS);", " ", " \t\t\t\t ", " \t\t\t\tsend_as4_aggregator = 1;", " \t\t\t} else", " \t\t\t\tstream_putw(s, (uint16_t)attr->aggregator_as);", " \t\t}", " \t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);", " \t}", " ", " \t ", " \tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)", " \t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) {", " \t\tif (attr->community->size * 4 > 255) {", " \t\t\tstream_putc(s,", " \t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS", " \t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);", " \t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);", " \t\t\tstream_putw(s, attr->community->size * 4);", " \t\t} else {", " \t\t\tstream_putc(s,", " \t\t\t\t    BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);", " \t\t\tstream_putc(s, BGP_ATTR_COMMUNITIES);", " \t\t\tstream_putc(s, attr->community->size * 4);", " \t\t}", " \t\tstream_put(s, attr->community->val, attr->community->size * 4);", " \t}", " ", " \t ", " \tif (CHECK_FLAG(peer->af_flags[afi][safi],", " \t\t       PEER_FLAG_SEND_LARGE_COMMUNITY)", " \t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) {", " \t\tif (lcom_length(attr->lcommunity) > 255) {", " \t\t\tstream_putc(s,", " \t\t\t\t    BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS", " \t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);", " \t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);", " \t\t\tstream_putw(s, lcom_length(attr->lcommunity));", " \t\t} else {", " \t\t\tstream_putc(s,", " \t\t\t\t    BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);", " \t\t\tstream_putc(s, BGP_ATTR_LARGE_COMMUNITIES);", " \t\t\tstream_putc(s, lcom_length(attr->lcommunity));", " \t\t}", " \t\tstream_put(s, attr->lcommunity->val,", " \t\t\t   lcom_length(attr->lcommunity));", " \t}", " ", " \t ", " \tif (peer->sort == BGP_PEER_IBGP && from", " \t    && from->sort == BGP_PEER_IBGP) {", " \t\t ", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);", " \t\tstream_putc(s, BGP_ATTR_ORIGINATOR_ID);", " \t\tstream_putc(s, 4);", " ", " \t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))", " \t\t\tstream_put_in_addr(s, &attr->originator_id);", " \t\telse", " \t\t\tstream_put_in_addr(s, &from->remote_id);", " ", " \t\t ", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);", " \t\tstream_putc(s, BGP_ATTR_CLUSTER_LIST);", " ", " \t\tif (attr->cluster) {", " \t\t\tstream_putc(s, attr->cluster->length + 4);", " \t\t\t ", " \t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)", " \t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);", " \t\t\telse", " \t\t\t\tstream_put_in_addr(s, &bgp->router_id);", " \t\t\tstream_put(s, attr->cluster->list,", " \t\t\t\t   attr->cluster->length);", " \t\t} else {", " \t\t\tstream_putc(s, 4);", " \t\t\t ", " \t\t\tif (bgp->config & BGP_CONFIG_CLUSTER_ID)", " \t\t\t\tstream_put_in_addr(s, &bgp->cluster_id);", " \t\t\telse", " \t\t\t\tstream_put_in_addr(s, &bgp->router_id);", " \t\t}", " \t}", " ", " \t ", " \tif (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)", " \t    && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) {", " \t\tif (peer->sort == BGP_PEER_IBGP", " \t\t    || peer->sort == BGP_PEER_CONFED) {", " \t\t\tif (attr->ecommunity->size * 8 > 255) {", " \t\t\t\tstream_putc(s,", " \t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS", " \t\t\t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);", " \t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);", " \t\t\t\tstream_putw(s, attr->ecommunity->size * 8);", " \t\t\t} else {", " \t\t\t\tstream_putc(s,", " \t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);", " \t\t\t\tstream_putc(s, BGP_ATTR_EXT_COMMUNITIES);", " \t\t\t\tstream_putc(s, attr->ecommunity->size * 8);", " \t\t\t}", " \t\t\tstream_put(s, attr->ecommunity->val,", " \t\t\t\t   attr->ecommunity->size * 8);", " \t\t} else {", " \t\t\tuint8_t *pnt;", " \t\t\tint tbit;", " \t\t\tint ecom_tr_size = 0;", " \t\t\tint i;", " ", " \t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {", " \t\t\t\tpnt = attr->ecommunity->val + (i * 8);", " \t\t\t\ttbit = *pnt;", " ", " \t\t\t\tif (CHECK_FLAG(tbit,", " \t\t\t\t\t       ECOMMUNITY_FLAG_NON_TRANSITIVE))", " \t\t\t\t\tcontinue;", " ", " \t\t\t\tecom_tr_size++;", " \t\t\t}", " ", " \t\t\tif (ecom_tr_size) {", " \t\t\t\tif (ecom_tr_size * 8 > 255) {", " \t\t\t\t\tstream_putc(", " \t\t\t\t\t\ts,", " \t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS", " \t\t\t\t\t\t\t| BGP_ATTR_FLAG_EXTLEN);", " \t\t\t\t\tstream_putc(s,", " \t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);", " \t\t\t\t\tstream_putw(s, ecom_tr_size * 8);", " \t\t\t\t} else {", " \t\t\t\t\tstream_putc(", " \t\t\t\t\t\ts,", " \t\t\t\t\t\tBGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t\t\t| BGP_ATTR_FLAG_TRANS);", " \t\t\t\t\tstream_putc(s,", " \t\t\t\t\t\t    BGP_ATTR_EXT_COMMUNITIES);", " \t\t\t\t\tstream_putc(s, ecom_tr_size * 8);", " \t\t\t\t}", " ", " \t\t\t\tfor (i = 0; i < attr->ecommunity->size; i++) {", " \t\t\t\t\tpnt = attr->ecommunity->val + (i * 8);", " \t\t\t\t\ttbit = *pnt;", " ", " \t\t\t\t\tif (CHECK_FLAG(", " \t\t\t\t\t\t    tbit,", " \t\t\t\t\t\t    ECOMMUNITY_FLAG_NON_TRANSITIVE))", " \t\t\t\t\t\tcontinue;", " ", " \t\t\t\t\tstream_put(s, pnt, 8);", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " ", " \t ", " \tif (safi == SAFI_LABELED_UNICAST) {", " \t\tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) {", " \t\t\tuint32_t label_index;", " ", " \t\t\tlabel_index = attr->label_index;", " ", " \t\t\tif (label_index != BGP_INVALID_LABEL_INDEX) {", " \t\t\t\tstream_putc(s,", " \t\t\t\t\t    BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t\t\t    | BGP_ATTR_FLAG_TRANS);", " \t\t\t\tstream_putc(s, BGP_ATTR_PREFIX_SID);", " \t\t\t\tstream_putc(s, 10);", " \t\t\t\tstream_putc(s, BGP_PREFIX_SID_LABEL_INDEX);", " \t\t\t\tstream_putw(s,", " \t\t\t\t\t    BGP_PREFIX_SID_LABEL_INDEX_LENGTH);", " \t\t\t\tstream_putc(s, 0);  ", " \t\t\t\tstream_putw(s, 0);  ", " \t\t\t\tstream_putl(s, label_index);", " \t\t\t}", " \t\t}", " \t}", " ", " \tif (send_as4_path) {", " \t\t ", " \t\t ", " ", " \t\t ", " \t\taspath = aspath_delete_confed_seq(aspath);", " ", " \t\tstream_putc(s,", " \t\t\t    BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL", " \t\t\t\t    | BGP_ATTR_FLAG_EXTLEN);", " \t\tstream_putc(s, BGP_ATTR_AS4_PATH);", " \t\taspath_sizep = stream_get_endp(s);", " \t\tstream_putw(s, 0);", " \t\tstream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1));", " \t}", " ", " \tif (aspath != attr->aspath)", " \t\taspath_free(aspath);", " ", " \tif (send_as4_aggregator) {", " \t\t ", " \t\t ", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);", " \t\tstream_putc(s, BGP_ATTR_AS4_AGGREGATOR);", " \t\tstream_putc(s, 8);", " \t\tstream_putl(s, attr->aggregator_as);", " \t\tstream_put_ipv4(s, attr->aggregator_addr.s_addr);", " \t}", " ", " \tif (((afi == AFI_IP || afi == AFI_IP6)", " \t     && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))", " \t    || (afi == AFI_L2VPN && safi == SAFI_EVPN)) {", "  \t\t ", "  \t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);", "  ", "#if ENABLE_BGP_VNC", " #if ENABLE_BGP_VNC_ATTR", "  \t\t ", "  \t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);", "  #endif", " \t}", " ", " \t ", " \tif (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) {", " \t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS);", " \t\tstream_putc(s, BGP_ATTR_PMSI_TUNNEL);", " \t\tstream_putc(s, 9);  ", " \t\tstream_putc(s, 0);  ", " \t\tstream_putc(s, PMSI_TNLTYPE_INGR_REPL);  ", " \t\tstream_put(s, &(attr->label),", " \t\t\t   BGP_LABEL_BYTES);  ", " \t\tstream_put_ipv4(s, attr->nexthop.s_addr);", " \t}", " ", " \t ", " \tif (attr->transit)", " \t\tstream_put(s, attr->transit->val, attr->transit->length);", " ", " \t ", " \treturn stream_get_endp(s) - cp;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["_forceinline void Unpack::CopyString(uint Length,uint Distance)", "{", "size_t SrcPtr=UnpPtr-Distance;", "if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)", "{", "", "", "", "byte *Src=Window+SrcPtr;", "byte *Dest=Window+UnpPtr;", "UnpPtr+=Length;", "", "#ifdef FAST_MEMCPY", "if (Distance<Length)", "#endif", "while (Length>=8)", "{", "Dest[0]=Src[0];", "Dest[1]=Src[1];", "Dest[2]=Src[2];", "Dest[3]=Src[3];", "Dest[4]=Src[4];", "Dest[5]=Src[5];", "Dest[6]=Src[6];", "Dest[7]=Src[7];", "", "Src+=8;", "Dest+=8;", "Length-=8;", "}", "#ifdef FAST_MEMCPY", "else", "while (Length>=8)", "{", "", "", "", "", "", "", "", "memcpy(Dest,Src,8);", "", "Src+=8;", "Dest+=8;", "Length-=8;", "}", "#endif", "", "", "if (Length>0) { Dest[0]=Src[0];", "if (Length>1) { Dest[1]=Src[1];", "if (Length>2) { Dest[2]=Src[2];", "if (Length>3) { Dest[3]=Src[3];", "if (Length>4) { Dest[4]=Src[4];", "if (Length>5) { Dest[5]=Src[5];", "if (Length>6) { Dest[6]=Src[6]; } } } } } } }", "}", "else", "while (Length-- > 0)", "{", "Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];", "", "", "UnpPtr=(UnpPtr+1) & MaxWinMask;", "}", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)", " {", "     if (!m_provider) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));", "         return;", "     }", " ", "     RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();", "     String errorMessage;", "     if (!executionContext->isSecureContext(errorMessage)) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));", "         return;", "     }", " ", "     KURL pageURL = KURL(KURL(), documentOrigin->toString());", "     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));", "         return;", "     }", " ", "     KURL scriptURL = rawScriptURL;", "     scriptURL.removeFragmentIdentifier();", "     if (!documentOrigin->canRequest(scriptURL)) {", "         RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));", "         return;", "     }", "     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));", "         return;", "     }", " ", "     KURL patternURL = scope;", "     patternURL.removeFragmentIdentifier();", " ", "     if (!documentOrigin->canRequest(patternURL)) {", "         RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));", "         return;", "     }", "     if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));", "         return;", "     }", " ", "     WebString webErrorMessage;", "     if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {", "         callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));", "          return;", "      }", "  ", "     ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();", "     if (csp) {", "         if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {", "             callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));", "             return;", "         }", "     }", " ", "      m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["static int bpf_convert_filter(struct sock_filter *prog, int len,", "struct bpf_prog *new_prog, int *new_len)", "{", "int new_flen = 0, pass = 0, target, i, stack_off;", "struct bpf_insn *new_insn, *first_insn = NULL;", "struct sock_filter *fp;", "int *addrs = NULL;", "u8 bpf_src;", "", "BUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);", "BUILD_BUG_ON(BPF_REG_FP + 1 != MAX_BPF_REG);", "", "if (len <= 0 || len > BPF_MAXINSNS)", "return -EINVAL;", "", "if (new_prog) {", "first_insn = new_prog->insnsi;", "addrs = kcalloc(len, sizeof(*addrs),", "GFP_KERNEL | __GFP_NOWARN);", "if (!addrs)", "return -ENOMEM;", "}", "", "do_pass:", "new_insn = first_insn;", "fp = prog;", "", "", "if (new_prog) {", "", "", "", "*new_insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_A, BPF_REG_A);", "*new_insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_X, BPF_REG_X);", "", "", "", "", "", "*new_insn++ = BPF_MOV64_REG(BPF_REG_CTX, BPF_REG_ARG1);", "} else {", "new_insn += 3;", "}", "", "for (i = 0; i < len; fp++, i++) {", "struct bpf_insn tmp_insns[6] = { };", "struct bpf_insn *insn = tmp_insns;", "", "if (addrs)", "addrs[i] = new_insn - first_insn;", "", "switch (fp->code) {", "", "case BPF_ALU | BPF_ADD | BPF_X:", "case BPF_ALU | BPF_ADD | BPF_K:", "case BPF_ALU | BPF_SUB | BPF_X:", "case BPF_ALU | BPF_SUB | BPF_K:", "case BPF_ALU | BPF_AND | BPF_X:", "case BPF_ALU | BPF_AND | BPF_K:", "case BPF_ALU | BPF_OR | BPF_X:", "case BPF_ALU | BPF_OR | BPF_K:", "case BPF_ALU | BPF_LSH | BPF_X:", "case BPF_ALU | BPF_LSH | BPF_K:", "case BPF_ALU | BPF_RSH | BPF_X:", "case BPF_ALU | BPF_RSH | BPF_K:", "case BPF_ALU | BPF_XOR | BPF_X:", "case BPF_ALU | BPF_XOR | BPF_K:", "case BPF_ALU | BPF_MUL | BPF_X:", "case BPF_ALU | BPF_MUL | BPF_K:", "case BPF_ALU | BPF_DIV | BPF_X:", "case BPF_ALU | BPF_DIV | BPF_K:", "case BPF_ALU | BPF_MOD | BPF_X:", "case BPF_ALU | BPF_MOD | BPF_K:", "case BPF_ALU | BPF_NEG:", "case BPF_LD | BPF_ABS | BPF_W:", "case BPF_LD | BPF_ABS | BPF_H:", "case BPF_LD | BPF_ABS | BPF_B:", "case BPF_LD | BPF_IND | BPF_W:", "case BPF_LD | BPF_IND | BPF_H:", "case BPF_LD | BPF_IND | BPF_B:", "", "", "", "", "if (BPF_CLASS(fp->code) == BPF_LD &&", "BPF_MODE(fp->code) == BPF_ABS &&", "convert_bpf_extensions(fp, &insn))", "break;", "", "if (fp->code == (BPF_ALU | BPF_DIV | BPF_X) ||", "fp->code == (BPF_ALU | BPF_MOD | BPF_X)) {", "*insn++ = BPF_MOV32_REG(BPF_REG_X, BPF_REG_X);", "", "", "", "*insn++ = BPF_JMP_IMM(BPF_JNE, BPF_REG_X, 0, 2);", "*insn++ = BPF_ALU32_REG(BPF_XOR, BPF_REG_A, BPF_REG_A);", "*insn++ = BPF_EXIT_INSN();", "}", "", "*insn = BPF_RAW_INSN(fp->code, BPF_REG_A, BPF_REG_X, 0, fp->k);", "break;", "", "", "", "", "", "", "", "#define BPF_EMIT_JMP\t\t\t\t\t\t\t\\", "\tdo {\t\t\t\t\t\t\t\t\\", "\t\tif (target >= len || target < 0)\t\t\t\\", "\t\t\tgoto err;\t\t\t\t\t\\", "\t\tinsn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;\t\\", "\t\t/* Adjust pc relative offset for 2nd or 3rd insn. */\t\\", "\t\tinsn->off -= insn - tmp_insns;\t\t\t\t\\", "\t} while (0)", "", "case BPF_JMP | BPF_JA:", "target = i + fp->k + 1;", "insn->code = fp->code;", "BPF_EMIT_JMP;", "break;", "", "case BPF_JMP | BPF_JEQ | BPF_K:", "case BPF_JMP | BPF_JEQ | BPF_X:", "case BPF_JMP | BPF_JSET | BPF_K:", "case BPF_JMP | BPF_JSET | BPF_X:", "case BPF_JMP | BPF_JGT | BPF_K:", "case BPF_JMP | BPF_JGT | BPF_X:", "case BPF_JMP | BPF_JGE | BPF_K:", "case BPF_JMP | BPF_JGE | BPF_X:", "if (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {", "", "", "", "", "*insn++ = BPF_MOV32_IMM(BPF_REG_TMP, fp->k);", "", "insn->dst_reg = BPF_REG_A;", "insn->src_reg = BPF_REG_TMP;", "bpf_src = BPF_X;", "} else {", "insn->dst_reg = BPF_REG_A;", "insn->imm = fp->k;", "bpf_src = BPF_SRC(fp->code);", "insn->src_reg = bpf_src == BPF_X ? BPF_REG_X : 0;", "}", "", "", "if (fp->jf == 0) {", "insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;", "target = i + fp->jt + 1;", "BPF_EMIT_JMP;", "break;", "}", "", "", "if (fp->jt == 0) {", "switch (BPF_OP(fp->code)) {", "case BPF_JEQ:", "insn->code = BPF_JMP | BPF_JNE | bpf_src;", "break;", "case BPF_JGT:", "insn->code = BPF_JMP | BPF_JLE | bpf_src;", "break;", "case BPF_JGE:", "insn->code = BPF_JMP | BPF_JLT | bpf_src;", "break;", "default:", "goto jmp_rest;", "}", "", "target = i + fp->jf + 1;", "BPF_EMIT_JMP;", "break;", "}", "jmp_rest:", "", "target = i + fp->jt + 1;", "insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;", "BPF_EMIT_JMP;", "insn++;", "", "insn->code = BPF_JMP | BPF_JA;", "target = i + fp->jf + 1;", "BPF_EMIT_JMP;", "break;", "", "", "case BPF_LDX | BPF_MSH | BPF_B:", "", "*insn++ = BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_A);", "", "*insn++ = BPF_LD_ABS(BPF_B, fp->k);", "", "*insn++ = BPF_ALU32_IMM(BPF_AND, BPF_REG_A, 0xf);", "", "*insn++ = BPF_ALU32_IMM(BPF_LSH, BPF_REG_A, 2);", "", "*insn++ = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);", "", "*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_TMP);", "break;", "", "", "", "", "case BPF_RET | BPF_A:", "case BPF_RET | BPF_K:", "if (BPF_RVAL(fp->code) == BPF_K)", "*insn++ = BPF_MOV32_RAW(BPF_K, BPF_REG_0,", "0, fp->k);", "*insn = BPF_EXIT_INSN();", "break;", "", "", "case BPF_ST:", "case BPF_STX:", "stack_off = fp->k * 4  + 4;", "*insn = BPF_STX_MEM(BPF_W, BPF_REG_FP, BPF_CLASS(fp->code) ==", "BPF_ST ? BPF_REG_A : BPF_REG_X,", "-stack_off);", "", "", "", "", "if (new_prog && new_prog->aux->stack_depth < stack_off)", "new_prog->aux->stack_depth = stack_off;", "break;", "", "", "case BPF_LD | BPF_MEM:", "case BPF_LDX | BPF_MEM:", "stack_off = fp->k * 4  + 4;", "*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD  ?", "BPF_REG_A : BPF_REG_X, BPF_REG_FP,", "-stack_off);", "break;", "", "", "case BPF_LD | BPF_IMM:", "case BPF_LDX | BPF_IMM:", "*insn = BPF_MOV32_IMM(BPF_CLASS(fp->code) == BPF_LD ?", "BPF_REG_A : BPF_REG_X, fp->k);", "break;", "", "", "case BPF_MISC | BPF_TAX:", "*insn = BPF_MOV64_REG(BPF_REG_X, BPF_REG_A);", "break;", "", "", "case BPF_MISC | BPF_TXA:", "*insn = BPF_MOV64_REG(BPF_REG_A, BPF_REG_X);", "break;", "", "", "case BPF_LD | BPF_W | BPF_LEN:", "case BPF_LDX | BPF_W | BPF_LEN:", "*insn = BPF_LDX_MEM(BPF_W, BPF_CLASS(fp->code) == BPF_LD ?", "BPF_REG_A : BPF_REG_X, BPF_REG_CTX,", "offsetof(struct sk_buff, len));", "break;", "", "", "case BPF_LDX | BPF_ABS | BPF_W:", "", "*insn = BPF_LDX_MEM(BPF_W, BPF_REG_A, BPF_REG_CTX, fp->k);", "break;", "", "", "default:", "goto err;", "}", "", "insn++;", "if (new_prog)", "memcpy(new_insn, tmp_insns,", "sizeof(*insn) * (insn - tmp_insns));", "new_insn += insn - tmp_insns;", "}", "", "if (!new_prog) {", "", "*new_len = new_insn - first_insn;", "return 0;", "}", "", "pass++;", "if (new_flen != new_insn - first_insn) {", "new_flen = new_insn - first_insn;", "if (pass > 2)", "goto err;", "goto do_pass;", "}", "", "kfree(addrs);", "BUG_ON(*new_len != new_flen);", "return 0;", "err:", "kfree(addrs);", "return -EINVAL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)", " {", " \tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;", " \tu8 b[] = { 0x00, 0xff, 0x00, 0x00,", "  \t\t   0x00, 0x00, 0x00, 0x00,", "  \t\t   0x00, 0x00 };", "  ", " \tif (cmd->msg_len > sizeof(b) - 4)", " \t\treturn -EINVAL;", " ", "  \tmemcpy(&b[4], cmd->msg, cmd->msg_len);", "  ", "  \tstate->config->send_command(fe, 0x72,", " \t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,", " \t\t\t\t    NULL, NULL);", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  Response StorageHandler::UntrackIndexedDBForOrigin(const std::string& origin) {", "  if (!process_)", "   if (!storage_partition_)", "      return Response::InternalError();", "  ", "    GURL origin_url(origin);", "   if (!origin_url.is_valid())", "     return Response::InvalidParams(origin + \" is not a valid URL\");", " ", "   GetIndexedDBObserver()->TaskRunner()->PostTask(", "       FROM_HERE, base::BindOnce(&IndexedDBObserver::UntrackOriginOnIDBThread,", "                                 base::Unretained(GetIndexedDBObserver()),", "                                 url::Origin::Create(origin_url)));", "   return Response::OK();", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,", "                             UINT16 data_size, UINT8 *p_data, UINT16 evt)", " {", "     UINT8 app_idx, mcl_idx, mdl_idx;", "  btif_hl_mdl_cb_t *p_dcb;", "     tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;", "  int            r;", "     BTIF_TRACE_DEBUG(\"%s app_id=%d mdl_handle=0x%x data_size=%d\",", "                       __FUNCTION__,app_id, mdl_handle, data_size);", " ", "  if (btif_hl_find_mdl_idx_using_handle(mdl_handle, &app_idx, &mcl_idx, &mdl_idx))", "  {", "         p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);", " ", "  if ((p_dcb->p_rx_pkt = (UINT8 *)btif_hl_get_buf(data_size)) != NULL)", "  {", "             memcpy(p_dcb->p_rx_pkt, p_data, data_size);", "  if (p_dcb->p_scb)", " ", "              {", "                  BTIF_TRACE_DEBUG(\"app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d\",", "                                    app_idx, mcl_idx, mdl_idx, data_size);", "                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);", "                 r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));", "  ", "                  if (r == data_size)", "                  {", "                     BTIF_TRACE_DEBUG(\"socket send success data_size=%d\",  data_size);", "                     status = BTA_HL_STATUS_OK;", "  }", "  else", "  {", "                     BTIF_TRACE_ERROR(\"socket send failed r=%d data_size=%d\",r, data_size);", "  }", " ", " ", "  }", "             btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);", "  }", "  }", " ", "     bta_hl_ci_put_rx_data(mdl_handle,  status, evt);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xfs_attr3_leaf_flipflags(", " \tstruct xfs_da_args\t*args)", " {", " \tstruct xfs_attr_leafblock *leaf1;", " \tstruct xfs_attr_leafblock *leaf2;", " \tstruct xfs_attr_leaf_entry *entry1;", " \tstruct xfs_attr_leaf_entry *entry2;", " \tstruct xfs_attr_leaf_name_remote *name_rmt;", " \tstruct xfs_buf\t\t*bp1;", " \tstruct xfs_buf\t\t*bp2;", " \tint error;", " #ifdef DEBUG", " \tstruct xfs_attr3_icleaf_hdr ichdr1;", " \tstruct xfs_attr3_icleaf_hdr ichdr2;", " \txfs_attr_leaf_name_local_t *name_loc;", " \tint namelen1, namelen2;", " \tchar *name1, *name2;", " #endif  ", " ", " \ttrace_xfs_attr_leaf_flipflags(args);", " ", " \t ", " \terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);", " \tif (error)", " \t\treturn error;", " ", " \t ", " \tif (args->blkno2 != args->blkno) {", " \t\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno2,", " \t\t\t\t\t   -1, &bp2);", " \t\tif (error)", " \t\t\treturn error;", " \t} else {", " \t\tbp2 = bp1;", " \t}", " ", " \tleaf1 = bp1->b_addr;", " \tentry1 = &xfs_attr3_leaf_entryp(leaf1)[args->index];", " ", " \tleaf2 = bp2->b_addr;", " \tentry2 = &xfs_attr3_leaf_entryp(leaf2)[args->index2];", " ", " #ifdef DEBUG", " \txfs_attr3_leaf_hdr_from_disk(&ichdr1, leaf1);", " \tASSERT(args->index < ichdr1.count);", " \tASSERT(args->index >= 0);", " ", " \txfs_attr3_leaf_hdr_from_disk(&ichdr2, leaf2);", " \tASSERT(args->index2 < ichdr2.count);", " \tASSERT(args->index2 >= 0);", " ", " \tif (entry1->flags & XFS_ATTR_LOCAL) {", " \t\tname_loc = xfs_attr3_leaf_name_local(leaf1, args->index);", " \t\tnamelen1 = name_loc->namelen;", " \t\tname1 = (char *)name_loc->nameval;", " \t} else {", " \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);", " \t\tnamelen1 = name_rmt->namelen;", " \t\tname1 = (char *)name_rmt->name;", " \t}", " \tif (entry2->flags & XFS_ATTR_LOCAL) {", " \t\tname_loc = xfs_attr3_leaf_name_local(leaf2, args->index2);", " \t\tnamelen2 = name_loc->namelen;", " \t\tname2 = (char *)name_loc->nameval;", " \t} else {", " \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);", " \t\tnamelen2 = name_rmt->namelen;", " \t\tname2 = (char *)name_rmt->name;", " \t}", " \tASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));", " \tASSERT(namelen1 == namelen2);", " \tASSERT(memcmp(name1, name2, namelen1) == 0);", " #endif  ", " ", " \tASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);", " \tASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);", " ", " \tentry1->flags &= ~XFS_ATTR_INCOMPLETE;", " \txfs_trans_log_buf(args->trans, bp1,", " \t\t\t  XFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));", " \tif (args->rmtblkno) {", "  \t\tASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);", "  \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf1, args->index);", "  \t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);", "\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);", " \t\tname_rmt->valuelen = cpu_to_be32(args->rmtvaluelen);", "  \t\txfs_trans_log_buf(args->trans, bp1,", "  \t\t\t XFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));", "  \t}", " ", " \tentry2->flags |= XFS_ATTR_INCOMPLETE;", " \txfs_trans_log_buf(args->trans, bp2,", " \t\t\t  XFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));", " \tif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {", " \t\tname_rmt = xfs_attr3_leaf_name_remote(leaf2, args->index2);", " \t\tname_rmt->valueblk = 0;", " \t\tname_rmt->valuelen = 0;", " \t\txfs_trans_log_buf(args->trans, bp2,", " \t\t\t XFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));", " \t}", " ", " \t ", " \terror = xfs_trans_roll(&args->trans, args->dp);", " ", " \treturn error;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE SoftAMR::internalSetParameter(", "         OMX_INDEXTYPE index, const OMX_PTR params) {", "  switch (index) {", "  case OMX_IndexParamStandardComponentRole:", "  {", " ", "              const OMX_PARAM_COMPONENTROLETYPE *roleParams =", "                  (const OMX_PARAM_COMPONENTROLETYPE *)params;", "  ", "             if (!isValidOMXParam(roleParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (mMode == MODE_NARROW) {", "                  if (strncmp((const char *)roleParams->cRole,", "                              \"audio_decoder.amrnb\",", "                             OMX_MAX_STRINGNAME_SIZE - 1)) {", "  return OMX_ErrorUndefined;", "  }", "  } else {", "  if (strncmp((const char *)roleParams->cRole,", "  \"audio_decoder.amrwb\",", "                             OMX_MAX_STRINGNAME_SIZE - 1)) {", "  return OMX_ErrorUndefined;", "  }", "  }", " ", "  return OMX_ErrorNone;", "  }", " ", "  case OMX_IndexParamAudioAmr:", "  {", " ", "              const OMX_AUDIO_PARAM_AMRTYPE *aacParams =", "                  (const OMX_AUDIO_PARAM_AMRTYPE *)params;", "  ", "             if (!isValidOMXParam(aacParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (aacParams->nPortIndex != 0) {", "                  return OMX_ErrorUndefined;", "              }", " ", "  return OMX_ErrorNone;", "  }", " ", "  case OMX_IndexParamAudioPcm:", "  {", " ", "              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =", "                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;", "  ", "             if (!isValidOMXParam(pcmParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (pcmParams->nPortIndex != 1) {", "                  return OMX_ErrorUndefined;", "              }", " ", "  return OMX_ErrorNone;", "  }", " ", "  default:", "  return SimpleSoftOMXComponent::internalSetParameter(index, params);", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int LibarchivePlugin::extractionFlags() const", "{", "int result = ARCHIVE_EXTRACT_TIME;", "result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;", "", "", "", "", "", "", "", "", "", "", "", "", "return result;", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" const service_manager::Manifest& GetChromeContentBrowserOverlayManifest() {", "   static base::NoDestructor<service_manager::Manifest> manifest {", "     service_manager::ManifestBuilder()", "         .ExposeCapability(\"gpu\",", "                           service_manager::Manifest::InterfaceList<", "                               metrics::mojom::CallStackProfileCollector>())", "         .ExposeCapability(\"renderer\",", "                           service_manager::Manifest::InterfaceList<", "                               chrome::mojom::AvailableOfflineContentProvider,", "                               chrome::mojom::CacheStatsRecorder,", "                               chrome::mojom::NetBenchmarking,", "                               data_reduction_proxy::mojom::DataReductionProxy,", "                               metrics::mojom::CallStackProfileCollector,", " #if defined(OS_WIN)", "                               mojom::ModuleEventSink,", " #endif", "                               rappor::mojom::RapporRecorder,", "                               safe_browsing::mojom::SafeBrowsing>())", "         .RequireCapability(\"ash\", \"system_ui\")", "         .RequireCapability(\"ash\", \"test\")", "         .RequireCapability(\"ash\", \"display\")", "         .RequireCapability(\"assistant\", \"assistant\")", "         .RequireCapability(\"assistant_audio_decoder\", \"assistant:audio_decoder\")", "         .RequireCapability(\"chrome\", \"input_device_controller\")", "         .RequireCapability(\"chrome_printing\", \"converter\")", "         .RequireCapability(\"cups_ipp_parser\", \"ipp_parser\")", "         .RequireCapability(\"device\", \"device:fingerprint\")", "         .RequireCapability(\"device\", \"device:geolocation_config\")", "         .RequireCapability(\"device\", \"device:geolocation_control\")", "         .RequireCapability(\"device\", \"device:ip_geolocator\")", "         .RequireCapability(\"ime\", \"input_engine\")", "         .RequireCapability(\"mirroring\", \"mirroring\")", "         .RequireCapability(\"nacl_broker\", \"browser\")", "         .RequireCapability(\"nacl_loader\", \"browser\")", "         .RequireCapability(\"noop\", \"noop\")", "         .RequireCapability(\"patch\", \"patch_file\")", "         .RequireCapability(\"preferences\", \"pref_client\")", "         .RequireCapability(\"preferences\", \"pref_control\")", "         .RequireCapability(\"profile_import\", \"import\")", "         .RequireCapability(\"removable_storage_writer\",", "                            \"removable_storage_writer\")", "         .RequireCapability(\"secure_channel\", \"secure_channel\")", "         .RequireCapability(\"ui\", \"ime_registrar\")", "         .RequireCapability(\"ui\", \"input_device_controller\")", "         .RequireCapability(\"ui\", \"window_manager\")", "         .RequireCapability(\"unzip\", \"unzip_file\")", "         .RequireCapability(\"util_win\", \"util_win\")", "         .RequireCapability(\"xr_device_service\", \"xr_device_provider\")", "         .RequireCapability(\"xr_device_service\", \"xr_device_test_hook\")", " #if defined(OS_CHROMEOS)", "         .RequireCapability(\"multidevice_setup\", \"multidevice_setup\")", " #endif", "         .ExposeInterfaceFilterCapability_Deprecated(", "             \"navigation:frame\", \"renderer\",", "             service_manager::Manifest::InterfaceList<", "                 autofill::mojom::AutofillDriver,", "                 autofill::mojom::PasswordManagerDriver,", "                 chrome::mojom::OfflinePageAutoFetcher,", " #if defined(OS_CHROMEOS)", "                  chromeos_camera::mojom::CameraAppHelper,", "                  chromeos::cellular_setup::mojom::CellularSetup,", "                  chromeos::crostini_installer::mojom::PageHandlerFactory,", "                chromeos::crostini_upgrader::mojom::PageHandlerFactory,", "                  chromeos::ime::mojom::InputEngineManager,", "                  chromeos::machine_learning::mojom::PageHandler,", "                  chromeos::media_perception::mojom::MediaPerception,", "                 chromeos::multidevice_setup::mojom::MultiDeviceSetup,", "                 chromeos::multidevice_setup::mojom::PrivilegedHostDeviceSetter,", "                 chromeos::network_config::mojom::CrosNetworkConfig,", "                 cros::mojom::CameraAppDeviceProvider,", " #endif", "                 contextual_search::mojom::ContextualSearchJsApiService,", " #if BUILDFLAG(ENABLE_EXTENSIONS)", "                 extensions::KeepAlive,", " #endif", "                 media::mojom::MediaEngagementScoreDetailsProvider,", "                 media_router::mojom::MediaRouter,", "                 page_load_metrics::mojom::PageLoadMetrics,", "                 translate::mojom::ContentTranslateDriver,", " ", "                 downloads::mojom::PageHandlerFactory,", "                 feed_internals::mojom::PageHandler,", "                 new_tab_page::mojom::PageHandlerFactory,", " #if defined(OS_ANDROID)", "                 explore_sites_internals::mojom::PageHandler,", " #else", "                 app_management::mojom::PageHandlerFactory,", " #endif", " #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \\", "     defined(OS_CHROMEOS)", "                 discards::mojom::DetailsProvider, discards::mojom::GraphDump,", " #endif", " #if defined(OS_CHROMEOS)", "                 add_supervision::mojom::AddSupervisionHandler,", " #endif", "                 mojom::BluetoothInternalsHandler,", "                 mojom::InterventionsInternalsPageHandler,", "                 mojom::OmniboxPageHandler, mojom::ResetPasswordHandler,", "                 mojom::SiteEngagementDetailsProvider,", "                 mojom::UsbInternalsPageHandler,", "                 snippets_internals::mojom::PageHandlerFactory>())", "         .PackageService(prefs::GetManifest())", " #if defined(OS_CHROMEOS)", "         .PackageService(chromeos::multidevice_setup::GetManifest())", " #endif   ", "         .Build()", "   };", "   return *manifest;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void SaveCardBubbleControllerImpl::ShowBubbleForLocalSave(", "      const CreditCard& card,", "      const base::Closure& save_card_callback) {", "    ", "   if (save_card_bubble_view_)", "     return;", " ", "    is_uploading_ = false;", "    is_reshow_ = false;", "    should_cvc_be_requested_ = false;", "   legal_message_lines_.clear();", " ", "   AutofillMetrics::LogSaveCardPromptMetric(", "       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,", "       is_reshow_,", "       pref_service_->GetInteger(", "           prefs::kAutofillAcceptSaveCreditCardPromptState));", " ", "   card_ = card;", "   save_card_callback_ = save_card_callback;", "   ShowBubble();", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void inet_sock_destruct(struct sock *sk)", " {", " \tstruct inet_sock *inet = inet_sk(sk);", " ", " \t__skb_queue_purge(&sk->sk_receive_queue);", " \t__skb_queue_purge(&sk->sk_error_queue);", " ", " \tsk_mem_reclaim(sk);", " ", " \tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {", " \t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",", " \t\t       sk->sk_state, sk);", " \t\treturn;", " \t}", " \tif (!sock_flag(sk, SOCK_DEAD)) {", " \t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);", " \t\treturn;", " \t}", " ", " \tWARN_ON(atomic_read(&sk->sk_rmem_alloc));", " \tWARN_ON(atomic_read(&sk->sk_wmem_alloc));", "  \tWARN_ON(sk->sk_wmem_queued);", "  \tWARN_ON(sk->sk_forward_alloc);", "  ", "\tkfree(inet->opt);", " \tkfree(rcu_dereference_protected(inet->inet_opt, 1));", "  \tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));", "  \tsk_refcnt_debug_dec(sk);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {", "__Pyx_RefNannyDeclarations", "__Pyx_RefNannySetupContext(\"__Pyx_InitCachedConstants\", 0);", "", "", "", "", "", "", "", "", "__pyx_tuple_ = PyTuple_Pack(5, __pyx_n_s_number, __pyx_n_s_buf, __pyx_n_s_i, __pyx_n_s_towrite, __pyx_n_s_num_buf); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 4, __pyx_L1_error)", "__Pyx_GOTREF(__pyx_tuple_);", "__Pyx_GIVEREF(__pyx_tuple_);", "__pyx_codeobj__2 = (PyObject*)__Pyx_PyCode_New(2, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple_, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_write_varint, 4, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__2)) __PYX_ERR(0, 4, __pyx_L1_error)", "", "", "", "", "", "", "", "", "__pyx_tuple__3 = PyTuple_Pack(5, __pyx_n_s_f, __pyx_n_s_shift, __pyx_n_s_result, __pyx_n_s_i, __pyx_n_s_read_one); if (unlikely(!__pyx_tuple__3)) __PYX_ERR(0, 29, __pyx_L1_error)", "__Pyx_GOTREF(__pyx_tuple__3);", "__Pyx_GIVEREF(__pyx_tuple__3);", "__pyx_codeobj__4 = (PyObject*)__Pyx_PyCode_New(1, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__3, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_clickhouse_driver_varint_pyx, __pyx_n_s_read_varint, 29, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__4)) __PYX_ERR(0, 29, __pyx_L1_error)", "__Pyx_RefNannyFinishContext();", "return 0;", "__pyx_L1_error:;", "__Pyx_RefNannyFinishContext();", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void close_uinput (void)", " ", "  {", "      BTIF_TRACE_DEBUG(\"%s\", __FUNCTION__);", "      if (uinput_fd > 0) {", "        ioctl(uinput_fd, UI_DEV_DESTROY);", "         TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));", "  ", "          close(uinput_fd);", "          uinput_fd = -1;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void SplashOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,", " \t\t\t\tint width, int height,", " \t\t\t\tGfxImageColorMap *colorMap,", " \t\t\t\tint *maskColors, GBool inlineImg) {", "   double *ctm;", "   SplashCoord mat[6];", "   SplashOutImageData imgData;", "   SplashColorMode srcMode;", "   SplashImageSource src;", "   GfxGray gray;", "   GfxRGB rgb;", " #if SPLASH_CMYK", "   GfxCMYK cmyk;", " #endif", "   Guchar pix;", "   int n, i;", " ", "   ctm = state->getCTM();", "   mat[0] = ctm[0];", "   mat[1] = ctm[1];", "   mat[2] = -ctm[2];", "   mat[3] = -ctm[3];", "   mat[4] = ctm[2] + ctm[4];", "   mat[5] = ctm[3] + ctm[5];", " ", "   imgData.imgStr = new ImageStream(str, width,", " \t\t\t\t   colorMap->getNumPixelComps(),", " \t\t\t\t   colorMap->getBits());", "   imgData.imgStr->reset();", "   imgData.colorMap = colorMap;", "   imgData.maskColors = maskColors;", "   imgData.colorMode = colorMode;", "   imgData.width = width;", "   imgData.height = height;", "   imgData.y = 0;", " ", "   imgData.lookup = NULL;", "   if (colorMap->getNumPixelComps() == 1) {", "     n = 1 << colorMap->getBits();", "     switch (colorMode) {", "     case splashModeMono1:", "     case splashModeMono8:", "       imgData.lookup = (SplashColorPtr)gmalloc(n);", "       for (i = 0; i < n; ++i) {", " \tpix = (Guchar)i;", " \tcolorMap->getGray(&pix, &gray);", " \timgData.lookup[i] = colToByte(gray);", "       }", "        break;", "      case splashModeRGB8:", "      case splashModeBGR8:", "      imgData.lookup = (SplashColorPtr)gmalloc(3 * n);", "       imgData.lookup = (SplashColorPtr)gmallocn(n, 3);", "        for (i = 0; i < n; ++i) {", "  \tpix = (Guchar)i;", "  \tcolorMap->getRGB(&pix, &rgb);", " \timgData.lookup[3*i] = colToByte(rgb.r);", " \timgData.lookup[3*i+1] = colToByte(rgb.g);", " \timgData.lookup[3*i+2] = colToByte(rgb.b);", "        }", "        break;", "      case splashModeXBGR8:", "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);", "       imgData.lookup = (SplashColorPtr)gmallocn(n, 3);", "        for (i = 0; i < n; ++i) {", "  \tpix = (Guchar)i;", "  \tcolorMap->getRGB(&pix, &rgb);", " \timgData.lookup[4*i] = colToByte(rgb.r);", " \timgData.lookup[4*i+1] = colToByte(rgb.g);", " \timgData.lookup[4*i+2] = colToByte(rgb.b);", " \timgData.lookup[4*i+3] = 255;", "       }", "        break;", "  #if SPLASH_CMYK", "      case splashModeCMYK8:", "      imgData.lookup = (SplashColorPtr)gmalloc(4 * n);", "       imgData.lookup = (SplashColorPtr)gmallocn(n, 4);", "        for (i = 0; i < n; ++i) {", "  \tpix = (Guchar)i;", "  \tcolorMap->getCMYK(&pix, &cmyk);", " \timgData.lookup[4*i] = colToByte(cmyk.c);", " \timgData.lookup[4*i+1] = colToByte(cmyk.m);", " \timgData.lookup[4*i+2] = colToByte(cmyk.y);", " \timgData.lookup[4*i+3] = colToByte(cmyk.k);", "       }", "       break;", " #endif", "       break;", "     }", "   }", " ", "   if (colorMode == splashModeMono1) {", "     srcMode = splashModeMono8;", "   } else {", "     srcMode = colorMode;", "   }", "   src = maskColors ? &alphaImageSrc : &imageSrc;", "   splash->drawImage(src, &imgData, srcMode, maskColors ? gTrue : gFalse,", " \t\t    width, height, mat);", "   if (inlineImg) {", "     while (imgData.y < height) {", "       imgData.imgStr->getLine();", "       ++imgData.y;", "     }", "   }", " ", "   gfree(imgData.lookup);", "   delete imgData.imgStr;", "   str->close();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bool FromkLinuxSockAddr(const struct klinux_sockaddr *input,", "socklen_t input_len, struct sockaddr *output,", "socklen_t *output_len,", "void (*abort_handler)(const char *)) {", "if (!input || !output || !output_len || input_len == 0) {", "output = nullptr;", "return false;", "}", "", "int16_t klinux_family = input->klinux_sa_family;", "if (klinux_family == kLinux_AF_UNIX) {", "struct klinux_sockaddr_un *klinux_sockaddr_un_in =", "const_cast<struct klinux_sockaddr_un *>(", "reinterpret_cast<const struct klinux_sockaddr_un *>(input));", "", "struct sockaddr_un sockaddr_un_out;", "sockaddr_un_out.sun_family = AF_UNIX;", "InitializeToZeroArray(sockaddr_un_out.sun_path);", "ReinterpretCopyArray(", "sockaddr_un_out.sun_path, klinux_sockaddr_un_in->klinux_sun_path,", "std::min(sizeof(sockaddr_un_out.sun_path),", "sizeof(klinux_sockaddr_un_in->klinux_sun_path)));", "CopySockaddr(&sockaddr_un_out, sizeof(sockaddr_un_out), output, output_len);", "} else if (klinux_family == kLinux_AF_INET) {", "struct klinux_sockaddr_in *klinux_sockaddr_in_in =", "const_cast<struct klinux_sockaddr_in *>(", "reinterpret_cast<const struct klinux_sockaddr_in *>(input));", "", "struct sockaddr_in sockaddr_in_out;", "sockaddr_in_out.sin_family = AF_INET;", "sockaddr_in_out.sin_port = klinux_sockaddr_in_in->klinux_sin_port;", "InitializeToZeroSingle(&sockaddr_in_out.sin_addr);", "ReinterpretCopySingle(&sockaddr_in_out.sin_addr,", "&klinux_sockaddr_in_in->klinux_sin_addr);", "InitializeToZeroArray(sockaddr_in_out.sin_zero);", "ReinterpretCopyArray(sockaddr_in_out.sin_zero,", "klinux_sockaddr_in_in->klinux_sin_zero);", "CopySockaddr(&sockaddr_in_out, sizeof(sockaddr_in_out), output, output_len);", "} else if (klinux_family == kLinux_AF_INET6) {", "struct klinux_sockaddr_in6 *klinux_sockaddr_in6_in =", "const_cast<struct klinux_sockaddr_in6 *>(", "reinterpret_cast<const struct klinux_sockaddr_in6 *>(input));", "", "struct sockaddr_in6 sockaddr_in6_out;", "sockaddr_in6_out.sin6_family = AF_INET6;", "sockaddr_in6_out.sin6_port = klinux_sockaddr_in6_in->klinux_sin6_port;", "sockaddr_in6_out.sin6_flowinfo =", "klinux_sockaddr_in6_in->klinux_sin6_flowinfo;", "sockaddr_in6_out.sin6_scope_id =", "klinux_sockaddr_in6_in->klinux_sin6_scope_id;", "InitializeToZeroSingle(&sockaddr_in6_out.sin6_addr);", "ReinterpretCopySingle(&sockaddr_in6_out.sin6_addr,", "&klinux_sockaddr_in6_in->klinux_sin6_addr);", "CopySockaddr(&sockaddr_in6_out, sizeof(sockaddr_in6_out), output,", "output_len);", "} else if (klinux_family == kLinux_AF_UNSPEC) {", "output = nullptr;", "*output_len = 0;", "} else {", "if (abort_handler != nullptr) {", "std::string message = absl::StrCat(", "\"Type conversion error - Unsupported AF family: \", klinux_family);", "abort_handler(message.c_str());", "} else {", "abort();", "}", "}", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" METHODDEF(JDIMENSION)", " get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)", "  ", "  {", "    bmp_source_ptr source = (bmp_source_ptr)sinfo;", "    register JSAMPARRAY colormap = source->colormap;", "   int cmaplen = source->cmap_length;", "    JSAMPARRAY image_ptr;", "    register int t;", "    register JSAMPROW inptr, outptr;", "   register JDIMENSION col;", " ", "   if (source->use_inversion_array) {", "      ", "     source->source_row--;", "     image_ptr = (*cinfo->mem->access_virt_sarray)", "       ((j_common_ptr)cinfo, source->whole_image,", "        source->source_row, (JDIMENSION)1, FALSE);", "     inptr = image_ptr[0];", "   } else {", "     if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))", "       ERREXIT(cinfo, JERR_INPUT_EOF);", "     inptr = source->iobuffer;", "   }", " ", "    ", "   outptr = source->pub.buffer[0];", "    if (cinfo->in_color_space == JCS_GRAYSCALE) {", "      for (col = cinfo->image_width; col > 0; col--) {", "        t = GETJSAMPLE(*inptr++);", "       if (t >= cmaplen)", "         ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);", "        *outptr++ = colormap[0][t];", "      }", "    } else if (cinfo->in_color_space == JCS_CMYK) {", "      for (col = cinfo->image_width; col > 0; col--) {", "        t = GETJSAMPLE(*inptr++);", "       if (t >= cmaplen)", "         ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);", "        rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,", "                    outptr + 1, outptr + 2, outptr + 3);", "        outptr += 4;", "     }", "   } else {", "     register int rindex = rgb_red[cinfo->in_color_space];", "     register int gindex = rgb_green[cinfo->in_color_space];", "     register int bindex = rgb_blue[cinfo->in_color_space];", "     register int aindex = alpha_index[cinfo->in_color_space];", "     register int ps = rgb_pixelsize[cinfo->in_color_space];", " ", "      if (aindex >= 0) {", "        for (col = cinfo->image_width; col > 0; col--) {", "          t = GETJSAMPLE(*inptr++);", "         if (t >= cmaplen)", "           ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);", "          outptr[rindex] = colormap[0][t];", "          outptr[gindex] = colormap[1][t];", "          outptr[bindex] = colormap[2][t];", "         outptr[aindex] = 0xFF;", "         outptr += ps;", "       }", "      } else {", "        for (col = cinfo->image_width; col > 0; col--) {", "          t = GETJSAMPLE(*inptr++);", "         if (t >= cmaplen)", "           ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);", "          outptr[rindex] = colormap[0][t];", "          outptr[gindex] = colormap[1][t];", "          outptr[bindex] = colormap[2][t];", "         outptr += ps;", "       }", "     }", "   }", " ", "   return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void __fput_sync(struct file *file)", "  {", "  \tif (atomic_long_dec_and_test(&file->f_count)) {", "  \t\tstruct task_struct *task = current;", "\t\tfile_sb_list_del(file);", "  \t\tBUG_ON(!(task->flags & PF_KTHREAD));", "  \t\t__fput(file);", "  \t}", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,", "                                                               bool ask_user,", "                                                               bool is_allowed) {", "   DCHECK_CURRENTLY_ON(BrowserThread::IO);", " ", "   auto iter = sessions_.find(session_id);", "   if (iter == sessions_.end())", "     return;", " ", "   Session* session = iter->second.get();", " ", "   if (session->abort_requested)", "     return;", " ", "    if (ask_user) {", "      SpeechRecognitionSessionContext& context = session->context;", "      context.label = media_stream_manager_->MakeMediaAccessRequest(", "        context.render_process_id, context.render_frame_id, session_id,", "        StreamControls(true, false), context.security_origin,", "         context.render_process_id, context.render_frame_id, requester_id_,", "         session_id, StreamControls(true, false), context.security_origin,", "          base::BindOnce(", "              &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,", "              weak_factory_.GetWeakPtr(), session_id));", "     return;", "   }", " ", "   if (is_allowed) {", "     base::ThreadTaskRunnerHandle::Get()->PostTask(", "         FROM_HERE,", "         base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,", "                        weak_factory_.GetWeakPtr(), session_id, EVENT_START));", "   } else {", "     OnRecognitionError(", "         session_id, blink::mojom::SpeechRecognitionError(", "                         blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,", "                         blink::mojom::SpeechAudioErrorDetails::kNone));", "     base::ThreadTaskRunnerHandle::Get()->PostTask(", "         FROM_HERE,", "         base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,", "                        weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static const char *vgacon_startup(void)", "{", "const char *display_desc = NULL;", "u16 saved1, saved2;", "volatile u16 *p;", "", "if (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB ||", "screen_info.orig_video_isVGA == VIDEO_TYPE_EFI) {", "no_vga:", "#ifdef CONFIG_DUMMY_CONSOLE", "conswitchp = &dummy_con;", "return conswitchp->con_startup();", "#else", "return NULL;", "#endif", "}", "", "", "if ((screen_info.orig_video_lines == 0) ||", "(screen_info.orig_video_cols  == 0))", "goto no_vga;", "", "", "if ((screen_info.orig_video_mode == 0x0D) ||", "(screen_info.orig_video_mode == 0x0E) ||", "(screen_info.orig_video_mode == 0x10) ||", "(screen_info.orig_video_mode == 0x12) ||", "(screen_info.orig_video_mode == 0x6A))", "goto no_vga;", "", "vga_video_num_lines = screen_info.orig_video_lines;", "vga_video_num_columns = screen_info.orig_video_cols;", "vgastate.vgabase = NULL;", "", "if (screen_info.orig_video_mode == 7) {", "", "vga_vram_base = 0xb0000;", "vga_video_port_reg = VGA_CRT_IM;", "vga_video_port_val = VGA_CRT_DM;", "if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {", "static struct resource ega_console_resource =", "{ .name = \"ega\",", ".flags = IORESOURCE_IO,", ".start = 0x3B0,", ".end = 0x3BF };", "vga_video_type = VIDEO_TYPE_EGAM;", "vga_vram_size = 0x8000;", "display_desc = \"EGA+\";", "request_resource(&ioport_resource,", "&ega_console_resource);", "} else {", "static struct resource mda1_console_resource =", "{ .name = \"mda\",", ".flags = IORESOURCE_IO,", ".start = 0x3B0,", ".end = 0x3BB };", "static struct resource mda2_console_resource =", "{ .name = \"mda\",", ".flags = IORESOURCE_IO,", ".start = 0x3BF,", ".end = 0x3BF };", "vga_video_type = VIDEO_TYPE_MDA;", "vga_vram_size = 0x2000;", "display_desc = \"*MDA\";", "request_resource(&ioport_resource,", "&mda1_console_resource);", "request_resource(&ioport_resource,", "&mda2_console_resource);", "vga_video_font_height = 14;", "}", "} else {", "", "vga_can_do_color = true;", "vga_vram_base = 0xb8000;", "vga_video_port_reg = VGA_CRT_IC;", "vga_video_port_val = VGA_CRT_DC;", "if ((screen_info.orig_video_ega_bx & 0xff) != 0x10) {", "int i;", "", "vga_vram_size = 0x8000;", "", "if (!screen_info.orig_video_isVGA) {", "static struct resource ega_console_resource =", "{ .name = \"ega\",", ".flags = IORESOURCE_IO,", ".start = 0x3C0,", ".end = 0x3DF };", "vga_video_type = VIDEO_TYPE_EGAC;", "display_desc = \"EGA\";", "request_resource(&ioport_resource,", "&ega_console_resource);", "} else {", "static struct resource vga_console_resource =", "{ .name = \"vga+\",", ".flags = IORESOURCE_IO,", ".start = 0x3C0,", ".end = 0x3DF };", "vga_video_type = VIDEO_TYPE_VGAC;", "display_desc = \"VGA+\";", "request_resource(&ioport_resource,", "&vga_console_resource);", "", "", "", "", "", "", "", "for (i = 0; i < 16; i++) {", "inb_p(VGA_IS1_RC);", "outb_p(i, VGA_ATT_W);", "outb_p(i, VGA_ATT_W);", "}", "outb_p(0x20, VGA_ATT_W);", "", "", "", "", "", "for (i = 0; i < 16; i++) {", "outb_p(color_table[i], VGA_PEL_IW);", "outb_p(default_red[i], VGA_PEL_D);", "outb_p(default_grn[i], VGA_PEL_D);", "outb_p(default_blu[i], VGA_PEL_D);", "}", "}", "} else {", "static struct resource cga_console_resource =", "{ .name = \"cga\",", ".flags = IORESOURCE_IO,", ".start = 0x3D4,", ".end = 0x3D5 };", "vga_video_type = VIDEO_TYPE_CGA;", "vga_vram_size = 0x2000;", "display_desc = \"*CGA\";", "request_resource(&ioport_resource,", "&cga_console_resource);", "vga_video_font_height = 8;", "}", "}", "", "vga_vram_base = VGA_MAP_MEM(vga_vram_base, vga_vram_size);", "vga_vram_end = vga_vram_base + vga_vram_size;", "", "", "", "", "", "p = (volatile u16 *) vga_vram_base;", "saved1 = scr_readw(p);", "saved2 = scr_readw(p + 1);", "scr_writew(0xAA55, p);", "scr_writew(0x55AA, p + 1);", "if (scr_readw(p) != 0xAA55 || scr_readw(p + 1) != 0x55AA) {", "scr_writew(saved1, p);", "scr_writew(saved2, p + 1);", "goto no_vga;", "}", "scr_writew(0x55AA, p);", "scr_writew(0xAA55, p + 1);", "if (scr_readw(p) != 0x55AA || scr_readw(p + 1) != 0xAA55) {", "scr_writew(saved1, p);", "scr_writew(saved2, p + 1);", "goto no_vga;", "}", "scr_writew(saved1, p);", "scr_writew(saved2, p + 1);", "", "if (vga_video_type == VIDEO_TYPE_EGAC", "|| vga_video_type == VIDEO_TYPE_VGAC", "|| vga_video_type == VIDEO_TYPE_EGAM) {", "vga_hardscroll_enabled = vga_hardscroll_user_enable;", "vga_default_font_height = screen_info.orig_video_points;", "vga_video_font_height = screen_info.orig_video_points;", "", "vga_scan_lines =", "vga_video_font_height * vga_video_num_lines;", "}", "", "vgacon_xres = screen_info.orig_video_cols * VGA_FONTWIDTH;", "vgacon_yres = vga_scan_lines;", "", "if (!vga_init_done) {", "vgacon_scrollback_startup();", "vga_init_done = true;", "}", "", "return display_desc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["_hivex_get_children (hive_h *h, hive_node_h node,", "hive_node_h **children_ret, size_t **blocks_ret,", "int flags)", "{", "if (!IS_VALID_BLOCK (h, node) || !block_id_eq (h, node, \"nk\")) {", "SET_ERRNO (EINVAL, \"invalid block or not an 'nk' block\");", "return -1;", "}", "", "struct ntreg_nk_record *nk =", "(struct ntreg_nk_record *) ((char *) h->addr + node);", "", "size_t nr_subkeys_in_nk = le32toh (nk->nr_subkeys);", "", "offset_list children, blocks;", "_hivex_init_offset_list (h, &children);", "_hivex_init_offset_list (h, &blocks);", "", "", "if (nr_subkeys_in_nk == 0)", "goto out;", "", "", "if (nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS) {", "SET_ERRNO (ERANGE,", "\"nr_subkeys_in_nk > HIVEX_MAX_SUBKEYS (%zu > %d)\",", "nr_subkeys_in_nk, HIVEX_MAX_SUBKEYS);", "goto error;", "}", "", "", "_hivex_set_offset_list_limit (&children, nr_subkeys_in_nk);", "", "", "", "", "", "", "_hivex_set_offset_list_limit (&blocks, HIVEX_MAX_SUBKEYS);", "", "", "if (_hivex_grow_offset_list (&children, nr_subkeys_in_nk) == -1)", "goto error;", "", "", "", "", "", "size_t subkey_lf = le32toh (nk->subkey_lf);", "subkey_lf += 0x1000;", "if (!IS_VALID_BLOCK (h, subkey_lf)) {", "SET_ERRNO (EFAULT,", "\"subkey_lf is not a valid block (0x%zx)\", subkey_lf);", "goto error;", "}", "", "if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)", "goto error;", "", "", "", "", "size_t nr_children = _hivex_get_offset_list_length (&children);", "if (nr_subkeys_in_nk != nr_children) {", "if (!h->unsafe) {", "SET_ERRNO (ENOTSUP,", "\"nr_subkeys_in_nk = %zu \"", "\"is not equal to number of children read %zu\",", "nr_subkeys_in_nk, nr_children);", "goto error;", "} else {", "DEBUG (2,", "\"nr_subkeys_in_nk = %zu \"", "\"is not equal to number of children read %zu\",", "nr_subkeys_in_nk, nr_children);", "}", "}", "", "out:", "#if 0", "if (h->msglvl >= 2) {", "fprintf (stderr, \"%s: %s: children = \", \"hivex\", __func__);", "_hivex_print_offset_list (&children, stderr);", "fprintf (stderr, \"\\n%s: %s: blocks = \", \"hivex\", __func__);", "_hivex_print_offset_list (&blocks, stderr);", "fprintf (stderr, \"\\n\");", "}", "#endif", "", "*children_ret = _hivex_return_offset_list (&children);", "*blocks_ret = _hivex_return_offset_list (&blocks);", "if (!*children_ret || !*blocks_ret)", "goto error;", "return 0;", "", "error:", "_hivex_free_offset_list (&children);", "_hivex_free_offset_list (&blocks);", "return -1;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["setup_seccomp (FlatpakBwrap   *bwrap,", "const char     *arch,", "gulong          allowed_personality,", "FlatpakRunFlags run_flags,", "GError        **error)", "{", "gboolean multiarch = (run_flags & FLATPAK_RUN_FLAG_MULTIARCH) != 0;", "gboolean devel = (run_flags & FLATPAK_RUN_FLAG_DEVEL) != 0;", "", "__attribute__((cleanup (cleanup_seccomp))) scmp_filter_ctx seccomp = NULL;", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "struct", "{", "int                  scall;", "struct scmp_arg_cmp *arg;", "} syscall_blocklist[] = {", "", "{SCMP_SYS (syslog)},", "", "{SCMP_SYS (uselib)},", "", "{SCMP_SYS (acct)},", "", "", "{SCMP_SYS (modify_ldt)},", "", "{SCMP_SYS (quotactl)},", "", "", "{SCMP_SYS (add_key)},", "{SCMP_SYS (keyctl)},", "{SCMP_SYS (request_key)},", "", "", "{SCMP_SYS (move_pages)},", "{SCMP_SYS (mbind)},", "{SCMP_SYS (get_mempolicy)},", "{SCMP_SYS (set_mempolicy)},", "{SCMP_SYS (migrate_pages)},", "", "", "{SCMP_SYS (unshare)},", "{SCMP_SYS (mount)},", "{SCMP_SYS (pivot_root)},", "#if defined(__s390__) || defined(__s390x__) || defined(__CRIS__)", "", "", "{SCMP_SYS (clone), &SCMP_A1 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},", "#else", "", "{SCMP_SYS (clone), &SCMP_A0 (SCMP_CMP_MASKED_EQ, CLONE_NEWUSER, CLONE_NEWUSER)},", "#endif", "", "", "{SCMP_SYS (ioctl), &SCMP_A1 (SCMP_CMP_MASKED_EQ, 0xFFFFFFFFu, (int) TIOCSTI)},", "};", "", "struct", "{", "int                  scall;", "struct scmp_arg_cmp *arg;", "} syscall_nondevel_blocklist[] = {", "", "", "", "{SCMP_SYS (perf_event_open)},", "", "{SCMP_SYS (personality), &SCMP_A0 (SCMP_CMP_NE, allowed_personality)},", "{SCMP_SYS (ptrace)}", "};", "", "struct", "{", "int             family;", "FlatpakRunFlags flags_mask;", "} socket_family_allowlist[] = {", "", "{ AF_UNSPEC, 0 },", "{ AF_LOCAL, 0 },", "{ AF_INET, 0 },", "{ AF_INET6, 0 },", "{ AF_NETLINK, 0 },", "{ AF_CAN, FLATPAK_RUN_FLAG_CANBUS },", "{ AF_BLUETOOTH, FLATPAK_RUN_FLAG_BLUETOOTH },", "};", "int last_allowed_family;", "int i, r;", "g_auto(GLnxTmpfile) seccomp_tmpf  = { 0, };", "", "seccomp = seccomp_init (SCMP_ACT_ALLOW);", "if (!seccomp)", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Initialize seccomp failed\"));", "", "if (arch != NULL)", "{", "uint32_t arch_id = 0;", "const uint32_t *extra_arches = NULL;", "", "if (strcmp (arch, \"i386\") == 0)", "{", "arch_id = SCMP_ARCH_X86;", "}", "else if (strcmp (arch, \"x86_64\") == 0)", "{", "arch_id = SCMP_ARCH_X86_64;", "extra_arches = seccomp_x86_64_extra_arches;", "}", "else if (strcmp (arch, \"arm\") == 0)", "{", "arch_id = SCMP_ARCH_ARM;", "}", "#ifdef SCMP_ARCH_AARCH64", "else if (strcmp (arch, \"aarch64\") == 0)", "{", "arch_id = SCMP_ARCH_AARCH64;", "extra_arches = seccomp_aarch64_extra_arches;", "}", "#endif", "", "", "", "if (arch_id != 0)", "{", "", "", "", "", "", "r = seccomp_arch_add (seccomp, arch_id);", "if (r < 0 && r != -EEXIST)", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add architecture to seccomp filter\"));", "", "if (multiarch && extra_arches != NULL)", "{", "for (i = 0; extra_arches[i] != 0; i++)", "{", "r = seccomp_arch_add (seccomp, extra_arches[i]);", "if (r < 0 && r != -EEXIST)", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to add multiarch architecture to seccomp filter\"));", "}", "}", "}", "}", "", "", "", "", "", "", "for (i = 0; i < G_N_ELEMENTS (syscall_blocklist); i++)", "{", "int scall = syscall_blocklist[i].scall;", "if (syscall_blocklist[i].arg)", "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_blocklist[i].arg);", "else", "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);", "if (r < 0 && r == -EFAULT                      )", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);", "}", "", "if (!devel)", "{", "for (i = 0; i < G_N_ELEMENTS (syscall_nondevel_blocklist); i++)", "{", "int scall = syscall_nondevel_blocklist[i].scall;", "if (syscall_nondevel_blocklist[i].arg)", "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 1, *syscall_nondevel_blocklist[i].arg);", "else", "r = seccomp_rule_add (seccomp, SCMP_ACT_ERRNO (EPERM), scall, 0);", "", "if (r < 0 && r == -EFAULT                      )", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to block syscall %d\"), scall);", "}", "}", "", "", "", "", "last_allowed_family = -1;", "for (i = 0; i < G_N_ELEMENTS (socket_family_allowlist); i++)", "{", "int family = socket_family_allowlist[i].family;", "int disallowed;", "", "if (socket_family_allowlist[i].flags_mask != 0 &&", "(socket_family_allowlist[i].flags_mask & run_flags) != socket_family_allowlist[i].flags_mask)", "continue;", "", "for (disallowed = last_allowed_family + 1; disallowed < family; disallowed++)", "{", "", "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_EQ, disallowed));", "}", "last_allowed_family = family;", "}", "", "seccomp_rule_add_exact (seccomp, SCMP_ACT_ERRNO (EAFNOSUPPORT), SCMP_SYS (socket), 1, SCMP_A0 (SCMP_CMP_GE, last_allowed_family + 1));", "", "if (!glnx_open_anonymous_tmpfile_full (O_RDWR | O_CLOEXEC, \"/tmp\", &seccomp_tmpf, error))", "return FALSE;", "", "if (seccomp_export_bpf (seccomp, seccomp_tmpf.fd) != 0)", "return flatpak_fail_error (error, FLATPAK_ERROR_SETUP_FAILED, _(\"Failed to export bpf\"));", "", "lseek (seccomp_tmpf.fd, 0, SEEK_SET);", "", "flatpak_bwrap_add_args_data_fd (bwrap,", "\"--seccomp\", glnx_steal_fd (&seccomp_tmpf.fd), NULL);", "", "return TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" mfr_print(netdissect_options *ndo,", "           register const u_char *p, u_int length)", " {", "     u_int tlen,idx,hdr_len = 0;", "     uint16_t sequence_num;", "     uint8_t ie_type,ie_len;", "     const uint8_t *tptr;", " ", " ", "  ", " ", "     ND_TCHECK2(*p, 4);  ", " ", "     if ((p[0] & MFR_BEC_MASK) == MFR_CTRL_FRAME && p[1] == 0) {", "         ND_PRINT((ndo, \"FRF.16 Control, Flags [%s], %s, length %u\",", "                bittok2str(frf_flag_values,\"none\",(p[0] & MFR_BEC_MASK)),", "                tok2str(mfr_ctrl_msg_values,\"Unknown Message (0x%02x)\",p[2]),", "                length));", "         tptr = p + 3;", "         tlen = length -3;", "         hdr_len = 3;", " ", "         if (!ndo->ndo_vflag)", "             return hdr_len;", " ", "         while (tlen>sizeof(struct ie_tlv_header_t)) {", "             ND_TCHECK2(*tptr, sizeof(struct ie_tlv_header_t));", "             ie_type=tptr[0];", "             ie_len=tptr[1];", " ", "             ND_PRINT((ndo, \"\\n\\tIE %s (%u), length %u: \",", "                    tok2str(mfr_ctrl_ie_values,\"Unknown\",ie_type),", "                    ie_type,", "                    ie_len));", " ", "              ", "             if (ie_type == 0 || ie_len <= sizeof(struct ie_tlv_header_t))", "                 return hdr_len;", " ", "             ND_TCHECK2(*tptr, ie_len);", "             tptr+=sizeof(struct ie_tlv_header_t);", "              ", "             ie_len-=sizeof(struct ie_tlv_header_t);", "             tlen-=sizeof(struct ie_tlv_header_t);", " ", "              switch (ie_type) {", "  ", "              case MFR_CTRL_IE_MAGIC_NUM:", "                  ", "                 if (ie_len != 4) {", "                     ND_PRINT((ndo, \"(invalid length)\"));", "                     break;", "                 }", "                  ND_PRINT((ndo, \"0x%08x\", EXTRACT_32BITS(tptr)));", "                  break;", "  ", "             case MFR_CTRL_IE_BUNDLE_ID:  ", "             case MFR_CTRL_IE_LINK_ID:", "                 for (idx = 0; idx < ie_len && idx < MFR_ID_STRING_MAXLEN; idx++) {", "                     if (*(tptr+idx) != 0)  ", "                         safeputchar(ndo, *(tptr + idx));", "                     else", "                         break;", "                 }", "                 break;", " ", "             case MFR_CTRL_IE_TIMESTAMP:", "                 if (ie_len == sizeof(struct timeval)) {", "                     ts_print(ndo, (const struct timeval *)tptr);", "                     break;", "                 }", "                  ", " ", "                  ", " ", "             case MFR_CTRL_IE_VENDOR_EXT:", "             case MFR_CTRL_IE_CAUSE:", " ", "             default:", "                 if (ndo->ndo_vflag <= 1)", "                     print_unknown_data(ndo, tptr, \"\\n\\t  \", ie_len);", "                 break;", "             }", " ", "              ", "             if (ndo->ndo_vflag > 1 )", "                 print_unknown_data(ndo, tptr, \"\\n\\t  \", ie_len);", " ", "             tlen-=ie_len;", "             tptr+=ie_len;", "         }", "         return hdr_len;", "     }", "  ", " ", "     sequence_num = (p[0]&0x1e)<<7 | p[1];", "      ", "     if ((p[0] & MFR_BEC_MASK) == MFR_FRAG_FRAME ||", "         (p[0] & MFR_BEC_MASK) == MFR_B_BIT) {", "         ND_PRINT((ndo, \"FRF.16 Frag, seq %u, Flags [%s], \",", "                sequence_num,", "                bittok2str(frf_flag_values,\"none\",(p[0] & MFR_BEC_MASK))));", "         hdr_len = 2;", "         fr_print(ndo, p+hdr_len,length-hdr_len);", "         return hdr_len;", "     }", " ", "      ", "     ND_PRINT((ndo, \"FRF.16 Frag, seq %u, Flags [%s]\",", "            sequence_num,", "            bittok2str(frf_flag_values,\"none\",(p[0] & MFR_BEC_MASK))));", "     print_unknown_data(ndo, p, \"\\n\\t\", length);", " ", "     return hdr_len;", " ", "  trunc:", "     ND_PRINT((ndo, \"[|mfr]\"));", "     return length;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,", "    png_byte bit_depth, png_uint_32 x, store_palette palette)", "     png_byte bit_depth, png_uint_32 x, store_palette palette,", "     const image_pixel *format  )", "  {", "   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==", "    const png_byte sample_depth = (png_byte)(colour_type ==", "        PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);", "   PNG_CONST unsigned int max = (1U<<sample_depth)-1;", "    const unsigned int max = (1U<<sample_depth)-1;", "    const int swap16 = (format != 0 && format->swap16);", "    const int littleendian = (format != 0 && format->littleendian);", "    const int sig_bits = (format != 0 && format->sig_bits);", "  ", "      ", "     this->palette_index = this->red = this->green = this->blue =", "      sample(row, colour_type, bit_depth, x, 0);", "       sample(row, colour_type, bit_depth, x, 0, swap16, littleendian);", "     this->alpha = max;", "     this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =", "        sample_depth;", " ", "   ", "  if (colour_type == 3)  ", "  {", " ", "         ", "        if (palette != 0)", "        {", "         PNG_CONST unsigned int i = this->palette_index;", "          const unsigned int i = this->palette_index;", "  ", "           this->red = palette[i].red;", "           this->green = palette[i].green;", "  this->blue = palette[i].blue;", "  this->alpha = palette[i].alpha;", "  }", "  }", " ", "  else  ", " ", "     {", "        unsigned int i = 0;", "  ", "       if ((colour_type & 4) != 0 && format != 0 && format->alpha_first)", "       {", "          this->alpha = this->red;", "           ", "          this->palette_index = this->red = this->green = this->blue =", "             sample(row, colour_type, bit_depth, x, 1, swap16, littleendian);", "          i = 1;", "       }", " ", "        if (colour_type & 2)", "        {", "         this->green = sample(row, colour_type, bit_depth, x, 1);", "         this->blue = sample(row, colour_type, bit_depth, x, 2);", "         i = 2;", "           ", "          this->green = sample(row, colour_type, bit_depth, x, ++i, swap16,", "                  littleendian);", " ", "          if (format != 0 && format->swap_rgb)  ", "              this->red = sample(row, colour_type, bit_depth, x, ++i, swap16,", "                      littleendian);", "          else", "              this->blue = sample(row, colour_type, bit_depth, x, ++i, swap16,", "                      littleendian);", "        }", "      if (colour_type & 4)", "         this->alpha = sample(row, colour_type, bit_depth, x, ++i);", " ", "       else   if (format != 0 && format->mono_inverted)", "          this->red = this->green = this->blue = this->red ^ max;", " ", "       if ((colour_type & 4) != 0)  ", "       {", "          if (format == 0 || !format->alpha_first)", "              this->alpha = sample(row, colour_type, bit_depth, x, ++i, swap16,", "                      littleendian);", " ", "          if (format != 0 && format->alpha_inverted)", "             this->alpha ^= max;", "       }", "     }", "  ", "      ", "   image_pixel_setf(this, max);", "    image_pixel_setf(this,", "       sig_bits ? (1U << format->red_sBIT)-1 : max,", "       sig_bits ? (1U << format->green_sBIT)-1 : max,", "       sig_bits ? (1U << format->blue_sBIT)-1 : max,", "       sig_bits ? (1U << format->alpha_sBIT)-1 : max);", "  ", "      ", "  this->colour_type = colour_type;", " ", "     this->bit_depth = bit_depth;", "     this->sample_depth = sample_depth;", "     this->have_tRNS = 0;", "    this->swap_rgb = 0;", "    this->alpha_first = 0;", "    this->alpha_inverted = 0;", "    this->mono_inverted = 0;", "    this->swap16 = 0;", "    this->littleendian = 0;", "    this->sig_bits = 0;", "  }"], "ner_tags": [0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["PQconnectPoll(PGconn *conn)", "{", "bool  reset_connection_state_machine = false;", "bool  need_new_connection = false;", "PGresult   *res;", "char  sebuf[PG_STRERROR_R_BUFLEN];", "int   optval;", "", "if (conn == NULL)", "return PGRES_POLLING_FAILED;", "", "", "switch (conn->status)", "{", "", "", "", "", "case CONNECTION_BAD:", "return PGRES_POLLING_FAILED;", "case CONNECTION_OK:", "return PGRES_POLLING_OK;", "", "", "case CONNECTION_AWAITING_RESPONSE:", "case CONNECTION_AUTH_OK:", "case CONNECTION_CHECK_WRITABLE:", "case CONNECTION_CONSUME:", "case CONNECTION_CHECK_STANDBY:", "{", "", "int   n = pqReadData(conn);", "", "if (n < 0)", "goto error_return;", "if (n == 0)", "return PGRES_POLLING_READING;", "", "break;", "}", "", "", "case CONNECTION_STARTED:", "case CONNECTION_MADE:", "break;", "", "", "case CONNECTION_SSL_STARTUP:", "case CONNECTION_NEEDED:", "case CONNECTION_GSS_STARTUP:", "case CONNECTION_CHECK_TARGET:", "break;", "", "default:", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"invalid connection state, probably indicative of memory corruption\\n\"));", "goto error_return;", "}", "", "", "keep_going:", "", "", "", "if (conn->try_next_addr)", "{", "if (conn->addr_cur && conn->addr_cur->ai_next)", "{", "conn->addr_cur = conn->addr_cur->ai_next;", "reset_connection_state_machine = true;", "}", "else", "conn->try_next_host = true;", "conn->try_next_addr = false;", "}", "", "", "if (conn->try_next_host)", "{", "pg_conn_host *ch;", "struct addrinfo hint;", "int   thisport;", "int   ret;", "char  portstr[MAXPGPATH];", "", "if (conn->whichhost + 1 < conn->nconnhost)", "conn->whichhost++;", "else", "{", "", "", "", "", "", "", "", "", "", "if (conn->target_server_type == SERVER_TYPE_PREFER_STANDBY &&", "conn->nconnhost > 0)", "{", "conn->target_server_type = SERVER_TYPE_PREFER_STANDBY_PASS2;", "conn->whichhost = 0;", "}", "else", "goto error_return;", "}", "", "", "release_conn_addrinfo(conn);", "", "", "", "", "", "", "ch = &conn->connhost[conn->whichhost];", "", "", "MemSet(&hint, 0, sizeof(hint));", "hint.ai_socktype = SOCK_STREAM;", "conn->addrlist_family = hint.ai_family = AF_UNSPEC;", "", "", "if (ch->port == NULL || ch->port[0] == '\\0')", "thisport = DEF_PGPORT;", "else", "{", "if (!parse_int_param(ch->port, &thisport, conn, \"port\"))", "goto error_return;", "", "if (thisport < 1 || thisport > 65535)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"invalid port number: \\\"%s\\\"\\n\"),", "ch->port);", "goto keep_going;", "}", "}", "snprintf(portstr, sizeof(portstr), \"%d\", thisport);", "", "", "switch (ch->type)", "{", "case CHT_HOST_NAME:", "ret = pg_getaddrinfo_all(ch->host, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not translate host name \\\"%s\\\" to address: %s\\n\"),", "ch->host, gai_strerror(ret));", "goto keep_going;", "}", "break;", "", "case CHT_HOST_ADDRESS:", "hint.ai_flags = AI_NUMERICHOST;", "ret = pg_getaddrinfo_all(ch->hostaddr, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not parse network address \\\"%s\\\": %s\\n\"),", "ch->hostaddr, gai_strerror(ret));", "goto keep_going;", "}", "break;", "", "case CHT_UNIX_SOCKET:", "#ifdef HAVE_UNIX_SOCKETS", "conn->addrlist_family = hint.ai_family = AF_UNIX;", "UNIXSOCK_PATH(portstr, thisport, ch->host);", "if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"Unix-domain socket path \\\"%s\\\" is too long (maximum %d bytes)\\n\"),", "portstr,", "(int) (UNIXSOCK_PATH_BUFLEN - 1));", "goto keep_going;", "}", "", "", "", "", "", "ret = pg_getaddrinfo_all(NULL, portstr, &hint,", "&conn->addrlist);", "if (ret || !conn->addrlist)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not translate Unix-domain socket path \\\"%s\\\" to address: %s\\n\"),", "portstr, gai_strerror(ret));", "goto keep_going;", "}", "#else", "Assert(false);", "#endif", "break;", "}", "", "", "conn->addr_cur = conn->addrlist;", "reset_connection_state_machine = true;", "conn->try_next_host = false;", "}", "", "", "if (reset_connection_state_machine)", "{", "", "", "", "", "", "", "conn->pversion = PG_PROTOCOL(3, 0);", "conn->send_appname = true;", "#ifdef USE_SSL", "", "conn->allow_ssl_try = (conn->sslmode[0] != 'd');", "conn->wait_ssl_try = (conn->sslmode[0] == 'a');", "#endif", "#ifdef ENABLE_GSS", "conn->try_gss = (conn->gssencmode[0] != 'd');", "#endif", "", "reset_connection_state_machine = false;", "need_new_connection = true;", "}", "", "", "if (need_new_connection)", "{", "", "pqDropConnection(conn, true);", "", "", "pqDropServerData(conn);", "", "", "conn->asyncStatus = PGASYNC_IDLE;", "conn->xactStatus = PQTRANS_IDLE;", "conn->pipelineStatus = PQ_PIPELINE_OFF;", "pqClearAsyncResult(conn);", "", "", "conn->status = CONNECTION_NEEDED;", "", "need_new_connection = false;", "}", "", "", "switch (conn->status)", "{", "case CONNECTION_NEEDED:", "{", "", "", "", "", "", "", "", "", "{", "struct addrinfo *addr_cur = conn->addr_cur;", "char  host_addr[NI_MAXHOST];", "", "", "", "", "", "if (addr_cur == NULL)", "{", "conn->try_next_host = true;", "goto keep_going;", "}", "", "", "memcpy(&conn->raddr.addr, addr_cur->ai_addr,", "addr_cur->ai_addrlen);", "conn->raddr.salen = addr_cur->ai_addrlen;", "", "", "", "", "", "if (conn->connip != NULL)", "{", "free(conn->connip);", "conn->connip = NULL;", "}", "getHostaddr(conn, host_addr, NI_MAXHOST);", "if (host_addr[0])", "conn->connip = strdup(host_addr);", "", "", "conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);", "if (conn->sock == PGINVALID_SOCKET)", "{", "int   errorno = SOCK_ERRNO;", "", "", "", "", "", "", "", "if (addr_cur->ai_next != NULL ||", "conn->whichhost + 1 < conn->nconnhost)", "{", "conn->try_next_addr = true;", "goto keep_going;", "}", "emitHostIdentityInfo(conn, host_addr);", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not create socket: %s\\n\"),", "SOCK_STRERROR(errorno, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "", "", "", "", "", "", "", "", "emitHostIdentityInfo(conn, host_addr);", "", "", "", "", "", "", "if (!IS_AF_UNIX(addr_cur->ai_family))", "{", "if (!connectNoDelay(conn))", "{", "", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "if (!pg_set_noblock(conn->sock))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not set socket to nonblocking mode: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "conn->try_next_addr = true;", "goto keep_going;", "}", "", "#ifdef F_SETFD", "if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not set socket to close-on-exec mode: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "conn->try_next_addr = true;", "goto keep_going;", "}", "#endif\t\t\t\t\t\t\t/* F_SETFD */", "", "if (!IS_AF_UNIX(addr_cur->ai_family))", "{", "#ifndef WIN32", "int   on = 1;", "#endif", "int   usekeepalives = useKeepalives(conn);", "int   err = 0;", "", "if (usekeepalives < 0)", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"keepalives parameter must be an integer\\n\"));", "err = 1;", "}", "else if (usekeepalives == 0)", "{", "", "}", "#ifndef WIN32", "else if (setsockopt(conn->sock,", "SOL_SOCKET, SO_KEEPALIVE,", "(char *) &on, sizeof(on)) < 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"%s(%s) failed: %s\\n\"),", "\"setsockopt\",", "\"SO_KEEPALIVE\",", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "err = 1;", "}", "else if (!setKeepalivesIdle(conn)", "|| !setKeepalivesInterval(conn)", "|| !setKeepalivesCount(conn))", "err = 1;", "#else\t\t\t\t\t\t\t/* WIN32 */", "#ifdef SIO_KEEPALIVE_VALS", "else if (!setKeepalivesWin32(conn))", "err = 1;", "#endif\t\t\t\t\t\t\t/* SIO_KEEPALIVE_VALS */", "#endif\t\t\t\t\t\t\t/* WIN32 */", "else if (!setTCPUserTimeout(conn))", "err = 1;", "", "if (err)", "{", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "conn->sigpipe_so = false;", "#ifdef MSG_NOSIGNAL", "conn->sigpipe_flag = true;", "#else", "conn->sigpipe_flag = false;", "#endif\t\t\t\t\t\t\t/* MSG_NOSIGNAL */", "", "#ifdef SO_NOSIGPIPE", "optval = 1;", "if (setsockopt(conn->sock, SOL_SOCKET, SO_NOSIGPIPE,", "(char *) &optval, sizeof(optval)) == 0)", "{", "conn->sigpipe_so = true;", "conn->sigpipe_flag = false;", "}", "#endif\t\t\t\t\t\t\t/* SO_NOSIGPIPE */", "", "", "", "", "", "if (connect(conn->sock, addr_cur->ai_addr,", "addr_cur->ai_addrlen) < 0)", "{", "if (SOCK_ERRNO == EINPROGRESS ||", "#ifdef WIN32", "SOCK_ERRNO == EWOULDBLOCK ||", "#endif", "SOCK_ERRNO == EINTR)", "{", "", "", "", "", "", "conn->status = CONNECTION_STARTED;", "return PGRES_POLLING_WRITING;", "}", "", "}", "else", "{", "", "", "", "", "", "conn->status = CONNECTION_STARTED;", "goto keep_going;", "}", "", "", "", "", "", "connectFailureMessage(conn, SOCK_ERRNO);", "conn->try_next_addr = true;", "goto keep_going;", "}", "}", "", "case CONNECTION_STARTED:", "{", "ACCEPT_TYPE_ARG3 optlen = sizeof(optval);", "", "", "", "", "", "", "", "", "", "", "", "if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,", "(char *) &optval, &optlen) == -1)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get socket error status: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "else if (optval != 0)", "{", "", "", "", "", "", "connectFailureMessage(conn, optval);", "", "", "", "", "", "conn->try_next_addr = true;", "goto keep_going;", "}", "", "", "conn->laddr.salen = sizeof(conn->laddr.addr);", "if (getsockname(conn->sock,", "(struct sockaddr *) &conn->laddr.addr,", "&conn->laddr.salen) < 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get client address from socket: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "", "", "", "", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "", "case CONNECTION_MADE:", "{", "char    *startpacket;", "int   packetlen;", "", "", "", "", "", "if (conn->requirepeer && conn->requirepeer[0] &&", "IS_AF_UNIX(conn->raddr.addr.ss_family))", "{", "#ifndef WIN32", "char  pwdbuf[BUFSIZ];", "struct passwd pass_buf;", "struct passwd *pass;", "int   passerr;", "#endif", "uid_t  uid;", "gid_t  gid;", "", "errno = 0;", "if (getpeereid(conn->sock, &uid, &gid) != 0)", "{", "", "", "", "", "if (errno == ENOSYS)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"requirepeer parameter is not supported on this platform\\n\"));", "else", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not get peer credentials: %s\\n\"),", "strerror_r(errno, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "", "#ifndef WIN32", "passerr = pqGetpwuid(uid, &pass_buf, pwdbuf, sizeof(pwdbuf), &pass);", "if (pass == NULL)", "{", "if (passerr != 0)", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not look up local user ID %d: %s\\n\"),", "(int) uid,", "strerror_r(passerr, sebuf, sizeof(sebuf)));", "else", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"local user with ID %d does not exist\\n\"),", "(int) uid);", "goto error_return;", "}", "", "if (strcmp(pass->pw_name, conn->requirepeer) != 0)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"requirepeer specifies \\\"%s\\\", but actual peer user name is \\\"%s\\\"\\n\"),", "conn->requirepeer, pass->pw_name);", "goto error_return;", "}", "#else\t\t\t\t\t\t\t/* WIN32 */", "", "Assert(false);", "#endif\t\t\t\t\t\t\t/* WIN32 */", "}", "", "if (IS_AF_UNIX(conn->raddr.addr.ss_family))", "{", "", "#ifdef USE_SSL", "conn->allow_ssl_try = false;", "#endif", "#ifdef ENABLE_GSS", "conn->try_gss = false;", "#endif", "}", "", "#ifdef ENABLE_GSS", "", "", "", "", "", "", "", "", "", "if (conn->try_gss && !conn->gctx)", "conn->try_gss = pg_GSS_have_cred_cache(&conn->gcred);", "if (conn->try_gss && !conn->gctx)", "{", "ProtocolVersion pv = pg_hton32(NEGOTIATE_GSS_CODE);", "", "if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send GSSAPI negotiation packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "", "", "conn->status = CONNECTION_GSS_STARTUP;", "return PGRES_POLLING_READING;", "}", "else if (!conn->gctx && conn->gssencmode[0] == 'r')", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"GSSAPI encryption required but was impossible (possibly no credential cache, no server support, or using a local socket)\\n\"));", "goto error_return;", "}", "#endif", "", "#ifdef USE_SSL", "", "", "", "", "", "", "", "", "if (pqsecure_initialize(conn, false, true) < 0)", "goto error_return;", "", "", "", "", "", "", "if (conn->allow_ssl_try && !conn->wait_ssl_try &&", "!conn->ssl_in_use", "#ifdef ENABLE_GSS", "&& !conn->gssenc", "#endif", ")", "{", "ProtocolVersion pv;", "", "", "", "", "", "", "", "", "pv = pg_hton32(NEGOTIATE_SSL_CODE);", "if (pqPacketSend(conn, 0, &pv, sizeof(pv)) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send SSL negotiation packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "goto error_return;", "}", "", "conn->status = CONNECTION_SSL_STARTUP;", "return PGRES_POLLING_READING;", "}", "#endif\t\t\t\t\t\t\t/* USE_SSL */", "", "", "", "", "startpacket = pqBuildStartupPacket3(conn, &packetlen,", "EnvironmentOptions);", "if (!startpacket)", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"out of memory\\n\"));", "goto error_return;", "}", "", "", "", "", "", "", "", "if (pqPacketSend(conn, 0, startpacket, packetlen) != STATUS_OK)", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"could not send startup packet: %s\\n\"),", "SOCK_STRERROR(SOCK_ERRNO, sebuf, sizeof(sebuf)));", "free(startpacket);", "goto error_return;", "}", "", "free(startpacket);", "", "conn->status = CONNECTION_AWAITING_RESPONSE;", "return PGRES_POLLING_READING;", "}", "", "", "", "", "", "case CONNECTION_SSL_STARTUP:", "{", "#ifdef USE_SSL", "PostgresPollingStatusType pollres;", "", "", "", "", "", "if (!conn->ssl_in_use)", "{", "", "", "", "", "", "char  SSLok;", "int   rdresult;", "", "rdresult = pqReadData(conn);", "if (rdresult < 0)", "{", "", "goto error_return;", "}", "if (rdresult == 0)", "{", "", "return PGRES_POLLING_READING;", "}", "if (pqGetc(&SSLok, conn) < 0)", "{", "", "return PGRES_POLLING_READING;", "}", "if (SSLok == 'S')", "{", "", "conn->inStart = conn->inCursor;", "", "", "", "", "", "", "", "if (pqsecure_initialize(conn, true, false) != 0)", "goto error_return;", "}", "else if (SSLok == 'N')", "{", "", "conn->inStart = conn->inCursor;", "", "if (conn->sslmode[0] == 'r' ||", "conn->sslmode[0] == 'v')", "", "{", "", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server does not support SSL, but SSL was required\\n\"));", "goto error_return;", "}", "", "conn->allow_ssl_try = false;", "", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (SSLok == 'E')", "{", "", "", "", "", "", "", "", "", "", "", "conn->status = CONNECTION_AWAITING_RESPONSE;", "goto keep_going;", "}", "else", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"received invalid response to SSL negotiation: %c\\n\"),", "SSLok);", "goto error_return;", "}", "}", "", "", "", "", "pollres = pqsecure_open_client(conn);", "if (pollres == PGRES_POLLING_OK)", "{", "", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "if (pollres == PGRES_POLLING_FAILED)", "{", "", "", "", "", "if (conn->sslmode[0] == 'p'", "&& conn->allow_ssl_try", "&& !conn->wait_ssl_try)", "{", "", "conn->allow_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "", "goto error_return;", "}", "", "return pollres;", "#else\t\t\t\t\t\t\t/* !USE_SSL */", "", "goto error_return;", "#endif\t\t\t\t\t\t\t/* USE_SSL */", "}", "", "case CONNECTION_GSS_STARTUP:", "{", "#ifdef ENABLE_GSS", "PostgresPollingStatusType pollres;", "", "", "", "", "", "if (conn->try_gss && !conn->gctx)", "{", "char  gss_ok;", "int   rdresult = pqReadData(conn);", "", "if (rdresult < 0)", "", "goto error_return;", "else if (rdresult == 0)", "", "return PGRES_POLLING_READING;", "if (pqGetc(&gss_ok, conn) < 0)", "", "return PGRES_POLLING_READING;", "", "if (gss_ok == 'E')", "{", "", "", "", "", "", "", "", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "", "", "conn->inStart = conn->inCursor;", "", "if (gss_ok == 'N')", "{", "", "if (conn->gssencmode[0] == 'r')", "{", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server doesn't support GSSAPI encryption, but it was required\\n\"));", "goto error_return;", "}", "", "conn->try_gss = false;", "", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (gss_ok != 'G')", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"received invalid response to GSSAPI negotiation: %c\\n\"),", "gss_ok);", "goto error_return;", "}", "}", "", "", "pollres = pqsecure_open_gss(conn);", "if (pollres == PGRES_POLLING_OK)", "{", "", "conn->status = CONNECTION_MADE;", "return PGRES_POLLING_WRITING;", "}", "else if (pollres == PGRES_POLLING_FAILED &&", "conn->gssencmode[0] == 'p')", "{", "", "", "", "", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "return pollres;", "#else\t\t\t\t\t\t\t/* !ENABLE_GSS */", "", "goto error_return;", "#endif\t\t\t\t\t\t\t/* ENABLE_GSS */", "}", "", "", "", "", "", "case CONNECTION_AWAITING_RESPONSE:", "{", "char  beresp;", "int   msgLength;", "int   avail;", "AuthRequest areq;", "int   res;", "", "", "", "", "", "", "conn->inCursor = conn->inStart;", "", "", "if (pqGetc(&beresp, conn))", "{", "", "return PGRES_POLLING_READING;", "}", "", "", "", "", "", "", "if (!(beresp == 'R' || beresp == 'E'))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"expected authentication request from server, but received %c\\n\"),", "beresp);", "goto error_return;", "}", "", "", "if (pqGetInt(&msgLength, 4, conn))", "{", "", "return PGRES_POLLING_READING;", "}", "", "", "", "", "", "", "", "", "", "", "", "if (beresp == 'R' && (msgLength < 8 || msgLength > 2000))", "{", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"expected authentication request from server, but received %c\\n\"),", "beresp);", "goto error_return;", "}", "", "if (beresp == 'E' && (msgLength < 8 || msgLength > 30000))", "{", "", "conn->inCursor = conn->inStart + 1;", "if (pqGets_append(&conn->errorMessage, conn))", "{", "", "return PGRES_POLLING_READING;", "}", "", "conn->inStart = conn->inCursor;", "", "", "", "", "", "", "if (conn->errorMessage.len == 0 ||", "conn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')", "{", "appendPQExpBufferChar(&conn->errorMessage, '\\n');", "}", "", "goto error_return;", "}", "", "", "", "", "msgLength -= 4;", "avail = conn->inEnd - conn->inCursor;", "if (avail < msgLength)", "{", "", "", "", "", "", "if (pqCheckInBufferSpace(conn->inCursor + (size_t) msgLength,", "conn))", "goto error_return;", "", "return PGRES_POLLING_READING;", "}", "", "", "if (beresp == 'E')", "{", "if (pqGetErrorNotice3(conn, true))", "{", "", "return PGRES_POLLING_READING;", "}", "", "conn->inStart = conn->inCursor;", "", "", "", "", "", "", "", "", "if (strcmp(conn->last_sqlstate,", "ERRCODE_CANNOT_CONNECT_NOW) == 0)", "{", "conn->try_next_host = true;", "goto keep_going;", "}", "", "", "pgpassfileWarning(conn);", "", "#ifdef ENABLE_GSS", "", "", "", "", "", "if (conn->gssenc && conn->gssencmode[0] == 'p')", "{", "", "conn->try_gss = false;", "need_new_connection = true;", "goto keep_going;", "}", "#endif", "", "#ifdef USE_SSL", "", "", "", "", "", "if (conn->sslmode[0] == 'a'", "&& !conn->ssl_in_use", "&& conn->allow_ssl_try", "&& conn->wait_ssl_try)", "{", "", "conn->wait_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "", "", "", "", "", "if (conn->sslmode[0] == 'p'", "&& conn->ssl_in_use", "&& conn->allow_ssl_try", "&& !conn->wait_ssl_try)", "{", "", "conn->allow_ssl_try = false;", "need_new_connection = true;", "goto keep_going;", "}", "#endif", "", "goto error_return;", "}", "", "", "conn->auth_req_received = true;", "", "", "if (pqGetInt((int *) &areq, 4, conn))", "{", "", "return PGRES_POLLING_READING;", "}", "msgLength -= 4;", "", "", "", "", "", "", "", "", "res = pg_fe_sendauth(areq, msgLength, conn);", "", "", "conn->inStart = conn->inCursor;", "", "if (res != STATUS_OK)", "goto error_return;", "", "", "", "", "", "", "if (pqFlush(conn))", "goto error_return;", "", "if (areq == AUTH_REQ_OK)", "{", "", "conn->status = CONNECTION_AUTH_OK;", "", "", "", "", "", "", "conn->asyncStatus = PGASYNC_BUSY;", "}", "", "", "goto keep_going;", "}", "", "case CONNECTION_AUTH_OK:", "{", "", "", "", "", "", "", "", "", "", "", "", "", "if (PQisBusy(conn))", "return PGRES_POLLING_READING;", "", "res = PQgetResult(conn);", "", "", "", "", "", "if (res)", "{", "if (res->resultStatus != PGRES_FATAL_ERROR)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"unexpected message from server during startup\\n\"));", "else if (conn->send_appname &&", "(conn->appname || conn->fbappname))", "{", "", "", "", "", "", "", "", "", "", "", "const char *sqlstate;", "", "sqlstate = PQresultErrorField(res, PG_DIAG_SQLSTATE);", "if (sqlstate &&", "strcmp(sqlstate, ERRCODE_APPNAME_UNKNOWN) == 0)", "{", "PQclear(res);", "conn->send_appname = false;", "need_new_connection = true;", "goto keep_going;", "}", "}", "", "", "", "", "", "", "", "if (conn->errorMessage.len <= 0 ||", "conn->errorMessage.data[conn->errorMessage.len - 1] != '\\n')", "appendPQExpBufferChar(&conn->errorMessage, '\\n');", "PQclear(res);", "goto error_return;", "}", "", "", "conn->status = CONNECTION_CHECK_TARGET;", "goto keep_going;", "}", "", "case CONNECTION_CHECK_TARGET:", "{", "", "", "", "", "if (conn->target_server_type == SERVER_TYPE_READ_WRITE ||", "conn->target_server_type == SERVER_TYPE_READ_ONLY)", "{", "bool  read_only_server;", "", "", "", "", "", "", "", "", "if (conn->default_transaction_read_only == PG_BOOL_UNKNOWN ||", "conn->in_hot_standby == PG_BOOL_UNKNOWN)", "{", "", "", "", "", "", "", "conn->status = CONNECTION_OK;", "if (!PQsendQueryContinue(conn,", "\"SHOW transaction_read_only\"))", "goto error_return;", "", "conn->status = CONNECTION_CHECK_WRITABLE;", "return PGRES_POLLING_READING;", "}", "", "", "read_only_server =", "(conn->default_transaction_read_only == PG_BOOL_YES ||", "conn->in_hot_standby == PG_BOOL_YES);", "", "if ((conn->target_server_type == SERVER_TYPE_READ_WRITE) ?", "read_only_server : !read_only_server)", "{", "", "if (conn->target_server_type == SERVER_TYPE_READ_WRITE)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"session is read-only\\n\"));", "else", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"session is not read-only\\n\"));", "", "", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "", "", "", "", "", "conn->try_next_host = true;", "goto keep_going;", "}", "}", "else if (conn->target_server_type == SERVER_TYPE_PRIMARY ||", "conn->target_server_type == SERVER_TYPE_STANDBY ||", "conn->target_server_type == SERVER_TYPE_PREFER_STANDBY)", "{", "", "", "", "", "", "", "", "", "if (conn->sversion < 90000)", "conn->in_hot_standby = PG_BOOL_NO;", "", "if (conn->in_hot_standby == PG_BOOL_UNKNOWN)", "{", "", "", "", "", "", "", "conn->status = CONNECTION_OK;", "if (!PQsendQueryContinue(conn,", "\"SELECT pg_catalog.pg_is_in_recovery()\"))", "goto error_return;", "", "conn->status = CONNECTION_CHECK_STANDBY;", "return PGRES_POLLING_READING;", "}", "", "", "if ((conn->target_server_type == SERVER_TYPE_PRIMARY) ?", "(conn->in_hot_standby == PG_BOOL_YES) :", "(conn->in_hot_standby == PG_BOOL_NO))", "{", "", "if (conn->target_server_type == SERVER_TYPE_PRIMARY)", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server is in hot standby mode\\n\"));", "else", "appendPQExpBufferStr(&conn->errorMessage,", "libpq_gettext(\"server is not in hot standby mode\\n\"));", "", "", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "", "", "", "", "", "conn->try_next_host = true;", "goto keep_going;", "}", "}", "", "", "release_conn_addrinfo(conn);", "", "", "", "", "", "", "resetPQExpBuffer(&conn->errorMessage);", "", "", "conn->status = CONNECTION_OK;", "return PGRES_POLLING_OK;", "}", "", "case CONNECTION_CONSUME:", "{", "", "", "", "", "", "", "", "", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CONSUME;", "return PGRES_POLLING_READING;", "}", "", "", "res = PQgetResult(conn);", "if (res != NULL)", "{", "PQclear(res);", "conn->status = CONNECTION_CONSUME;", "return PGRES_POLLING_READING;", "}", "", "conn->status = CONNECTION_CHECK_TARGET;", "goto keep_going;", "}", "", "case CONNECTION_CHECK_WRITABLE:", "{", "", "", "", "", "", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CHECK_WRITABLE;", "return PGRES_POLLING_READING;", "}", "", "res = PQgetResult(conn);", "if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&", "PQntuples(res) == 1)", "{", "char    *val = PQgetvalue(res, 0, 0);", "", "", "", "", "", "", "", "", "", "", "if (strncmp(val, \"on\", 2) == 0)", "{", "conn->default_transaction_read_only = PG_BOOL_YES;", "conn->in_hot_standby = PG_BOOL_YES;", "}", "else", "{", "conn->default_transaction_read_only = PG_BOOL_NO;", "conn->in_hot_standby = PG_BOOL_NO;", "}", "PQclear(res);", "", "", "conn->status = CONNECTION_CONSUME;", "goto keep_going;", "}", "", "", "if (res)", "PQclear(res);", "", "", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"\\\"%s\\\" failed\\n\"),", "\"SHOW transaction_read_only\");", "", "", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "", "", "conn->try_next_host = true;", "goto keep_going;", "}", "", "case CONNECTION_CHECK_STANDBY:", "{", "", "", "", "", "", "conn->status = CONNECTION_OK;", "if (!PQconsumeInput(conn))", "goto error_return;", "", "if (PQisBusy(conn))", "{", "conn->status = CONNECTION_CHECK_STANDBY;", "return PGRES_POLLING_READING;", "}", "", "res = PQgetResult(conn);", "if (res && PQresultStatus(res) == PGRES_TUPLES_OK &&", "PQntuples(res) == 1)", "{", "char    *val = PQgetvalue(res, 0, 0);", "", "if (strncmp(val, \"t\", 1) == 0)", "conn->in_hot_standby = PG_BOOL_YES;", "else", "conn->in_hot_standby = PG_BOOL_NO;", "PQclear(res);", "", "", "conn->status = CONNECTION_CONSUME;", "goto keep_going;", "}", "", "", "if (res)", "PQclear(res);", "", "", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"\\\"%s\\\" failed\\n\"),", "\"SELECT pg_is_in_recovery()\");", "", "", "conn->status = CONNECTION_OK;", "sendTerminateConn(conn);", "", "", "conn->try_next_host = true;", "goto keep_going;", "}", "", "default:", "appendPQExpBuffer(&conn->errorMessage,", "libpq_gettext(\"invalid connection state %d, \"", "\"probably indicative of memory corruption\\n\"),", "conn->status);", "goto error_return;", "}", "", "", "", "error_return:", "", "", "", "", "", "", "", "", "conn->status = CONNECTION_BAD;", "return PGRES_POLLING_FAILED;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_re_ast_create(", "     RE_AST** re_ast)", " {", "   *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));", " ", "   if (*re_ast == NULL)", "      return ERROR_INSUFFICIENT_MEMORY;", "  ", "    (*re_ast)->flags = 0;", "   (*re_ast)->levels = 0;", "    (*re_ast)->root_node = NULL;", "  ", "    return ERROR_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" status_t OMXNodeInstance::configureVideoTunnelMode(", " ", "          OMX_U32 portIndex, OMX_BOOL tunneled, OMX_U32 audioHwSync,", "          native_handle_t **sidebandHandle) {", "      Mutex::Autolock autolock(mLock);", "     if (mSailed) {", "         android_errorWriteLog(0x534e4554, \"29422020\");", "         return INVALID_OPERATION;", "     }", "      CLOG_CONFIG(configureVideoTunnelMode, \"%s:%u tun=%d sync=%u\",", "              portString(portIndex), portIndex, tunneled, audioHwSync);", "  ", "     OMX_INDEXTYPE index;", "     OMX_STRING name = const_cast<OMX_STRING>(", "  \"OMX.google.android.index.configureVideoTunnelMode\");", " ", "     OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);", "  if (err != OMX_ErrorNone) {", "         CLOG_ERROR_IF(tunneled, getExtensionIndex, err, \"%s\", name);", "  return StatusFromOMXError(err);", "  }", " ", "  ConfigureVideoTunnelModeParams tunnelParams;", "  InitOMXParams(&tunnelParams);", "     tunnelParams.nPortIndex = portIndex;", "     tunnelParams.bTunneled = tunneled;", "     tunnelParams.nAudioHwSync = audioHwSync;", "     err = OMX_SetParameter(mHandle, index, &tunnelParams);", "  if (err != OMX_ErrorNone) {", "         CLOG_ERROR(setParameter, err, \"%s(%#x): %s:%u tun=%d sync=%u\", name, index,", "                 portString(portIndex), portIndex, tunneled, audioHwSync);", "  return StatusFromOMXError(err);", "  }", " ", "     err = OMX_GetParameter(mHandle, index, &tunnelParams);", "  if (err != OMX_ErrorNone) {", "         CLOG_ERROR(getParameter, err, \"%s(%#x): %s:%u tun=%d sync=%u\", name, index,", "                 portString(portIndex), portIndex, tunneled, audioHwSync);", "  return StatusFromOMXError(err);", "  }", "  if (sidebandHandle) {", "  *sidebandHandle = (native_handle_t*)tunnelParams.pSidebandWindow;", "  }", " ", "  return OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)", " {", " \twhile (elements-- > 0) {", " \t\tzval *key, *data, **old_data;", " ", " \t\tALLOC_INIT_ZVAL(key);", " ", " \t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {", " \t\t\tzval_dtor(key);", " \t\t\tFREE_ZVAL(key);", " \t\t\treturn 0;", " \t\t}", " ", " \t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {", " \t\t\tzval_dtor(key);", " \t\t\tFREE_ZVAL(key);", " \t\t\treturn 0;", " \t\t}", " ", " \t\tALLOC_INIT_ZVAL(data);", " ", " \t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {", " \t\t\tzval_dtor(key);", " \t\t\tFREE_ZVAL(key);", " \t\t\tzval_dtor(data);", " \t\t\tFREE_ZVAL(data);", " \t\t\treturn 0;", " \t\t}", " ", " \t\tif (!objprops) {", " \t\t\tswitch (Z_TYPE_P(key)) {", " \t\t\tcase IS_LONG:", " \t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {", " \t\t\t\t\tvar_push_dtor(var_hash, old_data);", " \t\t\t\t}", " \t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);", " \t\t\t\tbreak;", " \t\t\tcase IS_STRING:", " \t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {", " \t\t\t\t\tvar_push_dtor(var_hash, old_data);", " \t\t\t\t}", " \t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t} else {", "  \t\t\t ", "  \t\t\tconvert_to_string(key);", "\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {", " \t\t\tif (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {", "  \t\t\t\tvar_push_dtor(var_hash, old_data);", "  \t\t\t}", "  \t\t\tzend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,", " \t\t\t\t\tsizeof data, NULL);", " \t\t}", " \t\t", " \t\tzval_dtor(key);", " \t\tFREE_ZVAL(key);", " ", " \t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {", " \t\t\t(*p)--;", " \t\t\treturn 0;", " \t\t}", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) {", "mpz_t xdiff, ydiff, lambda;", "mpz_inits(xdiff, ydiff, lambda, NULL);", "", "", "mpz_sub(ydiff, op2->y, op1->y);", "mpz_sub(xdiff, op2->x, op1->x);", "mpz_invert(xdiff, xdiff, curve->p);", "mpz_mul(lambda, ydiff, xdiff);", "mpz_mod(lambda, lambda, curve->p);", "", "", "mpz_mul(rop->x, lambda, lambda);", "mpz_sub(rop->x, rop->x, op1->x);", "mpz_sub(rop->x, rop->x, op2->x);", "mpz_mod(rop->x, rop->x, curve->p);", "", "", "mpz_sub(rop->y, op1->x, rop->x);", "mpz_mul(rop->y, lambda, rop->y);", "mpz_sub(rop->y, rop->y, op1->y);", "mpz_mod(rop->y, rop->y, curve->p);", "", "mpz_clears(xdiff, ydiff, lambda, NULL);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" int Track::Info::Copy(Info& dst) const {", "  if (&dst == this)", "  return 0;", " ", "   dst.type = type;", "   dst.number = number;", "   dst.defaultDuration = defaultDuration;", "   dst.codecDelay = codecDelay;", "   dst.seekPreRoll = seekPreRoll;", "   dst.uid = uid;", "   dst.lacing = lacing;", "   dst.settings = settings;", " ", " ", "  if (int status = CopyStr(&Info::nameAsUTF8, dst))", "  return status;", " ", "  if (int status = CopyStr(&Info::language, dst))", "  return status;", " ", "  if (int status = CopyStr(&Info::codecId, dst))", "  return status;", " ", "  if (int status = CopyStr(&Info::codecNameAsUTF8, dst))", "  return status;", " ", "  if (codecPrivateSize > 0) {", "  if (codecPrivate == NULL)", "  return -1;", " ", "  if (dst.codecPrivate)", "  return -1;", " ", " ", "      if (dst.codecPrivateSize != 0)", "        return -1;", "  ", "    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];", "     dst.codecPrivate = SafeArrayAlloc<unsigned char>(1, codecPrivateSize);", "  ", "      if (dst.codecPrivate == NULL)", "        return -1;", " ", "     memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);", "     dst.codecPrivateSize = codecPrivateSize;", "  }", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void RenderThreadImpl::Init(", "     const scoped_refptr<base::SingleThreadTaskRunner>& resource_task_queue) {", "   TRACE_EVENT0(\"startup\", \"RenderThreadImpl::Init\");", " ", "   base::trace_event::TraceLog::GetInstance()->SetThreadSortIndex(", "       base::PlatformThread::CurrentId(),", "       kTraceEventRendererMainThreadSortIndex);", " ", " #if BUILDFLAG(USE_EXTERNAL_POPUP_MENU)", "   blink::WebView::SetUseExternalPopupMenus(true);", " #endif", " ", "   lazy_tls.Pointer()->Set(this);", " ", "   ChildProcess::current()->set_main_thread(this);", " ", "   metrics::InitializeSingleSampleMetricsFactory(", "       base::BindRepeating(&CreateSingleSampleMetricsProvider,", "                           message_loop()->task_runner(), GetConnector()));", " ", "   gpu_ = ui::Gpu::Create(", "       GetConnector(),", "       IsRunningInMash() ? ui::mojom::kServiceName : mojom::kBrowserServiceName,", "       GetIOTaskRunner());", " ", "   viz::mojom::SharedBitmapAllocationNotifierPtr", "       shared_bitmap_allocation_notifier_ptr;", "   GetConnector()->BindInterface(", "       mojom::kBrowserServiceName,", "       mojo::MakeRequest(&shared_bitmap_allocation_notifier_ptr));", "   shared_bitmap_manager_ = std::make_unique<viz::ClientSharedBitmapManager>(", "       viz::mojom::ThreadSafeSharedBitmapAllocationNotifierPtr::Create(", "           shared_bitmap_allocation_notifier_ptr.PassInterface(),", "           GetChannel()->ipc_task_runner_refptr()));", " ", "   notification_dispatcher_ =", "       new NotificationDispatcher(thread_safe_sender());", "   AddFilter(notification_dispatcher_->GetFilter());", " ", "   resource_dispatcher_.reset(new ResourceDispatcher(", "       this, message_loop()->task_runner()));", "   resource_message_filter_ =", "       new ChildResourceMessageFilter(resource_dispatcher_.get());", "   AddFilter(resource_message_filter_.get());", "   quota_message_filter_ =", "       new QuotaMessageFilter(thread_safe_sender());", "   quota_dispatcher_.reset(new QuotaDispatcher(thread_safe_sender(),", "                                               quota_message_filter_.get()));", " ", "   AddFilter(quota_message_filter_->GetFilter());", " ", "   auto registry = std::make_unique<service_manager::BinderRegistry>();", "   BlinkInterfaceRegistryImpl interface_registry(registry->GetWeakPtr());", " ", "   InitializeWebKit(resource_task_queue, &interface_registry);", "   blink_initialized_time_ = base::TimeTicks::Now();", " ", "   webkit_shared_timer_suspended_ = false;", "   widget_count_ = 0;", "   hidden_widget_count_ = 0;", "   idle_notification_delay_in_ms_ = kInitialIdleHandlerDelayMs;", "   idle_notifications_to_skip_ = 0;", " ", "   appcache_dispatcher_.reset(", "       new AppCacheDispatcher(Get(), new AppCacheFrontendImpl()));", "   dom_storage_dispatcher_.reset(new DomStorageDispatcher());", "   main_thread_indexed_db_dispatcher_.reset(new IndexedDBDispatcher());", "   main_thread_cache_storage_dispatcher_.reset(", "       new CacheStorageDispatcher(thread_safe_sender()));", "   file_system_dispatcher_.reset(new FileSystemDispatcher());", " ", "   resource_dispatch_throttler_.reset(new ResourceDispatchThrottler(", "       static_cast<RenderThread*>(this), renderer_scheduler_.get(),", "       base::TimeDelta::FromSecondsD(kThrottledResourceRequestFlushPeriodS),", "       kMaxResourceRequestsPerFlushWhenThrottled));", "   resource_dispatcher_->set_message_sender(resource_dispatch_throttler_.get());", " ", "   blob_message_filter_ = new BlobMessageFilter(GetFileThreadTaskRunner());", "   AddFilter(blob_message_filter_.get());", "   vc_manager_.reset(new VideoCaptureImplManager());", " ", "   browser_plugin_manager_.reset(new BrowserPluginManager());", "   AddObserver(browser_plugin_manager_.get());", " ", " #if BUILDFLAG(ENABLE_WEBRTC)", "   peer_connection_tracker_.reset(new PeerConnectionTracker());", "   AddObserver(peer_connection_tracker_.get());", " ", "   p2p_socket_dispatcher_ = new P2PSocketDispatcher(GetIOTaskRunner().get());", "   AddFilter(p2p_socket_dispatcher_.get());", " ", "   peer_connection_factory_.reset(", "       new PeerConnectionDependencyFactory(p2p_socket_dispatcher_.get()));", " ", "   aec_dump_message_filter_ = new AecDumpMessageFilter(", "       GetIOTaskRunner(), message_loop()->task_runner());", " ", "   AddFilter(aec_dump_message_filter_.get());", " ", " #endif   ", " ", "   audio_input_message_filter_ = new AudioInputMessageFilter(GetIOTaskRunner());", "   AddFilter(audio_input_message_filter_.get());", " ", "   scoped_refptr<AudioMessageFilter> audio_message_filter;", "   if (!base::FeatureList::IsEnabled(", "           features::kUseMojoAudioOutputStreamFactory)) {", "     audio_message_filter =", "         base::MakeRefCounted<AudioMessageFilter>(GetIOTaskRunner());", "     AddFilter(audio_message_filter.get());", "   }", " ", "   audio_ipc_factory_.emplace(std::move(audio_message_filter),", "                              GetIOTaskRunner());", " ", "   midi_message_filter_ = new MidiMessageFilter(GetIOTaskRunner());", "   AddFilter(midi_message_filter_.get());", " ", "   AddFilter((new CacheStorageMessageFilter(thread_safe_sender()))->GetFilter());", " ", "   AddFilter((new ServiceWorkerContextMessageFilter())->GetFilter());", " ", " ", " #if defined(USE_AURA)", "   if (IsRunningInMash()) {", "     CreateRenderWidgetWindowTreeClientFactory(GetServiceManagerConnection());", "   }", " #endif", " ", "   registry->AddInterface(base::Bind(&SharedWorkerFactoryImpl::Create),", "                          base::ThreadTaskRunnerHandle::Get());", "   GetServiceManagerConnection()->AddConnectionFilter(", "       std::make_unique<SimpleConnectionFilter>(std::move(registry)));", " ", "   {", "     auto registry_with_source_info =", "         std::make_unique<service_manager::BinderRegistryWithArgs<", "             const service_manager::BindSourceInfo&>>();", "     registry_with_source_info->AddInterface(", "         base::Bind(&CreateFrameFactory), base::ThreadTaskRunnerHandle::Get());", "     GetServiceManagerConnection()->AddConnectionFilter(", "         std::make_unique<SimpleConnectionFilterWithSourceInfo>(", "             std::move(registry_with_source_info)));", "   }", " ", "   GetContentClient()->renderer()->RenderThreadStarted();", " ", "   StartServiceManagerConnection();", " ", "   GetAssociatedInterfaceRegistry()->AddInterface(", "       base::Bind(&RenderThreadImpl::OnRendererInterfaceRequest,", "                  base::Unretained(this)));", " ", "   InitSkiaEventTracer();", "   base::trace_event::MemoryDumpManager::GetInstance()->RegisterDumpProvider(", "       skia::SkiaMemoryDumpProvider::GetInstance(), \"Skia\", nullptr);", " ", "   const base::CommandLine& command_line =", "       *base::CommandLine::ForCurrentProcess();", " ", " #if defined(ENABLE_IPC_FUZZER)", "   if (command_line.HasSwitch(switches::kIpcDumpDirectory)) {", "     base::FilePath dump_directory =", "         command_line.GetSwitchValuePath(switches::kIpcDumpDirectory);", "     IPC::ChannelProxy::OutgoingMessageFilter* filter =", "         LoadExternalIPCDumper(dump_directory);", "     GetChannel()->set_outgoing_message_filter(filter);", "   }", " #endif", " ", "   cc::SetClientNameForMetrics(\"Renderer\");", " ", "   is_threaded_animation_enabled_ =", "       !command_line.HasSwitch(cc::switches::kDisableThreadedAnimation);", " ", "   is_zero_copy_enabled_ = command_line.HasSwitch(switches::kEnableZeroCopy);", "   is_partial_raster_enabled_ =", "       !command_line.HasSwitch(switches::kDisablePartialRaster);", "   is_gpu_memory_buffer_compositor_resources_enabled_ = command_line.HasSwitch(", "       switches::kEnableGpuMemoryBufferCompositorResources);", " ", " #if defined(OS_MACOSX)", "   is_elastic_overscroll_enabled_ = true;", " #else", "   is_elastic_overscroll_enabled_ = false;", " #endif", " ", "   std::string image_texture_target_string =", "       command_line.GetSwitchValueASCII(switches::kContentImageTextureTarget);", "   buffer_to_texture_target_map_ =", "       viz::StringToBufferToTextureTargetMap(image_texture_target_string);", " ", "   if (command_line.HasSwitch(switches::kDisableLCDText)) {", "     is_lcd_text_enabled_ = false;", "   } else if (command_line.HasSwitch(switches::kEnableLCDText)) {", "     is_lcd_text_enabled_ = true;", "   } else {", " #if defined(OS_ANDROID)", "     is_lcd_text_enabled_ = false;", " #else", "     is_lcd_text_enabled_ = true;", " #endif", "   }", " ", "   if (command_line.HasSwitch(switches::kDisableGpuCompositing))", "     is_gpu_compositing_disabled_ = true;", " ", "   is_gpu_rasterization_forced_ =", "       command_line.HasSwitch(switches::kForceGpuRasterization);", "   is_async_worker_context_enabled_ =", "       command_line.HasSwitch(switches::kEnableGpuAsyncWorkerContext);", " ", "   if (command_line.HasSwitch(switches::kGpuRasterizationMSAASampleCount)) {", "     std::string string_value = command_line.GetSwitchValueASCII(", "         switches::kGpuRasterizationMSAASampleCount);", "     bool parsed_msaa_sample_count =", "         base::StringToInt(string_value, &gpu_rasterization_msaa_sample_count_);", "     DCHECK(parsed_msaa_sample_count) << string_value;", "     DCHECK_GE(gpu_rasterization_msaa_sample_count_, 0);", "   } else {", "     gpu_rasterization_msaa_sample_count_ = -1;", "   }", " ", "   if (command_line.HasSwitch(switches::kDisableDistanceFieldText)) {", "     is_distance_field_text_enabled_ = false;", "   } else if (command_line.HasSwitch(switches::kEnableDistanceFieldText)) {", "     is_distance_field_text_enabled_ = true;", "   } else {", "     is_distance_field_text_enabled_ = false;", "   }", " ", "   WebRuntimeFeatures::EnableCompositorImageAnimations(", "       command_line.HasSwitch(switches::kEnableCompositorImageAnimations));", " ", "   media::InitializeMediaLibrary();", " ", " #if defined(OS_ANDROID)", "   if (!command_line.HasSwitch(switches::kDisableAcceleratedVideoDecode) &&", "       media::MediaCodecUtil::IsMediaCodecAvailable()) {", "     media::EnablePlatformDecoderSupport();", "   }", " #endif", " ", "   memory_pressure_listener_.reset(new base::MemoryPressureListener(", "       base::Bind(&RenderThreadImpl::OnMemoryPressure, base::Unretained(this)),", "       base::Bind(&RenderThreadImpl::OnSyncMemoryPressure,", "                  base::Unretained(this))));", " ", "   if (base::FeatureList::IsEnabled(features::kMemoryCoordinator)) {", "     base::MemoryPressureListener::SetNotificationsSuppressed(true);", " ", "     mojom::MemoryCoordinatorHandlePtr parent_coordinator;", "     GetConnector()->BindInterface(mojom::kBrowserServiceName,", "                                   mojo::MakeRequest(&parent_coordinator));", "     memory_coordinator_ = CreateChildMemoryCoordinator(", "         std::move(parent_coordinator), this);", "   }", " ", "   int num_raster_threads = 0;", "   std::string string_value =", "       command_line.GetSwitchValueASCII(switches::kNumRasterThreads);", "   bool parsed_num_raster_threads =", "       base::StringToInt(string_value, &num_raster_threads);", "   DCHECK(parsed_num_raster_threads) << string_value;", "   DCHECK_GT(num_raster_threads, 0);", " ", "   categorized_worker_pool_->Start(num_raster_threads);", " ", "   discardable_memory::mojom::DiscardableSharedMemoryManagerPtr manager_ptr;", "   if (IsRunningInMash()) {", " #if defined(USE_AURA)", "     GetServiceManagerConnection()->GetConnector()->BindInterface(", "         ui::mojom::kServiceName, &manager_ptr);", " #else", "     NOTREACHED();", " #endif", "   } else {", "     ChildThread::Get()->GetConnector()->BindInterface(", "         mojom::kBrowserServiceName, mojo::MakeRequest(&manager_ptr));", "   }", " ", "   discardable_shared_memory_manager_ = std::make_unique<", "       discardable_memory::ClientDiscardableSharedMemoryManager>(", "       std::move(manager_ptr), GetIOTaskRunner());", " ", "   base::DiscardableMemoryAllocator::SetInstance(", "       discardable_shared_memory_manager_.get());", " ", "   GetConnector()->BindInterface(mojom::kBrowserServiceName,", "                                 mojo::MakeRequest(&storage_partition_service_));", " ", " #if defined(OS_LINUX)", "   ChildProcess::current()->SetIOThreadPriority(base::ThreadPriority::DISPLAY);", "   ChildThreadImpl::current()->SetThreadPriority(", "       categorized_worker_pool_->background_worker_thread_id(),", "       base::ThreadPriority::BACKGROUND);", " #endif", " ", "   process_foregrounded_count_ = 0;", "   needs_to_record_first_active_paint_ = false;", "   was_backgrounded_time_ = base::TimeTicks::Min();", " ", "   base::MemoryCoordinatorClientRegistry::GetInstance()->Register(this);", " ", "    if (!command_line.HasSwitch(switches::kSingleProcess))", "      base::SequencedWorkerPool::EnableForProcess();", "  ", "  EVP_set_buggy_rsa_parser(", "      base::FeatureList::IsEnabled(features::kBuggyRSAParser));", "    GetConnector()->BindInterface(mojom::kBrowserServiceName,", "                                  mojo::MakeRequest(&frame_sink_provider_));", "  ", "   if (!is_gpu_compositing_disabled_) {", "     GetConnector()->BindInterface(", "         mojom::kBrowserServiceName,", "         mojo::MakeRequest(&compositing_mode_reporter_));", " ", "     viz::mojom::CompositingModeWatcherPtr watcher_ptr;", "     compositing_mode_watcher_binding_.Bind(mojo::MakeRequest(&watcher_ptr));", "     compositing_mode_reporter_->AddCompositingModeWatcher(", "         std::move(watcher_ptr));", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void encode_share_access(struct xdr_stream *xdr, int open_flags)", " static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)", "  {", "  \t__be32 *p;", "  ", "  \tRESERVE_SPACE(8);", "\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {", " \tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {", "  \t\tcase FMODE_READ:", "  \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);", "  \t\t\tbreak;", " \t\tcase FMODE_WRITE:", " \t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);", " \t\t\tbreak;", " \t\tcase FMODE_READ|FMODE_WRITE:", "  \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);", "  \t\t\tbreak;", "  \t\tdefault:", "\t\t\tBUG();", " \t\t\tWRITE32(0);", "  \t}", "  \tWRITE32(0);\t\t ", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void RenderProcessHostImpl::OnCompositorSurfaceBuffersSwappedNoHost(", "       int32 surface_id,", "       uint64 surface_handle,", "       int32 route_id,", "       const gfx::Size& size,", "       int32 gpu_process_host_id) {", "   TRACE_EVENT0(\"renderer_host\",", "                 \"RenderWidgetHostImpl::OnCompositorSurfaceBuffersSwappedNoHost\");", "    RenderWidgetHostImpl::AcknowledgeBufferPresent(route_id,", "                                                   gpu_process_host_id,", "                                                 false,", "                                                  surface_handle,", "                                                   0);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" xfs_attr_shortform_list(xfs_attr_list_context_t *context)", " {", " \tattrlist_cursor_kern_t *cursor;", " \txfs_attr_sf_sort_t *sbuf, *sbp;", " \txfs_attr_shortform_t *sf;", " \txfs_attr_sf_entry_t *sfe;", " \txfs_inode_t *dp;", " \tint sbsize, nsbuf, count, i;", " \tint error;", " ", " \tASSERT(context != NULL);", " \tdp = context->dp;", " \tASSERT(dp != NULL);", " \tASSERT(dp->i_afp != NULL);", " \tsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;", " \tASSERT(sf != NULL);", " \tif (!sf->hdr.count)", " \t\treturn 0;", " \tcursor = context->cursor;", " \tASSERT(cursor != NULL);", " ", " \ttrace_xfs_attr_list_sf(context);", " ", " \t ", " \tif (context->bufsize == 0 ||", " \t    (XFS_ISRESET_CURSOR(cursor) &&", "              (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {", " \t\tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {", " \t\t\terror = context->put_listent(context,", " \t\t\t\t\t   sfe->flags,", " \t\t\t\t\t   sfe->nameval,", " \t\t\t\t\t   (int)sfe->namelen,", " \t\t\t\t\t   (int)sfe->valuelen,", " \t\t\t\t\t   &sfe->nameval[sfe->namelen]);", " ", " \t\t\t ", " \t\t\tif (context->seen_enough)", " \t\t\t\tbreak;", " ", " \t\t\tif (error)", " \t\t\t\treturn error;", " \t\t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);", " \t\t}", " \t\ttrace_xfs_attr_list_sf_all(context);", " \t\treturn 0;", " \t}", " ", " \t ", " \tif (context->bufsize == 0)", " \t\treturn 0;", " ", " \t ", " \tsbsize = sf->hdr.count * sizeof(*sbuf);", " \tsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);", " ", " \t ", " \tnsbuf = 0;", " \tfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {", " \t\tif (unlikely(", " \t\t    ((char *)sfe < (char *)sf) ||", " \t\t    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {", " \t\t\tXFS_CORRUPTION_ERROR(\"xfs_attr_shortform_list\",", " \t\t\t\t\t     XFS_ERRLEVEL_LOW,", " \t\t\t\t\t     context->dp->i_mount, sfe);", " \t\t\tkmem_free(sbuf);", " \t\t\treturn -EFSCORRUPTED;", " \t\t}", " ", " \t\tsbp->entno = i;", " \t\tsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);", " \t\tsbp->name = sfe->nameval;", " \t\tsbp->namelen = sfe->namelen;", " \t\t ", " \t\tsbp->valuelen = sfe->valuelen;", " \t\tsbp->flags = sfe->flags;", " \t\tsfe = XFS_ATTR_SF_NEXTENTRY(sfe);", " \t\tsbp++;", " \t\tnsbuf++;", " \t}", " ", " \t ", " \txfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);", " ", " \t ", " \tcount = 0;", " \tcursor->initted = 1;", " \tcursor->blkno = 0;", " \tfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {", " \t\tif (sbp->hash == cursor->hashval) {", " \t\t\tif (cursor->offset == count) {", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tcount++;", " \t\t} else if (sbp->hash > cursor->hashval) {", " \t\t\tbreak;", " \t\t}", " \t}", " \tif (i == nsbuf) {", " \t\tkmem_free(sbuf);", " \t\treturn 0;", " \t}", " ", " \t ", " \tfor ( ; i < nsbuf; i++, sbp++) {", " \t\tif (cursor->hashval != sbp->hash) {", " \t\t\tcursor->hashval = sbp->hash;", " \t\t\tcursor->offset = 0;", " \t\t}", " \t\terror = context->put_listent(context,", " \t\t\t\t\tsbp->flags,", " \t\t\t\t\tsbp->name,", "  \t\t\t\t\tsbp->namelen,", "  \t\t\t\t\tsbp->valuelen,", "  \t\t\t\t\t&sbp->name[sbp->namelen]);", "\t\tif (error)", " \t\tif (error) {", " \t\t\tkmem_free(sbuf);", "  \t\t\treturn error;", " \t\t}", "  \t\tif (context->seen_enough)", "  \t\t\tbreak;", "  \t\tcursor->offset++;", " \t}", " ", " \tkmem_free(sbuf);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void launch(OpKernelContext* context, bool cudnn_use_autotune,", "const Tensor& input, const Tensor& filter,", "const std::array<int64, 3>& dilations,", "const std::array<int64, 3>& strides, const Padding padding,", "TensorFormat data_format, Tensor* output) {", "OP_REQUIRES(context, data_format == FORMAT_NHWC,", "errors::InvalidArgument(\"CPU implementation of Conv3D \"", "\"currently only supports the NHWC \"", "\"tensor format.\"));", "OP_REQUIRES(context,", "dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,", "errors::InvalidArgument(\"CPU implementation of Conv3D \"", "\"currently only supports dilated rates \"", "\"of 1.\"));", "functor::CuboidConvolution<CPUDevice, T>()(", "context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),", "input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],", "strides[0], BrainPadding2EigenPadding(padding));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" SYSCALL_DEFINE1(inotify_init1, int, flags)", " {", " \tstruct fsnotify_group *group;", " \tstruct user_struct *user;", " \tint ret;", " ", " \t ", " \tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);", " \tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);", " ", " \tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))", " \t\treturn -EINVAL;", " ", " \tuser = get_current_user();", " \tif (unlikely(atomic_read(&user->inotify_devs) >=", " \t\t\tinotify_max_user_instances)) {", " \t\tret = -EMFILE;", " \t\tgoto out_free_uid;", " \t}", " ", " \t ", " \tgroup = inotify_new_group(user, inotify_max_queued_events);", " \tif (IS_ERR(group)) {", " \t\tret = PTR_ERR(group);", " \t\tgoto out_free_uid;", " \t}", " ", " \tatomic_inc(&user->inotify_devs);", " ", " \tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,", " \t\t\t\t  O_RDONLY | flags);", "  \tif (ret >= 0)", "  \t\treturn ret;", "  ", " \tfsnotify_put_group(group);", "  \tatomic_dec(&user->inotify_devs);", "  out_free_uid:", "  \tfree_uid(user);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["void jsvAddName(JsVar *parent, JsVar *namedChild) {", "namedChild = jsvRef(namedChild);", "assert(jsvIsName(namedChild));", "", "", "if (jsvIsArray(parent) && jsvIsInt(namedChild)) {", "JsVarInt index = namedChild->varData.integer;", "if (index >= jsvGetArrayLength(parent)) {", "jsvSetArrayLength(parent, index + 1, false);", "}", "}", "", "if (jsvGetLastChild(parent)) {", "JsVar *insertAfter = jsvLock(jsvGetLastChild(parent));", "if (jsvIsArray(parent)) {", "", "while (insertAfter && jsvCompareInteger(namedChild, insertAfter)<0) {", "JsVarRef prev = jsvGetPrevSibling(insertAfter);", "jsvUnLock(insertAfter);", "insertAfter = jsvLockSafe(prev);", "}", "}", "", "if (insertAfter) {", "if (jsvGetNextSibling(insertAfter)) {", "", "JsVar *insertBefore = jsvLock(jsvGetNextSibling(insertAfter));", "jsvSetPrevSibling(insertBefore, jsvGetRef(namedChild));", "jsvSetNextSibling(namedChild, jsvGetRef(insertBefore));", "jsvUnLock(insertBefore);", "} else {", "", "jsvSetLastChild(parent, jsvGetRef(namedChild));", "}", "jsvSetNextSibling(insertAfter, jsvGetRef(namedChild));", "jsvSetPrevSibling(namedChild, jsvGetRef(insertAfter));", "jsvUnLock(insertAfter);", "} else {", "", "JsVar *firstChild = jsvLock(jsvGetFirstChild(parent));", "jsvSetPrevSibling(firstChild, jsvGetRef(namedChild));", "jsvUnLock(firstChild);", "", "jsvSetNextSibling(namedChild, jsvGetFirstChild(parent));", "", "jsvSetFirstChild(parent, jsvGetRef(namedChild));", "}", "} else {", "JsVarRef r = jsvGetRef(namedChild);", "jsvSetFirstChild(parent, r);", "jsvSetLastChild(parent, r);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void GestureProviderAura::OnTouchEventAck(bool event_consumed) {", "   DCHECK(pending_gestures_.empty());", "    DCHECK(!handling_event_);", "    base::AutoReset<bool> handling_event(&handling_event_, true);", "    filtered_gesture_provider_.OnTouchEventAck(event_consumed);", "   last_touch_event_latency_info_.Clear();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs)", "{", "GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s;", "int i;", "u32 tmp_strsize;", "char *tmp_str;", "GF_Err e;", "", "ISOM_DECREASE_SIZE(ptr, 25)", "ptr->bootstrapinfo_version = gf_bs_read_u32(bs);", "ptr->profile = gf_bs_read_int(bs, 2);", "ptr->live = gf_bs_read_int(bs, 1);", "ptr->update = gf_bs_read_int(bs, 1);", "ptr->reserved = gf_bs_read_int(bs, 4);", "ptr->time_scale = gf_bs_read_u32(bs);", "ptr->current_media_time = gf_bs_read_u64(bs);", "ptr->smpte_time_code_offset = gf_bs_read_u64(bs);", "", "i=0;", "if (ptr->size<8) return GF_ISOM_INVALID_FILE;", "tmp_strsize =(u32)ptr->size;", "tmp_str = gf_malloc(sizeof(char)*tmp_strsize);", "if (!tmp_str) return GF_OUT_OF_MEM;", "memset(tmp_str, 0, sizeof(char)*tmp_strsize);", "", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->movie_identifier = gf_strdup(tmp_str);", "}", "", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->server_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->server_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "if (j) {", "gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i);", "}", "}", "", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->quality_entry_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->quality_entry_count; i++) {", "int j=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[j] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[j])", "break;", "j++;", "}", "", "if (j) {", "gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i);", "}", "}", "", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->drm_data = gf_strdup(tmp_str);", "}", "", "i=0;", "tmp_strsize=(u32)ptr->size;", "while (tmp_strsize) {", "ISOM_DECREASE_SIZE(ptr, 1)", "tmp_str[i] = gf_bs_read_u8(bs);", "tmp_strsize--;", "if (!tmp_str[i])", "break;", "i++;", "}", "if (i) {", "ptr->meta_data = gf_strdup(tmp_str);", "}", "", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->segment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->segment_run_table_count; i++) {", "GF_AdobeSegmentRunTableBox *asrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&asrt, bs);", "if (e) {", "if (asrt) gf_isom_box_del((GF_Box*)asrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->segment_run_table_entries, asrt);", "}", "", "ISOM_DECREASE_SIZE(ptr, 1)", "ptr->fragment_run_table_count = gf_bs_read_u8(bs);", "for (i=0; i<ptr->fragment_run_table_count; i++) {", "GF_AdobeFragmentRunTableBox *afrt = NULL;", "e = gf_isom_box_parse((GF_Box **)&afrt, bs);", "if (e) {", "if (afrt) gf_isom_box_del((GF_Box*)afrt);", "gf_free(tmp_str);", "return e;", "}", "gf_list_add(ptr->fragment_run_table_entries, afrt);", "}", "", "gf_free(tmp_str);", "", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" AcpiPsCompleteFinalOp (", "     ACPI_WALK_STATE         *WalkState,", "      ACPI_PARSE_OBJECT       *Op,", "      ACPI_STATUS             Status)", "  {", "    ACPI_STATUS             Status2;", "     ACPI_STATUS             ReturnStatus = AE_OK;", "     BOOLEAN                 Ascending = TRUE;", "  ", "  ", "      ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);", " ", " ", "      ", "     ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\", Op));", "     do", "      {", "          if (Op)", "          {", "            if (WalkState->AscendingCallback != NULL)", "             if (Ascending && WalkState->AscendingCallback != NULL)", "              {", "                  WalkState->Op = Op;", "                  WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);", "                 WalkState->Opcode = Op->Common.AmlOpcode;", " ", "                 Status = WalkState->AscendingCallback (WalkState);", "                 Status = AcpiPsNextParseState (WalkState, Op, Status);", "                 if (Status == AE_CTRL_PENDING)", "                 {", "                     Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);", "                     if (ACPI_FAILURE (Status))", "                     {", "                         return_ACPI_STATUS (Status);", "                     }", "                 }", "  ", "                  if (Status == AE_CTRL_TERMINATE)", "                  {", "                    Status = AE_OK;", "                     ", "                    do", "                    {", "                        if (Op)", "                        {", "                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);", "                            if (ACPI_FAILURE (Status2))", "                            {", "                                return_ACPI_STATUS (Status2);", "                            }", "                        }", "                        AcpiPsPopScope (&(WalkState->ParserState), &Op,", "                            &WalkState->ArgTypes, &WalkState->ArgCount);", "                    } while (Op);", "                    return_ACPI_STATUS (Status);", "                     Ascending = FALSE;", "                     ReturnStatus = AE_CTRL_TERMINATE;", "                  }", "  ", "                  else if (ACPI_FAILURE (Status))", "                  {", "                       ", "  ", "                    (void) AcpiPsCompleteThisOp (WalkState, Op);", "                    return_ACPI_STATUS (Status);", "                     Ascending = FALSE;", "                     ReturnStatus = Status;", "                  }", "              }", "  ", "            Status2 = AcpiPsCompleteThisOp (WalkState, Op);", "            if (ACPI_FAILURE (Status2))", "             Status = AcpiPsCompleteThisOp (WalkState, Op);", "             if (ACPI_FAILURE (Status))", "              {", "                return_ACPI_STATUS (Status2);", "                 Ascending = FALSE;", "                 if (ACPI_SUCCESS (ReturnStatus) ||", "                     ReturnStatus == AE_CTRL_TERMINATE)", "                 {", "                     ReturnStatus = Status;", "                 }", "              }", "          }", "  ", "         AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,", "             &WalkState->ArgCount);", "  ", "      } while (Op);", "  ", "    return_ACPI_STATUS (Status);", "     return_ACPI_STATUS (ReturnStatus);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {", " \tint vA, vB, vC, payload = 0, i = (int) buf[0];", " \tint size = dalvik_opcodes[i].len;", " \tchar str[1024], *strasm;", " \tut64 offset;", " \tconst char *flag_str; ", " ", " \top->buf_asm[0] = 0;", " \tif (buf[0] == 0x00) {  ", " \t\tswitch (buf[1]) {", " \t\tcase 0x01:  ", "  \t\t\t{", "  \t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);", "  \t\t\t\tint first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);", "\t\t\t\tsprintf (op->buf_asm, \"packed-switch-payload %d, %d\", array_size, first_key);", " \t\t\t\tsnprintf (op->buf_asm, sizeof(op->buf_asm), \"packed-switch-payload %d, %d\", array_size, first_key);", "  \t\t\t\tsize = 8;", "  \t\t\t\tpayload = 2 * (array_size * 2);", "  \t\t\t\tlen = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 0x02:  ", "  \t\t\t{", "  \t\t\t\tunsigned short array_size = buf[2] | (buf[3] << 8);", "\t\t\t\tsprintf (op->buf_asm, \"sparse-switch-payload %d\", array_size);", " \t\t\t\tsnprintf (op->buf_asm, sizeof (op->buf_asm), \"sparse-switch-payload %d\", array_size);", "  \t\t\t\tsize = 4;", "  \t\t\t\tpayload = 2 * (array_size*4);", "  \t\t\t\tlen = 0;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 0x03:  ", " \t\t\tif (len > 7) {", " \t\t\t\tunsigned short elem_width = buf[2] | (buf[3] << 8);", " \t\t\t\tunsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);", " \t\t\t\tsnprintf (op->buf_asm, sizeof (op->buf_asm),", " \t\t\t\t\t\"fill-array-data-payload %d, %d\",", " \t\t\t\t\telem_width, array_size);", " \t\t\t\tpayload = 2 * ((array_size * elem_width+1)/2);", " \t\t\t}", " \t\t\tsize = 8;", " \t\t\tlen = 0;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\t ", " \t\t\tbreak;", " \t\t}", " \t}", " \tstrasm = NULL;", " \tif (size <= len) {", " \t\tstrncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);", " \t\tstrasm = strdup (op->buf_asm);", " \t\tsize = dalvik_opcodes[i].len;", " \t\tswitch (dalvik_opcodes[i].fmt) {", " \t\tcase fmtop: break;", "  \t\tcase fmtopvAvB:", "  \t\t\tvA = buf[1] & 0x0f;", "  \t\t\tvB = (buf[1] & 0xf0) >> 4;", "\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAvBBBB:", "  \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (buf[3] << 8) | buf[2];", "\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAAAvBBBB:  ", "  \t\t\tvA = (buf[3] << 8) | buf[2];", "  \t\t\tvB = (buf[5] << 8) | buf[4];", "\t\t\tsprintf (str, \" v%i, v%i\", vA, vB);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i\", vA, vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAA:", "  \t\t\tvA = (int) buf[1];", "\t\t\tsprintf (str, \" v%i\", vA);", " \t\t\tsnprintf (str, sizeof (str), \" v%i\", vA);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAcB:", "  \t\t\tvA = buf[1] & 0x0f;", "  \t\t\tvB = (buf[1] & 0xf0) >> 4;", "\t\t\tsprintf (str, \" v%i, %#x\", vA, vB);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, %#x\", vA, vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAcBBBB:", "  \t\t\tvA = (int) buf[1];", "  \t\t\t{", "  \t\t\t\tshort sB = (buf[3] << 8) | buf[2];", "\t\t\t\tsprintf (str, \" v%i, %#04hx\", vA, sB);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, %#04hx\", vA, sB);", "  \t\t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\t}", "  \t\t\tbreak;", " \t\tcase fmtopvAAcBBBBBBBB:", " \t\t\tvA = (int) buf[1];", " \t\t\tvB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);", " \t\t\tif (buf[0] == 0x17) {  ", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);", " \t\t\t} else {  ", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);", " \t\t\t}", " \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtopvAAcBBBB0000:", " \t\t\tvA = (int) buf[1];", " \t\t\tvB = 0 | (buf[2] << 16) | (buf[3] << 24);", " \t\t\tif (buf[0] == 0x19) {  ", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%08x\", vA, vA + 1, vB);", " \t\t\t} else {", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08x\", vA, vB);", " \t\t\t}", " \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtopvAAcBBBBBBBBBBBBBBBB:", " \t\t\tvA = (int) buf[1];", " \t\t\t#define llint long long int", " \t\t\tllint lB = (llint)buf[2] | ((llint)buf[3] << 8)|", " \t\t\t\t((llint)buf[4] << 16) | ((llint)buf[5] << 24)|", "  \t\t\t\t((llint)buf[6] << 32) | ((llint)buf[7] << 40)|", "  \t\t\t\t((llint)buf[8] << 48) | ((llint)buf[9] << 56);", "  \t\t\t#undef llint", "\t\t\tsprintf (str, \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);", " \t\t\tsnprintf (str, sizeof (str), \" v%i:v%i, 0x%\"PFMT64x, vA, vA + 1, lB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAvBBvCC:", "  \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (int) buf[2];", "  \t\t\tvC = (int) buf[3];", "\t\t\tsprintf (str, \" v%i, v%i, v%i\", vA, vB, vC);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, v%i\", vA, vB, vC);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAvBBcCC:", "  \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (int) buf[2];", "  \t\t\tvC = (int) buf[3];", "\t\t\tsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAvBcCCCC:", "  \t\t\tvA = buf[1] & 0x0f;", "  \t\t\tvB = (buf[1] & 0xf0) >> 4;", "  \t\t\tvC = (buf[3] << 8) | buf[2];", "\t\t\tsprintf (str, \" v%i, v%i, %#x\", vA, vB, vC);", " \t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %#x\", vA, vB, vC);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtoppAA:", "  \t\t\tvA = (char) buf[1];", " \t\t\t ", "  \t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));  ", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", " \t\tcase fmtoppAAAA:", " \t\t\tvA = (short) (buf[3] << 8 | buf[2]);", " \t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA * 2));  ", " \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", "  \t\tcase fmtopvAApBBBB:  ", "  \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (int) (buf[3] << 8 | buf[2]);", " \t\t\t ", "  \t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + (vB * 2));", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtoppAAAAAAAA:", "  \t\t\tvA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));", " \t\t\t ", "  \t\t\tsnprintf (str, sizeof (str), \" 0x%08\"PFMT64x, a->pc + (vA*2));  ", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAvBpCCCC:  ", "  \t\t\tvA = buf[1] & 0x0f;", "  \t\t\tvB = (buf[1] & 0xf0) >> 4;", "  \t\t\tvC = (int) (buf[3] << 8 | buf[2]);", " \t\t\t ", "  \t\t\tsnprintf (str, sizeof (str),\" v%i, v%i, 0x%08\"PFMT64x, vA, vB, a->pc + (vC * 2));", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", " \t\tcase fmtopvAApBBBBBBBB:", " \t\t\tvA = (int) buf[1];", " \t\t\tvB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));", " \t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%08\"PFMT64x, vA, a->pc + vB);  ", " \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtoptinlineI:", " \t\t\tvA = (int) (buf[1] & 0x0f);", " \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\t*str = 0;", "  \t\t\tswitch (vA) {", "  \t\t\tcase 1:", "\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);", "  \t\t\t\tbreak;", "  \t\t\tcase 2:", "\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", "  \t\t\t\tbreak;", "  \t\t\tcase 3:", "\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);", "  \t\t\t\tbreak;", "  \t\t\tcase 4:", "\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);", "  \t\t\t\tbreak;", "  \t\t\tdefault:", "\t\t\t\tsprintf (str, \" {}\");", " \t\t\t\tsnprintf (str, sizeof (str), \" {}\");", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "\t\t\tsprintf (str, \", [%04x]\", vB);", " \t\t\tsnprintf (str, sizeof (str), \", [%04x]\", vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtoptinlineIR:", "  \t\tcase fmtoptinvokeVSR:", "  \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\tvC = (buf[5] << 8) | buf[4];", "\t\t\tsprintf (str, \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);", " \t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, [%04x]\", vC, vC + vA - 1, vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtoptinvokeVS:", "  \t\t\tvA = (int) (buf[1] & 0xf0) >> 4;", "  \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\tswitch (vA) {", "  \t\t\tcase 1:", "\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);", "  \t\t\t\tbreak;", "  \t\t\tcase 2:", "\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", "  \t\t\t\tbreak;", "  \t\t\tcase 3:", "\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);", "  \t\t\t\tbreak;", "  \t\t\tcase 4:", "\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);", "  \t\t\t\tbreak;", "  \t\t\tdefault:", "\t\t\t\tsprintf (str, \" {}\");", " \t\t\t\tsnprintf (str, sizeof (str), \" {}\");", "  \t\t\t\tbreak;", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "\t\t\tsprintf (str, \", [%04x]\", vB);", " \t\t\tsnprintf (str, sizeof (str), \", [%04x]\", vB);", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", "  \t\tcase fmtopvAAtBBBB:  ", " \t\t\tvA = (int) buf[1];", " \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\tif (buf[0] == 0x1a) {", "  \t\t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);", "  \t\t\t\tif (offset == -1) {", "\t\t\t\t\tsprintf (str, \" v%i, string+%i\", vA, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);", "  \t\t\t\t} else {", "\t\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);", "  \t\t\t\t}", "  \t\t\t} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);", "  \t\t\t\tif (!flag_str) {", "\t\t\t\t\tsprintf (str, \" v%i, class+%i\", vA, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, class+%i\", vA, vB);", "  \t\t\t\t} else {", "\t\t\t\t\tsprintf (str, \" v%i, %s\", vA, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);", "  \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vB);", "  \t\t\t\tif (!flag_str) {", "\t\t\t\t\tsprintf (str, \" v%i, field+%i\", vA, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, field+%i\", vA, vB);", "  \t\t\t\t} else {", "\t\t\t\t\tsprintf (str, \" v%i, %s\", vA, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, %s\", vA, flag_str);", "  \t\t\t\t}", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtoptopvAvBoCCCC:", " \t\t\tvA = (buf[1] & 0x0f);", " \t\t\tvB = (buf[1] & 0xf0) >> 4;", "  \t\t\tvC = (buf[3]<<8) | buf[2];", "  \t\t\toffset = R_ASM_GET_OFFSET (a, 'o', vC);", "  \t\t\tif (offset == -1) {", "\t\t\t\tsprintf (str, \" v%i, v%i, [obj+%04x]\", vA, vB, vC);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, [obj+%04x]\", vA, vB, vC);", "  \t\t\t} else {", "\t\t\t\tsprintf (str, \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, [0x%\"PFMT64x\"]\", vA, vB, offset);", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", " \t\tcase fmtopAAtBBBB:", " \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\toffset = R_ASM_GET_OFFSET (a, 't', vB);", "  \t\t\tif (offset == -1) {", "\t\t\t\tsprintf (str, \" v%i, thing+%i\", vA, vB);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, thing+%i\", vA, vB);", "  \t\t\t} else {", "\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", " \t\tcase fmtopvAvBtCCCC:", " \t\t\tvA = (buf[1] & 0x0f);", " \t\t\tvB = (buf[1] & 0xf0) >> 4;", " \t\t\tvC = (buf[3] << 8) | buf[2];", "  \t\t\tif (buf[0] == 0x20 || buf[0] == 0x23) {  ", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vC);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);", "  \t\t\t\t}", "  \t\t\t\telse {", "\t\t\t\t\tsprintf (str, \" v%i, v%i, class+%i\", vA, vB, vC);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, class+%i\", vA, vB, vC);", "  \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'f', vC);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \" v%i, v%i, %s\", vA, vB, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, %s\", vA, vB, flag_str);", "  \t\t\t\t}", "  \t\t\t\telse {", "\t\t\t\t\tsprintf (str, \" v%i, v%i, field+%i\", vA, vB, vC);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" v%i, v%i, field+%i\", vA, vB, vC);", "  \t\t\t\t}", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtopvAAtBBBBBBBB:", " \t\t\tvA = (int) buf[1];", "  \t\t\tvB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));", "  \t\t\toffset = R_ASM_GET_OFFSET (a, 's', vB);", "  \t\t\tif (offset == -1) {", "\t\t\t\tsprintf (str, \" v%i, string+%i\", vA, vB);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, string+%i\", vA, vB);", "  \t\t\t}", "  \t\t\telse {", "\t\t\t\tsprintf (str, \" v%i, 0x%\"PFMT64x, vA, offset);", " \t\t\t\tsnprintf (str, sizeof (str), \" v%i, 0x%\"PFMT64x, vA, offset);", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tbreak;", " \t\tcase fmtopvCCCCmBBBB:", " \t\t\tvA = (int) buf[1];", " \t\t\tvB = (buf[3] << 8) | buf[2];", " \t\t\tvC = (buf[5] << 8) | buf[4];", "  \t\t\tif (buf[0] == 0x25) {  ", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);", "  \t\t\t\t}", "  \t\t\t\telse {", "\t\t\t\t\tsprintf (str, \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, class+%i\", vC, vC + vA - 1, vB);", "  \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, %s\", vC, vC + vA - 1, flag_str);", "  \t\t\t\t}", "  \t\t\t\telse {", "\t\t\t\t\tsprintf (str, \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i..v%i}, method+%i\", vC, vC + vA - 1, vB);", "  \t\t\t\t}", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtopvXtBBBB:", " \t\t\tvA = (int) (buf[1] & 0xf0) >> 4;", "  \t\t\tvB = (buf[3] << 8) | buf[2];", "  \t\t\tswitch (vA) {", "  \t\t\t\tcase 1:", "\t\t\t\t\tsprintf (str, \" {v%i}\", buf[4] & 0x0f);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i}\", buf[4] & 0x0f);", "  \t\t\t\t\tbreak;", "  \t\t\t\tcase 2:", "\t\t\t\t\tsprintf (str, \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i}\", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);", "  \t\t\t\t\tbreak;", "  \t\t\t\tcase 3:", "\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);", "  \t\t\t\t\tbreak;", "  \t\t\t\tcase 4:", "\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);", "  \t\t\t\t\tbreak;", "  \t\t\t\tcase 5:", "\t\t\t\t\tsprintf (str, \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {v%i, v%i, v%i, v%i, v%i}\", buf[4] & 0x0f,", "  \t\t\t\t\t\t\t(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f);  ", "  \t\t\t\t\tbreak;", "  \t\t\t\tdefault:", "\t\t\t\t\tsprintf (str, \" {}\");", " \t\t\t\t\tsnprintf (str, sizeof (str), \" {}\");", "  \t\t\t}", "  \t\t\tstrasm = r_str_concat (strasm, str);", "  \t\t\tif (buf[0] == 0x24) {  ", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'c', vB);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \", %s ; 0x%x\", flag_str, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);", "  \t\t\t\t} else {", "\t\t\t\t\tsprintf (str, \", class+%i\", vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \", class+%i\", vB);", "  \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tflag_str = R_ASM_GET_NAME (a, 'm', vB);", "  \t\t\t\tif (flag_str) {", "\t\t\t\t\tsprintf (str, \", %s ; 0x%x\", flag_str, vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \", %s ; 0x%x\", flag_str, vB);", "  \t\t\t\t} else {", "\t\t\t\t\tsprintf (str, \", method+%i\", vB);", " \t\t\t\t\tsnprintf (str, sizeof (str), \", method+%i\", vB);", "  \t\t\t\t}", "  ", "  \t\t\t}", " \t\t\tstrasm = r_str_concat (strasm, str);", " \t\t\tbreak;", " \t\tcase fmtoptinvokeI:  ", " \t\tcase fmtoptinvokeIR:", " \t\tcase fmt00:", " \t\tdefault:", " \t\t\tstrcpy (op->buf_asm, \"invalid \");", " \t\t\tfree (strasm);", " \t\t\tstrasm = NULL;", " \t\t\tsize = 2;", " \t\t}", " \t\tif (strasm) {", " \t\t\tstrncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);", " \t\t\top->buf_asm[sizeof (op->buf_asm) - 1] = 0;", " \t\t} else {", " \t\t\tstrcpy (op->buf_asm , \"invalid\");", " \t\t}", " \t} else if (len > 0) {", " \t\tstrcpy (op->buf_asm, \"invalid \");", " \t\top->size = len;", " \t\tsize = len;", " \t}", " \top->payload = payload;", " \tsize += payload;  ", " \top->size = size;", " \tfree (strasm);", " \treturn size;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadFITSImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   typedef struct _FITSInfo", "   {", "     MagickBooleanType", "       extend,", "       simple;", " ", "     int", "       bits_per_pixel,", "       columns,", "       rows,", "       number_axes,", "       number_planes;", " ", "     double", "       min_data,", "       max_data,", "       zero,", "       scale;", " ", "     EndianType", "       endian;", "   } FITSInfo;", " ", "   char", "     *comment,", "     keyword[9],", "     property[MaxTextExtent],", "     value[73];", " ", "   double", "     pixel,", "     scale;", " ", "   FITSInfo", "     fits_info;", " ", "   Image", "     *image;", " ", "   int", "     c;", " ", "   MagickBooleanType", "     status;", " ", "   MagickSizeType", "     number_pixels;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   ssize_t", "     count,", "     scene,", "     y;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   (void) ResetMagickMemory(&fits_info,0,sizeof(fits_info));", "   fits_info.extend=MagickFalse;", "   fits_info.simple=MagickFalse;", "   fits_info.bits_per_pixel=8;", "   fits_info.columns=1;", "   fits_info.rows=1;", "   fits_info.rows=1;", "   fits_info.number_planes=1;", "   fits_info.min_data=0.0;", "   fits_info.max_data=0.0;", "   fits_info.zero=0.0;", "   fits_info.scale=1.0;", "   fits_info.endian=MSBEndian;", "    ", "   for (comment=(char *) NULL; EOFBlob(image) == MagickFalse; )", "   {", "     for ( ; EOFBlob(image) == MagickFalse; )", "     {", "       register char", "         *p;", " ", "       count=ReadBlob(image,8,(unsigned char *) keyword);", "       if (count != 8)", "         break;", "       for (i=0; i < 8; i++)", "       {", "         if (isspace((int) ((unsigned char) keyword[i])) != 0)", "           break;", "         keyword[i]=tolower((int) ((unsigned char) keyword[i]));", "       }", "       keyword[i]='\\0';", "       count=ReadBlob(image,72,(unsigned char *) value);", "       value[72]='\\0';", "       if (count != 72)", "         break;", "       p=value;", "       if (*p == '=')", "         {", "           p+=2;", "           while (isspace((int) ((unsigned char) *p)) != 0)", "             p++;", "         }", "       if (LocaleCompare(keyword,\"end\") == 0)", "         break;", "       if (LocaleCompare(keyword,\"extend\") == 0)", "         fits_info.extend=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;", "       if (LocaleCompare(keyword,\"simple\") == 0)", "         fits_info.simple=(*p == 'T') || (*p == 't') ? MagickTrue : MagickFalse;", "       if (LocaleCompare(keyword,\"bitpix\") == 0)", "         fits_info.bits_per_pixel=StringToLong(p);", "       if (LocaleCompare(keyword,\"naxis\") == 0)", "         fits_info.number_axes=StringToLong(p);", "       if (LocaleCompare(keyword,\"naxis1\") == 0)", "         fits_info.columns=StringToLong(p);", "       if (LocaleCompare(keyword,\"naxis2\") == 0)", "         fits_info.rows=StringToLong(p);", "       if (LocaleCompare(keyword,\"naxis3\") == 0)", "         fits_info.number_planes=StringToLong(p);", "       if (LocaleCompare(keyword,\"datamax\") == 0)", "         fits_info.max_data=StringToDouble(p,(char **) NULL);", "       if (LocaleCompare(keyword,\"datamin\") == 0)", "         fits_info.min_data=StringToDouble(p,(char **) NULL);", "       if (LocaleCompare(keyword,\"bzero\") == 0)", "         fits_info.zero=StringToDouble(p,(char **) NULL);", "       if (LocaleCompare(keyword,\"bscale\") == 0)", "         fits_info.scale=StringToDouble(p,(char **) NULL);", "       if (LocaleCompare(keyword,\"comment\") == 0)", "         {", "           if (comment == (char *) NULL)", "             comment=ConstantString(p);", "           else", "             (void) ConcatenateString(&comment,p);", "         }", "       if (LocaleCompare(keyword,\"xendian\") == 0)", "         {", "           if (LocaleNCompare(p,\"big\",3) == 0)", "             fits_info.endian=MSBEndian;", "           else", "             fits_info.endian=LSBEndian;", "         }", "       (void) FormatLocaleString(property,MaxTextExtent,\"fits:%s\",keyword);", "       (void) SetImageProperty(image,property,p);", "     }", "     c=0;", "     while (((TellBlob(image) % FITSBlocksize) != 0) && (c != EOF))", "       c=ReadBlobByte(image);", "     if (fits_info.extend == MagickFalse)", "       break;", "     number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;", "     if ((fits_info.simple != MagickFalse) && (fits_info.number_axes >= 1) &&", "         (fits_info.number_axes <= 4) && (number_pixels != 0))", "       break;", "   }", "    ", "   if (comment != (char *) NULL)", "     {", "       (void) SetImageProperty(image,\"comment\",comment);", "       comment=DestroyString(comment);", "     }", "   if (EOFBlob(image) != MagickFalse)", "     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "       image->filename);", "   number_pixels=(MagickSizeType) fits_info.columns*fits_info.rows;", "   if ((fits_info.simple == MagickFalse) || (fits_info.number_axes < 1) ||", "       (fits_info.number_axes > 4) || (number_pixels == 0))", "     ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");", "   for (scene=0; scene < (ssize_t) fits_info.number_planes; scene++)", "   {", "     image->columns=(size_t) fits_info.columns;", "     image->rows=(size_t) fits_info.rows;", "     image->depth=(size_t) (fits_info.bits_per_pixel < 0 ? -1 : 1)*", "       fits_info.bits_per_pixel;", "     image->endian=fits_info.endian;", "     image->scene=(size_t) scene;", "      if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))", "        if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "          break;", "     status=SetImageExtent(image,image->columns,image->rows);", "     if (status == MagickFalse)", "       {", "         InheritException(exception,&image->exception);", "         return(DestroyImageList(image));", "       }", "       ", "     (void) SetImageColorspace(image,GRAYColorspace);", "     if ((fits_info.min_data == 0.0) && (fits_info.max_data == 0.0))", "       {", "         if (fits_info.zero == 0.0)", "           (void) GetFITSPixelExtrema(image,fits_info.bits_per_pixel,", "             &fits_info.min_data,&fits_info.max_data);", "         else", "           fits_info.max_data=GetFITSPixelRange((size_t)", "             fits_info.bits_per_pixel);", "       }", "     else", "       fits_info.max_data=GetFITSPixelRange((size_t) fits_info.bits_per_pixel);", "      ", "     scale=QuantumRange/(fits_info.max_data-fits_info.min_data);", "     for (y=(ssize_t) image->rows-1; y >= 0; y--)", "     {", "       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "       if (q == (PixelPacket *) NULL)", "         break;", "       for (x=0; x < (ssize_t) image->columns; x++)", "       {", "         pixel=GetFITSPixel(image,fits_info.bits_per_pixel);", "         if ((image->depth == 16) || (image->depth == 32) ||", "             (image->depth == 64))", "           SetFITSUnsignedPixels(1,image->depth,image->endian,(unsigned char *)", "             &pixel);", "         SetPixelRed(q,ClampToQuantum(scale*(fits_info.scale*(pixel-", "           fits_info.min_data)+fits_info.zero)));", "         SetPixelGreen(q,GetPixelRed(q));", "         SetPixelBlue(q,GetPixelRed(q));", "         q++;", "       }", "       if (SyncAuthenticPixels(image,exception) == MagickFalse)", "         break;", "       if (image->previous == (Image *) NULL)", "         {", "           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "           if (status == MagickFalse)", "             break;", "         }", "     }", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     if (scene < (ssize_t) (fits_info.number_planes-1))", "       {", "          ", "         AcquireNextImage(image_info,image);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   }", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ssl3_get_cert_verify(SSL *s)", " \t{", " \tEVP_PKEY *pkey=NULL;", " \tunsigned char *p;", " \tint al,ok,ret=0;", " \tlong n;", " \tint type=0,i,j;", " \tX509 *peer;", " \tconst EVP_MD *md = NULL;", " \tEVP_MD_CTX mctx;", " \tEVP_MD_CTX_init(&mctx);", " ", " \tn=s->method->ssl_get_message(s,", " \t\tSSL3_ST_SR_CERT_VRFY_A,", " \t\tSSL3_ST_SR_CERT_VRFY_B,", " \t\t-1,", " \t\tSSL3_RT_MAX_PLAIN_LENGTH,", " \t\t&ok);", " ", " \tif (!ok) return((int)n);", " ", " \tif (s->session->peer != NULL)", " \t\t{", " \t\tpeer=s->session->peer;", " \t\tpkey=X509_get_pubkey(peer);", " \t\ttype=X509_certificate_type(peer,pkey);", " \t\t}", " \telse", " \t\t{", " \t\tpeer=NULL;", " \t\tpkey=NULL;", " \t\t}", " ", "  \tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)", "  \t\t{", "  \t\ts->s3->tmp.reuse_message=1;", "\t\tif ((peer != NULL) && (type & EVP_PKT_SIGN))", " \t\tif (peer != NULL)", "  \t\t\t{", "  \t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;", "  \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\tret=1;", " \t\tgoto end;", " \t\t}", " ", " \tif (peer == NULL)", " \t\t{", " \t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);", " \t\tal=SSL_AD_UNEXPECTED_MESSAGE;", " \t\tgoto f_err;", " \t\t}", " ", " \tif (!(type & EVP_PKT_SIGN))", " \t\t{", " \t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);", " \t\tal=SSL_AD_ILLEGAL_PARAMETER;", " \t\tgoto f_err;", " \t\t}", " ", " \tif (s->s3->change_cipher_spec)", " \t\t{", " \t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);", " \t\tal=SSL_AD_UNEXPECTED_MESSAGE;", " \t\tgoto f_err;", " \t\t}", " ", " \t ", " \tp=(unsigned char *)s->init_msg;", " \t ", " \t ", " \tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||", " \t\tpkey->type == NID_id_GostR3410_2001) )", " \t\t{", " \t\ti=64;", " \t\t} ", " \telse ", " \t\t{\t", " \t\tif (SSL_USE_SIGALGS(s))", " \t\t\t{", " \t\t\tint rv = tls12_check_peer_sigalg(&md, s, p, pkey);", " \t\t\tif (rv == -1)", " \t\t\t\t{", " \t\t\t\tal = SSL_AD_INTERNAL_ERROR;", " \t\t\t\tgoto f_err;", " \t\t\t\t}", " \t\t\telse if (rv == 0)", " \t\t\t\t{", " \t\t\t\tal = SSL_AD_DECODE_ERROR;", " \t\t\t\tgoto f_err;", " \t\t\t\t}", " #ifdef SSL_DEBUG", " fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));", " #endif", " \t\t\tp += 2;", " \t\t\tn -= 2;", " \t\t\t}", " \t\tn2s(p,i);", " \t\tn-=2;", " \t\tif (i > n)", " \t\t\t{", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);", " \t\t\tal=SSL_AD_DECODE_ERROR;", " \t\t\tgoto f_err;", " \t\t\t}", "     \t}", " \tj=EVP_PKEY_size(pkey);", " \tif ((i > j) || (n > j) || (n <= 0))", " \t\t{", " \t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);", " \t\tal=SSL_AD_DECODE_ERROR;", " \t\tgoto f_err;", " \t\t}", " ", " \tif (SSL_USE_SIGALGS(s))", " \t\t{", " \t\tlong hdatalen = 0;", " \t\tvoid *hdata;", " \t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);", " \t\tif (hdatalen <= 0)", " \t\t\t{", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);", " \t\t\tal=SSL_AD_INTERNAL_ERROR;", " \t\t\tgoto f_err;", " \t\t\t}", " #ifdef SSL_DEBUG", " \t\tfprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",", " \t\t\t\t\t\t\tEVP_MD_name(md));", " #endif", " \t\tif (!EVP_VerifyInit_ex(&mctx, md, NULL)", " \t\t\t|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))", " \t\t\t{", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);", " \t\t\tal=SSL_AD_INTERNAL_ERROR;", " \t\t\tgoto f_err;", " \t\t\t}", " ", " \t\tif (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)", " \t\t\t{", " \t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " \telse", " #ifndef OPENSSL_NO_RSA ", " \tif (pkey->type == EVP_PKEY_RSA)", " \t\t{", " \t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,", " \t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, ", " \t\t\t\t\t\t\tpkey->pkey.rsa);", " \t\tif (i < 0)", " \t\t\t{", " \t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\tif (i == 0)", " \t\t\t{", " \t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " \telse", " #endif", " #ifndef OPENSSL_NO_DSA", " \t\tif (pkey->type == EVP_PKEY_DSA)", " \t\t{", " \t\tj=DSA_verify(pkey->save_type,", " \t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),", " \t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);", " \t\tif (j <= 0)", " \t\t\t{", " \t\t\t ", " \t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " \telse", " #endif", " #ifndef OPENSSL_NO_ECDSA", " \t\tif (pkey->type == EVP_PKEY_EC)", " \t\t{", " \t\tj=ECDSA_verify(pkey->save_type,", " \t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),", " \t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);", " \t\tif (j <= 0)", " \t\t\t{", " \t\t\t ", " \t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,", " \t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " \telse", " #endif", " \tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)", " \t\t{   unsigned char signature[64];", " \t\t\tint idx;", " \t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);", " \t\t\tEVP_PKEY_verify_init(pctx);", " \t\t\tif (i!=64) {", " \t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);", " \t\t\t}\t", " \t\t\tfor (idx=0;idx<64;idx++) {", " \t\t\t\tsignature[63-idx]=p[idx];", " \t\t\t}\t", " \t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);", " \t\t\tEVP_PKEY_CTX_free(pctx);", " \t\t\tif (j<=0) ", " \t\t\t\t{", " \t\t\t\tal=SSL_AD_DECRYPT_ERROR;", " \t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,", " \t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);", " \t\t\t\tgoto f_err;", " \t\t\t\t}\t", " \t\t}", " \telse\t", " \t\t{", " \t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);", " \t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;", " \t\tgoto f_err;", " \t\t}", " ", " ", " \tret=1;", " \tif (0)", " \t\t{", " f_err:", " \t\tssl3_send_alert(s,SSL3_AL_FATAL,al);", " \t\t}", " end:", " \tif (s->s3->handshake_buffer)", " \t\t{", " \t\tBIO_free(s->s3->handshake_buffer);", " \t\ts->s3->handshake_buffer = NULL;", " \t\ts->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;", " \t\t}", " \tEVP_MD_CTX_cleanup(&mctx);", " \tEVP_PKEY_free(pkey);", " \treturn(ret);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  header_read (SF_PRIVATE *psf, void *ptr, int bytes)", "  {\tint count = 0 ;", "  ", "\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))", "\t\treturn psf_fread (ptr, 1, bytes, psf) ;", "\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))", "\t{\tint most ;", " \tif (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))", " \t\treturn count ;", "  ", "\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;", "\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;", "\t\tmemcpy (ptr, psf->header + psf->headend, most) ;", "\t\tpsf->headend = psf->headindex += most ;", "\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;", "\t\treturn bytes ;", "\t\t} ;", "\tif (psf->headindex + bytes > psf->headend)", "\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;", "\t\tif (count != bytes - (int) (psf->headend - psf->headindex))", " \tif (psf->header.indx + bytes > psf->header.end)", " \t{\tcount = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;", " \t\tif (count != bytes - (int) (psf->header.end - psf->header.indx))", "  \t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;", "  \t\t\treturn count ;", "  \t\t\t} ;", "\t\tpsf->headend += count ;", " \t\tpsf->header.end += count ;", "  \t\t} ;", "  ", "\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;", "\tpsf->headindex += bytes ;", " \tmemcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;", " \tpsf->header.indx += bytes ;", "  ", "  \treturn bytes ;", "  }  "], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" bool DoCanonicalizePathURL(const URLComponentSource<CHAR>& source,", "                            const Parsed& parsed,", "                            CanonOutput* output,", "                            Parsed* new_parsed) {", "   bool success = CanonicalizeScheme(source.scheme, parsed.scheme,", "                                     output, &new_parsed->scheme);", " ", "   new_parsed->username.reset();", "   new_parsed->password.reset();", "   new_parsed->host.reset();", "    new_parsed->port.reset();", "  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(", "      source.path, parsed.path, '\\0', output, &new_parsed->path);", "  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(", "      source.query, parsed.query, '?', output, &new_parsed->query);", "  success &= DoCanonicalizePathComponent<CHAR, UCHAR>(", "      source.ref, parsed.ref, '#', output, &new_parsed->ref);", "    ", "    ", "    ", "   DoCanonicalizePathComponent<CHAR, UCHAR>(source.path, parsed.path, '\\0',", "                                            output, &new_parsed->path);", "   DoCanonicalizePathComponent<CHAR, UCHAR>(source.query, parsed.query, '?',", "                                            output, &new_parsed->query);", "   DoCanonicalizePathComponent<CHAR, UCHAR>(source.ref, parsed.ref, '#', output,", "                                            &new_parsed->ref);", "  ", "    return success;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" VOID ixheaacd_esbr_postradixcompute2(WORD32 *ptr_y, WORD32 *ptr_x,", "  const WORD32 *pdig_rev_tbl,", "                                      WORD32 npoints) {", "   WORD32 i, k;", "   WORD32 h2;", " ", "    WORD32 x_0, x_1, x_2, x_3;", "    WORD32 x_4, x_5, x_6, x_7;", "    WORD32 x_8, x_9, x_a, x_b, x_c, x_d, x_e, x_f;", "  WORD32 n00, n10, n20, n30, n01, n11, n21, n31;", "  WORD32 n02, n12, n22, n32, n03, n13, n23, n33;", "    WORD32 n0, j0;", "    WORD32 *x2, *x0;", "    WORD32 *y0, *y1, *y2, *y3;", " ", "   y0 = ptr_y;", "   y2 = ptr_y + (WORD32)npoints;", "   x0 = ptr_x;", "   x2 = ptr_x + (WORD32)(npoints >> 1);", " ", "   y1 = y0 + (WORD32)(npoints >> 2);", "   y3 = y2 + (WORD32)(npoints >> 2);", "   j0 = 8;", "   n0 = npoints >> 1;", " ", "  for (k = 0; k < 2; k++) {", "  for (i = 0; i<npoints>> 1; i += 8) {", "       h2 = *pdig_rev_tbl++ >> 2;", " ", "       x_0 = *x0++;", "       x_1 = *x0++;", "       x_2 = *x0++;", "       x_3 = *x0++;", "       x_4 = *x0++;", "       x_5 = *x0++;", " ", "        x_6 = *x0++;", "        x_7 = *x0++;", "  ", "      n00 = x_0 + x_2;", "      n01 = x_1 + x_3;", "      n20 = x_0 - x_2;", "      n21 = x_1 - x_3;", "      n10 = x_4 + x_6;", "      n11 = x_5 + x_7;", "      n30 = x_4 - x_6;", "      n31 = x_5 - x_7;", "      y0[h2] = n00;", "      y0[h2 + 1] = n01;", "      y1[h2] = n10;", "      y1[h2 + 1] = n11;", "      y2[h2] = n20;", "      y2[h2 + 1] = n21;", "      y3[h2] = n30;", "      y3[h2 + 1] = n31;", "       y0[h2] = ixheaacd_add32_sat(x_0, x_2);", "       y0[h2 + 1] = ixheaacd_add32_sat(x_1, x_3);", "       y1[h2] = ixheaacd_add32_sat(x_4, x_6);", "       y1[h2 + 1] = ixheaacd_add32_sat(x_5, x_7);", "       y2[h2] = ixheaacd_sub32_sat(x_0, x_2);", "       y2[h2 + 1] = ixheaacd_sub32_sat(x_1, x_3);", "       y3[h2] = ixheaacd_sub32_sat(x_4, x_6);", "       y3[h2 + 1] = ixheaacd_sub32_sat(x_5, x_7);", "  ", "        x_8 = *x2++;", "        x_9 = *x2++;", "       x_a = *x2++;", "       x_b = *x2++;", "       x_c = *x2++;", "       x_d = *x2++;", " ", "        x_e = *x2++;", "        x_f = *x2++;", "  ", "      n02 = x_8 + x_a;", "      n03 = x_9 + x_b;", "      n22 = x_8 - x_a;", "      n23 = x_9 - x_b;", "      n12 = x_c + x_e;", "      n13 = x_d + x_f;", "      n32 = x_c - x_e;", "      n33 = x_d - x_f;", "      y0[h2 + 2] = n02;", "      y0[h2 + 3] = n03;", "      y1[h2 + 2] = n12;", "      y1[h2 + 3] = n13;", "      y2[h2 + 2] = n22;", "      y2[h2 + 3] = n23;", "      y3[h2 + 2] = n32;", "      y3[h2 + 3] = n33;", "       y0[h2 + 2] = ixheaacd_add32_sat(x_8, x_a);", "       y0[h2 + 3] = ixheaacd_add32_sat(x_9, x_b);", "       y1[h2 + 2] = ixheaacd_add32_sat(x_c, x_e);", "       y1[h2 + 3] = ixheaacd_add32_sat(x_d, x_f);", "       y2[h2 + 2] = ixheaacd_sub32_sat(x_8, x_a);", "       y2[h2 + 3] = ixheaacd_sub32_sat(x_9, x_b);", "       y3[h2 + 2] = ixheaacd_sub32_sat(x_c, x_e);", "       y3[h2 + 3] = ixheaacd_sub32_sat(x_d, x_f);", "      }", "      x0 += (WORD32)npoints >> 1;", "      x2 += (WORD32)npoints >> 1;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void DiceResponseHandler::OnTokenExchangeSuccess(", "     DiceTokenFetcher* token_fetcher,", "     const std::string& refresh_token,", "     bool is_under_advanced_protection) {", "   const std::string& email = token_fetcher->email();", "   const std::string& gaia_id = token_fetcher->gaia_id();", "   if (!CanGetTokenForAccount(gaia_id, email))", "     return;", "   VLOG(1) << \"[Dice] OAuth success for email \" << email;", "   bool should_enable_sync = token_fetcher->should_enable_sync();", "   std::string account_id =", "        account_tracker_service_->SeedAccountInfo(gaia_id, email);", "    account_tracker_service_->SetIsAdvancedProtectionAccount(", "        account_id, is_under_advanced_protection);", "  token_service_->UpdateCredentials(account_id, refresh_token);", "   token_service_->UpdateCredentials(", "       account_id, refresh_token,", "       signin_metrics::SourceForRefreshTokenOperation::", "           kDiceResponseHandler_Signin);", "    about_signin_internals_->OnRefreshTokenReceived(", "        base::StringPrintf(\"Successful (%s)\", account_id.c_str()));", "    if (should_enable_sync)", "     token_fetcher->delegate()->EnableSync(account_id);", " ", "   DeleteTokenFetcher(token_fetcher);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   virtual void AddObserver(Observer* observer) {", "   virtual void AddObserver(InputMethodLibrary::Observer* observer) {", "      if (!observers_.size()) {", "        observer->FirstObserverIsAdded(this);", "      }", "      observers_.AddObserver(observer);", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" construct_mac_tlv(struct sc_card *card, unsigned char *apdu_buf, size_t data_tlv_len, size_t le_tlv_len,", " \t\tunsigned char *mac_tlv, size_t * mac_tlv_len, const unsigned char key_type)", " {", " \tsize_t block_size = (KEY_TYPE_AES == key_type ? 16 : 8);", " \tunsigned char mac[4096] = { 0 };", " \tsize_t mac_len;", " \tunsigned char icv[16] = { 0 };", " \tint i = (KEY_TYPE_AES == key_type ? 15 : 7);", " \tepass2003_exdata *exdata = NULL;", " ", " \tif (!card->drv_data) ", " \t\treturn SC_ERROR_INVALID_ARGUMENTS;", " ", " \texdata = (epass2003_exdata *)card->drv_data;", " ", " \tif (0 == data_tlv_len && 0 == le_tlv_len) {", " \t\tmac_len = block_size;", " \t}", " \telse {", " \t\t ", " \t\t*(apdu_buf + block_size + data_tlv_len + le_tlv_len) = 0x80;", " \t\tif ((data_tlv_len + le_tlv_len + 1) % block_size)", " \t\t\tmac_len = (((data_tlv_len + le_tlv_len + 1) / block_size) +", " \t\t\t\t\t1) * block_size + block_size;", " ", " \t\telse", " \t\t\tmac_len = data_tlv_len + le_tlv_len + 1 + block_size;", " ", " \t\tmemset((apdu_buf + block_size + data_tlv_len + le_tlv_len + 1),", " \t\t       0, (mac_len - (data_tlv_len + le_tlv_len + 1)));", " \t}", " ", " \t ", " \tfor (; i >= 0; i--) {", " \t\tif (exdata->icv_mac[i] == 0xff) {", " \t\t\texdata->icv_mac[i] = 0;", " \t\t}", " \t\telse {", " \t\t\texdata->icv_mac[i]++;", " \t\t\tbreak;", " \t\t}", " \t}", " ", " \t ", " \tmemset(icv, 0, sizeof(icv));", " \tmemcpy(icv, exdata->icv_mac, 16);", " \tif (KEY_TYPE_AES == key_type) {", " \t\taes128_encrypt_cbc(exdata->sk_mac, 16, icv, apdu_buf, mac_len, mac);", "  \t\tmemcpy(mac_tlv + 2, &mac[mac_len - 16], 8);", "  \t}", "  \telse {", "\t\tunsigned char iv[8] = { 0 };", " \t\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };", "  \t\tunsigned char tmp[8] = { 0 };", "  \t\tdes_encrypt_cbc(exdata->sk_mac, 8, icv, apdu_buf, mac_len, mac);", "  \t\tdes_decrypt_cbc(&exdata->sk_mac[8], 8, iv, &mac[mac_len - 8], 8, tmp);", "\t\tmemset(iv, 0x00, 8);", " \t\tmemset(iv, 0x00, sizeof iv);", "  \t\tdes_encrypt_cbc(exdata->sk_mac, 8, iv, tmp, 8, mac_tlv + 2);", "  \t}", "  ", " \t*mac_tlv_len = 2 + 8;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)", "{", "int r;", "", "static const char resp[] =", "\"<u:%sResponse \"", "\"xmlns:u=\\\"%s\\\">\"", "\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"", "\"</u:%sResponse>\";", "", "char body[512];", "int bodylen;", "struct NameValueParserData data;", "char * int_ip, * int_port, * rem_host, * rem_port, * protocol;", "int opt=0;", "", "unsigned short iport, rport;", "", "if (GETFLAG(IPV6FCFWDISABLEDMASK))", "{", "SoapError(h, 702, \"FirewallDisabled\");", "return;", "}", "", "ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);", "int_ip = GetValueFromNameValueList(&data, \"InternalClient\");", "int_port = GetValueFromNameValueList(&data, \"InternalPort\");", "rem_host = GetValueFromNameValueList(&data, \"RemoteHost\");", "rem_port = GetValueFromNameValueList(&data, \"RemotePort\");", "protocol = GetValueFromNameValueList(&data, \"Protocol\");", "", "if (!int_port || !ext_port || !protocol)", "{", "ClearNameValueList(&data);", "SoapError(h, 402, \"Invalid Args\");", "return;", "}", "", "rport = (unsigned short)atoi(rem_port);", "iport = (unsigned short)atoi(int_port);", "", "", "syslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);", "", "", "r = -1;", "", "switch(r)", "{", "case 1:", "bodylen = snprintf(body, sizeof(body), resp,", "action, ns                                                           ,", "opt, action);", "BuildSendAndCloseSoapResp(h, body, bodylen);", "break;", "case -5:", "SoapError(h, 705, \"ProtocolNotSupported\");", "break;", "default:", "SoapError(h, 501, \"ActionFailed\");", "}", "ClearNameValueList(&data);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void btif_hl_select_monitor_callback(fd_set *p_cur_set ,fd_set *p_org_set) {", "     UNUSED(p_org_set);", " ", "     BTIF_TRACE_DEBUG(\"entering %s\",__FUNCTION__);", " ", "  for (const list_node_t *node = list_begin(soc_queue);", "             node != list_end(soc_queue); node = list_next(node)) {", "  btif_hl_soc_cb_t *p_scb = list_node(node);", "  if (btif_hl_get_socket_state(p_scb) == BTIF_HL_SOC_STATE_W4_READ) {", "  if (FD_ISSET(p_scb->socket_id[1], p_cur_set)) {", "                 BTIF_TRACE_DEBUG(\"read data state= BTIF_HL_SOC_STATE_W4_READ\");", "  btif_hl_mdl_cb_t *p_dcb = BTIF_HL_GET_MDL_CB_PTR(p_scb->app_idx,", "                         p_scb->mcl_idx, p_scb->mdl_idx);", "                 assert(p_dcb != NULL);", "  if (p_dcb->p_tx_pkt) {", "                     BTIF_TRACE_ERROR(\"Rcv new pkt but the last pkt is still not been\"", "  \"  sent tx_size=%d\", p_dcb->tx_size);", "                     btif_hl_free_buf((void **) &p_dcb->p_tx_pkt);", " ", "                  }", "                  p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);", "                  if (p_dcb) {", "                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,", "                            p_dcb->mtu, MSG_DONTWAIT);", "                     int r = (int)TEMP_FAILURE_RETRY(recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,", "                             p_dcb->mtu, MSG_DONTWAIT));", "                      if (r > 0) {", "                          BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback send data r =%d\", r);", "                          p_dcb->tx_size = r;", "                         BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback send data tx_size=%d\", p_dcb->tx_size );", "                         BTA_HlSendData(p_dcb->mdl_handle, p_dcb->tx_size);", "  } else {", "                         BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_callback receive failed r=%d\",r);", "                         BTA_HlDchClose(p_dcb->mdl_handle);", "  }", "  }", "  }", "  }", "  }", " ", "  if (list_is_empty(soc_queue))", "         BTIF_TRACE_DEBUG(\"btif_hl_select_monitor_queue is empty\");", " ", "     BTIF_TRACE_DEBUG(\"leaving %s\",__FUNCTION__);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,", "int bits, int row, int row_stride)", "{", "x3f_directory_entry_header_t *DEH = &DE->header;", "x3f_image_data_t *ID = &DEH->data_subsection.image_data;", "x3f_huffman_t *HUF = ID->huffman;", "", "uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);", "", "uint16_t c[3] = {0, 0, 0};", "int col;", "", "uint32_t mask = 0;", "", "switch (bits)", "{", "case 8:", "mask = 0x0ff;", "break;", "case 9:", "mask = 0x1ff;", "break;", "case 10:", "mask = 0x3ff;", "break;", "case 11:", "mask = 0x7ff;", "break;", "case 12:", "mask = 0xfff;", "break;", "default:", "mask = 0;", "", "throw LIBRAW_EXCEPTION_IO_CORRUPT;", "break;", "}", "", "for (col = 0; col < ID->columns; col++)", "{", "int color;", "uint32_t val = data[col];", "", "for (color = 0; color < 3; color++)", "{", "uint16_t c_fix;", "c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);", "", "switch (ID->type_format)", "{", "case X3F_IMAGE_RAW_HUFFMAN_X530:", "case X3F_IMAGE_RAW_HUFFMAN_10BIT:", "c_fix = (int16_t)c[color] > 0 ? c[color] : 0;", "", "HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;", "break;", "case X3F_IMAGE_THUMB_HUFFMAN:", "c_fix = (int8_t)c[color] > 0 ? c[color] : 0;", "", "HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;", "break;", "default:", "", "throw LIBRAW_EXCEPTION_IO_CORRUPT;", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,", "     int clazz, int swap, size_t align, int *flags)", " {", " \tElf32_Nhdr nh32;", " \tElf64_Nhdr nh64;", " \tsize_t noff, doff;", " #ifdef ELFCORE", " \tint os_style = -1;", " #endif", "  \tuint32_t namesz, descsz;", "  \tunsigned char *nbuf = CAST(unsigned char *, vbuf);", "  ", " \tif (xnh_sizeof + offset > size) {", " \t\t ", " \t\treturn xnh_sizeof + offset;", " \t}", " ", "  \t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);", "  \toffset += xnh_sizeof;", "  ", " \tnamesz = xnh_namesz;", " \tdescsz = xnh_descsz;", " \tif ((namesz == 0) && (descsz == 0)) {", " \t\t ", " \t\treturn (offset >= size) ? offset : size;", " \t}", " ", " \tif (namesz & 0x80000000) {", " \t    (void)file_printf(ms, \", bad note name size 0x%lx\",", " \t\t(unsigned long)namesz);", " \t    return offset;", " \t}", " ", " \tif (descsz & 0x80000000) {", " \t    (void)file_printf(ms, \", bad note description size 0x%lx\",", " \t\t(unsigned long)descsz);", " \t    return offset;", " \t}", " ", " ", " \tnoff = offset;", " \tdoff = ELF_ALIGN(offset + namesz);", " ", " \tif (offset + namesz > size) {", " \t\t ", " \t\treturn doff;", " \t}", " ", " \toffset = ELF_ALIGN(doff + descsz);", " \tif (doff + descsz > size) {", " \t\t ", " \t\treturn (offset >= size) ? offset : size;", " \t}", " ", " \tif ((*flags & (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID)) ==", " \t    (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID))", " \t\tgoto core;", " ", " \tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&", " \t    xnh_type == NT_GNU_VERSION && descsz == 2) {", " \t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);", " \t}", " \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&", " \t    xnh_type == NT_GNU_VERSION && descsz == 16) {", " \t\tuint32_t desc[4];", " \t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));", " ", " \t\tif (file_printf(ms, \", for GNU/\") == -1)", " \t\t\treturn size;", " \t\tswitch (elf_getu32(swap, desc[0])) {", " \t\tcase GNU_OS_LINUX:", " \t\t\tif (file_printf(ms, \"Linux\") == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tcase GNU_OS_HURD:", " \t\t\tif (file_printf(ms, \"Hurd\") == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tcase GNU_OS_SOLARIS:", " \t\t\tif (file_printf(ms, \"Solaris\") == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tcase GNU_OS_KFREEBSD:", " \t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tcase GNU_OS_KNETBSD:", " \t\t\tif (file_printf(ms, \"kNetBSD\") == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tif (file_printf(ms, \"<unknown>\") == -1)", " \t\t\t\treturn size; ", " \t\t}", " \t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),", " \t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)", " \t\t\treturn size;", " \t\t*flags |= FLAGS_DID_NOTE;", " \t\treturn size;", " \t}", " ", " \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&", " \t    xnh_type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {", " \t    uint8_t desc[20];", " \t    uint32_t i;", " \t    if (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :", " \t\t\"sha1\") == -1)", " \t\t    return size;", " \t    (void)memcpy(desc, &nbuf[doff], descsz);", " \t    for (i = 0; i < descsz; i++)", " \t\tif (file_printf(ms, \"%02x\", desc[i]) == -1)", " \t\t    return size;", " \t    *flags |= FLAGS_DID_BUILD_ID;", " \t}", " ", " \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&", " \t    xnh_type == NT_NETBSD_PAX && descsz == 4) {", " \t\tstatic const char *pax[] = {", " \t\t    \"+mprotect\",", " \t\t    \"-mprotect\",", " \t\t    \"+segvguard\",", " \t\t    \"-segvguard\",", " \t\t    \"+ASLR\",", " \t\t    \"-ASLR\",", " \t\t};", " \t\tuint32_t desc;", " \t\tsize_t i;", " \t\tint did = 0;", " ", " \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));", " \t\tdesc = elf_getu32(swap, desc);", " ", " \t\tif (desc && file_printf(ms, \", PaX: \") == -1)", " \t\t\treturn size;", " ", " \t\tfor (i = 0; i < __arraycount(pax); i++) {", " \t\t\tif (((1 << i) & desc) == 0)", " \t\t\t\tcontinue;", " \t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",", " \t\t\t    pax[i]) == -1)", " \t\t\t\treturn size;", " \t\t}", " \t}", " ", " \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {", " \t\tswitch (xnh_type) {", " \t\tcase NT_NETBSD_VERSION:", " \t\t\tif (descsz == 4) {", " \t\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);", " \t\t\t\t*flags |= FLAGS_DID_NOTE;", " \t\t\t\treturn size;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase NT_NETBSD_MARCH:", " \t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,", " \t\t\t    (const char *)&nbuf[doff]) == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tcase NT_NETBSD_CMODEL:", " \t\t\tif (file_printf(ms, \", compiler model: %.*s\",", " \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)", " \t\t\t\treturn size;", " \t\t\tbreak;", " \t\t}", " \t\treturn size;", " \t}", " ", " \tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {", " \t    \tif (xnh_type == NT_FREEBSD_VERSION && descsz == 4) {", " \t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);", " \t\t\t*flags |= FLAGS_DID_NOTE;", " \t\t\treturn size;", " \t\t}", " \t}", " ", " \tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&", " \t    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {", " \t\tif (file_printf(ms, \", for OpenBSD\") == -1)", " \t\t\treturn size;", " \t\t ", " \t\t*flags |= FLAGS_DID_NOTE;", " \t\treturn size;", " \t}", " ", " \tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&", " \t    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {", " \t\tuint32_t desc;", " \t\tif (file_printf(ms, \", for DragonFly\") == -1)", " \t\t\treturn size;", " \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));", " \t\tdesc = elf_getu32(swap, desc);", " \t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,", " \t\t    desc / 10000 % 10, desc % 10000) == -1)", " \t\t\treturn size;", " \t\t*flags |= FLAGS_DID_NOTE;", " \t\treturn size;", " \t}", " ", " core:", " \t ", " \tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||", " \t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {", " \t\tos_style = OS_STYLE_SVR4;", " \t} ", " ", " \tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {", " \t\tos_style = OS_STYLE_FREEBSD;", " \t}", " ", " \tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)", " \t    == 0)) {", " \t\tos_style = OS_STYLE_NETBSD;", " \t}", " ", " #ifdef ELFCORE", " \tif ((*flags & FLAGS_DID_CORE) != 0)", " \t\treturn size;", " ", " \tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {", " \t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])", " \t\t    == -1)", " \t\t\treturn size;", " \t\t*flags |= FLAGS_DID_CORE_STYLE;", " \t}", " ", " \tswitch (os_style) {", " \tcase OS_STYLE_NETBSD:", " \t\tif (xnh_type == NT_NETBSD_CORE_PROCINFO) {", " \t\t\tuint32_t signo;", " \t\t\t ", " \t\t\tif (file_printf(ms, \", from '%.31s'\",", " \t\t\t    &nbuf[doff + 0x7c]) == -1)", " \t\t\t\treturn size;", " \t\t\t", " \t\t\t ", " \t\t\t(void)memcpy(&signo, &nbuf[doff + 0x08],", " \t\t\t    sizeof(signo));", " \t\t\tif (file_printf(ms, \" (signal %u)\",", " \t\t\t    elf_getu32(swap, signo)) == -1)", " \t\t\t\treturn size;", " \t\t\t*flags |= FLAGS_DID_CORE;", " \t\t\treturn size;", " \t\t}", " \t\tbreak;", " ", " \tdefault:", " \t\tif (xnh_type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {", " \t\t\tsize_t i, j;", " \t\t\tunsigned char c;", " \t\t\t ", " \t\t\tfor (i = 0; i < NOFFSETS; i++) {", " \t\t\t\tunsigned char *cname, *cp;", " \t\t\t\tsize_t reloffset = prpsoffsets(i);", " \t\t\t\tsize_t noffset = doff + reloffset;", " \t\t\t\tsize_t k;", " \t\t\t\tfor (j = 0; j < 16; j++, noffset++,", " \t\t\t\t    reloffset++) {", " \t\t\t\t\t ", " \t\t\t\t\tif (noffset >= size)", " \t\t\t\t\t\tgoto tryanother;", " ", " \t\t\t\t\t ", " \t\t\t\t\tif (reloffset >= descsz)", " \t\t\t\t\t\tgoto tryanother;", " ", " \t\t\t\t\tc = nbuf[noffset];", " \t\t\t\t\tif (c == '\\0') {", " \t\t\t\t\t\t ", " \t\t\t\t\t\tif (j == 0)", " \t\t\t\t\t\t\tgoto tryanother;", " \t\t\t\t\t\telse", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t} else {", " \t\t\t\t\t\t ", " \t\t\t\t\t\tif (!isprint(c) || isquote(c))", " \t\t\t\t\t\t\tgoto tryanother;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\t ", " ", " \t\t\t\t ", " \t\t\t\tfor (k = i + 1 ; k < NOFFSETS ; k++) {", " \t\t\t\t\tsize_t no;", " \t\t\t\t\tint adjust = 1;", " \t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))", " \t\t\t\t\t\tcontinue;", " \t\t\t\t\tfor (no = doff + prpsoffsets(k);", " \t\t\t\t\t     no < doff + prpsoffsets(i); no++)", " \t\t\t\t\t\tadjust = adjust", " \t\t\t\t\t\t         && isprint(nbuf[no]);", " \t\t\t\t\tif (adjust)", " \t\t\t\t\t\ti = k;", " \t\t\t\t}", " ", " \t\t\t\tcname = (unsigned char *)", " \t\t\t\t    &nbuf[doff + prpsoffsets(i)];", " \t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)", " \t\t\t\t\tcontinue;", " \t\t\t\t ", " \t\t\t\twhile (cp > cname && isspace(cp[-1]))", " \t\t\t\t\tcp--;", " \t\t\t\tif (file_printf(ms, \", from '%.*s'\",", " \t\t\t\t    (int)(cp - cname), cname) == -1)", " \t\t\t\t\treturn size;", " \t\t\t\t*flags |= FLAGS_DID_CORE;", " \t\t\t\treturn size;", " ", " \t\t\ttryanother:", " \t\t\t\t;", " \t\t\t}", " \t\t}", " \t\tbreak;", " \t}", " #endif", " \treturn offset;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)", "{", "int  is_global = *eap->arg == 'g' && eap->arg[1] == ':';", "char_u *name_start = eap->arg;", "char_u *name_end = to_name_end(eap->arg, TRUE);", "int  off;", "char_u *func_name;", "char_u *lambda_name;", "ufunc_T *ufunc;", "int  r = FAIL;", "compiletype_T   compile_type;", "isn_T *funcref_isn = NULL;", "", "if (eap->forceit)", "{", "emsg(_(e_cannot_use_bang_with_nested_def));", "return NULL;", "}", "", "if (*name_start == '/')", "{", "name_end = skip_regexp(name_start + 1, '/', TRUE);", "if (*name_end == '/')", "++name_end;", "set_nextcmd(eap, name_end);", "}", "if (name_end == name_start || *skipwhite(name_end) != '(')", "{", "if (!ends_excmd2(name_start, name_end))", "{", "if (*skipwhite(name_end) == '.')", "semsg(_(e_cannot_define_dict_func_in_vim9_script_str),", "eap->cmd);", "else", "semsg(_(e_invalid_command_str), eap->cmd);", "return NULL;", "}", "", "", "if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)", "return NULL;", "return eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;", "}", "", "", "if (name_start[1] == ':' && !is_global)", "{", "semsg(_(e_namespace_not_supported_str), name_start);", "return NULL;", "}", "if (cctx->ctx_skip != SKIP_YES", "&& check_defined(name_start, name_end - name_start, cctx,", "NULL, FALSE) == FAIL)", "return NULL;", "if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0]))", "{", "semsg(_(e_function_name_must_start_with_capital_str), name_start);", "return NULL;", "}", "", "eap->arg = name_end;", "fill_exarg_from_cctx(eap, cctx);", "", "eap->forceit = FALSE;", "", "lambda_name = vim_strsave(get_lambda_name());", "if (lambda_name == NULL)", "return NULL;", "", "", "off = is_global ? 2 : 0;", "func_name = vim_strnsave(name_start + off, name_end - name_start - off);", "if (func_name == NULL)", "{", "r = FAIL;", "goto theend;", "}", "", "ufunc = define_function(eap, lambda_name, lines_to_free);", "if (ufunc == NULL)", "{", "r = eap->skip ? OK : FAIL;", "goto theend;", "}", "if (eap->nextcmd != NULL)", "{", "semsg(_(e_text_found_after_str_str),", "eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);", "r = FAIL;", "func_ptr_unref(ufunc);", "goto theend;", "}", "", "", "if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)", "{", "int block_depth = cctx->ctx_ufunc->uf_block_depth;", "", "ufunc->uf_block_ids = ALLOC_MULT(int, block_depth);", "if (ufunc->uf_block_ids != NULL)", "{", "mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,", "sizeof(int) * block_depth);", "ufunc->uf_block_depth = block_depth;", "}", "}", "", "", "", "if (is_global)", "{", "r = generate_NEWFUNC(cctx, lambda_name, func_name);", "func_name = NULL;", "lambda_name = NULL;", "}", "else", "{", "", "lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,", "TRUE, ufunc->uf_func_type);", "", "if (lvar == NULL)", "goto theend;", "if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)", "goto theend;", "r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);", "}", "", "compile_type = get_compile_type(ufunc);", "#ifdef FEAT_PROFILE", "", "", "if (cctx->ctx_compile_type == CT_PROFILE)", "compile_type = CT_PROFILE;", "#endif", "if (func_needs_compiling(ufunc, compile_type)", "&& compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)", "{", "func_ptr_unref(ufunc);", "goto theend;", "}", "", "#ifdef FEAT_PROFILE", "", "", "if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))", "compile_def_function(ufunc, FALSE, CT_NONE, cctx);", "#endif", "", "", "if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED)", "funcref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx;", "", "theend:", "vim_free(lambda_name);", "vim_free(func_name);", "return r == FAIL ? NULL : (char_u *)\"\";", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["v8::Local<v8::Object> CreateNativeEvent(", "v8::Isolate* isolate,", "v8::Local<v8::Object> sender,", "content::RenderFrameHost* frame,", "electron::mojom::ElectronBrowser::MessageSyncCallback callback) {", "v8::Local<v8::Object> event;", "if (frame && callback) {", "gin::Handle<Event> native_event = Event::Create(isolate);", "native_event->SetCallback(std::move(callback));", "event = v8::Local<v8::Object>::Cast(native_event.ToV8());", "} else {", "", "event = CreateEvent(isolate);", "}", "", "Dictionary dict(isolate, event);", "dict.Set(\"sender\", sender);", "", "if (frame)", "dict.Set(\"frameId\", frame->GetRoutingID());", "return event;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"tokens": [" DOMWindow* CreateWindow(const String& url_string,", "                         const AtomicString& frame_name,", "                         const String& window_features_string,", "                         LocalDOMWindow& calling_window,", "                         LocalFrame& first_frame,", "                         LocalFrame& opener_frame,", "                         ExceptionState& exception_state) {", "   LocalFrame* active_frame = calling_window.GetFrame();", "   DCHECK(active_frame);", " ", "   KURL completed_url = url_string.IsEmpty()", "                            ? KURL(kParsedURLString, g_empty_string)", "                            : first_frame.GetDocument()->CompleteURL(url_string);", "   if (!completed_url.IsEmpty() && !completed_url.IsValid()) {", "     UseCounter::Count(active_frame, WebFeature::kWindowOpenWithInvalidURL);", "     exception_state.ThrowDOMException(", "         kSyntaxError, \"Unable to open a window with invalid URL '\" +", "                           completed_url.GetString() + \"'.\\n\");", "      return nullptr;", "    }", "  ", "   if (completed_url.ProtocolIsJavaScript() &&", "       opener_frame.GetDocument()->GetContentSecurityPolicy() &&", "       !ContentSecurityPolicy::ShouldBypassMainWorld(", "           opener_frame.GetDocument())) {", "     const int kJavascriptSchemeLength = sizeof(\"javascript:\") - 1;", "     String script_source = DecodeURLEscapeSequences(completed_url.GetString())", "                                .Substring(kJavascriptSchemeLength);", " ", "     if (!opener_frame.GetDocument()", "              ->GetContentSecurityPolicy()", "              ->AllowJavaScriptURLs(nullptr, script_source,", "                                    opener_frame.GetDocument()->Url(),", "                                    OrdinalNumber())) {", "       return nullptr;", "     }", "   }", " ", "    WebWindowFeatures window_features =", "        GetWindowFeaturesFromString(window_features_string);", "  ", "   FrameLoadRequest frame_request(calling_window.document(),", "                                  ResourceRequest(completed_url), frame_name);", "   frame_request.SetShouldSetOpener(window_features.noopener ? kNeverSetOpener", "                                                             : kMaybeSetOpener);", "   frame_request.GetResourceRequest().SetFrameType(", "       WebURLRequest::kFrameTypeAuxiliary);", "   frame_request.GetResourceRequest().SetRequestorOrigin(", "       SecurityOrigin::Create(active_frame->GetDocument()->Url()));", " ", "   frame_request.GetResourceRequest().SetHTTPReferrer(", "       SecurityPolicy::GenerateReferrer(", "           active_frame->GetDocument()->GetReferrerPolicy(), completed_url,", "           active_frame->GetDocument()->OutgoingReferrer()));", " ", "   bool has_user_gesture = UserGestureIndicator::ProcessingUserGesture();", " ", "   bool created;", "   Frame* new_frame = CreateWindowHelper(", "       opener_frame, *active_frame, opener_frame, frame_request, window_features,", "       kNavigationPolicyIgnore, created);", "   if (!new_frame)", "     return nullptr;", "   if (new_frame->DomWindow()->IsInsecureScriptAccess(calling_window,", "                                                      completed_url))", "     return window_features.noopener ? nullptr : new_frame->DomWindow();", " ", "   if (created) {", "     FrameLoadRequest request(calling_window.document(),", "                              ResourceRequest(completed_url));", "     request.GetResourceRequest().SetHasUserGesture(has_user_gesture);", "     new_frame->Navigate(request);", "   } else if (!url_string.IsEmpty()) {", "     new_frame->Navigate(*calling_window.document(), completed_url, false,", "                         has_user_gesture ? UserGestureStatus::kActive", "                                          : UserGestureStatus::kNone);", "   }", "   return window_features.noopener ? nullptr : new_frame->DomWindow();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   FileMetricsProviderTest()", "       : create_large_files_(GetParam()),", "         task_runner_(new base::TestSimpleTaskRunner()),", "         thread_task_runner_handle_(task_runner_),", "         statistics_recorder_(", "             base::StatisticsRecorder::CreateTemporaryForTesting()),", "         prefs_(new TestingPrefServiceSimple) {", "      EXPECT_TRUE(temp_dir_.CreateUniqueTempDir());", "      FileMetricsProvider::RegisterPrefs(prefs_->registry(), kMetricsName);", "      FileMetricsProvider::SetTaskRunnerForTesting(task_runner_);", "    base::GlobalHistogramAllocator::GetCreateHistogramResultHistogram();", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["int nfc_dep_link_down(struct nfc_dev *dev)", "{", "int rc = 0;", "", "pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));", "", "if (!dev->ops->dep_link_down)", "return -EOPNOTSUPP;", "", "device_lock(&dev->dev);", "", "if (!device_is_registered(&dev->dev)) {", "rc = -ENODEV;", "goto error;", "}", "", "if (dev->dep_link_up == false) {", "rc = -EALREADY;", "goto error;", "}", "", "rc = dev->ops->dep_link_down(dev);", "if (!rc) {", "dev->dep_link_up = false;", "dev->active_target = NULL;", "dev->rf_mode = NFC_RF_NONE;", "nfc_llcp_mac_is_down(dev);", "nfc_genl_dep_link_down_event(dev);", "}", "", "error:", "device_unlock(&dev->dev);", "", "return rc;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void array_cleanup( char* arr[] , int arr_size)", "  {", "  \tint i=0;", "\tfor( i=0; i< arr_size; i++ ){ ", " \tfor( i=0; i< arr_size; i++ ){", "  \t\tif( arr[i*2] ){", "  \t\t\tefree( arr[i*2]);", "  \t\t}", " \t}", " \tefree(arr);", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cg_open(const char *path, struct fuse_file_info *fi)", " {", " \tconst char *cgroup;", " \tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;", " \tstruct cgfs_files *k = NULL;", " \tstruct file_info *file_info;", " \tstruct fuse_context *fc = fuse_get_context();", " \tint ret;", " ", " \tif (!fc)", " \t\treturn -EIO;", " ", " \tcontroller = pick_controller_from_path(fc, path);", " \tif (!controller)", " \t\treturn -EIO;", " \tcgroup = find_cgroup_in_path(path);", " \tif (!cgroup)", " \t\treturn -EINVAL;", " ", " \tget_cgdir_and_path(cgroup, &cgdir, &fpath);", " \tif (!fpath) {", " \t\tpath1 = \"/\";", " \t\tpath2 = cgdir;", " \t} else {", " \t\tpath1 = cgdir;", " \t\tpath2 = fpath;", " \t}", " ", " \tk = cgfs_get_key(controller, path1, path2);", " \tif (!k) {", " \t\tret = -EINVAL;", " \t\tgoto out;", "  \t}", "  \tfree_key(k);", "  ", " \tif (!caller_may_see_dir(fc->pid, controller, path1)) {", " \t\tret = -ENOENT;", " \t\tgoto out;", " \t}", "  \tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {", "  \t\tret = -EACCES;", " \t\tgoto out;", " \t}", " ", " \t ", " \tfile_info = malloc(sizeof(*file_info));", " \tif (!file_info) {", " \t\tret = -ENOMEM;", " \t\tgoto out;", " \t}", " \tfile_info->controller = must_copy_string(controller);", " \tfile_info->cgroup = must_copy_string(path1);", " \tfile_info->file = must_copy_string(path2);", " \tfile_info->type = LXC_TYPE_CGFILE;", " \tfile_info->buf = NULL;", " \tfile_info->buflen = 0;", " ", " \tfi->fh = (unsigned long)file_info;", " \tret = 0;", " ", " out:", " \tfree(cgdir);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)", "", "{", "unsigned int len;", "unsigned long start=0, off;", "struct au1200fb_device *fbdev = info->par;", "", "if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {", "return -EINVAL;", "}", "", "start = fbdev->fb_phys & PAGE_MASK;", "len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);", "", "off = vma->vm_pgoff << PAGE_SHIFT;", "", "if ((vma->vm_end - vma->vm_start + off) > len) {", "return -EINVAL;", "}", "", "off += start;", "vma->vm_pgoff = off >> PAGE_SHIFT;", "", "vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);", "pgprot_val(vma->vm_page_prot) |= _CACHE_MASK;", "", "return io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,", "vma->vm_end - vma->vm_start,", "vma->vm_page_prot);", "}"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["  init_global_keywords(bool global_active)", "  {", " \t ", " \tinstall_keyword_root(\"linkbeat_use_polling\", use_polling_handler, global_active);", " #if HAVE_DECL_CLONE_NEWNET", " \tinstall_keyword_root(\"net_namespace\", &net_namespace_handler, global_active);", " \tinstall_keyword_root(\"namespace_with_ipsets\", &namespace_ipsets_handler, global_active);", " #endif", " \tinstall_keyword_root(\"use_pid_dir\", &use_pid_dir_handler, global_active);", " \tinstall_keyword_root(\"instance\", &instance_handler, global_active);", " \tinstall_keyword_root(\"child_wait_time\", &child_wait_handler, global_active);", " \tinstall_keyword_root(\"global_defs\", NULL, global_active);", " \tinstall_keyword(\"router_id\", &routerid_handler);", " \tinstall_keyword(\"notification_email_from\", &emailfrom_handler);", " \tinstall_keyword(\"smtp_server\", &smtpserver_handler);", " \tinstall_keyword(\"smtp_helo_name\", &smtphelo_handler);", " \tinstall_keyword(\"smtp_connect_timeout\", &smtpto_handler);", " \tinstall_keyword(\"notification_email\", &email_handler);", " \tinstall_keyword(\"smtp_alert\", &smtp_alert_handler);", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"smtp_alert_vrrp\", &smtp_alert_vrrp_handler);", " #endif", " #ifdef _WITH_LVS_", " \tinstall_keyword(\"smtp_alert_checker\", &smtp_alert_checker_handler);", " #endif", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"dynamic_interfaces\", &dynamic_interfaces_handler);", " \tinstall_keyword(\"no_email_faults\", &no_email_faults_handler);", " \tinstall_keyword(\"default_interface\", &default_interface_handler);", " #endif", " #ifdef _WITH_LVS_", " \tinstall_keyword(\"lvs_timeouts\", &lvs_timeouts);", " \tinstall_keyword(\"lvs_flush\", &lvs_flush_handler);", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"lvs_sync_daemon\", &lvs_syncd_handler);", " #endif", " #endif", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"vrrp_mcast_group4\", &vrrp_mcast_group4_handler);", " \tinstall_keyword(\"vrrp_mcast_group6\", &vrrp_mcast_group6_handler);", " \tinstall_keyword(\"vrrp_garp_master_delay\", &vrrp_garp_delay_handler);", " \tinstall_keyword(\"vrrp_garp_master_repeat\", &vrrp_garp_rep_handler);", " \tinstall_keyword(\"vrrp_garp_master_refresh\", &vrrp_garp_refresh_handler);", " \tinstall_keyword(\"vrrp_garp_master_refresh_repeat\", &vrrp_garp_refresh_rep_handler);", " \tinstall_keyword(\"vrrp_garp_lower_prio_delay\", &vrrp_garp_lower_prio_delay_handler);", " \tinstall_keyword(\"vrrp_garp_lower_prio_repeat\", &vrrp_garp_lower_prio_rep_handler);", " \tinstall_keyword(\"vrrp_garp_interval\", &vrrp_garp_interval_handler);", " \tinstall_keyword(\"vrrp_gna_interval\", &vrrp_gna_interval_handler);", " \tinstall_keyword(\"vrrp_lower_prio_no_advert\", &vrrp_lower_prio_no_advert_handler);", " \tinstall_keyword(\"vrrp_higher_prio_send_advert\", &vrrp_higher_prio_send_advert_handler);", " \tinstall_keyword(\"vrrp_version\", &vrrp_version_handler);", " \tinstall_keyword(\"vrrp_iptables\", &vrrp_iptables_handler);", " #ifdef _HAVE_LIBIPSET_", " \tinstall_keyword(\"vrrp_ipsets\", &vrrp_ipsets_handler);", " #endif", " \tinstall_keyword(\"vrrp_check_unicast_src\", &vrrp_check_unicast_src_handler);", " \tinstall_keyword(\"vrrp_skip_check_adv_addr\", &vrrp_check_adv_addr_handler);", " \tinstall_keyword(\"vrrp_strict\", &vrrp_strict_handler);", " \tinstall_keyword(\"vrrp_priority\", &vrrp_prio_handler);", " \tinstall_keyword(\"vrrp_no_swap\", &vrrp_no_swap_handler);", " #ifdef _HAVE_SCHED_RT_", " \tinstall_keyword(\"vrrp_rt_priority\", &vrrp_rt_priority_handler);", " #if HAVE_DECL_RLIMIT_RTTIME == 1", " \tinstall_keyword(\"vrrp_rlimit_rtime\", &vrrp_rt_rlimit_handler);", " #endif", " #endif", " #endif", " \tinstall_keyword(\"notify_fifo\", &global_notify_fifo);", " \tinstall_keyword(\"notify_fifo_script\", &global_notify_fifo_script);", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"vrrp_notify_fifo\", &vrrp_notify_fifo);", " \tinstall_keyword(\"vrrp_notify_fifo_script\", &vrrp_notify_fifo_script);", " #endif", " #ifdef _WITH_LVS_", " \tinstall_keyword(\"lvs_notify_fifo\", &lvs_notify_fifo);", " \tinstall_keyword(\"lvs_notify_fifo_script\", &lvs_notify_fifo_script);", " \tinstall_keyword(\"checker_priority\", &checker_prio_handler);", " \tinstall_keyword(\"checker_no_swap\", &checker_no_swap_handler);", " #ifdef _HAVE_SCHED_RT_", " \tinstall_keyword(\"checker_rt_priority\", &checker_rt_priority_handler);", " #if HAVE_DECL_RLIMIT_RTTIME == 1", " \tinstall_keyword(\"checker_rlimit_rtime\", &checker_rt_rlimit_handler);", " #endif", " #endif", " #endif", " #ifdef _WITH_BFD_", " \tinstall_keyword(\"bfd_priority\", &bfd_prio_handler);", " \tinstall_keyword(\"bfd_no_swap\", &bfd_no_swap_handler);", " #ifdef _HAVE_SCHED_RT_", " \tinstall_keyword(\"bfd_rt_priority\", &bfd_rt_priority_handler);", " #if HAVE_DECL_RLIMIT_RTTIME == 1", " \tinstall_keyword(\"bfd_rlimit_rtime\", &bfd_rt_rlimit_handler);", " #endif", " #endif", " #endif", " #ifdef _WITH_SNMP_", " \tinstall_keyword(\"snmp_socket\", &snmp_socket_handler);", " \tinstall_keyword(\"enable_traps\", &trap_handler);", " #ifdef _WITH_SNMP_VRRP_", " \tinstall_keyword(\"enable_snmp_vrrp\", &snmp_vrrp_handler);", " \tinstall_keyword(\"enable_snmp_keepalived\", &snmp_vrrp_handler);\t ", " #endif", " #ifdef _WITH_SNMP_RFC_", " \tinstall_keyword(\"enable_snmp_rfc\", &snmp_rfc_handler);", " #endif", " #ifdef _WITH_SNMP_RFCV2_", " \tinstall_keyword(\"enable_snmp_rfcv2\", &snmp_rfcv2_handler);", " #endif", " #ifdef _WITH_SNMP_RFCV3_", " \tinstall_keyword(\"enable_snmp_rfcv3\", &snmp_rfcv3_handler);", " #endif", " #ifdef _WITH_SNMP_CHECKER_", " \tinstall_keyword(\"enable_snmp_checker\", &snmp_checker_handler);", " #endif", " #endif", " #ifdef _WITH_DBUS_", " \tinstall_keyword(\"enable_dbus\", &enable_dbus_handler);", " \tinstall_keyword(\"dbus_service_name\", &dbus_service_name_handler);", " #endif", " \tinstall_keyword(\"script_user\", &script_user_handler);", " \tinstall_keyword(\"enable_script_security\", &script_security_handler);", " #ifdef _WITH_VRRP_", " \tinstall_keyword(\"vrrp_netlink_cmd_rcv_bufs\", &vrrp_netlink_cmd_rcv_bufs_handler);", " \tinstall_keyword(\"vrrp_netlink_cmd_rcv_bufs_force\", &vrrp_netlink_cmd_rcv_bufs_force_handler);", " \tinstall_keyword(\"vrrp_netlink_monitor_rcv_bufs\", &vrrp_netlink_monitor_rcv_bufs_handler);", " \tinstall_keyword(\"vrrp_netlink_monitor_rcv_bufs_force\", &vrrp_netlink_monitor_rcv_bufs_force_handler);", " #endif", " #ifdef _WITH_LVS_", " \tinstall_keyword(\"lvs_netlink_cmd_rcv_bufs\", &lvs_netlink_cmd_rcv_bufs_handler);", " \tinstall_keyword(\"lvs_netlink_cmd_rcv_bufs_force\", &lvs_netlink_cmd_rcv_bufs_force_handler);", " \tinstall_keyword(\"lvs_netlink_monitor_rcv_bufs\", &lvs_netlink_monitor_rcv_bufs_handler);", " \tinstall_keyword(\"lvs_netlink_monitor_rcv_bufs_force\", &lvs_netlink_monitor_rcv_bufs_force_handler);", " #endif", " #ifdef _WITH_LVS_", " \tinstall_keyword(\"rs_init_notifies\", &rs_init_notifies_handler);", " \tinstall_keyword(\"no_checker_emails\", &no_checker_emails_handler);", " #endif", " #ifdef _WITH_VRRP_", "  \tinstall_keyword(\"vrrp_rx_bufs_policy\", &vrrp_rx_bufs_policy_handler);", "  \tinstall_keyword(\"vrrp_rx_bufs_multiplier\", &vrrp_rx_bufs_multiplier_handler);", "  #endif", " \tinstall_keyword(\"umask\", &umask_handler);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" spnego_gss_delete_sec_context(", " \t\t\t    OM_uint32 *minor_status,", " \t\t\t    gss_ctx_id_t *context_handle,", " \t\t\t    gss_buffer_t output_token)", " {", " \tOM_uint32 ret = GSS_S_COMPLETE;", " \tspnego_gss_ctx_id_t *ctx =", " \t\t    (spnego_gss_ctx_id_t *)context_handle;", " ", " \t*minor_status = 0;", " ", " \tif (context_handle == NULL)", " \t\treturn (GSS_S_FAILURE);", " ", "  \tif (*ctx == NULL)", "  \t\treturn (GSS_S_COMPLETE);", "  ", "\t ", "\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {", "\t\t(void) gss_delete_sec_context(minor_status,", "\t\t\t\t    &(*ctx)->ctx_handle,", "\t\t\t\t    output_token);", "\t\t(void) release_spnego_ctx(ctx);", "\t} else {", "\t\tret = gss_delete_sec_context(minor_status,", "\t\t\t\t    context_handle,", "\t\t\t\t    output_token);", "\t}", " \t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,", " \t\t\t\t      output_token);", " \t(void) release_spnego_ctx(ctx);", "  ", "  \treturn (ret);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" vhost_scsi_make_tpg(struct se_wwn *wwn,", " \t\t   struct config_group *group,", " \t\t   const char *name)", " {", " \tstruct vhost_scsi_tport *tport = container_of(wwn,", "  \t\t\tstruct vhost_scsi_tport, tport_wwn);", "  ", "  \tstruct vhost_scsi_tpg *tpg;", "\tunsigned long tpgt;", " \tu16 tpgt;", "  \tint ret;", "  ", "  \tif (strstr(name, \"tpgt_\") != name)", "  \t\treturn ERR_PTR(-EINVAL);", "\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)", " \tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)", "  \t\treturn ERR_PTR(-EINVAL);", "  ", "  \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);", " \tif (!tpg) {", " \t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");", " \t\treturn ERR_PTR(-ENOMEM);", " \t}", " \tmutex_init(&tpg->tv_tpg_mutex);", " \tINIT_LIST_HEAD(&tpg->tv_tpg_list);", " \ttpg->tport = tport;", " \ttpg->tport_tpgt = tpgt;", " ", " \tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,", " \t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);", " \tif (ret < 0) {", " \t\tkfree(tpg);", " \t\treturn NULL;", " \t}", " \tmutex_lock(&vhost_scsi_mutex);", " \tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);", " \tmutex_unlock(&vhost_scsi_mutex);", " ", " \treturn &tpg->se_tpg;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)", " {", " \tint ufd;", " \tstruct timerfd_ctx *ctx;", " ", " \t ", " \tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);", " \tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);", " ", " \tif ((flags & ~TFD_CREATE_FLAGS) ||", " \t    (clockid != CLOCK_MONOTONIC &&", " \t     clockid != CLOCK_REALTIME &&", " \t     clockid != CLOCK_REALTIME_ALARM &&", " \t     clockid != CLOCK_BOOTTIME &&", " \t     clockid != CLOCK_BOOTTIME_ALARM))", " \t\treturn -EINVAL;", " ", " \tif (!capable(CAP_WAKE_ALARM) &&", " \t    (clockid == CLOCK_REALTIME_ALARM ||", " \t     clockid == CLOCK_BOOTTIME_ALARM))", " \t\treturn -EPERM;", " ", " \tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);", " \tif (!ctx)", "  \t\treturn -ENOMEM;", "  ", "  \tinit_waitqueue_head(&ctx->wqh);", " \tspin_lock_init(&ctx->cancel_lock);", "  \tctx->clockid = clockid;", "  ", "  \tif (isalarm(ctx))", " \t\talarm_init(&ctx->t.alarm,", " \t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?", " \t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,", " \t\t\t   timerfd_alarmproc);", " \telse", " \t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);", " ", " \tctx->moffs = ktime_mono_to_real(0);", " ", " \tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,", " \t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));", " \tif (ufd < 0)", " \t\tkfree(ctx);", " ", " \treturn ufd;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   ExtensionScriptAndCaptureVisibleTest()", "       : http_url(\"http:www.google.com\"),", "         http_url_with_path(\"http:www.google.com/index.html\"),", "         https_url(\"https:www.google.com\"),", "         example_com(\"https:example.com\"),", "         test_example_com(\"https:test.example.com\"),", "         sample_example_com(\"https:sample.example.com\"),", "         file_url(\"file:/foo/bar\"),", "         favicon_url(\"chrome:favicon/http:www.google.com\"),", "         extension_url(\"chrome-extension:\" +", "                        crx_file::id_util::GenerateIdForPath(", "                            base::FilePath(FILE_PATH_LITERAL(\"foo\")))),", "          settings_url(\"chrome:settings\"),", "        about_url(\"about:flags\") {", "         about_flags_url(\"about:flags\") {", "      urls_.insert(http_url);", "      urls_.insert(http_url_with_path);", "      urls_.insert(https_url);", "     urls_.insert(example_com);", "     urls_.insert(test_example_com);", "     urls_.insert(sample_example_com);", "     urls_.insert(file_url);", "      urls_.insert(favicon_url);", "      urls_.insert(extension_url);", "      urls_.insert(settings_url);", "    urls_.insert(about_url);", "     urls_.insert(about_flags_url);", "      PermissionsData::SetPolicyDelegate(NULL);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" bool GraphicsContext3D::getImageData(Image* image,", "                                      GC3Denum format,", "                                      GC3Denum type,", "                                      bool premultiplyAlpha,", "                                      bool ignoreGammaAndColorProfile,", "                                      Vector<uint8_t>& outputVector)", " {", "     if (!image)", "          return false;", "      CGImageRef cgImage;", "      RetainPtr<CGImageRef> decodedImage;", "    bool hasAlpha = image->isBitmapImage() ? static_cast<BitmapImage*>(image)->frameHasAlphaAtIndex(0) : true;", "     bool hasAlpha = image->isBitmapImage() ? image->currentFrameHasAlpha() : true;", "      if ((ignoreGammaAndColorProfile || (hasAlpha && !premultiplyAlpha)) && image->data()) {", "          ImageSource decoder(ImageSource::AlphaNotPremultiplied,", "                              ignoreGammaAndColorProfile ? ImageSource::GammaAndColorProfileIgnored : ImageSource::GammaAndColorProfileApplied);", "         decoder.setData(image->data(), true);", "         if (!decoder.frameCount())", "             return false;", "         decodedImage.adoptCF(decoder.createFrameAtIndex(0));", "         cgImage = decodedImage.get();", "     } else", "         cgImage = image->nativeImageForCurrentFrame();", "     if (!cgImage)", "         return false;", " ", "     size_t width = CGImageGetWidth(cgImage);", "     size_t height = CGImageGetHeight(cgImage);", "     if (!width || !height)", "         return false;", " ", "     CGColorSpaceRef colorSpace = CGImageGetColorSpace(cgImage);", "     CGColorSpaceModel model = CGColorSpaceGetModel(colorSpace);", "     if (model == kCGColorSpaceModelIndexed) {", "         RetainPtr<CGContextRef> bitmapContext;", "         bitmapContext.adoptCF(CGBitmapContextCreate(0, width, height, 8, width * 4,", "                                                     deviceRGBColorSpaceRef(),", "                                                     kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host));", "         if (!bitmapContext)", "             return false;", " ", "         CGContextSetBlendMode(bitmapContext.get(), kCGBlendModeCopy);", "         CGContextSetInterpolationQuality(bitmapContext.get(), kCGInterpolationNone);", "         CGContextDrawImage(bitmapContext.get(), CGRectMake(0, 0, width, height), cgImage);", " ", "         decodedImage.adoptCF(CGBitmapContextCreateImage(bitmapContext.get()));", "         cgImage = decodedImage.get();", "     }", " ", "     size_t bitsPerComponent = CGImageGetBitsPerComponent(cgImage);", "     size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage);", "     if (bitsPerComponent != 8 && bitsPerComponent != 16)", "         return false;", "     if (bitsPerPixel % bitsPerComponent)", "         return false;", "     size_t componentsPerPixel = bitsPerPixel / bitsPerComponent;", " ", "     CGBitmapInfo bitInfo = CGImageGetBitmapInfo(cgImage);", "     bool bigEndianSource = false;", "     if (bitsPerComponent == 16) {", "         switch (bitInfo & kCGBitmapByteOrderMask) {", "         case kCGBitmapByteOrder16Big:", "             bigEndianSource = true;", "             break;", "         case kCGBitmapByteOrder16Little:", "             bigEndianSource = false;", "             break;", "         case kCGBitmapByteOrderDefault:", "             bigEndianSource = true;", "             break;", "         default:", "             return false;", "         }", "     } else {", "         switch (bitInfo & kCGBitmapByteOrderMask) {", "         case kCGBitmapByteOrder32Big:", "             bigEndianSource = true;", "             break;", "         case kCGBitmapByteOrder32Little:", "             bigEndianSource = false;", "             break;", "         case kCGBitmapByteOrderDefault:", "             bigEndianSource = true;", "             break;", "         default:", "             return false;", "         }", "     }", " ", "     AlphaOp neededAlphaOp = AlphaDoNothing;", "     AlphaFormat alphaFormat = AlphaFormatNone;", "     switch (CGImageGetAlphaInfo(cgImage)) {", "     case kCGImageAlphaPremultipliedFirst:", "         if (!premultiplyAlpha)", "             neededAlphaOp = AlphaDoUnmultiply;", "         alphaFormat = AlphaFormatFirst;", "         break;", "     case kCGImageAlphaFirst:", "         if (premultiplyAlpha)", "             neededAlphaOp = AlphaDoPremultiply;", "         alphaFormat = AlphaFormatFirst;", "         break;", "     case kCGImageAlphaNoneSkipFirst:", "         alphaFormat = AlphaFormatFirst;", "         break;", "     case kCGImageAlphaPremultipliedLast:", "         if (!premultiplyAlpha)", "             neededAlphaOp = AlphaDoUnmultiply;", "         alphaFormat = AlphaFormatLast;", "         break;", "     case kCGImageAlphaLast:", "         if (premultiplyAlpha)", "             neededAlphaOp = AlphaDoPremultiply;", "         alphaFormat = AlphaFormatLast;", "         break;", "     case kCGImageAlphaNoneSkipLast:", "         alphaFormat = AlphaFormatLast;", "         break;", "     case kCGImageAlphaNone:", "         alphaFormat = AlphaFormatNone;", "         break;", "     default:", "         return false;", "     }", "     SourceDataFormat srcDataFormat = getSourceDataFormat(componentsPerPixel, alphaFormat, bitsPerComponent == 16, bigEndianSource);", "     if (srcDataFormat == SourceFormatNumFormats)", "         return false;", " ", "     RetainPtr<CFDataRef> pixelData;", "     pixelData.adoptCF(CGDataProviderCopyData(CGImageGetDataProvider(cgImage)));", "     if (!pixelData)", "         return false;", "     const UInt8* rgba = CFDataGetBytePtr(pixelData.get());", " ", "     unsigned int packedSize;", "     if (computeImageSizeInBytes(format, type, width, height, 1, &packedSize, 0) != GraphicsContext3D::NO_ERROR)", "         return false;", "     outputVector.resize(packedSize);", " ", "     unsigned int srcUnpackAlignment = 0;", "     size_t bytesPerRow = CGImageGetBytesPerRow(cgImage);", "     unsigned int padding = bytesPerRow - bitsPerPixel / 8 * width;", "     if (padding) {", "         srcUnpackAlignment = padding + 1;", "         while (bytesPerRow % srcUnpackAlignment)", "             ++srcUnpackAlignment;", "     }", "     bool rt = packPixels(rgba, srcDataFormat, width, height, srcUnpackAlignment,", "                          format, type, neededAlphaOp, outputVector.data());", "     return rt;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_uids_guids(long long *table_start)", " static int read_id_table(long long *table_start)", "  {", " \t ", "  \tint res, i;", "  \tint bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);", "  \tint indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);", "\tlong long id_index_table[indexes];", " \tint length = SQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids);", " \tlong long *id_index_table;", " ", " \t ", " \tif(length != (*table_start - sBlk.s.id_table_start)) {", " \t\tERROR(\"read_id_table: Bad id count in super block\\n\");", " \t\treturn FALSE;", " \t}", "  ", "\tTRACE(\"read_uids_guids: no_ids %d\\n\", sBlk.s.no_ids);", " \tTRACE(\"read_id_table: no_ids %d\\n\", sBlk.s.no_ids);", "  ", " \tid_index_table = alloc_index_table(indexes);", "  \tid_table = malloc(bytes);", "  \tif(id_table == NULL) {", "\t\tERROR(\"read_uids_guids: failed to allocate id table\\n\");", " \t\tERROR(\"read_id_table: failed to allocate id table\\n\");", "  \t\treturn FALSE;", "  \t}", "  ", "\tres = read_fs_bytes(fd, sBlk.s.id_table_start,", "\t\tSQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);", " \tres = read_fs_bytes(fd, sBlk.s.id_table_start, length, id_index_table);", "  \tif(res == FALSE) {", "\t\tERROR(\"read_uids_guids: failed to read id index table\\n\");", " \t\tERROR(\"read_id_table: failed to read id index table\\n\");", "  \t\treturn FALSE;", "  \t}", "  \tSQUASHFS_INSWAP_ID_BLOCKS(id_index_table, indexes);", " ", " \t ", " \t*table_start = id_index_table[0];", " ", " \tfor(i = 0; i < indexes; i++) {", " \t\tint expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :", " \t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);", "  \t\tres = read_block(fd, id_index_table[i], NULL, expected,", "  \t\t\t((char *) id_table) + i * SQUASHFS_METADATA_SIZE);", "  \t\tif(res == FALSE) {", "\t\t\tERROR(\"read_uids_guids: failed to read id table block\"", " \t\t\tERROR(\"read_id_table: failed to read id table block\"", "  \t\t\t\t\"\\n\");", "  \t\t\treturn FALSE;", "  \t\t}", " \t}", " ", " \tSQUASHFS_INSWAP_INTS(id_table, sBlk.s.no_ids);", " ", " \treturn TRUE;", " }"], "ner_tags": [0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void svhandler_flash_pgm_blk(void) {", "uint32_t beginAddr = _param_1;", "uint32_t data = _param_2;", "uint32_t length = _param_3;", "", "", "if (beginAddr + length < beginAddr) return;", "", "", "if (((beginAddr >= BSTRP_FLASH_SECT_START) &&", "(beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||", "(((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&", "((beginAddr + length) <=", "(BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {", "return;", "}", "", "if (((beginAddr >= BLDR_FLASH_SECT_START) &&", "(beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||", "(((beginAddr + length) >= BLDR_FLASH_SECT_START) &&", "((beginAddr + length) <=", "(BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {", "return;", "}", "", "", "flash_clear_status_flags();", "flash_unlock();", "", "", "flash_program(beginAddr, (uint8_t *)data, length);", "", "", "_param_1 = !!flash_chk_status();", "_param_2 = 0;", "_param_3 = 0;", "", "", "flash_wait_for_last_operation();", "", "", "FLASH_CR &= ~FLASH_CR_PG;", "", "", "FLASH_CR |= FLASH_CR_LOCK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,", "                                            LINK_KEY link_key,", "  uint8_t key_type,", "  uint8_t pin_length)", " {", "  bdstr_t bdstr;", "     bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));", " ", "      int ret = btif_config_set_int(bdstr, \"LinkKeyType\", (int)key_type);", "      ret &= btif_config_set_int(bdstr, \"PinLength\", (int)pin_length);", "      ret &= btif_config_set_bin(bdstr, \"LinkKey\", link_key, sizeof(LINK_KEY));", " ", "     if (is_restricted_mode()) {", "         BTIF_TRACE_WARNING(\"%s: '%s' pairing will be removed if unrestricted\",", "                          __func__, bdstr);", "         btif_config_set_int(bdstr, \"Restricted\", 1);", "     }", " ", "       ", "      btif_config_flush();", "      return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {", "  uint8_t* p = (uint8_t*)p_data;", " ", "    uint8_t reason = SMP_INVALID_PARAMETERS;", "  ", "    SMP_TRACE_DEBUG(\"%s\", __func__);", "  p_cb->status = *(uint8_t*)p_data;", "  ", "    if (smp_command_has_invalid_parameters(p_cb)) {", "     if (p_cb->rcvd_cmd_len < 2) {   ", "       android_errorWriteLog(0x534e4554, \"111936834\");", "     }", "      smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);", "      return;", "    }", "  ", "   p_cb->status = *(uint8_t*)p_data;", " ", "    if (p != NULL) {", "      STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);", "    } else {", "     p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;", "  }", "   p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", "   Image", "     *image;", " ", "   MagickBooleanType", "     status;", " ", "   MagickSizeType", "     number_pixels;", " ", "   MemoryInfo", "     *pixel_info;", " ", "   register Quantum", "     *q;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register unsigned char", "     *p;", " ", "   SGIInfo", "     iris_info;", " ", "   size_t", "     bytes_per_pixel,", "     quantum;", " ", "   ssize_t", "     count,", "     y,", "     z;", " ", "   unsigned char", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   iris_info.magic=ReadBlobMSBShort(image);", "   do", "   {", "      ", "     if (iris_info.magic != 0x01DA)", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     iris_info.storage=(unsigned char) ReadBlobByte(image);", "     switch (iris_info.storage)", "     {", "       case 0x00: image->compression=NoCompression; break;", "       case 0x01: image->compression=RLECompression; break;", "       default:", "         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "     iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);", "     if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     iris_info.dimension=ReadBlobMSBShort(image);", "     iris_info.columns=ReadBlobMSBShort(image);", "     iris_info.rows=ReadBlobMSBShort(image);", "     iris_info.depth=ReadBlobMSBShort(image);", "     if ((iris_info.depth == 0) || (iris_info.depth > 4))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "      iris_info.minimum_value=ReadBlobMSBLong(image);", "      iris_info.maximum_value=ReadBlobMSBLong(image);", "      iris_info.sans=ReadBlobMSBLong(image);", "    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)", "     count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)", "        iris_info.name);", "     if (count != sizeof(iris_info.name))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "      iris_info.name[sizeof(iris_info.name)-1]='\\0';", "      if (*iris_info.name != '\\0')", "        (void) SetImageProperty(image,\"label\",iris_info.name,exception);", "      iris_info.pixel_format=ReadBlobMSBLong(image);", "      if (iris_info.pixel_format != 0)", "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "      count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);", "    (void) count;", "     if (count != sizeof(iris_info.filler))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "      image->columns=iris_info.columns;", "      image->rows=iris_info.rows;", "      image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);", "     if (iris_info.pixel_format == 0)", "       image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,", "         MAGICKCORE_QUANTUM_DEPTH);", "     if (iris_info.depth < 3)", "       {", "          image->storage_class=PseudoClass;", "          image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;", "        }", "    if (EOFBlob(image) != MagickFalse)", "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "    if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))", "     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))", "        if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "          break;", "      status=SetImageExtent(image,image->columns,image->rows,exception);", "     if (status == MagickFalse)", "       return(DestroyImageList(image));", "      ", "     bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;", "     number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;", "     if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)", "         (4*bytes_per_pixel*number_pixels)))", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*", "       bytes_per_pixel*sizeof(*pixels));", "     if (pixel_info == (MemoryInfo *) NULL)", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);", "     if ((int) iris_info.storage != 0x01)", "       {", "         unsigned char", "           *scanline;", " ", "          ", "         scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,", "           bytes_per_pixel*sizeof(*scanline));", "         if (scanline == (unsigned char *) NULL)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         for (z=0; z < (ssize_t) iris_info.depth; z++)", "         {", "           p=pixels+bytes_per_pixel*z;", "           for (y=0; y < (ssize_t) iris_info.rows; y++)", "           {", "             count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);", "             if (EOFBlob(image) != MagickFalse)", "               break;", "             if (bytes_per_pixel == 2)", "               for (x=0; x < (ssize_t) iris_info.columns; x++)", "               {", "                 *p=scanline[2*x];", "                 *(p+1)=scanline[2*x+1];", "                 p+=8;", "               }", "             else", "               for (x=0; x < (ssize_t) iris_info.columns; x++)", "               {", "                 *p=scanline[x];", "                 p+=4;", "               }", "           }", "         }", "         scanline=(unsigned char *) RelinquishMagickMemory(scanline);", "       }", "     else", "       {", "         MemoryInfo", "           *packet_info;", " ", "         size_t", "           *runlength;", " ", "         ssize_t", "           offset,", "           *offsets;", " ", "         unsigned char", "           *packets;", " ", "         unsigned int", "           data_order;", " ", "          ", "         offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,", "           iris_info.depth*sizeof(*offsets));", "         runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,", "           iris_info.depth*sizeof(*runlength));", "         packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*", "           sizeof(*packets));", "         if ((offsets == (ssize_t *) NULL) ||", "             (runlength == (size_t *) NULL) ||", "             (packet_info == (MemoryInfo *) NULL))", "           {", "             if (offsets == (ssize_t *) NULL)", "               offsets=(ssize_t *) RelinquishMagickMemory(offsets);", "             if (runlength == (size_t *) NULL)", "               runlength=(size_t *) RelinquishMagickMemory(runlength);", "             if (packet_info == (MemoryInfo *) NULL)", "               packet_info=RelinquishVirtualMemory(packet_info);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);", "         for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)", "           offsets[i]=ReadBlobMSBSignedLong(image);", "         for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)", "         {", "           runlength[i]=ReadBlobMSBLong(image);", "           if (runlength[i] > (4*(size_t) iris_info.columns+10))", "             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         }", "          ", "         offset=0;", "         data_order=0;", "         for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)", "           for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)", "           {", "             if (offsets[y+z*iris_info.rows] < offset)", "               data_order=1;", "             offset=offsets[y+z*iris_info.rows];", "           }", "         offset=(ssize_t) TellBlob(image);", "         if (data_order == 1)", "           {", "             for (z=0; z < (ssize_t) iris_info.depth; z++)", "             {", "               p=pixels;", "               for (y=0; y < (ssize_t) iris_info.rows; y++)", "               {", "                 if (offset != offsets[y+z*iris_info.rows])", "                   {", "                     offset=offsets[y+z*iris_info.rows];", "                     offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);", "                   }", "                 count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],", "                   packets);", "                 if (EOFBlob(image) != MagickFalse)", "                   break;", "                 offset+=(ssize_t) runlength[y+z*iris_info.rows];", "                 status=SGIDecode(bytes_per_pixel,(ssize_t)", "                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,", "                   1L*iris_info.columns,p+bytes_per_pixel*z);", "                 if (status == MagickFalse)", "                   ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "                 p+=(iris_info.columns*4*bytes_per_pixel);", "               }", "             }", "           }", "         else", "           {", "             MagickOffsetType", "               position;", "            ", "             position=TellBlob(image);", "             p=pixels;", "             for (y=0; y < (ssize_t) iris_info.rows; y++)", "             {", "               for (z=0; z < (ssize_t) iris_info.depth; z++)", "               {", "                 if (offset != offsets[y+z*iris_info.rows])", "                   {", "                     offset=offsets[y+z*iris_info.rows];", "                     offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);", "                   }", "                 count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],", "                   packets);", "                 if (EOFBlob(image) != MagickFalse)", "                   break;", "                 offset+=(ssize_t) runlength[y+z*iris_info.rows];", "                 status=SGIDecode(bytes_per_pixel,(ssize_t)", "                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,", "                   1L*iris_info.columns,p+bytes_per_pixel*z);", "                 if (status == MagickFalse)", "                   ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "               }", "               p+=(iris_info.columns*4*bytes_per_pixel);", "             }", "             offset=(ssize_t) SeekBlob(image,position,SEEK_SET);", "           }", "         packet_info=RelinquishVirtualMemory(packet_info);", "         runlength=(size_t *) RelinquishMagickMemory(runlength);", "         offsets=(ssize_t *) RelinquishMagickMemory(offsets);", "       }", "      ", "     image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : ", "       UndefinedPixelTrait;", "     image->columns=iris_info.columns;", "     image->rows=iris_info.rows;", "      ", "     if (image->storage_class == DirectClass)", "       {", "          ", "         if (bytes_per_pixel == 2)", "           {", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               p=pixels+(image->rows-y-1)*8*image->columns;", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (Quantum *) NULL)", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 SetPixelRed(image,ScaleShortToQuantum((unsigned short)", "                   ((*(p+0) << 8) | (*(p+1)))),q);", "                 SetPixelGreen(image,ScaleShortToQuantum((unsigned short)", "                   ((*(p+2) << 8) | (*(p+3)))),q);", "                 SetPixelBlue(image,ScaleShortToQuantum((unsigned short)", "                   ((*(p+4) << 8) | (*(p+5)))),q);", "                 SetPixelAlpha(image,OpaqueAlpha,q);", "                 if (image->alpha_trait != UndefinedPixelTrait)", "                   SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)", "                     ((*(p+6) << 8) | (*(p+7)))),q);", "                 p+=8;", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "           }", "         else", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             p=pixels+(image->rows-y-1)*4*image->columns;", "             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               SetPixelRed(image,ScaleCharToQuantum(*p),q);", "               SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);", "               SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);", "               SetPixelAlpha(image,OpaqueAlpha,q);", "               if (image->alpha_trait != UndefinedPixelTrait)", "                 SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);", "               p+=4;", "               q+=GetPixelChannels(image);", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                   image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "       }", "     else", "       {", "          ", "         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "          ", "         if (bytes_per_pixel == 2)", "           {", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               p=pixels+(image->rows-y-1)*8*image->columns;", "               q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "               if (q == (Quantum *) NULL)", "                 break;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 quantum=(*p << 8);", "                 quantum|=(*(p+1));", "                 SetPixelIndex(image,(Quantum) quantum,q);", "                 p+=8;", "                 q+=GetPixelChannels(image);", "               }", "               if (SyncAuthenticPixels(image,exception) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "           }", "         else", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             p=pixels+(image->rows-y-1)*4*image->columns;", "             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               SetPixelIndex(image,*p,q);", "               p+=4;", "               q+=GetPixelChannels(image);", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         (void) SyncImage(image,exception);", "       }", "     pixel_info=RelinquishVirtualMemory(pixel_info);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     iris_info.magic=ReadBlobMSBShort(image);", "     if (iris_info.magic == 0x01DA)", "       {", "          ", "         AcquireNextImage(image_info,image,exception);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   } while (iris_info.magic == 0x01DA);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static RList *symbols(RBinFile *bf) {", "RList *res = r_list_newf ((RListFree)r_bin_symbol_free);", "r_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);", "RCoreSymCacheElement *element = bf->o->bin_obj;", "size_t i;", "HtUU *hash = ht_uu_new0 ();", "if (!hash) {", "return res;", "}", "bool found = false;", "for (i = 0; i < element->hdr->n_lined_symbols; i++) {", "RCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];", "ht_uu_find (hash, sym->paddr, &found);", "if (found) {", "continue;", "}", "RBinSymbol *s = bin_symbol_from_symbol (element, sym);", "if (s) {", "r_list_append (res, s);", "ht_uu_insert (hash, sym->paddr, 1);", "}", "}", "if (element->symbols) {", "for (i = 0; i < element->hdr->n_symbols; i++) {", "RCoreSymCacheElementSymbol *sym = &element->symbols[i];", "ht_uu_find (hash, sym->paddr, &found);", "if (found) {", "continue;", "}", "RBinSymbol *s = bin_symbol_from_symbol (element, sym);", "if (s) {", "r_list_append (res, s);", "}", "}", "}", "ht_uu_free (hash);", "return res;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct dst_entry *inet6_csk_route_socket(struct sock *sk,", " \t\t\t\t\t\tstruct flowi6 *fl6)", " {", " \tstruct inet_sock *inet = inet_sk(sk);", " \tstruct ipv6_pinfo *np = inet6_sk(sk);", " \tstruct in6_addr *final_p, final;", " \tstruct dst_entry *dst;", " ", " \tmemset(fl6, 0, sizeof(*fl6));", " \tfl6->flowi6_proto = sk->sk_protocol;", " \tfl6->daddr = sk->sk_v6_daddr;", " \tfl6->saddr = np->saddr;", " \tfl6->flowlabel = np->flow_label;", " \tIP6_ECN_flow_xmit(sk, fl6->flowlabel);", " \tfl6->flowi6_oif = sk->sk_bound_dev_if;", " \tfl6->flowi6_mark = sk->sk_mark;", " \tfl6->fl6_sport = inet->inet_sport;", "  \tfl6->fl6_dport = inet->inet_dport;", "  \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));", "  ", "\tfinal_p = fl6_update_dst(fl6, np->opt, &final);", " \trcu_read_lock();", " \tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);", " \trcu_read_unlock();", "  ", "  \tdst = __inet6_csk_dst_check(sk, np->dst_cookie);", "  \tif (!dst) {", " \t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);", " ", " \t\tif (!IS_ERR(dst))", " \t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);", " \t}", " \treturn dst;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["filter_session_io(struct io *io, int evt, void *arg)", "{", "struct filter_session *fs = arg;", "char *line = NULL;", "ssize_t len;", "", "log_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),", "io_strio(io));", "", "switch (evt) {", "case IO_DATAIN:", "nextline:", "line = io_getline(fs->io, &len);", "", "if (line == NULL)", "return;", "", "filter_data(fs->id, line);", "", "goto nextline;", "", "case IO_DISCONNECTED:", "io_free(fs->io);", "fs->io = NULL;", "break;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static struct dentry *aio_mount(struct file_system_type *fs_type,", " \t\t\t\tint flags, const char *dev_name, void *data)", " {", "  \tstatic const struct dentry_operations ops = {", "  \t\t.d_dname\t= simple_dname,", "  \t};", "\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);", " \tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, &ops,", " \t\t\t\t\t   AIO_RING_MAGIC);", " ", " \tif (!IS_ERR(root))", " \t\troot->d_sb->s_iflags |= SB_I_NOEXEC;", " \treturn root;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" int SSL_library_init(void)", " \t{", " ", " #ifndef OPENSSL_NO_DES", " \tEVP_add_cipher(EVP_des_cbc());", " \tEVP_add_cipher(EVP_des_ede3_cbc());", " #endif", " #ifndef OPENSSL_NO_IDEA", " \tEVP_add_cipher(EVP_idea_cbc());", " #endif", " #ifndef OPENSSL_NO_RC4", " \tEVP_add_cipher(EVP_rc4());", " #if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))", " \tEVP_add_cipher(EVP_rc4_hmac_md5());", " #endif", " #endif  ", " #ifndef OPENSSL_NO_RC2", " \tEVP_add_cipher(EVP_rc2_cbc());", " \t ", " \tEVP_add_cipher(EVP_rc2_40_cbc());", " #endif", " #ifndef OPENSSL_NO_AES", " \tEVP_add_cipher(EVP_aes_128_cbc());", " \tEVP_add_cipher(EVP_aes_192_cbc());", "         EVP_add_cipher(EVP_aes_256_cbc());", "         EVP_add_cipher(EVP_aes_128_gcm());", "         EVP_add_cipher(EVP_aes_256_gcm());", "#if 0  ", "  #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)", "         EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());", "         EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());", "  #endif", "#endif", "  ", "  #endif", "  #ifndef OPENSSL_NO_CAMELLIA", " #endif", " #ifndef OPENSSL_NO_CAMELLIA", " \tEVP_add_cipher(EVP_camellia_128_cbc());", " \tEVP_add_cipher(EVP_camellia_256_cbc());", " #endif", " ", " #ifndef OPENSSL_NO_SEED", " \tEVP_add_cipher(EVP_seed_cbc());", " #endif", "   ", " #ifndef OPENSSL_NO_MD5", " \tEVP_add_digest(EVP_md5());", " \tEVP_add_digest_alias(SN_md5,\"ssl2-md5\");", " \tEVP_add_digest_alias(SN_md5,\"ssl3-md5\");", " #endif", " #ifndef OPENSSL_NO_SHA", " \tEVP_add_digest(EVP_sha1());  ", " \tEVP_add_digest_alias(SN_sha1,\"ssl3-sha1\");", " \tEVP_add_digest_alias(SN_sha1WithRSAEncryption,SN_sha1WithRSA);", " #endif", " #ifndef OPENSSL_NO_SHA256", " \tEVP_add_digest(EVP_sha224());", " \tEVP_add_digest(EVP_sha256());", " #endif", " #ifndef OPENSSL_NO_SHA512", " \tEVP_add_digest(EVP_sha384());", " \tEVP_add_digest(EVP_sha512());", " #endif", " #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)", " \tEVP_add_digest(EVP_dss1());  ", " \tEVP_add_digest_alias(SN_dsaWithSHA1,SN_dsaWithSHA1_2);", " \tEVP_add_digest_alias(SN_dsaWithSHA1,\"DSS1\");", " \tEVP_add_digest_alias(SN_dsaWithSHA1,\"dss1\");", " #endif", " #ifndef OPENSSL_NO_ECDSA", " \tEVP_add_digest(EVP_ecdsa());", " #endif", " \t ", " #if 0", " \tEVP_add_digest(EVP_sha());", " \tEVP_add_digest(EVP_dss());", " #endif", " #ifndef OPENSSL_NO_COMP", " \t ", " \t(void)SSL_COMP_get_compression_methods();", " #endif", " \t ", " \tssl_load_ciphers();", " \treturn(1);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHP_METHOD(Phar, unlinkArchive)", " {", " \tchar *fname, *error, *zname, *arch, *entry;", " \tsize_t fname_len;", "         int zname_len, arch_len, entry_len;", "         phar_archive_data *phar;", "  ", "       if (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {", "        if (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {", "                 RETURN_FALSE;", "         }", "  ", " \tif (!fname_len) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"\\\"\");", " \t\treturn;", " \t}", " ", " \tif (FAILURE == phar_open_from_filename(fname, fname_len, NULL, 0, REPORT_ERRORS, &phar, &error)) {", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\": %s\", fname, error);", " \t\t\tefree(error);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"Unknown phar archive \\\"%s\\\"\", fname);", " \t\t}", " \t\treturn;", " \t}", " ", " \tzname = (char*)zend_get_executed_filename();", " \tzname_len = strlen(zname);", " ", " \tif (zname_len > 7 && !memcmp(zname, \"phar:\", 7) && SUCCESS == phar_split_fname(zname, zname_len, &arch, &arch_len, &entry, &entry_len, 2, 0)) {", " \t\tif (arch_len == fname_len && !memcmp(arch, fname, arch_len)) {", " \t\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" cannot be unlinked from within itself\", fname);", " \t\t\tefree(arch);", " \t\t\tefree(entry);", " \t\t\treturn;", " \t\t}", " \t\tefree(arch);", " \t\tefree(entry);", " \t}", " ", " \tif (phar->is_persistent) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" is in phar.cache_list, cannot unlinkArchive()\", fname);", " \t\treturn;", " \t}", " ", " \tif (phar->refcount) {", " \t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"phar archive \\\"%s\\\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\", fname);", " \t\treturn;", " \t}", " ", " \tfname = estrndup(phar->fname, phar->fname_len);", " ", " \t ", " \tPHAR_G(last_phar) = NULL;", " \tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;", " ", " \tphar_archive_delref(phar);", " \tunlink(fname);", " \tefree(fname);", " \tRETURN_TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static char *__filterShell(const char *arg) {", " \tr_return_val_if_fail (arg, NULL);", " \tchar *a = malloc (strlen (arg) + 1);", " \tif (!a) {", " \t\treturn NULL;", "  \t}", "  \tchar *b = a;", "  \twhile (*arg) {", "\t\tswitch (*arg) {", " \t\tchar ch = *arg;", " \t\tswitch (ch) {", "  \t\tcase '@':", "  \t\tcase '`':", "  \t\tcase '|':", "  \t\tcase ';':", " \t\tcase '=':", "  \t\tcase '\\n':", "  \t\t\tbreak;", "  \t\tdefault:", "\t\t\t*b++ = *arg;", " \t\t\t*b++ = ch;", "  \t\t\tbreak;", "  \t\t}", "  \t\targ++;", " \t}", " \t*b = 0;", " \treturn a;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char ** argv)", " {", " \tint c;", " \tunsigned long flags = MS_MANDLOCK;", " \tchar * orgoptions = NULL;", " \tchar * share_name = NULL;", " \tconst char * ipaddr = NULL;", " \tchar * uuid = NULL;", " \tchar * mountpoint = NULL;", " \tchar * options = NULL;", " \tchar * optionstail;", " \tchar * resolved_path = NULL;", " \tchar * temp;", " \tchar * dev_name;", " \tint rc = 0;", " \tint rsize = 0;", " \tint wsize = 0;", " \tint nomtab = 0;", " \tint uid = 0;", " \tint gid = 0;", " \tint optlen = 0;", " \tint orgoptlen = 0;", " \tsize_t options_size = 0;", " \tsize_t current_len;", " \tint retry = 0;  ", " \tstruct addrinfo *addrhead = NULL, *addr;", " \tstruct utsname sysinfo;", " \tstruct mntent mountent;", " \tstruct sockaddr_in *addr4;", " \tstruct sockaddr_in6 *addr6;", " \tFILE * pmntfile;", " ", " \t ", " ", " \tif(argc && argv)", " \t\tthisprogram = argv[0];", " \telse", " \t\tmount_cifs_usage(stderr);", " ", " \tif(thisprogram == NULL)", " \t\tthisprogram = \"mount.cifs\";", " ", " \tuname(&sysinfo);", " \t ", " ", "  ", " \tif(argc > 2) {", " \t\tdev_name = argv[1];", " \t\tshare_name = strndup(argv[1], MAX_UNC_LEN);", " \t\tif (share_name == NULL) {", " \t\t\tfprintf(stderr, \"%s: %s\", argv[0], strerror(ENOMEM));", " \t\t\texit(EX_SYSERR);", " \t\t}", " \t\tmountpoint = argv[2];", " \t} else if (argc == 2) {", " \t\tif ((strcmp(argv[1], \"-V\") == 0) ||", " \t\t    (strcmp(argv[1], \"--version\") == 0))", " \t\t{", " \t\t\tprint_cifs_mount_version();", " \t\t\texit(0);", " \t\t}", " ", " \t\tif ((strcmp(argv[1], \"-h\") == 0) ||", " \t\t    (strcmp(argv[1], \"-?\") == 0) ||", " \t\t    (strcmp(argv[1], \"--help\") == 0))", " \t\t\tmount_cifs_usage(stdout);", " ", " \t\tmount_cifs_usage(stderr);", " \t} else {", " \t\tmount_cifs_usage(stderr);", " \t}", " ", " ", " \t ", " \twhile ((c = getopt_long (argc, argv, \"afFhilL:no:O:rsSU:vVwt:\",", " \t\t\t longopts, NULL)) != -1) {", " \t\tswitch (c) {", "  ", "  ", "  ", " ", " \t\tcase '?':", " \t\tcase 'h':\t  ", " \t\t\tmount_cifs_usage(stdout);", " \t\tcase 'n':", " \t\t\t++nomtab;", " \t\t\tbreak;", " \t\tcase 'b':", " #ifdef MS_BIND", " \t\t\tflags |= MS_BIND;", " #else", " \t\t\tfprintf(stderr,", " \t\t\t\t\"option 'b' (MS_BIND) not supported\\n\");", " #endif", " \t\t\tbreak;", " \t\tcase 'm':", " #ifdef MS_MOVE\t\t      ", " \t\t\tflags |= MS_MOVE;", " #else", " \t\t\tfprintf(stderr,", " \t\t\t\t\"option 'm' (MS_MOVE) not supported\\n\");", " #endif", " \t\t\tbreak;", " \t\tcase 'o':", " \t\t\torgoptions = strdup(optarg);", " \t\t    break;", " \t\tcase 'r':   ", " \t\t\tflags |= MS_RDONLY;", " \t\t\tbreak;", " \t\tcase 'U':", " \t\t\tuuid = optarg;", " \t\t\tbreak;", " \t\tcase 'v':", " \t\t\t++verboseflag;", " \t\t\tbreak;", " \t\tcase 'V':", " \t\t\tprint_cifs_mount_version();", " \t\t\texit (0);", " \t\tcase 'w':", " \t\t\tflags &= ~MS_RDONLY;", " \t\t\tbreak;", " \t\tcase 'R':", " \t\t\trsize = atoi(optarg) ;", " \t\t\tbreak;", " \t\tcase 'W':", " \t\t\twsize = atoi(optarg);", " \t\t\tbreak;", " \t\tcase '1':", " \t\t\tif (isdigit(*optarg)) {", " \t\t\t\tchar *ep;", " ", " \t\t\t\tuid = strtoul(optarg, &ep, 10);", " \t\t\t\tif (*ep) {", " \t\t\t\t\tfprintf(stderr, \"bad uid value \\\"%s\\\"\\n\", optarg);", " \t\t\t\t\texit(EX_USAGE);", " \t\t\t\t}", " \t\t\t} else {", " \t\t\t\tstruct passwd *pw;", " ", " \t\t\t\tif (!(pw = getpwnam(optarg))) {", " \t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);", " \t\t\t\t\texit(EX_USAGE);", " \t\t\t\t}", " \t\t\t\tuid = pw->pw_uid;", " \t\t\t\tendpwent();", " \t\t\t}", " \t\t\tbreak;", " \t\tcase '2':", " \t\t\tif (isdigit(*optarg)) {", " \t\t\t\tchar *ep;", " ", " \t\t\t\tgid = strtoul(optarg, &ep, 10);", " \t\t\t\tif (*ep) {", " \t\t\t\t\tfprintf(stderr, \"bad gid value \\\"%s\\\"\\n\", optarg);", " \t\t\t\t\texit(EX_USAGE);", " \t\t\t\t}", " \t\t\t} else {", " \t\t\t\tstruct group *gr;", " ", " \t\t\t\tif (!(gr = getgrnam(optarg))) {", " \t\t\t\t\tfprintf(stderr, \"bad user name \\\"%s\\\"\\n\", optarg);", " \t\t\t\t\texit(EX_USAGE);", " \t\t\t\t}", " \t\t\t\tgid = gr->gr_gid;", " \t\t\t\tendpwent();", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'u':", " \t\t\tgot_user = 1;", " \t\t\tuser_name = optarg;", " \t\t\tbreak;", " \t\tcase 'd':", " \t\t\tdomain_name = optarg;  ", " \t\t\tgot_domain = 1;", " \t\t\tbreak;", " \t\tcase 'p':", " \t\t\tif(mountpassword == NULL)", " \t\t\t\tmountpassword = (char *)calloc(MOUNT_PASSWD_SIZE+1,1);", " \t\t\tif(mountpassword) {", " \t\t\t\tgot_password = 1;", " \t\t\t\tstrlcpy(mountpassword,optarg,MOUNT_PASSWD_SIZE+1);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 'S':", " \t\t\tget_password_from_file(0  ,NULL);", " \t\t\tbreak;", " \t\tcase 't':", " \t\t\tbreak;", " \t\tcase 'f':", " \t\t\t++fakemnt;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tfprintf(stderr, \"unknown mount option %c\\n\",c);", " \t\t\tmount_cifs_usage(stderr);", " \t\t}", " \t}", " ", " \tif((argc < 3) || (dev_name == NULL) || (mountpoint == NULL)) {", " \t\tmount_cifs_usage(stderr);", "         }", "  ", "          ", "        rc = chdir(mountpoint);", "        if (rc) {", "                fprintf(stderr, \"Couldn't chdir to %s: %s\\n\", mountpoint,", "                                strerror(errno));", "                rc = EX_USAGE;", "                goto mount_exit;", "        }", " ", "         rc = check_mountpoint(thisprogram, mountpoint);", "         if (rc)", "                 goto mount_exit;", " \t\t ", " \t\tflags |= CIFS_SETUID_FLAGS;", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int persistent_prepare_exception(struct dm_exception_store *store,", "  \t\t\t\t\tstruct dm_exception *e)", "  {", "  \tstruct pstore *ps = get_info(store);", "\tuint32_t stride;", "\tchunk_t next_free;", "  \tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);", "  ", "  \t ", " \tif (size < ((ps->next_free + 1) * store->chunk_size))", " \t\treturn -ENOSPC;", " ", " \te->new_chunk = ps->next_free;", " ", " \t ", "\tstride = (ps->exceptions_per_area + 1);", "\tnext_free = ++ps->next_free;", "\tif (sector_div(next_free, stride) == 1)", "\t\tps->next_free++;", " \tps->next_free++;", " \tskip_metadata(ps);", "  ", "  \tatomic_inc(&ps->pending_count);", "  \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,", "         const char *funcname, const int line, const char *file)", " {", "     u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);", " ", "     if (pktdata) {", "         if (pkthdr->len > MAXPACKET) {", "             fprintf(stderr, \"safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",", "                     file, funcname, line, pkthdr->len, MAXPACKET);", "              exit(-1);", "          }", "  ", "        if (pkthdr->len < pkthdr->caplen) {", "            fprintf(stderr, \"safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",", "         if (!pkthdr->len || pkthdr->len < pkthdr->caplen) {", "             fprintf(stderr, \"safe_pcap_next ERROR: Invalid packet length in %s:%s() line %d: packet length=%u capture length=%u\\n\",", "                      file, funcname, line, pkthdr->len, pkthdr->caplen);", "              exit(-1);", "          }", "     }", " ", "     return pktdata;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)", " void BlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)", "  {", "      if (origin && BlobURL::getOrigin(url) == \"null\")", "          originMap()->add(url.string(), origin);", "  ", "    if (isMainThread())", "        blobRegistry().registerBlobURL(url, srcURL);", "    else {", "     if (isMainThread()) {", "         if (WebBlobRegistry* registry = blobRegistry())", "             registry->registerBlobURL(url, srcURL);", "     } else {", "          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));", "          callOnMainThread(&registerBlobURLFromTask, context.leakPtr());", "      }", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["enum sctp_disposition sctp_sf_shutdown_pending_abort(", "struct net *net,", "const struct sctp_endpoint *ep,", "const struct sctp_association *asoc,", "const union sctp_subtype type,", "void *arg,", "struct sctp_cmd_seq *commands)", "{", "struct sctp_chunk *chunk = arg;", "", "if (!sctp_vtag_verify_either(chunk, asoc))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "", "", "", "", "", "", "", "", "", "", "if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "", "", "", "", "", "if (SCTP_ADDR_DEL ==", "sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))", "return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);", "", "if (!sctp_err_chunk_valid(chunk))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "return __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int kvm_ioctl_create_device(struct kvm *kvm,", " \t\t\t\t   struct kvm_create_device *cd)", " {", " \tstruct kvm_device_ops *ops = NULL;", " \tstruct kvm_device *dev;", " \tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;", " \tint ret;", " ", " \tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))", " \t\treturn -ENODEV;", " ", " \tops = kvm_device_ops_table[cd->type];", " \tif (ops == NULL)", " \t\treturn -ENODEV;", " ", " \tif (test)", " \t\treturn 0;", " ", " \tdev = kzalloc(sizeof(*dev), GFP_KERNEL);", " \tif (!dev)", " \t\treturn -ENOMEM;", " ", " \tdev->ops = ops;", " \tdev->kvm = kvm;", " ", " \tmutex_lock(&kvm->lock);", " \tret = ops->create(dev, cd->type);", " \tif (ret < 0) {", " \t\tmutex_unlock(&kvm->lock);", " \t\tkfree(dev);", " \t\treturn ret;", " \t}", " \tlist_add(&dev->vm_node, &kvm->devices);", " \tmutex_unlock(&kvm->lock);", " ", " \tif (ops->init)", " \t\tops->init(dev);", "  ", "  \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);", "  \tif (ret < 0) {", "\t\tops->destroy(dev);", "  \t\tmutex_lock(&kvm->lock);", "  \t\tlist_del(&dev->vm_node);", "  \t\tmutex_unlock(&kvm->lock);", " \t\tops->destroy(dev);", "  \t\treturn ret;", "  \t}", "  ", " \tkvm_get_kvm(kvm);", " \tcd->fd = ret;", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void FrameSelection::DocumentAttached(Document* document) {", "    DCHECK(document);", "  use_secure_keyboard_entry_when_active_ = false;", "    selection_editor_->DocumentAttached(document);", "    SetContext(document);", "  }"], "ner_tags": [0, 0, 1, 0, 0, 0]}
{"tokens": [" bool FileBrowserPrivateGetShareUrlFunction::RunAsync() {", "   using extensions::api::file_browser_private::GetShareUrl::Params;", "   const scoped_ptr<Params> params(Params::Create(*args_));", "   EXTENSION_FUNCTION_VALIDATE(params);", " ", "   const base::FilePath path = file_manager::util::GetLocalPathFromURL(", "       render_view_host(), GetProfile(), GURL(params->url));", "   DCHECK(drive::util::IsUnderDriveMountPoint(path));", " ", "   const base::FilePath drive_path = drive::util::ExtractDrivePath(path);", " ", "   drive::FileSystemInterface* const file_system =", "       drive::util::GetFileSystemByProfile(GetProfile());", "   if (!file_system) {", "     return false;", "   }", "  ", "    file_system->GetShareUrl(", "        drive_path,", "      file_manager::util::GetFileManagerBaseUrl(),   ", "       GURL(\"chrome-extension:\" + extension_id()),   ", "        base::Bind(&FileBrowserPrivateGetShareUrlFunction::OnGetShareUrl, this));", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" status_t MPEG4Source::read(", "  MediaBuffer **out, const ReadOptions *options) {", "  Mutex::Autolock autoLock(mLock);", " ", "     CHECK(mStarted);", " ", "  if (mFirstMoofOffset > 0) {", "  return fragmentedRead(out, options);", "  }", " ", "  *out = NULL;", " ", "  int64_t targetSampleTimeUs = -1;", " ", "  int64_t seekTimeUs;", "  ReadOptions::SeekMode mode;", "  if (options && options->getSeekTo(&seekTimeUs, &mode)) {", "  uint32_t findFlags = 0;", "  switch (mode) {", "  case ReadOptions::SEEK_PREVIOUS_SYNC:", "                 findFlags = SampleTable::kFlagBefore;", "  break;", "  case ReadOptions::SEEK_NEXT_SYNC:", "                 findFlags = SampleTable::kFlagAfter;", "  break;", "  case ReadOptions::SEEK_CLOSEST_SYNC:", "  case ReadOptions::SEEK_CLOSEST:", "                 findFlags = SampleTable::kFlagClosest;", "  break;", "  default:", "                 CHECK(!\"Should not be here.\");", "  break;", "  }", " ", "  uint32_t sampleIndex;", "  status_t err = mSampleTable->findSampleAtTime(", "                 seekTimeUs, 1000000, mTimescale,", "  &sampleIndex, findFlags);", " ", "  if (mode == ReadOptions::SEEK_CLOSEST) {", "             findFlags = SampleTable::kFlagBefore;", "  }", " ", "  uint32_t syncSampleIndex;", "  if (err == OK) {", "             err = mSampleTable->findSyncSampleNear(", "                     sampleIndex, &syncSampleIndex, findFlags);", "  }", " ", "  uint32_t sampleTime;", "  if (err == OK) {", "             err = mSampleTable->getMetaDataForSample(", "                     sampleIndex, NULL, NULL, &sampleTime);", "  }", " ", "  if (err != OK) {", "  if (err == ERROR_OUT_OF_RANGE) {", "                 err = ERROR_END_OF_STREAM;", "  }", "             ALOGV(\"end of stream\");", "  return err;", "  }", " ", "  if (mode == ReadOptions::SEEK_CLOSEST) {", "             targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;", "  }", " ", " #if 0", "  uint32_t syncSampleTime;", "         CHECK_EQ(OK, mSampleTable->getMetaDataForSample(", "                     syncSampleIndex, NULL, NULL, &syncSampleTime));", " ", "         ALOGI(\"seek to time %lld us => sample at time %lld us, \"", "  \"sync sample at time %lld us\",", "              seekTimeUs,", "              sampleTime * 1000000ll / mTimescale,", "              syncSampleTime * 1000000ll / mTimescale);", " #endif", " ", "         mCurrentSampleIndex = syncSampleIndex;", "  if (mBuffer != NULL) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  }", " ", "  off64_t offset;", "  size_t size;", "  uint32_t cts, stts;", "  bool isSyncSample;", "  bool newBuffer = false;", "  if (mBuffer == NULL) {", "         newBuffer = true;", " ", "  status_t err =", "             mSampleTable->getMetaDataForSample(", "                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         err = mGroup->acquire_buffer(&mBuffer);", " ", "  if (err != OK) {", "             CHECK(mBuffer == NULL);", "  return err;", "  }", "  if (size > mBuffer->size()) {", "             ALOGE(\"buffer too small: %zu > %zu\", size, mBuffer->size());", "  return ERROR_BUFFER_TOO_SMALL;", "  }", "  }", " ", "  if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {", "  if (newBuffer) {", "  ssize_t num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);", " ", "  if (num_bytes_read < (ssize_t)size) {", "                 mBuffer->release();", "                 mBuffer = NULL;", " ", "  return ERROR_IO;", "  }", " ", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", "             mBuffer->meta_data()->clear();", "             mBuffer->meta_data()->setInt64(", "                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "             mBuffer->meta_data()->setInt64(", "                     kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "                 mBuffer->meta_data()->setInt64(", "                         kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", "  }", " ", "  if (!mIsAVC && !mIsHEVC) {", "  *out = mBuffer;", "             mBuffer = NULL;", " ", "  return OK;", "  }", " ", " ", "         CHECK(mBuffer->range_length() >= mNALLengthSize);", " ", "  const uint8_t *src =", "  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();", " ", "  size_t nal_size = parseNALSize(src);", "  if (mNALLengthSize > SIZE_MAX - nal_size) {", "             ALOGE(\"b/24441553, b/24445122\");", "  }", "  if (mBuffer->range_length() - mNALLengthSize < nal_size) {", "             ALOGE(\"incomplete NAL unit.\");", " ", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_MALFORMED;", "  }", " ", "  MediaBuffer *clone = mBuffer->clone();", "         CHECK(clone != NULL);", "         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);", " ", "         CHECK(mBuffer != NULL);", "         mBuffer->set_range(", "                 mBuffer->range_offset() + mNALLengthSize + nal_size,", "                 mBuffer->range_length() - mNALLengthSize - nal_size);", " ", "  if (mBuffer->range_length() == 0) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  *out = clone;", " ", "  return OK;", "  } else {", "  ssize_t num_bytes_read = 0;", "  int32_t drm = 0;", "  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);", "  if (usesDRM) {", "             num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);", "  } else {", "             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);", "  }", " ", "  if (num_bytes_read < (ssize_t)size) {", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_IO;", "  }", " ", "  if (usesDRM) {", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", " ", "  } else {", "  uint8_t *dstData = (uint8_t *)mBuffer->data();", "  size_t srcOffset = 0;", "  size_t dstOffset = 0;", " ", "  while (srcOffset < size) {", "  bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);", "  size_t nalLength = 0;", "  if (!isMalFormed) {", "                     nalLength = parseNALSize(&mSrcBuffer[srcOffset]);", "                     srcOffset += mNALLengthSize;", "                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);", "  }", " ", "  if (isMalFormed) {", "                     ALOGE(\"Video is malformed\");", "                     mBuffer->release();", "                     mBuffer = NULL;", "  return ERROR_MALFORMED;", "  }", " ", "  if (nalLength == 0) {", " ", "                      continue;", "                  }", "  ", "                CHECK(dstOffset + 4 <= mBuffer->size());", "                 if (dstOffset > SIZE_MAX - 4 ||", "                         dstOffset + 4 > SIZE_MAX - nalLength ||", "                         dstOffset + 4 + nalLength > mBuffer->size()) {", "                     ALOGE(\"b/27208621 : %zu %zu\", dstOffset, mBuffer->size());", "                     android_errorWriteLog(0x534e4554, \"27208621\");", "                     mBuffer->release();", "                     mBuffer = NULL;", "                     return ERROR_MALFORMED;", "                 }", "  ", "                  dstData[dstOffset++] = 0;", "                  dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 1;", "                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);", "                 srcOffset += nalLength;", "                 dstOffset += nalLength;", "  }", "             CHECK_EQ(srcOffset, size);", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, dstOffset);", "  }", " ", "         mBuffer->meta_data()->clear();", "         mBuffer->meta_data()->setInt64(", "                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "         mBuffer->meta_data()->setInt64(", "                 kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "             mBuffer->meta_data()->setInt64(", "                     kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", " ", "  *out = mBuffer;", "         mBuffer = NULL;", " ", "  return OK;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void RemoteFrame::ScheduleNavigation(Document& origin_document,", "                                       const KURL& url,", "                                       WebFrameLoadType frame_load_type,", "                                       UserGestureStatus user_gesture_status) {", "   if (!origin_document.GetSecurityOrigin()->CanDisplay(url)) {", "     origin_document.AddConsoleMessage(ConsoleMessage::Create(", "         kSecurityMessageSource, kErrorMessageLevel,", "         \"Not allowed to load local resource: \" + url.ElidedString()));", "     return;", "   }", " ", "    FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));", "    frame_request.GetResourceRequest().SetHasUserGesture(", "        user_gesture_status == UserGestureStatus::kActive);", "   frame_request.GetResourceRequest().SetFrameType(", "       IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel", "                     : network::mojom::RequestContextFrameType::kNested);", "   Navigate(frame_request, frame_load_type);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,", " \t\t\t\t    struct nlattr **attrs)", " {", " \tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];", " \tstruct tipc_link_info link_info;", " \tint err;", " ", " \tif (!attrs[TIPC_NLA_LINK])", " \t\treturn -EINVAL;", " ", " \terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],", " \t\t\t       NULL);", " \tif (err)", " \t\treturn err;", "  ", "  \tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);", "  \tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));", "\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));", " \tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),", " \t\t    TIPC_MAX_LINK_NAME);", "  ", "  \treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,", "  \t\t\t    &link_info, sizeof(link_info));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["  ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {", "  \tint i;", "  ", "\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)", " \tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {", "  \t\treturn 0;", "\tfor (i = 0; i < bin->nsegs; ++i)", "\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)", " \t}", " \tfor (i = 0; i < bin->nsegs; ++i) {", " \t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {", "  \t\t\treturn bin->segs[i].vmaddr;", " \t\t}", " \t}", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0]}
{"tokens": [" int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)", " {", " \tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;", " \tstruct inet_sock *inet = inet_sk(sk);", " \tstruct dccp_sock *dp = dccp_sk(sk);", " \t__be16 orig_sport, orig_dport;", " \t__be32 daddr, nexthop;", "  \tstruct flowi4 fl4;", "  \tstruct rtable *rt;", "  \tint err;", " \tstruct ip_options_rcu *inet_opt;", "  ", "  \tdp->dccps_role = DCCP_ROLE_CLIENT;", "  ", " \tif (addr_len < sizeof(struct sockaddr_in))", " \t\treturn -EINVAL;", " ", " \tif (usin->sin_family != AF_INET)", "  \t\treturn -EAFNOSUPPORT;", "  ", "  \tnexthop = daddr = usin->sin_addr.s_addr;", "\tif (inet->opt != NULL && inet->opt->srr) {", " ", " \tinet_opt = rcu_dereference_protected(inet->inet_opt,", " \t\t\t\t\t     sock_owned_by_user(sk));", " \tif (inet_opt != NULL && inet_opt->opt.srr) {", "  \t\tif (daddr == 0)", "  \t\t\treturn -EINVAL;", "\t\tnexthop = inet->opt->faddr;", " \t\tnexthop = inet_opt->opt.faddr;", "  \t}", "  ", "  \torig_sport = inet->inet_sport;", " \torig_dport = usin->sin_port;", " \trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,", " \t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,", " \t\t\t      IPPROTO_DCCP,", " \t\t\t      orig_sport, orig_dport, sk, true);", " \tif (IS_ERR(rt))", " \t\treturn PTR_ERR(rt);", " ", " \tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {", " \t\tip_rt_put(rt);", "  \t\treturn -ENETUNREACH;", "  \t}", "  ", "\tif (inet->opt == NULL || !inet->opt->srr)", " \tif (inet_opt == NULL || !inet_opt->opt.srr)", "  \t\tdaddr = rt->rt_dst;", "  ", "  \tif (inet->inet_saddr == 0)", " \t\tinet->inet_saddr = rt->rt_src;", " \tinet->inet_rcv_saddr = inet->inet_saddr;", " ", " \tinet->inet_dport = usin->sin_port;", "  \tinet->inet_daddr = daddr;", "  ", "  \tinet_csk(sk)->icsk_ext_hdr_len = 0;", "\tif (inet->opt != NULL)", "\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;", " \tif (inet_opt)", " \t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;", "  \t ", " \tdccp_set_state(sk, DCCP_REQUESTING);", " \terr = inet_hash_connect(&dccp_death_row, sk);", " \tif (err != 0)", " \t\tgoto failure;", " ", " \trt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,", " \t\t\t       inet->inet_sport, inet->inet_dport, sk);", " \tif (IS_ERR(rt)) {", " \t\trt = NULL;", " \t\tgoto failure;", " \t}", " \t ", " \tsk_setup_caps(sk, &rt->dst);", " ", " \tdp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,", " \t\t\t\t\t\t    inet->inet_daddr,", " \t\t\t\t\t\t    inet->inet_sport,", " \t\t\t\t\t\t    inet->inet_dport);", " \tinet->inet_id = dp->dccps_iss ^ jiffies;", " ", " \terr = dccp_connect(sk);", " \trt = NULL;", " \tif (err != 0)", " \t\tgoto failure;", " out:", " \treturn err;", " failure:", " \t ", " \tdccp_set_state(sk, DCCP_CLOSED);", " \tip_rt_put(rt);", " \tsk->sk_route_caps = 0;", " \tinet->inet_dport = 0;", " \tgoto out;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["rrd_info_t *rrd_graph_v(", "int argc,", "char **argv)", "{", "image_desc_t im;", "rrd_info_t *grinfo;", "char *old_locale;", "rrd_graph_init(&im);", "", "old_locale = setlocale(LC_NUMERIC, \"C\");", "rrd_graph_options(argc, argv, &im);", "if (rrd_test_error()) {", "rrd_info_free(im.grinfo);", "im_free(&im);", "return NULL;", "}", "", "if (optind >= argc) {", "rrd_info_free(im.grinfo);", "im_free(&im);", "rrd_set_error(\"missing filename\");", "return NULL;", "}", "", "if (strlen(argv[optind]) >= MAXPATH) {", "rrd_set_error(\"filename (including path) too long\");", "rrd_info_free(im.grinfo);", "im_free(&im);", "return NULL;", "}", "", "strncpy(im.graphfile, argv[optind], MAXPATH - 1);", "im.graphfile[MAXPATH - 1] = '\\0';", "", "if (strcmp(im.graphfile, \"-\") == 0) {", "im.graphfile[0] = '\\0';", "}", "", "rrd_graph_script(argc, argv, &im, 1);", "setlocale(LC_NUMERIC, old_locale);", "", "if (rrd_test_error()) {", "rrd_info_free(im.grinfo);", "im_free(&im);", "return NULL;", "}", "", "", "", "if (graph_paint(&im) == -1) {", "rrd_info_free(im.grinfo);", "im_free(&im);", "return NULL;", "}", "", "", "", "", "", "", "if (im.imginfo) {", "rrd_infoval_t info;", "char     *path;", "char     *filename;", "", "if (bad_format_imginfo(im.imginfo)) {", "rrd_info_free(im.grinfo);", "im_free(&im);", "rrd_set_error(\"bad format for imginfo\");", "return NULL;", "}", "path = strdup(im.graphfile);", "filename = basename(path);", "info.u_str =", "sprintf_alloc(im.imginfo,", "filename,", "(long) (im.zoom *", "im.ximg), (long) (im.zoom * im.yimg));", "grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);", "free(info.u_str);", "free(path);", "}", "if (im.rendered_image) {", "rrd_infoval_t img;", "", "img.u_blo.size = im.rendered_image_size;", "img.u_blo.ptr = im.rendered_image;", "grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);", "}", "grinfo = im.grinfo;", "im_free(&im);", "return grinfo;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" error::Error GLES2DecoderImpl::HandleDrawElements(", "     uint32 immediate_data_size, const gles2::DrawElements& c) {", "   if (!bound_element_array_buffer_ ||", "       bound_element_array_buffer_->IsDeleted()) {", "     SetGLError(GL_INVALID_OPERATION,", "                \"glDrawElements: No element array buffer bound\");", "     return error::kNoError;", "   }", " ", "   GLenum mode = c.mode;", "   GLsizei count = c.count;", "   GLenum type = c.type;", "   int32 offset = c.index_offset;", "   if (count < 0) {", "     SetGLError(GL_INVALID_VALUE, \"glDrawElements: count < 0\");", "     return error::kNoError;", "   }", "   if (offset < 0) {", "     SetGLError(GL_INVALID_VALUE, \"glDrawElements: offset < 0\");", "     return error::kNoError;", "   }", "   if (!validators_->draw_mode.IsValid(mode)) {", "     SetGLError(GL_INVALID_ENUM, \"glDrawElements: mode GL_INVALID_ENUM\");", "     return error::kNoError;", "   }", "   if (!validators_->index_type.IsValid(type)) {", "     SetGLError(GL_INVALID_ENUM, \"glDrawElements: type GL_INVALID_ENUM\");", "     return error::kNoError;", "   }", " ", "   if (!CheckFramebufferComplete(\"glDrawElements\")) {", "     return error::kNoError;", "   }", " ", "   if (count == 0) {", "     return error::kNoError;", "   }", " ", "   GLuint max_vertex_accessed;", "   if (!bound_element_array_buffer_->GetMaxValueForRange(", "       offset, count, type, &max_vertex_accessed)) {", "     SetGLError(GL_INVALID_OPERATION,", "                \"glDrawElements: range out of bounds for buffer\");", "     return error::kNoError;", "    }", "  ", "    if (IsDrawValid(max_vertex_accessed)) {", "    bool simulated_attrib_0 = SimulateAttrib0(max_vertex_accessed);", "     bool simulated_attrib_0 = false;", "     if (!SimulateAttrib0(max_vertex_accessed, &simulated_attrib_0)) {", "       return error::kNoError;", "     }", "      bool simulated_fixed_attribs = false;", "      if (SimulateFixedAttribs(max_vertex_accessed, &simulated_fixed_attribs)) {", "        bool textures_set = SetBlackTextureForNonRenderableTextures();", "       ApplyDirtyState();", "       const GLvoid* indices = reinterpret_cast<const GLvoid*>(offset);", "       glDrawElements(mode, count, type, indices);", "       if (textures_set) {", "         RestoreStateForNonRenderableTextures();", "       }", "       if (simulated_fixed_attribs) {", "         RestoreStateForSimulatedFixedAttribs();", "       }", "     }", "     if (simulated_attrib_0) {", "       RestoreStateForSimulatedAttrib0();", "     }", "     if (WasContextLost()) {", "       LOG(ERROR) << \"  GLES2DecoderImpl: Context lost during DrawElements.\";", "       return error::kLostContext;", "     }", "   }", "   return error::kNoError;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void coroutine_fn v9fs_write(void *opaque)", " {", "     ssize_t err;", "     int32_t fid;", "     uint64_t off;", "     uint32_t count;", "     int32_t len = 0;", "     int32_t total = 0;", "     size_t offset = 7;", "     V9fsFidState *fidp;", "     V9fsPDU *pdu = opaque;", "     V9fsState *s = pdu->s;", "     QEMUIOVector qiov_full;", "     QEMUIOVector qiov;", " ", "     err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);", "     if (err < 0) {", "         pdu_complete(pdu, err);", "         return;", "     }", "     offset += err;", "     v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);", "     trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);", " ", "     fidp = get_fid(pdu, fid);", "     if (fidp == NULL) {", "         err = -EINVAL;", "         goto out_nofid;", "     }", "     if (fidp->fid_type == P9_FID_FILE) {", "         if (fidp->fs.fd == -1) {", "             err = -EINVAL;", "             goto out;", "         }", "     } else if (fidp->fid_type == P9_FID_XATTR) {", "          ", "         err = v9fs_xattr_write(s, pdu, fidp, off, count,", "                                qiov_full.iov, qiov_full.niov);", "         goto out;", "     } else {", "         err = -EINVAL;", "         goto out;", "     }", "     qemu_iovec_init(&qiov, qiov_full.niov);", "     do {", "         qemu_iovec_reset(&qiov);", "         qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);", "         if (0) {", "             print_sg(qiov.iov, qiov.niov);", "         }", "          ", "         do {", "             len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);", "             if (len >= 0) {", "                 off   += len;", "                 total += len;", "             }", "         } while (len == -EINTR && !pdu->cancelled);", "         if (len < 0) {", "              ", "             err = len;", "             goto out_qiov;", "         }", "     } while (total < count && len > 0);", " ", "      offset = 7;", "      err = pdu_marshal(pdu, offset, \"d\", total);", "      if (err < 0) {", "        goto out;", "         goto out_qiov;", "      }", "      err += offset;", "      trace_v9fs_write_return(pdu->tag, pdu->id, total, err);", " out_qiov:", "     qemu_iovec_destroy(&qiov);", " out:", "     put_fid(pdu, fidp);", " out_nofid:", "     qemu_iovec_destroy(&qiov_full);", "     pdu_complete(pdu, err);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["auto decode = [&](const int64 begin, const int64 end) {", "for (int b = begin; b < end; ++b) {", "sequences[b].resize(1);", "auto &sequence = sequences[b][0];", "int prev_indices = -1;", "for (int t = 0; t < seq_len_t(b); ++t) {", "int max_class_indices;", "log_prob_t(b, 0) +=", "-RowMax<T>(input_list_t[t], b, &max_class_indices);", "if (max_class_indices != blank_index &&", "!(merge_repeated_ && max_class_indices == prev_indices)) {", "sequence.push_back(max_class_indices);", "}", "prev_indices = max_class_indices;", "}", "}", "};"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" dtls1_process_record(SSL *s)", " {", " \tint i,al;", " \tint enc_err;", " \tSSL_SESSION *sess;", " \tSSL3_RECORD *rr;", " \tunsigned int mac_size;", " \tunsigned char md[EVP_MAX_MD_SIZE];", " ", " \trr= &(s->s3->rrec);", " \tsess = s->session;", " ", " \t ", " \trr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);", " ", " \t  ", " ", " \t ", " ", " \t ", " \tif (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)", " \t\t{", " \t\tal=SSL_AD_RECORD_OVERFLOW;", " \t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);", " \t\tgoto f_err;", " \t\t}", " ", " \t ", " \trr->data=rr->input;", " \trr->orig_len=rr->length;", " ", " \tenc_err = s->method->ssl3_enc->enc(s,0);", " \t ", " \tif (enc_err == 0)", " \t\t{", " \t\t ", " \t\trr->length = 0;", " \t\ts->packet_length = 0;", " \t\tgoto err;", " \t\t}", " ", " #ifdef TLS_DEBUG", " printf(\"dec %d\\n\",rr->length);", " { unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }", " printf(\"\\n\");", " #endif", " ", " \t ", " \tif ((sess != NULL) &&", " \t    (s->enc_read_ctx != NULL) &&", " \t    (EVP_MD_CTX_md(s->read_hash) != NULL))", " \t\t{", " \t\t ", " \t\tunsigned char *mac = NULL;", " \t\tunsigned char mac_tmp[EVP_MAX_MD_SIZE];", " \t\tmac_size=EVP_MD_CTX_size(s->read_hash);", " \t\tOPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);", " ", " \t\t ", " \t\tif (rr->orig_len < mac_size ||", " \t\t     ", " \t\t    (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&", " \t\t     rr->orig_len < mac_size+1))", " \t\t\t{", " \t\t\tal=SSL_AD_DECODE_ERROR;", " \t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);", " \t\t\tgoto f_err;", " \t\t\t}", " ", " \t\tif (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)", " \t\t\t{", " \t\t\t ", " \t\t\tmac = mac_tmp;", " \t\t\tssl3_cbc_copy_mac(mac_tmp, rr, mac_size);", " \t\t\trr->length -= mac_size;", " \t\t\t}", " \t\telse", " \t\t\t{", " \t\t\t ", " \t\t\trr->length -= mac_size;", " \t\t\tmac = &rr->data[rr->length];", " \t\t\t}", " ", " \t\ti=s->method->ssl3_enc->mac(s,md,0  );", " \t\tif (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)", " \t\t\tenc_err = -1;", " \t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)", " \t\t\tenc_err = -1;", " \t\t}", " ", " \tif (enc_err < 0)", " \t\t{", " \t\t ", " \t\trr->length = 0;", " \t\ts->packet_length = 0;", " \t\tgoto err;", " \t\t}", " ", " \t ", " \tif (s->expand != NULL)", " \t\t{", " \t\tif (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)", " \t\t\t{", " \t\t\tal=SSL_AD_RECORD_OVERFLOW;", " \t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\tif (!ssl3_do_uncompress(s))", " \t\t\t{", " \t\t\tal=SSL_AD_DECOMPRESSION_FAILURE;", " \t\t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);", " \t\t\tgoto f_err;", " \t\t\t}", " \t\t}", " ", " \tif (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)", " \t\t{", " \t\tal=SSL_AD_RECORD_OVERFLOW;", " \t\tSSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);", " \t\tgoto f_err;", " \t\t}", " ", " \trr->off=0;", " \t ", "  ", "  \t ", "  \ts->packet_length=0;", "\tdtls1_record_bitmap_update(s, &(s->d1->bitmap)); ", "  \treturn(1);", "  ", "  f_err:", " \tssl3_send_alert(s,SSL3_AL_FATAL,al);", " err:", " \treturn(0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void DevToolsUIBindings::RecordEnumeratedHistogram(const std::string& name,", "                                                     int sample,", "                                                     int boundary_value) {", "   if (!frontend_host_)", "     return;", "    if (!(boundary_value >= 0 && boundary_value <= 100 && sample >= 0 &&", "          sample < boundary_value)) {", "     frontend_host_->BadMessageRecieved();", "     return;", "   }", "   if (name == kDevToolsActionTakenHistogram)", "     UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);", "   else if (name == kDevToolsPanelShownHistogram)", "     UMA_HISTOGRAM_ENUMERATION(name, sample, boundary_value);", "   else", "     frontend_host_->BadMessageRecieved();", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  stub_charset ()", "  {", "   locale = get_locale_var (\"LC_CTYPE\");", "  ", "    locale = get_locale_var (\"LC_CTYPE\");", "    if (locale == 0 || *locale == 0)", "    return \"ASCII\";", "     {", "       strcpy (charsetbuf, \"ASCII\");", "       return charsetbuf;", "     }", "    s = strrchr (locale, '.');", "    if (s)", "      {", "      t = strchr (s, '@');", "       strcpy (charsetbuf, s+1);", "       t = strchr (charsetbuf, '@');", "        if (t)", "  \t*t = 0;", "      return ++s;", "       return charsetbuf;", "      }", "  else if (STREQ (locale, \"UTF-8\"))", "    return \"UTF-8\";", "  else", "    return \"ASCII\";", "   strcpy (charsetbuf, locale);", "   return charsetbuf;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["hb_set_subtract (hb_set_t       *set,", "const hb_set_t *other)", "{", "if (unlikely (hb_object_is_immutable (set)))", "return;", "", "set->subtract (*other);", "}"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void TouchEventHandler::handleTouchPoint(Platform::TouchPoint& point, unsigned modifiers)", " void TouchEventHandler::handleTouchPoint(const Platform::TouchPoint& point, unsigned modifiers)", "  {", "      m_webPage->m_inputHandler->setInputModeEnabled();", " ", "     bool shiftActive = modifiers & KEYMOD_SHIFT;", "      bool altActive = modifiers & KEYMOD_ALT;", "      bool ctrlActive = modifiers & KEYMOD_CTRL;", "  ", "    switch (point.m_state) {", "     switch (point.state()) {", "      case Platform::TouchPoint::TouchPressed:", "          {", "             m_webPage->m_inputHandler->clearDidSpellCheckState();", " ", "             if (!m_lastFatFingersResult.isValid())", "                 doFatFingers(point);", " ", "             Element* elementUnderFatFinger = m_lastFatFingersResult.nodeAsElementIfApplicable();", " ", "              if (m_lastFatFingersResult.isTextInput()) {", "                  elementUnderFatFinger = m_lastFatFingersResult.nodeAsElementIfApplicable(FatFingersResult::ShadowContentNotAllowed, true  );", "                m_shouldRequestSpellCheckOptions = m_webPage->m_inputHandler->shouldRequestSpellCheckingOptionsForPoint(point.m_pos, elementUnderFatFinger, m_spellCheckOptionRequest);", "                 m_shouldRequestSpellCheckOptions = m_webPage->m_inputHandler->shouldRequestSpellCheckingOptionsForPoint(point.documentContentPosition(), elementUnderFatFinger, m_spellCheckOptionRequest);", "              }", "  ", "              handleFatFingerPressed(shiftActive, altActive, ctrlActive);", "             break;", "         }", "     case Platform::TouchPoint::TouchReleased:", "         {", " ", "             if (!m_shouldRequestSpellCheckOptions)", "                 m_webPage->m_inputHandler->processPendingKeyboardVisibilityChange();", " ", "             if (m_webPage->m_inputHandler->isInputMode())", "                 m_webPage->m_inputHandler->notifyClientOfKeyboardVisibilityChange(true);", " ", "             m_webPage->m_tapHighlight->hide();", " ", "             IntPoint adjustedPoint = m_webPage->mapFromContentsToViewport(m_lastFatFingersResult.adjustedPosition());", "             PlatformMouseEvent mouseEvent(adjustedPoint, m_lastScreenPoint, PlatformEvent::MouseReleased, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);", " ", "             m_webPage->handleMouseEvent(mouseEvent);", " ", "             if (m_shouldRequestSpellCheckOptions) {", "                 IntPoint pixelPositionRelativeToViewport = m_webPage->mapToTransformed(adjustedPoint);", "                 IntSize screenOffset(m_lastScreenPoint - pixelPositionRelativeToViewport);", "                 m_webPage->m_inputHandler->requestSpellingCheckingOptions(m_spellCheckOptionRequest, screenOffset);", "                 m_shouldRequestSpellCheckOptions = false;", "             }", " ", "             m_lastFatFingersResult.reset();  ", "             break;", "         }", "     case Platform::TouchPoint::TouchMoved:", "         {", "              m_webPage->m_inputHandler->clearDidSpellCheckState();", "  ", "            PlatformMouseEvent mouseEvent(point.m_pos, m_lastScreenPoint, PlatformEvent::MouseMoved, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);", "            m_lastScreenPoint = point.m_screenPos;", "             PlatformMouseEvent mouseEvent(point.documentViewportPosition(), m_lastScreenPoint, PlatformEvent::MouseMoved, 1, LeftButton, shiftActive, ctrlActive, altActive, TouchScreen);", "             m_lastScreenPoint = point.screenPosition();", "              m_webPage->handleMouseEvent(mouseEvent);", "              break;", "          }", "     default:", "         break;", "     }", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   void RenameFile(const DownloadId& id,", "                   const FilePath& new_path,", "                   const FilePath& unique_path,", "                   net::Error rename_error,", "                   RenameFileState state,", "                   RenameFileOverwrite should_overwrite) {", "     MockDownloadFile* file = download_file_factory_->GetExistingFile(id);", "     ASSERT_TRUE(file != NULL);", " ", "     EXPECT_CALL(*file, Rename(unique_path))", "         .Times(1)", "         .WillOnce(Return(rename_error));", " ", "     if (rename_error != net::OK) {", "       EXPECT_CALL(*file, BytesSoFar())", "           .Times(AtLeast(1))", "           .WillRepeatedly(Return(byte_count_[id]));", "       EXPECT_CALL(*file, GetHashState())", "            .Times(AtLeast(1));", "        EXPECT_CALL(*file, GetDownloadManager())", "            .Times(AtLeast(1));", "    } else if (state == COMPLETE) {", "#if defined(OS_MACOSX)", "      EXPECT_CALL(*file, AnnotateWithSourceInformation());", "#endif", "      }", "  ", "    if (state == IN_PROGRESS) {", "      download_file_manager_->RenameInProgressDownloadFile(", "          id, new_path, (should_overwrite == OVERWRITE),", "          base::Bind(&TestDownloadManager::OnDownloadRenamed,", "                     download_manager_, id.local()));", "    } else {   ", "      download_file_manager_->RenameCompletingDownloadFile(", "          id, new_path, (should_overwrite == OVERWRITE),", "          base::Bind(&TestDownloadManager::OnDownloadRenamed,", "                     download_manager_, id.local()));", "    }", "     download_file_manager_->RenameDownloadFile(", "         id, new_path, (should_overwrite == OVERWRITE),", "         base::Bind(&TestDownloadManager::OnDownloadRenamed,", "                    download_manager_, id.local()));", "  ", "      if (rename_error != net::OK) {", "        EXPECT_CALL(*download_manager_,", "                   OnDownloadInterrupted(", "                       id.local(),", "                       byte_count_[id],", "                       \"\",", "                       content::ConvertNetErrorToInterruptReason(", "                           rename_error,", "                           content::DOWNLOAD_INTERRUPT_FROM_DISK)));", "       EXPECT_CALL(*download_manager_,", "                   OnDownloadRenamed(id.local(), FilePath()));", "       ProcessAllPendingMessages();", "       ++error_count_[id];", "     } else {", "       EXPECT_CALL(*download_manager_,", "                   OnDownloadRenamed(id.local(), unique_path));", "       ProcessAllPendingMessages();", "      }", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  views::NonClientFrameView* ShellWindowViews::CreateNonClientFrameView(", "      views::Widget* widget) {", "  ShellWindowFrameView* frame_view = new ShellWindowFrameView();", "   ShellWindowFrameView* frame_view =", "       new ShellWindowFrameView(use_custom_frame_);", "    frame_view->Init(window_);", "    return frame_view;", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,", "                 const mbedtls_mpi *d, const unsigned char *buf, size_t blen,", "                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )", " {", "     ECDSA_VALIDATE_RET( grp   != NULL );", "     ECDSA_VALIDATE_RET( r     != NULL );", "     ECDSA_VALIDATE_RET( s     != NULL );", "     ECDSA_VALIDATE_RET( d     != NULL );", "      ECDSA_VALIDATE_RET( f_rng != NULL );", "      ECDSA_VALIDATE_RET( buf   != NULL || blen == 0 );", "  ", "      ", "      return( ecdsa_sign_restartable( grp, r, s, d, buf, blen,", "                                    f_rng, p_rng, NULL ) );", "                                     f_rng, p_rng, f_rng, p_rng, NULL ) );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0]}
{"tokens": [" krb5_gss_inquire_context(minor_status, context_handle, initiator_name,", "                          acceptor_name, lifetime_rec, mech_type, ret_flags,", "                          locally_initiated, opened)", "     OM_uint32 *minor_status;", "     gss_ctx_id_t context_handle;", "     gss_name_t *initiator_name;", "     gss_name_t *acceptor_name;", "     OM_uint32 *lifetime_rec;", "     gss_OID *mech_type;", "     OM_uint32 *ret_flags;", "     int *locally_initiated;", "     int *opened;", " {", "     krb5_context context;", "     krb5_error_code code;", "     krb5_gss_ctx_id_rec *ctx;", "     krb5_gss_name_t initiator, acceptor;", "     krb5_timestamp now;", "     krb5_deltat lifetime;", " ", "     if (initiator_name)", "         *initiator_name = (gss_name_t) NULL;", "     if (acceptor_name)", "         *acceptor_name = (gss_name_t) NULL;", "  ", "      ctx = (krb5_gss_ctx_id_rec *) context_handle;", "  ", "    if (! ctx->established) {", "     if (ctx->terminated || !ctx->established) {", "          *minor_status = KG_CTX_INCOMPLETE;", "          return(GSS_S_NO_CONTEXT);", "      }", " ", "     initiator = NULL;", "     acceptor = NULL;", "     context = ctx->k5_context;", " ", "     if ((code = krb5_timeofday(context, &now))) {", "         *minor_status = code;", "         save_error_info(*minor_status, context);", "         return(GSS_S_FAILURE);", "     }", " ", "     if ((lifetime = ctx->krb_times.endtime - now) < 0)", "         lifetime = 0;", " ", "     if (initiator_name) {", "         if ((code = kg_duplicate_name(context,", "                                       ctx->initiate ? ctx->here : ctx->there,", "                                       &initiator))) {", "             *minor_status = code;", "             save_error_info(*minor_status, context);", "             return(GSS_S_FAILURE);", "         }", "     }", " ", "     if (acceptor_name) {", "         if ((code = kg_duplicate_name(context,", "                                       ctx->initiate ? ctx->there : ctx->here,", "                                       &acceptor))) {", "             if (initiator)", "                 kg_release_name(context, &initiator);", "             *minor_status = code;", "             save_error_info(*minor_status, context);", "             return(GSS_S_FAILURE);", "         }", "     }", " ", "     if (initiator_name)", "         *initiator_name = (gss_name_t) initiator;", " ", "     if (acceptor_name)", "         *acceptor_name = (gss_name_t) acceptor;", " ", "     if (lifetime_rec)", "         *lifetime_rec = lifetime;", " ", "     if (mech_type)", "         *mech_type = (gss_OID) ctx->mech_used;", " ", "     if (ret_flags)", "         *ret_flags = ctx->gss_flags;", " ", "     if (locally_initiated)", "         *locally_initiated = ctx->initiate;", " ", "     if (opened)", "         *opened = ctx->established;", " ", "     *minor_status = 0;", "     return((lifetime == 0)?GSS_S_CONTEXT_EXPIRED:GSS_S_COMPLETE);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)", "{", "u32 val=0, code;", "s32 nb_lead = -1;", "u32 bits = 0;", "for (code=0; !code; nb_lead++) {", "if (nb_lead>=32) {", "", "", "if (!gf_bs_available(bs)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));", "} else {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));", "}", "return 0;", "}", "", "code = gf_bs_read_int(bs, 1);", "bits++;", "}", "", "if (nb_lead) {", "val = gf_bs_read_int(bs, nb_lead);", "val += (1 << nb_lead) - 1;", "bits += nb_lead;", "}", "", "if (fname) {", "gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);", "}", "return val;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  next_format(png_bytep colour_type, png_bytep bit_depth,", "   unsigned int* palette_number, int no_low_depth_gray)", "    unsigned int* palette_number, int low_depth_gray, int tRNS)", "  {", "     if (*bit_depth == 0)", "     {", "        *colour_type = 0;", "      if (no_low_depth_gray)", "         *bit_depth = 8;", "      else", "       if (low_depth_gray)", "           *bit_depth = 1;", "       else", "          *bit_depth = 8;", "        *palette_number = 0;", "        return 1;", "     }", "  ", "   if (*colour_type == 3)", "    if  (*colour_type < 4 )", "     {", "        ", "      if (++*palette_number < PALETTE_COUNT(*bit_depth))", "       unsigned int pn = ++*palette_number;", "       png_byte ct = *colour_type;", " ", "       if (((ct == 0  || ct  == 2) && tRNS && pn < 2) ||", "           (ct == 3  && pn < PALETTE_COUNT(*bit_depth)))", "           return 1;", "  ", "        ", "        *palette_number = 0;", "     }", "  ", "  *bit_depth = (png_byte)(*bit_depth << 1);", " ", "  ", "      ", "     if (*bit_depth <= 8", "#     ifdef DO_16BIT", " #ifdef DO_16BIT", "           || (*colour_type != 3 && *bit_depth <= 16)", "#     endif", " #endif", "        )", "        return 1;", "  ", "   ", "  switch (*colour_type)", "  {", "  case 0:", "  *colour_type = 2;", "  *bit_depth = 8;", "  return 1;", " ", "  case 2:", "  *colour_type = 3;", "  *bit_depth = 1;", "  return 1;", " ", "  case 3:", "  *colour_type = 4;", "  *bit_depth = 8;", "  return 1;", " ", "  case 4:", "  *colour_type = 6;", "  *bit_depth = 8;", "  return 1;", " ", "  default:", "  return 0;", "  }", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ResourceHostMsg_Request CreateXHRRequestWithOrigin(const char* origin) {", " ResourceHostMsg_Request CreateXHRRequest(const char* url) {", "    ResourceHostMsg_Request request;", "    request.method = \"GET\";", "  request.url = GURL(\"http:bar.com/simple_page.html\");", "  request.first_party_for_cookies = GURL(origin);", "   request.url = GURL(url);", "    request.referrer_policy = blink::WebReferrerPolicyDefault;", "  request.headers = base::StringPrintf(\"Origin: %s\\r\\n\", origin);", "    request.load_flags = 0;", "    request.origin_pid = 0;", "    request.resource_type = RESOURCE_TYPE_XHR;", "   request.request_context = 0;", "   request.appcache_host_id = kAppCacheNoHostId;", "   request.download_to_file = false;", "   request.should_reset_appcache = false;", "   request.is_main_frame = true;", "   request.parent_is_main_frame = false;", "   request.parent_render_frame_id = -1;", "   request.transition_type = ui::PAGE_TRANSITION_LINK;", "   request.allow_download = true;", "    return request;", "  }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" esis_print(netdissect_options *ndo,", "            const uint8_t *pptr, u_int length)", " {", " \tconst uint8_t *optr;", " \tu_int li,esis_pdu_type,source_address_length, source_address_number;", " \tconst struct esis_header_t *esis_header;", " ", " \tif (!ndo->ndo_eflag)", " \t\tND_PRINT((ndo, \"ES-IS\"));", " ", " \tif (length <= 2) {", " \t\tND_PRINT((ndo, ndo->ndo_qflag ? \"bad pkt!\" : \"no header at all!\"));", " \t\treturn;", " \t}", " ", " \tesis_header = (const struct esis_header_t *) pptr;", "         ND_TCHECK(*esis_header);", "         li = esis_header->length_indicator;", "         optr = pptr;", " ", "          ", " ", "         if (esis_header->nlpid != NLPID_ESIS) {", "             ND_PRINT((ndo, \" nlpid 0x%02x packet not supported\", esis_header->nlpid));", "             return;", "         }", " ", "         if (esis_header->version != ESIS_VERSION) {", "             ND_PRINT((ndo, \" version %d packet not supported\", esis_header->version));", "             return;", "         }", " ", " \tif (li > length) {", "             ND_PRINT((ndo, \" length indicator(%u) > PDU size (%u)!\", li, length));", "             return;", " \t}", " ", " \tif (li < sizeof(struct esis_header_t) + 2) {", "             ND_PRINT((ndo, \" length indicator %u < min PDU size:\", li));", "             while (pptr < ndo->ndo_snapend)", "                 ND_PRINT((ndo, \"%02X\", *pptr++));", "             return;", " \t}", " ", "         esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK;", " ", "         if (ndo->ndo_vflag < 1) {", "             ND_PRINT((ndo, \"%s%s, length %u\",", "                    ndo->ndo_eflag ? \"\" : \", \",", "                    tok2str(esis_pdu_values,\"unknown type (%u)\",esis_pdu_type),", "                    length));", "             return;", "         } else", "             ND_PRINT((ndo, \"%slength %u\\n\\t%s (%u)\",", "                    ndo->ndo_eflag ? \"\" : \", \",", "                    length,", "                    tok2str(esis_pdu_values,\"unknown type: %u\", esis_pdu_type),", "                    esis_pdu_type));", " ", "         ND_PRINT((ndo, \", v: %u%s\", esis_header->version, esis_header->version == ESIS_VERSION ? \"\" : \"unsupported\" ));", "         ND_PRINT((ndo, \", checksum: 0x%04x\", EXTRACT_16BITS(esis_header->cksum)));", " ", "         osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li);", " ", "         ND_PRINT((ndo, \", holding time: %us, length indicator: %u\",", "                   EXTRACT_16BITS(esis_header->holdtime), li));", " ", "         if (ndo->ndo_vflag > 1)", "             print_unknown_data(ndo, optr, \"\\n\\t\", sizeof(struct esis_header_t));", " ", " \tpptr += sizeof(struct esis_header_t);", " \tli -= sizeof(struct esis_header_t);", " ", " \tswitch (esis_pdu_type) {", " \tcase ESIS_PDU_REDIRECT: {", " \t\tconst uint8_t *dst, *snpa, *neta;", " \t\tu_int dstl, snpal, netal;", " ", " \t\tND_TCHECK(*pptr);", " \t\tif (li < 1) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tdstl = *pptr;", " \t\tpptr++;", " \t\tli--;", " \t\tND_TCHECK2(*pptr, dstl);", " \t\tif (li < dstl) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tdst = pptr;", " \t\tpptr += dstl;", "                 li -= dstl;", " \t\tND_PRINT((ndo, \"\\n\\t  %s\", isonsap_string(ndo, dst, dstl)));", " ", " \t\tND_TCHECK(*pptr);", " \t\tif (li < 1) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tsnpal = *pptr;", " \t\tpptr++;", " \t\tli--;", " \t\tND_TCHECK2(*pptr, snpal);", " \t\tif (li < snpal) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tsnpa = pptr;", " \t\tpptr += snpal;", "                 li -= snpal;", " \t\tND_TCHECK(*pptr);", " \t\tif (li < 1) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tnetal = *pptr;", " \t\tpptr++;", " \t\tND_TCHECK2(*pptr, netal);", " \t\tif (li < netal) {", " \t\t\tND_PRINT((ndo, \", bad redirect/li\"));", " \t\t\treturn;", " \t\t}", " \t\tneta = pptr;", " \t\tpptr += netal;", "                 li -= netal;", " ", " \t\tif (snpal == 6)", " \t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",", " \t\t\t       snpal,", " \t\t\t       etheraddr_string(ndo, snpa)));", " \t\telse", " \t\t\tND_PRINT((ndo, \"\\n\\t  SNPA (length: %u): %s\",", " \t\t\t       snpal,", " \t\t\t       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));", " \t\tif (netal != 0)", " \t\t\tND_PRINT((ndo, \"\\n\\t  NET (length: %u) %s\",", " \t\t\t       netal,", " \t\t\t       isonsap_string(ndo, neta, netal)));", " \t\tbreak;", " \t}", " ", " \tcase ESIS_PDU_ESH:", "             ND_TCHECK(*pptr);", "             if (li < 1) {", "                 ND_PRINT((ndo, \", bad esh/li\"));", "                 return;", "             }", "             source_address_number = *pptr;", "             pptr++;", "             li--;", " ", "             ND_PRINT((ndo, \"\\n\\t  Number of Source Addresses: %u\", source_address_number));", " ", "             while (source_address_number > 0) {", "                 ND_TCHECK(*pptr);", "             \tif (li < 1) {", "                     ND_PRINT((ndo, \", bad esh/li\"));", "             \t    return;", "             \t}", "                 source_address_length = *pptr;", "                 pptr++;", "             \tli--;", " ", "                 ND_TCHECK2(*pptr, source_address_length);", "             \tif (li < source_address_length) {", "                     ND_PRINT((ndo, \", bad esh/li\"));", "             \t    return;", "             \t}", "                 ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\",", "                        source_address_length,", "                        isonsap_string(ndo, pptr, source_address_length)));", "                 pptr += source_address_length;", "                 li -= source_address_length;", "                 source_address_number--;", "             }", " ", "             break;", " ", " \tcase ESIS_PDU_ISH: {", "             ND_TCHECK(*pptr);", "             if (li < 1) {", "                 ND_PRINT((ndo, \", bad ish/li\"));", "                 return;", "             }", "             source_address_length = *pptr;", "             pptr++;", "             li--;", "             ND_TCHECK2(*pptr, source_address_length);", "             if (li < source_address_length) {", "                 ND_PRINT((ndo, \", bad ish/li\"));", "                 return;", "             }", "             ND_PRINT((ndo, \"\\n\\t  NET (length: %u): %s\", source_address_length, isonsap_string(ndo, pptr, source_address_length)));", "             pptr += source_address_length;", "             li -= source_address_length;", "             break;", " \t}", " ", " \tdefault:", " \t\tif (ndo->ndo_vflag <= 1) {", " \t\t\tif (pptr < ndo->ndo_snapend)", " \t\t\t\tprint_unknown_data(ndo, pptr, \"\\n\\t  \", ndo->ndo_snapend - pptr);", " \t\t}", " \t\treturn;", " \t}", " ", "          ", "         while (li != 0) {", "             u_int op, opli;", "             const uint8_t *tptr;", " ", "             if (li < 2) {", "                 ND_PRINT((ndo, \", bad opts/li\"));", "                 return;", "             }", "             ND_TCHECK2(*pptr, 2);", "             op = *pptr++;", "             opli = *pptr++;", "             li -= 2;", "             if (opli > li) {", "                 ND_PRINT((ndo, \", opt (%d) too long\", op));", "                 return;", "             }", "             li -= opli;", "             tptr = pptr;", " ", "             ND_PRINT((ndo, \"\\n\\t  %s Option #%u, length %u, value: \",", "                    tok2str(esis_option_values,\"Unknown\",op),", "                    op,", "                    opli));", " ", "             switch (op) {", " ", "             case ESIS_OPTION_ES_CONF_TIME:", "                 if (opli == 2) {", "                     ND_TCHECK2(*pptr, 2);", "                     ND_PRINT((ndo, \"%us\", EXTRACT_16BITS(tptr)));", "                 } else", "                     ND_PRINT((ndo, \"(bad length)\"));", "                 break;", "  ", "              case ESIS_OPTION_PROTOCOLS:", "                  while (opli>0) {", "                    ND_TCHECK(*pptr);", "                     ND_TCHECK(*tptr);", "                      ND_PRINT((ndo, \"%s (0x%02x)\",", "                             tok2str(nlpid_values,", "                                     \"unknown\",", "                                    *tptr),", "                            *tptr));", "                     if (opli>1)  ", "                         ND_PRINT((ndo, \", \"));", "                     tptr++;", "                     opli--;", "                 }", "                 break;", " ", "                  ", " ", "             case ESIS_OPTION_QOS_MAINTENANCE:", "             case ESIS_OPTION_SECURITY:", "             case ESIS_OPTION_PRIORITY:", "             case ESIS_OPTION_ADDRESS_MASK:", "             case ESIS_OPTION_SNPA_MASK:", " ", "             default:", "                 print_unknown_data(ndo, tptr, \"\\n\\t  \", opli);", "                 break;", "             }", "             if (ndo->ndo_vflag > 1)", "                 print_unknown_data(ndo, pptr, \"\\n\\t  \", opli);", "              pptr += opli;", "          }", "  trunc:", "\treturn;", "         ND_PRINT((ndo, \"[|esis]\"));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" void HTMLMediaElement::NoneSupported(const String& message) {", "  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\" << message", "                  << \"')\";", " void HTMLMediaElement::NoneSupported(const String& input_message) {", "   BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\"", "                   << input_message << \"')\";", "  ", "    StopPeriodicTimers();", "    load_state_ = kWaitingForSource;", "    current_source_node_ = nullptr;", "  ", "   String empty_string;", "   const String& message = MediaShouldBeOpaque() ? empty_string : input_message;", " ", "  ", "   error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);", " ", "   ForgetResourceSpecificTracks();", " ", "   SetNetworkState(kNetworkNoSource);", " ", "   UpdateDisplayState();", " ", "   ScheduleEvent(EventTypeNames::error);", " ", "   ScheduleRejectPlayPromises(kNotSupportedError);", " ", "   CloseMediaSource();", " ", "   SetShouldDelayLoadEvent(false);", " ", "   if (GetLayoutObject())", "     GetLayoutObject()->UpdateFromElement();", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool ConvertProperty(IBusProperty* ibus_prop,", "                      int selection_item_id,", "                      ImePropertyList* out_prop_list) {", "   DCHECK(ibus_prop);", "   DCHECK(ibus_prop->key);", "   DCHECK(out_prop_list);", " ", "   const bool has_sub_props = PropertyHasChildren(ibus_prop);", "   if (has_sub_props && (ibus_prop->type != PROP_TYPE_MENU)) {", "     LOG(ERROR) << \"The property has sub properties, \"", "                << \"but the type of the property is not PROP_TYPE_MENU\";", "     return false;", "    }", "    if ((!has_sub_props) && (ibus_prop->type == PROP_TYPE_MENU)) {", "    DLOG(INFO) << \"Property list is empty\";", "     VLOG(1) << \"Property list is empty\";", "      return false;", "    }", "    if (ibus_prop->type == PROP_TYPE_SEPARATOR ||", "       ibus_prop->type == PROP_TYPE_MENU) {", "     return true;", "   }", " ", "   const bool is_selection_item = (ibus_prop->type == PROP_TYPE_RADIO);", "   selection_item_id = is_selection_item ?", "       selection_item_id : ImeProperty::kInvalidSelectionItemId;", " ", "   bool is_selection_item_checked = false;", "   if (ibus_prop->state == PROP_STATE_INCONSISTENT) {", "     LOG(WARNING) << \"The property is in PROP_STATE_INCONSISTENT, \"", "                  << \"which is not supported.\";", "   } else if ((!is_selection_item) && (ibus_prop->state == PROP_STATE_CHECKED)) {", "     LOG(WARNING) << \"PROP_STATE_CHECKED is meaningful only if the type is \"", "                  << \"PROP_TYPE_RADIO.\";", "   } else {", "     is_selection_item_checked = (ibus_prop->state == PROP_STATE_CHECKED);", "   }", " ", "   if (!ibus_prop->key) {", "     LOG(ERROR) << \"key is NULL\";", "   }", "   if (ibus_prop->tooltip && (!ibus_prop->tooltip->text)) {", "     LOG(ERROR) << \"tooltip is NOT NULL, but tooltip->text IS NULL: key=\"", "                << Or(ibus_prop->key, \"\");", "   }", "   if (ibus_prop->label && (!ibus_prop->label->text)) {", "     LOG(ERROR) << \"label is NOT NULL, but label->text IS NULL: key=\"", "                << Or(ibus_prop->key, \"\");", "   }", " ", "   std::string label =", "       ((ibus_prop->tooltip &&", "         ibus_prop->tooltip->text) ? ibus_prop->tooltip->text : \"\");", "   if (label.empty()) {", "     label = (ibus_prop->label && ibus_prop->label->text)", "         ? ibus_prop->label->text : \"\";", "   }", "   if (label.empty()) {", "     label = Or(ibus_prop->key, \"\");", "   }", " ", "   out_prop_list->push_back(ImeProperty(ibus_prop->key,", "                                        label,", "                                        is_selection_item,", "                                        is_selection_item_checked,", "                                        selection_item_id));", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)", " {", "     unsigned nSyms = darray_size(expr->keysym_list.syms);", "     unsigned numEntries = darray_size(append->keysym_list.syms);", " ", "     darray_append(expr->keysym_list.symsMapIndex, nSyms);", "      darray_append(expr->keysym_list.symsNumEntries, numEntries);", "      darray_concat(expr->keysym_list.syms, append->keysym_list.syms);", "  ", "    FreeStmt((ParseCommon *) &append);", "     FreeStmt((ParseCommon *) append);", "  ", "      return expr;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" base::string16 IDNToUnicodeWithAdjustments(", "     base::StringPiece host, base::OffsetAdjuster::Adjustments* adjustments) {", "   if (adjustments)", "     adjustments->clear();", "   base::string16 input16;", "    input16.reserve(host.length());", "    input16.insert(input16.end(), host.begin(), host.end());", "  ", "   bool is_tld_ascii = true;", "   size_t last_dot = host.rfind('.');", "   if (last_dot != base::StringPiece::npos &&", "       host.substr(last_dot).starts_with(\".xn--\")) {", "     is_tld_ascii = false;", "   }", " ", "    base::string16 out16;", "   for (size_t component_start = 0, component_end;", "        component_start < input16.length();", "        component_start = component_end + 1) {", "     component_end = input16.find('.', component_start);", "     if (component_end == base::string16::npos)", "       component_end = input16.length();   ", "     size_t component_length = component_end - component_start;", "     size_t new_component_start = out16.length();", "     bool converted_idn = false;", "     if (component_end > component_start) {", "        converted_idn =", "            IDNToUnicodeOneComponent(input16.data() + component_start,", "                                   component_length, &out16);", "                                    component_length, is_tld_ascii, &out16);", "      }", "      size_t new_component_length = out16.length() - new_component_start;", "  ", "     if (converted_idn && adjustments) {", "       adjustments->push_back(base::OffsetAdjuster::Adjustment(", "           component_start, component_length, new_component_length));", "     }", " ", "     if (component_end < input16.length())", "       out16.push_back('.');", "   }", "   return out16;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  choose_filters(struct archive_read *a)", "  {", "\tint number_bidders, i, bid, best_bid;", " \tint number_bidders, i, bid, best_bid, n;", "  \tstruct archive_read_filter_bidder *bidder, *best_bidder;", "  \tstruct archive_read_filter *filter;", "  \tssize_t avail;", "  \tint r;", "  ", "\tfor (;;) {", " \tfor (n = 0; n < 25; ++n) {", "  \t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);", "  ", "  \t\tbest_bid = 0;", " \t\tbest_bidder = NULL;", " ", " \t\tbidder = a->bidders;", " \t\tfor (i = 0; i < number_bidders; i++, bidder++) {", " \t\t\tif (bidder->bid != NULL) {", " \t\t\t\tbid = (bidder->bid)(bidder, a->filter);", " \t\t\t\tif (bid > best_bid) {", " \t\t\t\t\tbest_bid = bid;", " \t\t\t\t\tbest_bidder = bidder;", " \t\t\t\t}", " \t\t\t}", " \t\t}", " ", " \t\t ", " \t\tif (best_bidder == NULL) {", " \t\t\t ", " \t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);", " \t\t\tif (avail < 0) {", " \t\t\t\t__archive_read_close_filters(a);", " \t\t\t\t__archive_read_free_filters(a);", " \t\t\t\treturn (ARCHIVE_FATAL);", " \t\t\t}", " \t\t\ta->archive.compression_name = a->filter->name;", " \t\t\ta->archive.compression_code = a->filter->code;", " \t\t\treturn (ARCHIVE_OK);", " \t\t}", " ", " \t\tfilter", " \t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));", " \t\tif (filter == NULL)", " \t\t\treturn (ARCHIVE_FATAL);", " \t\tfilter->bidder = best_bidder;", " \t\tfilter->archive = a;", " \t\tfilter->upstream = a->filter;", " \t\ta->filter = filter;", " \t\tr = (best_bidder->init)(a->filter);", " \t\tif (r != ARCHIVE_OK) {", " \t\t\t__archive_read_close_filters(a);", " \t\t\t__archive_read_free_filters(a);", "  \t\t\treturn (ARCHIVE_FATAL);", "  \t\t}", "  \t}", " \tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,", " \t    \"Input requires too many filters for decoding\");", " \treturn (ARCHIVE_FATAL);", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" GF_Err gf_sm_load_init(GF_SceneLoader *load)", " {", " \tGF_Err e = GF_NOT_SUPPORTED;", " \tchar *ext, szExt[50];", " \t ", " \tif (!load || (!load->ctx && !load->scene_graph)", " #ifndef GPAC_DISABLE_ISOM", " \t        || (!load->fileName && !load->isom && !(load->flags & GF_SM_LOAD_FOR_PLAYBACK) )", " #endif", " \t   ) return GF_BAD_PARAM;", " ", " \tif (!load->type) {", " #ifndef GPAC_DISABLE_ISOM", " \t\tif (load->isom) {", " \t\t\tload->type = GF_SM_LOAD_MP4;", " \t\t} else", " #endif", " \t\t{", " \t\t\text = (char *)strrchr(load->fileName, '.');", " \t\t\tif (!ext) return GF_NOT_SUPPORTED;", " \t\t\tif (!stricmp(ext, \".gz\")) {", " \t\t\t\tchar *anext;", " \t\t\t\text[0] = 0;", " \t\t\t\tanext = (char *)strrchr(load->fileName, '.');", "  \t\t\t\text[0] = '.';", "  \t\t\t\text = anext;", "  \t\t\t}", " \t\t\tif (strlen(ext) < 2 || strlen(ext) > sizeof(szExt)) {", " \t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, (\"[Scene Manager] invalid extension in file name %s\\n\", load->fileName));", " \t\t\t\treturn GF_NOT_SUPPORTED;", " \t\t\t}", "  \t\t\tstrcpy(szExt, &ext[1]);", "  \t\t\tstrlwr(szExt);", "  \t\t\tif (strstr(szExt, \"bt\")) load->type = GF_SM_LOAD_BT;", " \t\t\telse if (strstr(szExt, \"wrl\")) load->type = GF_SM_LOAD_VRML;", " \t\t\telse if (strstr(szExt, \"x3dv\")) load->type = GF_SM_LOAD_X3DV;", " #ifndef GPAC_DISABLE_LOADER_XMT", " \t\t\telse if (strstr(szExt, \"xmt\") || strstr(szExt, \"xmta\")) load->type = GF_SM_LOAD_XMTA;", " \t\t\telse if (strstr(szExt, \"x3d\")) load->type = GF_SM_LOAD_X3D;", " #endif", " \t\t\telse if (strstr(szExt, \"swf\")) load->type = GF_SM_LOAD_SWF;", " \t\t\telse if (strstr(szExt, \"mov\")) load->type = GF_SM_LOAD_QT;", " \t\t\telse if (strstr(szExt, \"svg\")) load->type = GF_SM_LOAD_SVG;", " \t\t\telse if (strstr(szExt, \"xsr\")) load->type = GF_SM_LOAD_XSR;", " \t\t\telse if (strstr(szExt, \"xbl\")) load->type = GF_SM_LOAD_XBL;", " \t\t\telse if (strstr(szExt, \"xml\")) {", " \t\t\t\tchar *rtype = gf_xml_get_root_type(load->fileName, &e);", " \t\t\t\tif (rtype) {", " \t\t\t\t\tif (!strcmp(rtype, \"SAFSession\")) load->type = GF_SM_LOAD_XSR;", " \t\t\t\t\telse if (!strcmp(rtype, \"XMT-A\")) load->type = GF_SM_LOAD_XMTA;", " \t\t\t\t\telse if (!strcmp(rtype, \"X3D\")) load->type = GF_SM_LOAD_X3D;", " \t\t\t\t\telse if (!strcmp(rtype, \"bindings\")) load->type = GF_SM_LOAD_XBL;", " ", " \t\t\t\t\tgf_free(rtype);", " \t\t\t\t}", " \t\t\t}", " \t\t}", " \t}", " \tif (!load->type) return e;", " ", " \tif (!load->scene_graph) load->scene_graph = load->ctx->scene_graph;", " ", " \tswitch (load->type) {", " #ifndef GPAC_DISABLE_LOADER_BT", " \tcase GF_SM_LOAD_BT:", " \tcase GF_SM_LOAD_VRML:", " \tcase GF_SM_LOAD_X3DV:", " \t\treturn gf_sm_load_init_bt(load);", " #endif", " ", " #ifndef GPAC_DISABLE_LOADER_XMT", " \tcase GF_SM_LOAD_XMTA:", " \tcase GF_SM_LOAD_X3D:", " \t\treturn gf_sm_load_init_xmt(load);", " #endif", " ", " #ifndef GPAC_DISABLE_SVG", " \tcase GF_SM_LOAD_SVG:", " \tcase GF_SM_LOAD_XSR:", " \tcase GF_SM_LOAD_DIMS:", " \t\treturn gf_sm_load_init_svg(load);", " ", " \tcase GF_SM_LOAD_XBL:", " \t\te = gf_sm_load_init_xbl(load);", " ", " \t\tload->process = gf_sm_load_run_xbl;", " \t\tload->done = gf_sm_load_done_xbl;", " \t\treturn e;", " #endif", " ", " #ifndef GPAC_DISABLE_SWF_IMPORT", " \tcase GF_SM_LOAD_SWF:", " \t\treturn gf_sm_load_init_swf(load);", " #endif", " ", " #ifndef GPAC_DISABLE_LOADER_ISOM", " \tcase GF_SM_LOAD_MP4:", " \t\treturn gf_sm_load_init_isom(load);", " #endif", " ", " #ifndef GPAC_DISABLE_QTVR", " \tcase GF_SM_LOAD_QT:", " \t\treturn gf_sm_load_init_qt(load);", " #endif", " \tdefault:", " \t\treturn GF_NOT_SUPPORTED;", " \t}", " \treturn GF_NOT_SUPPORTED;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void ext2_put_super (struct super_block * sb)", " {", " \tint db_count;", " \tint i;", " \tstruct ext2_sb_info *sbi = EXT2_SB(sb);", "  ", "  \tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);", "  ", "\text2_xattr_put_super(sb);", " \tif (sbi->s_mb_cache) {", " \t\text2_xattr_destroy_cache(sbi->s_mb_cache);", " \t\tsbi->s_mb_cache = NULL;", " \t}", "  \tif (!(sb->s_flags & MS_RDONLY)) {", "  \t\tstruct ext2_super_block *es = sbi->s_es;", "  ", " \t\tspin_lock(&sbi->s_lock);", " \t\tes->s_state = cpu_to_le16(sbi->s_mount_state);", " \t\tspin_unlock(&sbi->s_lock);", " \t\text2_sync_super(sb, es, 1);", " \t}", " \tdb_count = sbi->s_gdb_count;", " \tfor (i = 0; i < db_count; i++)", " \t\tif (sbi->s_group_desc[i])", " \t\t\tbrelse (sbi->s_group_desc[i]);", " \tkfree(sbi->s_group_desc);", " \tkfree(sbi->s_debts);", " \tpercpu_counter_destroy(&sbi->s_freeblocks_counter);", " \tpercpu_counter_destroy(&sbi->s_freeinodes_counter);", " \tpercpu_counter_destroy(&sbi->s_dirs_counter);", " \tbrelse (sbi->s_sbh);", " \tsb->s_fs_info = NULL;", " \tkfree(sbi->s_blockgroup_lock);", " \tkfree(sbi);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["pixFewColorsOctcubeQuantMixed(PIX       *pixs,", "l_int32    level,", "l_int32    darkthresh,", "l_int32    lightthresh,", "l_int32    diffthresh,", "l_float32  minfract,", "l_int32    maxspan)", "{", "l_int32    i, j, w, h, wplc, wplm, wpld, ncolors, index;", "l_int32    rval, gval, bval, val, minval, maxval;", "l_int32   *lut;", "l_uint32  *datac, *datam, *datad, *linec, *linem, *lined;", "PIX       *pixc, *pixm, *pixg, *pixd;", "PIXCMAP   *cmap, *cmapd;", "", "PROCNAME(\"pixFewColorsOctcubeQuantMixed\");", "", "if (!pixs || pixGetDepth(pixs) != 32)", "return (PIX *)ERROR_PTR(\"pixs undefined or not 32 bpp\", procName, NULL);", "if (level <= 0) level = 3;", "if (level > 6)", "return (PIX *)ERROR_PTR(\"invalid level\", procName, NULL);", "if (darkthresh <= 0) darkthresh = 20;", "if (lightthresh <= 0) lightthresh = 244;", "if (diffthresh <= 0) diffthresh = 20;", "if (minfract <= 0.0) minfract = 0.05;", "if (maxspan <= 2) maxspan = 15;", "", "", "if ((pixc = pixFewColorsOctcubeQuant1(pixs, level)) == NULL)", "return (PIX *)ERROR_PTR(\"too many colors\", procName, NULL);", "", "", "", "cmap = pixGetColormap(pixc);", "ncolors = pixcmapGetCount(cmap);", "cmapd = pixcmapCreate(8);", "lut = (l_int32 *)LEPT_CALLOC(256, sizeof(l_int32));", "for (i = 0; i < 256; i++)", "lut[i] = -1;", "for (i = 0, index = 0; i < ncolors; i++) {", "pixcmapGetColor(cmap, i, &rval, &gval, &bval);", "minval = L_MIN(rval, gval);", "minval = L_MIN(minval, bval);", "if (minval > lightthresh)", "continue;", "maxval = L_MAX(rval, gval);", "maxval = L_MAX(maxval, bval);", "if (maxval < darkthresh)", "continue;", "", "", "if (maxval - minval >= diffthresh) {", "pixcmapAddColor(cmapd, rval, gval, bval);", "lut[i] = index;", "index++;", "}", "}", "", "", "", "", "pixGetDimensions(pixs, &w, &h, NULL);", "pixd = pixCreate(w, h, 8);", "pixSetColormap(pixd, cmapd);", "pixm = pixCreate(w, h, 1);", "datac = pixGetData(pixc);", "datam = pixGetData(pixm);", "datad = pixGetData(pixd);", "wplc = pixGetWpl(pixc);", "wplm = pixGetWpl(pixm);", "wpld = pixGetWpl(pixd);", "for (i = 0; i < h; i++) {", "linec = datac + i * wplc;", "linem = datam + i * wplm;", "lined = datad + i * wpld;", "for (j = 0; j < w; j++) {", "val = GET_DATA_BYTE(linec, j);", "if (lut[val] == -1)", "SET_DATA_BIT(linem, j);", "else", "SET_DATA_BYTE(lined, j, lut[val]);", "}", "}", "", "", "", "pixg = pixConvertTo8(pixs, 0);", "pixGrayQuantFromHisto(pixd, pixg, pixm, minfract, maxspan);", "", "LEPT_FREE(lut);", "pixDestroy(&pixc);", "pixDestroy(&pixm);", "pixDestroy(&pixg);", "return pixd;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)", " {", " \tstruct key_user *newowner, *zapowner = NULL;", " \tstruct key *key;", " \tkey_ref_t key_ref;", " \tlong ret;", " \tkuid_t uid;", " \tkgid_t gid;", " ", " \tuid = make_kuid(current_user_ns(), user);", " \tgid = make_kgid(current_user_ns(), group);", " \tret = -EINVAL;", " \tif ((user != (uid_t) -1) && !uid_valid(uid))", " \t\tgoto error;", " \tif ((group != (gid_t) -1) && !gid_valid(gid))", " \t\tgoto error;", " ", " \tret = 0;", " \tif (user == (uid_t) -1 && group == (gid_t) -1)", " \t\tgoto error;", " ", " \tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,", " \t\t\t\t  KEY_NEED_SETATTR);", " \tif (IS_ERR(key_ref)) {", " \t\tret = PTR_ERR(key_ref);", " \t\tgoto error;", " \t}", " ", " \tkey = key_ref_to_ptr(key_ref);", " ", " \t ", " \tret = -EACCES;", " \tdown_write(&key->sem);", " ", " \tif (!capable(CAP_SYS_ADMIN)) {", " \t\t ", " \t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))", " \t\t\tgoto error_put;", " ", " \t\t ", " \t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))", " \t\t\tgoto error_put;", " \t}", " ", " \t ", " \tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {", " \t\tret = -ENOMEM;", " \t\tnewowner = key_user_lookup(uid);", " \t\tif (!newowner)", " \t\t\tgoto error_put;", " ", " \t\t ", " \t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {", " \t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?", " \t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;", " \t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?", " \t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;", " ", " \t\t\tspin_lock(&newowner->lock);", " \t\t\tif (newowner->qnkeys + 1 >= maxkeys ||", " \t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||", " \t\t\t    newowner->qnbytes + key->quotalen <", " \t\t\t    newowner->qnbytes)", " \t\t\t\tgoto quota_overrun;", " ", " \t\t\tnewowner->qnkeys++;", " \t\t\tnewowner->qnbytes += key->quotalen;", " \t\t\tspin_unlock(&newowner->lock);", " ", " \t\t\tspin_lock(&key->user->lock);", " \t\t\tkey->user->qnkeys--;", " \t\t\tkey->user->qnbytes -= key->quotalen;", " \t\t\tspin_unlock(&key->user->lock);", " \t\t}", " ", "  \t\tatomic_dec(&key->user->nkeys);", "  \t\tatomic_inc(&newowner->nkeys);", "  ", "\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {", " \t\tif (key->state != KEY_IS_UNINSTANTIATED) {", "  \t\t\tatomic_dec(&key->user->nikeys);", "  \t\t\tatomic_inc(&newowner->nikeys);", "  \t\t}", " ", " \t\tzapowner = key->user;", " \t\tkey->user = newowner;", " \t\tkey->uid = uid;", " \t}", " ", " \t ", " \tif (group != (gid_t) -1)", " \t\tkey->gid = gid;", " ", " \tret = 0;", " ", " error_put:", " \tup_write(&key->sem);", " \tkey_put(key);", " \tif (zapowner)", " \t\tkey_user_put(zapowner);", " error:", " \treturn ret;", " ", " quota_overrun:", " \tspin_unlock(&newowner->lock);", " \tzapowner = newowner;", " \tret = -EDQUOT;", " \tgoto error_put;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)", "{", "VirtQueueElement elem;", "VirtQueue *vq;", "", "vq = vser->c_ivq;", "if (!virtio_queue_ready(vq)) {", "return 0;", "}", "if (!virtqueue_pop(vq, &elem)) {", "return 0;", "}", "", "memcpy(elem.in_sg[0].iov_base, buf, len);", "", "virtqueue_push(vq, &elem, len);", "virtio_notify(VIRTIO_DEVICE(vser), vq);", "return len;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  bool PaintArtifactCompositor::MightOverlap(const PendingLayer& layer_a,", "                                             const PendingLayer& layer_b) {", "  PropertyTreeState root_property_tree_state(TransformPaintPropertyNode::Root(),", "                                             ClipPaintPropertyNode::Root(),", "                                             EffectPaintPropertyNode::Root());", "    FloatClipRect bounds_a(layer_a.bounds);", "  GeometryMapper::LocalToAncestorVisualRect(layer_a.property_tree_state,", "                                            root_property_tree_state, bounds_a);", "   GeometryMapper::LocalToAncestorVisualRect(", "       layer_a.property_tree_state, PropertyTreeState::Root(), bounds_a);", "    FloatClipRect bounds_b(layer_b.bounds);", "  GeometryMapper::LocalToAncestorVisualRect(layer_b.property_tree_state,", "                                            root_property_tree_state, bounds_b);", "   GeometryMapper::LocalToAncestorVisualRect(", "       layer_b.property_tree_state, PropertyTreeState::Root(), bounds_b);", "  ", "    return bounds_a.Rect().Intersects(bounds_b.Rect());", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": ["  static void copyIPv6IfDifferent(void * dest, const void * src)", "  {", "\tif(dest != src) {", " \tif(dest != src && src != NULL) {", "  \t\tmemcpy(dest, src, sizeof(struct in6_addr));", "  \t}", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["  horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)", "  {", "  \tTIFFPredictorState* sp = PredictorState(tif);", "  \ttmsize_t stride = sp->stride;", "  \tunsigned char* cp = (unsigned char*) cp0;", "  ", "\tassert((cc%stride)==0);", "     if((cc%stride)!=0)", "     {", "         TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",", "                      \"%s\", \"(cc%stride)!=0\");", "         return 0;", "     }", "  ", "  \tif (cc > stride) {", "  \t\tcc -= stride;", " \t\t ", " \t\tif (stride == 3) {", " \t\t\tunsigned int r1, g1, b1;", " \t\t\tunsigned int r2 = cp[0];", " \t\t\tunsigned int g2 = cp[1];", " \t\t\tunsigned  int b2 = cp[2];", " \t\t\tdo {", " \t\t\t\tr1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;", " \t\t\t\tg1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;", " \t\t\t\tb1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;", " \t\t\t\tcp += 3;", " \t\t\t} while ((cc -= 3) > 0);", " \t\t} else if (stride == 4) {", " \t\t\tunsigned int r1, g1, b1, a1;", " \t\t\tunsigned int r2 = cp[0];", " \t\t\tunsigned int g2 = cp[1];", " \t\t\tunsigned int b2 = cp[2];", " \t\t\tunsigned int a2 = cp[3];", " \t\t\tdo {", " \t\t\t\tr1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;", " \t\t\t\tg1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;", " \t\t\t\tb1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;", " \t\t\t\ta1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;", " \t\t\t\tcp += 4;", " \t\t\t} while ((cc -= 4) > 0);", " \t\t} else {", " \t\t\tcp += cc - 1;", " \t\t\tdo {", " \t\t\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)", "  \t\t\t} while ((cc -= stride) > 0);", "  \t\t}", "  \t}", " \treturn 1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void XMLHttpRequest::genericError()", " void XMLHttpRequest::handleDidFailGeneric()", "  {", "      clearResponse();", "      clearRequest();", "    m_error = true;", "  ", "    changeState(DONE);", "     m_error = true;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 1, 0, 1, 1, 0]}
{"tokens": [" IPV6DefragDoSturgesNovakTest(int policy, u_char *expected, size_t expected_len)", " {", "     int i;", "     int ret = 0;", " ", "     DefragInit();", " ", "      ", " ", "     int id = 1;", "     Packet *packets[17];", "     memset(packets, 0x00, sizeof(packets));", " ", "      ", "  ", "       ", "    packets[0] = IPV6BuildTestPacket(id, 0, 1, 'A', 24);", "     packets[0] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 0, 1, 'A', 24);", "  ", "       ", "    packets[1] = IPV6BuildTestPacket(id, 32 >> 3, 1, 'B', 16);", "     packets[1] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 32 >> 3, 1, 'B', 16);", "  ", "       ", "    packets[2] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'C', 24);", "     packets[2] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'C', 24);", "  ", "       ", "    packets[3] = IPV6BuildTestPacket(id, 80 >> 3, 1, 'D', 8);", "     packets[3] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 80 >> 3, 1, 'D', 8);", "  ", "       ", "    packets[4] = IPV6BuildTestPacket(id, 104 >> 3, 1, 'E', 16);", "     packets[4] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 104 >> 3, 1, 'E', 16);", "  ", "       ", "    packets[5] = IPV6BuildTestPacket(id, 120 >> 3, 1, 'F', 24);", "     packets[5] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 120 >> 3, 1, 'F', 24);", "  ", "       ", "    packets[6] = IPV6BuildTestPacket(id, 144 >> 3, 1, 'G', 16);", "     packets[6] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 144 >> 3, 1, 'G', 16);", "  ", "       ", "    packets[7] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'H', 16);", "     packets[7] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'H', 16);", "  ", "       ", "    packets[8] = IPV6BuildTestPacket(id, 176 >> 3, 1, 'I', 8);", "     packets[8] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 1, 'I', 8);", "  ", "       ", "  ", "       ", "    packets[9] = IPV6BuildTestPacket(id, 8 >> 3, 1, 'J', 32);", "     packets[9] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 8 >> 3, 1, 'J', 32);", "  ", "       ", "    packets[10] = IPV6BuildTestPacket(id, 48 >> 3, 1, 'K', 24);", "     packets[10] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 48 >> 3, 1, 'K', 24);", "  ", "       ", "    packets[11] = IPV6BuildTestPacket(id, 72 >> 3, 1, 'L', 24);", "     packets[11] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 72 >> 3, 1, 'L', 24);", "  ", "       ", "    packets[12] = IPV6BuildTestPacket(id, 96 >> 3, 1, 'M', 24);", "     packets[12] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 96 >> 3, 1, 'M', 24);", "  ", "       ", "    packets[13] = IPV6BuildTestPacket(id, 128 >> 3, 1, 'N', 8);", "     packets[13] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 128 >> 3, 1, 'N', 8);", "  ", "       ", "    packets[14] = IPV6BuildTestPacket(id, 152 >> 3, 1, 'O', 8);", "     packets[14] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 152 >> 3, 1, 'O', 8);", "  ", "       ", "    packets[15] = IPV6BuildTestPacket(id, 160 >> 3, 1, 'P', 8);", "     packets[15] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 160 >> 3, 1, 'P', 8);", "  ", "       ", "    packets[16] = IPV6BuildTestPacket(id, 176 >> 3, 0, 'Q', 16);", "     packets[16] = IPV6BuildTestPacket(IPPROTO_ICMPV6, id, 176 >> 3, 0, 'Q', 16);", "  ", "      default_policy = policy;", "  ", "      ", "     for (i = 0; i < 9; i++) {", "         Packet *tp = Defrag(NULL, NULL, packets[i], NULL);", "         if (tp != NULL) {", "             SCFree(tp);", "             goto end;", "         }", "         if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {", "             goto end;", "         }", "     }", "     int overlap = 0;", "     for (; i < 16; i++) {", "         Packet *tp = Defrag(NULL, NULL, packets[i], NULL);", "         if (tp != NULL) {", "             SCFree(tp);", "             goto end;", "         }", "         if (ENGINE_ISSET_EVENT(packets[i], IPV6_FRAG_OVERLAP)) {", "             overlap++;", "         }", "     }", "     if (!overlap)", "         goto end;", " ", "      ", "     Packet *reassembled = Defrag(NULL, NULL, packets[16], NULL);", "     if (reassembled == NULL)", "         goto end;", "     if (memcmp(GET_PKT_DATA(reassembled) + 40, expected, expected_len) != 0)", "         goto end;", " ", "     if (IPV6_GET_PLEN(reassembled) != 192)", "         goto end;", " ", "     SCFree(reassembled);", " ", "      ", "     if (defrag_context->frag_pool->outstanding != 0) {", "         printf(\"defrag_context->frag_pool->outstanding %u: \", defrag_context->frag_pool->outstanding);", "         goto end;", "     }", " ", "     ret = 1;", " ", " end:", "     for (i = 0; i < 17; i++) {", "         SCFree(packets[i]);", "     }", "     DefragDestroy();", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int lua_websocket_read(lua_State *L) ", "  {", "      apr_socket_t *sock;", "      apr_status_t rv;", "     int do_read = 1;", "      int n = 0;", "      apr_size_t len = 1;", "      apr_size_t plen = 0;", "     unsigned short payload_short = 0;", "     apr_uint64_t payload_long = 0;", "     unsigned char *mask_bytes;", "     char byte;", "     int plaintext;", "     ", "     ", "     request_rec *r = ap_lua_check_request_rec(L, 1);", "     plaintext = ap_lua_ssl_is_https(r->connection) ? 0 : 1;", " ", "     ", "      mask_bytes = apr_pcalloc(r->pool, 4);", "      sock = ap_get_conn_socket(r->connection);", "  ", "     while (do_read) { ", "     do_read = 0;", "       ", "      if (plaintext) {", "          rv = apr_socket_recv(sock, &byte, &len);", "     }", "     else {", "         rv = lua_websocket_readbytes(r->connection, &byte, 1);", "     }", "     if (rv == APR_SUCCESS) {", "         unsigned char ubyte, fin, opcode, mask, payload;", "         ubyte = (unsigned char)byte;", "          ", "         fin = ubyte >> (CHAR_BIT - 1);", "          ", "         opcode = ubyte & 0xf;", "         ", "          ", "         if (plaintext) {", "             rv = apr_socket_recv(sock, &byte, &len);", "         }", "         else {", "             rv = lua_websocket_readbytes(r->connection, &byte, 1);", "         }", "         if (rv == APR_SUCCESS) {", "             ubyte = (unsigned char)byte;", "              ", "             mask = ubyte >> (CHAR_BIT - 1);", "              ", "             payload = ubyte & 0x7f;", "             plen = payload;", "             ", "              ", "             if (payload == 126) {", "                 len = 2;", "                 if (plaintext) {", "                      ", "                     rv = apr_socket_recv(sock, (char*) &payload_short, &len);", "                 }", "                 else {", "                     rv = lua_websocket_readbytes(r->connection, ", "                         (char*) &payload_short, 2);", "                 }", "                 payload_short = ntohs(payload_short);", "                 ", "                 if (rv == APR_SUCCESS) {", "                     plen = payload_short;", "                 }", "                 else {", "                     return 0;", "                 }", "             }", "              ", "             if (payload == 127) {", "                 len = 8;", "                 if (plaintext) {", "                     rv = apr_socket_recv(sock, (char*) &payload_long, &len);", "                 }", "                 else {", "                     rv = lua_websocket_readbytes(r->connection, ", "                             (char*) &payload_long, 8);", "                 }", "                 if (rv == APR_SUCCESS) {", "                     plen = ap_ntoh64(&payload_long);", "                 }", "                 else {", "                     return 0;", "                 }", "             }", "             ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, ", "                     \"Websocket: Reading %\" APR_SIZE_T_FMT \" (%s) bytes, masking is %s. %s\", ", "                     plen,", "                     (payload >= 126) ? \"extra payload\" : \"no extra payload\", ", "                     mask ? \"on\" : \"off\", ", "                     fin ? \"This is a final frame\" : \"more to follow\");", "             if (mask) {", "                 len = 4;", "                 if (plaintext) {", "                     rv = apr_socket_recv(sock, (char*) mask_bytes, &len);", "                 }", "                 else {", "                     rv = lua_websocket_readbytes(r->connection, ", "                             (char*) mask_bytes, 4);", "                 }", "                 if (rv != APR_SUCCESS) {", "                     return 0;", "                 }", "             }", "             if (plen < (HUGE_STRING_LEN*1024) && plen > 0) {", "                 apr_size_t remaining = plen;", "                 apr_size_t received;", "                 apr_off_t at = 0;", "                 char *buffer = apr_palloc(r->pool, plen+1);", "                 buffer[plen] = 0;", "                 ", "                 if (plaintext) {", "                     while (remaining > 0) {", "                         received = remaining;", "                         rv = apr_socket_recv(sock, buffer+at, &received);", "                         if (received > 0 ) {", "                             remaining -= received;", "                             at += received;", "                         }", "                     }", "                     ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ", "                     \"Websocket: Frame contained %\" APR_OFF_T_FMT \" bytes, pushed to Lua stack\", ", "                         at);", "                 }", "                 else {", "                     rv = lua_websocket_readbytes(r->connection, buffer, ", "                             remaining);", "                     ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ", "                     \"Websocket: SSL Frame contained %\" APR_SIZE_T_FMT \" bytes, \"\\", "                             \"pushed to Lua stack\", ", "                         remaining);", "                 }", "                 if (mask) {", "                     for (n = 0; n < plen; n++) {", "                         buffer[n] ^= mask_bytes[n%4];", "                     }", "                 }", "                 ", "                 lua_pushlstring(L, buffer, (size_t) plen);  ", "                 lua_pushboolean(L, fin);  ", "                 return 2;", "             }", "             ", "             ", "              ", "             if (opcode == 0x09) {  ", "                 char frame[2];", "                 plen = 2;", "                  frame[0] = 0x8A;", "                  frame[1] = 0;", "                  apr_socket_send(sock, frame, &plen);  ", "                lua_websocket_read(L);  ", "                 do_read = 1;", "              }", "          }", "      }", "     }", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static struct mount *clone_mnt(struct mount *old, struct dentry *root,", " \t\t\t\t\tint flag)", " {", " \tstruct super_block *sb = old->mnt.mnt_sb;", " \tstruct mount *mnt;", " \tint err;", " ", " \tmnt = alloc_vfsmnt(old->mnt_devname);", " \tif (!mnt)", " \t\treturn ERR_PTR(-ENOMEM);", " ", " \tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))", " \t\tmnt->mnt_group_id = 0;  ", " \telse", " \t\tmnt->mnt_group_id = old->mnt_group_id;", " ", " \tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {", " \t\terr = mnt_alloc_group_id(mnt);", " \t\tif (err)", " \t\t\tgoto out_free;", " \t}", "  ", "  \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);", "  \t ", "\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))", "\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;", " \tif (flag & CL_UNPRIVILEGED) {", " \t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;", " ", " \t\tif (mnt->mnt.mnt_flags & MNT_READONLY)", " \t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;", " ", " \t\tif (mnt->mnt.mnt_flags & MNT_NODEV)", " \t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;", " ", " \t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)", " \t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;", " ", " \t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)", " \t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;", " \t}", "  ", "  \t ", "  \tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))", " \t\tmnt->mnt.mnt_flags |= MNT_LOCKED;", " ", " \tatomic_inc(&sb->s_active);", " \tmnt->mnt.mnt_sb = sb;", " \tmnt->mnt.mnt_root = dget(root);", " \tmnt->mnt_mountpoint = mnt->mnt.mnt_root;", " \tmnt->mnt_parent = mnt;", " \tlock_mount_hash();", " \tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);", " \tunlock_mount_hash();", " ", " \tif ((flag & CL_SLAVE) ||", " \t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {", " \t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);", " \t\tmnt->mnt_master = old;", " \t\tCLEAR_MNT_SHARED(mnt);", " \t} else if (!(flag & CL_PRIVATE)) {", " \t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))", " \t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);", " \t\tif (IS_MNT_SLAVE(old))", " \t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);", " \t\tmnt->mnt_master = old->mnt_master;", " \t}", " \tif (flag & CL_MAKE_SHARED)", " \t\tset_mnt_shared(mnt);", " ", " \t ", " \tif (flag & CL_EXPIRE) {", " \t\tif (!list_empty(&old->mnt_expire))", " \t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);", " \t}", " ", " \treturn mnt;", " ", "  out_free:", " \tmnt_free_id(mnt);", " \tfree_vfsmnt(mnt);", " \treturn ERR_PTR(err);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static sk_sp<SkImage> premulSkImageToUnPremul(SkImage* input) {", "   SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),", "                                        kN32_SkColorType, kUnpremul_SkAlphaType);", "   RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);", "   if (!dstPixels)", "      return nullptr;", "    return newSkImageFromRaster(", "        info, std::move(dstPixels),", "      static_cast<size_t>(input->width()) * info.bytesPerPixel());", "       static_cast<unsigned>(input->width()) * info.bytesPerPixel());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", " #define CheckOverflowException(length,width,height) \\", "   (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))", " ", "   char", "     *comment;", " ", "   Image", "     *image;", " ", "   IndexPacket", "     index;", " ", "   int", "     x_status;", " ", "   MagickBooleanType", "     authentic_colormap;", " ", "   MagickStatusType", "     status;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   register ssize_t", "     i;", " ", "   register size_t", "     pixel;", " ", "   size_t", "     length;", " ", "   ssize_t", "     count,", "     y;", " ", "   unsigned long", "     lsb_first;", " ", "   XColor", "     *colors;", " ", "   XImage", "     *ximage;", " ", "   XWDFileHeader", "     header;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);", "   if (count != sz_XWDheader)", "     ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");", "    ", "   lsb_first=1;", "   if ((int) (*(char *) &lsb_first) != 0)", "     MSBOrderLong((unsigned char *) &header,sz_XWDheader);", "    ", "   if (header.file_version != XWD_FILE_VERSION)", "     ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");", "   if (header.header_size < sz_XWDheader)", "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "    if ((header.bits_per_pixel == 0) || (header.bits_per_pixel > 32))", "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   if ((header.bitmap_bit_order != MSBFirst) &&", "       (header.bitmap_bit_order != LSBFirst))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "    if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))", "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "    if (header.bitmap_unit > 32)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   if (header.ncolors > 256)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   switch (header.visual_class)", "   {", "     case StaticGray:", "     case GrayScale:", "     case StaticColor:", "     case PseudoColor:", "     case TrueColor:", "     case DirectColor:", "       break;", "     default:", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   }", "   switch (header.pixmap_format)", "   {", "     case XYBitmap:", "     case XYPixmap:", "     case ZPixmap:", "       break;", "     default:", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   }", "   length=(size_t) (header.header_size-sz_XWDheader);", "   if ((length+1) != ((size_t) ((CARD32) (length+1))))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));", "   if (comment == (char *) NULL)", "     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "   count=ReadBlob(image,length,(unsigned char *) comment);", "   comment[length]='\\0';", "   (void) SetImageProperty(image,\"comment\",comment);", "   comment=DestroyString(comment);", "   if (count != (ssize_t) length)", "     ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "    ", "   ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));", "   if (ximage == (XImage *) NULL)", "     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "   ximage->depth=(int) header.pixmap_depth;", "   ximage->format=(int) header.pixmap_format;", "   ximage->xoffset=(int) header.xoffset;", "   ximage->data=(char *) NULL;", "   ximage->width=(int) header.pixmap_width;", "   ximage->height=(int) header.pixmap_height;", "   ximage->bitmap_pad=(int) header.bitmap_pad;", "   ximage->bytes_per_line=(int) header.bytes_per_line;", "   ximage->byte_order=(int) header.byte_order;", "   ximage->bitmap_unit=(int) header.bitmap_unit;", "   ximage->bitmap_bit_order=(int) header.bitmap_bit_order;", "   ximage->bits_per_pixel=(int) header.bits_per_pixel;", "   ximage->red_mask=header.red_mask;", "   ximage->green_mask=header.green_mask;", "   ximage->blue_mask=header.blue_mask;", "   if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || ", "       (ximage->format < 0) || (ximage->byte_order < 0) ||", "       (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||", "       (ximage->bytes_per_line < 0))", "     {", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "   if ((ximage->width > 65535) || (ximage->height > 65535))", "     {", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "   if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))", "     {", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "   x_status=XInitImage(ximage);", "   if (x_status == 0)", "     {", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "     }", "    ", "   authentic_colormap=MagickFalse;", "   colors=(XColor *) NULL;", "   if (header.ncolors != 0)", "     {", "       XWDColor", "         color;", " ", "       length=(size_t) header.ncolors;", "       if (length > ((~0UL)/sizeof(*colors)))", "         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "       colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));", "       if (colors == (XColor *) NULL)", "         {", "           ximage=(XImage *) RelinquishMagickMemory(ximage);", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         }", "       for (i=0; i < (ssize_t) header.ncolors; i++)", "       {", "         count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);", "         if (count != sz_XWDColor)", "           {", "             colors=(XColor *) RelinquishMagickMemory(colors);", "             ximage=(XImage *) RelinquishMagickMemory(ximage);", "             ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "           }", "         colors[i].pixel=color.pixel;", "         colors[i].red=color.red;", "         colors[i].green=color.green;", "         colors[i].blue=color.blue;", "         colors[i].flags=(char) color.flags;", "         if (color.flags != 0)", "           authentic_colormap=MagickTrue;", "       }", "        ", "       lsb_first=1;", "       if ((int) (*(char *) &lsb_first) != 0)", "         for (i=0; i < (ssize_t) header.ncolors; i++)", "         {", "           MSBOrderLong((unsigned char *) &colors[i].pixel,", "             sizeof(colors[i].pixel));", "           MSBOrderShort((unsigned char *) &colors[i].red,3*", "             sizeof(colors[i].red));", "         }", "     }", "    ", "   length=(size_t) ximage->bytes_per_line*ximage->height;", "   if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))", "     {", "       if (header.ncolors != 0)", "         colors=(XColor *) RelinquishMagickMemory(colors);", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "   if (ximage->format != ZPixmap)", "     {", "       size_t", "         extent;", " ", "       extent=length;", "       length*=ximage->depth;", "       if (CheckOverflowException(length,extent,ximage->depth))", "         {", "           if (header.ncolors != 0)", "             colors=(XColor *) RelinquishMagickMemory(colors);", "           ximage=(XImage *) RelinquishMagickMemory(ximage);", "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         }", "     }", "   ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));", "   if (ximage->data == (char *) NULL)", "     {", "       if (header.ncolors != 0)", "         colors=(XColor *) RelinquishMagickMemory(colors);", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "      }", "   count=ReadBlob(image,length,(unsigned char *) ximage->data);", "   if (count != (ssize_t) length)", "     {", "       if (header.ncolors != 0)", "         colors=(XColor *) RelinquishMagickMemory(colors);", "       ximage->data=DestroyString(ximage->data);", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "     }", "    ", "   image->columns=(size_t) ximage->width;", "   image->rows=(size_t) ximage->height;", "   image->depth=8;", "   status=SetImageExtent(image,image->columns,image->rows);", "   if (status == MagickFalse)", "     {", "       if (header.ncolors != 0)", "         colors=(XColor *) RelinquishMagickMemory(colors);", "       ximage->data=DestroyString(ximage->data);", "       ximage=(XImage *) RelinquishMagickMemory(ximage);", "       InheritException(exception,&image->exception);", "       return(DestroyImageList(image));", "     }", "   if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||", "       (ximage->green_mask != 0) || (ximage->blue_mask != 0))", "     image->storage_class=DirectClass;", "   else", "     image->storage_class=PseudoClass;", "   image->colors=header.ncolors;", "   if (image_info->ping == MagickFalse)", "     switch (image->storage_class)", "     {", "       case DirectClass:", "       default:", "       {", "         register size_t", "           color;", " ", "         size_t", "           blue_mask,", "           blue_shift,", "           green_mask,", "           green_shift,", "           red_mask,", "           red_shift;", " ", "          ", "         red_mask=ximage->red_mask;", "         red_shift=0;", "         while ((red_mask != 0) && ((red_mask & 0x01) == 0))", "         {", "           red_mask>>=1;", "           red_shift++;", "         }", "         green_mask=ximage->green_mask;", "         green_shift=0;", "         while ((green_mask != 0) && ((green_mask & 0x01) == 0))", "         {", "           green_mask>>=1;", "           green_shift++;", "         }", "         blue_mask=ximage->blue_mask;", "         blue_shift=0;", "         while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))", "         {", "           blue_mask>>=1;", "           blue_shift++;", "         }", "          ", "         if ((image->colors != 0) && (authentic_colormap != MagickFalse))", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (PixelPacket *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               pixel=XGetPixel(ximage,(int) x,(int) y);", "               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>", "                 red_shift) & red_mask);", "               SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));", "               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>", "                 green_shift) & green_mask);", "               SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)", "                 index].green));", "               index=ConstrainColormapIndex(image,(ssize_t) (pixel >>", "                 blue_shift) & blue_mask);", "               SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t) index].blue));", "               q++;", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "               image->rows);", "             if (status == MagickFalse)", "               break;", "           }", "         else", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (PixelPacket *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               pixel=XGetPixel(ximage,(int) x,(int) y);", "               color=(pixel >> red_shift) & red_mask;", "               if (red_mask != 0)", "                 color=(color*65535UL)/red_mask;", "               SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));", "               color=(pixel >> green_shift) & green_mask;", "               if (green_mask != 0)", "                 color=(color*65535UL)/green_mask;", "               SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));", "               color=(pixel >> blue_shift) & blue_mask;", "               if (blue_mask != 0)", "                 color=(color*65535UL)/blue_mask;", "               SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));", "               q++;", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "               image->rows);", "             if (status == MagickFalse)", "               break;", "           }", "         break;", "       }", "       case PseudoClass:", "       {", "          ", "         if (AcquireImageColormap(image,image->colors) == MagickFalse)", "           {", "             if (header.ncolors != 0)", "               colors=(XColor *) RelinquishMagickMemory(colors);", "             ximage->data=DestroyString(ximage->data);", "             ximage=(XImage *) RelinquishMagickMemory(ximage);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         for (i=0; i < (ssize_t) image->colors; i++)", "         {", "           image->colormap[i].red=ScaleShortToQuantum(colors[i].red);", "           image->colormap[i].green=ScaleShortToQuantum(colors[i].green);", "           image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);", "         }", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (PixelPacket *) NULL)", "             break;", "           indexes=GetAuthenticIndexQueue(image);", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             index=ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int)", "               x,(int) y));", "             SetPixelIndex(indexes+x,index);", "             SetPixelRGBO(q,image->colormap+(ssize_t) index);", "             q++;", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "             image->rows);", "           if (status == MagickFalse)", "             break;", "         }", "         break;", "       }", "     }", "    ", "   if (header.ncolors != 0)", "     colors=(XColor *) RelinquishMagickMemory(colors);", "   ximage->data=DestroyString(ximage->data);", "   ximage=(XImage *) RelinquishMagickMemory(ximage);", "   if (EOFBlob(image) != MagickFalse)", "     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "       image->filename);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int dns_read_name(unsigned char *buffer, unsigned char *bufend,", "                   unsigned char *name, char *destination, int dest_len,", "                 int *offset)", "                  int *offset, unsigned int depth)", "  {", "         int nb_bytes = 0, n = 0;", "         int label_len;", " \tunsigned char *reader = name;", " \tchar *dest = destination;", " ", " \twhile (1) {", " \t\t ", " \t\tif ((*reader & 0xc0) == 0xc0) {", " \t\t\t ", "                         if ((buffer + reader[1]) > reader)", "                                 goto err;", "  ", "                        if (depth++ > 100)", "                                goto err;", " ", "                         n = dns_read_name(buffer, bufend, buffer + reader[1],", "                                         dest, dest_len - nb_bytes, offset);", "                                          dest, dest_len - nb_bytes, offset, depth);", "                         if (n == 0)", "                                 goto err;", "  ", " \t\t}", " ", " \t\tlabel_len = *reader;", " \t\tif (label_len == 0)", " \t\t\tgoto out;", " ", " \t\t ", " \t\tif ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))", " \t\t\tgoto err;", " ", " \t\t ", " \t\tlabel_len++;", " ", " \t\tmemcpy(dest, reader, label_len);", " ", " \t\tdest     += label_len;", " \t\tnb_bytes += label_len;", " \t\treader   += label_len;", " \t}", " ", "   out:", " \t ", " \treader  = name;", " \t*offset = 0;", " \twhile (reader < bufend) {", " \t\tif ((reader[0] & 0xc0) == 0xc0) {", " \t\t\t*offset += 2;", " \t\t\tbreak;", " \t\t}", " \t\telse if (*reader == 0) {", " \t\t\t*offset += 1;", " \t\t\tbreak;", " \t\t}", " \t\t*offset += 1;", " \t\t++reader;", " \t}", " \treturn nb_bytes;", " ", "   err:", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool AppCacheBackendImpl::SelectCacheForWorker(", "      int host_id, int parent_process_id, int parent_host_id) {", "    AppCacheHost* host = GetHost(host_id);", "  if (!host || host->was_select_cache_called())", "   if (!host)", "      return false;", "  ", "  host->SelectCacheForWorker(parent_process_id, parent_host_id);", "  return true;", "   return host->SelectCacheForWorker(parent_process_id, parent_host_id);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0]}
{"tokens": [" static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", "   char", "     filename[MagickPathExtent];", " ", "   FILE", "     *file;", " ", "   Image", "     *image,", "     *next_image,", "     *pwp_image;", " ", "   ImageInfo", "     *read_info;", " ", "   int", "     c,", "     unique_file;", " ", "   MagickBooleanType", "     status;", " ", "   register Image", "     *p;", " ", "   register ssize_t", "     i;", " ", "   size_t", "     filesize,", "     length;", " ", "   ssize_t", "     count;", " ", "   unsigned char", "     magick[MagickPathExtent];", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImage(image);", "       return((Image *) NULL);", "     }", "   pwp_image=image;", "   memset(magick,0,sizeof(magick));", "   count=ReadBlob(pwp_image,5,magick);", "   if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   read_info=CloneImageInfo(image_info);", "   (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,", "     (void *) NULL);", "   SetImageInfoBlob(read_info,(void *) NULL,0);", "   unique_file=AcquireUniqueFileResource(filename);", "   (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",", "     filename);", "   for ( ; ; )", "   {", "     (void) memset(magick,0,sizeof(magick));", "     for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))", "     {", "       for (i=0; i < 17; i++)", "         magick[i]=magick[i+1];", "       magick[17]=(unsigned char) c;", "       if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)", "         break;", "     }", "     if (c == EOF)", "       {", "         (void) RelinquishUniqueFileResource(filename);", "         read_info=DestroyImageInfo(read_info);", "         ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "       }", "     if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)", "       {", "         (void) RelinquishUniqueFileResource(filename);", "         read_info=DestroyImageInfo(read_info);", "         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "       }", "      ", "     file=(FILE *) NULL;", "     if (unique_file != -1)", "       file=fdopen(unique_file,\"wb\");", "     if ((unique_file == -1) || (file == (FILE *) NULL))", "       {", "         (void) RelinquishUniqueFileResource(filename);", "         read_info=DestroyImageInfo(read_info);", "         ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",", "           image->filename);", "         image=DestroyImageList(image);", "         return((Image *) NULL);", "       }", "     length=fwrite(\"SFW94A\",1,6,file);", "     (void) length;", "     filesize=65535UL*magick[2]+256L*magick[1]+magick[0];", "     for (i=0; i < (ssize_t) filesize; i++)", "     {", "        c=ReadBlobByte(pwp_image);", "        if (c == EOF)", "          break;", "      (void) fputc(c,file);", "       if (fputc(c,file) != c)", "         break;", "      }", "      (void) fclose(file);", "      if (c == EOF)", "       {", "         (void) RelinquishUniqueFileResource(filename);", "         read_info=DestroyImageInfo(read_info);", "         ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "       }", "     next_image=ReadImage(read_info,exception);", "     if (next_image == (Image *) NULL)", "       break;", "     (void) FormatLocaleString(next_image->filename,MagickPathExtent,", "       \"slide_%02ld.sfw\",(long) next_image->scene);", "     if (image == (Image *) NULL)", "       image=next_image;", "     else", "       {", "          ", "         for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;", "         next_image->previous=p;", "         next_image->scene=p->scene+1;", "         p->next=next_image;", "       }", "     if (image_info->number_scenes != 0)", "       if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),", "       GetBlobSize(pwp_image));", "     if (status == MagickFalse)", "       break;", "   }", "   if (unique_file != -1)", "     (void) close(unique_file);", "   (void) RelinquishUniqueFileResource(filename);", "   read_info=DestroyImageInfo(read_info);", "   if (image != (Image *) NULL)", "     {", "       if (EOFBlob(image) != MagickFalse)", "         {", "           char", "             *message;", " ", "           message=GetExceptionMessage(errno);", "           (void) ThrowMagickException(exception,GetMagickModule(),", "             CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,", "             message);", "           message=DestroyString(message);", "         }", "       (void) CloseBlob(image);", "     }", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ext4_orphan_add(handle_t *handle, struct inode *inode)", " {", " \tstruct super_block *sb = inode->i_sb;", "  \tstruct ext4_iloc iloc;", "  \tint err = 0, rc;", "  ", "\tif (!ext4_handle_valid(handle))", " \tif (!EXT4_SB(sb)->s_journal)", "  \t\treturn 0;", "  ", "  \tmutex_lock(&EXT4_SB(sb)->s_orphan_lock);", " \tif (!list_empty(&EXT4_I(inode)->i_orphan))", " \t\tgoto out_unlock;", " ", " \t ", " \tJ_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||", " \t\t  S_ISLNK(inode->i_mode)) || inode->i_nlink == 0);", " ", " \tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");", " \terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);", " \tif (err)", " \t\tgoto out_unlock;", " ", " \terr = ext4_reserve_inode_write(handle, inode, &iloc);", " \tif (err)", " \t\tgoto out_unlock;", " \t ", " \tif (NEXT_ORPHAN(inode) && NEXT_ORPHAN(inode) <=", " \t\t(le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count)))", " \t\t\tgoto mem_insert;", " ", " \t ", " \tNEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)->s_es->s_last_orphan);", " \tEXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino);", " \terr = ext4_handle_dirty_super(handle, sb);", " \trc = ext4_mark_iloc_dirty(handle, inode, &iloc);", " \tif (!err)", " \t\terr = rc;", " ", " \t ", " mem_insert:", " \tif (!err)", " \t\tlist_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan);", " ", " \tjbd_debug(4, \"superblock will point to %lu\\n\", inode->i_ino);", " \tjbd_debug(4, \"orphan inode %lu will point to %d\\n\",", " \t\t\tinode->i_ino, NEXT_ORPHAN(inode));", " out_unlock:", " \tmutex_unlock(&EXT4_SB(sb)->s_orphan_lock);", " \text4_std_error(inode->i_sb, err);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,", " \t\t\tint len)", " {", " \tint r;", " \tunsigned long addr;", " ", "  \taddr = gfn_to_hva(kvm, gfn);", "  \tif (kvm_is_error_hva(addr))", "  \t\treturn -EFAULT;", "\tr = copy_from_user(data, (void __user *)addr + offset, len);", " \tr = __copy_from_user(data, (void __user *)addr + offset, len);", "  \tif (r)", "  \t\treturn -EFAULT;", "  \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" status_t OMXNodeInstance::setConfig(", "         OMX_INDEXTYPE index, const void *params, size_t size) {", "  Mutex::Autolock autoLock(mLock);", " ", "      OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;", "      CLOG_CONFIG(setConfig, \"%s(%#x), %zu@%p)\", asString(extIndex), index, size, params);", "  ", "     if (isProhibitedIndex_l(index)) {", "         android_errorWriteLog(0x534e4554, \"29422020\");", "         return BAD_INDEX;", "     }", " ", "      OMX_ERRORTYPE err = OMX_SetConfig(", "              mHandle, index, const_cast<void *>(params));", "      CLOG_IF_ERROR(setConfig, err, \"%s(%#x)\", asString(extIndex), index);", "  return StatusFromOMXError(err);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" int _mkp_stage_30(struct plugin *p,", "         struct client_session *cs,", "         struct session_request *sr)", " {", "     mk_ptr_t referer;", "     (void) p;", "      (void) cs;", "  ", "      PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);", "    if (mk_security_check_url(sr->uri) < 0) {", " ", "     if (mk_security_check_url(sr->uri_processed) < 0) {", "          PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);", "          mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);", "          return MK_PLUGIN_RET_CLOSE_CONX;", "     }", " ", "     PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);", "     referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));", "     if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {", "         PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);", "         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);", "         return MK_PLUGIN_RET_CLOSE_CONX;", "     }", " ", "     return MK_PLUGIN_RET_NOT_ME;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(", "     const String& source,", "     Document* owner_document) {", "   Document* document = frame_->GetDocument();", "   if (!document_loader_ ||", "       document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)", "     return;", " ", "   UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);", " ", "   const KURL& url = document->Url();", "  ", "    ", "    ", "    ", "    ", "    WebGlobalObjectReusePolicy global_object_reuse_policy =", "      frame_->ShouldReuseDefaultView(url)", "       frame_->ShouldReuseDefaultView(url, document->GetContentSecurityPolicy())", "            ? WebGlobalObjectReusePolicy::kUseExisting", "            : WebGlobalObjectReusePolicy::kCreateNew;", "  ", "   StopAllLoaders();", "   SubframeLoadingDisabler disabler(document);", "   frame_->DetachChildren();", " ", "   if (!frame_->IsAttached() || document != frame_->GetDocument())", "     return;", " ", "   frame_->GetDocument()->Shutdown();", "   Client()->TransitionToCommittedForNewPage();", "   document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(", "       url, owner_document, global_object_reuse_policy, source);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool ResourcePrefetchPredictor::PredictPreconnectOrigins(", "     const GURL& url,", "     PreconnectPrediction* prediction) const {", "   DCHECK(!prediction || prediction->requests.empty());", "   DCHECK_CURRENTLY_ON(BrowserThread::UI);", "   if (initialization_state_ != INITIALIZED)", "     return false;", " ", "   url::Origin url_origin = url::Origin::Create(url);", "   url::Origin redirect_origin;", "   bool has_any_prediction = GetRedirectEndpointsForPreconnect(", "       url_origin, *host_redirect_data_, prediction);", "   if (!GetRedirectOrigin(url_origin, *host_redirect_data_, &redirect_origin)) {", "     return has_any_prediction;", "   }", " ", "   OriginData data;", "   if (!origin_data_->TryGetData(redirect_origin.host(), &data)) {", "     return has_any_prediction;", "   }", " ", "   if (prediction) {", "     prediction->host = redirect_origin.host();", "     prediction->is_redirected = (redirect_origin != url_origin);", "   }", " ", "   net::NetworkIsolationKey network_isolation_key(redirect_origin,", "                                                  redirect_origin);", " ", "   for (const OriginStat& origin : data.origins()) {", "     float confidence = static_cast<float>(origin.number_of_hits()) /", "                        (origin.number_of_hits() + origin.number_of_misses());", "     if (confidence < kMinOriginConfidenceToTriggerPreresolve)", "       continue;", " ", "      has_any_prediction = true;", "      if (prediction) {", "        if (confidence > kMinOriginConfidenceToTriggerPreconnect) {", "        prediction->requests.emplace_back(GURL(origin.origin()), 1,", "                                          network_isolation_key);", "         prediction->requests.emplace_back(", "             url::Origin::Create(GURL(origin.origin())), 1,", "             network_isolation_key);", "        } else {", "        prediction->requests.emplace_back(GURL(origin.origin()), 0,", "                                          network_isolation_key);", "         prediction->requests.emplace_back(", "             url::Origin::Create(GURL(origin.origin())), 0,", "             network_isolation_key);", "        }", "      }", "    }", " ", "   return has_any_prediction;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,", " \t\t\t\t      unsigned long resolution,", " \t\t\t\t      unsigned long ticks)", " {", " \tstruct snd_timer_user *tu = timeri->callback_data;", " \tstruct snd_timer_tread *r, r1;", " \tstruct timespec tstamp;", " \tint prev, append = 0;", " ", " \tmemset(&tstamp, 0, sizeof(tstamp));", " \tspin_lock(&tu->qlock);", " \tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |", " \t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {", " \t\tspin_unlock(&tu->qlock);", " \t\treturn;", " \t}", " \tif (tu->last_resolution != resolution || ticks > 0) {", " \t\tif (timer_tstamp_monotonic)", " \t\t\tktime_get_ts(&tstamp);", " \t\telse", " \t\t\tgetnstimeofday(&tstamp);", "  \t}", "  \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&", "  \t    tu->last_resolution != resolution) {", " \t\tmemset(&r1, 0, sizeof(r1));", "  \t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;", "  \t\tr1.tstamp = tstamp;", "  \t\tr1.val = resolution;", " \t\tsnd_timer_user_append_to_tqueue(tu, &r1);", " \t\ttu->last_resolution = resolution;", " \t\tappend++;", " \t}", " \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)", " \t\tgoto __wake;", " \tif (ticks == 0)", " \t\tgoto __wake;", " \tif (tu->qused > 0) {", " \t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;", " \t\tr = &tu->tqueue[prev];", " \t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {", " \t\t\tr->tstamp = tstamp;", " \t\t\tr->val += ticks;", " \t\t\tappend++;", " \t\t\tgoto __wake;", " \t\t}", " \t}", " \tr1.event = SNDRV_TIMER_EVENT_TICK;", " \tr1.tstamp = tstamp;", " \tr1.val = ticks;", " \tsnd_timer_user_append_to_tqueue(tu, &r1);", " \tappend++;", "       __wake:", " \tspin_unlock(&tu->qlock);", " \tif (append == 0)", " \t\treturn;", " \tkill_fasync(&tu->fasync, SIGIO, POLL_IN);", " \twake_up(&tu->qchange_sleep);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void CheckClientDownloadRequest::UploadBinary(", "     DownloadCheckResult result,", "     DownloadCheckResultReason reason) {", "   saved_result_ = result;", "   saved_reason_ = reason;", " ", "   bool upload_for_dlp = ShouldUploadForDlpScan();", "   bool upload_for_malware = ShouldUploadForMalwareScan(reason);", "   auto request = std::make_unique<DownloadItemRequest>(", "       item_,  true,", "       base::BindOnce(&CheckClientDownloadRequest::OnDeepScanningComplete,", "                      weakptr_factory_.GetWeakPtr()));", " ", "   Profile* profile = Profile::FromBrowserContext(GetBrowserContext());", " ", "   if (upload_for_dlp) {", "     DlpDeepScanningClientRequest dlp_request;", "     dlp_request.set_content_source(DlpDeepScanningClientRequest::FILE_DOWNLOAD);", "     request->set_request_dlp_scan(std::move(dlp_request));", "   }", " ", "   if (upload_for_malware) {", "     MalwareDeepScanningClientRequest malware_request;", "     malware_request.set_population(", "         MalwareDeepScanningClientRequest::POPULATION_ENTERPRISE);", "     malware_request.set_download_token(", "         DownloadProtectionService::GetDownloadPingToken(item_));", "      request->set_request_malware_scan(std::move(malware_request));", "    }", "  ", "  request->set_dm_token(", "      policy::BrowserDMTokenStorage::Get()->RetrieveDMToken());", "   auto dm_token = BrowserDMTokenStorage::Get()->RetrieveBrowserDMToken();", "   DCHECK(dm_token.is_valid());", "   request->set_dm_token(dm_token.value());", "  ", "    service()->UploadForDeepScanning(profile, std::move(request));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )", " {", "     int ret;", "     const mbedtls_ssl_ciphersuite_t *ciphersuite_info =", "         ssl->transform_negotiate->ciphersuite_info;", "     unsigned char *p = NULL, *end = NULL;", " ", "     MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );", " ", " #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );", "         ssl->state++;", "         return( 0 );", "     }", "     ((void) p);", "     ((void) end);", " #endif", " ", " #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\", "     defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )", "     {", "         if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )", "         {", "             MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );", "             return( ret );", "         }", " ", "         MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );", "         ssl->state++;", "         return( 0 );", "     }", "     ((void) p);", "     ((void) end);", " #endif  ", " ", "     if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )", "     {", "         MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );", "         return( ret );", "     }", " ", "     if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );", "         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );", "     }", " ", "      ", "     if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )", "     {", "         if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||", "             ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )", "         {", "              ", "             ssl->keep_current_message = 1;", "             goto exit;", "         }", " ", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"", "                                     \"not be skipped\" ) );", "         mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                         MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );", " ", "         return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );", "     }", " ", "     p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );", "     end = ssl->in_msg + ssl->in_hslen;", "     MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );", " ", " #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )", "     {", "         if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", "     }  ", " #endif  ", " ", " #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\", "     defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )", "         ;  ", "     else", " #endif  ", " #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\", "     defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )", "     {", "         if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", "     }", "     else", " #endif  ", " #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\", "     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\", "     defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||", "         ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )", "     {", "         if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", "     }", "     else", " #endif  ", " #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)", "     if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )", "     {", "         ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,", "                                               p, end - p );", "         if( ret != 0 )", "         {", "             MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", "     }", "     else", " #endif  ", "     {", "         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );", "         return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );", "     }", " ", " #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)", "     if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )", "     {", "         size_t sig_len, hashlen;", "         unsigned char hash[64];", "         mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;", "         mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;", "         unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );", "         size_t params_len = p - params;", " ", "          ", " #if defined(MBEDTLS_SSL_PROTO_TLS1_2)", "         if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )", "         {", "             if( ssl_parse_signature_algorithm( ssl, &p, end,", "                                                &md_alg, &pk_alg ) != 0 )", "             {", "                 MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "                 mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "                 return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "             }", " ", "             if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )", "             {", "                 MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "                 mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                                 MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );", "                 return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "             }", "         }", "         else", " #endif  ", " #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\", "     defined(MBEDTLS_SSL_PROTO_TLS1_1)", "         if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )", "         {", "             pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );", " ", "              ", "             if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )", "                 md_alg = MBEDTLS_MD_SHA1;", "         }", "         else", " #endif", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );", "             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );", "         }", " ", "          ", " ", "         if( p > end - 2 )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", "          sig_len = ( p[0] << 8 ) | p[1];", "          p += 2;", "  ", "        if( end != p + sig_len )", "         if( p != end - sig_len )", "          {", "              MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "              mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );", "             return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );", "         }", " ", "         MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );", " ", "          ", " #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\", "     defined(MBEDTLS_SSL_PROTO_TLS1_1)", "         if( md_alg == MBEDTLS_MD_NONE )", "         {", "             hashlen = 36;", "             ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,", "                                                            params_len );", "             if( ret != 0 )", "                 return( ret );", "         }", "         else", " #endif  ", " #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\", "     defined(MBEDTLS_SSL_PROTO_TLS1_2)", "         if( md_alg != MBEDTLS_MD_NONE )", "         {", "              ", "             hashlen = 0;", "             ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,", "                                                           params_len, md_alg );", "             if( ret != 0 )", "                 return( ret );", "         }", "         else", " #endif  ", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );", "             return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );", "         }", " ", "         MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :", "             (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );", " ", "         if( ssl->session_negotiate->peer_cert == NULL )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );", "             return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );", "         }", " ", "          ", "         if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )", "         {", "             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );", "             return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );", "         }", " ", "         if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,", "                                md_alg, hash, hashlen, p, sig_len ) ) != 0 )", "         {", "             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,", "                                             MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );", "             MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );", "             return( ret );", "         }", "     }", " #endif  ", " ", " exit:", "     ssl->state++;", " ", "     MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );", " ", "     return( 0 );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int read_tfra(MOVContext *mov, AVIOContext *f)", " {", "     MOVFragmentIndex* index = NULL;", "     int version, fieldlength, i, j;", "     int64_t pos = avio_tell(f);", "     uint32_t size = avio_rb32(f);", "     void *tmp;", " ", "     if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {", "         return 1;", "     }", "     av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");", "     index = av_mallocz(sizeof(MOVFragmentIndex));", "     if (!index) {", "         return AVERROR(ENOMEM);", "     }", " ", "     tmp = av_realloc_array(mov->fragment_index_data,", "                            mov->fragment_index_count + 1,", "                            sizeof(MOVFragmentIndex*));", "     if (!tmp) {", "         av_freep(&index);", "         return AVERROR(ENOMEM);", "     }", "     mov->fragment_index_data = tmp;", "     mov->fragment_index_data[mov->fragment_index_count++] = index;", " ", "     version = avio_r8(f);", "     avio_rb24(f);", "     index->track_id = avio_rb32(f);", "     fieldlength = avio_rb32(f);", "     index->item_count = avio_rb32(f);", "     index->items = av_mallocz_array(", "             index->item_count, sizeof(MOVFragmentIndexItem));", "     if (!index->items) {", "         index->item_count = 0;", "         return AVERROR(ENOMEM);", "      }", "      for (i = 0; i < index->item_count; i++) {", "          int64_t time, offset;", " ", "         if (avio_feof(f)) {", "             index->item_count = 0;", "             av_freep(&index->items);", "             return AVERROR_INVALIDDATA;", "         }", " ", "          if (version == 1) {", "              time   = avio_rb64(f);", "              offset = avio_rb64(f);", "         } else {", "             time   = avio_rb32(f);", "             offset = avio_rb32(f);", "         }", "         index->items[i].time = time;", "         index->items[i].moof_offset = offset;", "         for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)", "             avio_r8(f);", "         for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)", "             avio_r8(f);", "         for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)", "             avio_r8(f);", "     }", " ", "     avio_seek(f, pos + size, SEEK_SET);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["file_rlookup(const char *filename)", "{", "int  i;", "cache_t *wc;", "", "", "for (i = web_files, wc = web_cache; i > 0; i --, wc ++)", "if (!strcmp(wc->name, filename))", "return (wc->url);", "", "return (filename);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["  load_fake(png_charp param, png_bytepp profile)", "  {", "     char *endptr = NULL;", "   unsigned long long int size = strtoull(param, &endptr, 0 );", "    uint64_t size = strtoull(param, &endptr, 0 );", "  ", "      ", "     if (endptr != NULL && *endptr == '*')", "  {", "  size_t len = strlen(++endptr);", "  size_t result = (size_t)size;", " ", "  if (len == 0) len = 1;  ", " ", "   ", "  if (result == size && (*profile = malloc(result)) != NULL)", "  {", "          png_bytep out = *profile;", " ", "  if (len == 1)", "             memset(out, *endptr, result);", " ", "  else", "  {", "  while (size >= len)", "  {", "                memcpy(out, endptr, len);", "                out += len;", "                size -= len;", "  }", "             memcpy(out, endptr, size);", "  }", " ", "  return result;", "  }", " ", "  else", "  {", "          fprintf(stderr, \"%s: size exceeds system limits\\n\", param);", "          exit(1);", "  }", "  }", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static char *parse_note(char *p,", "int flags)", "{", "struct SYMBOL *s;", "char *q;", "int pit = 0, len, acc, nostem, chord, j, m, n;", "", "if (flags & ABC_F_GRACE) {", "s = abc_new(ABC_T_NOTE, NULL);", "} else {", "s = abc_new(ABC_T_NOTE, gchord);", "if (gchord)", "gchord = NULL;", "}", "s->flags |= flags;", "s->u.note.notes[0].color = -1;", "", "if (!lyric_started) {", "lyric_started = 1;", "s->flags |= ABC_F_LYRIC_START;", "}", "if (*p != 'X' && *p != 'Z'", "&& !(flags & ABC_F_GRACE)) {", "if (!deco_start)", "deco_start = s;", "}", "chord = 0;", "", "", "switch (*p) {", "case 'X':", "s->flags |= ABC_F_INVIS;", "case 'Z':", "s->abc_type = ABC_T_MREST;", "p++;", "len = 1;", "if (isdigit((unsigned char) *p)) {", "len = strtol(p, &q, 10);", "if (len == 0 || len > 100) {", "syntax(\"Bad number of measures\", p);", "len = 1;", "}", "p = q;", "}", "s->u.bar.type = 0;", "s->u.bar.len = len;", "goto add_deco;", "case 'y':", "s->abc_type = ABC_T_REST;", "s->flags |= ABC_F_INVIS;", "p++;", "if (isdigit((unsigned char) *p)", "|| *p == '-') {", "s->u.note.notes[0].shhd = strtol(p, &q, 10);", "p = q;", "} else {", "s->u.note.notes[0].shhd = 10;", "}", "goto add_deco;", "case 'x':", "s->flags |= ABC_F_INVIS;", "", "case 'z':", "s->abc_type = ABC_T_REST;", "p = parse_len(p + 1, ulen, &len);", "s->u.note.notes[0].len = len;", "goto do_brhythm;", "case '[':", "chord = 1;", "p++;", "break;", "}", "", "q = p;", "", "", "m = 0;", "nostem = 0;", "for (;;) {", "if (chord) {", "if (m >= MAXHD) {", "syntax(\"Too many notes in chord\", p);", "m--;", "}", "n = 0;", "if (*p == '.') {", "n = SL_DOTTED;", "p++;", "}", "if (*p == '(') {", "p++;", "switch (*p) {", "case '\\'':", "n += SL_ABOVE;", "p++;", "break;", "case ',':", "n += SL_BELOW;", "p++;", "break;", "default:", "n += SL_AUTO;", "break;", "}", "s->u.note.notes[m].sl1 = (s->u.note.notes[m].sl1 << 3)", "+ n;", "}", "}", "p = parse_deco(p, &dc, m);", "p = parse_acc_pit(p, &pit, &acc);", "if (*p == '0') {", "nostem = 1;", "p++;", "}", "p = parse_len(p, (flags & ABC_F_GRACE) ?", "BASE_LEN / 8 :", "ulen,", "&len);", "s->u.note.notes[m].pit = pit;", "s->pits[m] = pit;", "s->u.note.notes[m].len = len;", "s->u.note.notes[m].acc = acc;", "s->u.note.notes[m].color = -1;", "", "if (chord) {", "for (;;) {", "if (*p == '.') {", "if (p[1] != '-')", "break;", "p++;", "}", "if (*p == '-') {", "switch (p[1]) {", "case '\\'':", "s->u.note.notes[m].ti1 = SL_ABOVE;", "p++;", "break;", "case ',':", "s->u.note.notes[m].ti1 = SL_BELOW;", "p++;", "break;", "default:", "s->u.note.notes[m].ti1 = SL_AUTO;", "break;", "}", "} else if (*p == ')') {", "s->u.note.notes[m].sl2++;", "} else {", "break;", "}", "p++;", "}", "}", "if (acc >= 0)", "m++;", "", "if (!chord)", "break;", "if (*p == ']') {", "p++;", "if (*p == '0') {", "nostem = 1;", "p++;", "}", "if (*p == '/' || isdigit((unsigned char) *p)) {", "p = parse_len(p, ulen, &len);", "for (j = 0; j < m; j++) {", "s->u.note.notes[j].len =", "len * s->u.note.notes[j].len / ulen;", "}", "}", "break;", "}", "if (*p == '\\0') {", "syntax(\"Chord not closed\", q);", "break;", "}", "}", "if (nostem)", "s->flags |= ABC_F_STEMLESS;", "", "if (m == 0)", "goto err;", "", "s->u.note.microscale = microscale;", "s->nhd = m - 1;", "", "do_brhythm:", "if (curvoice->last_note", "&& curvoice->last_note->u.note.brhythm != 0)", "broken_rhythm(s, -curvoice->last_note->u.note.brhythm);", "add_deco:", "if (dc.n > 0) {", "memcpy(s->abc_type != ABC_T_MREST ? &s->u.note.dc", ": &s->u.bar.dc,", "&dc, sizeof dc);", "dc.n = 0;", "}", "", "", "if (s->abc_type != ABC_T_NOTE && (flags & ABC_F_GRACE)) {", "syntax(\"Not a note in grace note sequence\", p);", "goto err;", "}", "return p;", "", "err:", "if ((parse.last_sym = s->abc_prev) == NULL) {", "parse.first_sym = NULL;", "} else {", "s->abc_prev->abc_next = NULL;", "s->abc_prev->flags |= (s->flags & ABC_F_ERROR);", "}", "return p;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    virtual void CancelHandwritingStrokes(int stroke_count) {", "      if (!initialized_successfully_)", "        return;", "    chromeos::CancelHandwriting(input_method_status_connection_, stroke_count);", "     ibus_controller_->CancelHandwriting(stroke_count);", "    }"], "ner_tags": [0, 0, 0, 1, 1, 0]}
{"tokens": ["int ldbRepl(lua_State *lua) {", "sds *argv;", "int argc;", "", "", "", "while(1) {", "while((argv = ldbReplParseCommand(&argc)) == NULL) {", "char buf[1024];", "int nread = connRead(ldb.conn,buf,sizeof(buf));", "if (nread <= 0) {", "", "", "ldb.step = 0;", "ldb.bpcount = 0;", "return C_ERR;", "}", "ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);", "}", "", "", "sdsfree(ldb.cbuf);", "ldb.cbuf = sdsempty();", "", "", "if (!strcasecmp(argv[0],\"h\") || !strcasecmp(argv[0],\"help\")) {", "ldbLog(sdsnew(\"Redis Lua debugger help:\"));", "ldbLog(sdsnew(\"[h]elp               Show this help.\"));", "ldbLog(sdsnew(\"[s]tep               Run current line and stop again.\"));", "ldbLog(sdsnew(\"[n]ext               Alias for step.\"));", "ldbLog(sdsnew(\"[c]continue          Run till next breakpoint.\"));", "ldbLog(sdsnew(\"[l]list              List source code around current line.\"));", "ldbLog(sdsnew(\"[l]list [line]       List source code around [line].\"));", "ldbLog(sdsnew(\"                     line = 0 means: current position.\"));", "ldbLog(sdsnew(\"[l]list [line] [ctx] In this form [ctx] specifies how many lines\"));", "ldbLog(sdsnew(\"                     to show before/after [line].\"));", "ldbLog(sdsnew(\"[w]hole              List all source code. Alias for 'list 1 1000000'.\"));", "ldbLog(sdsnew(\"[p]rint              Show all the local variables.\"));", "ldbLog(sdsnew(\"[p]rint <var>        Show the value of the specified variable.\"));", "ldbLog(sdsnew(\"                     Can also show global vars KEYS and ARGV.\"));", "ldbLog(sdsnew(\"[b]reak              Show all breakpoints.\"));", "ldbLog(sdsnew(\"[b]reak <line>       Add a breakpoint to the specified line.\"));", "ldbLog(sdsnew(\"[b]reak -<line>      Remove breakpoint from the specified line.\"));", "ldbLog(sdsnew(\"[b]reak 0            Remove all breakpoints.\"));", "ldbLog(sdsnew(\"[t]race              Show a backtrace.\"));", "ldbLog(sdsnew(\"[e]eval <code>       Execute some Lua code (in a different callframe).\"));", "ldbLog(sdsnew(\"[r]edis <cmd>        Execute a Redis command.\"));", "ldbLog(sdsnew(\"[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\"));", "ldbLog(sdsnew(\"                     Specifying zero as <len> means unlimited.\"));", "ldbLog(sdsnew(\"[a]bort              Stop the execution of the script. In sync\"));", "ldbLog(sdsnew(\"                     mode dataset changes will be retained.\"));", "ldbLog(sdsnew(\"\"));", "ldbLog(sdsnew(\"Debugger functions you can call from Lua scripts:\"));", "ldbLog(sdsnew(\"redis.debug()        Produce logs in the debugger console.\"));", "ldbLog(sdsnew(\"redis.breakpoint()   Stop execution like if there was a breakpoint in the\"));", "ldbLog(sdsnew(\"                     next line of code.\"));", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"s\") || !strcasecmp(argv[0],\"step\") ||", "!strcasecmp(argv[0],\"n\") || !strcasecmp(argv[0],\"next\")) {", "ldb.step = 1;", "break;", "} else if (!strcasecmp(argv[0],\"c\") || !strcasecmp(argv[0],\"continue\")){", "break;", "} else if (!strcasecmp(argv[0],\"t\") || !strcasecmp(argv[0],\"trace\")) {", "ldbTrace(lua);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"m\") || !strcasecmp(argv[0],\"maxlen\")) {", "ldbMaxlen(argv,argc);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"b\") || !strcasecmp(argv[0],\"break\")) {", "ldbBreak(argv,argc);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"e\") || !strcasecmp(argv[0],\"eval\")) {", "ldbEval(lua,argv,argc);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"a\") || !strcasecmp(argv[0],\"abort\")) {", "lua_pushstring(lua, \"script aborted for user request\");", "lua_error(lua);", "} else if (argc > 1 &&", "(!strcasecmp(argv[0],\"r\") || !strcasecmp(argv[0],\"redis\"))) {", "ldbRedis(lua,argv,argc);", "ldbSendLogs();", "} else if ((!strcasecmp(argv[0],\"p\") || !strcasecmp(argv[0],\"print\"))) {", "if (argc == 2)", "ldbPrint(lua,argv[1]);", "else", "ldbPrintAll(lua);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"l\") || !strcasecmp(argv[0],\"list\")){", "int around = ldb.currentline, ctx = 5;", "if (argc > 1) {", "int num = atoi(argv[1]);", "if (num > 0) around = num;", "}", "if (argc > 2) ctx = atoi(argv[2]);", "ldbList(around,ctx);", "ldbSendLogs();", "} else if (!strcasecmp(argv[0],\"w\") || !strcasecmp(argv[0],\"whole\")){", "ldbList(1,1000000);", "ldbSendLogs();", "} else {", "ldbLog(sdsnew(\"<error> Unknown Redis Lua debugger command or \"", "\"wrong number of arguments.\"));", "ldbSendLogs();", "}", "", "", "sdsfreesplitres(argv,argc);", "}", "", "", "sdsfreesplitres(argv,argc);", "return C_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool config_save(const config_t *config, const char *filename) {", "   assert(config != NULL);", " ", "    assert(filename != NULL);", "    assert(*filename != '\\0');", "  ", "  char *temp_filename = osi_calloc(strlen(filename) + 5);", "  if (!temp_filename) {", "    LOG_ERROR(\"%s unable to allocate memory for filename.\", __func__);", "    return false;", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "   int dir_fd = -1;", "   FILE *fp = NULL;", " ", "    ", "   static const char *temp_file_ext = \".new\";", "   const int filename_len = strlen(filename);", "   const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;", "   char *temp_filename = osi_calloc(temp_filename_len);", "   snprintf(temp_filename, temp_filename_len, \"%s%s\", filename, temp_file_ext);", " ", "    ", "   char *temp_dirname = osi_strdup(filename);", "   const char *directoryname = dirname(temp_dirname);", "   if (!directoryname) {", "     LOG_ERROR(\"%s error extracting directory from '%s': %s\", __func__, filename, strerror(errno));", "     goto error;", "    }", "  ", "  strcpy(temp_filename, filename);", "  strcat(temp_filename, \".new\");", "   dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));", "   if (dir_fd < 0) {", "     LOG_ERROR(\"%s unable to open dir '%s': %s\", __func__, directoryname, strerror(errno));", "     goto error;", "   }", "  ", "  FILE *fp = fopen(temp_filename, \"wt\");", "   fp = fopen(temp_filename, \"wt\");", "    if (!fp) {", "      LOG_ERROR(\"%s unable to write file '%s': %s\", __func__, temp_filename, strerror(errno));", "      goto error;", "  }", " ", "  ", "    for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {", "      const section_t *section = (const section_t *)list_node(node);", "    fprintf(fp, \"[%s]\\n\", section->name);", "     if (fprintf(fp, \"[%s]\\n\", section->name) < 0) {", "       LOG_ERROR(\"%s unable to write to file '%s': %s\", __func__, temp_filename, strerror(errno));", "       goto error;", "     }", "  ", "      for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {", "        const entry_t *entry = (const entry_t *)list_node(enode);", "      fprintf(fp, \"%s = %s\\n\", entry->key, entry->value);", "       if (fprintf(fp, \"%s = %s\\n\", entry->key, entry->value) < 0) {", "         LOG_ERROR(\"%s unable to write to file '%s': %s\", __func__, temp_filename, strerror(errno));", "         goto error;", "       }", "      }", "  ", "    if (list_next(node) != list_end(config->sections))", "      fputc('\\n', fp);", "     if (list_next(node) != list_end(config->sections)) {", "       if (fputc('\\n', fp) == EOF) {", "         LOG_ERROR(\"%s unable to write to file '%s': %s\", __func__, temp_filename, strerror(errno));", "         goto error;", "       }", "     }", "    }", "  ", "  fflush(fp);", "  fclose(fp);", "    ", "   if (fsync(fileno(fp)) < 0) {", "     LOG_WARN(\"%s unable to fsync file '%s': %s\", __func__, temp_filename, strerror(errno));", "   }", " ", "   if (fclose(fp) == EOF) {", "     LOG_ERROR(\"%s unable to close file '%s': %s\", __func__, temp_filename, strerror(errno));", "     goto error;", "   }", "   fp = NULL;", "  ", "    if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {", "     LOG_ERROR(\"%s unable to change file permissions '%s': %s\", __func__, filename, strerror(errno));", " ", "      goto error;", "    }", "  ", "    ", "    if (rename(temp_filename, filename) == -1) {", "      LOG_ERROR(\"%s unable to commit file '%s': %s\", __func__, filename, strerror(errno));", "      goto error;", "    }", "  ", "    ", "   if (fsync(dir_fd) < 0) {", "     LOG_WARN(\"%s unable to fsync dir '%s': %s\", __func__, directoryname, strerror(errno));", "   }", " ", "   if (close(dir_fd) < 0) {", "     LOG_ERROR(\"%s unable to close dir '%s': %s\", __func__, directoryname, strerror(errno));", "     goto error;", "   }", " ", "    osi_free(temp_filename);", "   osi_free(temp_dirname);", "    return true;", "  ", "error:;", " error:", "    ", "    unlink(temp_filename);", "   if (fp)", "     fclose(fp);", "   if (dir_fd != -1)", "     close(dir_fd);", "    osi_free(temp_filename);", "   osi_free(temp_dirname);", "    return false;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0]}
{"tokens": [" main(int ac, char **av)", " {", " \tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;", " \tint sock, fd, ch, result, saved_errno;", " \tu_int nalloc;", " \tchar *shell, *format, *pidstr, *agentsocket = NULL;", " \tfd_set *readsetp = NULL, *writesetp = NULL;", " \tstruct rlimit rlim;", " \textern int optind;", " \textern char *optarg;", " \tpid_t pid;", " \tchar pidstrbuf[1 + 3 * sizeof pid];", " \tstruct timeval *tvp = NULL;", " \tsize_t len;", " \tmode_t prev_mask;", " ", " \tssh_malloc_init();\t ", " \t ", " \tsanitise_stdfd();", " ", " \t ", " \tsetegid(getgid());", " \tsetgid(getgid());", " ", " #ifdef WITH_OPENSSL", "  \tOpenSSL_add_all_algorithms();", "  #endif", "  ", "\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {", " \twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {", "  \t\tswitch (ch) {", "  \t\tcase 'E':", "  \t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);", " \t\t\tif (fingerprint_hash == -1)", " \t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);", " \t\t\tbreak;", " \t\tcase 'c':", " \t\t\tif (s_flag)", " \t\t\t\tusage();", " \t\t\tc_flag++;", " \t\t\tbreak;", "  \t\tcase 'k':", "  \t\t\tk_flag++;", "  \t\t\tbreak;", " \t\tcase 'P':", " \t\t\tif (pkcs11_whitelist != NULL)", " \t\t\t\tfatal(\"-P option already specified\");", " \t\t\tpkcs11_whitelist = xstrdup(optarg);", " \t\t\tbreak;", "  \t\tcase 's':", "  \t\t\tif (c_flag)", "  \t\t\t\tusage();", " \t\t\ts_flag++;", " \t\t\tbreak;", " \t\tcase 'd':", " \t\t\tif (d_flag || D_flag)", " \t\t\t\tusage();", " \t\t\td_flag++;", " \t\t\tbreak;", " \t\tcase 'D':", " \t\t\tif (d_flag || D_flag)", " \t\t\t\tusage();", " \t\t\tD_flag++;", " \t\t\tbreak;", " \t\tcase 'a':", " \t\t\tagentsocket = optarg;", " \t\t\tbreak;", " \t\tcase 't':", " \t\t\tif ((lifetime = convtime(optarg)) == -1) {", " \t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");", " \t\t\t\tusage();", " \t\t\t}", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tusage();", " \t\t}", " \t}", " \tac -= optind;", " \tav += optind;", " ", "  \tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))", "  \t\tusage();", "  ", " \tif (pkcs11_whitelist == NULL)", " \t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);", " ", "  \tif (ac == 0 && !c_flag && !s_flag) {", "  \t\tshell = getenv(\"SHELL\");", "  \t\tif (shell != NULL && (len = strlen(shell)) > 2 &&", " \t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)", " \t\t\tc_flag = 1;", " \t}", " \tif (k_flag) {", " \t\tconst char *errstr = NULL;", " ", " \t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);", " \t\tif (pidstr == NULL) {", " \t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",", " \t\t\t    SSH_AGENTPID_ENV_NAME);", " \t\t\texit(1);", " \t\t}", " \t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);", " \t\tif (errstr) {", " \t\t\tfprintf(stderr,", " \t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",", " \t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);", " \t\t\texit(1);", " \t\t}", " \t\tif (kill(pid, SIGTERM) == -1) {", " \t\t\tperror(\"kill\");", " \t\t\texit(1);", " \t\t}", " \t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";", " \t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);", " \t\tprintf(format, SSH_AGENTPID_ENV_NAME);", " \t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);", " \t\texit(0);", " \t}", " \tparent_pid = getpid();", " ", " \tif (agentsocket == NULL) {", " \t\t ", " \t\tmktemp_proto(socket_dir, sizeof(socket_dir));", " \t\tif (mkdtemp(socket_dir) == NULL) {", " \t\t\tperror(\"mkdtemp: private socket dir\");", " \t\t\texit(1);", " \t\t}", " \t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,", " \t\t    (long)parent_pid);", " \t} else {", " \t\t ", " \t\tsocket_dir[0] = '\\0';", " \t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);", " \t}", " ", " \t ", " \tprev_mask = umask(0177);", " \tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);", " \tif (sock < 0) {", " \t\t ", " \t\t*socket_name = '\\0';  ", " \t\tcleanup_exit(1);", " \t}", " \tumask(prev_mask);", " ", " \t ", " \tif (D_flag || d_flag) {", " \t\tlog_init(__progname,", " \t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,", " \t\t    SYSLOG_FACILITY_AUTH, 1);", " \t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";", " \t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,", " \t\t    SSH_AUTHSOCKET_ENV_NAME);", " \t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);", " \t\tfflush(stdout);", " \t\tgoto skip;", " \t}", " \tpid = fork();", " \tif (pid == -1) {", " \t\tperror(\"fork\");", " \t\tcleanup_exit(1);", " \t}", " \tif (pid != 0) {\t\t ", " \t\tclose(sock);", " \t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);", " \t\tif (ac == 0) {", " \t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";", " \t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,", " \t\t\t    SSH_AUTHSOCKET_ENV_NAME);", " \t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,", " \t\t\t    SSH_AGENTPID_ENV_NAME);", " \t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);", " \t\t\texit(0);", " \t\t}", " \t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||", " \t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {", " \t\t\tperror(\"setenv\");", " \t\t\texit(1);", " \t\t}", " \t\texecvp(av[0], av);", " \t\tperror(av[0]);", " \t\texit(1);", " \t}", " \t ", " \tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);", " ", " \tif (setsid() == -1) {", " \t\terror(\"setsid: %s\", strerror(errno));", " \t\tcleanup_exit(1);", " \t}", " ", " \t(void)chdir(\"/\");", " \tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {", " \t\t ", " \t\t(void)dup2(fd, STDIN_FILENO);", " \t\t(void)dup2(fd, STDOUT_FILENO);", " \t\t(void)dup2(fd, STDERR_FILENO);", " \t\tif (fd > 2)", " \t\t\tclose(fd);", " \t}", " ", " \t ", " \trlim.rlim_cur = rlim.rlim_max = 0;", " \tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {", " \t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));", " \t\tcleanup_exit(1);", " \t}", " ", " skip:", " ", " \tcleanup_pid = getpid();", " ", " #ifdef ENABLE_PKCS11", " \tpkcs11_init(0);", " #endif", " \tnew_socket(AUTH_SOCKET, sock);", " \tif (ac > 0)", " \t\tparent_alive_interval = 10;", " \tidtab_init();", " \tsignal(SIGPIPE, SIG_IGN);", " \tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);", " \tsignal(SIGHUP, cleanup_handler);", "  \tsignal(SIGTERM, cleanup_handler);", "  \tnalloc = 0;", "  ", "\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)", " \tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)", "  \t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));", "  ", "  \twhile (1) {", " \t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);", " \t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);", " \t\tsaved_errno = errno;", " \t\tif (parent_alive_interval != 0)", " \t\t\tcheck_parent_exists();", " \t\t(void) reaper();\t ", " \t\tif (result < 0) {", " \t\t\tif (saved_errno == EINTR)", " \t\t\t\tcontinue;", " \t\t\tfatal(\"select: %s\", strerror(saved_errno));", " \t\t} else if (result > 0)", " \t\t\tafter_select(readsetp, writesetp);", " \t}", " \t ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xsltFreeTemplateHashes(xsltStylesheetPtr style) {", "     if (style->templatesHash != NULL)", " \txmlHashFree((xmlHashTablePtr) style->templatesHash,", " \t\t    (xmlHashDeallocator) xsltFreeCompMatchList);", "     if (style->rootMatch != NULL)", "         xsltFreeCompMatchList(style->rootMatch);", "     if (style->keyMatch != NULL)", "         xsltFreeCompMatchList(style->keyMatch);", "     if (style->elemMatch != NULL)", "         xsltFreeCompMatchList(style->elemMatch);", "     if (style->attrMatch != NULL)", "         xsltFreeCompMatchList(style->attrMatch);", "     if (style->parentMatch != NULL)", "         xsltFreeCompMatchList(style->parentMatch);", "     if (style->textMatch != NULL)", "         xsltFreeCompMatchList(style->textMatch);", "     if (style->piMatch != NULL)", "          xsltFreeCompMatchList(style->piMatch);", "      if (style->commentMatch != NULL)", "          xsltFreeCompMatchList(style->commentMatch);", "     if (style->namedTemplates != NULL)", "         xmlHashFree(style->namedTemplates, NULL);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" status_t ACodec::setupAACCodec(", "  bool encoder, int32_t numChannels, int32_t sampleRate,", "  int32_t bitRate, int32_t aacProfile, bool isADTS, int32_t sbrMode,", "  int32_t maxOutputChannelCount, const drcParams_t& drc,", "  int32_t pcmLimiterEnable) {", "  if (encoder && isADTS) {", "  return -EINVAL;", "  }", " ", "  status_t err = setupRawAudioFormat(", "             encoder ? kPortIndexInput : kPortIndexOutput,", "             sampleRate,", "             numChannels);", " ", "  if (err != OK) {", "  return err;", "  }", " ", "  if (encoder) {", "         err = selectAudioPortFormat(kPortIndexOutput, OMX_AUDIO_CodingAAC);", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         OMX_PARAM_PORTDEFINITIONTYPE def;", "  InitOMXParams(&def);", "         def.nPortIndex = kPortIndexOutput;", " ", "         err = mOMX->getParameter(", "                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         def.format.audio.bFlagErrorConcealment = OMX_TRUE;", "         def.format.audio.eEncoding = OMX_AUDIO_CodingAAC;", " ", "         err = mOMX->setParameter(", "                 mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         OMX_AUDIO_PARAM_AACPROFILETYPE profile;", "  InitOMXParams(&profile);", "         profile.nPortIndex = kPortIndexOutput;", " ", "         err = mOMX->getParameter(", "                 mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         profile.nChannels = numChannels;", " ", "         profile.eChannelMode =", "  (numChannels == 1)", "  ? OMX_AUDIO_ChannelModeMono: OMX_AUDIO_ChannelModeStereo;", " ", "         profile.nSampleRate = sampleRate;", "         profile.nBitRate = bitRate;", "         profile.nAudioBandWidth = 0;", "         profile.nFrameLength = 0;", "         profile.nAACtools = OMX_AUDIO_AACToolAll;", "         profile.nAACERtools = OMX_AUDIO_AACERNone;", "         profile.eAACProfile = (OMX_AUDIO_AACPROFILETYPE) aacProfile;", "         profile.eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;", "  switch (sbrMode) {", "  case 0:", "             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;", "             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;", "  break;", "  case 1:", "             profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;", "             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;", "  break;", "  case 2:", "             profile.nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;", "             profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;", "  break;", "  case -1:", "             profile.nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;", "             profile.nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;", "  break;", "  default:", "  return BAD_VALUE;", "  }", " ", " ", "         err = mOMX->setParameter(", "                 mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));", " ", "  if (err != OK) {", "  return err;", "  }", " ", "  return err;", "  }", " ", "     OMX_AUDIO_PARAM_AACPROFILETYPE profile;", "  InitOMXParams(&profile);", "     profile.nPortIndex = kPortIndexInput;", " ", "     err = mOMX->getParameter(", "             mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));", " ", "  if (err != OK) {", "  return err;", "  }", " ", "     profile.nChannels = numChannels;", "     profile.nSampleRate = sampleRate;", " ", "     profile.eAACStreamFormat =", "         isADTS", "  ? OMX_AUDIO_AACStreamFormatMP4ADTS", " ", "              : OMX_AUDIO_AACStreamFormatMP4FF;", "  ", "      OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE presentation;", "     InitOMXParams(&presentation);", "      presentation.nMaxOutputChannels = maxOutputChannelCount;", "      presentation.nDrcCut = drc.drcCut;", "      presentation.nDrcBoost = drc.drcBoost;", "     presentation.nHeavyCompression = drc.heavyCompression;", "     presentation.nTargetReferenceLevel = drc.targetRefLevel;", "     presentation.nEncodedTargetLevel = drc.encodedTargetLevel;", "     presentation.nPCMLimiterEnable = pcmLimiterEnable;", " ", "  status_t res = mOMX->setParameter(mNode, OMX_IndexParamAudioAac, &profile, sizeof(profile));", "  if (res == OK) {", "         mOMX->setParameter(mNode, (OMX_INDEXTYPE)OMX_IndexParamAudioAndroidAacPresentation,", "  &presentation, sizeof(presentation));", "  } else {", "         ALOGW(\"did not set AudioAndroidAacPresentation due to error %d when setting AudioAac\", res);", "  }", "  return res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" image_transform_ini_end(PNG_CONST image_transform *this,", " image_transform_ini_end(const image_transform *this,", "     transform_display *that)", "  {", "     UNUSED(this)", "    UNUSED(that)", " ", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" lldp_private_8021_print(netdissect_options *ndo,", "                         const u_char *tptr, u_int tlv_len)", " {", "      int subtype, hexdump = FALSE;", "      u_int sublen;", "      u_int tval;", "    uint8_t i;", "     u_int i;", "  ", "      if (tlv_len < 4) {", "          return hexdump;", "     }", "     subtype = *(tptr+3);", " ", "     ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",", "            tok2str(lldp_8021_subtype_values, \"unknown\", subtype),", "            subtype));", " ", "     switch (subtype) {", "     case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:", "         if (tlv_len < 6) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    port vlan id (PVID): %u\",", "                EXTRACT_16BITS(tptr + 4)));", "         break;", "     case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:", "         if (tlv_len < 7) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\",", "                EXTRACT_16BITS(tptr+5),", " \t       bittok2str(lldp_8021_port_protocol_id_values, \"none\", *(tptr+4)),", " \t       *(tptr + 4)));", "         break;", "     case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:", "         if (tlv_len < 6) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    vlan id (VID): %u\", EXTRACT_16BITS(tptr + 4)));", "         if (tlv_len < 7) {", "             return hexdump;", "         }", "         sublen = *(tptr+6);", "         if (tlv_len < 7+sublen) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    vlan name: \"));", "         safeputs(ndo, tptr + 7, sublen);", "         break;", "     case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:", "         if (tlv_len < 5) {", "             return hexdump;", "         }", "         sublen = *(tptr+4);", "         if (tlv_len < 5+sublen) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    protocol identity: \"));", "         safeputs(ndo, tptr + 5, sublen);", "         break;", "     case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){", "         \treturn hexdump;", "         }", "         tval=*(tptr+4);", "         ND_PRINT((ndo, \"\\n\\t    Pre-Priority CNPV Indicator\"));", "         ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));", "         ND_PRINT((ndo, \"\\n\\t     Value    : \"));", "         for(i=0;i<NO_OF_BITS;i++)", "             ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));", "         tval=*(tptr+5);", "         ND_PRINT((ndo, \"\\n\\t    Pre-Priority Ready Indicator\"));", "         ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));", "         ND_PRINT((ndo, \"\\n\\t     Value    : \"));", "         for(i=0;i<NO_OF_BITS;i++)", "             ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));", "         break;", " ", "     case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {", "             return hexdump;", "         }", "         tval=*(tptr+4);", "         ND_PRINT((ndo, \"\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\",", "         \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));", " ", "          ", "         print_ets_priority_assignment_table(ndo, tptr + 5);", " ", "          ", "         print_tc_bandwidth_table(ndo, tptr + 9);", " ", "          ", "         print_tsa_assignment_table(ndo, tptr + 17);", " ", "         break;", " ", "     case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {", "         \treturn hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));", "          ", "         print_ets_priority_assignment_table(ndo, tptr + 5);", "          ", "         print_tc_bandwidth_table(ndo, tptr + 9);", "          ", "         print_tsa_assignment_table(ndo, tptr + 17);", "         break;", " ", "     case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {", "             return hexdump;", "         }", "         tval=*(tptr+4);", "         ND_PRINT((ndo, \"\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \",", "         \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));", "         ND_PRINT((ndo, \"\\n\\t    PFC Enable\"));", "         tval=*(tptr+5);", "         ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));", "         ND_PRINT((ndo, \"\\n\\t     Value    : \"));", "         for(i=0;i<NO_OF_BITS;i++)", "             ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));", "         break;", " ", "     case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {", "             return hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));", "         if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){", "         \treturn hexdump;", "         }", "          ", "         sublen=tlv_len-5;", "         if(sublen%3!=0){", "         \treturn hexdump;", "         }", "         i=0;", "          ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));", "          while(i<sublen) {", "          \ttval=*(tptr+i+5);", "        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",", "        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));", "        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));", "         \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",", "         \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),", "         \t\t EXTRACT_16BITS(tptr + i + 5)));", "          \ti=i+3;", "          }", "          break;", "     case LLDP_PRIVATE_8021_SUBTYPE_EVB:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){", "         \treturn hexdump;", "         }", "         ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));", "         tval=*(tptr+4);", "         ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",", "         \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));", "         ND_PRINT((ndo, \"\\n\\t    EVB Station Status\"));", "         tval=*(tptr+5);", "         ND_PRINT((ndo, \"\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\",", "         \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));", "         tval=*(tptr+6);", "         ND_PRINT((ndo, \"\\n\\t    R: %d, RTE: %d, \",tval >> 5, tval & 0x1f));", "         tval=*(tptr+7);", "         ND_PRINT((ndo, \"EVB Mode: %s [%d]\",", "         \ttok2str(lldp_evb_mode_values, \"unknown\", tval >> 6), tval >> 6));", "         ND_PRINT((ndo, \"\\n\\t    ROL: %d, RWD: %d, \", (tval >> 5) & 0x01, tval & 0x1f));", "         tval=*(tptr+8);", "         ND_PRINT((ndo, \"RES: %d, ROL: %d, RKA: %d\", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));", "         break;", " ", "     case LLDP_PRIVATE_8021_SUBTYPE_CDCP:", "         if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){", "         \treturn hexdump;", "         }", "         tval=*(tptr+4);", "         ND_PRINT((ndo, \"\\n\\t    Role: %d, RES: %d, Scomp: %d \",", "         \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));", "         ND_PRINT((ndo, \"ChnCap: %d\", EXTRACT_16BITS(tptr + 6) & 0x0fff));", "         sublen=tlv_len-8;", "         if(sublen%3!=0) {", "         \treturn hexdump;", "         }", "         i=0;", "         while(i<sublen) {", "         \ttval=EXTRACT_24BITS(tptr+i+8);", "         \tND_PRINT((ndo, \"\\n\\t    SCID: %d, SVID: %d\",", "         \t\ttval >> 12, tval & 0x000fff));", "         \ti=i+3;", "         }", "         break;", " ", "     default:", "         hexdump = TRUE;", "         break;", "     }", " ", "     return hexdump;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void PaymentRequest::Init(mojom::PaymentRequestClientPtr client,", "                           std::vector<mojom::PaymentMethodDataPtr> method_data,", "                            mojom::PaymentDetailsPtr details,", "                            mojom::PaymentOptionsPtr options) {", "    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);", " ", "   if (is_initialized_) {", "     log_.Error(\"Attempted initialization twice\");", "     OnConnectionTerminated();", "     return;", "   }", " ", "   is_initialized_ = true;", "    client_ = std::move(client);", "  ", "    const GURL last_committed_url = delegate_->GetLastCommittedURL();", "    if (!OriginSecurityChecker::IsOriginSecure(last_committed_url)) {", "    LOG(ERROR) << \"Not in a secure origin\";", "     log_.Error(\"Not in a secure origin\");", "      OnConnectionTerminated();", "      return;", "    }", " ", "   bool allowed_origin =", "        OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) ||", "        OriginSecurityChecker::IsOriginLocalhostOrFile(last_committed_url);", "    if (!allowed_origin) {", "    LOG(ERROR) << \"Only localhost, file:, and cryptographic scheme origins \"", "                  \"allowed\";", "     log_.Error(", "         \"Only localhost, file:, and cryptographic scheme origins allowed\");", "    }", "  ", "    bool invalid_ssl =", "        OriginSecurityChecker::IsSchemeCryptographic(last_committed_url) &&", "        !delegate_->IsSslCertificateValid();", "  if (invalid_ssl)", "    LOG(ERROR) << \"SSL certificate is not valid\";", "   if (invalid_ssl) {", "     log_.Error(\"SSL certificate is not valid.\");", "   }", "  ", "    if (!allowed_origin || invalid_ssl) {", "      ", "     log_.Error(", "         \"No UI will be shown. CanMakePayment will always return false. \"", "         \"Show will be rejected with NotSupportedError.\");", "      return;", "    }", "  ", "    std::string error;", "    if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {", "    LOG(ERROR) << error;", "     log_.Error(error);", "      OnConnectionTerminated();", "      return;", "    }", "  ", "    if (!details->total) {", "    LOG(ERROR) << \"Missing total\";", "     log_.Error(\"Missing total\");", "      OnConnectionTerminated();", "      return;", "    }", " ", "   spec_ = std::make_unique<PaymentRequestSpec>(", "       std::move(options), std::move(details), std::move(method_data), this,", "       delegate_->GetApplicationLocale());", "   state_ = std::make_unique<PaymentRequestState>(", "       web_contents_, top_level_origin_, frame_origin_, spec_.get(), this,", "       delegate_->GetApplicationLocale(), delegate_->GetPersonalDataManager(),", "       delegate_.get(), &journey_logger_);", " ", "   journey_logger_.SetRequestedInformation(", "       spec_->request_shipping(), spec_->request_payer_email(),", "       spec_->request_payer_phone(), spec_->request_payer_name());", " ", "   GURL google_pay_url(kGooglePayMethodName);", "   GURL android_pay_url(kAndroidPayMethodName);", "   auto non_google_it =", "       std::find_if(spec_->url_payment_method_identifiers().begin(),", "                    spec_->url_payment_method_identifiers().end(),", "                    [google_pay_url, android_pay_url](const GURL& url) {", "                      return url != google_pay_url && url != android_pay_url;", "                    });", "   journey_logger_.SetRequestedPaymentMethodTypes(", "        !spec_->supported_card_networks().empty(),", "        ", "       base::ContainsValue(spec_->url_payment_method_identifiers(),", "                           google_pay_url) ||", "           base::ContainsValue(spec_->url_payment_method_identifiers(),", "                               android_pay_url),", "        non_google_it !=", "           spec_->url_payment_method_identifiers().end());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static unsigned int seedsize(struct crypto_alg *alg)", "  {", "  \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);", "  ", "\treturn alg->cra_rng.rng_make_random ?", "\t       alg->cra_rng.seedsize : ralg->seedsize;", " \treturn ralg->seedsize;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" wiki_handle_http_request(HttpRequest *req)", " {", "   HttpResponse *res      = http_response_new(req);", "   char         *page     = http_request_get_path_info(req); ", "   char         *command  = http_request_get_query_string(req); ", "   char         *wikitext = \"\";", " ", "   util_dehttpize(page); \t ", " ", "   if (!strcmp(page, \"/\"))", "     {", "       if (access(\"WikiHome\", R_OK) != 0)", " \twiki_redirect(res, \"/WikiHome?create\");", "       page = \"/WikiHome\";", "     }", " ", "   if (!strcmp(page, \"/styles.css\"))", "     {", "        ", "       http_response_set_content_type(res, \"text/css\");", "       http_response_printf(res, \"%s\", CssData);", "       http_response_send(res);", "       exit(0);", "     }", " ", "   if (!strcmp(page, \"/favicon.ico\"))", "     {", "        ", "       http_response_set_content_type(res, \"image/ico\");", "       http_response_set_data(res, FaviconData, FaviconDataLen);", "       http_response_send(res);", "       exit(0);", "     }", " ", " ", "   page = page + 1; \t\t ", " ", "   if (!strncmp(page, \"api/\", 4))", "     {", "       char *p;", " ", "       page += 4; ", "       for (p=page; *p != '\\0'; p++)", " \tif (*p=='?') { *p ='\\0'; break; }", "       ", "       wiki_handle_rest_call(req, res, page); ", "       exit(0);", "     }", " ", "     ", "  if (strchr(page, '/'))", "   if (!page_name_is_good(page))", "      {", "        http_response_set_status(res, 404, \"Not Found\");", "        http_response_printf(res, \"<html><body>404 Not Found</body></html>\\n\");", "       http_response_send(res);", "       exit(0);", "     }", " ", "   if (!strcmp(page, \"Changes\"))", "     {", "       wiki_show_changes_page(res);", "     }", "   else if (!strcmp(page, \"ChangesRss\"))", "     {", "       wiki_show_changes_page_rss(res);", "     }", "   else if (!strcmp(page, \"Search\"))", "     {", "       wiki_show_search_results_page(res, http_request_param_get(req, \"expr\"));", "     }", "   else if (!strcmp(page, \"Create\"))", "     {", "       if ( (wikitext = http_request_param_get(req, \"title\")) != NULL)", " \t{", " \t   ", " \t  wiki_redirect(res, http_request_param_get(req, \"title\"));", " \t}", "       else", " \t{", " \t    ", " \t  wiki_show_create_page(res);", " \t}", "     }", "   else", "     {", "        ", "       if ( (wikitext = http_request_param_get(req, \"wikitext\")) != NULL)", " \t{", " \t  file_write(page, wikitext);\t      ", " \t}", " ", "       if (access(page, R_OK) == 0) \t ", " \t{", " \t  wikitext = file_read(page);", " \t  ", " \t  if (!strcmp(command, \"edit\"))", " \t    {", " \t       ", " \t      wiki_show_edit_page(res, wikitext, page);", " \t    }", " \t  else", " \t    {", " \t      wiki_show_page(res, wikitext, page);", " \t    }", " \t}", "       else", " \t{", " \t  if (!strcmp(command, \"create\"))", " \t    {", " \t      wiki_show_edit_page(res, NULL, page);", " \t    }", " \t  else", " \t    {", " \t      char buf[1024];", " \t      snprintf(buf, 1024, \"%s?create\", page);", " \t      wiki_redirect(res, buf);", " \t    }", " \t}", "     }", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   static void RegisterPropertiesHandler(", "      void* object, const ImePropertyList& prop_list) {", "    ", "   virtual void OnRegisterImeProperties(", "       const input_method::ImePropertyList& prop_list) {", "      if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {", "        LOG(ERROR) << \"Not on UI thread\";", "        return;", "      }", "  ", "    InputMethodLibraryImpl* input_method_library =", "        static_cast<InputMethodLibraryImpl*>(object);", "    input_method_library->RegisterProperties(prop_list);", "     RegisterProperties(prop_list);", "    }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": [" OMX_ERRORTYPE SimpleSoftOMXComponent::internalGetParameter(", "         OMX_INDEXTYPE index, OMX_PTR params) {", "  switch (index) {", "  case OMX_IndexParamPortDefinition:", "  {", " ", "              OMX_PARAM_PORTDEFINITIONTYPE *defParams =", "                  (OMX_PARAM_PORTDEFINITIONTYPE *)params;", "  ", "             if (!isValidOMXParam(defParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (defParams->nPortIndex >= mPorts.size()", "                      || defParams->nSize", "                              != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {", "  return OMX_ErrorUndefined;", "  }", " ", "  const PortInfo *port =", "  &mPorts.itemAt(defParams->nPortIndex);", " ", "             memcpy(defParams, &port->mDef, sizeof(port->mDef));", " ", "  return OMX_ErrorNone;", "  }", " ", "  default:", "  return OMX_ErrorUnsupportedIndex;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["struct resource_pool *dcn10_create_resource_pool(", "const struct dc_init_data *init_data,", "struct dc *dc)", "{", "struct dcn10_resource_pool *pool =", "kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);", "", "if (!pool)", "return NULL;", "", "if (construct(init_data->num_virtual_links, dc, pool))", "return &pool->base;", "", "BREAK_TO_DEBUGGER();", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,", "                      int len, int peek)", " {", "     int al, i, j, ret;", "     unsigned int n;", "     SSL3_RECORD *rr;", "     void (*cb) (const SSL *ssl, int type2, int val) = NULL;", " ", "     if (!SSL3_BUFFER_is_initialised(&s->rlayer.rbuf)) {", "          ", "         if (!ssl3_setup_buffers(s))", "             return (-1);", "     }", " ", "     if ((type && (type != SSL3_RT_APPLICATION_DATA) &&", "          (type != SSL3_RT_HANDSHAKE)) ||", "         (peek && (type != SSL3_RT_APPLICATION_DATA))) {", "         SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);", "         return -1;", "     }", " ", "      ", "     if ((ret = have_handshake_fragment(s, type, buf, len)))", "         return ret;", " ", "      ", " ", " #ifndef OPENSSL_NO_SCTP", "      ", "     if ((!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) ||", "         (BIO_dgram_is_sctp(SSL_get_rbio(s))", "          && ossl_statem_in_sctp_read_sock(s)", "          && s->s3->in_read_app_data != 2))", " #else", "     if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s))", " #endif", "     {", "          ", "         i = s->handshake_func(s);", "         if (i < 0)", "             return (i);", "         if (i == 0) {", "             SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE);", "             return (-1);", "         }", "     }", " ", "  start:", "     s->rwstate = SSL_NOTHING;", " ", "      ", "     rr = s->rlayer.rrec;", " ", "      ", "     if (SSL_is_init_finished(s) && SSL3_RECORD_get_length(rr) == 0) {", "         pitem *item;", "         item = pqueue_pop(s->rlayer.d->buffered_app_data.q);", "         if (item) {", " #ifndef OPENSSL_NO_SCTP", "              ", "             if (BIO_dgram_is_sctp(SSL_get_rbio(s))) {", "                 DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *)item->data;", "                 BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO,", "                          sizeof(rdata->recordinfo), &rdata->recordinfo);", "             }", " #endif", " ", "             dtls1_copy_record(s, item);", " ", "             OPENSSL_free(item->data);", "             pitem_free(item);", "         }", "     }", " ", "      ", "     if (dtls1_handle_timeout(s) > 0)", "         goto start;", " ", "      ", "     if ((SSL3_RECORD_get_length(rr) == 0)", "         || (s->rlayer.rstate == SSL_ST_READ_BODY)) {", "         ret = dtls1_get_record(s);", "         if (ret <= 0) {", "             ret = dtls1_read_failed(s, ret);", "              ", "             if (ret <= 0)", "                 return (ret);", "             else", "                 goto start;", "          }", "      }", "  ", "      ", "     if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT", "             && SSL3_RECORD_get_length(rr) != 0)", "         s->rlayer.alert_count = 0;", " ", "       ", "  ", "      if (s->s3->change_cipher_spec /* set when we receive ChangeCipherSpec,", "                                 SSL3_RECORD_get_seq_num(rr)) < 0) {", "             SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);", "             return -1;", "         }", "         SSL3_RECORD_set_length(rr, 0);", "         goto start;", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,", " \t\t\t     size_t outlen, int invert)", "  {", "  \tconst u8 *in = inbuf;", "  \tu8 *out = (u8 *) outbuf;", "\tint zero_bits = *in & 0x07;", "\tsize_t octets_left = inlen - 1;", "  \tint i, count = 0;", " \tint zero_bits;", " \tsize_t octets_left;", "  ", "\tmemset(outbuf, 0, outlen);", "\tin++;", "  \tif (outlen < octets_left)", "  \t\treturn SC_ERROR_BUFFER_TOO_SMALL;", "  \tif (inlen < 1)", "  \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " ", " \tzero_bits = *in & 0x07;", " \toctets_left = inlen - 1;", " \tin++;", " \tmemset(outbuf, 0, outlen);", " ", "  \twhile (octets_left) {", "  \t\t ", "  \t\t ", " \t\t ", " \t\tint bits_to_go;", " ", " \t\t*out = 0;", " \t\tif (octets_left == 1)", " \t\t\tbits_to_go = 8 - zero_bits;", " \t\telse", " \t\t\tbits_to_go = 8;", " \t\tif (invert)", " \t\t\tfor (i = 0; i < bits_to_go; i++) {", " \t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;", " \t\t\t}", " \t\telse {", " \t\t\t*out = *in;", " \t\t}", " \t\tout++;", " \t\tin++;", " \t\toctets_left--;", " \t\tcount++;", " \t}", " \treturn (count * 8) - zero_bits;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int install_relocation_handler(int num_cpus, size_t save_state_size)", "{", "struct smm_loader_params smm_params = {", ".per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,", ".num_concurrent_stacks = num_cpus,", ".per_cpu_save_state_size = save_state_size,", ".num_concurrent_save_states = 1,", ".handler = smm_do_relocation,", "};", "", "", "if (mp_state.ops.adjust_smm_params != NULL)", "mp_state.ops.adjust_smm_params(&smm_params, 0);", "", "if (smm_setup_relocation_handler(&smm_params))", "return -1;", "", "adjust_smm_apic_id_map(&smm_params);", "", "return 0;", "}"], "ner_tags": [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void NavigationObserver::PromptToEnableExtensionIfNecessary(", "     NavigationController* nav_controller) {", "   if (!in_progress_prompt_extension_id_.empty())", "     return;", " ", "   NavigationEntry* nav_entry = nav_controller->GetVisibleEntry();", "    if (!nav_entry)", "      return;", "  ", "  const GURL& url = (nav_entry->GetPageType() == content::PAGE_TYPE_ERROR &&", "                     nav_entry->GetURL() == url::kAboutBlankURL &&", "                     nav_entry->GetVirtualURL().SchemeIs(kExtensionScheme))", "                        ? nav_entry->GetVirtualURL()", "                        : nav_entry->GetURL();", "   const GURL& url = nav_entry->GetURL();", "  ", "   if (!url.SchemeIs(kExtensionScheme))", "     return;", " ", "   const Extension* extension = ExtensionRegistry::Get(profile_)", "                                    ->disabled_extensions()", "                                    .GetExtensionOrAppByURL(url);", "   if (!extension)", "     return;", " ", "   if (!prompted_extensions_.insert(extension->id()).second &&", "       !g_repeat_prompting) {", "     return;", "   }", " ", "   ExtensionPrefs* extension_prefs = ExtensionPrefs::Get(profile_);", "   if (extension_prefs->DidExtensionEscalatePermissions(extension->id())) {", "     in_progress_prompt_extension_id_ = extension->id();", "     in_progress_prompt_navigation_controller_ = nav_controller;", " ", "     extension_install_prompt_.reset(", "         new ExtensionInstallPrompt(nav_controller->GetWebContents()));", "     ExtensionInstallPrompt::PromptType type =", "         ExtensionInstallPrompt::GetReEnablePromptTypeForExtension(profile_,", "                                                                   extension);", "     extension_install_prompt_->ShowDialog(", "         base::Bind(&NavigationObserver::OnInstallPromptDone,", "                    weak_factory_.GetWeakPtr()),", "         extension, nullptr,", "         base::MakeUnique<ExtensionInstallPrompt::Prompt>(type),", "         ExtensionInstallPrompt::GetDefaultShowDialogCallback());", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" v8::Handle<v8::Value> V8DirectoryEntry::getDirectoryCallback(const v8::Arguments& args)", " {", "     INC_STATS(\"DOM.DirectoryEntry.getDirectory\");", "      DirectoryEntry* imp = V8DirectoryEntry::toNative(args.Holder());", "  ", "      if (args.Length() < 1)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "  ", "      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<WithUndefinedOrNullCheck>, path, args[0]);", "      if (args.Length() <= 1) {", "         imp->getDirectory(path);", "         return v8::Handle<v8::Value>();", "     }", "     RefPtr<WebKitFlags> flags;", "     if (!isUndefinedOrNull(args[1]) && args[1]->IsObject()) {", "         EXCEPTION_BLOCK(v8::Handle<v8::Object>, object, v8::Handle<v8::Object>::Cast(args[1]));", "         flags = WebKitFlags::create();", "         v8::Local<v8::Value> v8Create = object->Get(v8::String::New(\"create\"));", "         if (!v8Create.IsEmpty() && !isUndefinedOrNull(v8Create)) {", "             EXCEPTION_BLOCK(bool, isCreate, v8Create->BooleanValue());", "             flags->setCreate(isCreate);", "         }", "         v8::Local<v8::Value> v8Exclusive = object->Get(v8::String::New(\"exclusive\"));", "         if (!v8Exclusive.IsEmpty() && !isUndefinedOrNull(v8Exclusive)) {", "             EXCEPTION_BLOCK(bool, isExclusive, v8Exclusive->BooleanValue());", "             flags->setExclusive(isExclusive);", "         }", "     }", "     RefPtr<EntryCallback> successCallback;", "     if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {", "         if (!args[2]->IsObject())", "             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());", "         successCallback = V8EntryCallback::create(args[2], getScriptExecutionContext());", "     }", "     RefPtr<ErrorCallback> errorCallback;", "     if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {", "         if (!args[3]->IsObject())", "             return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());", "         errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());", "     }", "     imp->getDirectory(path, flags, successCallback, errorCallback);", "     return v8::Handle<v8::Value>();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int insert_pin(", "sc_pkcs15_card_t *p15card,", "const char       *path,", "unsigned char     id,", "unsigned char     auth_id,", "unsigned char     pin_reference,", "int               min_length,", "const char       *label,", "int               pin_flags", "){", "sc_card_t *card=p15card->card;", "sc_context_t *ctx=p15card->card->ctx;", "sc_file_t *f = NULL;", "struct sc_pkcs15_auth_info pin_info;", "struct sc_pkcs15_object pin_obj;", "int r;", "", "memset(&pin_info, 0, sizeof(pin_info));", "pin_info.auth_id.len      = 1;", "pin_info.auth_id.value[0] = id;", "pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;", "pin_info.attrs.pin.reference        = pin_reference;", "pin_info.attrs.pin.flags            = pin_flags;", "pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;", "pin_info.attrs.pin.min_length       = min_length;", "pin_info.attrs.pin.stored_length    = 16;", "pin_info.attrs.pin.max_length       = 16;", "pin_info.attrs.pin.pad_char         = '\\0';", "pin_info.logged_in = SC_PIN_STATE_UNKNOWN;", "sc_format_path(path, &pin_info.path);", "", "memset(&pin_obj, 0, sizeof(pin_obj));", "strlcpy(pin_obj.label, label, sizeof(pin_obj.label));", "pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;", "pin_obj.auth_id.len      = auth_id ? 0 : 1;", "pin_obj.auth_id.value[0] = auth_id;", "", "if(card->type == SC_CARD_TYPE_TCOS_V3) {", "unsigned char buf[256];", "int i, rec_no=0;", "if (pin_info.path.len >= 2) {", "pin_info.path.len -= 2;", "}", "sc_append_file_id(&pin_info.path, 0x5049);", "if (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {", "sc_log(ctx,", "\"Select(%s) failed\\n\",", "sc_print_path(&pin_info.path));", "return 1;", "}", "sc_log(ctx,", "\"Searching for PIN-Ref %02X\\n\", pin_reference);", "while ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {", "int found = 0, fbz = -1;", "if (buf[0] != 0xA0)", "continue;", "for (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {", "if (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {", "++found;", "}", "if (buf[i] == 0x90) {", "fbz = buf[i + 1 + buf[i + 1]];", "}", "}", "if (found) {", "pin_info.tries_left = fbz;", "break;", "}", "}", "if (r <= 0) {", "sc_log(ctx, \"No EF_PWDD-Record found\\n\");", "return 1;", "}", "} else {", "if (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS", "|| !f->prop_attr || f->prop_attr_len < 4){", "sc_log(ctx, \"Select(%s) failed\\n\", path);", "sc_file_free(f);", "return 1;", "}", "pin_info.tries_left = f->prop_attr[3];", "sc_file_free(f);", "}", "", "r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);", "if(r!=SC_SUCCESS){", "sc_log(ctx,  \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);", "return 4;", "}", "sc_log(ctx,  \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,", " \t\t\t   struct msghdr *msg, size_t len,", " \t\t\t   int flags)", " {", " \tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);", " \tstruct scm_cookie scm;", " \tstruct sock *sk = sock->sk;", " \tstruct netlink_sock *nlk = nlk_sk(sk);", " \tint noblock = flags&MSG_DONTWAIT;", " \tsize_t copied;", " \tstruct sk_buff *skb, *data_skb;", " \tint err, ret;", " ", " \tif (flags&MSG_OOB)", " \t\treturn -EOPNOTSUPP;", " ", " \tcopied = 0;", " ", " \tskb = skb_recv_datagram(sk, flags, noblock, &err);", " \tif (skb == NULL)", " \t\tgoto out;", " ", " \tdata_skb = skb;", " ", " #ifdef CONFIG_COMPAT_NETLINK_MESSAGES", " \tif (unlikely(skb_shinfo(skb)->frag_list)) {", " \t\t ", " \t\tif (flags & MSG_CMSG_COMPAT)", " \t\t\tdata_skb = skb_shinfo(skb)->frag_list;", "  \t}", "  #endif", "  ", "\tmsg->msg_namelen = 0;", "  \tcopied = data_skb->len;", "  \tif (len < copied) {", "  \t\tmsg->msg_flags |= MSG_TRUNC;", " \t\tcopied = len;", " \t}", " ", " \tskb_reset_transport_header(data_skb);", " \terr = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);", " ", " \tif (msg->msg_name) {", " \t\tstruct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;", " \t\taddr->nl_family = AF_NETLINK;", " \t\taddr->nl_pad    = 0;", " \t\taddr->nl_pid\t= NETLINK_CB(skb).portid;", " \t\taddr->nl_groups\t= netlink_group_mask(NETLINK_CB(skb).dst_group);", " \t\tmsg->msg_namelen = sizeof(*addr);", " \t}", " ", " \tif (nlk->flags & NETLINK_RECV_PKTINFO)", " \t\tnetlink_cmsg_recv_pktinfo(msg, skb);", " ", " \tif (NULL == siocb->scm) {", " \t\tmemset(&scm, 0, sizeof(scm));", " \t\tsiocb->scm = &scm;", " \t}", " \tsiocb->scm->creds = *NETLINK_CREDS(skb);", " \tif (flags & MSG_TRUNC)", " \t\tcopied = data_skb->len;", " ", " \tskb_free_datagram(sk, skb);", " ", " \tif (nlk->cb_running &&", " \t    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {", " \t\tret = netlink_dump(sk);", " \t\tif (ret) {", " \t\t\tsk->sk_err = ret;", " \t\t\tsk->sk_error_report(sk);", " \t\t}", " \t}", " ", " \tscm_recv(sock, msg, siocb->scm, flags);", " out:", " \tnetlink_rcv_wake(sk);", " \treturn err ? : copied;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int hci_uart_set_proto(struct hci_uart *hu, int id)", " {", " \tconst struct hci_uart_proto *p;", " \tint err;", " ", " \tp = hci_uart_get_proto(id);", " \tif (!p)", "  \t\treturn -EPROTONOSUPPORT;", "  ", "  \thu->proto = p;", "\tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "  ", "  \terr = hci_uart_register_dev(hu);", "  \tif (err) {", "\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);", "  \t\treturn err;", "  \t}", "  ", " \tset_bit(HCI_UART_PROTO_READY, &hu->flags);", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]}
{"tokens": [" bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)", " static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)", "  {", "  \tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);", "  \tstruct extent_tree *et;", " \tstruct extent_node *en;", " \tstruct extent_info ei;", " ", " \tif (!f2fs_may_extent_tree(inode)) {", " \t\t ", " \t\tif (i_ext && i_ext->len) {", " \t\t\ti_ext->len = 0;", " \t\t\treturn true;", " \t\t}", " \t\treturn false;", " \t}", " ", " \tet = __grab_extent_tree(inode);", " ", " \tif (!i_ext || !i_ext->len)", " \t\treturn false;", " ", " \tget_extent_info(&ei, i_ext);", " ", " \twrite_lock(&et->lock);", " \tif (atomic_read(&et->node_cnt))", " \t\tgoto out;", " ", " \ten = __init_extent_tree(sbi, et, &ei);", " \tif (en) {", " \t\tspin_lock(&sbi->extent_lock);", " \t\tlist_add_tail(&en->list, &sbi->extent_list);", " \t\tspin_unlock(&sbi->extent_lock);", " \t}", " out:", " \twrite_unlock(&et->lock);", "  \treturn false;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ixheaacd_complex_anal_filt(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer) {", "   WORD32 idx;", "   WORD32 anal_size = 2 * ptr_hbe_txposer->synth_size;", "   WORD32 N = (10 * anal_size);", " ", "  for (idx = 0; idx < (ptr_hbe_txposer->no_bins >> 1); idx++) {", "     WORD32 i, j, k, l;", "     FLOAT32 window_output[640];", "     FLOAT32 u[128], u_in[256], u_out[256];", "     FLOAT32 accu_r, accu_i;", "  const FLOAT32 *inp_signal;", "     FLOAT32 *anal_buf;", " ", "     FLOAT32 *analy_cos_sin_tab = ptr_hbe_txposer->analy_cos_sin_tab;", "  const FLOAT32 *interp_window_coeff = ptr_hbe_txposer->analy_wind_coeff;", "     FLOAT32 *x = ptr_hbe_txposer->analy_buf;", " ", "     memset(ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1], 0,", "            TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof(FLOAT32));", " ", "     inp_signal = ptr_hbe_txposer->ptr_input_buf +", "                  idx * 2 * ptr_hbe_txposer->synth_size + 1;", "     anal_buf = &ptr_hbe_txposer->qmf_in_buf[idx + HBE_OPER_WIN_LEN - 1]", "  [4 * ptr_hbe_txposer->k_start];", " ", "  for (i = N - 1; i >= anal_size; i--) {", "       x[i] = x[i - anal_size];", "  }", " ", "  for (i = anal_size - 1; i >= 0; i--) {", "       x[i] = inp_signal[anal_size - 1 - i];", "  }", " ", "  for (i = 0; i < N; i++) {", "       window_output[i] = x[i] * interp_window_coeff[i];", "  }", " ", "  for (i = 0; i < 2 * anal_size; i++) {", "       accu_r = 0.0;", "  for (j = 0; j < 5; j++) {", "         accu_r = accu_r + window_output[i + j * 2 * anal_size];", "  }", "       u[i] = accu_r;", "  }", " ", "  if (anal_size == 40) {", "  for (i = 1; i < anal_size; i++) {", "         FLOAT32 temp1 = u[i] + u[2 * anal_size - i];", "         FLOAT32 temp2 = u[i] - u[2 * anal_size - i];", "         u[i] = temp1;", "         u[2 * anal_size - i] = temp2;", "  }", " ", "  for (k = 0; k < anal_size; k++) {", "         accu_r = u[anal_size];", "  if (k & 1)", "           accu_i = u[0];", "  else", "           accu_i = -u[0];", "  for (l = 1; l < anal_size; l++) {", "           accu_r = accu_r + u[0 + l] * analy_cos_sin_tab[2 * l + 0];", "           accu_i = accu_i + u[2 * anal_size - l] * analy_cos_sin_tab[2 * l + 1];", "  }", "         analy_cos_sin_tab += (2 * anal_size);", "  *anal_buf++ = (FLOAT32)accu_r;", "  *anal_buf++ = (FLOAT32)accu_i;", "  }", "  } else {", "       FLOAT32 *ptr_u = u_in;", "       FLOAT32 *ptr_v = u_out;", "  for (k = 0; k < anal_size * 2; k++) {", " ", "          *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);", "          *ptr_u++ = ((*analy_cos_sin_tab++) * u[k]);", "        }", "      if (ixheaacd_cmplx_anal_fft != NULL)", "        (*ixheaacd_cmplx_anal_fft)(u_in, u_out, anal_size * 2);", "       if (ptr_hbe_txposer->ixheaacd_cmplx_anal_fft != NULL)", "         (*(ptr_hbe_txposer->ixheaacd_cmplx_anal_fft))(u_in, u_out,", "                                                       anal_size * 2);", "        else", "          return -1;", "  ", "  for (k = 0; k < anal_size / 2; k++) {", "  *(anal_buf + 1) = -*ptr_v++;", "  *anal_buf = *ptr_v++;", " ", "         anal_buf += 2;", " ", "  *(anal_buf + 1) = *ptr_v++;", "  *anal_buf = -*ptr_v++;", " ", "         anal_buf += 2;", "  }", "  }", "  }", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void build_l4proto_icmp(const struct nf_conntrack *ct, struct nethdr *n)", "  {", " \t ", " \tif (!nfct_attr_is_set(ct, ATTR_ICMP_TYPE))", " \t\treturn;", " ", "  \tct_build_u8(ct, ATTR_ICMP_TYPE, n, NTA_ICMP_TYPE);", "  \tct_build_u8(ct, ATTR_ICMP_CODE, n, NTA_ICMP_CODE);", "  \tct_build_u16(ct, ATTR_ICMP_ID, n, NTA_ICMP_ID);", " \tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,", " \t\t      sizeof(struct nfct_attr_grp_port));", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ExtensionFunction::ResponseAction UsbFindDevicesFunction::Run() {", "   scoped_ptr<extensions::core_api::usb::FindDevices::Params> parameters =", "       FindDevices::Params::Create(*args_);", "   EXTENSION_FUNCTION_VALIDATE(parameters.get());", "  ", "    vendor_id_ = parameters->options.vendor_id;", "    product_id_ = parameters->options.product_id;", "  interface_id_ = parameters->options.interface_id.get()", "                      ? *parameters->options.interface_id.get()", "                      : UsbDevicePermissionData::ANY_INTERFACE;", "  UsbDevicePermission::CheckParam param(vendor_id_, product_id_, interface_id_);", "   int interface_id = parameters->options.interface_id.get()", "                          ? *parameters->options.interface_id.get()", "                          : UsbDevicePermissionData::ANY_INTERFACE;", "   UsbDevicePermission::CheckParam param(vendor_id_, product_id_, interface_id);", "    if (!extension()->permissions_data()->CheckAPIPermissionWithParam(", "            APIPermission::kUsbDevice, &param)) {", "      return RespondNow(Error(kErrorPermissionDenied));", "   }", " ", "   UsbService* service = device::DeviceClient::Get()->GetUsbService();", "   if (!service) {", "     return RespondNow(Error(kErrorInitService));", "   }", " ", "   service->GetDevices(", "       base::Bind(&UsbFindDevicesFunction::OnGetDevicesComplete, this));", "   return RespondLater();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,", "                                                           PolkitSubject                  *caller,", "                                                           PolkitSubject                  *subject,", "                                                           const gchar                    *action_id,", "                                                           PolkitDetails                  *details,", "                                                           PolkitCheckAuthorizationFlags   flags,", "                                                           GCancellable                   *cancellable,", "                                                           GAsyncReadyCallback             callback,", "                                                           gpointer                        user_data)", " {", "   PolkitBackendInteractiveAuthority *interactive_authority;", "   PolkitBackendInteractiveAuthorityPrivate *priv;", "   gchar *caller_str;", "    gchar *subject_str;", "    PolkitIdentity *user_of_caller;", "    PolkitIdentity *user_of_subject;", "   gboolean user_of_subject_matches;", "    gchar *user_of_caller_str;", "    gchar *user_of_subject_str;", "    PolkitAuthorizationResult *result;", "   GError *error;", "   GSimpleAsyncResult *simple;", "   gboolean has_details;", "   gchar **detail_keys;", " ", "   interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);", "   priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);", " ", "   error = NULL;", "   caller_str = NULL;", "   subject_str = NULL;", "   user_of_caller = NULL;", "   user_of_subject = NULL;", "   user_of_caller_str = NULL;", "   user_of_subject_str = NULL;", "   result = NULL;", " ", "   simple = g_simple_async_result_new (G_OBJECT (authority),", "                                       callback,", "                                       user_data,", "                                       polkit_backend_interactive_authority_check_authorization);", " ", "    ", "   if (caller == NULL)", "     {", "        ", "       GDBusConnection *system_bus;", "       system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);", "       caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));", "       g_object_unref (system_bus);", "     }", " ", "   caller_str = polkit_subject_to_string (caller);", "   subject_str = polkit_subject_to_string (subject);", " ", "   g_debug (\"%s is inquiring whether %s is authorized for %s\",", "            caller_str,", "            subject_str,", "            action_id);", "             action_id);", "  ", "    user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,", "                                                                        caller,", "                                                                         caller, NULL,", "                                                                          &error);", "    if (error != NULL)", "      {", "       g_simple_async_result_complete (simple);", "       g_object_unref (simple);", "       g_error_free (error);", "       goto out;", "     }", " ", "   user_of_caller_str = polkit_identity_to_string (user_of_caller);", "   g_debug (\" user of caller is %s\", user_of_caller_str);", "    g_debug (\" user of caller is %s\", user_of_caller_str);", "  ", "    user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,", "                                                                         subject,", "                                                                          subject, &user_of_subject_matches,", "                                                                           &error);", "    if (error != NULL)", "      {", "       g_simple_async_result_complete (simple);", "       g_object_unref (simple);", "       g_error_free (error);", "       goto out;", "     }", " ", "   user_of_subject_str = polkit_identity_to_string (user_of_subject);", "   g_debug (\" user of subject is %s\", user_of_subject_str);", " ", "   has_details = FALSE;", "   if (details != NULL)", "     {", "       detail_keys = polkit_details_get_keys (details);", "       if (detail_keys != NULL)", "         {", "           if (g_strv_length (detail_keys) > 0)", "             has_details = TRUE;", "           g_strfreev (detail_keys);", "         }", "     }", " ", "    ", "  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)", "   if (!user_of_subject_matches", "       || !polkit_identity_equal (user_of_caller, user_of_subject)", "       || has_details)", "      {", "        if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))", "          {", "                                                \"pass details\");", "             }", "           else", "             {", "               g_simple_async_result_set_error (simple,", "                                                POLKIT_ERROR,", "                                                POLKIT_ERROR_NOT_AUTHORIZED,", "                                                \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"", "                                                \"subjects belonging to other identities\");", "             }", "           g_simple_async_result_complete (simple);", "           g_object_unref (simple);", "           goto out;", "         }", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ospf6_print_lshdr(netdissect_options *ndo,", "                   register const struct lsa6_hdr *lshp, const u_char *dataend)", "  {", "  \tif ((const u_char *)(lshp + 1) > dataend)", "  \t\tgoto trunc;", "\tND_TCHECK(lshp->ls_type);", "\tND_TCHECK(lshp->ls_seq);", " \tND_TCHECK(lshp->ls_length);\t ", "  ", "  \tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",", "                 ipaddr_string(ndo, &lshp->ls_router),", "                EXTRACT_32BITS(&lshp->ls_seq),", "                EXTRACT_16BITS(&lshp->ls_age),", "                EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));", " ", " \tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);", " ", " \treturn (0);", " trunc:", " \treturn (1);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WritePNMImage(const ImageInfo *image_info,Image *image,", "   ExceptionInfo *exception)", " {", "   char", "     buffer[MagickPathExtent],", "     format,", "     magick[MagickPathExtent];", " ", "   const char", "     *value;", " ", "   MagickBooleanType", "     status;", " ", "   MagickOffsetType", "     scene;", " ", "   Quantum", "     index;", " ", "   QuantumAny", "     pixel;", " ", "   QuantumInfo", "     *quantum_info;", " ", "   QuantumType", "     quantum_type;", " ", "   register unsigned char", "     *q;", " ", "   size_t", "     extent,", "     imageListLength,", "     packet_size;", " ", "   ssize_t", "     count,", "     y;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickCoreSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     return(status);", "   scene=0;", "   imageListLength=GetImageListLength(image);", "   do", "   {", "     QuantumAny", "       max_value;", " ", "      ", "     packet_size=3;", "     quantum_type=RGBQuantum;", "     (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);", "     max_value=GetQuantumRange(image->depth);", "     switch (magick[1])", "     {", "       case 'A':", "       case 'a':", "       {", "         format='7';", "         break;", "       }", "       case 'B':", "       case 'b':", "       {", "         format='4';", "         if (image_info->compression == NoCompression)", "           format='1';", "         break;", "       }", "       case 'F':", "       case 'f':", "       {", "         format='F';", "         if (SetImageGray(image,exception) != MagickFalse)", "           format='f';", "         break;", "       }", "       case 'G':", "       case 'g':", "       {", "         format='5';", "         if (image_info->compression == NoCompression)", "           format='2';", "         break;", "       }", "       case 'N':", "       case 'n':", "       {", "         if ((image_info->type != TrueColorType) &&", "             (SetImageGray(image,exception) != MagickFalse))", "           {", "             format='5';", "             if (image_info->compression == NoCompression)", "               format='2';", "             if (SetImageMonochrome(image,exception) != MagickFalse)", "               {", "                 format='4';", "                 if (image_info->compression == NoCompression)", "                   format='1';", "               }", "             break;", "           }", "       }", "       default:", "       {", "         format='6';", "         if (image_info->compression == NoCompression)", "           format='3';", "         break;", "       }", "     }", "     (void) FormatLocaleString(buffer,MagickPathExtent,\"P%c\\n\",format);", "     (void) WriteBlobString(image,buffer);", "     value=GetImageProperty(image,\"comment\",exception);", "     if (value != (const char *) NULL)", "       {", "         register const char", "           *p;", " ", "          ", "         (void) WriteBlobByte(image,'#');", "         for (p=value; *p != '\\0'; p++)", "         {", "           (void) WriteBlobByte(image,(unsigned char) *p);", "           if ((*p == '\\n') || (*p == '\\r'))", "             (void) WriteBlobByte(image,'#');", "         }", "         (void) WriteBlobByte(image,'\\n');", "       }", "     if (format != '7')", "       {", "         (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g %.20g\\n\",", "           (double) image->columns,(double) image->rows);", "         (void) WriteBlobString(image,buffer);", "       }", "     else", "       {", "         char", "           type[MagickPathExtent];", " ", "          ", "         (void) FormatLocaleString(buffer,MagickPathExtent,", "           \"WIDTH %.20g\\nHEIGHT %.20g\\n\",(double) image->columns,(double)", "           image->rows);", "         (void) WriteBlobString(image,buffer);", "         quantum_type=GetQuantumType(image,exception);", "         switch (quantum_type)", "         {", "           case CMYKQuantum:", "           case CMYKAQuantum:", "           {", "             packet_size=4;", "             (void) CopyMagickString(type,\"CMYK\",MagickPathExtent);", "             break;", "           }", "           case GrayQuantum:", "           case GrayAlphaQuantum:", "           {", "             packet_size=1;", "             (void) CopyMagickString(type,\"GRAYSCALE\",MagickPathExtent);", "             if (IdentifyImageMonochrome(image,exception) != MagickFalse)", "               (void) CopyMagickString(type,\"BLACKANDWHITE\",MagickPathExtent);", "             break;", "           }", "           default:", "           {", "             quantum_type=RGBQuantum;", "             if (image->alpha_trait != UndefinedPixelTrait)", "               quantum_type=RGBAQuantum;", "             packet_size=3;", "             (void) CopyMagickString(type,\"RGB\",MagickPathExtent);", "             break;", "           }", "         }", "         if (image->alpha_trait != UndefinedPixelTrait)", "           {", "             packet_size++;", "             (void) ConcatenateMagickString(type,\"_ALPHA\",MagickPathExtent);", "           }", "         if (image->depth > 32)", "           image->depth=32;", "         (void) FormatLocaleString(buffer,MagickPathExtent,", "           \"DEPTH %.20g\\nMAXVAL %.20g\\n\",(double) packet_size,(double)", "           ((MagickOffsetType) GetQuantumRange(image->depth)));", "         (void) WriteBlobString(image,buffer);", "         (void) FormatLocaleString(buffer,MagickPathExtent,", "           \"TUPLTYPE %s\\nENDHDR\\n\",type);", "         (void) WriteBlobString(image,buffer);", "       }", "      ", "     switch (format)", "     {", "       case '1':", "       {", "         unsigned char", "           pixels[2048];", " ", "          ", "         (void) SetImageType(image,BilevelType,exception);", "         q=pixels;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             *q++=(unsigned char) (GetPixelLuma(image,p) >= (QuantumRange/2.0) ?", "               '0' : '1');", "             *q++=' ';", "             if ((q-pixels+1) >= (ssize_t) sizeof(pixels))", "               {", "                 *q++='\\n';", "                 (void) WriteBlob(image,q-pixels,pixels);", "                 q=pixels;", "               }", "             p+=GetPixelChannels(image);", "           }", "           *q++='\\n';", "           (void) WriteBlob(image,q-pixels,pixels);", "           q=pixels;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         if (q != pixels)", "           {", "             *q++='\\n';", "             (void) WriteBlob(image,q-pixels,pixels);", "           }", "         break;", "       }", "       case '2':", "       {", "         unsigned char", "           pixels[2048];", " ", "          ", "         if (image->depth <= 8)", "           (void) WriteBlobString(image,\"255\\n\");", "         else", "           if (image->depth <= 16)", "             (void) WriteBlobString(image,\"65535\\n\");", "           else", "             (void) WriteBlobString(image,\"4294967295\\n\");", "         q=pixels;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             index=ClampToQuantum(GetPixelLuma(image,p));", "             if (image->depth <= 8)", "               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,\"%u \",", "                 ScaleQuantumToChar(index));", "             else", "               if (image->depth <= 16)", "                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,", "                   \"%u \",ScaleQuantumToShort(index));", "               else", "                  count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,", "                    \"%u \",ScaleQuantumToLong(index));", "              extent=(size_t) count;", "            (void) strncpy((char *) q,buffer,extent);", "            q+=extent;", "            if ((q-pixels+extent+2) >= sizeof(pixels))", "             if ((q-pixels+extent+1) >= sizeof(pixels))", "                {", "                  *q++='\\n';", "                  (void) WriteBlob(image,q-pixels,pixels);", "                  q=pixels;", "                }", "             (void) strncpy((char *) q,buffer,extent);", "             q+=extent;", "              p+=GetPixelChannels(image);", "            }", "            *q++='\\n';", "           (void) WriteBlob(image,q-pixels,pixels);", "           q=pixels;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         if (q != pixels)", "           {", "             *q++='\\n';", "             (void) WriteBlob(image,q-pixels,pixels);", "           }", "         break;", "       }", "       case '3':", "       {", "         unsigned char", "           pixels[2048];", " ", "          ", "         (void) TransformImageColorspace(image,sRGBColorspace,exception);", "         if (image->depth <= 8)", "           (void) WriteBlobString(image,\"255\\n\");", "         else", "           if (image->depth <= 16)", "             (void) WriteBlobString(image,\"65535\\n\");", "           else", "             (void) WriteBlobString(image,\"4294967295\\n\");", "         q=pixels;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             if (image->depth <= 8)", "               count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,", "                 \"%u %u %u \",ScaleQuantumToChar(GetPixelRed(image,p)),", "                 ScaleQuantumToChar(GetPixelGreen(image,p)),", "                 ScaleQuantumToChar(GetPixelBlue(image,p)));", "             else", "               if (image->depth <= 16)", "                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,", "                   \"%u %u %u \",ScaleQuantumToShort(GetPixelRed(image,p)),", "                   ScaleQuantumToShort(GetPixelGreen(image,p)),", "                   ScaleQuantumToShort(GetPixelBlue(image,p)));", "               else", "                 count=(ssize_t) FormatLocaleString(buffer,MagickPathExtent,", "                   \"%u %u %u \",ScaleQuantumToLong(GetPixelRed(image,p)),", "                    ScaleQuantumToLong(GetPixelGreen(image,p)),", "                    ScaleQuantumToLong(GetPixelBlue(image,p)));", "              extent=(size_t) count;", "            (void) strncpy((char *) q,buffer,extent);", "            q+=extent;", "              if ((q-pixels+extent+2) >= sizeof(pixels))", "                {", "                  *q++='\\n';", "                  (void) WriteBlob(image,q-pixels,pixels);", "                  q=pixels;", "                }", "             (void) strncpy((char *) q,buffer,extent);", "             q+=extent;", "              p+=GetPixelChannels(image);", "            }", "            *q++='\\n';", "           (void) WriteBlob(image,q-pixels,pixels);", "           q=pixels;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         if (q != pixels)", "           {", "             *q++='\\n';", "             (void) WriteBlob(image,q-pixels,pixels);", "           }", "         break;", "       }", "       case '4':", "       {", "         register unsigned char", "           *pixels;", " ", "          ", "         (void) SetImageType(image,BilevelType,exception);", "         image->depth=1;", "         quantum_info=AcquireQuantumInfo(image_info,image);", "         if (quantum_info == (QuantumInfo *) NULL)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         (void) SetQuantumEndian(image,quantum_info,MSBEndian);", "         quantum_info->min_is_white=MagickTrue;", "         pixels=GetQuantumPixels(quantum_info);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "             GrayQuantum,pixels,exception);", "           count=WriteBlob(image,extent,pixels);", "           if (count != (ssize_t) extent)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         break;", "       }", "       case '5':", "       {", "         register unsigned char", "           *pixels;", " ", "          ", "         if (image->depth > 32)", "           image->depth=32;", "         (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)", "           ((MagickOffsetType) GetQuantumRange(image->depth)));", "         (void) WriteBlobString(image,buffer);", "         quantum_info=AcquireQuantumInfo(image_info,image);", "         if (quantum_info == (QuantumInfo *) NULL)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         (void) SetQuantumEndian(image,quantum_info,MSBEndian);", "         quantum_info->min_is_white=MagickTrue;", "         pixels=GetQuantumPixels(quantum_info);", "         extent=GetQuantumExtent(image,quantum_info,GrayQuantum);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           q=pixels;", "           switch (image->depth)", "           {", "             case 8:", "             case 16:", "             case 32:", "             {", "               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "                 GrayQuantum,pixels,exception);", "               break;", "             }", "             default:", "             {", "               if (image->depth <= 8)", "                 {", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     if (IsPixelGray(image,p) == MagickFalse)", "                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(", "                         image,p)),max_value);", "                     else", "                       {", "                         if (image->depth == 8)", "                           pixel=ScaleQuantumToChar(GetPixelRed(image,p));", "                         else", "                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),", "                             max_value);", "                       }", "                     q=PopCharPixel((unsigned char) pixel,q);", "                     p+=GetPixelChannels(image);", "                   }", "                   extent=(size_t) (q-pixels);", "                   break;", "                 }", "               if (image->depth <= 16)", "                 {", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     if (IsPixelGray(image,p) == MagickFalse)", "                       pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,", "                         p)),max_value);", "                     else", "                       {", "                         if (image->depth == 16)", "                           pixel=ScaleQuantumToShort(GetPixelRed(image,p));", "                         else", "                           pixel=ScaleQuantumToAny(GetPixelRed(image,p),", "                             max_value);", "                       }", "                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                     p+=GetPixelChannels(image);", "                   }", "                   extent=(size_t) (q-pixels);", "                   break;", "                 }", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 if (IsPixelGray(image,p) == MagickFalse)", "                   pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,p)),", "                     max_value);", "                 else", "                   {", "                     if (image->depth == 16)", "                       pixel=ScaleQuantumToLong(GetPixelRed(image,p));", "                     else", "                       pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                   }", "                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                 p+=GetPixelChannels(image);", "               }", "               extent=(size_t) (q-pixels);", "               break;", "             }", "           }", "           count=WriteBlob(image,extent,pixels);", "           if (count != (ssize_t) extent)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         break;", "       }", "       case '6':", "       {", "         register unsigned char", "           *pixels;", " ", "          ", "         (void) TransformImageColorspace(image,sRGBColorspace,exception);", "         if (image->depth > 32)", "           image->depth=32;", "         (void) FormatLocaleString(buffer,MagickPathExtent,\"%.20g\\n\",(double)", "           ((MagickOffsetType) GetQuantumRange(image->depth)));", "         (void) WriteBlobString(image,buffer);", "         quantum_info=AcquireQuantumInfo(image_info,image);", "         if (quantum_info == (QuantumInfo *) NULL)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         (void) SetQuantumEndian(image,quantum_info,MSBEndian);", "         pixels=GetQuantumPixels(quantum_info);", "         extent=GetQuantumExtent(image,quantum_info,quantum_type);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           q=pixels;", "           switch (image->depth)", "           {", "             case 8:", "             case 16:", "             case 32:", "             {", "               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "                 quantum_type,pixels,exception);", "               break;", "             }", "             default:", "             {", "               if (image->depth <= 8)", "                 {", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                     q=PopCharPixel((unsigned char) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);", "                     q=PopCharPixel((unsigned char) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);", "                     q=PopCharPixel((unsigned char) pixel,q);", "                     p+=GetPixelChannels(image);", "                   }", "                   extent=(size_t) (q-pixels);", "                   break;", "                 }", "               if (image->depth <= 16)", "                 {", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);", "                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);", "                     q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                     p+=GetPixelChannels(image);", "                   }", "                   extent=(size_t) (q-pixels);", "                   break;", "                 }", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                 pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);", "                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                 pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);", "                 q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                 p+=GetPixelChannels(image);", "               }", "               extent=(size_t) (q-pixels);", "               break;", "             }", "           }", "           count=WriteBlob(image,extent,pixels);", "           if (count != (ssize_t) extent)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         break;", "       }", "       case '7':", "       {", "         register unsigned char", "           *pixels;", " ", "          ", "         if (image->depth > 32)", "           image->depth=32;", "         quantum_info=AcquireQuantumInfo(image_info,image);", "         if (quantum_info == (QuantumInfo *) NULL)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         (void) SetQuantumEndian(image,quantum_info,MSBEndian);", "         pixels=GetQuantumPixels(quantum_info);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           register ssize_t", "             x;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           q=pixels;", "           switch (image->depth)", "           {", "             case 8:", "             case 16:", "             case 32:", "             {", "               extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "                 quantum_type,pixels,exception);", "               break;", "             }", "             default:", "             {", "               switch (quantum_type)", "               {", "                 case GrayQuantum:", "                 case GrayAlphaQuantum:", "                 {", "                   if (image->depth <= 8)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(", "                           image,p)),max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=(unsigned char) ScaleQuantumToAny(", "                               GetPixelAlpha(image,p),max_value);", "                             q=PopCharPixel((unsigned char) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   if (image->depth <= 16)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(", "                           image,p)),max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=(unsigned char) ScaleQuantumToAny(", "                               GetPixelAlpha(image,p),max_value);", "                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     pixel=ScaleQuantumToAny(ClampToQuantum(GetPixelLuma(image,", "                       p)),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     if (image->alpha_trait != UndefinedPixelTrait)", "                       {", "                         pixel=(unsigned char) ScaleQuantumToAny(", "                           GetPixelAlpha(image,p),max_value);", "                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                       }", "                     p+=GetPixelChannels(image);", "                   }", "                   break;", "                 }", "                 case CMYKQuantum:", "                 case CMYKAQuantum:", "                 {", "                   if (image->depth <= 8)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),", "                           max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),", "                           max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),", "                           max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                               max_value);", "                             q=PopCharPixel((unsigned char) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   if (image->depth <= 16)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),", "                           max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),", "                           max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlack(image,p),", "                           max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                               max_value);", "                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelBlack(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     if (image->alpha_trait != UndefinedPixelTrait)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                           max_value);", "                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                       }", "                     p+=GetPixelChannels(image);", "                   }", "                   break;", "                 }", "                 default:", "                 {", "                   if (image->depth <= 8)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),", "                           max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),", "                           max_value);", "                         q=PopCharPixel((unsigned char) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                               max_value);", "                             q=PopCharPixel((unsigned char) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   if (image->depth <= 16)", "                     {", "                       for (x=0; x < (ssize_t) image->columns; x++)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelGreen(image,p),", "                           max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         pixel=ScaleQuantumToAny(GetPixelBlue(image,p),", "                           max_value);", "                         q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                         if (image->alpha_trait != UndefinedPixelTrait)", "                           {", "                             pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                               max_value);", "                             q=PopShortPixel(MSBEndian,(unsigned short) pixel,q);", "                           }", "                         p+=GetPixelChannels(image);", "                       }", "                       break;", "                     }", "                   for (x=0; x < (ssize_t) image->columns; x++)", "                   {", "                     pixel=ScaleQuantumToAny(GetPixelRed(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelGreen(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     pixel=ScaleQuantumToAny(GetPixelBlue(image,p),max_value);", "                     q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                     if (image->alpha_trait != UndefinedPixelTrait)", "                       {", "                         pixel=ScaleQuantumToAny(GetPixelAlpha(image,p),", "                           max_value);", "                         q=PopLongPixel(MSBEndian,(unsigned int) pixel,q);", "                       }", "                     p+=GetPixelChannels(image);", "                   }", "                   break;", "                 }", "               }", "               extent=(size_t) (q-pixels);", "               break;", "             }", "           }", "           count=WriteBlob(image,extent,pixels);", "           if (count != (ssize_t) extent)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         break;", "       }", "       case 'F':", "       case 'f':", "       {", "         register unsigned char", "           *pixels;", " ", "         (void) WriteBlobString(image,image->endian == LSBEndian ? \"-1.0\\n\" :", "           \"1.0\\n\");", "         image->depth=32;", "         quantum_type=format == 'f' ? GrayQuantum : RGBQuantum;", "         quantum_info=AcquireQuantumInfo(image_info,image);", "         if (quantum_info == (QuantumInfo *) NULL)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);", "         if (status == MagickFalse)", "           ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "         pixels=GetQuantumPixels(quantum_info);", "         for (y=(ssize_t) image->rows-1; y >= 0; y--)", "         {", "           register const Quantum", "             *magick_restrict p;", " ", "           p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "           if (p == (const Quantum *) NULL)", "             break;", "           extent=ExportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "             quantum_type,pixels,exception);", "           (void) WriteBlob(image,extent,pixels);", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         break;", "       }", "     }", "     if (GetNextImageInList(image) == (Image *) NULL)", "       break;", "     image=SyncNextImageInList(image);", "     status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);", "     if (status == MagickFalse)", "       break;", "   } while (image_info->adjoin != MagickFalse);", "   (void) CloseBlob(image);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> V8TestNamedConstructorConstructorCallback(const v8::Arguments& args)", " {", "     INC_STATS(\"DOM.TestNamedConstructor.Constructor\");", " ", "     if (!args.IsConstructCall())", "         return V8Proxy::throwTypeError(\"DOM object constructor cannot be called as a function.\");", " ", "     if (ConstructorMode::current() == ConstructorMode::WrapExistingObject)", "         return args.Holder();", " ", "     Frame* frame = V8Proxy::retrieveFrameForCurrentContext();", "     if (!frame)", "         return V8Proxy::throwError(V8Proxy::ReferenceError, \"TestNamedConstructor constructor associated frame is unavailable\", args.GetIsolate());", " ", "     Document* document = frame->document();", " ", "      toV8(document, args.GetIsolate());", "  ", "      if (args.Length() < 1)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "  ", "      ExceptionCode ec = 0;", "      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str1, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));", "     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str2, MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined));", "     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str3, MAYBE_MISSING_PARAMETER(args, 2, DefaultIsNullString));", " ", "     RefPtr<TestNamedConstructor> impl = TestNamedConstructor::createForJSConstructor(document, str1, str2, str3, ec);", "     v8::Handle<v8::Object> wrapper = args.Holder();", "     if (ec)", "         goto fail;", " ", "     V8DOMWrapper::setDOMWrapper(wrapper, &V8TestNamedConstructorConstructor::info, impl.get());", "     V8DOMWrapper::setJSWrapperForActiveDOMObject(impl.release(), v8::Persistent<v8::Object>::New(wrapper), args.GetIsolate());", "     return args.Holder();", "   fail:", "     return throwError(ec, args.GetIsolate());", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int phar_parse_pharfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, long halt_offset, phar_archive_data** pphar, php_uint32 compression, char **error TSRMLS_DC)", "{", "char b32[4], *buffer, *endbuffer, *savebuf;", "phar_archive_data *mydata = NULL;", "phar_entry_info entry;", "php_uint32 manifest_len, manifest_count, manifest_flags, manifest_index, tmp_len, sig_flags;", "php_uint16 manifest_ver;", "php_uint32 len;", "long offset;", "int sig_len, register_alias = 0, temp_alias = 0;", "char *signature = NULL;", "", "if (pphar) {", "*pphar = NULL;", "}", "", "if (error) {", "*error = NULL;", "}", "", "", "if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {", "MAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")", "}", "", "buffer = b32;", "", "if (3 != php_stream_read(fp, buffer, 3)) {", "MAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")", "}", "", "if ((*buffer == ' ' || *buffer == '\\n') && *(buffer + 1) == '?' && *(buffer + 2) == '>') {", "int nextchar;", "halt_offset += 3;", "if (EOF == (nextchar = php_stream_getc(fp))) {", "MAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")", "}", "", "if ((char) nextchar == '\\r') {", "", "if (EOF == (nextchar = php_stream_getc(fp)) || (char)nextchar != '\\n') {", "MAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at stub end)\")", "}", "++halt_offset;", "}", "", "if ((char) nextchar == '\\n') {", "++halt_offset;", "}", "}", "", "", "if (-1 == php_stream_seek(fp, halt_offset, SEEK_SET)) {", "MAPPHAR_ALLOC_FAIL(\"cannot seek to __HALT_COMPILER(); location in phar \\\"%s\\\"\")", "}", "", "", "buffer = b32;", "", "if (4 != php_stream_read(fp, buffer, 4)) {", "MAPPHAR_ALLOC_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest at manifest length)\")", "}", "", "PHAR_GET_32(buffer, manifest_len);", "", "if (manifest_len > 1048576 * 100) {", "", "MAPPHAR_ALLOC_FAIL(\"manifest cannot be larger than 100 MB in phar \\\"%s\\\"\")", "}", "", "buffer = (char *)emalloc(manifest_len);", "savebuf = buffer;", "endbuffer = buffer + manifest_len;", "", "if (manifest_len < 10 || manifest_len != php_stream_read(fp, buffer, manifest_len)) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")", "}", "", "", "PHAR_GET_32(buffer, manifest_count);", "", "if (manifest_count == 0) {", "MAPPHAR_FAIL(\"in phar \\\"%s\\\", manifest claims to have zero entries.  Phars must have at least 1 entry\");", "}", "", "", "manifest_ver = (((unsigned char)buffer[0]) << 8)", "+ ((unsigned char)buffer[1]);", "buffer += 2;", "", "if ((manifest_ver & PHAR_API_VER_MASK) < PHAR_API_MIN_READ) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" is API version %1.u.%1.u.%1.u, and cannot be processed\", fname, manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0x0F);", "}", "return FAILURE;", "}", "", "PHAR_GET_32(buffer, manifest_flags);", "", "manifest_flags &= ~PHAR_HDR_COMPRESSION_MASK;", "manifest_flags &= ~PHAR_FILE_COMPRESSION_MASK;", "", "manifest_flags |= compression;", "", "", "", "if (manifest_flags & PHAR_HDR_SIGNATURE) {", "char sig_buf[8], *sig_ptr = sig_buf;", "off_t read_len;", "size_t end_of_phar;", "", "if (-1 == php_stream_seek(fp, -8, SEEK_END)", "|| (read_len = php_stream_tell(fp)) < 20", "|| 8 != php_stream_read(fp, sig_buf, 8)", "|| memcmp(sig_buf+4, \"GBMB\", 4)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);", "}", "return FAILURE;", "}", "", "PHAR_GET_32(sig_ptr, sig_flags);", "", "switch(sig_flags) {", "case PHAR_SIG_OPENSSL: {", "php_uint32 signature_len;", "char *sig;", "off_t whence;", "", "", "if (-1 == php_stream_seek(fp, -12, SEEK_CUR)", "|| 4 != php_stream_read(fp, sig_buf, 4)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" openssl signature length could not be read\", fname);", "}", "return FAILURE;", "}", "", "sig_ptr = sig_buf;", "PHAR_GET_32(sig_ptr, signature_len);", "sig = (char *) emalloc(signature_len);", "whence = signature_len + 4;", "whence = -whence;", "", "if (-1 == php_stream_seek(fp, whence, SEEK_CUR)", "|| !(end_of_phar = php_stream_tell(fp))", "|| signature_len != php_stream_read(fp, sig, signature_len)) {", "efree(savebuf);", "efree(sig);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be read\", fname);", "}", "return FAILURE;", "}", "", "if (FAILURE == phar_verify_signature(fp, end_of_phar, PHAR_SIG_OPENSSL, sig, signature_len, fname, &signature, &sig_len, error TSRMLS_CC)) {", "efree(savebuf);", "efree(sig);", "php_stream_close(fp);", "if (error) {", "char *save = *error;", "spprintf(error, 0, \"phar \\\"%s\\\" openssl signature could not be verified: %s\", fname, *error);", "efree(save);", "}", "return FAILURE;", "}", "efree(sig);", "}", "break;", "#if PHAR_HASH_OK", "case PHAR_SIG_SHA512: {", "unsigned char digest[64];", "", "php_stream_seek(fp, -(8 + 64), SEEK_END);", "read_len = php_stream_tell(fp);", "", "if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);", "}", "return FAILURE;", "}", "", "if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA512, (char *)digest, 64, fname, &signature, &sig_len, error TSRMLS_CC)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "char *save = *error;", "spprintf(error, 0, \"phar \\\"%s\\\" SHA512 signature could not be verified: %s\", fname, *error);", "efree(save);", "}", "return FAILURE;", "}", "break;", "}", "case PHAR_SIG_SHA256: {", "unsigned char digest[32];", "", "php_stream_seek(fp, -(8 + 32), SEEK_END);", "read_len = php_stream_tell(fp);", "", "if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);", "}", "return FAILURE;", "}", "", "if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA256, (char *)digest, 32, fname, &signature, &sig_len, error TSRMLS_CC)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "char *save = *error;", "spprintf(error, 0, \"phar \\\"%s\\\" SHA256 signature could not be verified: %s\", fname, *error);", "efree(save);", "}", "return FAILURE;", "}", "break;", "}", "#else", "case PHAR_SIG_SHA512:", "case PHAR_SIG_SHA256:", "efree(savebuf);", "php_stream_close(fp);", "", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a unsupported signature\", fname);", "}", "return FAILURE;", "#endif", "case PHAR_SIG_SHA1: {", "unsigned char digest[20];", "", "php_stream_seek(fp, -(8 + 20), SEEK_END);", "read_len = php_stream_tell(fp);", "", "if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);", "}", "return FAILURE;", "}", "", "if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_SHA1, (char *)digest, 20, fname, &signature, &sig_len, error TSRMLS_CC)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "char *save = *error;", "spprintf(error, 0, \"phar \\\"%s\\\" SHA1 signature could not be verified: %s\", fname, *error);", "efree(save);", "}", "return FAILURE;", "}", "break;", "}", "case PHAR_SIG_MD5: {", "unsigned char digest[16];", "", "php_stream_seek(fp, -(8 + 16), SEEK_END);", "read_len = php_stream_tell(fp);", "", "if (php_stream_read(fp, (char*)digest, sizeof(digest)) != sizeof(digest)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken signature\", fname);", "}", "return FAILURE;", "}", "", "if (FAILURE == phar_verify_signature(fp, read_len, PHAR_SIG_MD5, (char *)digest, 16, fname, &signature, &sig_len, error TSRMLS_CC)) {", "efree(savebuf);", "php_stream_close(fp);", "if (error) {", "char *save = *error;", "spprintf(error, 0, \"phar \\\"%s\\\" MD5 signature could not be verified: %s\", fname, *error);", "efree(save);", "}", "return FAILURE;", "}", "break;", "}", "default:", "efree(savebuf);", "php_stream_close(fp);", "", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" has a broken or unsupported signature\", fname);", "}", "return FAILURE;", "}", "} else if (PHAR_G(require_hash)) {", "efree(savebuf);", "php_stream_close(fp);", "", "if (error) {", "spprintf(error, 0, \"phar \\\"%s\\\" does not have a signature\", fname);", "}", "return FAILURE;", "} else {", "sig_flags = 0;", "sig_len = 0;", "}", "", "", "PHAR_GET_32(buffer, tmp_len);", "", "if (buffer + tmp_len > endbuffer) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (buffer overrun)\");", "}", "", "if (manifest_len < 10 + tmp_len) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest header)\")", "}", "", "", "if (tmp_len) {", "", "if (alias && alias_len && (alias_len != (int)tmp_len || strncmp(alias, buffer, tmp_len)))", "{", "buffer[tmp_len] = '\\0';", "php_stream_close(fp);", "", "if (signature) {", "efree(signature);", "}", "", "if (error) {", "spprintf(error, 0, \"cannot load phar \\\"%s\\\" with implicit alias \\\"%s\\\" under different alias \\\"%s\\\"\", fname, buffer, alias);", "}", "", "efree(savebuf);", "return FAILURE;", "}", "", "alias_len = tmp_len;", "alias = buffer;", "buffer += tmp_len;", "register_alias = 1;", "} else if (!alias_len || !alias) {", "", "alias = NULL;", "alias_len = 0;", "register_alias = 0;", "} else if (alias_len) {", "register_alias = 1;", "temp_alias = 1;", "}", "", "", "if (manifest_count > ((manifest_len - 10 - tmp_len) / (5 * 4 + 1))) {", "", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (too many manifest entries for size of manifest)\")", "}", "", "mydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));", "mydata->is_persistent = PHAR_G(persist);", "", "", "PHAR_GET_32(buffer, len);", "if (mydata->is_persistent) {", "mydata->metadata_len = len;", "if(!len) {", "", "PHAR_GET_32(buffer, len);", "}", "}", "if(len > endbuffer - buffer) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (trying to read past buffer end)\");", "}", "if (phar_parse_metadata(&buffer, &mydata->metadata, len TSRMLS_CC) == FAILURE) {", "MAPPHAR_FAIL(\"unable to read phar metadata in .phar file \\\"%s\\\"\");", "}", "buffer += len;", "", "", "zend_hash_init(&mydata->manifest, manifest_count,", "zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);", "zend_hash_init(&mydata->mounted_dirs, 5,", "zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);", "zend_hash_init(&mydata->virtual_dirs, manifest_count * 2,", "zend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);", "mydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);", "#ifdef PHP_WIN32", "phar_unixify_path_separators(mydata->fname, fname_len);", "#endif", "mydata->fname_len = fname_len;", "offset = halt_offset + manifest_len + 4;", "memset(&entry, 0, sizeof(phar_entry_info));", "entry.phar = mydata;", "entry.fp_type = PHAR_FP;", "entry.is_persistent = mydata->is_persistent;", "", "for (manifest_index = 0; manifest_index < manifest_count; ++manifest_index) {", "if (buffer + 4 > endbuffer) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\")", "}", "", "PHAR_GET_32(buffer, entry.filename_len);", "", "if (entry.filename_len == 0) {", "MAPPHAR_FAIL(\"zero-length filename encountered in phar \\\"%s\\\"\");", "}", "", "if (entry.is_persistent) {", "entry.manifest_pos = manifest_index;", "}", "", "if (entry.filename_len + 20 > endbuffer - buffer) {", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");", "}", "", "if ((manifest_ver & PHAR_API_VER_MASK) >= PHAR_API_MIN_DIR && buffer[entry.filename_len - 1] == '/') {", "entry.is_dir = 1;", "} else {", "entry.is_dir = 0;", "}", "", "phar_add_virtual_dirs(mydata, buffer, entry.filename_len TSRMLS_CC);", "entry.filename = pestrndup(buffer, entry.filename_len, entry.is_persistent);", "buffer += entry.filename_len;", "PHAR_GET_32(buffer, entry.uncompressed_filesize);", "PHAR_GET_32(buffer, entry.timestamp);", "", "if (offset == halt_offset + (int)manifest_len + 4) {", "mydata->min_timestamp = entry.timestamp;", "mydata->max_timestamp = entry.timestamp;", "} else {", "if (mydata->min_timestamp > entry.timestamp) {", "mydata->min_timestamp = entry.timestamp;", "} else if (mydata->max_timestamp < entry.timestamp) {", "mydata->max_timestamp = entry.timestamp;", "}", "}", "", "PHAR_GET_32(buffer, entry.compressed_filesize);", "PHAR_GET_32(buffer, entry.crc32);", "PHAR_GET_32(buffer, entry.flags);", "", "if (entry.is_dir) {", "entry.filename_len--;", "entry.flags |= PHAR_ENT_PERM_DEF_DIR;", "}", "", "PHAR_GET_32(buffer, len);", "if (entry.is_persistent) {", "entry.metadata_len = len;", "} else {", "entry.metadata_len = 0;", "}", "if (len > endbuffer - buffer) {", "pefree(entry.filename, entry.is_persistent);", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (truncated manifest entry)\");", "}", "if (phar_parse_metadata(&buffer, &entry.metadata, len TSRMLS_CC) == FAILURE) {", "pefree(entry.filename, entry.is_persistent);", "MAPPHAR_FAIL(\"unable to read file metadata in .phar file \\\"%s\\\"\");", "}", "buffer += len;", "", "entry.offset = entry.offset_abs = offset;", "offset += entry.compressed_filesize;", "", "switch (entry.flags & PHAR_ENT_COMPRESSION_MASK) {", "case PHAR_ENT_COMPRESSED_GZ:", "if (!PHAR_G(has_zlib)) {", "if (entry.metadata) {", "if (entry.is_persistent) {", "free(entry.metadata);", "} else {", "zval_ptr_dtor(&entry.metadata);", "}", "}", "pefree(entry.filename, entry.is_persistent);", "MAPPHAR_FAIL(\"zlib extension is required for gz compressed .phar file \\\"%s\\\"\");", "}", "break;", "case PHAR_ENT_COMPRESSED_BZ2:", "if (!PHAR_G(has_bz2)) {", "if (entry.metadata) {", "if (entry.is_persistent) {", "free(entry.metadata);", "} else {", "zval_ptr_dtor(&entry.metadata);", "}", "}", "pefree(entry.filename, entry.is_persistent);", "MAPPHAR_FAIL(\"bz2 extension is required for bzip2 compressed .phar file \\\"%s\\\"\");", "}", "break;", "default:", "if (entry.uncompressed_filesize != entry.compressed_filesize) {", "if (entry.metadata) {", "if (entry.is_persistent) {", "free(entry.metadata);", "} else {", "zval_ptr_dtor(&entry.metadata);", "}", "}", "pefree(entry.filename, entry.is_persistent);", "MAPPHAR_FAIL(\"internal corruption of phar \\\"%s\\\" (compressed and uncompressed size does not match for uncompressed entry)\");", "}", "break;", "}", "", "manifest_flags |= (entry.flags & PHAR_ENT_COMPRESSION_MASK);", "", "entry.is_crc_checked = (manifest_flags & PHAR_HDR_SIGNATURE ? 1 : 0);", "phar_set_inode(&entry TSRMLS_CC);", "zend_hash_add(&mydata->manifest, entry.filename, entry.filename_len, (void*)&entry, sizeof(phar_entry_info), NULL);", "}", "", "snprintf(mydata->version, sizeof(mydata->version), \"%u.%u.%u\", manifest_ver >> 12, (manifest_ver >> 8) & 0xF, (manifest_ver >> 4) & 0xF);", "mydata->internal_file_start = halt_offset + manifest_len + 4;", "mydata->halt_offset = halt_offset;", "mydata->flags = manifest_flags;", "endbuffer = strrchr(mydata->fname, '/');", "", "if (endbuffer) {", "mydata->ext = memchr(endbuffer, '.', (mydata->fname + fname_len) - endbuffer);", "if (mydata->ext == endbuffer) {", "mydata->ext = memchr(endbuffer + 1, '.', (mydata->fname + fname_len) - endbuffer - 1);", "}", "if (mydata->ext) {", "mydata->ext_len = (mydata->fname + mydata->fname_len) - mydata->ext;", "}", "}", "", "mydata->alias = alias ?", "pestrndup(alias, alias_len, mydata->is_persistent) :", "pestrndup(mydata->fname, fname_len, mydata->is_persistent);", "mydata->alias_len = alias ? alias_len : fname_len;", "mydata->sig_flags = sig_flags;", "mydata->fp = fp;", "mydata->sig_len = sig_len;", "mydata->signature = signature;", "phar_request_initialize(TSRMLS_C);", "", "if (register_alias) {", "phar_archive_data **fd_ptr;", "", "mydata->is_temporary_alias = temp_alias;", "", "if (!phar_validate_alias(mydata->alias, mydata->alias_len)) {", "signature = NULL;", "fp = NULL;", "MAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", invalid alias\");", "}", "", "if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void **)&fd_ptr)) {", "if (SUCCESS != phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {", "signature = NULL;", "fp = NULL;", "MAPPHAR_FAIL(\"Cannot open archive \\\"%s\\\", alias is already in use by existing archive\");", "}", "}", "", "zend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&mydata, sizeof(phar_archive_data*), NULL);", "} else {", "mydata->is_temporary_alias = 1;", "}", "", "zend_hash_add(&(PHAR_GLOBALS->phar_fname_map), mydata->fname, fname_len, (void*)&mydata, sizeof(phar_archive_data*),  NULL);", "efree(savebuf);", "", "if (pphar) {", "*pphar = mydata;", "}", "", "return SUCCESS;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" InputMethodDescriptors* CrosMock::CreateInputMethodDescriptors() {", "  InputMethodDescriptors* descriptors = new InputMethodDescriptors;", " input_method::InputMethodDescriptors*", " CrosMock::CreateInputMethodDescriptors() {", "   input_method::InputMethodDescriptors* descriptors =", "       new input_method::InputMethodDescriptors;", "    descriptors->push_back(", "        input_method::GetFallbackInputMethodDescriptor());", "    return descriptors;", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)", " {", "     PCNetState *s = qemu_get_nic_opaque(nc);", "     int is_padr = 0, is_bcast = 0, is_ladr = 0;", "     uint8_t buf1[60];", "     int remaining;", "     int crc_err = 0;", "     int size = size_;", " ", "     if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size ||", "         (CSR_LOOP(s) && !s->looptest)) {", "         return -1;", "     }", " #ifdef PCNET_DEBUG", "     printf(\"pcnet_receive size=%d\\n\", size);", " #endif", " ", "      ", "     if (size < MIN_BUF_SIZE) {", "         memcpy(buf1, buf, size);", "         memset(buf1 + size, 0, MIN_BUF_SIZE - size);", "         buf = buf1;", "         size = MIN_BUF_SIZE;", "     }", " ", "     if (CSR_PROM(s)", "         || (is_padr=padr_match(s, buf, size))", "         || (is_bcast=padr_bcast(s, buf, size))", "         || (is_ladr=ladr_match(s, buf, size))) {", " ", "         pcnet_rdte_poll(s);", " ", "         if (!(CSR_CRST(s) & 0x8000) && s->rdra) {", "             struct pcnet_RMD rmd;", "             int rcvrc = CSR_RCVRC(s)-1,i;", "             hwaddr nrda;", "             for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {", "                 if (rcvrc <= 1)", "                     rcvrc = CSR_RCVRL(s);", "                 nrda = s->rdra +", "                     (CSR_RCVRL(s) - rcvrc) *", "                     (BCR_SWSTYLE(s) ? 16 : 8 );", "                 RMDLOAD(&rmd, nrda);", "                 if (GET_FIELD(rmd.status, RMDS, OWN)) {", " #ifdef PCNET_DEBUG_RMD", "                     printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",", "                                 rcvrc, CSR_RCVRC(s));", " #endif", "                     CSR_RCVRC(s) = rcvrc;", "                     pcnet_rdte_poll(s);", "                     break;", "                 }", "             }", "         }", " ", "         if (!(CSR_CRST(s) & 0x8000)) {", " #ifdef PCNET_DEBUG_RMD", "             printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));", " #endif", "             s->csr[0] |= 0x1000;  ", "             CSR_MISSC(s)++;", "         } else {", "             uint8_t *src = s->buffer;", "             hwaddr crda = CSR_CRDA(s);", "             struct pcnet_RMD rmd;", "              int pktcount = 0;", "  ", "              if (!s->looptest) {", "                 if (size > 4092) {", " #ifdef PCNET_DEBUG_RMD", "                     fprintf(stderr, \"pcnet: truncates rx packet.\\n\");", " #endif", "                     size = 4092;", "                 }", "                  memcpy(src, buf, size);", "                   ", "                  src[size] = 0;", "                 uint32_t fcs = ~0;", "                 uint8_t *p = src;", " ", "                 while (p != &src[size])", "                     CRC(fcs, *p++);", "                 *(uint32_t *)p = htonl(fcs);", "                 size += 4;", "             } else {", "                 uint32_t fcs = ~0;", "                 uint8_t *p = src;", " ", "                 while (p != &src[size])", "                     CRC(fcs, *p++);", "                 crc_err = (*(uint32_t *)p != htonl(fcs));", "             }", " ", " #ifdef PCNET_DEBUG_MATCH", "             PRINT_PKTHDR(buf);", " #endif", " ", "             RMDLOAD(&rmd, PHYSADDR(s,crda));", "              ", "                 SET_FIELD(&rmd.status, RMDS, STP, 1);", " ", " #define PCNET_RECV_STORE() do {                                 \\", "     int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\", "     hwaddr rbadr = PHYSADDR(s, rmd.rbadr);          \\", "     s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\", "     src += count; remaining -= count;                           \\", "     SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\", "     RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\", "     pktcount++;                                                 \\", " } while (0)", " ", "             remaining = size;", "             PCNET_RECV_STORE();", "             if ((remaining > 0) && CSR_NRDA(s)) {", "                 hwaddr nrda = CSR_NRDA(s);", " #ifdef PCNET_DEBUG_RMD", "                 PRINT_RMD(&rmd);", " #endif", "                 RMDLOAD(&rmd, PHYSADDR(s,nrda));", "                 if (GET_FIELD(rmd.status, RMDS, OWN)) {", "                     crda = nrda;", "                     PCNET_RECV_STORE();", " #ifdef PCNET_DEBUG_RMD", "                     PRINT_RMD(&rmd);", " #endif", "                     if ((remaining > 0) && (nrda=CSR_NNRD(s))) {", "                         RMDLOAD(&rmd, PHYSADDR(s,nrda));", "                         if (GET_FIELD(rmd.status, RMDS, OWN)) {", "                             crda = nrda;", "                             PCNET_RECV_STORE();", "                         }", "                     }", "                 }", "             }", " ", " #undef PCNET_RECV_STORE", " ", "             RMDLOAD(&rmd, PHYSADDR(s,crda));", "             if (remaining == 0) {", "                 SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);", "                 SET_FIELD(&rmd.status, RMDS, ENP, 1);", "                 SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);", "                 SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);", "                 SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);", "                 if (crc_err) {", "                     SET_FIELD(&rmd.status, RMDS, CRC, 1);", "                     SET_FIELD(&rmd.status, RMDS, ERR, 1);", "                 }", "             } else {", "                 SET_FIELD(&rmd.status, RMDS, OFLO, 1);", "                 SET_FIELD(&rmd.status, RMDS, BUFF, 1);", "                 SET_FIELD(&rmd.status, RMDS, ERR, 1);", "             }", "             RMDSTORE(&rmd, PHYSADDR(s,crda));", "             s->csr[0] |= 0x0400;", " ", " #ifdef PCNET_DEBUG", "             printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",", "                 CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);", " #endif", " #ifdef PCNET_DEBUG_RMD", "             PRINT_RMD(&rmd);", " #endif", " ", "             while (pktcount--) {", "                 if (CSR_RCVRC(s) <= 1)", "                     CSR_RCVRC(s) = CSR_RCVRL(s);", "                 else", "                     CSR_RCVRC(s)--;", "             }", " ", "             pcnet_rdte_poll(s);", " ", "         }", "     }", " ", "     pcnet_poll(s);", "     pcnet_update_irq(s);", " ", "     return size_;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {", "   const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();", " #if BUILDFLAG(USE_ALLOCATOR_SHIM)", "   if (cmdline->HasSwitch(switches::kMemlog) ||", "       base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {", "     if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {", "       LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling", "                  << \" specified with --\" << switches::kMemlog", "                  << \"which are not compatible. Memlog will be disabled.\";", "       return Mode::kNone;", "     }", " ", "     std::string mode;", "     if (cmdline->HasSwitch(switches::kMemlog)) {", "       mode = cmdline->GetSwitchValueASCII(switches::kMemlog);", "     } else {", "       mode = base::GetFieldTrialParamValueByFeature(", "            kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);", "      }", "  ", "    if (mode == switches::kMemlogModeAll)", "      return Mode::kAll;", "    if (mode == switches::kMemlogModeMinimal)", "      return Mode::kMinimal;", "    if (mode == switches::kMemlogModeBrowser)", "      return Mode::kBrowser;", "    if (mode == switches::kMemlogModeGpu)", "      return Mode::kGpu;", "    if (mode == switches::kMemlogModeRendererSampling)", "      return Mode::kRendererSampling;", "    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"", "                << switches::kMemlog;", "     return ConvertStringToMode(mode);", "    }", "    return Mode::kNone;", "  #else", "   LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))", "       << \"--\" << switches::kMemlog", "       << \" specified but it will have no effect because the use_allocator_shim \"", "       << \"is not available in this build.\";", "   return Mode::kNone;", "  #endif", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ExtensionNavigationThrottle::WillStartOrRedirectRequest() {", "   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);", "   content::WebContents* web_contents = navigation_handle()->GetWebContents();", "   ExtensionRegistry* registry =", "       ExtensionRegistry::Get(web_contents->GetBrowserContext());", " ", "   const GURL& url = navigation_handle()->GetURL();", "   bool url_has_extension_scheme = url.SchemeIs(kExtensionScheme);", "   url::Origin target_origin = url::Origin::Create(url);", "   const Extension* target_extension = nullptr;", "   if (url_has_extension_scheme) {", "     target_extension =", "         registry->enabled_extensions().GetExtensionOrAppByURL(url);", "   } else if (target_origin.scheme() == kExtensionScheme) {", "     DCHECK(url.SchemeIsFileSystem() || url.SchemeIsBlob());", "     target_extension =", "         registry->enabled_extensions().GetByID(target_origin.host());", "   } else {", "     return content::NavigationThrottle::PROCEED;", "   }", " ", "   if (!target_extension) {", "     return content::NavigationThrottle::BLOCK_REQUEST;", "   }", " ", "   if (target_extension->is_hosted_app()) {", "     base::StringPiece resource_root_relative_path =", "         url.path_piece().empty() ? base::StringPiece()", "                                  : url.path_piece().substr(1);", "     if (!IconsInfo::GetIcons(target_extension)", "              .ContainsPath(resource_root_relative_path)) {", "       return content::NavigationThrottle::BLOCK_REQUEST;", "      }", "    }", "  ", "  if (navigation_handle()->IsInMainFrame()) {", "    bool current_frame_is_extension_process =", "        !!registry->enabled_extensions().GetExtensionOrAppByURL(", "            navigation_handle()->GetStartingSiteInstance()->GetSiteURL());", "    if (!url_has_extension_scheme && !current_frame_is_extension_process) {", "      if (target_origin.scheme() == kExtensionScheme &&", "          navigation_handle()->GetSuggestedFilename().has_value()) {", "        return content::NavigationThrottle::PROCEED;", "      }", "      bool has_webview_permission =", "          target_extension->permissions_data()->HasAPIPermission(", "              APIPermission::kWebView);", "      if (!has_webview_permission)", "        return content::NavigationThrottle::CANCEL;", "    ", "    ", "    ", "   bool current_frame_is_extension_process =", "       !!registry->enabled_extensions().GetExtensionOrAppByURL(", "           navigation_handle()->GetStartingSiteInstance()->GetSiteURL());", " ", "   if (!url_has_extension_scheme && !current_frame_is_extension_process) {", "      ", "      ", "     if (target_origin.scheme() == kExtensionScheme &&", "         navigation_handle()->GetSuggestedFilename().has_value()) {", "       return content::NavigationThrottle::PROCEED;", "      }", "  ", "      ", "      ", "     bool has_webview_permission =", "         target_extension->permissions_data()->HasAPIPermission(", "             APIPermission::kWebView);", "     if (!has_webview_permission)", "       return content::NavigationThrottle::CANCEL;", "   }", " ", "   if (navigation_handle()->IsInMainFrame()) {", "      guest_view::GuestViewBase* guest =", "          guest_view::GuestViewBase::FromWebContents(web_contents);", "      if (url_has_extension_scheme && guest) {", "       const std::string& owner_extension_id = guest->owner_host();", "       const Extension* owner_extension =", "           registry->enabled_extensions().GetByID(owner_extension_id);", " ", "       std::string partition_domain;", "       std::string partition_id;", "       bool in_memory = false;", "       bool is_guest = WebViewGuest::GetGuestPartitionConfigForSite(", "           navigation_handle()->GetStartingSiteInstance()->GetSiteURL(),", "           &partition_domain, &partition_id, &in_memory);", " ", "       bool allowed = true;", "       url_request_util::AllowCrossRendererResourceLoadHelper(", "           is_guest, target_extension, owner_extension, partition_id, url.path(),", "           navigation_handle()->GetPageTransition(), &allowed);", "       if (!allowed)", "         return content::NavigationThrottle::BLOCK_REQUEST;", "     }", " ", "     return content::NavigationThrottle::PROCEED;", "   }", " ", "   content::RenderFrameHost* parent = navigation_handle()->GetParentFrame();", " ", "   bool external_ancestor = false;", "   for (auto* ancestor = parent; ancestor; ancestor = ancestor->GetParent()) {", "     if (ancestor->GetLastCommittedOrigin() == target_origin)", "       continue;", "     if (url::Origin::Create(ancestor->GetLastCommittedURL()) == target_origin)", "       continue;", "     if (ancestor->GetLastCommittedURL().SchemeIs(", "             content::kChromeDevToolsScheme))", "       continue;", " ", "     external_ancestor = true;", "     break;", "   }", " ", "   if (external_ancestor) {", "     if (!url_has_extension_scheme)", "       return content::NavigationThrottle::CANCEL;", " ", "     if (!WebAccessibleResourcesInfo::IsResourceWebAccessible(target_extension,", "                                                              url.path()))", "       return content::NavigationThrottle::BLOCK_REQUEST;", " ", "     if (target_extension->is_platform_app())", "       return content::NavigationThrottle::CANCEL;", " ", "     const Extension* parent_extension =", "         registry->enabled_extensions().GetExtensionOrAppByURL(", "             parent->GetSiteInstance()->GetSiteURL());", "     if (parent_extension && parent_extension->is_platform_app())", "       return content::NavigationThrottle::BLOCK_REQUEST;", "   }", " ", "   return content::NavigationThrottle::PROCEED;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void AutomationProvider::SendFindRequest(", "     TabContents* tab_contents,", "     bool with_json,", "     const string16& search_string,", "     bool forward,", "     bool match_case,", "     bool find_next,", "     IPC::Message* reply_message) {", "   int request_id = FindInPageNotificationObserver::kFindInPageRequestId;", "   FindInPageNotificationObserver* observer =", "       new FindInPageNotificationObserver(this,", "                                          tab_contents,", "                                          with_json,", "                                          reply_message);", "   if (!with_json) {", "     find_in_page_observer_.reset(observer);", "   }", "    TabContentsWrapper* wrapper =", "        TabContentsWrapper::GetCurrentWrapperForContents(tab_contents);", "    if (wrapper)", "    wrapper->GetFindManager()->set_current_find_request_id(request_id);", "     wrapper->find_tab_helper()->set_current_find_request_id(request_id);", "  ", "    tab_contents->render_view_host()->StartFinding(", "        FindInPageNotificationObserver::kFindInPageRequestId,", "       search_string,", "       forward,", "       match_case,", "       find_next);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHP_FUNCTION(imageaffinematrixget)", " {", " \tdouble affine[6];", " \tlong type;", " \tzval *options;", " \tzval **tmp;", " \tint res = GD_FALSE, i;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|z\", &type, &options) == FAILURE)  {", " \t\treturn;", " \t}", " ", " \tswitch((gdAffineStandardMatrix)type) {", " \t\tcase GD_AFFINE_TRANSLATE:", " \t\tcase GD_AFFINE_SCALE: {", " \t\t\tdouble x, y;", " \t\t\tif (Z_TYPE_P(options) != IS_ARRAY) {", "  \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");", "  \t\t\t}", "  \t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {", "\t\t\t\tconvert_to_double_ex(tmp);", "\t\t\t\tx = Z_DVAL_PP(tmp);", " \t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {", " \t\t\t\t\tzval dval;", " \t\t\t\t\tdval = **tmp;", " \t\t\t\t\tzval_copy_ctor(&dval);", " \t\t\t\t\tconvert_to_double(&dval);", " \t\t\t\t\tx = Z_DVAL(dval);", " \t\t\t\t} else {", " \t\t\t\t\tx = Z_DVAL_PP(tmp);", " \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");", "  \t\t\t\tRETURN_FALSE;", "  \t\t\t}", "  ", "  \t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {", "\t\t\t\tconvert_to_double_ex(tmp);", "\t\t\t\ty = Z_DVAL_PP(tmp);", " \t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {", " \t\t\t\t\tzval dval;", " \t\t\t\t\tdval = **tmp;", " \t\t\t\t\tzval_copy_ctor(&dval);", " \t\t\t\t\tconvert_to_double(&dval);", " \t\t\t\t\ty = Z_DVAL(dval);", " \t\t\t\t} else {", " \t\t\t\t\ty = Z_DVAL_PP(tmp);", " \t\t\t\t}", "  \t\t\t} else {", "  \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");", "  \t\t\t\tRETURN_FALSE;", " \t\t\t}", " \t\t\t", " \t\t\tif (type == GD_AFFINE_TRANSLATE) {", " \t\t\t\tres = gdAffineTranslate(affine, x, y);", " \t\t\t} else {", " \t\t\t\tres = gdAffineScale(affine, x, y);", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " ", " \t\tcase GD_AFFINE_ROTATE:", " \t\tcase GD_AFFINE_SHEAR_HORIZONTAL:", " \t\tcase GD_AFFINE_SHEAR_VERTICAL: {", " \t\t\tdouble angle;", " ", " \t\t\tconvert_to_double_ex(&options);", " \t\t\tangle = Z_DVAL_P(options);", " ", " \t\t\tif (type == GD_AFFINE_SHEAR_HORIZONTAL) {", " \t\t\t\tres = gdAffineShearHorizontal(affine, angle);", " \t\t\t} else if (type == GD_AFFINE_SHEAR_VERTICAL) {", " \t\t\t\tres = gdAffineShearVertical(affine, angle);", " \t\t\t} else {", " \t\t\t\tres = gdAffineRotate(affine, angle);", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " ", " \t\tdefault:", " \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %li\", type);", " \t\t\tRETURN_FALSE;", " \t}", " ", " \tif (res == GD_FALSE) {", " \t\tRETURN_FALSE;", " \t} else {", " \t\tarray_init(return_value);", " \t\tfor (i = 0; i < 6; i++) {", " \t\t\tadd_index_double(return_value, i, affine[i]);", " \t\t}", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int aa_read_header(AVFormatContext *s)", " {", "     int i, j, idx, largest_idx = -1;", "     uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;", "     char key[128], val[128], codec_name[64] = {0};", "     uint8_t output[24], dst[8], src[8];", "     int64_t largest_size = -1, current_size = -1, chapter_pos;", "     struct toc_entry {", "         uint32_t offset;", "         uint32_t size;", "     } TOC[MAX_TOC_ENTRIES];", "     uint32_t header_key_part[4];", "     uint8_t header_key[16] = {0};", "      AADemuxContext *c = s->priv_data;", "      AVIOContext *pb = s->pb;", "      AVStream *st;", "     int ret;", "  ", "       ", "      avio_skip(pb, 4);  ", "     avio_skip(pb, 4);  ", "     toc_size = avio_rb32(pb);  ", "     avio_skip(pb, 4);  ", "     if (toc_size > MAX_TOC_ENTRIES)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < toc_size; i++) {  ", "         avio_skip(pb, 4);  ", "         TOC[i].offset = avio_rb32(pb);  ", "         TOC[i].size = avio_rb32(pb);  ", "     }", "     avio_skip(pb, 24);  ", "     npairs = avio_rb32(pb);  ", "     if (npairs > MAX_DICTIONARY_ENTRIES)", "         return AVERROR_INVALIDDATA;", "     for (i = 0; i < npairs; i++) {", "         memset(val, 0, sizeof(val));", "         memset(key, 0, sizeof(key));", "         avio_skip(pb, 1);  ", "         nkey = avio_rb32(pb);  ", "         nval = avio_rb32(pb);  ", "         avio_get_str(pb, nkey, key, sizeof(key));", "         avio_get_str(pb, nval, val, sizeof(val));", "         if (!strcmp(key, \"codec\")) {", "             av_log(s, AV_LOG_DEBUG, \"Codec is <%s>\\n\", val);", "             strncpy(codec_name, val, sizeof(codec_name) - 1);", "         } else if (!strcmp(key, \"HeaderSeed\")) {", "             av_log(s, AV_LOG_DEBUG, \"HeaderSeed is <%s>\\n\", val);", "              header_seed = atoi(val);", "          } else if (!strcmp(key, \"HeaderKey\")) {  ", "              av_log(s, AV_LOG_DEBUG, \"HeaderKey is <%s>\\n\", val);", "            sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,", " ", "             ret = sscanf(val, \"%\"SCNu32\"%\"SCNu32\"%\"SCNu32\"%\"SCNu32,", "                     &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);", "             if (ret != 4)", "                 return AVERROR_INVALIDDATA;", " ", "              for (idx = 0; idx < 4; idx++) {", "                  AV_WB32(&header_key[idx * 4], header_key_part[idx]);  ", "              }", "             av_log(s, AV_LOG_DEBUG, \"Processed HeaderKey is \");", "             for (i = 0; i < 16; i++)", "                 av_log(s, AV_LOG_DEBUG, \"%02x\", header_key[i]);", "             av_log(s, AV_LOG_DEBUG, \"\\n\");", "         } else {", "             av_dict_set(&s->metadata, key, val, 0);", "         }", "     }", " ", "      ", "     if (c->aa_fixed_key_len != 16) {", "         av_log(s, AV_LOG_ERROR, \"aa_fixed_key value needs to be 16 bytes!\\n\");", "         return AVERROR(EINVAL);", "     }", " ", "      ", "     if ((c->codec_second_size = get_second_size(codec_name)) == -1) {", "         av_log(s, AV_LOG_ERROR, \"unknown codec <%s>!\\n\", codec_name);", "         return AVERROR(EINVAL);", "     }", " ", "      ", "     c->tea_ctx = av_tea_alloc();", "     if (!c->tea_ctx)", "         return AVERROR(ENOMEM);", "     av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);", "     output[0] = output[1] = 0;  ", "     memcpy(output + 2, header_key, 16);", "     idx = 0;", "     for (i = 0; i < 3; i++) {  ", "         AV_WB32(src, header_seed);", "         AV_WB32(src + 4, header_seed + 1);", "         header_seed += 2;", "         av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0);  ", "         for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {", "             output[idx] = output[idx] ^ dst[j];", "         }", "     }", "     memcpy(c->file_key, output + 2, 16);  ", "     av_log(s, AV_LOG_DEBUG, \"File key is \");", "     for (i = 0; i < 16; i++)", "         av_log(s, AV_LOG_DEBUG, \"%02x\", c->file_key[i]);", "     av_log(s, AV_LOG_DEBUG, \"\\n\");", " ", "      ", "     st = avformat_new_stream(s, NULL);", "     if (!st) {", "         av_freep(&c->tea_ctx);", "         return AVERROR(ENOMEM);", "     }", "     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;", "     if (!strcmp(codec_name, \"mp332\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_MP3;", "         st->codecpar->sample_rate = 22050;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);", "     } else if (!strcmp(codec_name, \"acelp85\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_SIPR;", "         st->codecpar->block_align = 19;", "         st->codecpar->channels = 1;", "         st->codecpar->sample_rate = 8500;", "         st->codecpar->bit_rate = 8500;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);", "     } else if (!strcmp(codec_name, \"acelp16\")) {", "         st->codecpar->codec_id = AV_CODEC_ID_SIPR;", "         st->codecpar->block_align = 20;", "         st->codecpar->channels = 1;", "         st->codecpar->sample_rate = 16000;", "         st->codecpar->bit_rate = 16000;", "         st->need_parsing = AVSTREAM_PARSE_FULL_RAW;", "         avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);", "     }", " ", "      ", "     for (i = 1; i < toc_size; i++) {  ", "         current_size = TOC[i].size;", "         if (current_size > largest_size) {", "             largest_idx = i;", "             largest_size = current_size;", "         }", "     }", "     start = TOC[largest_idx].offset;", "     avio_seek(pb, start, SEEK_SET);", " ", "     st->start_time = 0;", "     c->content_start = start;", "     c->content_end = start + largest_size;", " ", "     while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {", "         int chapter_idx = s->nb_chapters;", "         uint32_t chapter_size = avio_rb32(pb);", "         if (chapter_size == 0) break;", "         chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;", "         avio_skip(pb, 4 + chapter_size);", "         if (!avpriv_new_chapter(s, chapter_idx, st->time_base,", "             chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))", "                 return AVERROR(ENOMEM);", "     }", " ", "     st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;", " ", "     ff_update_cur_dts(s, st, 0);", "     avio_seek(pb, start, SEEK_SET);", "     c->current_chapter_size = 0;", "     c->seek_offset = 0;", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ThreadableBlobRegistry::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)", " void BlobRegistry::addDataToStream(const KURL& url, PassRefPtr<RawData> streamData)", "  {", "      if (isMainThread()) {", "        blobRegistry().addDataToStream(url, streamData);", "         if (WebBlobRegistry* registry = blobRegistry()) {", "             WebThreadSafeData webThreadSafeData(streamData);", "             registry->addDataToStream(url, webThreadSafeData);", "         }", "      } else {", "          OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, streamData));", "          callOnMainThread(&addDataToStreamTask, context.leakPtr());", "     }", " }"], "ner_tags": [0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["int __close_fd_get_file(unsigned int fd, struct file **res)", "{", "struct files_struct *files = current->files;", "struct file *file;", "struct fdtable *fdt;", "", "spin_lock(&files->file_lock);", "fdt = files_fdtable(files);", "if (fd >= fdt->max_fds)", "goto out_unlock;", "file = fdt->fd[fd];", "if (!file)", "goto out_unlock;", "rcu_assign_pointer(fdt->fd[fd], NULL);", "__put_unused_fd(files, fd);", "spin_unlock(&files->file_lock);", "get_file(file);", "*res = file;", "return filp_close(file, files);", "", "out_unlock:", "spin_unlock(&files->file_lock);", "*res = NULL;", "return -ENOENT;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void nfs4_open_confirm_release(void *calldata)", " {", " \tstruct nfs4_opendata *data = calldata;", " \tstruct nfs4_state *state = NULL;", " ", " \t ", " \tif (data->cancelled == 0)", " \t\tgoto out_free;", " \t ", " \tif (!data->rpc_done)", "  \t\tgoto out_free;", "  \tstate = nfs4_opendata_to_nfs4_state(data);", "  \tif (!IS_ERR(state))", "\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);", " \t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);", "  out_free:", "  \tnfs4_opendata_put(data);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" static int fx_command(effect_handle_t  self,", "  uint32_t            cmdCode,", "  uint32_t            cmdSize,", "  void *pCmdData,", "  uint32_t *replySize,", "  void *pReplyData)", " {", "  struct effect_s *effect = (struct effect_s *)self;", " ", "  if (effect == NULL)", "  return -EINVAL;", " ", " ", "  switch (cmdCode) {", "  case EFFECT_CMD_INIT:", "  if (pReplyData == NULL || *replySize != sizeof(int))", "  return -EINVAL;", " ", "  *(int *)pReplyData = 0;", "  break;", " ", "  case EFFECT_CMD_SET_CONFIG: {", "  if (pCmdData    == NULL||", "                     cmdSize     != sizeof(effect_config_t)||", "                     pReplyData  == NULL||", "  *replySize  != sizeof(int)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_SET_CONFIG invalid args\");", "  return -EINVAL;", "  }", "  *(int *)pReplyData = session_set_config(effect->session, (effect_config_t *)pCmdData);", "  if (*(int *)pReplyData != 0)", "  break;", " ", "  if (effect->state != EFFECT_STATE_ACTIVE)", "  *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_CONFIG);", " ", "  } break;", " ", "  case EFFECT_CMD_GET_CONFIG:", "  if (pReplyData == NULL ||", "  *replySize != sizeof(effect_config_t)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_GET_CONFIG invalid args\");", "  return -EINVAL;", "  }", " ", "             session_get_config(effect->session, (effect_config_t *)pReplyData);", "  break;", " ", "  case EFFECT_CMD_RESET:", "  break;", " ", "  case EFFECT_CMD_GET_PARAM: {", " ", "              if (pCmdData == NULL ||", "                      cmdSize < (int)sizeof(effect_param_t) ||", "                      pReplyData == NULL ||", "                    *replySize < (int)sizeof(effect_param_t)) {", "                     *replySize < (int)sizeof(effect_param_t) ||", "                      ", "                     ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t)) {", "                  ALOGV(\"fx_command() EFFECT_CMD_GET_PARAM invalid args\");", "                  return -EINVAL;", "              }", "  effect_param_t *p = (effect_param_t *)pCmdData;", " ", "             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", "             p = (effect_param_t *)pReplyData;", "             p->status = -ENOSYS;", " ", "  } break;", " ", "  case EFFECT_CMD_SET_PARAM: {", "  if (pCmdData == NULL||", "                     cmdSize < (int)sizeof(effect_param_t) ||", "                     pReplyData == NULL ||", "  *replySize != sizeof(int32_t)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_SET_PARAM invalid args\");", "  return -EINVAL;", "  }", "  effect_param_t *p = (effect_param_t *) pCmdData;", " ", "  if (p->psize != sizeof(int32_t)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_SET_PARAM invalid param format\");", "  return -EINVAL;", "  }", "  *(int *)pReplyData = -ENOSYS;", "  } break;", " ", "  case EFFECT_CMD_ENABLE:", "  if (pReplyData == NULL || *replySize != sizeof(int)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_ENABLE invalid args\");", "  return -EINVAL;", "  }", "  *(int *)pReplyData = effect_set_state(effect, EFFECT_STATE_ACTIVE);", "  break;", " ", "  case EFFECT_CMD_DISABLE:", "  if (pReplyData == NULL || *replySize != sizeof(int)) {", "                 ALOGV(\"fx_command() EFFECT_CMD_DISABLE invalid args\");", "  return -EINVAL;", "  }", "  *(int *)pReplyData  = effect_set_state(effect, EFFECT_STATE_CONFIG);", "  break;", " ", "  case EFFECT_CMD_SET_DEVICE:", "  case EFFECT_CMD_SET_INPUT_DEVICE:", "  case EFFECT_CMD_SET_VOLUME:", "  case EFFECT_CMD_SET_AUDIO_MODE:", "  if (pCmdData == NULL ||", "                     cmdSize != sizeof(uint32_t)) {", "                 ALOGV(\"fx_command() %s invalid args\",", "                       cmdCode == EFFECT_CMD_SET_DEVICE ? \"EFFECT_CMD_SET_DEVICE\" :", "                       cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? \"EFFECT_CMD_SET_INPUT_DEVICE\" :", "                       cmdCode == EFFECT_CMD_SET_VOLUME ? \"EFFECT_CMD_SET_VOLUME\" :", "                       cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? \"EFFECT_CMD_SET_AUDIO_MODE\" :", "  \"\");", "  return -EINVAL;", "  }", "             ALOGV(\"fx_command() %s value %08x\",", "                   cmdCode == EFFECT_CMD_SET_DEVICE ? \"EFFECT_CMD_SET_DEVICE\" :", "                   cmdCode == EFFECT_CMD_SET_INPUT_DEVICE ? \"EFFECT_CMD_SET_INPUT_DEVICE\" :", "                   cmdCode == EFFECT_CMD_SET_VOLUME ? \"EFFECT_CMD_SET_VOLUME\" :", "                   cmdCode == EFFECT_CMD_SET_AUDIO_MODE ? \"EFFECT_CMD_SET_AUDIO_MODE\":", "  \"\",", "  *(int *)pCmdData);", "  break;", " ", "  default:", "  return -EINVAL;", "  }", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static char *lxclock_name(const char *p, const char *n)", " {", " \tint ret;", " \tint len;", " \tchar *dest;", "  \tchar *rundir;", "  ", "  \t ", "  ", " \t ", "\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;", " \tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;", "  \trundir = get_rundir();", "  \tif (!rundir)", "  \t\treturn NULL;", " \tlen += strlen(rundir);", " ", " \tif ((dest = malloc(len)) == NULL) {", " \t\tfree(rundir);", "  \t\treturn NULL;", "  \t}", "  ", "\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);", " \tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);", "  \tif (ret < 0 || ret >= len) {", "  \t\tfree(dest);", "  \t\tfree(rundir);", "  \t\treturn NULL;", "  \t}", "  \tret = mkdir_p(dest, 0755);", "  \tif (ret < 0) {", "\t\t ", "\t\tint l2 = 22 + strlen(n) + strlen(p);", "\t\tif (l2 > len) {", "\t\t\tchar *d;", "\t\t\td = realloc(dest, l2);", "\t\t\tif (!d) {", "\t\t\t\tfree(dest);", "\t\t\t\tfree(rundir);", "\t\t\t\treturn NULL;", "\t\t\t}", "\t\t\tlen = l2;", "\t\t\tdest = d;", "\t\t}", "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);", "\t\tif (ret < 0 || ret >= len) {", "\t\t\tfree(dest);", "\t\t\tfree(rundir);", "\t\t\treturn NULL;", "\t\t}", "\t\tret = mkdir_p(dest, 0755);", "\t\tif (ret < 0) {", "\t\t\tfree(dest);", "\t\t\tfree(rundir);", "\t\t\treturn NULL;", "\t\t}", "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);", "\t} else", "\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);", " \t\tfree(dest);", " \t\tfree(rundir);", " \t\treturn NULL;", " \t}", "  ", " \tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);", "  \tfree(rundir);", "  \tif (ret < 0 || ret >= len) {", "  \t\tfree(dest);", "  \t\treturn NULL;", " \t}", " \treturn dest;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ixheaacd_qmf_hbe_data_reinit(ia_esbr_hbe_txposer_struct *ptr_hbe_txposer,", "                                     WORD16 *p_freq_band_tab[2],", "                                     WORD16 *p_num_sfb, WORD32 upsamp_4_flag) {", "   WORD32 synth_size, sfb, patch, stop_patch;", " ", "  if (ptr_hbe_txposer != NULL) {", "     ptr_hbe_txposer->start_band = p_freq_band_tab[LOW][0];", "     ptr_hbe_txposer->end_band = p_freq_band_tab[LOW][p_num_sfb[LOW]];", " ", "     ptr_hbe_txposer->synth_size =", "  4 * ((ptr_hbe_txposer->start_band + 4) / 8 + 1);", "     ptr_hbe_txposer->k_start =", "         ixheaacd_start_subband2kL_tbl[ptr_hbe_txposer->start_band];", " ", "     ptr_hbe_txposer->upsamp_4_flag = upsamp_4_flag;", " ", "  if (upsamp_4_flag) {", "  if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 16)", "         ptr_hbe_txposer->k_start = 16 - ptr_hbe_txposer->synth_size;", "  } else if (ptr_hbe_txposer->core_frame_length == 768) {", "  if (ptr_hbe_txposer->k_start + ptr_hbe_txposer->synth_size > 24)", "         ptr_hbe_txposer->k_start = 24 - ptr_hbe_txposer->synth_size;", "  }", " ", "     memset(ptr_hbe_txposer->synth_buf, 0, 1280 * sizeof(FLOAT32));", "     synth_size = ptr_hbe_txposer->synth_size;", "     ptr_hbe_txposer->synth_buf_offset = 18 * synth_size;", "  switch (synth_size) {", "  case 4:", "         ptr_hbe_txposer->synth_cos_tab =", " ", "              (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;", "          ptr_hbe_txposer->analy_cos_sin_tab =", "              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;", "        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "          break;", "        case 8:", "          ptr_hbe_txposer->synth_cos_tab =", "              (FLOAT32 *)ixheaacd_synth_cos_table_kl_8;", "          ptr_hbe_txposer->analy_cos_sin_tab =", "              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_16;", "        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "          break;", "        case 12:", "          ptr_hbe_txposer->synth_cos_tab =", "              (FLOAT32 *)ixheaacd_synth_cos_table_kl_12;", "          ptr_hbe_txposer->analy_cos_sin_tab =", "              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_24;", "        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;", "        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;", "         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p3;", "         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p3;", "          break;", "        case 16:", "          ptr_hbe_txposer->synth_cos_tab =", "              (FLOAT32 *)ixheaacd_synth_cos_table_kl_16;", "          ptr_hbe_txposer->analy_cos_sin_tab =", "              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_32;", "        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "          break;", "        case 20:", "          ptr_hbe_txposer->synth_cos_tab =", "  (FLOAT32 *)ixheaacd_synth_cos_table_kl_20;", "         ptr_hbe_txposer->analy_cos_sin_tab =", "  (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_40;", "  break;", "  default:", "         ptr_hbe_txposer->synth_cos_tab =", " ", "              (FLOAT32 *)ixheaacd_synth_cos_table_kl_4;", "          ptr_hbe_txposer->analy_cos_sin_tab =", "              (FLOAT32 *)ixheaacd_analy_cos_sin_table_kl_8;", "        ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "        ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "         ptr_hbe_txposer->ixheaacd_real_synth_fft = &ixheaacd_real_synth_fft_p2;", "         ptr_hbe_txposer->ixheaacd_cmplx_anal_fft = &ixheaacd_cmplx_anal_fft_p2;", "      }", "  ", "      ptr_hbe_txposer->synth_wind_coeff = ixheaacd_map_prot_filter(synth_size);", " ", "     memset(ptr_hbe_txposer->analy_buf, 0, 640 * sizeof(FLOAT32));", "     synth_size = 2 * ptr_hbe_txposer->synth_size;", "     ptr_hbe_txposer->analy_wind_coeff = ixheaacd_map_prot_filter(synth_size);", " ", "     memset(ptr_hbe_txposer->x_over_qmf, 0, MAX_NUM_PATCHES * sizeof(WORD32));", "     sfb = 0;", "  if (upsamp_4_flag) {", "       stop_patch = MAX_NUM_PATCHES;", "       ptr_hbe_txposer->max_stretch = MAX_STRETCH;", "  } else {", "       stop_patch = MAX_STRETCH;", "  }", " ", "  for (patch = 1; patch <= stop_patch; patch++) {", "  while (sfb <= p_num_sfb[LOW] &&", "              p_freq_band_tab[LOW][sfb] <= patch * ptr_hbe_txposer->start_band)", "         sfb++;", "  if (sfb <= p_num_sfb[LOW]) {", "  if ((patch * ptr_hbe_txposer->start_band -", "              p_freq_band_tab[LOW][sfb - 1]) <= 3) {", "           ptr_hbe_txposer->x_over_qmf[patch - 1] =", "               p_freq_band_tab[LOW][sfb - 1];", "  } else {", "           WORD32 sfb = 0;", "  while (sfb <= p_num_sfb[HIGH] &&", "                  p_freq_band_tab[HIGH][sfb] <=", "                      patch * ptr_hbe_txposer->start_band)", "             sfb++;", "           ptr_hbe_txposer->x_over_qmf[patch - 1] =", "               p_freq_band_tab[HIGH][sfb - 1];", "  }", "  } else {", "         ptr_hbe_txposer->x_over_qmf[patch - 1] = ptr_hbe_txposer->end_band;", "         ptr_hbe_txposer->max_stretch = min(patch, MAX_STRETCH);", " ", "          break;", "        }", "      }", "  }", "  if (ptr_hbe_txposer->k_start < 0) {", "    return -1;", "     if (ptr_hbe_txposer->k_start < 0) {", "       return -1;", "     }", "    }", "    return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" void impeg2d_dec_pic_data_thread(dec_state_t *ps_dec)", " {", "     WORD32 i4_continue_decode;", " ", "     WORD32 i4_cur_row, temp;", "     UWORD32 u4_bits_read;", "     WORD32 i4_dequeue_job;", "     IMPEG2D_ERROR_CODES_T e_error;", " ", "     i4_cur_row = ps_dec->u2_mb_y + 1;", " ", "     i4_continue_decode = 1;", " ", "     i4_dequeue_job = 1;", "  do", "  {", "  if(i4_cur_row > ps_dec->u2_num_vert_mb)", "  {", "             i4_continue_decode = 0;", "  break;", "  }", " ", "  {", "  if((ps_dec->i4_num_cores> 1) && (i4_dequeue_job))", "  {", "  job_t s_job;", "                 IV_API_CALL_STATUS_T e_ret;", "                 UWORD8 *pu1_buf;", " ", "                 e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);", "  if(e_ret != IV_SUCCESS)", "  break;", " ", "  if(CMD_PROCESS == s_job.i4_cmd)", "  {", "                     pu1_buf = ps_dec->pu1_inp_bits_buf + s_job.i4_bistream_ofst;", "                     impeg2d_bit_stream_init(&(ps_dec->s_bit_stream), pu1_buf,", "  (ps_dec->u4_num_inp_bytes - s_job.i4_bistream_ofst) + 8);", "                     i4_cur_row      = s_job.i2_start_mb_y;", "                     ps_dec->i4_start_mb_y = s_job.i2_start_mb_y;", "                     ps_dec->i4_end_mb_y = s_job.i2_end_mb_y;", "                     ps_dec->u2_mb_x = 0;", "                     ps_dec->u2_mb_y = ps_dec->i4_start_mb_y;", "                     ps_dec->u2_num_mbs_left = (ps_dec->i4_end_mb_y - ps_dec->i4_start_mb_y) * ps_dec->u2_num_horiz_mb;", " ", "  }", "  else", "  {", "                     WORD32 start_row;", "                     WORD32 num_rows;", "                     start_row = s_job.i2_start_mb_y << 4;", "                     num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);", "                     num_rows -= start_row;", "                     impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,", "                                         ps_dec->ps_disp_frm_buf,", "                                         start_row, num_rows);", "  break;", " ", "  }", " ", "  }", "             e_error = impeg2d_dec_slice(ps_dec);", " ", "  if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)", "  {", "                 impeg2d_next_start_code(ps_dec);", "  }", "  }", " ", "   ", "  while(1)", "  {", "             u4_bits_read = impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,START_CODE_LEN);", " ", "              temp = u4_bits_read & 0xFF;", "              i4_continue_decode = (((u4_bits_read >> 8) == 0x01) && (temp) && (temp <= 0xAF));", "  ", "             if (1 == ps_dec->i4_num_cores && 0 == ps_dec->u2_num_mbs_left)", "             {", "                 i4_continue_decode = 0;", "                 android_errorWriteLog(0x534e4554, \"26070014\");", "             }", " ", "              if(i4_continue_decode)", "              {", "                   ", "  if((temp - 1) == i4_cur_row)", "  {", "                     i4_dequeue_job = 0;", "  break;", "  }", " ", "  if(temp < ps_dec->i4_end_mb_y)", "  {", "                     i4_cur_row = ps_dec->u2_mb_y;", "  }", "  else", "  {", "                     i4_dequeue_job = 1;", "  }", "  break;", " ", "  }", "  else", "  break;", "  }", " ", "  }while(i4_continue_decode);", "  if(ps_dec->i4_num_cores > 1)", "  {", "  while(1)", "  {", "  job_t s_job;", "             IV_API_CALL_STATUS_T e_ret;", " ", "             e_ret = impeg2_jobq_dequeue(ps_dec->pv_jobq, &s_job, sizeof(s_job), 1, 1);", "  if(e_ret != IV_SUCCESS)", "  break;", "  if(CMD_FMTCONV == s_job.i4_cmd)", "  {", "                 WORD32 start_row;", "                 WORD32 num_rows;", "                 start_row = s_job.i2_start_mb_y << 4;", "                 num_rows = MIN((s_job.i2_end_mb_y << 4), ps_dec->u2_vertical_size);", "                 num_rows -= start_row;", "                 impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,", "                                     ps_dec->ps_disp_frm_buf,", "                                     start_row, num_rows);", "  }", "  }", "  }", "  else", "  {", "  if((NULL != ps_dec->ps_disp_pic) && ((0 == ps_dec->u4_share_disp_buf) || (IV_YUV_420P != ps_dec->i4_chromaFormat)))", "             impeg2d_format_convert(ps_dec, ps_dec->ps_disp_pic,", "                             ps_dec->ps_disp_frm_buf,", "  0, ps_dec->u2_vertical_size);", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static PHP_FUNCTION(gzopen)", " {", " \tchar *filename;", " \tchar *mode;", " \tint filename_len, mode_len;", " \tint flags = REPORT_ERRORS;", "         php_stream *stream;", "         long use_include_path = 0;", "  ", "       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {", "        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ps|l\", &filename, &filename_len, &mode, &mode_len, &use_include_path) == FAILURE) {", "                 return;", "         }", "  ", " \tif (use_include_path) {", " \t\tflags |= USE_PATH;", " \t}", " ", " \tstream = php_stream_gzopen(NULL, filename, mode, flags, NULL, NULL STREAMS_CC TSRMLS_CC);", " ", " \tif (!stream) {", " \t\tRETURN_FALSE;", " \t}", " \tphp_stream_to_zval(stream, return_value);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {", " \tsize_t pos, nextpos = 0;", " \tx86newTokenType last_type;", " \tint size_token = 1;", " \tbool explicit_size = false;", " \tint reg_index = 0;", " \top->type = 0;", " \twhile (size_token) {", " \t\tpos = nextpos;", " \t\tlast_type = getToken (str, &pos, &nextpos);", " ", " \t\tif (!r_str_ncasecmp (str + pos, \"ptr\", 3)) {", " \t\t\tcontinue;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"byte\", 4)) {", " \t\t\top->type |= OT_MEMORY | OT_BYTE;", " \t\t\top->dest_size = OT_BYTE;", " \t\t\texplicit_size = true;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"word\", 4)) {", " \t\t\top->type |= OT_MEMORY | OT_WORD;", " \t\t\top->dest_size = OT_WORD;", " \t\t\texplicit_size = true;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"dword\", 5)) {", " \t\t\top->type |= OT_MEMORY | OT_DWORD;", " \t\t\top->dest_size = OT_DWORD;", " \t\t\texplicit_size = true;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"qword\", 5)) {", " \t\t\top->type |= OT_MEMORY | OT_QWORD;", " \t\t\top->dest_size = OT_QWORD;", " \t\t\texplicit_size = true;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"oword\", 5)) {", " \t\t\top->type |= OT_MEMORY | OT_OWORD;", " \t\t\top->dest_size = OT_OWORD;", " \t\t\texplicit_size = true;", " \t\t} else if (!r_str_ncasecmp (str + pos, \"tbyte\", 5)) {", " \t\t\top->type |= OT_MEMORY | OT_TBYTE;", " \t\t\top->dest_size = OT_TBYTE;", " \t\t\texplicit_size = true;", " \t\t} else {  ", " \t\t\tsize_token = 0;", " \t\t}", " \t}", " ", " \tif (str[pos] == '[') {", " \t\tif (!op->type) {", " \t\t\top->type = OT_MEMORY;", " \t\t}", " \t\top->offset = op->scale[0] = op->scale[1] = 0;", " ", " \t\tut64 temp = 1;", " \t\tRegister reg = X86R_UNDEFINED;", " \t\tbool first_reg = true;", " \t\twhile (str[pos] != ']') {", " \t\t\tif (pos > nextpos) {", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tpos = nextpos;", " \t\t\tif (!str[pos]) {", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tlast_type = getToken (str, &pos, &nextpos);", " ", "  \t\t\tif (last_type == TT_SPECIAL) {", "  \t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {", "  \t\t\t\t\tif (reg != X86R_UNDEFINED) {", "\t\t\t\t\t\top->regs[reg_index] = reg;", "\t\t\t\t\t\top->scale[reg_index] = temp;", " \t\t\t\t\t\tif (reg_index < 2) {", " \t\t\t\t\t\t\top->regs[reg_index] = reg;", " \t\t\t\t\t\t\top->scale[reg_index] = temp;", " \t\t\t\t\t\t}", "  \t\t\t\t\t\t++reg_index;", "  \t\t\t\t\t} else {", "  \t\t\t\t\t\top->offset += temp;", "\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;", " \t\t\t\t\t\tif (reg_index < 2) {", " \t\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;", " \t\t\t\t\t\t}", "  \t\t\t\t\t}", "  \t\t\t\t\ttemp = 1;", "  \t\t\t\t\treg = X86R_UNDEFINED;", "  \t\t\t\t} else if (str[pos] == '*') {", " ", " \t\t\t\t}", " \t\t\t}", " \t\t\telse if (last_type == TT_WORD) {", " \t\t\t\tut32 reg_type = 0;", " ", " \t\t\t\tif (reg != X86R_UNDEFINED) {", " \t\t\t\t\top->type = 0;\t ", " \t\t\t\t}", " ", " \t\t\t\tnextpos = pos;", " \t\t\t\treg = parseReg (a, str, &nextpos, &reg_type);", " ", " \t\t\t\tif (first_reg) {", " \t\t\t\t\top->extended = false;", " \t\t\t\t\tif (reg > 8) {", " \t\t\t\t\t\top->extended = true;", " \t\t\t\t\t\top->reg = reg - 9;", " \t\t\t\t\t}", " \t\t\t\t\tfirst_reg = false;", " \t\t\t\t} else if (reg > 8) {", " \t\t\t\t\top->reg = reg - 9;", " \t\t\t\t}", " \t\t\t\tif (reg_type & OT_REGTYPE & OT_SEGMENTREG) {", " \t\t\t\t\top->reg = reg;", " \t\t\t\t\top->type = reg_type;", " \t\t\t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);", " \t\t\t\t\treturn nextpos;", " \t\t\t\t}", " ", " \t\t\t\tif (!explicit_size) {", " \t\t\t\t\top->type |= reg_type;", " \t\t\t\t}", " \t\t\t\top->reg_size = reg_type;", " \t\t\t\top->explicit_size = explicit_size;", " ", " \t\t\t\tif (!(reg_type & OT_GPREG)) {", " \t\t\t\t\top->type = 0;\t ", " \t\t\t\t}", " \t\t\t}", " \t\t\telse {", " \t\t\t\tchar *p = strchr (str, '+');", " \t\t\t\top->offset_sign = 1;", " \t\t\t\tif (!p) {", " \t\t\t\t\tp = strchr (str, '-');", " \t\t\t\t\tif (p) {", " \t\t\t\t\t\top->offset_sign = -1;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tchar * plus = strchr (str, '+');", " \t\t\t\tchar * minus = strchr (str, '-');", " \t\t\t\tchar * closeB = strchr (str, ']');", " \t\t\t\tif (plus && minus && plus < closeB && minus < closeB) {", " \t\t\t\t\top->offset_sign = -1;", " \t\t\t\t}", " \t\t\t\tchar *tmp;", " \t\t\t\ttmp = malloc (strlen (str + pos) + 1);", " \t\t\t\tstrcpy (tmp, str + pos);", " \t\t\t\tstrtok (tmp, \"+-\");", " \t\t\t\tst64 read = getnum (a, tmp);", " \t\t\t\tfree (tmp);", " \t\t\t\ttemp *= read;", " \t\t\t}", " \t\t}", " \t} else if (last_type == TT_WORD) {    ", " \t\tnextpos = pos;", " \t\tRFlagItem *flag;", " ", " \t\tif (isrepop) {", " \t\t\top->is_good_flag = false;", " \t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);", " \t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';", " \t\t\treturn nextpos;", " \t\t}", " ", " \t\top->reg = parseReg (a, str, &nextpos, &op->type);", " ", " \t\top->extended = false;", " \t\tif (op->reg > 8) {", " \t\t\top->extended = true;", " \t\t\top->reg -= 9;", " \t\t}", " \t\tif (op->type & OT_REGTYPE & OT_SEGMENTREG) {", " \t\t\tparse_segment_offset (a, str, &nextpos, op, reg_index);", " \t\t\treturn nextpos;", " \t\t}", " \t\tif (op->reg == X86R_UNDEFINED) {", " \t\t\top->is_good_flag = false;", " \t\t\tif (a->num && a->num->value == 0) {", " \t\t\t\treturn nextpos;", " \t\t\t}", " \t\t\top->type = OT_CONSTANT;", " \t\t\tRCore *core = a->num? (RCore *)(a->num->userptr): NULL;", " \t\t\tif (core && (flag = r_flag_get (core->flags, str))) {", " \t\t\t\top->is_good_flag = true;", " \t\t\t}", " ", " \t\t\tchar *p = strchr (str, '-');", " \t\t\tif (p) {", " \t\t\t\top->sign = -1;", " \t\t\t\tstr = ++p;", " \t\t\t}", " \t\t\top->immediate = getnum (a, str);", " \t\t} else if (op->reg < X86R_UNDEFINED) {", " \t\t\tstrncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1);", " \t\t\top->rep_op[MAX_REPOP_LENGTH - 1] = '\\0';", " \t\t}", " \t} else {                              ", " \t\top->type = OT_CONSTANT;", " \t\top->sign = 1;", " \t\tchar *p = strchr (str, '-');", " \t\tif (p) {", " \t\t\top->sign = -1;", " \t\t\tstr = ++p;", " \t\t}", " \t\top->immediate = getnum (a, str);", " \t}", " ", " \treturn nextpos;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image)", " {", "   MagickBooleanType", "     status;", " ", "   MagickOffsetType", "     offset,", "     *page_table,", "     scene;", " ", "   MemoryInfo", "     *pixel_info;", " ", "   PCXInfo", "     pcx_info;", " ", "   register const IndexPacket", "     *indexes;", " ", "   register const PixelPacket", "     *p;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register unsigned char", "     *q;", " ", "   size_t", "     length;", " ", "   ssize_t", "     y;", " ", "   unsigned char", "     *pcx_colormap,", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);", "   if (status == MagickFalse)", "     return(status);", "   (void) TransformImageColorspace(image,sRGBColorspace);", "   page_table=(MagickOffsetType *) NULL;", "   if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||", "       ((GetNextImageInList(image) != (Image *) NULL) &&", "        (image_info->adjoin != MagickFalse)))", "     {", "        ", "       (void) WriteBlobLSBLong(image,0x3ADE68B1L);", "       page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,", "         sizeof(*page_table));", "       if (page_table == (MagickOffsetType *) NULL)", "         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       for (scene=0; scene < 1024; scene++)", "         (void) WriteBlobLSBLong(image,0x00000000L);", "     }", "   scene=0;", "   do", "   {", "     if (page_table != (MagickOffsetType *) NULL)", "       page_table[scene]=TellBlob(image);", "      ", "     pcx_info.identifier=0x0a;", "     pcx_info.version=5;", "     pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;", "     pcx_info.bits_per_pixel=8;", "     if ((image->storage_class == PseudoClass) &&", "         (SetImageMonochrome(image,&image->exception) != MagickFalse))", "       pcx_info.bits_per_pixel=1;", "     pcx_info.left=0;", "     pcx_info.top=0;", "     pcx_info.right=(unsigned short) (image->columns-1);", "     pcx_info.bottom=(unsigned short) (image->rows-1);", "     switch (image->units)", "     {", "       case UndefinedResolution:", "       case PixelsPerInchResolution:", "       default:", "       {", "         pcx_info.horizontal_resolution=(unsigned short) image->x_resolution;", "         pcx_info.vertical_resolution=(unsigned short) image->y_resolution;", "         break;", "       }", "       case PixelsPerCentimeterResolution:", "       {", "         pcx_info.horizontal_resolution=(unsigned short)", "           (2.54*image->x_resolution+0.5);", "         pcx_info.vertical_resolution=(unsigned short)", "           (2.54*image->y_resolution+0.5);", "         break;", "       }", "     }", "     pcx_info.reserved=0;", "     pcx_info.planes=1;", "     if ((image->storage_class == DirectClass) || (image->colors > 256))", "       {", "         pcx_info.planes=3;", "         if (image->matte != MagickFalse)", "           pcx_info.planes++;", "       }", "     pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*", "       pcx_info.bits_per_pixel+7)/8);", "     pcx_info.palette_info=1;", "     pcx_info.colormap_signature=0x0c;", "      ", "     (void) WriteBlobByte(image,pcx_info.identifier);", "     (void) WriteBlobByte(image,pcx_info.version);", "     (void) WriteBlobByte(image,pcx_info.encoding);", "     (void) WriteBlobByte(image,pcx_info.bits_per_pixel);", "     (void) WriteBlobLSBShort(image,pcx_info.left);", "     (void) WriteBlobLSBShort(image,pcx_info.top);", "     (void) WriteBlobLSBShort(image,pcx_info.right);", "     (void) WriteBlobLSBShort(image,pcx_info.bottom);", "     (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);", "     (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);", "      ", "     pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,", "       3*sizeof(*pcx_colormap));", "     if (pcx_colormap == (unsigned char *) NULL)", "       ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "     (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));", "     q=pcx_colormap;", "     if ((image->storage_class == PseudoClass) && (image->colors <= 256))", "       for (i=0; i < (ssize_t) image->colors; i++)", "       {", "         *q++=ScaleQuantumToChar(image->colormap[i].red);", "         *q++=ScaleQuantumToChar(image->colormap[i].green);", "         *q++=ScaleQuantumToChar(image->colormap[i].blue);", "       }", "     (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);", "     (void) WriteBlobByte(image,pcx_info.reserved);", "     (void) WriteBlobByte(image,pcx_info.planes);", "     (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);", "     (void) WriteBlobLSBShort(image,pcx_info.palette_info);", "     for (i=0; i < 58; i++)", "       (void) WriteBlobByte(image,'\\0');", "      length=(size_t) pcx_info.bytes_per_line;", "      pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));", "      if (pixel_info == (MemoryInfo *) NULL)", "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       {", "         pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);", "         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       }", "      pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);", "      q=pixels;", "      if ((image->storage_class == DirectClass) || (image->colors > 256))", "       {", "          ", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           q=pixels;", "           for (i=0; i < pcx_info.planes; i++)", "           {", "             p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "             if (p == (const PixelPacket *) NULL)", "               break;", "             switch ((int) i)", "             {", "               case 0:", "               {", "                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)", "                 {", "                   *q++=ScaleQuantumToChar(GetPixelRed(p));", "                   p++;", "                 }", "                 break;", "               }", "               case 1:", "               {", "                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)", "                 {", "                   *q++=ScaleQuantumToChar(GetPixelGreen(p));", "                   p++;", "                 }", "                 break;", "               }", "               case 2:", "               {", "                 for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)", "                 {", "                   *q++=ScaleQuantumToChar(GetPixelBlue(p));", "                   p++;", "                 }", "                 break;", "               }", "               case 3:", "               default:", "               {", "                 for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)", "                 {", "                   *q++=ScaleQuantumToChar((Quantum)", "                     (GetPixelAlpha(p)));", "                   p++;", "                 }", "                 break;", "               }", "             }", "           }", "           if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "       }", "     else", "       {", "         if (pcx_info.bits_per_pixel > 1)", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "             if (p == (const PixelPacket *) NULL)", "               break;", "             indexes=GetVirtualIndexQueue(image);", "             q=pixels;", "             for (x=0; x < (ssize_t) image->columns; x++)", "               *q++=(unsigned char) GetPixelIndex(indexes+x);", "             if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "                 image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         else", "           {", "             register unsigned char", "               bit,", "               byte;", " ", "              ", "             for (y=0; y < (ssize_t) image->rows; y++)", "             {", "               p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "               if (p == (const PixelPacket *) NULL)", "                 break;", "               indexes=GetVirtualIndexQueue(image);", "               bit=0;", "               byte=0;", "               q=pixels;", "               for (x=0; x < (ssize_t) image->columns; x++)", "               {", "                 byte<<=1;", "                 if (GetPixelLuma(image,p) >= (QuantumRange/2.0))", "                   byte|=0x01;", "                 bit++;", "                 if (bit == 8)", "                   {", "                     *q++=byte;", "                     bit=0;", "                     byte=0;", "                   }", "                 p++;", "               }", "               if (bit != 0)", "                 *q++=byte << (8-bit);", "               if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)", "                 break;", "               if (image->previous == (Image *) NULL)", "                 {", "                   status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)", "                     y,image->rows);", "                   if (status == MagickFalse)", "                     break;", "                 }", "             }", "           }", "         (void) WriteBlobByte(image,pcx_info.colormap_signature);", "         (void) WriteBlob(image,3*256,pcx_colormap);", "       }", "     pixel_info=RelinquishVirtualMemory(pixel_info);", "     pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);", "     if (page_table == (MagickOffsetType *) NULL)", "       break;", "     if (scene >= 1023)", "       break;", "     if (GetNextImageInList(image) == (Image *) NULL)", "       break;", "     image=SyncNextImageInList(image);", "     status=SetImageProgress(image,SaveImagesTag,scene++,", "       GetImageListLength(image));", "     if (status == MagickFalse)", "       break;", "   } while (image_info->adjoin != MagickFalse);", "   if (page_table != (MagickOffsetType *) NULL)", "     {", "        ", "       page_table[scene+1]=0;", "       offset=SeekBlob(image,0L,SEEK_SET);", "       if (offset < 0)", "         ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");", "       (void) WriteBlobLSBLong(image,0x3ADE68B1L);", "       for (i=0; i <= (ssize_t) scene; i++)", "         (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);", "       page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);", "     }", "   if (status == MagickFalse)", "     {", "       char", "         *message;", " ", "       message=GetExceptionMessage(errno);", "       (void) ThrowMagickException(&image->exception,GetMagickModule(),", "         FileOpenError,\"UnableToWriteFile\",\"`%s': %s\",image->filename,message);", "       message=DestroyString(message);", "     }", "   (void) CloseBlob(image);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" BOOL SQLWriteFileDSN(\t\t\tLPCSTR\tpszFileName,", " \t\t\t\t\t\t\t\tLPCSTR\tpszAppName,", " \t\t\t\t\t\t\t\tLPCSTR\tpszKeyName,", " \t\t\t\t\t\t\t\tLPCSTR\tpszString )", " {", " \tHINI\thIni;", " \tchar\tszFileName[ODBC_FILENAME_MAX+1];", "  ", "  \tif ( pszFileName[0] == '/' )", "  \t{", "\t\tstrncpy( szFileName, sizeof(szFileName) - 5, pszFileName );", " \t\tstrncpy( szFileName, pszFileName, sizeof(szFileName) - 5 );", "  \t}", "  \telse", "  \t{\t", " \t\tchar szPath[ODBC_FILENAME_MAX+1];", " \t\t*szPath = '\\0';", " \t\t_odbcinst_FileINI( szPath );", " \t\tsnprintf( szFileName, sizeof(szFileName) - 5, \"%s/%s\", szPath, pszFileName );", " \t}", " ", "     if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, \".dsn\" ))", "     {", "         strcat( szFileName, \".dsn\" );", "     }", " ", " #ifdef __OS2__", " \tif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS )", " #else", " \tif ( iniOpen( &hIni, szFileName, \"#;\", '[', ']', '=', TRUE ) != INI_SUCCESS )", " #endif", " \t{", "        \tinst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, \"\" );", " \t\treturn FALSE;", " \t}", " ", " \t ", " \tif ( pszString == NULL && pszKeyName == NULL )", " \t{", " \t\tif ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS )", "         {", " \t\t\tiniObjectDelete( hIni );", "         }", " \t}", " \t ", " \telse if\t( pszString == NULL )", " \t{", " \t\tif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )", "         {", " \t\t\tiniPropertyDelete( hIni );", "         }", " \t}", " \telse", " \t{", " \t\t ", " \t\tif ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS )", "         {", " \t\t\tiniObjectInsert( hIni, (char *)pszAppName );", "         }", " \t\t ", " \t\tif ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, \"\" ) == INI_SUCCESS )", " \t\t{", " \t\t\tiniObjectSeek( hIni, (char *)pszAppName );", " \t\t\tiniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString );", " \t\t}", " \t\t ", " \t\telse", " \t\t{", " \t\t\tiniObjectSeek( hIni, (char *)pszAppName );", " \t\t\tiniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString );", " \t\t}", " \t}", " ", " \tif ( iniCommit( hIni ) != INI_SUCCESS )", " \t{", " \t\tiniClose( hIni );", "         inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, \"\" );", " \t\treturn FALSE;", " \t}", " ", " \tiniClose( hIni );", " ", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)", "{", "int i;", "BYTE iBitmapFormat;", "BOOL compressed = FALSE;", "CACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));", "", "if (!cache_brush)", "goto fail;", "", "if (Stream_GetRemainingLength(s) < 6)", "goto fail;", "", "Stream_Read_UINT8(s, cache_brush->index);", "Stream_Read_UINT8(s, iBitmapFormat);", "", "if (iBitmapFormat >= ARRAYSIZE(BMF_BPP))", "goto fail;", "", "cache_brush->bpp = BMF_BPP[iBitmapFormat];", "Stream_Read_UINT8(s, cache_brush->cx);", "Stream_Read_UINT8(s, cache_brush->cy);", "Stream_Read_UINT8(s, cache_brush->style);", "Stream_Read_UINT8(s, cache_brush->length);", "", "if ((cache_brush->cx == 8) && (cache_brush->cy == 8))", "{", "if (cache_brush->bpp == 1)", "{", "if (cache_brush->length != 8)", "{", "WLog_Print(update->log, WLOG_ERROR, \"incompatible 1bpp brush of length:%\" PRIu32 \"\",", "cache_brush->length);", "goto fail;", "}", "", "", "if (Stream_GetRemainingLength(s) < 8)", "goto fail;", "", "for (i = 7; i >= 0; i--)", "{", "Stream_Read_UINT8(s, cache_brush->data[i]);", "}", "}", "else", "{", "if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))", "compressed = TRUE;", "else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))", "compressed = TRUE;", "else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))", "compressed = TRUE;", "", "if (compressed != FALSE)", "{", "", "if (!update_decompress_brush(s, cache_brush->data, sizeof(cache_brush->data),", "cache_brush->bpp))", "goto fail;", "}", "else", "{", "", "UINT32 scanline = (cache_brush->bpp / 8) * 8;", "", "if (Stream_GetRemainingLength(s) < scanline * 8)", "goto fail;", "", "for (i = 7; i >= 0; i--)", "{", "Stream_Read(s, &cache_brush->data[i * scanline], scanline);", "}", "}", "}", "}", "", "return cache_brush;", "fail:", "free_cache_brush_order(update->context, cache_brush);", "return NULL;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" RenderFrameImpl::RenderFrameImpl(const CreateParams& params)", "     : frame_(NULL),", "       is_subframe_(false),", "       is_local_root_(false),", "       render_view_(params.render_view->AsWeakPtr()),", "       routing_id_(params.routing_id),", "       is_swapped_out_(false),", "       render_frame_proxy_(NULL),", "       is_detaching_(false),", "       proxy_routing_id_(MSG_ROUTING_NONE),", " #if defined(ENABLE_PLUGINS)", "       plugin_power_saver_helper_(NULL),", " #endif", "       cookie_jar_(this),", "       selection_text_offset_(0),", "       selection_range_(gfx::Range::InvalidRange()),", "       handling_select_range_(false),", "       notification_permission_dispatcher_(NULL),", "       web_user_media_client_(NULL),", "       media_permission_dispatcher_(NULL),", "       midi_dispatcher_(NULL),", " #if defined(OS_ANDROID)", "       media_player_manager_(NULL),", " #endif", " #if defined(ENABLE_BROWSER_CDMS)", "       cdm_manager_(NULL),", " #endif", " #if defined(VIDEO_HOLE)", "       contains_media_player_(false),", " #endif", "       has_played_media_(false),", "       devtools_agent_(nullptr),", "       geolocation_dispatcher_(NULL),", "       push_messaging_dispatcher_(NULL),", "       presentation_dispatcher_(NULL),", "       screen_orientation_dispatcher_(NULL),", "       manifest_manager_(NULL),", "       accessibility_mode_(AccessibilityModeOff),", "       renderer_accessibility_(NULL),", "       weak_factory_(this) {", "   std::pair<RoutingIDFrameMap::iterator, bool> result =", "       g_routing_id_frame_map.Get().insert(std::make_pair(routing_id_, this));", "   CHECK(result.second) << \"Inserting a duplicate item.\";", " ", "   RenderThread::Get()->AddRoute(routing_id_, this);", " ", "   render_view_->RegisterRenderFrame(this);", " ", " #if defined(OS_ANDROID)", "   new GinJavaBridgeDispatcher(this);", " #endif", " ", " #if defined(ENABLE_PLUGINS)", "   plugin_power_saver_helper_ = new PluginPowerSaverHelper(this);", "  #endif", "  ", "    manifest_manager_ = new ManifestManager(this);", " ", "   GetServiceRegistry()->ConnectToRemoteService(mojo::GetProxy(&mojo_shell_));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["service_info *FindServiceEventURLPath(", "service_table *table, const char *eventURLPath)", "{", "service_info *finger = NULL;", "uri_type parsed_url;", "uri_type parsed_url_in;", "", "if (table &&", "parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==", "HTTP_SUCCESS) {", "finger = table->serviceList;", "while (finger) {", "if (finger->eventURL) {", "if (parse_uri(finger->eventURL,", "strlen(finger->eventURL),", "&parsed_url) == HTTP_SUCCESS) {", "if (!token_cmp(&parsed_url.pathquery,", "&parsed_url_in.pathquery)) {", "return finger;", "}", "}", "}", "finger = finger->next;", "}", "}", "", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int exif_process_IFD_TAG(image_info_type *ImageInfo, char *dir_entry, char *offset_base, size_t IFDlength, size_t displacement, int section_index, int ReadNextIFD, tag_table_type tag_table TSRMLS_DC)", " {", " \tsize_t length;", " \tint tag, format, components;", " \tchar *value_ptr, tagname[64], cbuf[32], *outside=NULL;", " \tsize_t byte_count, offset_val, fpos, fgot;", " \tint64_t byte_count_signed;", " \txp_field_type *tmp_xp;", " #ifdef EXIF_DEBUG", " \tchar *dump_data;", " \tint dump_free;", " #endif  ", " ", " \t ", " \tif (ImageInfo->ifd_nesting_level > MAX_IFD_NESTING_LEVEL) {", " \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"corrupt EXIF header: maximum directory nesting level reached\");", " \t\treturn FALSE;", " \t}", " \tImageInfo->ifd_nesting_level++;", " ", " \ttag = php_ifd_get16u(dir_entry, ImageInfo->motorola_intel);", " \tformat = php_ifd_get16u(dir_entry+2, ImageInfo->motorola_intel);", " \tcomponents = php_ifd_get32u(dir_entry+4, ImageInfo->motorola_intel);", " ", " \tif (!format || format > NUM_FORMATS) {", " \t\t ", " \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal format code 0x%04X, suppose BYTE\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), format);", " \t\tformat = TAG_FMT_BYTE;", " \t\t ", " \t}", " ", " \tif (components < 0) {", " \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal components(%ld)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), components);", " \t\treturn FALSE;", " \t}", " ", " \tbyte_count_signed = (int64_t)components * php_tiff_bytes_per_format[format];", " ", " \tif (byte_count_signed < 0 || (byte_count_signed > INT32_MAX)) {", " \t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal byte_count\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC));", " \t\treturn FALSE;", " \t}", " ", " \tbyte_count = (size_t)byte_count_signed;", " ", " \tif (byte_count > 4) {", " \t\toffset_val = php_ifd_get32u(dir_entry+8, ImageInfo->motorola_intel);", " \t\t ", " \t\tvalue_ptr = offset_base+offset_val;", "          ", " \t\tif (byte_count > IFDlength || offset_val > IFDlength-byte_count || value_ptr < dir_entry || offset_val < (size_t)(dir_entry-offset_base)) {", " \t\t\t ", " \t\t\tif (byte_count > ImageInfo->FileSize || offset_val>ImageInfo->FileSize-byte_count || (ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_II && ImageInfo->FileType!=IMAGE_FILETYPE_TIFF_MM && ImageInfo->FileType!=IMAGE_FILETYPE_JPEG)) {", " \t\t\t\tif (value_ptr < dir_entry) {", " \t\t\t\t\t ", " \t\t\t\t\t ", " \t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X < x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, dir_entry);", " \t\t\t\t} else {", " \t\t\t\t\t ", " \t\t\t\t\t ", " \t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Process tag(x%04X=%s): Illegal pointer offset(x%04X + x%04X = x%04X > x%04X)\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val, byte_count, offset_val+byte_count, IFDlength);", " \t\t\t\t}", " \t\t\t\treturn FALSE;", " \t\t\t}", " \t\t\tif (byte_count>sizeof(cbuf)) {", " \t\t\t\t ", " \t\t\t\tvalue_ptr = safe_emalloc(byte_count, 1, 0);", " \t\t\t\toutside = value_ptr;", " \t\t\t} else {", " \t\t\t\t ", " \t\t\t\tmemset(&cbuf, 0, sizeof(cbuf));", " \t\t\t\tvalue_ptr = cbuf;", " \t\t\t}", " ", " \t\t\tfpos = php_stream_tell(ImageInfo->infile);", " \t\t\tphp_stream_seek(ImageInfo->infile, offset_val, SEEK_SET);", " \t\t\tfgot = php_stream_tell(ImageInfo->infile);", " \t\t\tif (fgot!=offset_val) {", " \t\t\t\tEFREE_IF(outside);", " \t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Wrong file pointer: 0x%08X != 0x%08X\", fgot, offset_val);", " \t\t\t\treturn FALSE;", " \t\t\t}", " \t\t\tfgot = php_stream_read(ImageInfo->infile, value_ptr, byte_count);", " \t\t\tphp_stream_seek(ImageInfo->infile, fpos, SEEK_SET);", " \t\t\tif (fgot<byte_count) {", " \t\t\t\tEFREE_IF(outside);", " \t\t\t\tEXIF_ERRLOG_FILEEOF(ImageInfo)", " \t\t\t\treturn FALSE;", " \t\t\t}", " \t\t}", " \t} else {", " \t\t ", " \t\tvalue_ptr = dir_entry+8;", " \t\toffset_val= value_ptr-offset_base;", " \t}", " ", " \tImageInfo->sections_found |= FOUND_ANY_TAG;", " #ifdef EXIF_DEBUG", " \tdump_data = exif_dump_data(&dump_free, format, components, length, ImageInfo->motorola_intel, value_ptr TSRMLS_CC);", " \texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Process tag(x%04X=%s,@x%04X + x%04X(=%d)): %s%s %s\", tag, exif_get_tagname(tag, tagname, -12, tag_table TSRMLS_CC), offset_val+displacement, byte_count, byte_count, (components>1)&&format!=TAG_FMT_UNDEFINED&&format!=TAG_FMT_STRING?\"ARRAY OF \":\"\", exif_get_tagformat(format), dump_data);", " \tif (dump_free) {", " \t\tefree(dump_data);", " \t}", " #endif", " ", " \tif (section_index==SECTION_THUMBNAIL) {", " \t\tif (!ImageInfo->Thumbnail.data) {", " \t\t\tswitch(tag) {", " \t\t\t\tcase TAG_IMAGEWIDTH:", " \t\t\t\tcase TAG_COMP_IMAGE_WIDTH:", " \t\t\t\t\tImageInfo->Thumbnail.width = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\t\tbreak;", " ", " \t\t\t\tcase TAG_IMAGEHEIGHT:", " \t\t\t\tcase TAG_COMP_IMAGE_HEIGHT:", " \t\t\t\t\tImageInfo->Thumbnail.height = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\t\tbreak;", " ", " \t\t\t\tcase TAG_STRIP_OFFSETS:", " \t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT:", " \t\t\t\t\t ", " \t\t\t\t\tImageInfo->Thumbnail.offset = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\t\tbreak;", " ", " \t\t\t\tcase TAG_STRIP_BYTE_COUNTS:", " \t\t\t\t\tif (ImageInfo->FileType == IMAGE_FILETYPE_TIFF_II || ImageInfo->FileType == IMAGE_FILETYPE_TIFF_MM) {", " \t\t\t\t\t\tImageInfo->Thumbnail.filetype = ImageInfo->FileType;", " \t\t\t\t\t} else {", " \t\t\t\t\t\t ", " \t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_TIFF_MM;", " \t\t\t\t\t}", " \t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\t\tbreak;", " ", " \t\t\t\tcase TAG_JPEG_INTERCHANGE_FORMAT_LEN:", " \t\t\t\t\tif (ImageInfo->Thumbnail.filetype == IMAGE_FILETYPE_UNKNOWN) {", " \t\t\t\t\t\tImageInfo->Thumbnail.filetype = IMAGE_FILETYPE_JPEG;", " \t\t\t\t\t\tImageInfo->Thumbnail.size = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\t\t}", " \t\t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t} else {", " \t\tif (section_index==SECTION_IFD0 || section_index==SECTION_EXIF)", " \t\tswitch(tag) {", " \t\t\tcase TAG_COPYRIGHT:", " \t\t\t\t ", " \t\t\t\tif (byte_count>1 && (length=php_strnlen(value_ptr, byte_count)) > 0) {", " \t\t\t\t\tif (length<byte_count-1) {", "                                                  ", "                                                 ImageInfo->CopyrightPhotographer  = estrdup(value_ptr);", "                                                 ImageInfo->CopyrightEditor        = estrndup(value_ptr+length+1, byte_count-length-1);", "                                               spprintf(&ImageInfo->Copyright, 0, \"%s, %s\", value_ptr, value_ptr+length+1);", "                                                spprintf(&ImageInfo->Copyright, 0, \"%s, %s\", ImageInfo->CopyrightPhotographer, ImageInfo->CopyrightEditor);", "                                                  ", "                                                  ", "                                                  ", " \t\t\t\t\t} else {", " \t\t\t\t\t\tImageInfo->Copyright = estrndup(value_ptr, byte_count);", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_USERCOMMENT:", " \t\t\t\tImageInfo->UserCommentLength = exif_process_user_comment(ImageInfo, &(ImageInfo->UserComment), &(ImageInfo->UserCommentEncoding), value_ptr, byte_count TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_XP_TITLE:", " \t\t\tcase TAG_XP_COMMENTS:", " \t\t\tcase TAG_XP_AUTHOR:", " \t\t\tcase TAG_XP_KEYWORDS:", " \t\t\tcase TAG_XP_SUBJECT:", " \t\t\t\ttmp_xp = (xp_field_type*)safe_erealloc(ImageInfo->xp_fields.list, (ImageInfo->xp_fields.count+1), sizeof(xp_field_type), 0);", " \t\t\t\tImageInfo->sections_found |= FOUND_WINXP;", " \t\t\t\tImageInfo->xp_fields.list = tmp_xp;", " \t\t\t\tImageInfo->xp_fields.count++;", " \t\t\t\texif_process_unicode(ImageInfo, &(ImageInfo->xp_fields.list[ImageInfo->xp_fields.count-1]), tag, value_ptr, byte_count TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_FNUMBER:", " \t\t\t\t ", " \t\t\t\tImageInfo->ApertureFNumber = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_APERTURE:", " \t\t\tcase TAG_MAX_APERTURE:", " \t\t\t\t ", " \t\t\t\tif (ImageInfo->ApertureFNumber == 0) {", " \t\t\t\t\tImageInfo->ApertureFNumber", " \t\t\t\t\t\t= (float)exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)*0.5);", " \t\t\t\t}", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_SHUTTERSPEED:", " \t\t\t\t ", " \t\t\t\tif (ImageInfo->ExposureTime == 0) {", " \t\t\t\t\tImageInfo->ExposureTime", " \t\t\t\t\t\t= (float)(1/exp(exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)*log(2)));", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase TAG_EXPOSURETIME:", " \t\t\t\tImageInfo->ExposureTime = -1;", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_COMP_IMAGE_WIDTH:", " \t\t\t\tImageInfo->ExifImageWidth = exif_convert_any_to_int(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_FOCALPLANE_X_RES:", " \t\t\t\tImageInfo->FocalplaneXRes = exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_SUBJECT_DISTANCE:", " \t\t\t\t ", " \t\t\t\tImageInfo->Distance = (float)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_FOCALPLANE_RESOLUTION_UNIT:", " \t\t\t\tswitch((int)exif_convert_any_format(value_ptr, format, ImageInfo->motorola_intel TSRMLS_CC)) {", " \t\t\t\t\tcase 1: ImageInfo->FocalplaneUnits = 25.4; break;  ", " \t\t\t\t\tcase 2:", " \t\t\t\t\t\t ", " \t\t\t\t\t\tImageInfo->FocalplaneUnits = 25.4;", " \t\t\t\t\t\tbreak;", " ", " \t\t\t\t\tcase 3: ImageInfo->FocalplaneUnits = 10;   break;   ", " \t\t\t\t\tcase 4: ImageInfo->FocalplaneUnits = 1;    break;   ", " \t\t\t\t\tcase 5: ImageInfo->FocalplaneUnits = .001; break;   ", " \t\t\t\t}", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_SUB_IFD:", " \t\t\t\tif (format==TAG_FMT_IFD) {", " \t\t\t\t\t ", " \t\t\t\t\t ", " \t\t\t\t\t ", " \t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Skip SUB IFD\");", " \t\t\t\t}", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_MAKE:", " \t\t\t\tImageInfo->make = estrndup(value_ptr, byte_count);", " \t\t\t\tbreak;", " \t\t\tcase TAG_MODEL:", " \t\t\t\tImageInfo->model = estrndup(value_ptr, byte_count);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_MAKER_NOTE:", " \t\t\t\texif_process_IFD_in_MAKERNOTE(ImageInfo, value_ptr, byte_count, offset_base, IFDlength, displacement TSRMLS_CC);", " \t\t\t\tbreak;", " ", " \t\t\tcase TAG_EXIF_IFD_POINTER:", " \t\t\tcase TAG_GPS_IFD_POINTER:", " \t\t\tcase TAG_INTEROP_IFD_POINTER:", " \t\t\t\tif (ReadNextIFD) {", " \t\t\t\t\tchar *Subdir_start;", " \t\t\t\t\tint sub_section_index = 0;", " \t\t\t\t\tswitch(tag) {", " \t\t\t\t\t\tcase TAG_EXIF_IFD_POINTER:", " #ifdef EXIF_DEBUG", " \t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found EXIF\");", " #endif", " \t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_EXIF;", " \t\t\t\t\t\t\tsub_section_index = SECTION_EXIF;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\tcase TAG_GPS_IFD_POINTER:", " #ifdef EXIF_DEBUG", " \t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found GPS\");", " #endif", " \t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_GPS;", " \t\t\t\t\t\t\tsub_section_index = SECTION_GPS;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t\tcase TAG_INTEROP_IFD_POINTER:", " #ifdef EXIF_DEBUG", " \t\t\t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Found INTEROPERABILITY\");", " #endif", " \t\t\t\t\t\t\tImageInfo->sections_found |= FOUND_INTEROP;", " \t\t\t\t\t\t\tsub_section_index = SECTION_INTEROP;", " \t\t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tSubdir_start = offset_base + php_ifd_get32u(value_ptr, ImageInfo->motorola_intel);", " \t\t\t\t\tif (Subdir_start < offset_base || Subdir_start > offset_base+IFDlength) {", " \t\t\t\t\t\texif_error_docref(\"exif_read_data#error_ifd\" EXIFERR_CC, ImageInfo, E_WARNING, \"Illegal IFD Pointer\");", " \t\t\t\t\t\treturn FALSE;", " \t\t\t\t\t}", " \t\t\t\t\tif (!exif_process_IFD_in_JPEG(ImageInfo, Subdir_start, offset_base, IFDlength, displacement, sub_section_index TSRMLS_CC)) {", " \t\t\t\t\t\treturn FALSE;", " \t\t\t\t\t}", " #ifdef EXIF_DEBUG", " \t\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, \"Subsection %s done\", exif_get_sectionname(sub_section_index));", " #endif", " \t\t\t\t}", " \t\t}", " \t}", " \texif_iif_add_tag(ImageInfo, section_index, exif_get_tagname(tag, tagname, sizeof(tagname), tag_table TSRMLS_CC), tag, format, components, value_ptr TSRMLS_CC);", " \tEFREE_IF(outside);", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,", " \t\t\t    struct flowi *fl, struct sock *sk)", " {", " \tstruct sctp_association *asoc = t->asoc;", "  \tstruct dst_entry *dst = NULL;", "  \tstruct flowi6 *fl6 = &fl->u.ip6;", "  \tstruct sctp_bind_addr *bp;", " \tstruct ipv6_pinfo *np = inet6_sk(sk);", "  \tstruct sctp_sockaddr_entry *laddr;", "  \tunion sctp_addr *baddr = NULL;", "  \tunion sctp_addr *daddr = &t->ipaddr;", "  \tunion sctp_addr dst_saddr;", " \tstruct in6_addr *final_p, final;", "  \t__u8 matchlen = 0;", "  \t__u8 bmatchlen;", "  \tsctp_scope_t scope;", " ", " \tmemset(fl6, 0, sizeof(struct flowi6));", " \tfl6->daddr = daddr->v6.sin6_addr;", " \tfl6->fl6_dport = daddr->v6.sin6_port;", " \tfl6->flowi6_proto = IPPROTO_SCTP;", " \tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)", " \t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;", " ", " \tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);", " ", " \tif (asoc)", " \t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);", " ", " \tif (saddr) {", " \t\tfl6->saddr = saddr->v6.sin6_addr;", " \t\tfl6->fl6_sport = saddr->v6.sin6_port;", " ", "  \t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);", "  \t}", "  ", "\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);", " \tfinal_p = fl6_update_dst(fl6, np->opt, &final);", " \tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);", "  \tif (!asoc || saddr)", "  \t\tgoto out;", "  ", " \tbp = &asoc->base.bind_addr;", " \tscope = sctp_scope(daddr);", " \t ", " \tif (!IS_ERR(dst)) {", " \t\t ", " \t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));", " \t\trcu_read_lock();", " \t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {", " \t\t\tif (!laddr->valid || (laddr->state != SCTP_ADDR_SRC))", " \t\t\t\tcontinue;", " ", " \t\t\t ", " \t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&", " \t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {", " \t\t\t\trcu_read_unlock();", " \t\t\t\tgoto out;", " \t\t\t}", " \t\t}", " \t\trcu_read_unlock();", " \t\t ", " \t\tdst_release(dst);", " \t\tdst = NULL;", " \t}", " ", " \t ", " \trcu_read_lock();", " \tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {", " \t\tif (!laddr->valid)", " \t\t\tcontinue;", " \t\tif ((laddr->state == SCTP_ADDR_SRC) &&", " \t\t    (laddr->a.sa.sa_family == AF_INET6) &&", " \t\t    (scope <= sctp_scope(&laddr->a))) {", " \t\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);", " \t\t\tif (!baddr || (matchlen < bmatchlen)) {", " \t\t\t\tbaddr = &laddr->a;", " \t\t\t\tmatchlen = bmatchlen;", " \t\t\t}", "  \t\t}", "  \t}", "  \trcu_read_unlock();", " ", "  \tif (baddr) {", "  \t\tfl6->saddr = baddr->v6.sin6_addr;", "  \t\tfl6->fl6_sport = baddr->v6.sin6_port;", "\t\tdst = ip6_dst_lookup_flow(sk, fl6, NULL, false);", " \t\tfinal_p = fl6_update_dst(fl6, np->opt, &final);", " \t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p, false);", "  \t}", "  ", "  out:", " \tif (!IS_ERR_OR_NULL(dst)) {", " \t\tstruct rt6_info *rt;", " ", " \t\trt = (struct rt6_info *)dst;", " \t\tt->dst = dst;", " \t\tt->dst_cookie = rt->rt6i_node ? rt->rt6i_node->fn_sernum : 0;", " \t\tpr_debug(\"rt6_dst:%pI6 rt6_src:%pI6\\n\", &rt->rt6i_dst.addr,", " \t\t\t &fl6->saddr);", " \t} else {", " \t\tt->dst = NULL;", " ", " \t\tpr_debug(\"no route\\n\");", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,", "int uncompressed_size, EXRThreadData *td)", "{", "int64_t version, lo_usize, lo_size;", "int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;", "int64_t ac_count, dc_count, ac_compression;", "const int dc_w = td->xsize >> 3;", "const int dc_h = td->ysize >> 3;", "GetByteContext gb, agb;", "int skip, ret;", "", "if (compressed_size <= 88)", "return AVERROR_INVALIDDATA;", "", "version = AV_RL64(src + 0);", "if (version != 2)", "return AVERROR_INVALIDDATA;", "", "lo_usize = AV_RL64(src + 8);", "lo_size = AV_RL64(src + 16);", "ac_size = AV_RL64(src + 24);", "dc_size = AV_RL64(src + 32);", "rle_csize = AV_RL64(src + 40);", "rle_usize = AV_RL64(src + 48);", "rle_raw_size = AV_RL64(src + 56);", "ac_count = AV_RL64(src + 64);", "dc_count = AV_RL64(src + 72);", "ac_compression = AV_RL64(src + 80);", "", "if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)", "return AVERROR_INVALIDDATA;", "", "bytestream2_init(&gb, src + 88, compressed_size - 88);", "skip = bytestream2_get_le16(&gb);", "if (skip < 2)", "return AVERROR_INVALIDDATA;", "", "bytestream2_skip(&gb, skip - 2);", "", "if (lo_size > 0) {", "if (lo_usize > uncompressed_size)", "return AVERROR_INVALIDDATA;", "bytestream2_skip(&gb, lo_size);", "}", "", "if (ac_size > 0) {", "unsigned long dest_len = ac_count * 2LL;", "GetByteContext agb = gb;", "", "if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)", "return AVERROR_INVALIDDATA;", "", "av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);", "if (!td->ac_data)", "return AVERROR(ENOMEM);", "", "switch (ac_compression) {", "case 0:", "ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);", "if (ret < 0)", "return ret;", "break;", "case 1:", "if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||", "dest_len != ac_count * 2LL)", "return AVERROR_INVALIDDATA;", "break;", "default:", "return AVERROR_INVALIDDATA;", "}", "", "bytestream2_skip(&gb, ac_size);", "}", "", "if (dc_size > 0) {", "unsigned long dest_len = dc_count * 2LL;", "GetByteContext agb = gb;", "", "if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)", "return AVERROR_INVALIDDATA;", "", "av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);", "if (!td->dc_data)", "return AVERROR(ENOMEM);", "", "if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||", "(dest_len != dc_count * 2LL))", "return AVERROR_INVALIDDATA;", "", "s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);", "s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);", "", "bytestream2_skip(&gb, dc_size);", "}", "", "if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {", "unsigned long dest_len = rle_usize;", "", "av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);", "if (!td->rle_data)", "return AVERROR(ENOMEM);", "", "av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);", "if (!td->rle_raw_data)", "return AVERROR(ENOMEM);", "", "if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||", "(dest_len != rle_usize))", "return AVERROR_INVALIDDATA;", "", "ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);", "if (ret < 0)", "return ret;", "bytestream2_skip(&gb, rle_csize);", "}", "", "bytestream2_init(&agb, td->ac_data, ac_count * 2);", "", "for (int y = 0; y < td->ysize; y += 8) {", "for (int x = 0; x < td->xsize; x += 8) {", "memset(td->block, 0, sizeof(td->block));", "", "for (int j = 0; j < 3; j++) {", "float *block = td->block[j];", "const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;", "uint16_t *dc = (uint16_t *)td->dc_data;", "union av_intfloat32 dc_val;", "", "dc_val.i = half2float(dc[idx], s->mantissatable,", "s->exponenttable, s->offsettable);", "", "block[0] = dc_val.f;", "ac_uncompress(s, &agb, block);", "dct_inverse(block);", "}", "", "{", "const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;", "const int o = s->nb_channels == 4;", "float *bo = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;", "float *go = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;", "float *ro = ((float *)td->uncompressed_data) +", "y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;", "float *yb = td->block[0];", "float *ub = td->block[1];", "float *vb = td->block[2];", "", "for (int yy = 0; yy < 8; yy++) {", "for (int xx = 0; xx < 8; xx++) {", "const int idx = xx + yy * 8;", "", "convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);", "", "bo[xx] = to_linear(bo[xx], scale);", "go[xx] = to_linear(go[xx], scale);", "ro[xx] = to_linear(ro[xx], scale);", "}", "", "bo += td->xsize * s->nb_channels;", "go += td->xsize * s->nb_channels;", "ro += td->xsize * s->nb_channels;", "}", "}", "}", "}", "", "if (s->nb_channels < 4)", "return 0;", "", "for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {", "uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;", "uint8_t *ai0 = td->rle_raw_data + y * td->xsize;", "uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;", "", "for (int x = 0; x < td->xsize; x++) {", "uint16_t ha = ai0[x] | (ai1[x] << 8);", "", "ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable);", "}", "}", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void load_xref_from_plaintext(FILE *fp, xref_t *xref)", " {", "     int  i, buf_idx, obj_id, added_entries;", "     char c, buf[32] = {0};", "     long start, pos;", " ", "     start = ftell(fp);", " ", "      ", "     pos = xref->end;", "     fseek(fp, pos, SEEK_SET);", "     while (ftell(fp) != 0)", "       if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))", "         break;", "       else", "         SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");", "  ", "      SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");", "      xref->n_entries = atoi(buf + strlen(\"ize \"));", "    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));", "     xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));", "  ", "       ", "      obj_id = 0;", "     fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);", "     added_entries = 0;", "     for (i=0; i<xref->n_entries; i++)", "     {", "          ", "         c = fgetc(fp);", "         while (c == '\\n' || c == '\\r')", "           c = fgetc(fp);", " ", "          ", "         buf_idx = 0;", "         while (c != '\\n' && c != '\\r' && !feof(fp) &&", "                !ferror(fp) && buf_idx < sizeof(buf))", "         {", "             buf[buf_idx++] = c;", "             c = fgetc(fp);", "         }", "         if (buf_idx >= sizeof(buf))", "         {", "             ERR(\"Failed to locate newline character. \"", "                 \"This might be a corrupt PDF.\\n\");", "             exit(EXIT_FAILURE);", "         }", "         buf[buf_idx] = '\\0';", " ", "          ", "         if (strchr(buf, 't'))", "           break;", " ", "          ", "         if (strlen(buf) > 17)", "         {", "             xref->entries[i].obj_id = obj_id++;", "             xref->entries[i].offset = atol(strtok(buf, \" \"));", "             xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));", "             xref->entries[i].f_or_n = buf[17];", "             ++added_entries;", "         }", "         else", "         {", "             obj_id = atoi(buf);", "             --i;", "         }", "     }", " ", "     xref->n_entries = added_entries;", "     fseek(fp, start, SEEK_SET);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" hcom_client_init", " (", " \t\tOUT\tp_hsm_com_client_hdl_t\t*p_hdl,", " \tIN\t\tchar\t\t\t\t\t*server_path,", " \tIN\t\tchar\t\t\t\t\t*client_path,", " \tIN\t\tint\t\t\t\t\t\tmax_data_len", " )", " {", " \thsm_com_client_hdl_t\t*hdl = NULL;", " \thsm_com_errno_t\t\t\tres = HSM_COM_OK;", " \t", " ", " \tif((strlen(server_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||", " \t   (strlen(server_path) == 0)){", " \t\tres = HSM_COM_PATH_ERR;", " \t\tgoto cleanup;", " \t}", " ", " \tif((strlen(client_path) > (HSM_COM_SVR_MAX_PATH - 1)) ||", " \t   (strlen(client_path) == 0)){", " \t\tres = HSM_COM_PATH_ERR;", " \t\tgoto cleanup;", " \t}", " ", " ", " \tif((hdl = calloc(1,sizeof(hsm_com_client_hdl_t))) == NULL)", " \t{", " \t\tres = HSM_COM_NO_MEM;", " \t\tgoto cleanup;", " \t}", " ", " \tif((hdl->scr.scratch = malloc(max_data_len)) == NULL) ", " \t{", " \t\tres = HSM_COM_NO_MEM;", " \t\tgoto cleanup;", " \t}", " ", " \tif((hdl->recv_buf = malloc(max_data_len)) == NULL) ", " \t{", " \t\tres = HSM_COM_NO_MEM;", " \t\tgoto cleanup;", " \t}", " ", " \tif((hdl->send_buf = malloc(max_data_len)) == NULL) ", " \t{", " \t\tres = HSM_COM_NO_MEM;", " \t\tgoto cleanup;", " \t}", " ", " \thdl->scr.scratch_fill = 0;", " \thdl->scr.scratch_len = max_data_len;", " \thdl->buf_len = max_data_len;", " \thdl->trans_id = 1;", " ", " ", "  \tstrcpy(hdl->s_path,server_path);", "  \tstrcpy(hdl->c_path,client_path);", "  ", " \tif (mkstemp(hdl->c_path) == -1)", " \t{", " \t\tres = HSM_COM_PATH_ERR;", " \t\tgoto cleanup;", " \t}", "  ", "  \thdl->client_state = HSM_COM_C_STATE_IN;", "  ", " \t*p_hdl = hdl;", " ", " \treturn res;", " ", " cleanup:", " \tif(hdl)", " \t{", " \t\tif (hdl->scr.scratch) {", " \t\t\tfree(hdl->scr.scratch);", " \t\t}", " \t\tif (hdl->recv_buf) {", " \t\t\tfree(hdl->recv_buf);", " \t\t}", " \t\tfree(hdl);", " \t}", " ", " \treturn res;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)", "      : ObjectBackedNativeHandler(context) {", "    RouteFunction(", "      \"GetNotificationImageSizes\",", "       \"GetNotificationImageSizes\", \"notifications\",", "        base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,", "                   base::Unretained(this)));", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["  int insn_get_code_seg_params(struct pt_regs *regs)", "  {", "\tstruct desc_struct *desc;", " \tstruct desc_struct desc;", "  \tshort sel;", "  ", "  \tif (v8086_mode(regs))", " \t\t ", " \t\treturn INSN_CODE_SEG_PARAMS(2, 2);", " ", " \tsel = get_segment_selector(regs, INAT_SEG_REG_CS);", "  \tif (sel < 0)", "  \t\treturn sel;", "  ", "\tdesc = get_desc(sel);", "\tif (!desc)", " \tif (!get_desc(&desc, sel))", "  \t\treturn -EINVAL;", "  ", "  \t ", "\tif (!(desc->type & BIT(3)))", " \tif (!(desc.type & BIT(3)))", "  \t\treturn -EINVAL;", "  ", "\tswitch ((desc->l << 1) | desc->d) {", " \tswitch ((desc.l << 1) | desc.d) {", "  \tcase 0:  ", " \t\treturn INSN_CODE_SEG_PARAMS(2, 2);", " \tcase 1:  ", " \t\treturn INSN_CODE_SEG_PARAMS(4, 4);", " \tcase 2:  ", " \t\treturn INSN_CODE_SEG_PARAMS(4, 8);", " \tcase 3:  ", " \t\t ", " \tdefault:", " \t\treturn -EINVAL;", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int sc_asn1_read_tag(const u8 ** buf, size_t buflen, unsigned int *cla_out,", " \t\t     unsigned int *tag_out, size_t *taglen)", " {", " \tconst u8 *p = *buf;", " \tsize_t left = buflen, len;", " \tunsigned int cla, tag, i;", " ", " \tif (left < 2)", " \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \t*buf = NULL;", " \tif (*p == 0xff || *p == 0) {", " \t\t ", " \t\t*taglen = 0;", " \t\t*tag_out = SC_ASN1_TAG_EOC;", " \t\treturn SC_SUCCESS;", " \t}", " \t ", " \tcla = (*p & SC_ASN1_TAG_CLASS) | (*p & SC_ASN1_TAG_CONSTRUCTED);", " \ttag = *p & SC_ASN1_TAG_PRIMITIVE;", " \tp++;", " \tleft--;", " \tif (tag == SC_ASN1_TAG_PRIMITIVE) {", " \t\t ", " \t\tsize_t n = SC_ASN1_TAGNUM_SIZE - 1;", " \t\t ", " \t\twhile (left-- != 0 && n != 0) {", " \t\t\ttag <<= 8;", " \t\t\ttag |= *p;", " \t\t\tif ((*p++ & 0x80) == 0)", " \t\t\t\tbreak;", " \t\t\tn--;", " \t\t}", " \t\tif (left == 0 || n == 0)", " \t\t\t ", " \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", " \t}", " ", " \t ", "  \tlen = *p & 0x7f;", "  \tif (*p++ & 0x80) {", "  \t\tunsigned int a = 0;", " \t\tleft--;", "  \t\tif (len > 4 || len > left)", "  \t\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;", "  \t\tleft -= len;", " \t\tfor (i = 0; i < len; i++) {", " \t\t\ta <<= 8;", " \t\t\ta |= *p;", " \t\t\tp++;", " \t\t}", " \t\tlen = a;", " \t}", " ", " \t*cla_out = cla;", " \t*tag_out = tag;", " \t*taglen = len;", " \t*buf = p;", " ", " \tif (len > left)", " \t\treturn SC_ERROR_ASN1_END_OF_CONTENTS;", " ", " \treturn SC_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) {", "  \top->len = 1;", "  \top->op = buf[0];", "\tif (op->op > 0xbf) return 1;", " \tif (op->op > 0xbf) {", " \t\treturn 1;", " \t}", "  \tWasmOpDef *opdef = &opcodes[op->op];", "  \tswitch (op->op) {", " \tcase WASM_OP_TRAP:", " \tcase WASM_OP_NOP:", " \tcase WASM_OP_ELSE:", " \tcase WASM_OP_RETURN:", " \tcase WASM_OP_DROP:", " \tcase WASM_OP_SELECT:", " \tcase WASM_OP_I32EQZ: ", " \tcase WASM_OP_I32EQ: ", " \tcase WASM_OP_I32NE: ", " \tcase WASM_OP_I32LTS: ", " \tcase WASM_OP_I32LTU: ", " \tcase WASM_OP_I32GTS: ", " \tcase WASM_OP_I32GTU: ", " \tcase WASM_OP_I32LES: ", " \tcase WASM_OP_I32LEU: ", " \tcase WASM_OP_I32GES: ", " \tcase WASM_OP_I32GEU: ", " \tcase WASM_OP_I64EQZ: ", " \tcase WASM_OP_I64EQ: ", " \tcase WASM_OP_I64NE: ", " \tcase WASM_OP_I64LTS: ", " \tcase WASM_OP_I64LTU: ", " \tcase WASM_OP_I64GTS: ", " \tcase WASM_OP_I64GTU: ", " \tcase WASM_OP_I64LES: ", " \tcase WASM_OP_I64LEU: ", " \tcase WASM_OP_I64GES: ", " \tcase WASM_OP_I64GEU: ", " \tcase WASM_OP_F32EQ: ", " \tcase WASM_OP_F32NE: ", " \tcase WASM_OP_F32LT: ", " \tcase WASM_OP_F32GT: ", " \tcase WASM_OP_F32LE: ", " \tcase WASM_OP_F32GE: ", " \tcase WASM_OP_F64EQ: ", " \tcase WASM_OP_F64NE: ", " \tcase WASM_OP_F64LT: ", " \tcase WASM_OP_F64GT: ", " \tcase WASM_OP_F64LE: ", " \tcase WASM_OP_F64GE: ", " \tcase WASM_OP_I32CLZ: ", " \tcase WASM_OP_I32CTZ: ", " \tcase WASM_OP_I32POPCNT: ", " \tcase WASM_OP_I32ADD: ", " \tcase WASM_OP_I32SUB: ", " \tcase WASM_OP_I32MUL: ", " \tcase WASM_OP_I32DIVS: ", " \tcase WASM_OP_I32DIVU: ", " \tcase WASM_OP_I32REMS: ", " \tcase WASM_OP_I32REMU: ", " \tcase WASM_OP_I32AND: ", " \tcase WASM_OP_I32OR: ", " \tcase WASM_OP_I32XOR: ", " \tcase WASM_OP_I32SHL: ", " \tcase WASM_OP_I32SHRS: ", " \tcase WASM_OP_I32SHRU: ", " \tcase WASM_OP_I32ROTL: ", " \tcase WASM_OP_I32ROTR: ", " \tcase WASM_OP_I64CLZ: ", " \tcase WASM_OP_I64CTZ: ", " \tcase WASM_OP_I64POPCNT: ", " \tcase WASM_OP_I64ADD: ", " \tcase WASM_OP_I64SUB: ", " \tcase WASM_OP_I64MUL: ", " \tcase WASM_OP_I64DIVS: ", " \tcase WASM_OP_I64DIVU: ", " \tcase WASM_OP_I64REMS: ", " \tcase WASM_OP_I64REMU: ", " \tcase WASM_OP_I64AND: ", " \tcase WASM_OP_I64OR: ", " \tcase WASM_OP_I64XOR: ", " \tcase WASM_OP_I64SHL: ", " \tcase WASM_OP_I64SHRS: ", " \tcase WASM_OP_I64SHRU: ", " \tcase WASM_OP_I64ROTL: ", " \tcase WASM_OP_I64ROTR: ", " \tcase WASM_OP_F32ABS: ", " \tcase WASM_OP_F32NEG: ", " \tcase WASM_OP_F32CEIL: ", " \tcase WASM_OP_F32FLOOR: ", " \tcase WASM_OP_F32TRUNC: ", " \tcase WASM_OP_F32NEAREST: ", " \tcase WASM_OP_F32SQRT: ", " \tcase WASM_OP_F32ADD: ", " \tcase WASM_OP_F32SUB: ", " \tcase WASM_OP_F32MUL: ", " \tcase WASM_OP_F32DIV: ", " \tcase WASM_OP_F32MIN: ", " \tcase WASM_OP_F32MAX: ", " \tcase WASM_OP_F32COPYSIGN: ", " \tcase WASM_OP_F64ABS: ", " \tcase WASM_OP_F64NEG: ", " \tcase WASM_OP_F64CEIL: ", " \tcase WASM_OP_F64FLOOR: ", " \tcase WASM_OP_F64TRUNC: ", " \tcase WASM_OP_F64NEAREST: ", " \tcase WASM_OP_F64SQRT: ", " \tcase WASM_OP_F64ADD: ", " \tcase WASM_OP_F64SUB: ", " \tcase WASM_OP_F64MUL: ", " \tcase WASM_OP_F64DIV: ", " \tcase WASM_OP_F64MIN: ", " \tcase WASM_OP_F64MAX: ", " \tcase WASM_OP_F64COPYSIGN: ", " \tcase WASM_OP_I32WRAPI64: ", " \tcase WASM_OP_I32TRUNCSF32: ", " \tcase WASM_OP_I32TRUNCUF32: ", " \tcase WASM_OP_I32TRUNCSF64: ", " \tcase WASM_OP_I32TRUNCUF64: ", " \tcase WASM_OP_I64EXTENDSI32: ", " \tcase WASM_OP_I64EXTENDUI32: ", " \tcase WASM_OP_I64TRUNCSF32: ", " \tcase WASM_OP_I64TRUNCUF32: ", " \tcase WASM_OP_I64TRUNCSF64: ", " \tcase WASM_OP_I64TRUNCUF64: ", " \tcase WASM_OP_F32CONVERTSI32: ", " \tcase WASM_OP_F32CONVERTUI32: ", " \tcase WASM_OP_F32CONVERTSI64: ", " \tcase WASM_OP_F32CONVERTUI64: ", " \tcase WASM_OP_F32DEMOTEF64: ", " \tcase WASM_OP_F64CONVERTSI32: ", " \tcase WASM_OP_F64CONVERTUI32: ", " \tcase WASM_OP_F64CONVERTSI64: ", " \tcase WASM_OP_F64CONVERTUI64: ", " \tcase WASM_OP_F64PROMOTEF32: ", " \tcase WASM_OP_I32REINTERPRETF32: ", " \tcase WASM_OP_I64REINTERPRETF64: ", " \tcase WASM_OP_F32REINTERPRETI32: ", " \tcase WASM_OP_F64REINTERPRETI64:", " \tcase WASM_OP_END:", " \t\t{", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_BLOCK:", " \tcase WASM_OP_LOOP:", " \tcase WASM_OP_IF:", " \t\t{", " \t\t\tst32 val = 0;", " \t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tswitch (0x80 - val) {", " \t\t\tcase R_BIN_WASM_VALUETYPE_EMPTY:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\tcase R_BIN_WASM_VALUETYPE_i32:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i32)\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\tcase R_BIN_WASM_VALUETYPE_i64:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result i64)\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\tcase R_BIN_WASM_VALUETYPE_f32:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f32)\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\tcase R_BIN_WASM_VALUETYPE_f64:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result f64)\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s (result ?)\", opdef->txt);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_BR:", " \tcase WASM_OP_BRIF:", " \tcase WASM_OP_CALL:", " \t\t{", " \t\t\tut32 val = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_BRTABLE:", "  \t\t{", "  \t\t\tut32 count = 0, *table = NULL, def = 0;", "  \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count);", "\t\t\tif (!(n > 0 && n < buf_len)) goto err;", "\t\t\tif (!(table = calloc (count, sizeof (ut32)))) goto err;", " \t\t\tif (!(n > 0 && n < buf_len)) {", " \t\t\t\tgoto err;", " \t\t\t}", " \t\t\tif (!(table = calloc (count, sizeof (ut32)))) {", " \t\t\t\tgoto err;", " \t\t\t}", "  \t\t\tint i = 0;", "  \t\t\top->len += n;", "  \t\t\tfor (i = 0; i < count; i++) {", "  \t\t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]);", "\t\t\t\tif (!(op->len + n <= buf_len)) goto beach;", " \t\t\t\tif (!(op->len + n <= buf_len)) {", " \t\t\t\t\tgoto beach;", " \t\t\t\t}", "  \t\t\t\top->len += n;", "  \t\t\t}", "  \t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &def);", "\t\t\tif (!(n > 0 && n + op->len < buf_len)) goto beach;", " \t\t\tif (!(n > 0 && n + op->len < buf_len)) {", " \t\t\t\tgoto beach;", " \t\t\t}", "  \t\t\top->len += n;", "  \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d \", opdef->txt, count);", "\t\t\tfor (i = 0; i < count && strlen (op->txt) < R_ASM_BUFSIZE; i++) {", "\t\t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d \", table[i]);", " \t\t\tfor (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) {", " \t\t\t\tint optxtlen = strlen (op->txt);", " \t\t\t\tsnprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, \"%d \", table[i]);", "  \t\t\t}\t", "  \t\t\tsnprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, \"%d\", def);", "  \t\t\tfree (table);", "  \t\t\tbreak;", "  \t\t\tbeach:", "\t\t\t\tfree (table);", "\t\t\t\tgoto err;", " \t\t\tfree (table);", " \t\t\tgoto err;", "  \t\t}", "  \t\tbreak;", "  \tcase WASM_OP_CALLINDIRECT:", " \t\t{", " \t\t\tut32 val = 0, reserved = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\top->len += n;", " \t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved);", " \t\t\tif (!(n == 1 && op->len + n <= buf_len)) goto err;", " \t\t\treserved &= 0x1;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, val, reserved);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_GETLOCAL:", " \tcase WASM_OP_SETLOCAL:", " \tcase WASM_OP_TEELOCAL:", " \tcase WASM_OP_GETGLOBAL:", " \tcase WASM_OP_SETGLOBAL:", " \t\t{", " \t\t\tut32 val = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, val);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_I32LOAD:", " \tcase WASM_OP_I64LOAD: ", " \tcase WASM_OP_F32LOAD: ", " \tcase WASM_OP_F64LOAD: ", " \tcase WASM_OP_I32LOAD8S: ", " \tcase WASM_OP_I32LOAD8U: ", " \tcase WASM_OP_I32LOAD16S: ", " \tcase WASM_OP_I32LOAD16U: ", " \tcase WASM_OP_I64LOAD8S: ", " \tcase WASM_OP_I64LOAD8U: ", " \tcase WASM_OP_I64LOAD16S: ", " \tcase WASM_OP_I64LOAD16U: ", " \tcase WASM_OP_I64LOAD32S: ", " \tcase WASM_OP_I64LOAD32U: ", " \tcase WASM_OP_I32STORE: ", " \tcase WASM_OP_I64STORE: ", " \tcase WASM_OP_F32STORE: ", " \tcase WASM_OP_F64STORE: ", " \tcase WASM_OP_I32STORE8: ", " \tcase WASM_OP_I32STORE16: ", " \tcase WASM_OP_I64STORE8: ", " \tcase WASM_OP_I64STORE16: ", " \tcase WASM_OP_I64STORE32: ", " \t\t{", " \t\t\tut32 flag = 0, offset = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\top->len += n;", " \t\t\tn = read_u32_leb128 (buf + op->len, buf + buf_len, &offset);", " \t\t\tif (!(n > 0 && op->len + n <= buf_len)) goto err;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d %d\", opdef->txt, flag, offset);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_CURRENTMEMORY:", " \tcase WASM_OP_GROWMEMORY:", " \t\t{", " \t\t\tut32 reserved = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved);", " \t\t\tif (!(n == 1 && n < buf_len)) goto err;", " \t\t\treserved &= 0x1;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %d\", opdef->txt, reserved); ", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " ", " \tcase WASM_OP_I32CONST:", " \t\t{", " \t\t\tst32 val = 0;", " \t\t\tsize_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT32d, opdef->txt, val);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_I64CONST:", " \t\t{", " \t\t\tst64 val = 0;", " \t\t\tsize_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" PFMT64d, opdef->txt, val);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_F32CONST:", " \t\t{", " \t\t\tut32 val = 0;", " \t\t\tsize_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tlong double d =  (long double)val;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tcase WASM_OP_F64CONST:", " \t\t{", " \t\t\tut64 val = 0;", " \t\t\tsize_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val);", " \t\t\tif (!(n > 0 && n < buf_len)) goto err;", " \t\t\tlong double d =  (long double)val;", " \t\t\tsnprintf (op->txt, R_ASM_BUFSIZE, \"%s %\" LDBLFMT, opdef->txt, d);", " \t\t\top->len += n;", " \t\t}", " \t\tbreak;", " \tdefault:", " \t\tgoto err;", " \t}", " ", " \treturn op->len;", " ", " err:", " \top->len = 1;", "  \tsnprintf (op->txt, R_ASM_BUFSIZE, \"invalid\");", "  \treturn op->len;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int key_update(key_ref_t key_ref, const void *payload, size_t plen)", " {", " \tstruct key_preparsed_payload prep;", " \tstruct key *key = key_ref_to_ptr(key_ref);", " \tint ret;", " ", " \tkey_check(key);", " ", " \t ", " \tret = key_permission(key_ref, KEY_NEED_WRITE);", " \tif (ret < 0)", " \t\treturn ret;", " ", " \t ", " \tif (!key->type->update)", " \t\treturn -EOPNOTSUPP;", " ", " \tmemset(&prep, 0, sizeof(prep));", " \tprep.data = payload;", " \tprep.datalen = plen;", " \tprep.quotalen = key->type->def_datalen;", " \tprep.expiry = TIME_T_MAX;", " \tif (key->type->preparse) {", " \t\tret = key->type->preparse(&prep);", " \t\tif (ret < 0)", " \t\t\tgoto error;", " \t}", " ", " \tdown_write(&key->sem);", "  ", "  \tret = key->type->update(key, &prep);", "  \tif (ret == 0)", " \t\t ", "\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);", " \t\tmark_key_instantiated(key, 0);", "  ", "  \tup_write(&key->sem);", "  ", " error:", " \tif (key->type->preparse)", " \t\tkey->type->free_preparse(&prep);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" pax_decode_header (struct tar_sparse_file *file)", " {", "   if (file->stat_info->sparse_major > 0)", "     {", "       uintmax_t u;", "       char nbuf[UINTMAX_STRSIZE_BOUND];", "       union block *blk;", "       char *p;", "       size_t i;", "       off_t start;", "       ", " #define COPY_BUF(b,buf,src) do                                     \\", "  {                                                                 \\", "    char *endp = b->buffer + BLOCKSIZE;                             \\", "    char *dst = buf;                                                \\", "    do                                                              \\", "      {                                                             \\", "        if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\", "          {                                                         \\", "            ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\", " \t          file->stat_info->orig_file_name));               \\", "            return false;                                           \\", "          }                                                         \\", "        if (src == endp)                                            \\", "  \t {                                                         \\", "  \t   set_next_block_after (b);                               \\", "             b = find_next_block ();                                 \\", "            if (!b)                                                 \\", "              FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\", "             src = b->buffer;                                        \\", "  \t   endp = b->buffer + BLOCKSIZE;                           \\", "  \t }                                                         \\", "    while (*dst++ != '\\n');                                         \\", "    dst[-1] = 0;                                                    \\", "  } while (0)", " ", "       start = current_block_ordinal ();", "       set_next_block_after (current_header);", "        start = current_block_ordinal ();", "        set_next_block_after (current_header);", "        blk = find_next_block ();", "       if (!blk)", "         FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));", "        p = blk->buffer;", "        COPY_BUF (blk,nbuf,p);", "        if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))", " \t}", "       file->stat_info->sparse_map_size = u;", "       file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,", " \t\t\t\t\t     sizeof (*file->stat_info->sparse_map));", "       file->stat_info->sparse_map_avail = 0;", "       for (i = 0; i < file->stat_info->sparse_map_size; i++)", " \t{", " \t  struct sp_array sp;", " ", " \t  COPY_BUF (blk,nbuf,p);", " \t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))", " \t    {", " \t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),", " \t\t      file->stat_info->orig_file_name));", " \t      return false;", " \t    }", " \t  sp.offset = u;", " \t  COPY_BUF (blk,nbuf,p);", " \t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))", " \t    {", " \t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),", " \t\t      file->stat_info->orig_file_name));", " \t      return false;", " \t    }", " \t  sp.numbytes = u;", " \t  sparse_add_map (file->stat_info, &sp);", " \t}", "       set_next_block_after (blk);", " ", "       file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);", "     }", " ", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)", " static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,", " \t\t\t const void *data)", "  {", " \tu8 *buf;", "  \tint ret;", "  ", " \tbuf = kmemdup(data, size, GFP_NOIO);", " \tif (!buf)", " \t\treturn -ENOMEM;", " ", "  \tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),", "  \t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,", "\t\t\t      indx, data, size, 100);", " \t\t\t      indx, buf, size, 100);", "  \tif (ret < 0)", "  \t\tnetif_dbg(pegasus, drv, pegasus->net,", "  \t\t\t  \"%s returned %d\\n\", __func__, ret);", " \tkfree(buf);", "  \treturn ret;", "  }"], "ner_tags": [0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]}
{"tokens": ["  jbig2_text_region(Jbig2Ctx *ctx, Jbig2Segment *segment, const byte *segment_data)", "  {", "    int offset = 0;", "     uint32_t offset = 0;", "      Jbig2RegionSegmentInfo region_info;", "      Jbig2TextRegionParams params;", "      Jbig2Image *image = NULL;", "      Jbig2SymbolDict **dicts = NULL;", "    int n_dicts = 0;", "     uint32_t n_dicts = 0;", "      uint16_t flags = 0;", "      uint16_t huffman_flags = 0;", "      Jbig2ArithCx *GR_stats = NULL;", "      int code = 0;", "      Jbig2WordStream *ws = NULL;", "      Jbig2ArithState *as = NULL;", "    int table_index = 0;", "     uint32_t table_index = 0;", "      const Jbig2HuffmanParams *huffman_params = NULL;", "  ", "       ", "     if (segment->data_length < 17)", "         goto too_short;", "     jbig2_get_region_segment_info(&region_info, segment_data);", "     offset += 17;", " ", "      ", "     flags = jbig2_get_uint16(segment_data + offset);", "     offset += 2;", " ", "     jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"text region header flags 0x%04x\", flags);", " ", "      ", "     memset(&params, 0, sizeof(Jbig2TextRegionParams));", " ", "     params.SBHUFF = flags & 0x0001;", "     params.SBREFINE = flags & 0x0002;", "     params.LOGSBSTRIPS = (flags & 0x000c) >> 2;", "     params.SBSTRIPS = 1 << params.LOGSBSTRIPS;", "     params.REFCORNER = (Jbig2RefCorner)((flags & 0x0030) >> 4);", "     params.TRANSPOSED = flags & 0x0040;", "     params.SBCOMBOP = (Jbig2ComposeOp)((flags & 0x0180) >> 7);", "     params.SBDEFPIXEL = flags & 0x0200;", "      ", "     params.SBDSOFFSET = (flags & 0x7C00) >> 10;", "     if (params.SBDSOFFSET > 0x0f)", "         params.SBDSOFFSET -= 0x20;", "     params.SBRTEMPLATE = flags & 0x8000;", " ", "     if (params.SBDSOFFSET) {", "         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number, \"text region has SBDSOFFSET %d\", params.SBDSOFFSET);", "     }", " ", "     if (params.SBHUFF) {         ", "          ", "         huffman_flags = jbig2_get_uint16(segment_data + offset);", "         offset += 2;", " ", "         if (huffman_flags & 0x8000)", "             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"reserved bit 15 of text region huffman flags is not zero\");", "     } else {                     ", " ", "          ", "         if ((params.SBREFINE) && !(params.SBRTEMPLATE)) {", "             params.sbrat[0] = segment_data[offset];", "             params.sbrat[1] = segment_data[offset + 1];", "             params.sbrat[2] = segment_data[offset + 2];", "             params.sbrat[3] = segment_data[offset + 3];", "             offset += 4;", "         }", "     }", " ", "      ", "     params.SBNUMINSTANCES = jbig2_get_uint32(segment_data + offset);", "     offset += 4;", " ", "     if (params.SBHUFF) {", "          ", "          ", " ", "          ", "         switch (huffman_flags & 0x0003) {", "         case 0:                 ", "             params.SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_F);", "             break;", "         case 1:                 ", "             params.SBHUFFFS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_G);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom FS huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFFS = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         case 2:                 ", "         default:", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region specified invalid FS huffman table\");", "             goto cleanup1;", "             break;", "         }", "         if (params.SBHUFFFS == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified FS huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x000c) >> 2) {", "         case 0:                 ", "             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_H);", "             break;", "         case 1:                 ", "             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_I);", "             break;", "         case 2:                 ", "             params.SBHUFFDS = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_J);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom DS huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFDS = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         }", "         if (params.SBHUFFDS == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified DS huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x0030) >> 4) {", "         case 0:                 ", "             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_K);", "             break;", "         case 1:                 ", "             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_L);", "             break;", "         case 2:                 ", "             params.SBHUFFDT = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_M);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom DT huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFDT = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         }", "         if (params.SBHUFFDT == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified DT huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x00c0) >> 6) {", "         case 0:                 ", "             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);", "             break;", "         case 1:                 ", "             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom RDW huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFRDW = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         case 2:                 ", "         default:", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region specified invalid RDW huffman table\");", "             goto cleanup1;", "             break;", "         }", "         if (params.SBHUFFRDW == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified RDW huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x0300) >> 8) {", "         case 0:                 ", "             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);", "             break;", "         case 1:                 ", "             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom RDH huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFRDH = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         case 2:                 ", "         default:", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region specified invalid RDH huffman table\");", "             goto cleanup1;", "             break;", "         }", "         if (params.SBHUFFRDH == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified RDH huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x0c00) >> 10) {", "         case 0:                 ", "             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);", "             break;", "         case 1:                 ", "             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom RDX huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFRDX = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         case 2:                 ", "         default:", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region specified invalid RDX huffman table\");", "             goto cleanup1;", "             break;", "         }", "         if (params.SBHUFFRDX == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified RDX huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x3000) >> 12) {", "         case 0:                 ", "             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_N);", "             break;", "         case 1:                 ", "             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_O);", "             break;", "         case 3:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom RDY huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFRDY = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         case 2:                 ", "         default:", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region specified invalid RDY huffman table\");", "             goto cleanup1;", "             break;", "         }", "         if (params.SBHUFFRDY == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified RDY huffman table\");", "             goto cleanup1;", "         }", " ", "         switch ((huffman_flags & 0x4000) >> 14) {", "         case 0:                 ", "             params.SBHUFFRSIZE = jbig2_build_huffman_table(ctx, &jbig2_huffman_params_A);", "             break;", "         case 1:                 ", "             huffman_params = jbig2_find_table(ctx, segment, table_index);", "             if (huffman_params == NULL) {", "                 code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Custom RSIZE huffman table not found (%d)\", table_index);", "                 goto cleanup1;", "             }", "             params.SBHUFFRSIZE = jbig2_build_huffman_table(ctx, huffman_params);", "             ++table_index;", "             break;", "         }", "         if (params.SBHUFFRSIZE == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to allocate text region specified RSIZE huffman table\");", "             goto cleanup1;", "         }", " ", "         if (huffman_flags & 0x8000) {", "             jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"text region huffman flags bit 15 is set, contrary to spec\");", "         }", " ", "          ", "          ", "     }", " ", "     jbig2_error(ctx, JBIG2_SEVERITY_INFO, segment->number,", "                 \"text region: %d x %d @ (%d,%d) %d symbols\", region_info.width, region_info.height, region_info.x, region_info.y, params.SBNUMINSTANCES);", " ", "      ", "     n_dicts = jbig2_sd_count_referred(ctx, segment);", "     if (n_dicts != 0) {", "         dicts = jbig2_sd_list_referred(ctx, segment);", "     } else {", "         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"text region refers to no symbol dictionaries!\");", "         goto cleanup1;", "     }", "     if (dicts == NULL) {", "          code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"unable to retrive symbol dictionaries! previous parsing error?\");", "          goto cleanup1;", "      } else {", "        int index;", "         uint32_t index;", "  ", "          if (dicts[0] == NULL) {", "              code = jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"unable to find first referenced symbol dictionary!\");", "             goto cleanup1;", "         }", "         for (index = 1; index < n_dicts; index++)", "             if (dicts[index] == NULL) {", "                 jbig2_error(ctx, JBIG2_SEVERITY_WARNING, segment->number, \"unable to find all referenced symbol dictionaries!\");", "                 n_dicts = index;", "             }", "     }", " ", "      ", "     {", "         int stats_size = params.SBRTEMPLATE ? 1 << 10 : 1 << 13;", " ", "         GR_stats = jbig2_new(ctx, Jbig2ArithCx, stats_size);", "         if (GR_stats == NULL) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"could not allocate GR_stats\");", "             goto cleanup1;", "         }", "         memset(GR_stats, 0, stats_size);", "     }", " ", "     image = jbig2_image_new(ctx, region_info.width, region_info.height);", "     if (image == NULL) {", "         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"couldn't allocate text region image\");", "         goto cleanup2;", "     }", " ", "     ws = jbig2_word_stream_buf_new(ctx, segment_data + offset, segment->data_length - offset);", "     if (ws == NULL) {", "         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"couldn't allocate ws in text region image\");", "         goto cleanup2;", "     }", " ", "     as = jbig2_arith_new(ctx, ws);", "     if (as == NULL) {", "         code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"couldn't allocate as in text region image\");", "         goto cleanup2;", "      }", "  ", "      if (!params.SBHUFF) {", "        int SBSYMCODELEN, index;", "        int SBNUMSYMS = 0;", "         uint32_t SBSYMCODELEN, index;", "         uint32_t SBNUMSYMS = 0;", "  ", "          for (index = 0; index < n_dicts; index++) {", "              SBNUMSYMS += dicts[index]->n_symbols;", "         }", " ", "         params.IADT = jbig2_arith_int_ctx_new(ctx);", "         params.IAFS = jbig2_arith_int_ctx_new(ctx);", "         params.IADS = jbig2_arith_int_ctx_new(ctx);", "         params.IAIT = jbig2_arith_int_ctx_new(ctx);", "         if ((params.IADT == NULL) || (params.IAFS == NULL) || (params.IADS == NULL) || (params.IAIT == NULL)) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"couldn't allocate text region image data\");", "             goto cleanup3;", "          }", "  ", "           ", "        for (SBSYMCODELEN = 0; (1 << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) {", "         for (SBSYMCODELEN = 0; (1U << SBSYMCODELEN) < SBNUMSYMS; SBSYMCODELEN++) {", "          }", "          params.IAID = jbig2_arith_iaid_ctx_new(ctx, SBSYMCODELEN);", "          params.IARI = jbig2_arith_int_ctx_new(ctx);", "         params.IARDW = jbig2_arith_int_ctx_new(ctx);", "         params.IARDH = jbig2_arith_int_ctx_new(ctx);", "         params.IARDX = jbig2_arith_int_ctx_new(ctx);", "         params.IARDY = jbig2_arith_int_ctx_new(ctx);", "         if ((params.IAID == NULL) || (params.IARI == NULL) ||", "                 (params.IARDW == NULL) || (params.IARDH == NULL) || (params.IARDX == NULL) || (params.IARDY == NULL)) {", "             code = jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"couldn't allocate text region image data\");", "             goto cleanup4;", "         }", "     }", " ", "     code = jbig2_decode_text_region(ctx, segment, &params,", "                                     (const Jbig2SymbolDict * const *)dicts, n_dicts, image,", "                                     segment_data + offset, segment->data_length - offset, GR_stats, as, ws);", "     if (code < 0) {", "         jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"failed to decode text region image data\");", "         goto cleanup4;", "     }", " ", "     if ((segment->flags & 63) == 4) {", "          ", "         segment->result = jbig2_image_clone(ctx, image);", "     } else {", "          ", "         jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, segment->number,", "                     \"composing %dx%d decoded text region onto page at (%d, %d)\", region_info.width, region_info.height, region_info.x, region_info.y);", "         jbig2_page_add_result(ctx, &ctx->pages[ctx->current_page], image, region_info.x, region_info.y, region_info.op);", "     }", " ", " cleanup4:", "     if (!params.SBHUFF) {", "         jbig2_arith_iaid_ctx_free(ctx, params.IAID);", "         jbig2_arith_int_ctx_free(ctx, params.IARI);", "         jbig2_arith_int_ctx_free(ctx, params.IARDW);", "         jbig2_arith_int_ctx_free(ctx, params.IARDH);", "         jbig2_arith_int_ctx_free(ctx, params.IARDX);", "         jbig2_arith_int_ctx_free(ctx, params.IARDY);", "     }", " ", " cleanup3:", "     if (!params.SBHUFF) {", "         jbig2_arith_int_ctx_free(ctx, params.IADT);", "         jbig2_arith_int_ctx_free(ctx, params.IAFS);", "         jbig2_arith_int_ctx_free(ctx, params.IADS);", "         jbig2_arith_int_ctx_free(ctx, params.IAIT);", "     }", "     jbig2_free(ctx->allocator, as);", "     jbig2_word_stream_buf_free(ctx, ws);", " ", " cleanup2:", "     jbig2_free(ctx->allocator, GR_stats);", "     jbig2_image_release(ctx, image);", " ", " cleanup1:", "     if (params.SBHUFF) {", "         jbig2_release_huffman_table(ctx, params.SBHUFFFS);", "         jbig2_release_huffman_table(ctx, params.SBHUFFDS);", "         jbig2_release_huffman_table(ctx, params.SBHUFFDT);", "         jbig2_release_huffman_table(ctx, params.SBHUFFRDX);", "         jbig2_release_huffman_table(ctx, params.SBHUFFRDY);", "         jbig2_release_huffman_table(ctx, params.SBHUFFRDW);", "         jbig2_release_huffman_table(ctx, params.SBHUFFRDH);", "         jbig2_release_huffman_table(ctx, params.SBHUFFRSIZE);", "     }", "     jbig2_free(ctx->allocator, dicts);", " ", "     return code;", " ", " too_short:", "     return jbig2_error(ctx, JBIG2_SEVERITY_FATAL, segment->number, \"Segment too short\");", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,", "struct nft_data_desc *desc, const struct nlattr *nla)", "{", "u8 genmask = nft_genmask_next(ctx->net);", "struct nlattr *tb[NFTA_VERDICT_MAX + 1];", "struct nft_chain *chain;", "int err;", "", "err = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,", "nft_verdict_policy, NULL);", "if (err < 0)", "return err;", "", "if (!tb[NFTA_VERDICT_CODE])", "return -EINVAL;", "data->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));", "", "switch (data->verdict.code) {", "default:", "switch (data->verdict.code & NF_VERDICT_MASK) {", "case NF_ACCEPT:", "case NF_DROP:", "case NF_QUEUE:", "break;", "default:", "return -EINVAL;", "}", "fallthrough;", "case NFT_CONTINUE:", "case NFT_BREAK:", "case NFT_RETURN:", "break;", "case NFT_JUMP:", "case NFT_GOTO:", "if (tb[NFTA_VERDICT_CHAIN]) {", "chain = nft_chain_lookup(ctx->net, ctx->table,", "tb[NFTA_VERDICT_CHAIN],", "genmask);", "} else if (tb[NFTA_VERDICT_CHAIN_ID]) {", "chain = nft_chain_lookup_byid(ctx->net, ctx->table,", "tb[NFTA_VERDICT_CHAIN_ID]);", "if (IS_ERR(chain))", "return PTR_ERR(chain);", "} else {", "return -EINVAL;", "}", "", "if (IS_ERR(chain))", "return PTR_ERR(chain);", "if (nft_is_base_chain(chain))", "return -EOPNOTSUPP;", "if (desc->flags & NFT_DATA_DESC_SETELEM &&", "chain->flags & NFT_CHAIN_BINDING)", "return -EINVAL;", "", "chain->use++;", "data->verdict.chain = chain;", "break;", "}", "", "desc->len = sizeof(data->verdict);", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void __net_exit sctp_net_exit(struct net *net)", " static void __net_exit sctp_defaults_exit(struct net *net)", "  {", "  \t ", "  \tsctp_free_addr_wq(net);", "  \tsctp_free_local_addr_list(net);", "  ", "\t ", "\tinet_ctl_sock_destroy(net->sctp.ctl_sock);", "  \tsctp_dbg_objcnt_exit(net);", "  ", "  \tsctp_proc_exit(net);", "  \tcleanup_sctp_mibs(net);", "  \tsctp_sysctl_net_unregister(net);", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,", "const xmlChar *name, const xmlChar *value) {", "xmlChar *ret, *dst;", "const xmlChar *src;", "xmlAttributePtr attrDecl = NULL;", "", "if (doc == NULL) return(NULL);", "if (elem == NULL) return(NULL);", "if (name == NULL) return(NULL);", "if (value == NULL) return(NULL);", "", "if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {", "xmlChar fn[50];", "xmlChar *fullname;", "", "fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);", "if (fullname == NULL)", "return(NULL);", "if ((fullname != fn) && (fullname != elem->name))", "xmlFree(fullname);", "}", "attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);", "if ((attrDecl == NULL) && (doc->extSubset != NULL))", "attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);", "", "if (attrDecl == NULL)", "return(NULL);", "if (attrDecl->atype == XML_ATTRIBUTE_CDATA)", "return(NULL);", "", "ret = xmlStrdup(value);", "if (ret == NULL)", "return(NULL);", "src = value;", "dst = ret;", "while (*src == 0x20) src++;", "while (*src != 0) {", "if (*src == 0x20) {", "while (*src == 0x20) src++;", "if (*src != 0)", "*dst++ = 0x20;", "} else {", "*dst++ = *src++;", "}", "}", "*dst = 0;", "return(ret);", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": [" void bpf_jit_compile(struct sk_filter *fp)", " {", " \tu8 temp[64];", " \tu8 *prog;", " \tunsigned int proglen, oldproglen = 0;", " \tint ilen, i;", " \tint t_offset, f_offset;", " \tu8 t_op, f_op, seen = 0, pass;", " \tu8 *image = NULL;", " \tu8 *func;", " \tint pc_ret0 = -1;  ", " \tunsigned int cleanup_addr;  ", " \tunsigned int *addrs;", " \tconst struct sock_filter *filter = fp->insns;", " \tint flen = fp->len;", " ", " \tif (!bpf_jit_enable)", " \t\treturn;", " ", " \taddrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);", " \tif (addrs == NULL)", " \t\treturn;", " ", " \t ", " \tfor (proglen = 0, i = 0; i < flen; i++) {", " \t\tproglen += 64;", " \t\taddrs[i] = proglen;", " \t}", " \tcleanup_addr = proglen;  ", " ", " \tfor (pass = 0; pass < 10; pass++) {", " \t\t ", " \t\tproglen = 0;", " \t\tprog = temp;", " ", " \t\tif (seen) {", " \t\t\tEMIT4(0x55, 0x48, 0x89, 0xe5);  ", " \t\t\tEMIT4(0x48, 0x83, 0xec, 96);\t ", " \t\t\t ", " \t\t\tif (seen & (SEEN_XREG | SEEN_DATAREF))", " \t\t\t\tEMIT4(0x48, 0x89, 0x5d, 0xf8);  ", " \t\t\tif (seen & SEEN_XREG)", " \t\t\t\tCLEAR_X();  ", " ", " \t\t\t ", " \t\t\tif (seen & SEEN_DATAREF) {", " \t\t\t\tif (offsetof(struct sk_buff, len) <= 127)", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));", " \t\t\t\telse {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x44, 0x8b, 0x8f);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);", " \t\t\t\t}", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, data_len)))", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));", " \t\t\t\telse {", " \t\t\t\t\tEMIT3(0x44, 0x2b, 0x8f);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, data_len), 4);", " \t\t\t\t}", " ", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, data)))", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));", " \t\t\t\telse {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x4c, 0x8b, 0x87);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, data), 4);", " \t\t\t\t}", " \t\t\t}", " \t\t}", " ", " \t\tswitch (filter[0].code) {", " \t\tcase BPF_S_RET_K:", " \t\tcase BPF_S_LD_W_LEN:", " \t\tcase BPF_S_ANC_PROTOCOL:", " \t\tcase BPF_S_ANC_IFINDEX:", " \t\tcase BPF_S_ANC_MARK:", " \t\tcase BPF_S_ANC_RXHASH:", " \t\tcase BPF_S_ANC_CPU:", " \t\tcase BPF_S_ANC_QUEUE:", " \t\tcase BPF_S_LD_W_ABS:", " \t\tcase BPF_S_LD_H_ABS:", " \t\tcase BPF_S_LD_B_ABS:", " \t\t\t ", " \t\t\tbreak;", " \t\tdefault:", " \t\t\t ", " \t\t\tCLEAR_A();  ", " \t\t}", " ", " \t\tfor (i = 0; i < flen; i++) {", " \t\t\tunsigned int K = filter[i].k;", " ", " \t\t\tswitch (filter[i].code) {", " \t\t\tcase BPF_S_ALU_ADD_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x01, 0xd8);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_ADD_K:  ", " \t\t\t\tif (!K)", " \t\t\t\t\tbreak;", " \t\t\t\tif (is_imm8(K))", " \t\t\t\t\tEMIT3(0x83, 0xc0, K);\t ", " \t\t\t\telse", " \t\t\t\t\tEMIT1_off32(0x05, K);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_SUB_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x29, 0xd8);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_SUB_K:  ", " \t\t\t\tif (!K)", " \t\t\t\t\tbreak;", " \t\t\t\tif (is_imm8(K))", " \t\t\t\t\tEMIT3(0x83, 0xe8, K);  ", " \t\t\t\telse", " \t\t\t\t\tEMIT1_off32(0x2d, K);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_MUL_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT3(0x0f, 0xaf, 0xc3);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_MUL_K:  ", " \t\t\t\tif (is_imm8(K))", " \t\t\t\t\tEMIT3(0x6b, 0xc0, K);  ", " \t\t\t\telse {", " \t\t\t\t\tEMIT2(0x69, 0xc0);\t\t ", " \t\t\t\t\tEMIT(K, 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_DIV_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x85, 0xdb);\t ", " \t\t\t\tif (pc_ret0 != -1)", " \t\t\t\t\tEMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));", " \t\t\t\telse {", " \t\t\t\t\tEMIT_COND_JMP(X86_JNE, 2 + 5);", " \t\t\t\t\tCLEAR_A();", " \t\t\t\t\tEMIT1_off32(0xe9, cleanup_addr - (addrs[i] - 4));  ", " \t\t\t\t}", " \t\t\t\tEMIT4(0x31, 0xd2, 0xf7, 0xf3);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_DIV_K:  ", " \t\t\t\tEMIT3(0x48, 0x69, 0xc0);  ", " \t\t\t\tEMIT(K, 4);", " \t\t\t\tEMIT4(0x48, 0xc1, 0xe8, 0x20);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_AND_X:", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x21, 0xd8);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_AND_K:", " \t\t\t\tif (K >= 0xFFFFFF00) {", " \t\t\t\t\tEMIT2(0x24, K & 0xFF);  ", " \t\t\t\t} else if (K >= 0xFFFF0000) {", " \t\t\t\t\tEMIT2(0x66, 0x25);\t ", " \t\t\t\t\tEMIT2(K, 2);", " \t\t\t\t} else {", " \t\t\t\t\tEMIT1_off32(0x25, K);\t ", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_OR_X:", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x09, 0xd8);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_OR_K:", " \t\t\t\tif (is_imm8(K))", " \t\t\t\t\tEMIT3(0x83, 0xc8, K);  ", " \t\t\t\telse", " \t\t\t\t\tEMIT1_off32(0x0d, K);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_LSH_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe0);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_LSH_K:", " \t\t\t\tif (K == 0)", " \t\t\t\t\tbreak;", " \t\t\t\telse if (K == 1)", " \t\t\t\t\tEMIT2(0xd1, 0xe0);  ", " \t\t\t\telse", " \t\t\t\t\tEMIT3(0xc1, 0xe0, K);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_RSH_X:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT4(0x89, 0xd9, 0xd3, 0xe8);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_RSH_K:  ", " \t\t\t\tif (K == 0)", " \t\t\t\t\tbreak;", " \t\t\t\telse if (K == 1)", " \t\t\t\t\tEMIT2(0xd1, 0xe8);  ", " \t\t\t\telse", " \t\t\t\t\tEMIT3(0xc1, 0xe8, K);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ALU_NEG:", " \t\t\t\tEMIT2(0xf7, 0xd8);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_RET_K:", " \t\t\t\tif (!K) {", " \t\t\t\t\tif (pc_ret0 == -1)", " \t\t\t\t\t\tpc_ret0 = i;", " \t\t\t\t\tCLEAR_A();", " \t\t\t\t} else {", " \t\t\t\t\tEMIT1_off32(0xb8, K);\t ", " \t\t\t\t}", " \t\t\t\t ", " \t\t\tcase BPF_S_RET_A:", " \t\t\t\tif (seen) {", " \t\t\t\t\tif (i != flen - 1) {", " \t\t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tif (seen & SEEN_XREG)", " \t\t\t\t\t\tEMIT4(0x48, 0x8b, 0x5d, 0xf8);   ", " \t\t\t\t\tEMIT1(0xc9);\t\t ", " \t\t\t\t}", " \t\t\t\tEMIT1(0xc3);\t\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_MISC_TAX:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x89, 0xc3);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_MISC_TXA:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tEMIT2(0x89, 0xd8);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_IMM:  ", " \t\t\t\tif (!K)", " \t\t\t\t\tCLEAR_A();", " \t\t\t\telse", " \t\t\t\t\tEMIT1_off32(0xb8, K);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LDX_IMM:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tif (!K)", " \t\t\t\t\tCLEAR_X();", " \t\t\t\telse", " \t\t\t\t\tEMIT1_off32(0xbb, K);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_MEM:  ", " \t\t\t\tseen |= SEEN_MEM;", " \t\t\t\tEMIT3(0x8b, 0x45, 0xf0 - K*4);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LDX_MEM:  ", " \t\t\t\tseen |= SEEN_XREG | SEEN_MEM;", " \t\t\t\tEMIT3(0x8b, 0x5d, 0xf0 - K*4);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ST:  ", " \t\t\t\tseen |= SEEN_MEM;", " \t\t\t\tEMIT3(0x89, 0x45, 0xf0 - K*4);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_STX:  ", " \t\t\t\tseen |= SEEN_XREG | SEEN_MEM;", " \t\t\t\tEMIT3(0x89, 0x5d, 0xf0 - K*4);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_W_LEN:  ", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));", " \t\t\t\telse {", " \t\t\t\t\tEMIT2(0x8b, 0x87);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LDX_W_LEN:  ", " \t\t\t\tseen |= SEEN_XREG;", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, len)))", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));", " \t\t\t\telse {", " \t\t\t\t\tEMIT2(0x8b, 0x9f);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, len), 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_PROTOCOL:  ", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, protocol))) {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));", " \t\t\t\t} else {", " \t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87);  ", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, protocol), 4);", " \t\t\t\t}", " \t\t\t\tEMIT2(0x86, 0xc4);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_IFINDEX:", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, dev))) {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));", " \t\t\t\t} else {", " \t\t\t\t\tEMIT3(0x48, 0x8b, 0x87);  ", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, dev), 4);", " \t\t\t\t}", " \t\t\t\tEMIT3(0x48, 0x85, 0xc0);\t ", " \t\t\t\tEMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);", " \t\t\t\tEMIT2(0x8b, 0x80);\t ", " \t\t\t\tEMIT(offsetof(struct net_device, ifindex), 4);", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_MARK:", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, mark))) {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));", " \t\t\t\t} else {", " \t\t\t\t\tEMIT2(0x8b, 0x87);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, mark), 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_RXHASH:", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, rxhash))) {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));", " \t\t\t\t} else {", " \t\t\t\t\tEMIT2(0x8b, 0x87);", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, rxhash), 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_QUEUE:", " \t\t\t\tBUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);", " \t\t\t\tif (is_imm8(offsetof(struct sk_buff, queue_mapping))) {", " \t\t\t\t\t ", " \t\t\t\t\tEMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));", " \t\t\t\t} else {", " \t\t\t\t\tEMIT3(0x0f, 0xb7, 0x87);  ", " \t\t\t\t\tEMIT(offsetof(struct sk_buff, queue_mapping), 4);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_ANC_CPU:", " #ifdef CONFIG_SMP", " \t\t\t\tEMIT4(0x65, 0x8b, 0x04, 0x25);  ", " \t\t\t\tEMIT((u32)(unsigned long)&cpu_number, 4);  ", " #else", " \t\t\t\tCLEAR_A();", " #endif", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_W_ABS:", " \t\t\t\tfunc = sk_load_word;", " common_load:\t\t\tseen |= SEEN_DATAREF;", " \t\t\t\tif ((int)K < 0)", " \t\t\t\t\tgoto out;", " \t\t\t\tt_offset = func - (image + addrs[i]);", " \t\t\t\tEMIT1_off32(0xbe, K);  ", " \t\t\t\tEMIT1_off32(0xe8, t_offset);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_H_ABS:", " \t\t\t\tfunc = sk_load_half;", " \t\t\t\tgoto common_load;", " \t\t\tcase BPF_S_LD_B_ABS:", " \t\t\t\tfunc = sk_load_byte;", " \t\t\t\tgoto common_load;", " \t\t\tcase BPF_S_LDX_B_MSH:", " \t\t\t\tif ((int)K < 0) {", " \t\t\t\t\tif (pc_ret0 != -1) {", " \t\t\t\t\t\tEMIT_JMP(addrs[pc_ret0] - addrs[i]);", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\t\tCLEAR_A();", " \t\t\t\t\tEMIT_JMP(cleanup_addr - addrs[i]);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tseen |= SEEN_DATAREF | SEEN_XREG;", " \t\t\t\tt_offset = sk_load_byte_msh - (image + addrs[i]);", " \t\t\t\tEMIT1_off32(0xbe, K);\t ", " \t\t\t\tEMIT1_off32(0xe8, t_offset);  ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_W_IND:", " \t\t\t\tfunc = sk_load_word_ind;", " common_load_ind:\t\tseen |= SEEN_DATAREF | SEEN_XREG;", " \t\t\t\tt_offset = func - (image + addrs[i]);", " \t\t\t\tEMIT1_off32(0xbe, K);\t ", " \t\t\t\tEMIT1_off32(0xe8, t_offset);\t ", " \t\t\t\tbreak;", " \t\t\tcase BPF_S_LD_H_IND:", " \t\t\t\tfunc = sk_load_half_ind;", " \t\t\t\tgoto common_load_ind;", " \t\t\tcase BPF_S_LD_B_IND:", " \t\t\t\tfunc = sk_load_byte_ind;", " \t\t\t\tgoto common_load_ind;", " \t\t\tcase BPF_S_JMP_JA:", " \t\t\t\tt_offset = addrs[i + K] - addrs[i];", " \t\t\t\tEMIT_JMP(t_offset);", " \t\t\t\tbreak;", " \t\t\tCOND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);", " \t\t\tCOND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);", " \t\t\tCOND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);", " \t\t\tCOND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);", " \t\t\tCOND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);", " \t\t\tCOND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);", " \t\t\tCOND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);", " \t\t\tCOND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);", " ", " cond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];", " \t\t\t\tt_offset = addrs[i + filter[i].jt] - addrs[i];", " ", " \t\t\t\t ", " \t\t\t\tif (filter[i].jt == filter[i].jf) {", " \t\t\t\t\tEMIT_JMP(t_offset);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " ", " \t\t\t\tswitch (filter[i].code) {", " \t\t\t\tcase BPF_S_JMP_JGT_X:", " \t\t\t\tcase BPF_S_JMP_JGE_X:", " \t\t\t\tcase BPF_S_JMP_JEQ_X:", " \t\t\t\t\tseen |= SEEN_XREG;", " \t\t\t\t\tEMIT2(0x39, 0xd8);  ", " \t\t\t\t\tbreak;", " \t\t\t\tcase BPF_S_JMP_JSET_X:", " \t\t\t\t\tseen |= SEEN_XREG;", " \t\t\t\t\tEMIT2(0x85, 0xd8);  ", " \t\t\t\t\tbreak;", " \t\t\t\tcase BPF_S_JMP_JEQ_K:", " \t\t\t\t\tif (K == 0) {", " \t\t\t\t\t\tEMIT2(0x85, 0xc0);  ", " \t\t\t\t\t\tbreak;", " \t\t\t\t\t}", " \t\t\t\tcase BPF_S_JMP_JGT_K:", " \t\t\t\tcase BPF_S_JMP_JGE_K:", " \t\t\t\t\tif (K <= 127)", " \t\t\t\t\t\tEMIT3(0x83, 0xf8, K);  ", " \t\t\t\t\telse", " \t\t\t\t\t\tEMIT1_off32(0x3d, K);  ", " \t\t\t\t\tbreak;", " \t\t\t\tcase BPF_S_JMP_JSET_K:", " \t\t\t\t\tif (K <= 0xFF)", " \t\t\t\t\t\tEMIT2(0xa8, K);  ", " \t\t\t\t\telse if (!(K & 0xFFFF00FF))", " \t\t\t\t\t\tEMIT3(0xf6, 0xc4, K >> 8);  ", " \t\t\t\t\telse if (K <= 0xFFFF) {", " \t\t\t\t\t\tEMIT2(0x66, 0xa9);  ", " \t\t\t\t\t\tEMIT(K, 2);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tEMIT1_off32(0xa9, K);  ", " \t\t\t\t\t}", "  \t\t\t\t\tbreak;", "  \t\t\t\t}", "  \t\t\t\tif (filter[i].jt != 0) {", "\t\t\t\t\tif (filter[i].jf)", "\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;", " \t\t\t\t\tif (filter[i].jf && f_offset)", " \t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;", "  \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);", "  \t\t\t\t\tif (filter[i].jf)", "  \t\t\t\t\t\tEMIT_JMP(f_offset);", " \t\t\t\t\tbreak;", " \t\t\t\t}", " \t\t\t\tEMIT_COND_JMP(f_op, f_offset);", " \t\t\t\tbreak;", " \t\t\tdefault:", " \t\t\t\t ", " \t\t\t\tgoto out;", " \t\t\t}", " \t\t\tilen = prog - temp;", " \t\t\tif (image) {", " \t\t\t\tif (unlikely(proglen + ilen > oldproglen)) {", " \t\t\t\t\tpr_err(\"bpb_jit_compile fatal error\\n\");", " \t\t\t\t\tkfree(addrs);", " \t\t\t\t\tmodule_free(NULL, image);", " \t\t\t\t\treturn;", " \t\t\t\t}", " \t\t\t\tmemcpy(image + proglen, temp, ilen);", " \t\t\t}", " \t\t\tproglen += ilen;", " \t\t\taddrs[i] = proglen;", " \t\t\tprog = temp;", " \t\t}", " \t\t ", " \t\tcleanup_addr = proglen - 1;  ", " \t\tif (seen)", " \t\t\tcleanup_addr -= 1;  ", " \t\tif (seen & SEEN_XREG)", " \t\t\tcleanup_addr -= 4;  ", " ", " \t\tif (image) {", " \t\t\tWARN_ON(proglen != oldproglen);", " \t\t\tbreak;", " \t\t}", " \t\tif (proglen == oldproglen) {", " \t\t\timage = module_alloc(max_t(unsigned int,", " \t\t\t\t\t\t   proglen,", " \t\t\t\t\t\t   sizeof(struct work_struct)));", " \t\t\tif (!image)", " \t\t\t\tgoto out;", " \t\t}", " \t\toldproglen = proglen;", " \t}", " \tif (bpf_jit_enable > 1)", " \t\tpr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",", " \t\t       flen, proglen, pass, image);", " ", " \tif (image) {", " \t\tif (bpf_jit_enable > 1)", " \t\t\tprint_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,", " \t\t\t\t       16, 1, image, proglen, false);", " ", " \t\tbpf_flush_icache(image, image + proglen);", " ", " \t\tfp->bpf_func = (void *)image;", " \t}", " out:", " \tkfree(addrs);", " \treturn;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool FakePluginServiceFilter::IsPluginEnabled(int render_process_id,", "                                              int render_view_id,", "                                              const void* context,", "                                              const GURL& url,", "                                              const GURL& policy_url,", "                                              webkit::WebPluginInfo* plugin) {", " bool FakePluginServiceFilter::IsPluginAvailable(int render_process_id,", "                                                 int render_view_id,", "                                                 const void* context,", "                                                 const GURL& url,", "                                                 const GURL& policy_url,", "                                                 webkit::WebPluginInfo* plugin) {", "    std::map<FilePath, bool>::iterator it = plugin_state_.find(plugin->path);", "    if (it == plugin_state_.end()) {", "      ADD_FAILURE() << \"No plug-in state for '\" << plugin->path.value() << \"'\";", "     return false;", "   }", "   return it->second;", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bool AES_GCM_EncryptContext::Encrypt(", "const void *pPlaintextData, size_t cbPlaintextData,", "const void *pIV,", "void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,", "const void *pAdditionalAuthenticationData, size_t cbAuthenticationData", ") {", "unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;", "", "crypto_aead_aes256gcm_encrypt_afternm(", "static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,", "static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,", "static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,", "nullptr,", "static_cast<const unsigned char*>( pIV ),", "static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )", ");", "", "*pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;", "", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  av_cold void ff_mpv_idct_init(MpegEncContext *s)", "  {", "     if (s->codec_id == AV_CODEC_ID_MPEG4)", "         s->idsp.mpeg4_studio_profile = s->studio_profile;", "      ff_idctdsp_init(&s->idsp, s->avctx);", "  ", "       ", "     if (s->alternate_scan) {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);", "     } else {", "         ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);", "         ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);", "     }", "     ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);", "     ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void SocketStream::Connect() {", "   DCHECK(base::MessageLoop::current())", "        << \"The current base::MessageLoop must exist\";", "    DCHECK_EQ(base::MessageLoop::TYPE_IO, base::MessageLoop::current()->type())", "        << \"The current base::MessageLoop must be TYPE_IO\";", "  if (context_.get()) {", "   if (context_) {", "      context_->ssl_config_service()->GetSSLConfig(&server_ssl_config_);", "      proxy_ssl_config_ = server_ssl_config_;", "    }", "   CheckPrivacyMode();", " ", "   DCHECK_EQ(next_state_, STATE_NONE);", " ", "   AddRef();   ", "   next_state_ = STATE_BEFORE_CONNECT;", "   net_log_.BeginEvent(", "       NetLog::TYPE_SOCKET_STREAM_CONNECT,", "       NetLog::StringCallback(\"url\", &url_.possibly_invalid_spec()));", "   base::MessageLoop::current()->PostTask(", "       FROM_HERE, base::Bind(&SocketStream::DoLoop, this, OK));", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static QSvgNode *createPathNode(QSvgNode *parent,", "const QXmlStreamAttributes &attributes,", "QSvgHandler *)", "{", "QStringRef data      = attributes.value(QLatin1String(\"d\"));", "", "QPainterPath qpath;", "qpath.setFillRule(Qt::WindingFill);", "", "parsePathDataFast(data, qpath);", "", "QSvgNode *path = new QSvgPath(parent, qpath);", "return path;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,", " \t\tunsigned long address, unsigned int *flags, int *nonblocking)", " {", " \tunsigned int fault_flags = 0;", " \tint ret;", " ", " \t ", " \tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)", " \t\treturn -ENOENT;", " \t ", " \tif ((*flags & FOLL_POPULATE) &&", " \t\t\t(stack_guard_page_start(vma, address) ||", " \t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))", " \t\treturn -ENOENT;", " \tif (*flags & FOLL_WRITE)", " \t\tfault_flags |= FAULT_FLAG_WRITE;", " \tif (*flags & FOLL_REMOTE)", " \t\tfault_flags |= FAULT_FLAG_REMOTE;", " \tif (nonblocking)", " \t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;", " \tif (*flags & FOLL_NOWAIT)", " \t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;", " \tif (*flags & FOLL_TRIED) {", " \t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);", " \t\tfault_flags |= FAULT_FLAG_TRIED;", " \t}", " ", " \tret = handle_mm_fault(vma, address, fault_flags);", " \tif (ret & VM_FAULT_ERROR) {", " \t\tif (ret & VM_FAULT_OOM)", " \t\t\treturn -ENOMEM;", " \t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))", " \t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;", " \t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))", " \t\t\treturn -EFAULT;", " \t\tBUG();", " \t}", " ", " \tif (tsk) {", " \t\tif (ret & VM_FAULT_MAJOR)", " \t\t\ttsk->maj_flt++;", " \t\telse", " \t\t\ttsk->min_flt++;", " \t}", " ", " \tif (ret & VM_FAULT_RETRY) {", " \t\tif (nonblocking)", " \t\t\t*nonblocking = 0;", " \t\treturn -EBUSY;", " \t}", " ", " \t ", "  \tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))", "\t\t*flags &= ~FOLL_WRITE;", " \t        *flags |= FOLL_COW;", "  \treturn 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["  static char* getPreferredTag(const char* gf_tag)", "{ ", " {", "  \tchar* result = NULL;", "  \tint grOffset = 0;", "  ", " \tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);", " \tif(grOffset < 0) {", " \t\treturn NULL;", " \t}", " \tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){", " \t\t ", " \t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );", " \t} else {", " \t\t ", " \t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );", " \t}", " \treturn result;", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" COMPAT_SYSCALL_DEFINE5(waitid,", " \t\tint, which, compat_pid_t, pid,", " \t\tstruct compat_siginfo __user *, infop, int, options,", " \t\tstruct compat_rusage __user *, uru)", " {", " \tstruct rusage ru;", " \tstruct waitid_info info = {.status = 0};", " \tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);", " \tint signo = 0;", "  \tif (err > 0) {", "  \t\tsigno = SIGCHLD;", "  \t\terr = 0;", "\t}", "\tif (!err && uru) {", "\t\t ", "\t\tif (COMPAT_USE_64BIT_TIME)", "\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));", "\t\telse", "\t\t\terr = put_compat_rusage(&ru, uru);", "\t\tif (err)", "\t\t\treturn -EFAULT;", " \t\tif (uru) {", " \t\t\t ", " \t\t\tif (COMPAT_USE_64BIT_TIME)", " \t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));", " \t\t\telse", " \t\t\t\terr = put_compat_rusage(&ru, uru);", " \t\t\tif (err)", " \t\t\t\treturn -EFAULT;", " \t\t}", "  \t}", "  ", "  \tif (!infop)", " \t\treturn err;", " ", " \tuser_access_begin();", " \tunsafe_put_user(signo, &infop->si_signo, Efault);", " \tunsafe_put_user(0, &infop->si_errno, Efault);", " \tunsafe_put_user(info.cause, &infop->si_code, Efault);", " \tunsafe_put_user(info.pid, &infop->si_pid, Efault);", " \tunsafe_put_user(info.uid, &infop->si_uid, Efault);", " \tunsafe_put_user(info.status, &infop->si_status, Efault);", " \tuser_access_end();", " \treturn err;", " Efault:", " \tuser_access_end();", " \treturn -EFAULT;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void WebGL2RenderingContextBase::bindVertexArray(", "      WebGLVertexArrayObject* vertex_array) {", "  if (isContextLost())", "   bool deleted;", "   if (!CheckObjectToBeBound(\"bindVertexArray\", vertex_array, deleted))", "      return;", "  if (vertex_array &&", "      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {", "   if (deleted) {", "      SynthesizeGLError(GL_INVALID_OPERATION, \"bindVertexArray\",", "                      \"invalid vertexArray\");", "                       \"attempt to bind a deleted vertex array\");", "      return;", "    }", "  ", "   if (vertex_array && !vertex_array->IsDefaultObject() &&", "       vertex_array->Object()) {", "     ContextGL()->BindVertexArrayOES(ObjectOrZero(vertex_array));", " ", "     vertex_array->SetHasEverBeenBound();", "     SetBoundVertexArrayObject(vertex_array);", "   } else {", "     ContextGL()->BindVertexArrayOES(0);", "     SetBoundVertexArrayObject(nullptr);", "   }", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void WebContentsImpl::DidFailProvisionalLoadWithError(", "     RenderViewHost* render_view_host,", "     const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {", "   VLOG(1) << \"Failed Provisional Load: \" << params.url.possibly_invalid_spec()", "           << \", error_code: \" << params.error_code", "           << \", error_description: \" << params.error_description", "           << \", is_main_frame: \" << params.is_main_frame", "           << \", showing_repost_interstitial: \" <<", "             params.showing_repost_interstitial", "           << \", frame_id: \" << params.frame_id;", "   GURL validated_url(params.url);", "   RenderProcessHost* render_process_host =", "       render_view_host->GetProcess();", "   RenderViewHost::FilterURL(render_process_host, false, &validated_url);", " ", "   if (net::ERR_ABORTED == params.error_code) {", "     if (ShowingInterstitialPage()) {", "       LOG(WARNING) << \"Discarding message during interstitial.\";", "        return;", "      }", "  ", "      render_manager_.RendererAbortedProvisionalLoad(render_view_host);", "    }", "  ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "   if (controller_.GetPendingEntry() != controller_.GetVisibleEntry())", "     controller_.DiscardPendingEntry();", " ", "    FOR_EACH_OBSERVER(WebContentsObserver,", "                      observers_,", "                      DidFailProvisionalLoad(params.frame_id,", "                                            params.is_main_frame,", "                                            validated_url,", "                                            params.error_code,", "                                            params.error_description,", "                                            render_view_host));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static redisReply* oidc_cache_redis_command(request_rec *r,", "oidc_cache_cfg_redis_t *context, const char *command) {", "", "redisReply *reply = NULL;", "int i = 0;", "", "", "for (i = 0; i < OIDC_REDIS_MAX_TRIES; i++) {", "", "", "if (oidc_cache_redis_connect(r, context) != APR_SUCCESS)", "break;", "", "", "reply = redisCommand(context->ctx, command);", "", "", "if ((reply != NULL) && (reply->type != REDIS_REPLY_ERROR))", "", "break;", "", "", "oidc_error(r,", "\"Redis command (attempt=%d to %s:%d) failed, disconnecting: '%s' [%s]\",", "i, context->host_str, context->port, context->ctx->errstr,", "reply ? reply->str : \"<n/a>\");", "", "", "oidc_cache_redis_reply_free(&reply);", "", "", "oidc_cache_redis_free(context);", "}", "", "return reply;", "}"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": ["TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {", "auto* params =", "reinterpret_cast<TfLiteConcatenationParams*>(node->builtin_data);", "int axis = params->axis;", "int num_inputs = node->inputs->size;", "", "", "", "const TfLiteTensor* t0;", "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &t0));", "TfLiteType input_type = t0->type;", "if (axis < 0) axis += t0->dims->size;", "TF_LITE_ENSURE(context, axis >= 0);", "TF_LITE_ENSURE(context, axis < t0->dims->size);", "", "TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);", "TF_LITE_ENSURE(context,", "input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 ||", "input_type == kTfLiteInt8 || input_type == kTfLiteInt16 ||", "input_type == kTfLiteInt32 || input_type == kTfLiteInt64 ||", "input_type == kTfLiteBool);", "", "", "", "int sum_axis = t0->dims->data[axis];", "for (int i = 1; i < num_inputs; ++i) {", "const TfLiteTensor* t;", "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));", "TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);", "TF_LITE_ENSURE_EQ(context, t->type, input_type);", "for (int d = 0; d < t0->dims->size; ++d) {", "if (d == axis) {", "sum_axis += t->dims->data[axis];", "} else {", "TF_LITE_ENSURE_EQ(context, t->dims->data[d], t0->dims->data[d]);", "}", "}", "}", "", "TfLiteIntArray* output_size = TfLiteIntArrayCreate(t0->dims->size);", "for (int d = 0; d < t0->dims->size; ++d) {", "output_size->data[d] = (d == axis) ? sum_axis : t0->dims->data[d];", "}", "", "TfLiteTensor* output;", "TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));", "TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type);", "", "if (input_type == kTfLiteInt8) {", "", "", "VectorOfTensors<int8_t> all_inputs(*context, *node->inputs);", "for (int i = 0; i < node->inputs->size; ++i) {", "const TfLiteTensor* t;", "TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &t));", "TF_LITE_ENSURE_EQ(context, t->params.scale, output->params.scale);", "TF_LITE_ENSURE_EQ(context, t->params.zero_point,", "output->params.zero_point);", "}", "}", "", "if (input_type == kTfLiteInt16) {", "", "for (int i = 0; i < node->inputs->size; ++i) {", "const TfLiteTensor* t = GetInput(context, node, i);", "TF_LITE_ENSURE_EQ(context, t->params.zero_point, 0);", "}", "TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0);", "}", "", "return context->ResizeTensor(context, output, output_size);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" mp_join_print(netdissect_options *ndo,", "               const u_char *opt, u_int opt_len, u_char flags)", "  {", "          const struct mp_join *mpj = (const struct mp_join *) opt;", "  ", "        if (!(opt_len == 12 && flags & TH_SYN) &&", "         if (!(opt_len == 12 && (flags & TH_SYN)) &&", "              !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&", "            !(opt_len == 24 && flags & TH_ACK))", "             !(opt_len == 24 && (flags & TH_ACK)))", "                  return 0;", "  ", "          if (opt_len != 24) {", "                 if (mpj->sub_b & MP_JOIN_B)", "                         ND_PRINT((ndo, \" backup\"));", "                 ND_PRINT((ndo, \" id %u\", mpj->addr_id));", "         }", " ", "         switch (opt_len) {", "         case 12:  ", "                 ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",", "                         EXTRACT_32BITS(mpj->u.syn.token),", "                         EXTRACT_32BITS(mpj->u.syn.nonce)));", "                 break;", "         case 16:  ", "                 ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",", "                         EXTRACT_64BITS(mpj->u.synack.mac),", "                         EXTRACT_32BITS(mpj->u.synack.nonce)));", "                 break;", "         case 24: { ", "                 size_t i;", "                 ND_PRINT((ndo, \" hmac 0x\"));", "                 for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)", "                         ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));", "         }", "         default:", "                 break;", "         }", "          return 1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int n_tty_ioctl(struct tty_struct *tty, struct file *file,", " \t\t       unsigned int cmd, unsigned long arg)", " {", " \tstruct n_tty_data *ldata = tty->disc_data;", " \tint retval;", " ", " \tswitch (cmd) {", " \tcase TIOCOUTQ:", "  \t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);", "  \tcase TIOCINQ:", "  \t\tdown_write(&tty->termios_rwsem);", "\t\tif (L_ICANON(tty))", " \t\tif (L_ICANON(tty) && !L_EXTPROC(tty))", "  \t\t\tretval = inq_canon(ldata);", "  \t\telse", "  \t\t\tretval = read_cnt(ldata);", " \t\tup_write(&tty->termios_rwsem);", " \t\treturn put_user(retval, (unsigned int __user *) arg);", " \tdefault:", " \t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" DataPipeConsumerDispatcher::Deserialize(const void* data,", "                                         size_t num_bytes,", "                                         const ports::PortName* ports,", "                                         size_t num_ports,", "                                         PlatformHandle* handles,", "                                         size_t num_handles) {", "   if (num_ports != 1 || num_handles != 1 ||", "       num_bytes != sizeof(SerializedState)) {", "     return nullptr;", "   }", "  ", "    const SerializedState* state = static_cast<const SerializedState*>(data);", "    if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||", "      state->options.capacity_num_bytes < state->options.element_num_bytes) {", "       state->options.capacity_num_bytes < state->options.element_num_bytes ||", "       state->read_offset >= state->options.capacity_num_bytes ||", "       state->bytes_available > state->options.capacity_num_bytes) {", "      return nullptr;", "    }", "  ", "   NodeController* node_controller = Core::Get()->GetNodeController();", "   ports::PortRef port;", "   if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)", "     return nullptr;", " ", "   auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(", "       std::move(handles[0]), PlatformHandle());", "   auto region = base::subtle::PlatformSharedMemoryRegion::Take(", "       std::move(region_handle),", "       base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,", "       state->options.capacity_num_bytes,", "       base::UnguessableToken::Deserialize(state->buffer_guid_high,", "                                           state->buffer_guid_low));", "   auto ring_buffer =", "       base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));", "   if (!ring_buffer.IsValid()) {", "     DLOG(ERROR) << \"Failed to deserialize shared buffer handle.\";", "     return nullptr;", "   }", " ", "   scoped_refptr<DataPipeConsumerDispatcher> dispatcher =", "       new DataPipeConsumerDispatcher(node_controller, port,", "                                      std::move(ring_buffer), state->options,", "                                      state->pipe_id);", " ", "   {", "     base::AutoLock lock(dispatcher->lock_);", "     dispatcher->read_offset_ = state->read_offset;", "     dispatcher->bytes_available_ = state->bytes_available;", "     dispatcher->new_data_available_ = state->bytes_available > 0;", "      dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;", "      if (!dispatcher->InitializeNoLock())", "        return nullptr;", "     if (state->options.capacity_num_bytes >", "         dispatcher->ring_buffer_mapping_.mapped_size()) {", "       return nullptr;", "     }", "      dispatcher->UpdateSignalsStateNoLock();", "    }", "  ", "   return dispatcher;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  IW_IMPL(int) iw_get_i32le(const iw_byte *b)", "  {", "\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));", " \treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |", " \t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0]}
{"tokens": ["  void grubfs_free (GrubFS *gf) {", "  \tif (gf) {", "\t\tif (gf->file && gf->file->device)", " \t\tif (gf->file && gf->file->device) {", "  \t\t\tfree (gf->file->device->disk);", " \t\t}", "  \t\tfree (gf->file);", "  \t\tfree (gf);", " \t}", " }"], "ner_tags": [0, 0, 1, 1, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  int ParseCaffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)", "  {", "    uint32_t chan_chunk = 0, channel_layout = 0, bcount;", "     uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;", "      unsigned char *channel_identities = NULL;", "      unsigned char *channel_reorder = NULL;", "      int64_t total_samples = 0, infilesize;", "     CAFFileHeader caf_file_header;", "     CAFChunkHeader caf_chunk_header;", "     CAFAudioFormat caf_audio_format;", "     int i;", " ", "     infilesize = DoGetFileSize (infile);", "     memcpy (&caf_file_header, fourcc, 4);", " ", "     if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||", "         bcount != sizeof (CAFFileHeader) - 4)) {", "             error_line (\"%s is not a valid .CAF file!\", infilename);", "             return WAVPACK_SOFT_ERROR;", "     }", "     else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "         !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {", "             error_line (\"%s\", WavpackGetErrorMessage (wpc));", "             return WAVPACK_SOFT_ERROR;", "     }", " ", "     WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);", " ", "     if (caf_file_header.mFileVersion != 1) {", "         error_line (\"%s: can't handle version %d .CAF files!\", infilename, caf_file_header.mFileVersion);", "         return WAVPACK_SOFT_ERROR;", "     }", " ", " ", "     while (1) {", "         if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||", "             bcount != sizeof (CAFChunkHeader)) {", "                 error_line (\"%s is not a valid .CAF file!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "         }", "         else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "             !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {", "                 error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                 return WAVPACK_SOFT_ERROR;", "         }", " ", "         WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);", " ", " ", "         if (!strncmp (caf_chunk_header.mChunkType, \"desc\", 4)) {", "             int supported = TRUE;", " ", "             if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||", "                 !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||", "                 bcount != caf_chunk_header.mChunkSize) {", "                     error_line (\"%s is not a valid .CAF file!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "             }", "             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     return WAVPACK_SOFT_ERROR;", "              }", "  ", "              WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);", "             desc_chunk = 1;", "  ", "              if (debug_logging_mode) {", "                  char formatstr [5];", " ", "                 memcpy (formatstr, caf_audio_format.mFormatID, 4);", "                 formatstr [4] = 0;", "                 error_line (\"format = %s, flags = %x, sampling rate = %g\",", "                     formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);", "                 error_line (\"packet = %d bytes and %d frames\",", "                     caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);", "                 error_line (\"channels per frame = %d, bits per channel = %d\",", "                     caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);", "             }", " ", "             if (strncmp (caf_audio_format.mFormatID, \"lpcm\", 4) || (caf_audio_format.mFormatFlags & ~3))", "                 supported = FALSE;", "             else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||", "                 caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))", "                     supported = FALSE;", "             else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)", "                 supported = FALSE;", "             else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||", "                 ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))", "                     supported = FALSE;", "             else if (caf_audio_format.mFramesPerPacket != 1 ||", "                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||", "                 caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||", "                 caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)", "                     supported = FALSE;", " ", "             if (!supported) {", "                 error_line (\"%s is an unsupported .CAF format!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;", "             config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;", "             config->bits_per_sample = caf_audio_format.mBitsPerChannel;", "             config->num_channels = caf_audio_format.mChannelsPerFrame;", "             config->sample_rate = (int) caf_audio_format.mSampleRate;", " ", "             if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)", "                 config->qmode |= QMODE_BIG_ENDIAN;", " ", "             if (config->bytes_per_sample == 1)", "                 config->qmode |= QMODE_SIGNED_BYTES;", " ", "             if (debug_logging_mode) {", "                 if (config->float_norm_exp == 127)", "                     error_line (\"data format: 32-bit %s-endian floating point\", (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\");", "                 else", "                     error_line (\"data format: %d-bit %s-endian integers stored in %d byte(s)\",", "                         config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? \"big\" : \"little\", config->bytes_per_sample);", "             }", "         }", "         else if (!strncmp (caf_chunk_header.mChunkType, \"chan\", 4)) {", "             CAFChannelLayout *caf_channel_layout;", " ", "             if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||", "                 caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {", "                     error_line (\"this .CAF file has an invalid 'chan' chunk!\");", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             if (debug_logging_mode)", "                 error_line (\"'chan' chunk is %d bytes\", (int) caf_chunk_header.mChunkSize);", " ", "             caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);", " ", "             if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||", "                 bcount != caf_chunk_header.mChunkSize) {", "                     error_line (\"%s is not a valid .CAF file!\", infilename);", "                     free (caf_channel_layout);", "                     return WAVPACK_SOFT_ERROR;", "             }", "             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     free (caf_channel_layout);", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);", "             chan_chunk = 1;", " ", "             if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {", "                 error_line (\"this CAF file already has channel order information!\");", "                 free (caf_channel_layout);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             switch (caf_channel_layout->mChannelLayoutTag) {", "                 case kCAFChannelLayoutTag_UseChannelDescriptions:", "                     {", "                         CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);", "                         int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;", "                         int label, cindex = 0, idents = 0;", " ", "                         if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||", "                             num_descriptions != config->num_channels) {", "                                 error_line (\"channel descriptions in 'chan' chunk are the wrong size!\");", "                                 free (caf_channel_layout);", "                                 return WAVPACK_SOFT_ERROR;", "                         }", " ", "                         if (num_descriptions >= 256) {", "                             error_line (\"%d channel descriptions is more than we can handle...ignoring!\");", "                             break;", "                         }", " ", " ", "                         channel_reorder = malloc (num_descriptions);", "                         memset (channel_reorder, -1, num_descriptions);", "                         channel_identities = malloc (num_descriptions+1);", " ", " ", "                         for (i = 0; i < num_descriptions; ++i) {", "                             WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);", " ", "                             if (debug_logging_mode)", "                                 error_line (\"chan %d --> %d\", i + 1, descriptions [i].mChannelLabel);", "                         }", " ", " ", "                         for (label = 1; label <= 18; ++label)", "                             for (i = 0; i < num_descriptions; ++i)", "                                 if (descriptions [i].mChannelLabel == label) {", "                                     config->channel_mask |= 1 << (label - 1);", "                                     channel_reorder [i] = cindex++;", "                                     break;", "                                 }", " ", " ", "                         for (i = 0; i < num_descriptions; ++i)", "                             if (channel_reorder [i] == (unsigned char) -1) {", "                                 uint32_t clabel = descriptions [i].mChannelLabel;", " ", "                                 if (clabel == 0 || clabel == 0xffffffff || clabel == 100)", "                                     channel_identities [idents++] = 0xff;", "                                 else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))", "                                     channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;", "                                 else {", "                                     error_line (\"warning: unknown channel descriptions label: %d\", clabel);", "                                     channel_identities [idents++] = 0xff;", "                                 }", " ", "                                 channel_reorder [i] = cindex++;", "                             }", " ", " ", "                         for (i = 0; i < num_descriptions; ++i)", "                             if (channel_reorder [i] != i)", "                                 break;", " ", "                         if (i == num_descriptions) {", "                             free (channel_reorder);                  ", "                             channel_reorder = NULL;", "                         }", "                         else {", "                             config->qmode |= QMODE_REORDERED_CHANS;  ", "                             channel_layout = num_descriptions;", "                         }", " ", "                         if (!idents) {                               ", "                             free (channel_identities);", "                             channel_identities = NULL;", "                         }", "                         else", "                             channel_identities [idents] = 0;         ", " ", "                         if (debug_logging_mode) {", "                             error_line (\"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\",", "                                 caf_channel_layout->mChannelLayoutTag, config->channel_mask,", "                                 caf_channel_layout->mNumberChannelDescriptions, idents);", " ", " ", "                             if (channel_reorder && num_descriptions <= 8) {", "                                 char reorder_string [] = \"12345678\";", " ", "                                 for (i = 0; i < num_descriptions; ++i)", "                                     reorder_string [i] = channel_reorder [i] + '1';", " ", "                                 reorder_string [i] = 0;", "                                 error_line (\"reordering string = \\\"%s\\\"\\n\", reorder_string);", "                             }", "                         }", "                     }", " ", "                     break;", " ", "                 case kCAFChannelLayoutTag_UseChannelBitmap:", "                     config->channel_mask = caf_channel_layout->mChannelBitmap;", " ", "                     if (debug_logging_mode)", "                         error_line (\"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\",", "                             caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);", " ", "                     break;", " ", "                 default:", "                     for (i = 0; i < NUM_LAYOUTS; ++i)", "                         if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {", "                             config->channel_mask = layouts [i].mChannelBitmap;", "                             channel_layout = layouts [i].mChannelLayoutTag;", " ", "                             if (layouts [i].mChannelReorder) {", "                                 channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);", "                                 config->qmode |= QMODE_REORDERED_CHANS;", "                             }", " ", "                             if (layouts [i].mChannelIdentities)", "                                 channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);", " ", "                             if (debug_logging_mode)", "                                 error_line (\"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\",", "                                     channel_layout, config->channel_mask, channel_reorder ? \"yes\" : \"no\", channel_identities ? \"yes\" : \"no\");", " ", "                             break;", "                         }", " ", "                     if (i == NUM_LAYOUTS && debug_logging_mode)", "                         error_line (\"layout_tag 0x%08x not found in table...all channels unassigned\",", "                             caf_channel_layout->mChannelLayoutTag);", " ", "                     break;", "             }", " ", "             free (caf_channel_layout);", "         }", "          else if (!strncmp (caf_chunk_header.mChunkType, \"data\", 4)) {      ", "              uint32_t mEditCount;", "  ", "            if (!DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||", "             if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||", "                  bcount != sizeof (mEditCount)) {", "                      error_line (\"%s is not a valid .CAF file!\", infilename);", "                      return WAVPACK_SOFT_ERROR;", "             }", "             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {", "                 config->qmode |= QMODE_IGNORE_LENGTH;", " ", "                 if (infilesize && DoGetFilePosition (infile) != -1)", "                     total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;", "                 else", "                     total_samples = -1;", "             }", "             else {", "                 if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {", "                     error_line (\".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "                 }", " ", "                 if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {", "                     error_line (\".CAF file %s has an invalid data chunk size, probably is corrupt!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "                 }", " ", "                 total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;", " ", "                 if (!total_samples) {", "                     error_line (\"this .CAF file has no audio samples, probably is corrupt!\");", "                     return WAVPACK_SOFT_ERROR;", "                 }", " ", "                 if (total_samples > MAX_WAVPACK_SAMPLES) {", "                     error_line (\"%s has too many samples for WavPack!\", infilename);", "                     return WAVPACK_SOFT_ERROR;", "                 }", "             }", " ", "             break;", "         }", "         else {           ", " ", "             uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;", "             char *buff;", " ", "             if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {", "                 error_line (\"%s is not a valid .CAF file!\", infilename);", "                 return WAVPACK_SOFT_ERROR;", "             }", " ", "             buff = malloc (bytes_to_copy);", " ", "             if (debug_logging_mode)", "                 error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",", "                     caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],", "                     caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);", " ", "             if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||", "                 bcount != bytes_to_copy ||", "                 (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&", "                 !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {", "                     error_line (\"%s\", WavpackGetErrorMessage (wpc));", "                     free (buff);", "                     return WAVPACK_SOFT_ERROR;", "             }", " ", "             free (buff);", "         }", "     }", " ", "     if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))", "         config->channel_mask = 0x5 - config->num_channels;", " ", "     if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {", "         error_line (\"%s\", WavpackGetErrorMessage (wpc));", "         return WAVPACK_SOFT_ERROR;", "     }", " ", "     if (channel_identities)", "         free (channel_identities);", " ", "     if (channel_layout || channel_reorder) {", "         if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {", "             error_line (\"problem with setting channel layout (should not happen)\");", "             return WAVPACK_SOFT_ERROR;", "         }", " ", "         if (channel_reorder)", "             free (channel_reorder);", "     }", " ", "     return WAVPACK_NO_ERROR;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionRemoveEventListener(ExecState* exec)", " {", "     JSValue thisValue = exec->hostThisValue();", "     if (!thisValue.inherits(&JSTestEventTarget::s_info))", "         return throwVMTypeError(exec);", "     JSTestEventTarget* castedThis = jsCast<JSTestEventTarget*>(asObject(thisValue));", "      ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);", "      TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());", "      if (exec->argumentCount() < 2)", "        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));", "         return throwVMError(exec, createNotEnoughArgumentsError(exec));", "      JSValue listener = exec->argument(1);", "      if (!listener.isObject())", "          return JSValue::encode(jsUndefined());", "     impl->removeEventListener(ustringToAtomicString(exec->argument(0).toString(exec)->value(exec)), JSEventListener::create(asObject(listener), castedThis, false, currentWorld(exec)).get(), exec->argument(2).toBoolean(exec));", "     return JSValue::encode(jsUndefined());", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int perf_pmu_register(struct pmu *pmu, const char *name, int type)", " {", " \tint cpu, ret;", " ", " \tmutex_lock(&pmus_lock);", " \tret = -ENOMEM;", " \tpmu->pmu_disable_count = alloc_percpu(int);", " \tif (!pmu->pmu_disable_count)", " \t\tgoto unlock;", " ", " \tpmu->type = -1;", " \tif (!name)", " \t\tgoto skip_type;", " \tpmu->name = name;", " ", " \tif (type < 0) {", " \t\ttype = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);", " \t\tif (type < 0) {", " \t\t\tret = type;", " \t\t\tgoto free_pdc;", " \t\t}", " \t}", " \tpmu->type = type;", " ", " \tif (pmu_bus_running) {", " \t\tret = pmu_dev_alloc(pmu);", " \t\tif (ret)", " \t\t\tgoto free_idr;", " \t}", " ", " skip_type:", " \tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);", " \tif (pmu->pmu_cpu_context)", " \t\tgoto got_cpu_context;", " ", " \tret = -ENOMEM;", " \tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);", " \tif (!pmu->pmu_cpu_context)", " \t\tgoto free_dev;", " ", " \tfor_each_possible_cpu(cpu) {", " \t\tstruct perf_cpu_context *cpuctx;", " ", " \t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);", "  \t\t__perf_event_init_context(&cpuctx->ctx);", "  \t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);", "  \t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);", "\t\tcpuctx->ctx.type = cpu_context;", "  \t\tcpuctx->ctx.pmu = pmu;", "  ", "  \t\t__perf_cpu_hrtimer_init(cpuctx, cpu);", " ", " \t\tINIT_LIST_HEAD(&cpuctx->rotation_list);", " \t\tcpuctx->unique_pmu = pmu;", " \t}", " ", " got_cpu_context:", " \tif (!pmu->start_txn) {", " \t\tif (pmu->pmu_enable) {", " \t\t\t ", " \t\t\tpmu->start_txn  = perf_pmu_start_txn;", " \t\t\tpmu->commit_txn = perf_pmu_commit_txn;", " \t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;", " \t\t} else {", " \t\t\tpmu->start_txn  = perf_pmu_nop_void;", " \t\t\tpmu->commit_txn = perf_pmu_nop_int;", " \t\t\tpmu->cancel_txn = perf_pmu_nop_void;", " \t\t}", " \t}", " ", " \tif (!pmu->pmu_enable) {", " \t\tpmu->pmu_enable  = perf_pmu_nop_void;", " \t\tpmu->pmu_disable = perf_pmu_nop_void;", " \t}", " ", " \tif (!pmu->event_idx)", " \t\tpmu->event_idx = perf_event_idx_default;", " ", " \tlist_add_rcu(&pmu->entry, &pmus);", " \tret = 0;", " unlock:", " \tmutex_unlock(&pmus_lock);", " ", " \treturn ret;", " ", " free_dev:", " \tdevice_del(pmu->dev);", " \tput_device(pmu->dev);", " ", " free_idr:", " \tif (pmu->type >= PERF_TYPE_MAX)", " \t\tidr_remove(&pmu_idr, pmu->type);", " ", " free_pdc:", " \tfree_percpu(pmu->pmu_disable_count);", " \tgoto unlock;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void prefetch_table(const void *tab, size_t len)", "  {", "    const volatile byte *vtab = tab;", "    size_t i;", "  ", "  for (i = 0; i < len; i += 8 * 32)", "   for (i = 0; len - i >= 8 * 32; i += 8 * 32)", "      {", "        (void)vtab[i + 0 * 32];", "        (void)vtab[i + 1 * 32];", "       (void)vtab[i + 2 * 32];", "       (void)vtab[i + 3 * 32];", "       (void)vtab[i + 4 * 32];", "       (void)vtab[i + 5 * 32];", "        (void)vtab[i + 6 * 32];", "        (void)vtab[i + 7 * 32];", "      }", "   for (; i < len; i += 32)", "     {", "       (void)vtab[i];", "     }", "  ", "    (void)vtab[len - 1];", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" atol10(const char *p, size_t char_cnt)", " {", "  \tuint64_t l;", "  \tint digit;", "  ", " \tif (char_cnt == 0)", " \t\treturn (0);", " ", "  \tl = 0;", "  \tdigit = *p - '0';", "  \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {", " \t\tl = (l * 10) + digit;", " \t\tdigit = *++p - '0';", " \t}", " \treturn (l);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)", " {", " \tstruct sk_buff *clone;", " \tstruct net_device *dev = skb->dev;", " \tstruct frag_hdr *fhdr;", " \tstruct nf_ct_frag6_queue *fq;", " \tstruct ipv6hdr *hdr;", " \tint fhoff, nhoff;", " \tu8 prevhdr;", " \tstruct sk_buff *ret_skb = NULL;", " ", " \t ", " \tif (ipv6_hdr(skb)->payload_len == 0) {", " \t\tpr_debug(\"payload len = 0\\n\");", " \t\treturn skb;", " \t}", " ", " \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)", " \t\treturn skb;", " ", " \tclone = skb_clone(skb, GFP_ATOMIC);", " \tif (clone == NULL) {", " \t\tpr_debug(\"Can't clone skb\\n\");", " \t\treturn skb;", " \t}", " ", " \tNFCT_FRAG6_CB(clone)->orig = skb;", " ", " \tif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {", " \t\tpr_debug(\"message is too short.\\n\");", " \t\tgoto ret_orig;", " \t}", " ", " \tskb_set_transport_header(clone, fhoff);", "  \thdr = ipv6_hdr(clone);", "  \tfhdr = (struct frag_hdr *)skb_transport_header(clone);", "  ", "\tif (!(fhdr->frag_off & htons(0xFFF9))) {", "\t\tpr_debug(\"Invalid fragment offset\\n\");", "\t\t ", "\t\tgoto ret_orig;", "\t}", "  \tif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)", "  \t\tnf_ct_frag6_evictor();", "  ", " \tfq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr);", " \tif (fq == NULL) {", " \t\tpr_debug(\"Can't find and can't create new queue\\n\");", " \t\tgoto ret_orig;", " \t}", " ", " \tspin_lock_bh(&fq->q.lock);", " ", " \tif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {", " \t\tspin_unlock_bh(&fq->q.lock);", " \t\tpr_debug(\"Can't insert skb to queue\\n\");", " \t\tfq_put(fq);", " \t\tgoto ret_orig;", " \t}", " ", " \tif (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&", " \t    fq->q.meat == fq->q.len) {", " \t\tret_skb = nf_ct_frag6_reasm(fq, dev);", " \t\tif (ret_skb == NULL)", " \t\t\tpr_debug(\"Can't reassemble fragmented packets\\n\");", " \t}", " \tspin_unlock_bh(&fq->q.lock);", " ", " \tfq_put(fq);", " \treturn ret_skb;", " ", " ret_orig:", " \tkfree_skb(clone);", " \treturn skb;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Jp2Image::readMetadata()", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;", "#endif", "if (io_->open() != 0)", "{", "throw Error(kerDataSourceOpenFailed, io_->path(), strError());", "}", "IoCloser closer(*io_);", "", "if (!isJp2Type(*io_, true))", "{", "if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);", "throw Error(kerNotAnImage, \"JPEG-2000\");", "}", "", "long              position  = 0;", "Jp2BoxHeader      box       = {0,0};", "Jp2BoxHeader      subBox    = {0,0};", "Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};", "Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};", "", "while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))", "{", "position   = io_->tell();", "box.length = getLong((byte*)&box.length, bigEndian);", "box.type   = getLong((byte*)&box.type, bigEndian);", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: \"", "<< \"Position: \" << position", "<< \" box type: \" << toAscii(box.type)", "<< \" length: \" << box.length", "<< std::endl;", "#endif", "", "if (box.length == 0) return ;", "", "if (box.length == 1)", "{", "", "}", "", "switch(box.type)", "{", "case kJp2BoxTypeJp2Header:", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;", "#endif", "long restore = io_->tell();", "", "while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )", "{", "subBox.length = getLong((byte*)&subBox.length, bigEndian);", "subBox.type   = getLong((byte*)&subBox.type, bigEndian);", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: \"", "<< \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;", "#endif", "if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: \"", "<< \"Color data found\" << std::endl;", "#endif", "", "const long pad = 3 ;", "const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));", "", "if (data_length > io_->size() - io_->tell()) {", "throw Error(kerCorruptedMetadata);", "}", "DataBuf data(static_cast<long>(data_length));", "io_->read(data.pData_,data.size_);", "const long    iccLength = getULong(data.pData_+pad, bigEndian);", "", "", "if (iccLength > data.size_ - pad) {", "throw Error(kerCorruptedMetadata);", "}", "DataBuf icc(iccLength);", "::memcpy(icc.pData_,data.pData_+pad,icc.size_);", "#ifdef EXIV2_DEBUG_MESSAGES", "const char* iccPath = \"/tmp/libexiv2_jp2.icc\";", "FILE* f = fopen(iccPath,\"wb\");", "if ( f ) {", "fwrite(icc.pData_,icc.size_,1,f);", "fclose(f);", "}", "std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;", "#endif", "setIccProfile(icc);", "}", "", "if( subBox.type == kJp2BoxTypeImageHeader)", "{", "io_->read((byte*)&ihdr, sizeof(ihdr));", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;", "#endif", "ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);", "ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);", "ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);", "ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);", "", "pixelWidth_  = ihdr.imageWidth;", "pixelHeight_ = ihdr.imageHeight;", "}", "", "io_->seek(restore,BasicIo::beg);", "io_->seek(subBox.length, Exiv2::BasicIo::cur);", "restore = io_->tell();", "}", "break;", "}", "", "case kJp2BoxTypeUuid:", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;", "#endif", "", "if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))", "{", "DataBuf rawData;", "long    bufRead;", "bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;", "bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;", "bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;", "", "if(bIsExif)", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;", "#endif", "rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));", "bufRead = io_->read(rawData.pData_, rawData.size_);", "if (io_->error()) throw Error(kerFailedToReadImageData);", "if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);", "", "if (rawData.size_ > 0)", "{", "", "long pos = (     (rawData.pData_[0]      == rawData.pData_[1])", "&&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')", ")  ? 0 : -1;", "", "", "const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };", "for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)", "{", "if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)", "{", "pos = i+sizeof(exifHeader);", "#ifndef SUPPRESS_WARNINGS", "EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;", "#endif", "", "}", "}", "", "", "if (pos >= 0 )", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;", "#endif", "ByteOrder bo = TiffParser::decode(exifData(),", "iptcData(),", "xmpData(),", "rawData.pData_ + pos,", "rawData.size_ - pos);", "setByteOrder(bo);", "}", "}", "else", "{", "#ifndef SUPPRESS_WARNINGS", "EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;", "#endif", "exifData_.clear();", "}", "}", "", "if(bIsIPTC)", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;", "#endif", "rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));", "bufRead = io_->read(rawData.pData_, rawData.size_);", "if (io_->error()) throw Error(kerFailedToReadImageData);", "if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);", "", "if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))", "{", "#ifndef SUPPRESS_WARNINGS", "EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;", "#endif", "iptcData_.clear();", "}", "}", "", "if(bIsXMP)", "{", "#ifdef EXIV2_DEBUG_MESSAGES", "std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;", "#endif", "rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));", "bufRead = io_->read(rawData.pData_, rawData.size_);", "if (io_->error()) throw Error(kerFailedToReadImageData);", "if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);", "xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);", "", "std::string::size_type idx = xmpPacket_.find_first_of('<');", "if (idx != std::string::npos && idx > 0)", "{", "#ifndef SUPPRESS_WARNINGS", "EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)", "<< \" characters from the beginning of the XMP packet\" << std::endl;", "#endif", "xmpPacket_ = xmpPacket_.substr(idx);", "}", "", "if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))", "{", "#ifndef SUPPRESS_WARNINGS", "EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;", "#endif", "}", "}", "}", "break;", "}", "", "default:", "{", "break;", "}", "}", "", "", "io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);", "if (io_->error()) throw Error(kerFailedToReadImageData);", "}", "", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)", " codetype type;", " unsigned short FAR *lens;", " unsigned codes;", " code FAR * FAR *table;", " unsigned FAR *bits;", " unsigned short FAR *work;", " {", "     unsigned len;                ", "     unsigned sym;                ", "     unsigned min, max;           ", "     unsigned root;               ", "     unsigned curr;               ", "     unsigned drop;               ", "     int left;                    ", "     unsigned used;               ", "     unsigned huff;               ", "     unsigned incr;               ", "     unsigned fill;               ", "     unsigned low;                ", "     unsigned mask;               ", "     code here;                   ", "      code FAR *next;              ", "      const unsigned short FAR *base;      ", "      const unsigned short FAR *extra;     ", "    int end;                     ", "     unsigned match;              ", "      unsigned short count[MAXBITS+1];     ", "      unsigned short offs[MAXBITS+1];      ", "      static const unsigned short lbase[31] = {  ", "         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,", "         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};", "     static const unsigned short lext[31] = {  ", "         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,", "         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 198};", "     static const unsigned short dbase[32] = {  ", "         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,", "         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,", "         8193, 12289, 16385, 24577, 0, 0};", "     static const unsigned short dext[32] = {  ", "         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,", "         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,", "         28, 28, 29, 29, 64, 64};", " ", "      ", " ", "      ", "     for (len = 0; len <= MAXBITS; len++)", "         count[len] = 0;", "     for (sym = 0; sym < codes; sym++)", "         count[lens[sym]]++;", " ", "      ", "     root = *bits;", "     for (max = MAXBITS; max >= 1; max--)", "         if (count[max] != 0) break;", "     if (root > max) root = max;", "     if (max == 0) {                      ", "         here.op = (unsigned char)64;     ", "         here.bits = (unsigned char)1;", "         here.val = (unsigned short)0;", "         *(*table)++ = here;              ", "         *(*table)++ = here;", "         *bits = 1;", "         return 0;      ", "     }", "     for (min = 1; min < max; min++)", "         if (count[min] != 0) break;", "     if (root < min) root = min;", " ", "      ", "     left = 1;", "     for (len = 1; len <= MAXBITS; len++) {", "         left <<= 1;", "         left -= count[len];", "         if (left < 0) return -1;         ", "     }", "     if (left > 0 && (type == CODES || max != 1))", "         return -1;                       ", " ", "      ", "     offs[1] = 0;", "     for (len = 1; len < MAXBITS; len++)", "         offs[len + 1] = offs[len] + count[len];", " ", "      ", "     for (sym = 0; sym < codes; sym++)", "         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;", " ", "      ", " ", "      ", "      switch (type) {", "      case CODES:", "          base = extra = work;     ", "        end = 19;", "         match = 20;", "          break;", "      case LENS:", "          base = lbase;", "        base -= 257;", "          extra = lext;", "        extra -= 257;", "        end = 256;", "         match = 257;", "          break;", "      default:             ", "          base = dbase;", "          extra = dext;", "        end = -1;", "         match = 0;", "      }", "  ", "       ", "     huff = 0;                    ", "     sym = 0;                     ", "     len = min;                   ", "     next = *table;               ", "     curr = root;                 ", "     drop = 0;                    ", "     low = (unsigned)(-1);        ", "     used = 1U << root;           ", "     mask = used - 1;             ", " ", "      ", "     if ((type == LENS && used > ENOUGH_LENS) ||", "         (type == DISTS && used > ENOUGH_DISTS))", "         return 1;", " ", "      ", "      for (;;) {", "           ", "          here.bits = (unsigned char)(len - drop);", "        if ((int)(work[sym]) < end) {", "         if (work[sym] + 1 < match) {", "              here.op = (unsigned char)0;", "              here.val = work[sym];", "          }", "        else if ((int)(work[sym]) > end) {", "            here.op = (unsigned char)(extra[work[sym]]);", "            here.val = base[work[sym]];", "         else if (work[sym] >= match) {", "             here.op = (unsigned char)(extra[work[sym] - match]);", "             here.val = base[work[sym] - match];", "          }", "          else {", "              here.op = (unsigned char)(32 + 64);          ", "             here.val = 0;", "         }", " ", "          ", "         incr = 1U << (len - drop);", "         fill = 1U << curr;", "         min = fill;                  ", "         do {", "             fill -= incr;", "             next[(huff >> drop) + fill] = here;", "         } while (fill != 0);", " ", "          ", "         incr = 1U << (len - 1);", "         while (huff & incr)", "             incr >>= 1;", "         if (incr != 0) {", "             huff &= incr - 1;", "             huff += incr;", "         }", "         else", "             huff = 0;", " ", "          ", "         sym++;", "         if (--(count[len]) == 0) {", "             if (len == max) break;", "             len = lens[work[sym]];", "         }", " ", "          ", "         if (len > root && (huff & mask) != low) {", "              ", "             if (drop == 0)", "                 drop = root;", " ", "              ", "             next += min;             ", " ", "              ", "             curr = len - drop;", "             left = (int)(1 << curr);", "             while (curr + drop < max) {", "                 left -= count[curr + drop];", "                 if (left <= 0) break;", "                 curr++;", "                 left <<= 1;", "             }", " ", "              ", "             used += 1U << curr;", "             if ((type == LENS && used > ENOUGH_LENS) ||", "                 (type == DISTS && used > ENOUGH_DISTS))", "                 return 1;", " ", "              ", "             low = huff & mask;", "             (*table)[low].op = (unsigned char)curr;", "             (*table)[low].bits = (unsigned char)root;", "             (*table)[low].val = (unsigned short)(next - *table);", "         }", "     }", " ", "      ", "     if (huff != 0) {", "         here.op = (unsigned char)64;             ", "         here.bits = (unsigned char)(len - drop);", "         here.val = (unsigned short)0;", "         next[huff] = here;", "     }", " ", "      ", "     *table += used;", "     *bits = root;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void EC_GROUP_clear_free(EC_GROUP *group)", " \t{", " \tif (!group) return;", " ", " \tif (group->meth->group_clear_finish != 0)", " \t\tgroup->meth->group_clear_finish(group);", " \telse if (group->meth->group_finish != 0)", " \t\tgroup->meth->group_finish(group);", " ", " \tEC_EX_DATA_clear_free_all_data(&group->extra_data);", " ", " \tif (group->generator != NULL)", "  ", "         EC_EX_DATA_clear_free_all_data(&group->extra_data);", "  ", "        if (group->mont_data)", "                BN_MONT_CTX_free(group->mont_data);", " ", "         if (group->generator != NULL)", "                 EC_POINT_clear_free(group->generator);", "         BN_clear_free(&group->order);", " ", " \tOPENSSL_cleanse(group, sizeof *group);", " \tOPENSSL_free(group);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool check_allocations(ASS_Shaper *shaper, size_t new_size)", " {", "     if (new_size > shaper->n_glyphs) {", "         if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||", "             !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||", "              !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||", "              !ASS_REALLOC_ARRAY(shaper->cmap, new_size))", "              return false;", "         shaper->n_glyphs = new_size;", "      }", "      return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["jbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)", "{", "uint32_t w, h;", "uint32_t shift;", "uint32_t leftbyte;", "uint8_t *ss;", "uint8_t *dd;", "uint8_t leftmask, rightmask;", "int early = x >= 0;", "int late;", "uint32_t bytewidth;", "uint32_t syoffset = 0;", "", "if (src == NULL)", "return 0;", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w = src->width;", "h = src->height;", "shift = (x & 7);", "ss = src->data - early;", "", "if (x < 0) {", "if (w < (uint32_t) -x)", "w = 0;", "else", "w += x;", "ss += (-x-1)>>3;", "x = 0;", "}", "if (y < 0) {", "if (h < (uint32_t) -y)", "h = 0;", "else", "h += y;", "syoffset = -y * src->stride;", "y = 0;", "}", "if ((uint32_t)x + w > dst->width)", "{", "if (dst->width < (uint32_t)x)", "w = 0;", "else", "w = dst->width - x;", "}", "if ((uint32_t)y + h > dst->height)", "{", "if (dst->height < (uint32_t)y)", "h = 0;", "else", "h = dst->height - y;", "}", "#ifdef JBIG2_DEBUG", "jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);", "#endif", "", "", "if ((w <= 0) || (h <= 0)) {", "#ifdef JBIG2_DEBUG", "jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");", "#endif", "return 0;", "}", "", "leftbyte = (uint32_t) x >> 3;", "dd = dst->data + y * dst->stride + leftbyte;", "bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;", "leftmask = 255>>(x&7);", "rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));", "if (bytewidth == 1)", "leftmask &= rightmask;", "late = (ss + bytewidth >= src->data + ((src->width+7)>>3));", "ss += syoffset;", "", "switch(op)", "{", "case JBIG2_COMPOSE_OR:", "jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_AND:", "jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_XOR:", "jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_XNOR:", "jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "case JBIG2_COMPOSE_REPLACE:", "jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);", "break;", "}", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int32_t PPB_Flash_MessageLoop_Impl::InternalRun(", "     const RunFromHostProxyCallback& callback) {", "   if (state_->run_called()) {", "     if (!callback.is_null())", "       callback.Run(PP_ERROR_FAILED);", "     return PP_ERROR_FAILED;", "   }", "   state_->set_run_called();", "   state_->set_run_callback(callback);", " ", "   scoped_refptr<State> state_protector(state_);", "    {", "      base::MessageLoop::ScopedNestableTaskAllower allow(", "          base::MessageLoop::current());", "     blink::WebView::willEnterModalLoop();", " ", "      base::MessageLoop::current()->Run();", " ", "     blink::WebView::didExitModalLoop();", "    }", "  ", "   return state_protector->result();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" image_transform_png_set_expand_mod(PNG_CONST image_transform *this,", " image_transform_png_set_expand_mod(const image_transform *this,", "      image_pixel *that, png_const_structp pp,", "    PNG_CONST transform_display *display)", "     const transform_display *display)", "  {", "      ", "     if (that->colour_type == PNG_COLOR_TYPE_PALETTE)", "       image_pixel_convert_PLTE(that);", "  else if (that->bit_depth < 8)  ", " ", "        that->sample_depth = that->bit_depth = 8;", "  ", "     if (that->have_tRNS)", "      image_pixel_add_alpha(that, &display->this);", "       image_pixel_add_alpha(that, &display->this, 0 );", "  ", "     this->next->mod(this->next, that, pp, display);", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" HarfBuzzShaper::HarfBuzzShaper(const Font* font, const TextRun& run, const GlyphData* emphasisData,", "     HashSet<const SimpleFontData*>* fallbackFonts, FloatRect* bounds)", "     : Shaper(font, run, emphasisData, fallbackFonts, bounds)", "     , m_normalizedBufferLength(0)", "     , m_wordSpacingAdjustment(font->fontDescription().wordSpacing())", "     , m_letterSpacing(font->fontDescription().letterSpacing())", "      , m_expansionOpportunityCount(0)", "      , m_fromIndex(0)", "      , m_toIndex(m_run.length())", "     , m_totalWidth(0)", "  {", "      m_normalizedBuffer = adoptArrayPtr(new UChar[m_run.length() + 1]);", "      normalizeCharacters(m_run, m_run.length(), m_normalizedBuffer.get(), &m_normalizedBufferLength);", "     setExpansion(m_run.expansion());", "     setFontFeatures();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType GetMagickModulePath(const char *filename,", "   MagickModuleType module_type,char *path,ExceptionInfo *exception)", " {", "   char", "     *module_path;", " ", "   assert(filename != (const char *) NULL);", "   (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);", "    assert(path != (char *) NULL);", "    assert(exception != (ExceptionInfo *) NULL);", "    (void) CopyMagickString(path,filename,MaxTextExtent);", " #if defined(MAGICKCORE_INSTALLED_SUPPORT)", "   if (strstr(path,\"../\") != (char *) NULL)", "     {", "       errno=EPERM;", "       (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,", "         \"NotAuthorized\",\"`%s'\",path);", "       return(MagickFalse);", "     }", " #endif", "    module_path=(char *) NULL;", "    switch (module_type)", "    {", "     case MagickImageCoderModule:", "     default:", "     {", "       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),", "         \"Searching for coder module file \\\"%s\\\" ...\",filename);", "       module_path=GetEnvironmentValue(\"MAGICK_CODER_MODULE_PATH\");", " #if defined(MAGICKCORE_CODER_PATH)", "       if (module_path == (char *) NULL)", "         module_path=AcquireString(MAGICKCORE_CODER_PATH);", " #endif", "       break;", "     }", "     case MagickImageFilterModule:", "     {", "       (void) LogMagickEvent(ModuleEvent,GetMagickModule(),", "         \"Searching for filter module file \\\"%s\\\" ...\",filename);", "       module_path=GetEnvironmentValue(\"MAGICK_CODER_FILTER_PATH\");", " #if defined(MAGICKCORE_FILTER_PATH)", "       if (module_path == (char *) NULL)", "         module_path=AcquireString(MAGICKCORE_FILTER_PATH);", " #endif", "       break;", "     }", "   }", "   if (module_path != (char *) NULL)", "     {", "       register char", "         *p,", "         *q;", " ", "       for (p=module_path-1; p != (char *) NULL; )", "       {", "         (void) CopyMagickString(path,p+1,MaxTextExtent);", "         q=strchr(path,DirectoryListSeparator);", "         if (q != (char *) NULL)", "           *q='\\0';", "         q=path+strlen(path)-1;", "         if ((q >= path) && (*q != *DirectorySeparator))", "           (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);", "         (void) ConcatenateMagickString(path,filename,MaxTextExtent);", "         if (IsPathAccessible(path) != MagickFalse)", "           {", "             module_path=DestroyString(module_path);", "             return(MagickTrue);", "           }", "         p=strchr(p+1,DirectoryListSeparator);", "       }", "       module_path=DestroyString(module_path);", "     }", " #if defined(MAGICKCORE_INSTALLED_SUPPORT)", "   else", " #if defined(MAGICKCORE_CODER_PATH)", "     {", "       const char", "         *directory;", " ", "        ", "       switch (module_type)", "       {", "         case MagickImageCoderModule:", "         default:", "         {", "           directory=MAGICKCORE_CODER_PATH;", "           break;", "         }", "         case MagickImageFilterModule:", "         {", "           directory=MAGICKCORE_FILTER_PATH;", "           break;", "         }", "       }", "       (void) FormatLocaleString(path,MaxTextExtent,\"%s%s\",directory,filename);", "       if (IsPathAccessible(path) == MagickFalse)", "         {", "           ThrowFileException(exception,ConfigureWarning,", "             \"UnableToOpenModuleFile\",path);", "           return(MagickFalse);", "         }", "       return(MagickTrue);", "     }", " #else", " #if defined(MAGICKCORE_WINDOWS_SUPPORT)", "     {", "       const char", "         *registery_key;", " ", "       unsigned char", "         *key_value;", " ", "        ", "       switch (module_type)", "       {", "         case MagickImageCoderModule:", "         default:", "         {", "           registery_key=\"CoderModulesPath\";", "           break;", "         }", "         case MagickImageFilterModule:", "         {", "           registery_key=\"FilterModulesPath\";", "           break;", "         }", "       }", "       key_value=NTRegistryKeyLookup(registery_key);", "       if (key_value == (unsigned char *) NULL)", "         {", "           ThrowMagickException(exception,GetMagickModule(),ConfigureError,", "             \"RegistryKeyLookupFailed\",\"`%s'\",registery_key);", "           return(MagickFalse);", "         }", "       (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",(char *) key_value,", "         DirectorySeparator,filename);", "       key_value=(unsigned char *) RelinquishMagickMemory(key_value);", "       if (IsPathAccessible(path) == MagickFalse)", "         {", "           ThrowFileException(exception,ConfigureWarning,", "             \"UnableToOpenModuleFile\",path);", "           return(MagickFalse);", "         }", "       return(MagickTrue);", "     }", " #endif", " #endif", " #if !defined(MAGICKCORE_CODER_PATH) && !defined(MAGICKCORE_WINDOWS_SUPPORT)", " # error MAGICKCORE_CODER_PATH or MAGICKCORE_WINDOWS_SUPPORT must be defined when MAGICKCORE_INSTALLED_SUPPORT is defined", " #endif", " #else", "   {", "     char", "       *home;", " ", "     home=GetEnvironmentValue(\"MAGICK_HOME\");", "     if (home != (char *) NULL)", "       {", "          ", " #if !defined(MAGICKCORE_POSIX_SUPPORT)", "         (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",home,", "           DirectorySeparator,filename);", " #else", "         const char", "           *directory;", " ", "         switch (module_type)", "         {", "           case MagickImageCoderModule:", "           default:", "           {", "             directory=MAGICKCORE_CODER_RELATIVE_PATH;", "             break;", "           }", "           case MagickImageFilterModule:", "           {", "             directory=MAGICKCORE_FILTER_RELATIVE_PATH;", "             break;", "           }", "         }", "         (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s\",home,", "           directory,filename);", " #endif", "         home=DestroyString(home);", "         if (IsPathAccessible(path) != MagickFalse)", "           return(MagickTrue);", "       }", "   }", "   if (*GetClientPath() != '\\0')", "     {", "        ", " #if !defined(MAGICKCORE_POSIX_SUPPORT)", "       (void) FormatLocaleString(path,MaxTextExtent,\"%s%s%s\",GetClientPath(),", "         DirectorySeparator,filename);", " #else", "       char", "         prefix[MaxTextExtent];", " ", "       const char", "         *directory;", " ", "       switch (module_type)", "       {", "         case MagickImageCoderModule:", "         default:", "         {", "           directory=\"coders\";", "           break;", "         }", "         case MagickImageFilterModule:", "         {", "           directory=\"filters\";", "           break;", "         }", "       }", "       (void) CopyMagickString(prefix,GetClientPath(),MaxTextExtent);", "       ChopPathComponents(prefix,1);", "       (void) FormatLocaleString(path,MaxTextExtent,\"%s/lib/%s/%s/%s\",prefix,", "         MAGICKCORE_MODULES_RELATIVE_PATH,directory,filename);", " #endif", "       if (IsPathAccessible(path) != MagickFalse)", "         return(MagickTrue);", "     }", " #if defined(MAGICKCORE_WINDOWS_SUPPORT)", "   {", "      ", "     if ((NTGetModulePath(\"CORE_RL_magick_.dll\",path) != MagickFalse) ||", "         (NTGetModulePath(\"CORE_DB_magick_.dll\",path) != MagickFalse) ||", "         (NTGetModulePath(\"Magick.dll\",path) != MagickFalse))", "       {", "         (void) ConcatenateMagickString(path,DirectorySeparator,MaxTextExtent);", "         (void) ConcatenateMagickString(path,filename,MaxTextExtent);", "         if (IsPathAccessible(path) != MagickFalse)", "           return(MagickTrue);", "       }", "   }", " #endif", "   {", "     char", "       *home;", " ", "     home=GetEnvironmentValue(\"XDG_CONFIG_HOME\");", "     if (home == (char *) NULL)", "       home=GetEnvironmentValue(\"LOCALAPPDATA\");", "     if (home == (char *) NULL)", "       home=GetEnvironmentValue(\"APPDATA\");", "     if (home == (char *) NULL)", "       home=GetEnvironmentValue(\"USERPROFILE\");", "     if (home != (char *) NULL)", "       {", "          ", "         (void) FormatLocaleString(path,MaxTextExtent,\"%s%sImageMagick%s%s\",", "           home,DirectorySeparator,DirectorySeparator,filename);", "         home=DestroyString(home);", "         if (IsPathAccessible(path) != MagickFalse)", "           return(MagickTrue);", "       }", "     home=GetEnvironmentValue(\"HOME\");", "     if (home != (char *) NULL)", "       {", "          ", "         (void) FormatLocaleString(path,MaxTextExtent,", "           \"%s%s.config%sImageMagick%s%s\",home,DirectorySeparator,", "           DirectorySeparator,DirectorySeparator,filename);", "         if (IsPathAccessible(path) != MagickFalse)", "           {", "             home=DestroyString(home);", "             return(MagickTrue);", "           }", "          ", "         (void) FormatLocaleString(path,MaxTextExtent,\"%s%s.magick%s%s\",home,", "           DirectorySeparator,DirectorySeparator,filename);", "         home=DestroyString(home);", "         if (IsPathAccessible(path) != MagickFalse)", "           return(MagickTrue);", "       }", "   }", "    ", "   if (IsPathAccessible(path) != MagickFalse)", "     return(MagickTrue);", "   if (exception->severity < ConfigureError)", "     ThrowFileException(exception,ConfigureWarning,\"UnableToOpenModuleFile\",", "       path);", " #endif", "   return(MagickFalse);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst)", " void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len)", "  {", "      if (src == NULL || src_len == 0 || dst == NULL) {", "          return;", "  }", " ", "  const char32_t *cur_utf32 = src;", "  const char32_t *end_utf32 = src + src_len;", " ", "      char *cur = dst;", "      while (cur_utf32 < end_utf32) {", "          size_t len = utf32_codepoint_utf8_length(*cur_utf32);", "         LOG_ALWAYS_FATAL_IF(dst_len < len, \"%zu < %zu\", dst_len, len);", "          utf32_codepoint_to_utf8((uint8_t *)cur, *cur_utf32++, len);", "          cur += len;", "         dst_len -= len;", "      }", "     LOG_ALWAYS_FATAL_IF(dst_len < 1, \"dst_len < 1: %zu < 1\", dst_len);", "      *cur = '\\0';", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0]}
{"tokens": [" txid_current_snapshot(PG_FUNCTION_ARGS)", " {", " \tTxidSnapshot *snap;", " \tuint32\t\tnxip,", " \t\t\t\ti,", " \t\t\t\tsize;", " \tTxidEpoch\tstate;", " \tSnapshot\tcur;", " ", " \tcur = GetActiveSnapshot();", " \tif (cur == NULL)", " \t\telog(ERROR, \"no active snapshot set\");", "  ", "  \tload_xid_epoch(&state);", "  ", " \t ", " \tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,", " \t\t\t\t\t \"possible overflow in txid_current_snapshot()\");", " ", "  \t ", "  \tnxip = cur->xcnt;", "  \tsize = TXID_SNAPSHOT_SIZE(nxip);", " \tsnap = palloc(size);", " \tSET_VARSIZE(snap, size);", " ", " \t ", " \tsnap->xmin = convert_xid(cur->xmin, &state);", " \tsnap->xmax = convert_xid(cur->xmax, &state);", " \tsnap->nxip = nxip;", " \tfor (i = 0; i < nxip; i++)", " \t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);", " ", " \t ", " \tsort_snapshot(snap);", " ", " \tPG_RETURN_POINTER(snap);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static ssize_t read_mem(struct file *file, char __user *buf,", " \t\t\tsize_t count, loff_t *ppos)", " {", " \tphys_addr_t p = *ppos;", " \tssize_t read, sz;", " \tvoid *ptr;", " ", " \tif (p != *ppos)", " \t\treturn 0;", " ", " \tif (!valid_phys_addr_range(p, count))", " \t\treturn -EFAULT;", " \tread = 0;", " #ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED", " \t ", " \tif (p < PAGE_SIZE) {", " \t\tsz = size_inside_page(p, count);", " \t\tif (sz > 0) {", " \t\t\tif (clear_user(buf, sz))", " \t\t\t\treturn -EFAULT;", " \t\t\tbuf += sz;", " \t\t\tp += sz;", " \t\t\tcount -= sz;", " \t\t\tread += sz;", " \t\t}", " \t}", " #endif", "  ", "  \twhile (count > 0) {", "  \t\tunsigned long remaining;", " \t\tint allowed;", "  ", "  \t\tsz = size_inside_page(p, count);", "  ", "\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))", " \t\tallowed = page_is_allowed(p >> PAGE_SHIFT);", " \t\tif (!allowed)", "  \t\t\treturn -EPERM;", " \t\tif (allowed == 2) {", " \t\t\t ", " \t\t\tremaining = clear_user(buf, sz);", " \t\t} else {", " \t\t\t ", " \t\t\tptr = xlate_dev_mem_ptr(p);", " \t\t\tif (!ptr)", " \t\t\t\treturn -EFAULT;", "  ", "\t\t ", "\t\tptr = xlate_dev_mem_ptr(p);", "\t\tif (!ptr)", "\t\t\treturn -EFAULT;", " \t\t\tremaining = copy_to_user(buf, ptr, sz);", " ", " \t\t\tunxlate_dev_mem_ptr(p, ptr);", " \t\t}", "  ", "\t\tremaining = copy_to_user(buf, ptr, sz);", "\t\tunxlate_dev_mem_ptr(p, ptr);", "  \t\tif (remaining)", "  \t\t\treturn -EFAULT;", "  ", " \t\tbuf += sz;", " \t\tp += sz;", " \t\tcount -= sz;", " \t\tread += sz;", " \t}", " ", " \t*ppos += read;", " \treturn read;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,", "size_t mincodes, size_t numcodes, unsigned maxbitlen)", "{", "unsigned error = 0;", "while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--;", "tree->maxbitlen = maxbitlen;", "tree->numcodes = (unsigned)numcodes;", "tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));", "if(!tree->lengths) return 83;", "", "memset(tree->lengths, 0, numcodes * sizeof(unsigned));", "", "error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);", "if(!error) error = HuffmanTree_makeFromLengths2(tree);", "return error;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" DrawingBuffer::DrawingBuffer(", "     std::unique_ptr<WebGraphicsContext3DProvider> context_provider,", "     std::unique_ptr<Extensions3DUtil> extensions_util,", "     Client* client,", "     bool discard_framebuffer_supported,", "      bool want_alpha_channel,", "      bool premultiplied_alpha,", "      PreserveDrawingBuffer preserve,", "    WebGLVersion web_gl_version,", "     WebGLVersion webgl_version,", "      bool want_depth,", "      bool want_stencil,", "      ChromiumImageUsage chromium_image_usage,", "      const CanvasColorParams& color_params)", "      : client_(client),", "        preserve_drawing_buffer_(preserve),", "      web_gl_version_(web_gl_version),", "       webgl_version_(webgl_version),", "        context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(", "            std::move(context_provider)))),", "        gl_(this->ContextProvider()->ContextGL()),", "       extensions_util_(std::move(extensions_util)),", "       discard_framebuffer_supported_(discard_framebuffer_supported),", "       want_alpha_channel_(want_alpha_channel),", "       premultiplied_alpha_(premultiplied_alpha),", "       software_rendering_(this->ContextProvider()->IsSoftwareRendering()),", "       want_depth_(want_depth),", "       want_stencil_(want_stencil),", "       color_space_(color_params.GetGfxColorSpace()),", "       chromium_image_usage_(chromium_image_usage) {", "   TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",", "                        TRACE_EVENT_SCOPE_GLOBAL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" transform_name(int t)", "   ", " {", "  unsigned int i;", " ", "  ", "     t &= -t;  ", "  ", "   for (i=0; i<TTABLE_SIZE; ++i)", "    for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)", "     {", "        if ((transform_info[i].transform & t) != 0)", "           return transform_info[i].name;", "  }", " ", "  return \"invalid transform\";", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int phar_parse_zipfile(php_stream *fp, char *fname, int fname_len, char *alias, int alias_len, phar_archive_data** pphar, char **error)  ", " {", " \tphar_zip_dir_end locator;", " \tchar buf[sizeof(locator) + 65536];", " \tzend_long size;", " \tphp_uint16 i;", " \tphar_archive_data *mydata = NULL;", " \tphar_entry_info entry = {0};", " \tchar *p = buf, *ext, *actual_alias = NULL;", " \tchar *metadata = NULL;", " ", " \tsize = php_stream_tell(fp);", " ", " \tif (size > sizeof(locator) + 65536) {", " \t\t ", " \t\tsize = sizeof(locator) + 65536;", " \t\tif (FAILURE == php_stream_seek(fp, -size, SEEK_END)) {", " \t\t\tphp_stream_close(fp);", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 4096, \"phar error: unable to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);", " \t\t\t}", " \t\t\treturn FAILURE;", " \t\t}", " \t} else {", " \t\tphp_stream_seek(fp, 0, SEEK_SET);", " \t}", " ", " \tif (!php_stream_read(fp, buf, size)) {", " \t\tphp_stream_close(fp);", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: unable to read in data to search for end of central directory in zip-based phar \\\"%s\\\"\", fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \twhile ((p=(char *) memchr(p + 1, 'P', (size_t) (size - (p + 1 - buf)))) != NULL) {", " \t\tif ((p - buf) + sizeof(locator) <= size && !memcmp(p + 1, \"K\\5\\6\", 3)) {", " \t\t\tmemcpy((void *)&locator, (void *) p, sizeof(locator));", " \t\t\tif (PHAR_GET_16(locator.centraldisk) != 0 || PHAR_GET_16(locator.disknumber) != 0) {", " \t\t\t\t ", " \t\t\t\tphp_stream_close(fp);", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 4096, \"phar error: split archives spanning multiple zips cannot be processed in zip-based phar \\\"%s\\\"\", fname);", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tif (PHAR_GET_16(locator.counthere) != PHAR_GET_16(locator.count)) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, conflicting file count in end of central directory record in zip-based phar \\\"%s\\\"\", fname);", " \t\t\t\t}", " \t\t\t\tphp_stream_close(fp);", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tmydata = pecalloc(1, sizeof(phar_archive_data), PHAR_G(persist));", " \t\t\tmydata->is_persistent = PHAR_G(persist);", " ", " \t\t\t ", " \t\t\tif (PHAR_GET_16(locator.comment_len)) {", " ", " \t\t\t\tmetadata = p + sizeof(locator);", " ", " \t\t\t\tif (PHAR_GET_16(locator.comment_len) != size - (metadata - buf)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: corrupt zip archive, zip file comment truncated in zip-based phar \\\"%s\\\"\", fname);", " \t\t\t\t\t}", " \t\t\t\t\tphp_stream_close(fp);", " \t\t\t\t\tpefree(mydata, mydata->is_persistent);", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " ", " \t\t\t\tmydata->metadata_len = PHAR_GET_16(locator.comment_len);", " ", " \t\t\t\tif (phar_parse_metadata(&metadata, &mydata->metadata, PHAR_GET_16(locator.comment_len)) == FAILURE) {", " \t\t\t\t\tmydata->metadata_len = 0;", " \t\t\t\t\t ", " ", " \t\t\t\t\tZVAL_NEW_STR(&mydata->metadata, zend_string_init(metadata, PHAR_GET_16(locator.comment_len), mydata->is_persistent));", " \t\t\t\t}", " \t\t\t} else {", " \t\t\t\tZVAL_UNDEF(&mydata->metadata);", " \t\t\t}", " ", " \t\t\tgoto foundit;", " \t\t}", " \t}", " ", " \tphp_stream_close(fp);", " ", " \tif (error) {", " \t\tspprintf(error, 4096, \"phar error: end of central directory not found in zip-based phar \\\"%s\\\"\", fname);", " \t}", " ", " \treturn FAILURE;", " foundit:", " \tmydata->fname = pestrndup(fname, fname_len, mydata->is_persistent);", " #ifdef PHP_WIN32", " \tphar_unixify_path_separators(mydata->fname, fname_len);", " #endif", " \tmydata->is_zip = 1;", " \tmydata->fname_len = fname_len;", " \text = strrchr(mydata->fname, '/');", " ", " \tif (ext) {", " \t\tmydata->ext = memchr(ext, '.', (mydata->fname + fname_len) - ext);", " \t\tif (mydata->ext == ext) {", " \t\t\tmydata->ext = memchr(ext + 1, '.', (mydata->fname + fname_len) - ext - 1);", " \t\t}", " \t\tif (mydata->ext) {", " \t\t\tmydata->ext_len = (mydata->fname + fname_len) - mydata->ext;", " \t\t}", " \t}", " ", " \t ", " \t ", " \tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);", " \t ", " \tzend_hash_init(&mydata->manifest, PHAR_GET_16(locator.count),", " \t\tzend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)mydata->is_persistent);", " \tzend_hash_init(&mydata->mounted_dirs, 5,", " \t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);", " \tzend_hash_init(&mydata->virtual_dirs, PHAR_GET_16(locator.count) * 2,", " \t\tzend_get_hash_value, NULL, (zend_bool)mydata->is_persistent);", " \tentry.phar = mydata;", " \tentry.is_zip = 1;", " \tentry.fp_type = PHAR_FP;", " \tentry.is_persistent = mydata->is_persistent;", " #define PHAR_ZIP_FAIL_FREE(errmsg, save) \\", " \t\t\tzend_hash_destroy(&mydata->manifest); \\", " \t\t\tmydata->manifest.u.flags = 0; \\", " \t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\", " \t\t\tmydata->mounted_dirs.u.flags = 0; \\", " \t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\", " \t\t\tmydata->virtual_dirs.u.flags = 0; \\", " \t\t\tphp_stream_close(fp); \\", " \t\t\tzval_dtor(&mydata->metadata); \\", " \t\t\tif (mydata->signature) { \\", " \t\t\t\tefree(mydata->signature); \\", " \t\t\t} \\", " \t\t\tif (error) { \\", " \t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\", " \t\t\t} \\", " \t\t\tpefree(mydata->fname, mydata->is_persistent); \\", " \t\t\tif (mydata->alias) { \\", " \t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\", " \t\t\t} \\", " \t\t\tpefree(mydata, mydata->is_persistent); \\", " \t\t\tefree(save); \\", " \t\t\treturn FAILURE;", " #define PHAR_ZIP_FAIL(errmsg) \\", " \t\t\tzend_hash_destroy(&mydata->manifest); \\", " \t\t\tmydata->manifest.u.flags = 0; \\", " \t\t\tzend_hash_destroy(&mydata->mounted_dirs); \\", " \t\t\tmydata->mounted_dirs.u.flags = 0; \\", " \t\t\tzend_hash_destroy(&mydata->virtual_dirs); \\", " \t\t\tmydata->virtual_dirs.u.flags = 0; \\", " \t\t\tphp_stream_close(fp); \\", " \t\t\tzval_dtor(&mydata->metadata); \\", " \t\t\tif (mydata->signature) { \\", " \t\t\t\tefree(mydata->signature); \\", " \t\t\t} \\", " \t\t\tif (error) { \\", " \t\t\t\tspprintf(error, 4096, \"phar error: %s in zip-based phar \\\"%s\\\"\", errmsg, mydata->fname); \\", " \t\t\t} \\", " \t\t\tpefree(mydata->fname, mydata->is_persistent); \\", " \t\t\tif (mydata->alias) { \\", " \t\t\t\tpefree(mydata->alias, mydata->is_persistent); \\", " \t\t\t} \\", " \t\t\tpefree(mydata, mydata->is_persistent); \\", " \t\t\treturn FAILURE;", " ", " \t ", " \tfor (i = 0; i < PHAR_GET_16(locator.count); ++i) {", " \t\tphar_zip_central_dir_file zipentry;", " \t\tzend_off_t beforeus = php_stream_tell(fp);", " ", " \t\tif (sizeof(zipentry) != php_stream_read(fp, (char *) &zipentry, sizeof(zipentry))) {", " \t\t\tPHAR_ZIP_FAIL(\"unable to read central directory entry, truncated\");", " \t\t}", " ", " \t\t ", " \t\tif (memcmp(\"PK\\1\\2\", zipentry.signature, 4)) {", " \t\t\t ", " \t\t\tPHAR_ZIP_FAIL(\"corrupted central directory entry, no magic signature\");", " \t\t}", " ", " \t\tif (entry.is_persistent) {", " \t\t\tentry.manifest_pos = i;", " \t\t}", " ", " \t\tentry.compressed_filesize = PHAR_GET_32(zipentry.compsize);", " \t\tentry.uncompressed_filesize = PHAR_GET_32(zipentry.uncompsize);", " \t\tentry.crc32 = PHAR_GET_32(zipentry.crc32);", " \t\t ", " \t\tentry.timestamp = phar_zip_d2u_time(zipentry.timestamp, zipentry.datestamp);", " \t\tentry.flags = PHAR_ENT_PERM_DEF_FILE;", " \t\tentry.header_offset = PHAR_GET_32(zipentry.offset);", " \t\tentry.offset = entry.offset_abs = PHAR_GET_32(zipentry.offset) + sizeof(phar_zip_file_header) + PHAR_GET_16(zipentry.filename_len) +", " \t\t\tPHAR_GET_16(zipentry.extra_len);", " ", " \t\tif (PHAR_GET_16(zipentry.flags) & PHAR_ZIP_FLAG_ENCRYPTED) {", " \t\t\tPHAR_ZIP_FAIL(\"Cannot process encrypted zip files\");", " \t\t}", " ", " \t\tif (!PHAR_GET_16(zipentry.filename_len)) {", " \t\t\tPHAR_ZIP_FAIL(\"Cannot process zips created from stdin (zero-length filename)\");", " \t\t}", " ", " \t\tentry.filename_len = PHAR_GET_16(zipentry.filename_len);", " \t\tentry.filename = (char *) pemalloc(entry.filename_len + 1, entry.is_persistent);", " ", " \t\tif (entry.filename_len != php_stream_read(fp, entry.filename, entry.filename_len)) {", " \t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\tPHAR_ZIP_FAIL(\"unable to read in filename from central directory, truncated\");", " \t\t}", " ", " \t\tentry.filename[entry.filename_len] = '\\0';", " ", " \t\tif (entry.filename[entry.filename_len - 1] == '/') {", " \t\t\tentry.is_dir = 1;", " \t\t\tif(entry.filename_len > 1) {", " \t\t\t\tentry.filename_len--;", " \t\t\t}", " \t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;", " \t\t} else {", " \t\t\tentry.is_dir = 0;", " \t\t}", " ", " \t\tif (entry.filename_len == sizeof(\".phar/signature.bin\")-1 && !strncmp(entry.filename, \".phar/signature.bin\", sizeof(\".phar/signature.bin\")-1)) {", " \t\t\tsize_t read;", " \t\t\tphp_stream *sigfile;", " \t\t\tzend_off_t now;", " \t\t\tchar *sig;", " ", " \t\t\tnow = php_stream_tell(fp);", " \t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\tsigfile = php_stream_fopen_tmpfile();", " \t\t\tif (!sigfile) {", " \t\t\t\tPHAR_ZIP_FAIL(\"couldn't open temporary file\");", " \t\t\t}", " ", " \t\t\tphp_stream_seek(fp, 0, SEEK_SET);", " \t\t\t ", " \t\t\tphp_stream_copy_to_stream_ex(fp, sigfile, entry.header_offset, NULL);", " \t\t\t ", " \t\t\tphp_stream_seek(fp, PHAR_GET_32(locator.cdir_offset), SEEK_SET);", " \t\t\t ", " \t\t\tphp_stream_copy_to_stream_ex(fp, sigfile, beforeus - PHAR_GET_32(locator.cdir_offset), NULL);", " \t\t\tif (metadata) {", " \t\t\t\tphp_stream_write(sigfile, metadata, PHAR_GET_16(locator.comment_len));", " \t\t\t}", "  \t\t\tphp_stream_seek(fp, sizeof(phar_zip_file_header) + entry.header_offset + entry.filename_len + PHAR_GET_16(zipentry.extra_len), SEEK_SET);", "  \t\t\tsig = (char *) emalloc(entry.uncompressed_filesize);", "  \t\t\tread = php_stream_read(fp, sig, entry.uncompressed_filesize);", "\t\t\tif (read != entry.uncompressed_filesize) {", " \t\t\tif (read != entry.uncompressed_filesize || read <= 8) {", "  \t\t\t\tphp_stream_close(sigfile);", "  \t\t\t\tefree(sig);", "  \t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be read\");", " \t\t\t}", " \t\t\tmydata->sig_flags = PHAR_GET_32(sig);", " \t\t\tif (FAILURE == phar_verify_signature(sigfile, php_stream_tell(sigfile), mydata->sig_flags, sig + 8, entry.uncompressed_filesize - 8, fname, &mydata->signature, &mydata->sig_len, error)) {", " \t\t\t\tefree(sig);", " \t\t\t\tif (error) {", " \t\t\t\t\tchar *save;", " \t\t\t\t\tphp_stream_close(sigfile);", " \t\t\t\t\tspprintf(&save, 4096, \"signature cannot be verified: %s\", *error);", " \t\t\t\t\tefree(*error);", " \t\t\t\t\tPHAR_ZIP_FAIL_FREE(save, save);", " \t\t\t\t} else {", " \t\t\t\t\tphp_stream_close(sigfile);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"signature cannot be verified\");", " \t\t\t\t}", " \t\t\t}", " \t\t\tphp_stream_close(sigfile);", " \t\t\tefree(sig);", " \t\t\t ", " \t\t\tif (i != PHAR_GET_16(locator.count) - 1) {", " \t\t\t\tPHAR_ZIP_FAIL(\"entries exist after signature, invalid phar\");", " \t\t\t}", " ", " \t\t\tcontinue;", " \t\t}", " ", " \t\tphar_add_virtual_dirs(mydata, entry.filename, entry.filename_len);", " ", " \t\tif (PHAR_GET_16(zipentry.extra_len)) {", " \t\t\tzend_off_t loc = php_stream_tell(fp);", " \t\t\tif (FAILURE == phar_zip_process_extra(fp, &entry, PHAR_GET_16(zipentry.extra_len))) {", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"Unable to process extra field header for file in central directory\");", " \t\t\t}", " \t\t\tphp_stream_seek(fp, loc + PHAR_GET_16(zipentry.extra_len), SEEK_SET);", " \t\t}", " ", " \t\tswitch (PHAR_GET_16(zipentry.compressed)) {", " \t\t\tcase PHAR_ZIP_COMP_NONE :", " \t\t\t\t ", " \t\t\t\tbreak;", " \t\t\tcase PHAR_ZIP_COMP_DEFLATE :", " \t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_GZ;", " \t\t\t\tif (!PHAR_G(has_zlib)) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"zlib extension is required\");", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase PHAR_ZIP_COMP_BZIP2 :", " \t\t\t\tentry.flags |= PHAR_ENT_COMPRESSED_BZ2;", " \t\t\t\tif (!PHAR_G(has_bz2)) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"bzip2 extension is required\");", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase 1 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Shrunk) used in this zip\");", " \t\t\tcase 2 :", " \t\t\tcase 3 :", " \t\t\tcase 4 :", " \t\t\tcase 5 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Reduce) used in this zip\");", " \t\t\tcase 6 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Implode) used in this zip\");", " \t\t\tcase 7 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Tokenize) used in this zip\");", " \t\t\tcase 9 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (Deflate64) used in this zip\");", " \t\t\tcase 10 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PKWare Implode/old IBM TERSE) used in this zip\");", " \t\t\tcase 14 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (LZMA) used in this zip\");", " \t\t\tcase 18 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM TERSE) used in this zip\");", " \t\t\tcase 19 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (IBM LZ77) used in this zip\");", " \t\t\tcase 97 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (WavPack) used in this zip\");", " \t\t\tcase 98 :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (PPMd) used in this zip\");", " \t\t\tdefault :", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unsupported compression method (unknown) used in this zip\");", " \t\t}", " ", " \t\t ", " \t\tif (PHAR_GET_16(zipentry.comment_len)) {", " \t\t\tif (PHAR_GET_16(zipentry.comment_len) != php_stream_read(fp, buf, PHAR_GET_16(zipentry.comment_len))) {", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"unable to read in file comment, truncated\");", " \t\t\t}", " ", " \t\t\tp = buf;", " \t\t\tentry.metadata_len = PHAR_GET_16(zipentry.comment_len);", " ", " \t\t\tif (phar_parse_metadata(&p, &(entry.metadata), PHAR_GET_16(zipentry.comment_len)) == FAILURE) {", " \t\t\t\tentry.metadata_len = 0;", " \t\t\t\t ", " ", " \t\t\t\tZVAL_NEW_STR(&entry.metadata, zend_string_init(buf, PHAR_GET_16(zipentry.comment_len), entry.is_persistent));", " \t\t\t}", " \t\t} else {", " \t\t\tZVAL_UNDEF(&entry.metadata);", " \t\t}", " ", " \t\tif (!actual_alias && entry.filename_len == sizeof(\".phar/alias.txt\")-1 && !strncmp(entry.filename, \".phar/alias.txt\", sizeof(\".phar/alias.txt\")-1)) {", " \t\t\tphp_stream_filter *filter;", " \t\t\tzend_off_t saveloc;", " \t\t\t ", " \t\t\tphar_zip_file_header local;", " ", " \t\t\t ", " \t\t\tsaveloc = php_stream_tell(fp);", " \t\t\tphp_stream_seek(fp, PHAR_GET_32(zipentry.offset), SEEK_SET);", " ", " \t\t\tif (sizeof(local) != php_stream_read(fp, (char *) &local, sizeof(local))) {", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (cannot read local file header for alias)\");", " \t\t\t}", " ", " \t\t\t ", " \t\t\tif (entry.filename_len != PHAR_GET_16(local.filename_len) || entry.crc32 != PHAR_GET_32(local.crc32) || entry.uncompressed_filesize != PHAR_GET_32(local.uncompsize) || entry.compressed_filesize != PHAR_GET_32(local.compsize)) {", " \t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\tPHAR_ZIP_FAIL(\"phar error: internal corruption of zip-based phar (local header of alias does not match central directory)\");", " \t\t\t}", " ", " \t\t\t ", " \t\t\tentry.offset = entry.offset_abs =", " \t\t\t\tsizeof(local) + entry.header_offset + PHAR_GET_16(local.filename_len) + PHAR_GET_16(local.extra_len);", " \t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);", " \t\t\t ", " \t\t\tfp->writepos = 0;", " \t\t\tfp->readpos = 0;", " \t\t\tphp_stream_seek(fp, entry.offset, SEEK_SET);", " \t\t\tfp->writepos = 0;", " \t\t\tfp->readpos = 0;", " \t\t\t ", " ", " \t\t\tmydata->alias_len = entry.uncompressed_filesize;", " \t\t\tif (entry.flags & PHAR_ENT_COMPRESSED_GZ) {", " \t\t\t\tfilter = php_stream_filter_create(\"zlib.inflate\", NULL, php_stream_is_persistent(fp));", " ", " \t\t\t\tif (!filter) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"unable to decompress alias, zlib filter creation failed\");", " \t\t\t\t}", " ", " \t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);", " ", " \t\t\t\t{", " \t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);", " \t\t\t\t\tif (str) {", " \t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);", " \t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));", " \t\t\t\t\t\tzend_string_release(str);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tactual_alias = NULL;", " \t\t\t\t\t\tentry.uncompressed_filesize = 0;", " \t\t\t\t\t}", " \t\t\t\t}", " ", " \t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");", " \t\t\t\t}", " ", " \t\t\t\tphp_stream_filter_flush(filter, 1);", " \t\t\t\tphp_stream_filter_remove(filter, 1);", " ", " \t\t\t} else if (entry.flags & PHAR_ENT_COMPRESSED_BZ2) {", " \t\t\t\tfilter = php_stream_filter_create(\"bzip2.decompress\", NULL, php_stream_is_persistent(fp));", " ", " \t\t\t\tif (!filter) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, bzip2 filter creation failed\");", " \t\t\t\t}", " ", " \t\t\t\tphp_stream_filter_append(&fp->readfilters, filter);", " ", " \t\t\t\t{", " \t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);", " \t\t\t\t\tif (str) {", " \t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);", " \t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));", " \t\t\t\t\t\tzend_string_release(str);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tactual_alias = NULL;", " \t\t\t\t\t\tentry.uncompressed_filesize = 0;", " \t\t\t\t\t}", " \t\t\t\t}", " ", " \t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");", " \t\t\t\t}", " ", " \t\t\t\tphp_stream_filter_flush(filter, 1);", " \t\t\t\tphp_stream_filter_remove(filter, 1);", " \t\t\t} else {", " \t\t\t\t{", " \t\t\t\t\tzend_string *str = php_stream_copy_to_mem(fp, entry.uncompressed_filesize, 0);", " \t\t\t\t\tif (str) {", " \t\t\t\t\t\tentry.uncompressed_filesize = ZSTR_LEN(str);", " \t\t\t\t\t\tactual_alias = estrndup(ZSTR_VAL(str), ZSTR_LEN(str));", " \t\t\t\t\t\tzend_string_release(str);", " \t\t\t\t\t} else {", " \t\t\t\t\t\tactual_alias = NULL;", " \t\t\t\t\t\tentry.uncompressed_filesize = 0;", " \t\t\t\t\t}", " \t\t\t\t}", " ", " \t\t\t\tif (!entry.uncompressed_filesize || !actual_alias) {", " \t\t\t\t\tpefree(entry.filename, entry.is_persistent);", " \t\t\t\t\tPHAR_ZIP_FAIL(\"unable to read in alias, truncated\");", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\t ", " \t\t\tphp_stream_seek(fp, saveloc, SEEK_SET);", " \t\t}", " ", " \t\tphar_set_inode(&entry);", " \t\tzend_hash_str_add_mem(&mydata->manifest, entry.filename, entry.filename_len, (void *)&entry, sizeof(phar_entry_info));", " \t}", " ", " \tmydata->fp = fp;", " ", " \tif (zend_hash_str_exists(&(mydata->manifest), \".phar/stub.php\", sizeof(\".phar/stub.php\")-1)) {", " \t\tmydata->is_data = 0;", " \t} else {", " \t\tmydata->is_data = 1;", " \t}", " ", " \tzend_hash_str_add_ptr(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len, mydata);", " ", " \tif (actual_alias) {", " \t\tphar_archive_data *fd_ptr;", " ", " \t\tif (!phar_validate_alias(actual_alias, mydata->alias_len)) {", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 4096, \"phar error: invalid alias \\\"%s\\\" in zip-based phar \\\"%s\\\"\", actual_alias, fname);", " \t\t\t}", " \t\t\tefree(actual_alias);", " \t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);", " \t\t\treturn FAILURE;", " \t\t}", " ", " \t\tmydata->is_temporary_alias = 0;", " ", " \t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len))) {", " \t\t\tif (SUCCESS != phar_free_alias(fd_ptr, actual_alias, mydata->alias_len)) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with implicit alias, alias is already in use\", fname);", " \t\t\t\t}", " \t\t\t\tefree(actual_alias);", " \t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);", " \t\t\t\treturn FAILURE;", " \t\t\t}", " \t\t}", " ", " \t\tmydata->alias = entry.is_persistent ? pestrndup(actual_alias, mydata->alias_len, 1) : actual_alias;", " ", " \t\tif (entry.is_persistent) {", " \t\t\tefree(actual_alias);", " \t\t}", " ", " \t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);", " \t} else {", " \t\tphar_archive_data *fd_ptr;", " ", " \t\tif (alias_len) {", " \t\t\tif (NULL != (fd_ptr = zend_hash_str_find_ptr(&(PHAR_G(phar_alias_map)), alias, alias_len))) {", " \t\t\t\tif (SUCCESS != phar_free_alias(fd_ptr, alias, alias_len)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: Unable to add zip-based phar \\\"%s\\\" with explicit alias, alias is already in use\", fname);", " \t\t\t\t\t}", " \t\t\t\t\tzend_hash_str_del(&(PHAR_G(phar_fname_map)), mydata->fname, fname_len);", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tzend_hash_str_add_ptr(&(PHAR_G(phar_alias_map)), actual_alias, mydata->alias_len, mydata);", " \t\t\tmydata->alias = pestrndup(alias, alias_len, mydata->is_persistent);", " \t\t\tmydata->alias_len = alias_len;", " \t\t} else {", " \t\t\tmydata->alias = pestrndup(mydata->fname, fname_len, mydata->is_persistent);", " \t\t\tmydata->alias_len = fname_len;", " \t\t}", " ", " \t\tmydata->is_temporary_alias = 1;", " \t}", " ", " \tif (pphar) {", " \t\t*pphar = mydata;", " \t}", " ", " \treturn SUCCESS;", " }", "  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)", " ", "  {", "      stream_t *ps_stream = (stream_t *)pv_ctxt;", "  ", "    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)", " ", "     if (ps_stream->u4_offset < ps_stream->u4_max_offset)", "     {", "         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)", "     }", "      return;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" horizontalDifferenceF(float *ip, int n, int stride, uint16 *wp, uint16 *FromLT2)", " {", "     int32 r1, g1, b1, a1, r2, g2, b2, a2, mask;", "     float fltsize = Fltsize;", " ", " #define  CLAMP(v) ( (v<(float)0.)   ? 0\t\t\t\t\\", " \t\t  : (v<(float)2.)   ? FromLT2[(int)(v*fltsize)]\t\\", " \t\t  : (v>(float)24.2) ? 2047\t\t\t\\", " \t\t  : LogK1*log(v*LogK2) + 0.5 )", " ", "     mask = CODE_MASK;", "     if (n >= stride) {", " \tif (stride == 3) {", " \t    r2 = wp[0] = (uint16) CLAMP(ip[0]);", " \t    g2 = wp[1] = (uint16) CLAMP(ip[1]);", " \t    b2 = wp[2] = (uint16) CLAMP(ip[2]);", " \t    n -= 3;", " \t    while (n > 0) {", " \t\tn -= 3;", " \t\twp += 3;", " \t\tip += 3;", " \t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;", " \t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;", " \t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;", " \t    }", " \t} else if (stride == 4) {", " \t    r2 = wp[0] = (uint16) CLAMP(ip[0]);", " \t    g2 = wp[1] = (uint16) CLAMP(ip[1]);", " \t    b2 = wp[2] = (uint16) CLAMP(ip[2]);", " \t    a2 = wp[3] = (uint16) CLAMP(ip[3]);", " \t    n -= 4;", " \t    while (n > 0) {", " \t\tn -= 4;", " \t\twp += 4;", " \t\tip += 4;", " \t\tr1 = (int32) CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;", " \t\tg1 = (int32) CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;", " \t\tb1 = (int32) CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;", "  \t\ta1 = (int32) CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;", "  \t    }", "  \t} else {", "\t    ip += n - 1;\t ", "\t    wp += n - 1;\t ", "\t    n -= stride;", "\t    while (n > 0) {", "\t\tREPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]);", "\t\t\t\twp[stride] -= wp[0];", "\t\t\t\twp[stride] &= mask;", "\t\t\t\twp--; ip--)", "\t\tn -= stride;", "\t    }", "\t    REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp--; ip--)", "         REPEAT(stride, wp[0] = (uint16) CLAMP(ip[0]); wp++; ip++)", "         n -= stride;", "         while (n > 0) {", "             REPEAT(stride,", "                 wp[0] = (uint16)(((int32)CLAMP(ip[0])-(int32)CLAMP(ip[-stride])) & mask);", "                 wp++; ip++)", "             n -= stride;", "         }", "  \t}", "      }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" static bool freelist_state_initialize(union freelist_init_state *state,", " \t\t\t\tstruct kmem_cache *cachep,", " \t\t\t\tunsigned int count)", " {", " \tbool ret;", " \tunsigned int rand;", " ", " \t ", " \trand = get_random_int();", " ", " \t ", " \tif (!cachep->random_seq) {", " \t\tprandom_seed_state(&state->rnd_state, rand);", " \t\tret = false;", "  \t} else {", "  \t\tstate->list = cachep->random_seq;", "  \t\tstate->count = count;", "\t\tstate->pos = 0;", "\t\tstate->rand = rand;", " \t\tstate->pos = rand % count;", "  \t\tret = true;", "  \t}", "  \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" void InitializePrinting(content::WebContents* web_contents) {", " #if BUILDFLAG(ENABLE_PRINT_PREVIEW)", "   printing::PrintViewManager::CreateForWebContents(web_contents);", "   printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);", "  #else", "    printing::PrintViewManagerBasic::CreateForWebContents(web_contents);", "  #endif   ", "   CreateCompositeClientIfNeeded(web_contents, false  );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void arch_pick_mmap_layout(struct mm_struct *mm)", " {", " \tunsigned long random_factor = 0UL;", " ", "  \tif (current->flags & PF_RANDOMIZE)", "  \t\trandom_factor = arch_mmap_rnd();", "  ", "\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);", " \tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;", "  ", "  \tif (mmap_is_legacy()) {", "  \t\tmm->mmap_base = mm->mmap_legacy_base;", " \t\tmm->get_unmapped_area = arch_get_unmapped_area;", " \t} else {", " \t\tmm->mmap_base = mmap_base(random_factor);", " \t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int LE_command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize,", "  void *pCmdData, uint32_t *replySize, void *pReplyData) {", " ", "  LoudnessEnhancerContext * pContext = (LoudnessEnhancerContext *)self;", "  int retsize;", " ", "  if (pContext == NULL || pContext->mState == LOUDNESS_ENHANCER_STATE_UNINITIALIZED) {", "  return -EINVAL;", "  }", " ", "  switch (cmdCode) {", "  case EFFECT_CMD_INIT:", "  if (pReplyData == NULL || *replySize != sizeof(int)) {", "  return -EINVAL;", "  }", "  *(int *) pReplyData = LE_init(pContext);", " ", "          break;", "      case EFFECT_CMD_SET_CONFIG:", "          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)", "                || pReplyData == NULL || *replySize != sizeof(int)) {", "                 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {", "              return -EINVAL;", "          }", "          *(int *) pReplyData = LE_setConfig(pContext,", "  (effect_config_t *) pCmdData);", "  break;", "  case EFFECT_CMD_GET_CONFIG:", "  if (pReplyData == NULL ||", "  *replySize != sizeof(effect_config_t)) {", "  return -EINVAL;", "  }", "         LE_getConfig(pContext, (effect_config_t *)pReplyData);", "  break;", "  case EFFECT_CMD_RESET:", " ", "          LE_reset(pContext);", "          break;", "      case EFFECT_CMD_ENABLE:", "        if (pReplyData == NULL || *replySize != sizeof(int)) {", "         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {", "              return -EINVAL;", "          }", "          if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {", "  return -ENOSYS;", "  }", "         pContext->mState = LOUDNESS_ENHANCER_STATE_ACTIVE;", "         ALOGV(\"EFFECT_CMD_ENABLE() OK\");", "  *(int *)pReplyData = 0;", "  break;", "  case EFFECT_CMD_DISABLE:", "  if (pReplyData == NULL || *replySize != sizeof(int)) {", "  return -EINVAL;", "  }", "  if (pContext->mState != LOUDNESS_ENHANCER_STATE_ACTIVE) {", "  return -ENOSYS;", "  }", "         pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;", "         ALOGV(\"EFFECT_CMD_DISABLE() OK\");", "  *(int *)pReplyData = 0;", "  break;", " ", "      case EFFECT_CMD_GET_PARAM: {", "          if (pCmdData == NULL ||", "              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||", "            pReplyData == NULL ||", "             pReplyData == NULL || replySize == NULL ||", "              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {", "              return -EINVAL;", "          }", "         memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(uint32_t));", "  effect_param_t *p = (effect_param_t *)pReplyData;", "         p->status = 0;", "  *replySize = sizeof(effect_param_t) + sizeof(uint32_t);", "  if (p->psize != sizeof(uint32_t)) {", "             p->status = -EINVAL;", "  break;", "  }", "  switch (*(uint32_t *)p->data) {", "  case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:", "             ALOGV(\"get target gain(mB) = %d\", pContext->mTargetGainmB);", "  *((int32_t *)p->data + 1) = pContext->mTargetGainmB;", "             p->vsize = sizeof(int32_t);", "  *replySize += sizeof(int32_t);", "  break;", "  default:", "             p->status = -EINVAL;", "  }", "  } break;", " ", "      case EFFECT_CMD_SET_PARAM: {", "          if (pCmdData == NULL ||", "              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||", "            pReplyData == NULL || *replySize != sizeof(int32_t)) {", "             pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {", "              return -EINVAL;", "          }", "          *(int32_t *)pReplyData = 0;", "  effect_param_t *p = (effect_param_t *)pCmdData;", "  if (p->psize != sizeof(uint32_t) || p->vsize != sizeof(uint32_t)) {", "  *(int32_t *)pReplyData = -EINVAL;", "  break;", "  }", "  switch (*(uint32_t *)p->data) {", "  case LOUDNESS_ENHANCER_PARAM_TARGET_GAIN_MB:", "             pContext->mTargetGainmB = *((int32_t *)p->data + 1);", "             ALOGV(\"set target gain(mB) = %d\", pContext->mTargetGainmB);", "             LE_reset(pContext);  ", "  break;", "  default:", "  *(int32_t *)pReplyData = -EINVAL;", "  }", "  } break;", "  case EFFECT_CMD_SET_DEVICE:", "  case EFFECT_CMD_SET_VOLUME:", "  case EFFECT_CMD_SET_AUDIO_MODE:", "  break;", " ", "  default:", "         ALOGW(\"LE_command invalid command %d\",cmdCode);", "  return -EINVAL;", "  }", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)", " {", " \tint i;", " \tunsigned char max_level = 0;", " \tint unix_sock_count = 0;", " ", " \tif (too_many_unix_fds(current))", " \t\treturn -ETOOMANYREFS;", " ", " \tfor (i = scm->fp->count - 1; i >= 0; i--) {", " \t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);", " ", " \t\tif (sk) {", " \t\t\tunix_sock_count++;", " \t\t\tmax_level = max(max_level,", " \t\t\t\t\tunix_sk(sk)->recursion_level);", " \t\t}", " \t}", " \tif (unlikely(max_level > MAX_RECURSION_LEVEL))", " \t\treturn -ETOOMANYREFS;", " ", " \t ", " \tUNIXCB(skb).fp = scm_fp_dup(scm->fp);", " \tif (!UNIXCB(skb).fp)", "  \t\treturn -ENOMEM;", "  ", "  \tfor (i = scm->fp->count - 1; i >= 0; i--)", "\t\tunix_inflight(scm->fp->fp[i]);", " \t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);", "  \treturn max_level;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["  ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(", "      ImageBitmapFactories& factory,", "      base::Optional<IntRect> crop_rect,", "      ScriptState* script_state,", "      const ImageBitmapOptions* options)", "    : loader_(", "     : ContextLifecycleObserver(ExecutionContext::From(script_state)),", "       loader_(", "            FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),", "        factory_(&factory),", "        resolver_(ScriptPromiseResolver::Create(script_state)),", "        crop_rect_(crop_rect),", "        options_(options) {}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)", "{", "u32 Width, Height;", "GF_ESD *esd;", "char sdpLine[20000];", "char mediaName[30], payloadName[30];", "u32 mtype;", "", "Width = Height = 0;", "gf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);", "mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);", "if (gf_isom_is_video_handler_type(mtype))", "gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);", "", "gf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);", "", "", "sprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "if (tkHint->bandwidth) {", "sprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "if (tkHint->nb_chan) {", "sprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);", "} else {", "sprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "", "if (AddSystemInfo) {", "sprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "sprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "", "", "if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {", "sprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {", "sprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "else if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {", "u32 w, h, i, m_w, m_h;", "s32 tx, ty;", "s16 l;", "", "gf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);", "m_w = w;", "m_h = h;", "for (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {", "switch (gf_isom_get_media_type(tkHint->file, i+1)) {", "case GF_ISOM_MEDIA_SCENE:", "case GF_ISOM_MEDIA_VISUAL:", "case GF_ISOM_MEDIA_AUXV:", "case GF_ISOM_MEDIA_PICT:", "gf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);", "if (w>m_w) m_w = w;", "if (h>m_h) m_h = h;", "break;", "default:", "break;", "}", "}", "", "gf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);", "", "strcat(sdpLine, \"; tx3g=\");", "for (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {", "u8 *tx3g;", "char buffer[2000];", "u32 tx3g_len, len;", "gf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);", "len = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);", "gf_free(tx3g);", "buffer[len] = 0;", "if (i) strcat(sdpLine, \", \");", "strcat(sdpLine, buffer);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {", "sprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "else if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {", "GF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);", "GF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);", "", "", "if (avcc) {", "sprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);", "} else {", "sprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);", "}", "", "write_avc_config(sdpLine, avcc, svcc);", "", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "gf_odf_avc_cfg_del(avcc);", "gf_odf_avc_cfg_del(svcc);", "}", "", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "", "if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);", "} else {", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "", "if (tkHint->rtp_p->slMap.IV_length) {", "const char *kms;", "gf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);", "if (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {", "strcat(sdpLine, \"; ISMACrypKey=\");", "} else {", "strcat(sdpLine, \"; ISMACrypKey=(uri)\");", "}", "strcat(sdpLine, kms);", "}", "", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {", "GF_BitStream *bs;", "u8 *config_bytes;", "u32 config_size;", "", "", "bs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_write_int(bs, 1, 1);", "gf_bs_write_int(bs, 0, 6);", "gf_bs_write_int(bs, 0, 4);", "gf_bs_write_int(bs, 0, 3);", "", "", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "if (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {", "", "gf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "", "", "gf_bs_write_int(bs, 0, 3);", "gf_bs_write_int(bs, 0xff, 8);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_write_int(bs, 0, 1);", "gf_bs_get_content(bs, &config_bytes, &config_size);", "gf_bs_del(bs);", "", "gf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "gf_free(config_bytes);", "}", "#if GPAC_ENABLE_3GPP_DIMS_RTP", "", "else if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {", "GF_DIMSDescription dims;", "gf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);", "", "gf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);", "sprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);", "if (! dims.fullRequestHost) {", "char fmt[200];", "strcat(sdpLine, \";useFullRequestHost=0\");", "sprintf(fmt, \";pathComponents=%d\", dims.pathComponents);", "strcat(sdpLine, fmt);", "}", "if (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");", "if (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");", "else if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");", "", "if (dims.textEncoding && strlen(dims.textEncoding)) {", "strcat(sdpLine, \";text-encoding=\");", "strcat(sdpLine, dims.textEncoding);", "}", "if (dims.contentEncoding && strlen(dims.contentEncoding)) {", "strcat(sdpLine, \";content-coding=\");", "strcat(sdpLine, dims.contentEncoding);", "}", "if (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {", "strcat(sdpLine, \";content-script-types=\");", "strcat(sdpLine, dims.contentEncoding);", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "#endif", "", "if (Width && Height) {", "sprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "", "esd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);", "if (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {", "if (esd->decoderConfig->predefined_rvc_config) {", "sprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);", "} else {", "", "if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {", "sprintf(sdpLine, \"a=rvc-config:%s\", \"http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");", "} else {", "sprintf(sdpLine, \"a=rvc-config:%s\", \"http:download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");", "}", "}", "gf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);", "}", "if (esd) gf_odf_desc_del((GF_Descriptor *)esd);", "", "gf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" MediaControlsHeaderView::MediaControlsHeaderView() {", "  SetLayoutManager(std::make_unique<views::BoxLayout>(", "      views::BoxLayout::Orientation::kHorizontal, kMediaControlsHeaderInsets,", "      kMediaControlsHeaderChildSpacing));", " MediaControlsHeaderView::MediaControlsHeaderView(", "     base::OnceClosure close_button_cb)", "     : close_button_cb_(std::move(close_button_cb)) {", "   auto* layout = SetLayoutManager(std::make_unique<views::FlexLayout>());", "   layout->SetInteriorMargin(kHeaderViewInsets);", "  ", "    auto app_icon_view = std::make_unique<views::ImageView>();", "    app_icon_view->SetImageSize(gfx::Size(kIconSize, kIconSize));", "   app_icon_view->SetVerticalAlignment(views::ImageView::Alignment::kLeading);", "   app_icon_view->SetHorizontalAlignment(views::ImageView::Alignment::kLeading);", "   app_icon_view->SetBorder(views::CreateEmptyBorder(kIconPadding));", "   app_icon_view->SetBackground(", "       views::CreateRoundedRectBackground(SK_ColorWHITE, kIconCornerRadius));", "   app_icon_view_ = AddChildView(std::move(app_icon_view));", " ", "   gfx::Font default_font;", "   int font_size_delta = kHeaderTextFontSize - default_font.GetFontSize();", "   gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,", "                                        gfx::Font::Weight::NORMAL);", "   gfx::FontList font_list(font);", " ", "   auto app_name_view = std::make_unique<views::Label>();", "   app_name_view->SetFontList(font_list);", "    app_name_view->SetHorizontalAlignment(gfx::ALIGN_LEFT);", "    app_name_view->SetEnabledColor(SK_ColorWHITE);", "    app_name_view->SetAutoColorReadabilityEnabled(false);", "   app_name_view->SetBorder(views::CreateEmptyBorder(kAppNamePadding));", "    app_name_view_ = AddChildView(std::move(app_name_view));", " ", "    ", "   auto spacer = std::make_unique<NonAccessibleView>();", "   spacer->SetPreferredSize(kSpacerPreferredSize);", "   spacer->SetProperty(views::kFlexBehaviorKey,", "                       views::FlexSpecification::ForSizeRule(", "                           views::MinimumFlexSizeRule::kScaleToMinimum,", "                           views::MaximumFlexSizeRule::kUnbounded));", "   AddChildView(std::move(spacer));", " ", "   auto close_button = CreateVectorImageButton(this);", "   SetImageFromVectorIcon(close_button.get(), vector_icons::kCloseRoundedIcon,", "                          kCloseButtonIconSize, gfx::kGoogleGrey700);", "   close_button->SetPreferredSize(kCloseButtonSize);", "   close_button->SetFocusBehavior(View::FocusBehavior::ALWAYS);", "   base::string16 close_button_label(", "       l10n_util::GetStringUTF16(IDS_ASH_LOCK_SCREEN_MEDIA_CONTROLS_CLOSE));", "   close_button->SetAccessibleName(close_button_label);", "   close_button->SetVisible(false);", "   close_button_ = AddChildView(std::move(close_button));", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["   void CreateFusionSensor(", "       std::unique_ptr<PlatformSensorFusionAlgorithm> fusion_algorithm) {", "     auto callback =", "          base::Bind(&PlatformSensorFusionTest::PlatformSensorFusionCallback,", "                     base::Unretained(this));", "      SensorType type = fusion_algorithm->fused_type();", "    PlatformSensorFusion::Create(provider_->GetMapping(type), provider_.get(),", "                                 std::move(fusion_algorithm), callback);", "     PlatformSensorFusion::Create(provider_->GetSensorReadingBuffer(type),", "                                  provider_.get(), std::move(fusion_algorithm),", "                                  callback);", "      EXPECT_TRUE(platform_sensor_fusion_callback_called_);", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {", " #if !defined(NACL_WIN64)   ", "   if (base::win::GetVersion() > base::win::VERSION_SERVER_2003) {", "     if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==", "         gfx::kGLImplementationDesktopName) {", "       policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                             sandbox::USER_LIMITED);", "       policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);", "       policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);", "     } else {", "       if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==", "           gfx::kGLImplementationSwiftShaderName ||", "           cmd_line->HasSwitch(switches::kReduceGpuSandbox)) {", "         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                               sandbox::USER_LIMITED);", "         policy->SetJobLevel(sandbox::JOB_LIMITED_USER,", "                             JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |", "                             JOB_OBJECT_UILIMIT_DESKTOP |", "                             JOB_OBJECT_UILIMIT_EXITWINDOWS |", "                             JOB_OBJECT_UILIMIT_DISPLAYSETTINGS);", "       } else {", "         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                               sandbox::USER_RESTRICTED);", "         policy->SetJobLevel(sandbox::JOB_LOCKDOWN,", "                             JOB_OBJECT_UILIMIT_HANDLES);", "       }", " ", "       policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);", "     }", "   } else {", "     policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);", "     policy->SetTokenLevel(sandbox::USER_UNPROTECTED,", "                           sandbox::USER_LIMITED);", "   }", " ", "   sandbox::ResultCode result = policy->AddRule(", "       sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,", "       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,", "       L\"\\\\\\\\.\\\\pipe\\\\chrome.gpu.*\");", "    if (result != sandbox::SBOX_ALL_OK)", "      return false;", "  ", "    ", "   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,", "                            sandbox::TargetPolicy::HANDLES_DUP_ANY,", "                            L\"Section\");", "   if (result != sandbox::SBOX_ALL_OK)", "     return false;", " ", "    AddGenericDllEvictionPolicy(policy);", "  #endif", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" ip_optprint(netdissect_options *ndo,", "             register const u_char *cp, u_int length)", " {", " \tregister u_int option_len;", " \tconst char *sep = \"\";", " ", " \tfor (; length > 0; cp += option_len, length -= option_len) {", " \t\tu_int option_code;", " ", " \t\tND_PRINT((ndo, \"%s\", sep));", " \t\tsep = \",\";", " ", " \t\tND_TCHECK(*cp);", " \t\toption_code = *cp;", " ", " \t\tND_PRINT((ndo, \"%s\",", " \t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));", " ", " \t\tif (option_code == IPOPT_NOP ||", "                     option_code == IPOPT_EOL)", " \t\t\toption_len = 1;", " ", " \t\telse {", " \t\t\tND_TCHECK(cp[1]);", " \t\t\toption_len = cp[1];", " \t\t\tif (option_len < 2) {", " \t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));", " \t\t\t\treturn;", " \t\t\t}", " \t\t}", " ", " \t\tif (option_len > length) {", " \t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));", " \t\t\treturn;", " \t\t}", " ", " \t\tND_TCHECK2(*cp, option_len);", " ", " \t\tswitch (option_code) {", " \t\tcase IPOPT_EOL:", "  \t\t\treturn;", "  ", "  \t\tcase IPOPT_TS:", "\t\t\tip_printts(ndo, cp, option_len);", " \t\t\tif (ip_printts(ndo, cp, option_len) == -1)", " \t\t\t\tgoto trunc;", "  \t\t\tbreak;", "  ", "  \t\tcase IPOPT_RR:        ", " \t\tcase IPOPT_SSRR:", " \t\tcase IPOPT_LSRR:", " \t\t\tif (ip_printroute(ndo, cp, option_len) == -1)", " \t\t\t\tgoto trunc;", " \t\t\tbreak;", " ", " \t\tcase IPOPT_RA:", " \t\t\tif (option_len < 4) {", " \t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));", " \t\t\t\tbreak;", " \t\t\t}", " \t\t\tND_TCHECK(cp[3]);", " \t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)", " \t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));", " \t\t\tbreak;", " ", " \t\tcase IPOPT_NOP:        ", " \t\tcase IPOPT_SECURITY:", " \t\tdefault:", " \t\t\tbreak;", " \t\t}", " \t}", " \treturn;", " ", " trunc:", " \tND_PRINT((ndo, \"%s\", tstr));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" brcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,", " \t\t       struct cfg80211_mgmt_tx_params *params, u64 *cookie)", " {", " \tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);", " \tstruct ieee80211_channel *chan = params->chan;", " \tconst u8 *buf = params->buf;", " \tsize_t len = params->len;", " \tconst struct ieee80211_mgmt *mgmt;", " \tstruct brcmf_cfg80211_vif *vif;", " \ts32 err = 0;", " \ts32 ie_offset;", " \ts32 ie_len;", " \tstruct brcmf_fil_action_frame_le *action_frame;", " \tstruct brcmf_fil_af_params_le *af_params;", " \tbool ack;", " \ts32 chan_nr;", " \tu32 freq;", " ", " \tbrcmf_dbg(TRACE, \"Enter\\n\");", " ", " \t*cookie = 0;", " ", " \tmgmt = (const struct ieee80211_mgmt *)buf;", " ", " \tif (!ieee80211_is_mgmt(mgmt->frame_control)) {", " \t\tbrcmf_err(\"Driver only allows MGMT packet type\\n\");", " \t\treturn -EPERM;", " \t}", " ", " \tvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);", " ", " \tif (ieee80211_is_probe_resp(mgmt->frame_control)) {", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\t ", " \t\tie_offset =  DOT11_MGMT_HDR_LEN +", " \t\t\t     DOT11_BCN_PRB_FIXED_LEN;", " \t\tie_len = len - ie_offset;", " \t\tif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)", " \t\t\tvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;", " \t\terr = brcmf_vif_set_mgmt_ie(vif,", " \t\t\t\t\t    BRCMF_VNDR_IE_PRBRSP_FLAG,", " \t\t\t\t\t    &buf[ie_offset],", " \t\t\t\t\t    ie_len);", "  \t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,", "  \t\t\t\t\tGFP_KERNEL);", "  \t} else if (ieee80211_is_action(mgmt->frame_control)) {", " \t\tif (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {", " \t\t\tbrcmf_err(\"invalid action frame length\\n\");", " \t\t\terr = -EINVAL;", " \t\t\tgoto exit;", " \t\t}", "  \t\taf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);", "  \t\tif (af_params == NULL) {", "  \t\t\tbrcmf_err(\"unable to allocate frame\\n\");", " \t\t\terr = -ENOMEM;", " \t\t\tgoto exit;", " \t\t}", " \t\taction_frame = &af_params->action_frame;", " \t\t ", " \t\taction_frame->packet_id = cpu_to_le32(*cookie);", " \t\t ", " \t\tmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);", " \t\tmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);", " \t\t ", " \t\taction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);", " \t\t ", " \t\tif (chan)", " \t\t\tfreq = chan->center_freq;", " \t\telse", " \t\t\tbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,", " \t\t\t\t\t      &freq);", " \t\tchan_nr = ieee80211_frequency_to_channel(freq);", " \t\taf_params->channel = cpu_to_le32(chan_nr);", " ", " \t\tmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],", " \t\t       le16_to_cpu(action_frame->len));", " ", " \t\tbrcmf_dbg(TRACE, \"Action frame, cookie=%lld, len=%d, freq=%d\\n\",", " \t\t\t  *cookie, le16_to_cpu(action_frame->len), freq);", " ", " \t\tack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),", " \t\t\t\t\t\t  af_params);", " ", " \t\tcfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,", " \t\t\t\t\tGFP_KERNEL);", " \t\tkfree(af_params);", " \t} else {", " \t\tbrcmf_dbg(TRACE, \"Unhandled, fc=%04x!!\\n\", mgmt->frame_control);", " \t\tbrcmf_dbg_hex_dump(true, buf, len, \"payload, len=%zu\\n\", len);", " \t}", " ", " exit:", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" get_policy_2_svc(gpol_arg *arg, struct svc_req *rqstp)", " {", "      static gpol_ret             ret;", "      kadm5_ret_t         ret2;", "      char                        *prime_arg, *funcname;", "    gss_buffer_desc             client_name,", "        service_name;", "     gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;", "     gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;", "      OM_uint32                   minor_stat;", "      kadm5_principal_ent_rec     caller_ent;", "      kadm5_server_handle_t       handle;", "     const char                  *errmsg = NULL;", " ", "     xdr_free(xdr_gpol_ret,  &ret);", " ", "     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))", "         goto exit_func;", " ", "     if ((ret.code = check_handle((void *)handle)))", "         goto exit_func;", " ", "     ret.api_version = handle->api_version;", " ", "     funcname = \"kadm5_get_policy\";", " ", "     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {", "         ret.code = KADM5_FAILURE;", "         goto exit_func;", "     }", "     prime_arg = arg->name;", " ", "     ret.code = KADM5_AUTH_GET;", "     if (!CHANGEPW_SERVICE(rqstp) && kadm5int_acl_check(handle->context,", "                                                        rqst2name(rqstp),", "                                                        ACL_INQUIRE, NULL, NULL))", "         ret.code = KADM5_OK;", "     else {", "         ret.code = kadm5_get_principal(handle->lhandle,", "                                        handle->current_caller,", "                                        &caller_ent,", "                                        KADM5_PRINCIPAL_NORMAL_MASK);", "         if (ret.code == KADM5_OK) {", "             if (caller_ent.aux_attributes & KADM5_POLICY &&", "                 strcmp(caller_ent.policy, arg->name) == 0) {", "                 ret.code = KADM5_OK;", "             } else ret.code = KADM5_AUTH_GET;", "             ret2 = kadm5_free_principal_ent(handle->lhandle,", "                                             &caller_ent);", "             ret.code = ret.code ? ret.code : ret2;", "         }", "     }", " ", "     if (ret.code == KADM5_OK) {", "         ret.code = kadm5_get_policy(handle, arg->name, &ret.rec);", " ", "         if( ret.code != 0 )", "             errmsg = krb5_get_error_message(handle->context, ret.code);", " ", "         log_done(funcname,", "                  ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,", "                  &client_name, &service_name, rqstp);", "         if (errmsg != NULL)", "             krb5_free_error_message(handle->context, errmsg);", " ", "     } else {", "          log_unauth(funcname, prime_arg,", "                     &client_name, &service_name, rqstp);", "      }", " exit_func:", "      gss_release_buffer(&minor_stat, &client_name);", "      gss_release_buffer(&minor_stat, &service_name);", "exit_func:", "      free_server_handle(handle);", "      return &ret;", "  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["void Update(const char* str, size_t size) {", "if (str_ == NULL)", "str_ = str;", "else if (on_heap_ || str_ + size != str) {", "", "", "char* s = new char[size_ + size];", "memcpy(s, str_, size_);", "memcpy(s + size_, str, size);", "", "if (on_heap_)", "delete[] str_;", "else", "on_heap_ = true;", "", "str_ = s;", "}", "size_ += size;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ext4_fill_flex_info(struct super_block *sb)", " {", " \tstruct ext4_sb_info *sbi = EXT4_SB(sb);", "  \tstruct ext4_group_desc *gdp = NULL;", "  \text4_group_t flex_group_count;", "  \text4_group_t flex_group;", "\tint groups_per_flex = 0;", " \tunsigned int groups_per_flex = 0;", "  \tsize_t size;", "  \tint i;", "  ", "  \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;", "\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;", "\tif (groups_per_flex < 2) {", " \tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {", "  \t\tsbi->s_log_groups_per_flex = 0;", "  \t\treturn 1;", "  \t}", " \tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;", "  ", "  \t ", "  \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +", " \t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<", " \t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;", " \tsize = flex_group_count * sizeof(struct flex_groups);", " \tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);", " \tif (sbi->s_flex_groups == NULL) {", " \t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",", " \t\t\t flex_group_count);", " \t\tgoto failed;", " \t}", " ", " \tfor (i = 0; i < sbi->s_groups_count; i++) {", " \t\tgdp = ext4_get_group_desc(sb, i, NULL);", " ", " \t\tflex_group = ext4_flex_group(sbi, i);", " \t\tatomic_add(ext4_free_inodes_count(sb, gdp),", " \t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);", " \t\tatomic_add(ext4_free_group_clusters(sb, gdp),", " \t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);", " \t\tatomic_add(ext4_used_dirs_count(sb, gdp),", " \t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);", " \t}", " ", " \treturn 1;", " failed:", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void sas_resume_port(struct asd_sas_phy *phy)", " {", " \tstruct domain_device *dev;", " \tstruct asd_sas_port *port = phy->port;", " \tstruct sas_ha_struct *sas_ha = phy->ha;", " \tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);", " ", " \tif (si->dft->lldd_port_formed)", " \t\tsi->dft->lldd_port_formed(phy);", " ", " \tif (port->suspended)", " \t\tport->suspended = 0;", " \telse {", " \t\t ", " \t\treturn;", " \t}", " ", " \t ", " \tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {", " \t\tint i, rc;", " ", "  \t\trc = sas_notify_lldd_dev_found(dev);", "  \t\tif (rc) {", "  \t\t\tsas_unregister_dev(port, dev);", " \t\t\tsas_destruct_devices(port);", "  \t\t\tcontinue;", "  \t\t}", "  ", " \t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {", " \t\t\tdev->ex_dev.ex_change_count = -1;", " \t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {", " \t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];", " ", " \t\t\t\tphy->phy_change_count = -1;", " \t\t\t}", " \t\t}", " \t}", " ", " \tsas_discover_event(port, DISCE_RESUME);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int RsaPad_PSS(const byte* input, word32 inputLen, byte* pkcsBlock,", "word32 pkcsBlockLen, WC_RNG* rng, enum wc_HashType hType, int mgf,", "int saltLen, int bits, void* heap)", "{", "int   ret = 0;", "int   hLen, i, o, maskLen, hiBits;", "byte* m;", "byte* s;", "#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)", "#if defined(WOLFSSL_NO_MALLOC) && !defined(WOLFSSL_STATIC_MEMORY)", "byte salt[RSA_MAX_SIZE/8 + RSA_PSS_PAD_SZ];", "#else", "byte* salt = NULL;", "#endif", "#else", "byte salt[WC_MAX_DIGEST_SIZE];", "#endif", "", "#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)", "if (pkcsBlockLen > RSA_MAX_SIZE/8) {", "return MEMORY_E;", "}", "#endif", "", "hLen = wc_HashGetDigestSize(hType);", "if (hLen < 0)", "return hLen;", "if ((int)inputLen != hLen) {", "return BAD_FUNC_ARG;", "}", "", "hiBits = (bits - 1) & 0x7;", "if (hiBits == 0) {", "", "", "", "*(pkcsBlock++) = 0;", "pkcsBlockLen--;", "}", "", "if (saltLen == RSA_PSS_SALT_LEN_DEFAULT) {", "saltLen = hLen;", "#ifdef WOLFSSL_SHA512", "", "if (bits == 1024 && hLen == WC_SHA512_DIGEST_SIZE) {", "saltLen = RSA_PSS_SALT_MAX_SZ;", "}", "#endif", "}", "#ifndef WOLFSSL_PSS_LONG_SALT", "else if (saltLen > hLen) {", "return PSS_SALTLEN_E;", "}", "#endif", "#ifndef WOLFSSL_PSS_SALT_LEN_DISCOVER", "else if (saltLen < RSA_PSS_SALT_LEN_DEFAULT) {", "return PSS_SALTLEN_E;", "}", "#else", "else if (saltLen == RSA_PSS_SALT_LEN_DISCOVER) {", "saltLen = (int)pkcsBlockLen - hLen - 2;", "if (saltLen < 0) {", "return PSS_SALTLEN_E;", "}", "}", "else if (saltLen < RSA_PSS_SALT_LEN_DISCOVER) {", "return PSS_SALTLEN_E;", "}", "#endif", "if ((int)pkcsBlockLen - hLen < saltLen + 2) {", "return PSS_SALTLEN_E;", "}", "maskLen = pkcsBlockLen - 1 - hLen;", "", "#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)", "#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)", "salt = (byte*)XMALLOC(RSA_PSS_PAD_SZ + inputLen + saltLen, heap,", "DYNAMIC_TYPE_RSA_BUFFER);", "if (salt == NULL) {", "return MEMORY_E;", "}", "#endif", "s = m = salt;", "XMEMSET(m, 0, RSA_PSS_PAD_SZ);", "m += RSA_PSS_PAD_SZ;", "XMEMCPY(m, input, inputLen);", "m += inputLen;", "o = (int)(m - s);", "if (saltLen > 0) {", "ret = wc_RNG_GenerateBlock(rng, m, saltLen);", "if (ret == 0) {", "m += saltLen;", "}", "}", "#else", "s = m = pkcsBlock;", "XMEMSET(m, 0, RSA_PSS_PAD_SZ);", "m += RSA_PSS_PAD_SZ;", "XMEMCPY(m, input, inputLen);", "m += inputLen;", "o = 0;", "if (saltLen > 0) {", "ret = wc_RNG_GenerateBlock(rng, salt, saltLen);", "if (ret == 0) {", "XMEMCPY(m, salt, saltLen);", "m += saltLen;", "}", "}", "#endif", "if (ret == 0) {", "", "ret = wc_Hash(hType, s, (word32)(m - s), pkcsBlock + maskLen, hLen);", "}", "if (ret == 0) {", "", "pkcsBlock[pkcsBlockLen - 1] = RSA_PSS_PAD_TERM;", "", "ret = RsaMGF(mgf, pkcsBlock + maskLen, hLen, pkcsBlock, maskLen, heap);", "}", "if (ret == 0) {", "", "", "if (hiBits)", "pkcsBlock[0] &= (1 << hiBits) - 1;", "", "m = pkcsBlock + maskLen - saltLen - 1;", "*(m++) ^= 0x01;", "for (i = 0; i < saltLen; i++) {", "m[i] ^= salt[o + i];", "}", "}", "", "#if defined(WOLFSSL_PSS_LONG_SALT) || defined(WOLFSSL_PSS_SALT_LEN_DISCOVER)", "#if !defined(WOLFSSL_NO_MALLOC) || defined(WOLFSSL_STATIC_MEMORY)", "if (salt != NULL) {", "XFREE(salt, heap, DYNAMIC_TYPE_RSA_BUFFER);", "}", "#endif", "#endif", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": ["  static sk_sp<SkImage> flipSkImageVertically(SkImage* input,", "                                              AlphaDisposition alphaOp) {", "  size_t width = static_cast<size_t>(input->width());", "  size_t height = static_cast<size_t>(input->height());", "   unsigned width = static_cast<unsigned>(input->width());", "   unsigned height = static_cast<unsigned>(input->height());", "    SkImageInfo info = SkImageInfo::MakeN32(input->width(), input->height(),", "                                            (alphaOp == PremultiplyAlpha)", "                                                ? kPremul_SkAlphaType", "                                                : kUnpremul_SkAlphaType);", "  size_t imageRowBytes = width * info.bytesPerPixel();", "   unsigned imageRowBytes = width * info.bytesPerPixel();", "    RefPtr<Uint8Array> imagePixels = copySkImageData(input, info);", "    if (!imagePixels)", "      return nullptr;", "  for (size_t i = 0; i < height / 2; i++) {", "    size_t topFirstElement = i * imageRowBytes;", "    size_t topLastElement = (i + 1) * imageRowBytes;", "    size_t bottomFirstElement = (height - 1 - i) * imageRowBytes;", "   for (unsigned i = 0; i < height / 2; i++) {", "     unsigned topFirstElement = i * imageRowBytes;", "     unsigned topLastElement = (i + 1) * imageRowBytes;", "     unsigned bottomFirstElement = (height - 1 - i) * imageRowBytes;", "      std::swap_ranges(imagePixels->data() + topFirstElement,", "                       imagePixels->data() + topLastElement,", "                       imagePixels->data() + bottomFirstElement);", "   }", "   return newSkImageFromRaster(info, std::move(imagePixels), imageRowBytes);", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(", "      MemoryDumpType dump_type,", "      MemoryDumpLevelOfDetail level_of_detail,", "      const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {", "    ", "    ", "    ", "   if (level_of_detail ==", "       MemoryDumpLevelOfDetail::VM_REGIONS_ONLY_FOR_HEAP_PROFILER) {", "     bindings_.ReportBadMessage(", "         \"Requested global memory dump using level of detail reserved for the \"", "         \"heap profiler.\");", "     return;", "   }", " ", "    auto adapter =", "        [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,", "          bool success, uint64_t dump_guid,", "          mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };", " ", "   QueuedRequest::Args args(dump_type, level_of_detail, {},", "                            true  , base::kNullProcessId);", "   RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" P2PQuicTransportImpl::P2PQuicTransportImpl(", "     P2PQuicTransportConfig p2p_transport_config,", "     std::unique_ptr<net::QuicChromiumConnectionHelper> helper,", "     std::unique_ptr<quic::QuicConnection> connection,", "     const quic::QuicConfig& quic_config,", "     quic::QuicClock* clock)", "     : quic::QuicSession(connection.get(),", "                         nullptr  ,", "                         quic_config,", "                         quic::CurrentSupportedVersions()),", "       helper_(std::move(helper)),", "       connection_(std::move(connection)),", "       perspective_(p2p_transport_config.is_server", "                        ? quic::Perspective::IS_SERVER", "                         : quic::Perspective::IS_CLIENT),", "        packet_transport_(p2p_transport_config.packet_transport),", "        delegate_(p2p_transport_config.delegate),", "      clock_(clock) {", "       clock_(clock),", "       stream_write_buffer_size_(p2p_transport_config.stream_write_buffer_size) {", "    DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);", "    DCHECK(delegate_);", "    DCHECK(clock_);", "    DCHECK(packet_transport_);", "   DCHECK_GT(stream_write_buffer_size_, 0u);", "    DCHECK_GT(p2p_transport_config.certificates.size(), 0u);", "    if (p2p_transport_config.can_respond_to_crypto_handshake) {", "      InitializeCryptoStream();", "   }", "   certificate_ = p2p_transport_config.certificates[0];", "   packet_transport_->SetReceiveDelegate(this);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void gf_dump_vrml_proto_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field)", "{", "u32 i, sf_type;", "void *slot_ptr;", "", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"<fieldValue name=\\\"%s\\\" \", field.name);", "if (gf_sg_vrml_is_sf_field(field.fieldType)) {", "if (field.fieldType == GF_SG_VRML_SFNODE) {", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<node>\");", "gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</node>\");", "sdump->indent--;", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"</fieldValue>\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node);", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "} else {", "GenMFField *mffield = (GenMFField *) field.far_ptr;", "sf_type = gf_sg_vrml_get_sf_type(field.fieldType);", "", "if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) {", "if (sf_type == GF_SG_VRML_SFNODE) {", "GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr;", "gf_fprintf(sdump->trace, \">\\n\");", "sdump->indent++;", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"<nodes>\");", "while (list) {", "gf_dump_vrml_node(sdump, list->node, 1, NULL);", "list = list->next;", "}", "if (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");", "sdump->indent--;", "DUMP_IND(sdump);", "gf_fprintf(sdump->trace, \"</fieldValue>\\n\");", "} else {", "if (sdump->X3DDump) {", "gf_fprintf(sdump->trace, \" value=\\\"\");", "} else {", "gf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));", "}", "if (mffield) {", "for (i=0; i<mffield->count; i++) {", "if (i) gf_fprintf(sdump->trace, \" \");", "if (field.fieldType != GF_SG_VRML_MFNODE) {", "gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);", "gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);", "}", "}", "}", "gf_fprintf(sdump->trace, \"\\\"/>\\n\");", "}", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" string_modifier_check(struct magic_set *ms, struct magic *m)", " {", "  \tif ((ms->flags & MAGIC_CHECK) == 0)", "  \t\treturn 0;", "  ", "\tif (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0) {", " \tif ((m->type != FILE_REGEX || (m->str_flags & REGEX_LINE_COUNT) == 0) &&", " \t    (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0)) {", "  \t\tfile_magwarn(ms,", "  \t\t    \"'/BHhLl' modifiers are only allowed for pascal strings\\n\");", "  \t\treturn -1;", " \t}", " \tswitch (m->type) {", " \tcase FILE_BESTRING16:", " \tcase FILE_LESTRING16:", " \t\tif (m->str_flags != 0) {", " \t\t\tfile_magwarn(ms,", " \t\t\t    \"no modifiers allowed for 16-bit strings\\n\");", " \t\t\treturn -1;", " \t\t}", " \t\tbreak;", " \tcase FILE_STRING:", " \tcase FILE_PSTRING:", " \t\tif ((m->str_flags & REGEX_OFFSET_START) != 0) {", " \t\t\tfile_magwarn(ms,", " \t\t\t    \"'/%c' only allowed on regex and search\\n\",", " \t\t\t    CHAR_REGEX_OFFSET_START);", " \t\t\treturn -1;", " \t\t}", " \t\tbreak;", " \tcase FILE_SEARCH:", " \t\tif (m->str_range == 0) {", " \t\t\tfile_magwarn(ms,", " \t\t\t    \"missing range; defaulting to %d\\n\",", "                             STRING_DEFAULT_RANGE);", " \t\t\tm->str_range = STRING_DEFAULT_RANGE;", " \t\t\treturn -1;", " \t\t}", " \t\tbreak;", " \tcase FILE_REGEX:", " \t\tif ((m->str_flags & STRING_COMPACT_WHITESPACE) != 0) {", " \t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",", " \t\t\t    CHAR_COMPACT_WHITESPACE);", " \t\t\treturn -1;", " \t\t}", " \t\tif ((m->str_flags & STRING_COMPACT_OPTIONAL_WHITESPACE) != 0) {", " \t\t\tfile_magwarn(ms, \"'/%c' not allowed on regex\\n\",", " \t\t\t    CHAR_COMPACT_OPTIONAL_WHITESPACE);", " \t\t\treturn -1;", " \t\t}", " \t\tbreak;", " \tdefault:", " \t\tfile_magwarn(ms, \"coding error: m->type=%d\\n\",", " \t\t    m->type);", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image)", " {", "   const char", "     *option,", "     *property;", " ", "   int", "     jp2_status;", " ", "   MagickBooleanType", "     status;", " ", "   opj_codec_t", "     *jp2_codec;", " ", "   OPJ_COLOR_SPACE", "     jp2_colorspace;", " ", "   opj_cparameters_t", "     parameters;", " ", "   opj_image_cmptparm_t", "     jp2_info[5];", " ", "   opj_image_t", "     *jp2_image;", " ", "   opj_stream_t", "     *jp2_stream;", " ", "   register ssize_t", "     i;", " ", "   ssize_t", "     y;", " ", "   unsigned int", "     channels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);", "   if (status == MagickFalse)", "     return(status);", "    ", "   opj_set_default_encoder_parameters(&parameters);", "   for (i=1; i < 6; i++)", "     if (((size_t) (1 << (i+2)) > image->columns) &&", "         ((size_t) (1 << (i+2)) > image->rows))", "       break;", "   parameters.numresolution=i;", "   option=GetImageOption(image_info,\"jp2:number-resolutions\");", "   if (option != (const char *) NULL)", "     parameters.numresolution=StringToInteger(option);", "   parameters.tcp_numlayers=1;", "   parameters.tcp_rates[0]=0;   ", "   parameters.cp_disto_alloc=1;", "   if ((image_info->quality != 0) && (image_info->quality != 100))", "     {", "       parameters.tcp_distoratio[0]=(double) image_info->quality;", "       parameters.cp_fixed_quality=OPJ_TRUE;", "     }", "   if (image_info->extract != (char *) NULL)", "     {", "       RectangleInfo", "         geometry;", " ", "       int", "         flags;", " ", "        ", "       flags=ParseAbsoluteGeometry(image_info->extract,&geometry);", "       parameters.cp_tdx=(int) geometry.width;", "       parameters.cp_tdy=(int) geometry.width;", "       if ((flags & HeightValue) != 0)", "         parameters.cp_tdy=(int) geometry.height;", "       if ((flags & XValue) != 0)", "         parameters.cp_tx0=geometry.x;", "       if ((flags & YValue) != 0)", "         parameters.cp_ty0=geometry.y;", "       parameters.tile_size_on=OPJ_TRUE;", "     }", "   option=GetImageOption(image_info,\"jp2:quality\");", "   if (option != (const char *) NULL)", "     {", "       register const char", "         *p;", " ", "        ", "       p=option;", "       for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)", "       {", "         if (i >= 100)", "           break;", "         while ((*p != '\\0') && (*p != ','))", "           p++;", "         if (*p == '\\0')", "           break;", "         p++;", "       }", "       parameters.tcp_numlayers=i+1;", "       parameters.cp_fixed_quality=OPJ_TRUE;", "     }", "   option=GetImageOption(image_info,\"jp2:progression-order\");", "   if (option != (const char *) NULL)", "     {", "       if (LocaleCompare(option,\"LRCP\") == 0)", "         parameters.prog_order=OPJ_LRCP;", "       if (LocaleCompare(option,\"RLCP\") == 0)", "         parameters.prog_order=OPJ_RLCP;", "       if (LocaleCompare(option,\"RPCL\") == 0)", "         parameters.prog_order=OPJ_RPCL;", "       if (LocaleCompare(option,\"PCRL\") == 0)", "         parameters.prog_order=OPJ_PCRL;", "       if (LocaleCompare(option,\"CPRL\") == 0)", "         parameters.prog_order=OPJ_CPRL;", "     }", "   option=GetImageOption(image_info,\"jp2:rate\");", "   if (option != (const char *) NULL)", "     {", "       register const char", "         *p;", " ", "        ", "       p=option;", "       for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)", "       {", "         if (i > 100)", "           break;", "         while ((*p != '\\0') && (*p != ','))", "           p++;", "         if (*p == '\\0')", "           break;", "         p++;", "       }", "       parameters.tcp_numlayers=i+1;", "       parameters.cp_disto_alloc=OPJ_TRUE;", "     }", "   if (image_info->sampling_factor != (const char *) NULL)", "     (void) sscanf(image_info->sampling_factor,\"%d,%d\",", "        &parameters.subsampling_dx,&parameters.subsampling_dy);", "    property=GetImageProperty(image,\"comment\");", "    if (property != (const char *) NULL)", "    parameters.cp_comment=property;", "     parameters.cp_comment=(char *) property;", "    channels=3;", "    jp2_colorspace=OPJ_CLRSPC_SRGB;", "    if (image->colorspace == YUVColorspace)", "     {", "       jp2_colorspace=OPJ_CLRSPC_SYCC;", "       parameters.subsampling_dx=2;", "     }", "   else", "     {", "       if (IsGrayColorspace(image->colorspace) != MagickFalse)", "         {", "           channels=1;", "           jp2_colorspace=OPJ_CLRSPC_GRAY;", "         }", "       else", "         (void) TransformImageColorspace(image,sRGBColorspace);", "       if (image->matte != MagickFalse)", "         channels++;", "     }", "   parameters.tcp_mct=channels == 3 ? 1 : 0;", "   ResetMagickMemory(jp2_info,0,sizeof(jp2_info));", "   for (i=0; i < (ssize_t) channels; i++)", "   {", "     jp2_info[i].prec=(unsigned int) image->depth;", "     jp2_info[i].bpp=(unsigned int) image->depth;", "     if ((image->depth == 1) &&", "         ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||", "          (LocaleCompare(image_info->magick,\"JP2\") == 0)))", "       {", "         jp2_info[i].prec++;   ", "         jp2_info[i].bpp++;", "       }", "     jp2_info[i].sgnd=0;", "     jp2_info[i].dx=parameters.subsampling_dx;", "     jp2_info[i].dy=parameters.subsampling_dy;", "     jp2_info[i].w=(unsigned int) image->columns;", "     jp2_info[i].h=(unsigned int) image->rows;", "   }", "   jp2_image=opj_image_create(channels,jp2_info,jp2_colorspace);", "   if (jp2_image == (opj_image_t *) NULL)", "     ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");", "   jp2_image->x0=parameters.image_offset_x0;", "   jp2_image->y0=parameters.image_offset_y0;", "   jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*", "     parameters.subsampling_dx+1);", "   jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*", "     parameters.subsampling_dx+1);", "   if ((image->depth == 12) &&", "       ((image->columns == 2048) || (image->rows == 1080) ||", "        (image->columns == 4096) || (image->rows == 2160)))", "     CinemaProfileCompliance(jp2_image,&parameters);", "   if (channels == 4)", "     jp2_image->comps[3].alpha=1;", "   else", "    if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))", "      jp2_image->comps[1].alpha=1;", "    ", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     register const PixelPacket", "       *p;", " ", "     ssize_t", "       x;", " ", "     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "     if (p == (const PixelPacket *) NULL)", "       break;", "     for (x=0; x < (ssize_t) image->columns; x++)", "     {", "       for (i=0; i < (ssize_t) channels; i++)", "       {", "         double", "           scale;", " ", "         register int", "           *q;", " ", "         scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;", "         q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*", "           image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);", "         switch (i)", "         {", "           case 0:", "           {", "             if (jp2_colorspace == OPJ_CLRSPC_GRAY)", "               {", "                 *q=(int) (scale*GetPixelLuma(image,p));", "                 break;", "               }", "             *q=(int) (scale*p->red);", "             break;", "           }", "           case 1:", "           {", "             if (jp2_colorspace == OPJ_CLRSPC_GRAY)", "               {", "                 *q=(int) (scale*(QuantumRange-p->opacity));", "                 break;", "               }", "             *q=(int) (scale*p->green);", "             break;", "           }", "           case 2:", "           {", "             *q=(int) (scale*p->blue);", "             break;", "           }", "           case 3:", "           {", "             *q=(int) (scale*(QuantumRange-p->opacity));", "             break;", "           }", "         }", "       }", "       p++;", "     }", "     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "       image->rows);", "     if (status == MagickFalse)", "       break;", "   }", "   if (LocaleCompare(image_info->magick,\"JPT\") == 0)", "     jp2_codec=opj_create_compress(OPJ_CODEC_JPT);", "   else", "     if (LocaleCompare(image_info->magick,\"J2K\") == 0)", "       jp2_codec=opj_create_compress(OPJ_CODEC_J2K);", "     else", "       jp2_codec=opj_create_compress(OPJ_CODEC_JP2);", "   opj_set_warning_handler(jp2_codec,JP2WarningHandler,&image->exception);", "   opj_set_error_handler(jp2_codec,JP2ErrorHandler,&image->exception);", "   opj_setup_encoder(jp2_codec,&parameters,jp2_image);", "   jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);", "   opj_stream_set_read_function(jp2_stream,JP2ReadHandler);", "   opj_stream_set_write_function(jp2_stream,JP2WriteHandler);", "   opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);", "   opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);", "   opj_stream_set_user_data(jp2_stream,image,NULL);", "   if (jp2_stream == (opj_stream_t *) NULL)", "     ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");", "   jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);", "   if (jp2_status == 0)", "     ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");", "   if ((opj_encode(jp2_codec,jp2_stream) == 0) ||", "       (opj_end_compress(jp2_codec,jp2_stream) == 0))", "     {", "       opj_stream_destroy(jp2_stream);", "       opj_destroy_codec(jp2_codec);", "       opj_image_destroy(jp2_image);", "       ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");", "     }", "    ", "   opj_stream_destroy(jp2_stream);", "   opj_destroy_codec(jp2_codec);", "   opj_image_destroy(jp2_image);", "   (void) CloseBlob(image);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   void StopInputMethodDaemon() {", "     if (!initialized_successfully_)", "       return;", " ", "      should_launch_ime_ = false;", "      if (ibus_daemon_process_handle_ != base::kNullProcessHandle) {", "        const base::ProcessId pid = base::GetProcId(ibus_daemon_process_handle_);", "      if (!chromeos::StopInputMethodProcess(input_method_status_connection_)) {", "       if (!ibus_controller_->StopInputMethodProcess()) {", "          LOG(ERROR) << \"StopInputMethodProcess IPC failed. Sending SIGTERM to \"", "                     << \"PID \" << pid;", "          base::KillProcess(ibus_daemon_process_handle_, -1, false  );", "       }", "       VLOG(1) << \"ibus-daemon (PID=\" << pid << \") is terminated\";", "       ibus_daemon_process_handle_ = base::kNullProcessHandle;", "     }", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" XSharedMemoryId AttachSharedMemory(Display* display, int shared_memory_key) {", "   DCHECK(QuerySharedMemorySupport(display));", " ", "   XShmSegmentInfo shminfo;", "   memset(&shminfo, 0, sizeof(shminfo));", "   shminfo.shmid = shared_memory_key;", " ", "  if (!XShmAttach(display, &shminfo))", "   if (!XShmAttach(display, &shminfo)) {", "     LOG(WARNING) << \"X failed to attach to shared memory segment \"", "                  << shminfo.shmid;", "      NOTREACHED();", "   } else {", "     VLOG(1) << \"X attached to shared memory segment \" << shminfo.shmid;", "   }", "  ", "    return shminfo.shmseg;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {", "  size_t oldSize = mSize;", " ", "  size_t offset = 0;", "  while (mSize >= 10 && offset <= mSize - 10) {", "  if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {", "  break;", "  }", " ", "  size_t dataSize;", "  if (iTunesHack) {", "             dataSize = U32_AT(&mData[offset + 4]);", "  } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {", "  return false;", "  }", " ", "  if (dataSize > mSize - 10 - offset) {", "  return false;", "  }", " ", "  uint16_t flags = U16_AT(&mData[offset + 8]);", "  uint16_t prevFlags = flags;", " ", "  if (flags & 1) {", " ", "  if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {", "  return false;", "  }", "             memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);", "             mSize -= 4;", "             dataSize -= 4;", " ", "             flags &= ~1;", "  }", " ", "  if ((flags & 2) && (dataSize >= 2)) {", " ", "  size_t readOffset = offset + 11;", "  size_t writeOffset = offset + 11;", "  for (size_t i = 0; i + 1 < dataSize; ++i) {", "  if (mData[readOffset - 1] == 0xff", "  && mData[readOffset] == 0x00) {", "  ++readOffset;", " ", "                      --mSize;", "                      --dataSize;", "                  }", "                mData[writeOffset++] = mData[readOffset++];", "                 if (i + 1 < dataSize) {", "                      ", "                      ", "                      ", "                     mData[writeOffset++] = mData[readOffset++];", "                 }", "              }", "              if (readOffset <= oldSize) {", "                 memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);", "  } else {", "                 ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);", "                 android_errorWriteLog(0x534e4554, \"34618607\");", "  }", " ", "  }", "         flags &= ~2;", "  if (flags != prevFlags || iTunesHack) {", "  WriteSyncsafeInteger(&mData[offset + 4], dataSize);", "             mData[offset + 8] = flags >> 8;", "             mData[offset + 9] = flags & 0xff;", "  }", " ", "         offset += 10 + dataSize;", "  }", " ", "     memset(&mData[mSize], 0, oldSize - mSize);", " ", "  return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,", "                                 WORD32 num_mb_skip,", "                                 UWORD8 u1_is_idr_slice,", "                                 UWORD16 u2_frame_num,", "  pocstruct_t *ps_cur_poc,", "                                 WORD32 prev_slice_err)", " {", "     WORD32 i2_cur_mb_addr;", "     UWORD32 u1_num_mbs, u1_num_mbsNby2;", "     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;", "     UWORD32 i2_mb_skip_run;", " ", "     UWORD32 u1_num_mbs_next, u1_end_of_row;", "  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;", "     UWORD32 u1_slice_end;", "     UWORD32 u1_tfr_n_mb;", "     UWORD32 u1_decode_nmb;", "  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;", "  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;", "  deblk_mb_t *ps_cur_deblk_mb;", "  dec_mb_info_t *ps_cur_mb_info;", "  parse_pmbarams_t *ps_parse_mb_data;", "     UWORD32 u1_inter_mb_type;", "     UWORD32 u1_deblk_mb_type;", "     UWORD16 u2_total_mbs_coded;", "     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;", "  parse_part_params_t *ps_part_info;", "     WORD32 ret;", " ", " ", "  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)", "  {", "         ih264d_err_pic_dispbuf_mgr(ps_dec);", "  return 0;", "  }", "     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;", "  if(prev_slice_err == 1)", "  {", "   ", "         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;", " ", " ", "  if(!ps_dec->u1_first_slice_in_stream)", "  {", "             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,", "                 ps_dec->ps_cur_slice->u2_frame_num);", "             ps_dec->s_cur_pic_poc.u2_frame_num =", "                 ps_dec->ps_cur_slice->u2_frame_num;", "  }", " ", "  {", "             WORD32 i, j, poc = 0;", " ", "             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;", " ", "             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;", "             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;", "             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;", " ", "  if(ps_dec->ps_cur_pic != NULL)", "                 poc = ps_dec->ps_cur_pic->i4_poc + 2;", " ", "             j = 0;", "  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)", "  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)", "                        j = i;", "  {", "                 ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "                 ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;", "                 ps_dec->ps_cur_slice->u1_nal_unit_type = 1;", "                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,", "                         ps_dec->ps_cur_slice->u2_frame_num,", "  &ps_dec->ps_pps[j]);", " ", "  if(ret != OK)", "  {", "  return ret;", "  }", "  }", " ", "             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;", " ", "             ps_dec->u4_output_present = 0;", " ", "  {", "                 ih264d_get_next_display_field(ps_dec,", "                                               ps_dec->ps_out_buffer,", "  &(ps_dec->s_disp_op));", "   ", " ", "  if(0 != ps_dec->s_disp_op.u4_error_code)", "  {", "                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;", "  }", "  else", "                     ps_dec->u4_output_present = 1;", "  }", " ", "  if(ps_dec->u1_separate_parse == 1)", "  {", "  if(ps_dec->u4_dec_thread_created == 0)", "  {", "                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,", "  (void *)ih264d_decode_picture_thread,", "  (void *)ps_dec);", " ", "                     ps_dec->u4_dec_thread_created = 1;", "  }", " ", "  if((ps_dec->u4_num_cores == 3) &&", "  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)", "  && (ps_dec->u4_bs_deblk_thread_created == 0))", "  {", "                     ps_dec->u4_start_recon_deblk = 0;", "                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,", "  (void *)ih264d_recon_deblk_thread,", "  (void *)ps_dec);", "                     ps_dec->u4_bs_deblk_thread_created = 1;", " ", "                  }", "              }", "          }", "         ps_dec->u4_first_slice_in_pic = 0;", "      }", "      else", "      {", " ", "  dec_slice_struct_t *ps_parse_cur_slice;", "         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;", " ", "  if(ps_dec->u1_slice_header_done", "  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)", "  {", "             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;", " ", "  if(u1_num_mbs)", "  {", "                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;", "  }", "  else", "  {", "  if(ps_dec->u1_separate_parse)", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info - 1;", "  }", "  else", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info", "  + ps_dec->u4_num_mbs_prev_nmb - 1;", "  }", "  }", " ", "             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;", "             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;", " ", "             ps_dec->u1_mb_ngbr_availablity =", "                     ps_cur_mb_info->u1_mb_ngbr_availablity;", " ", "             ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;", "             ps_dec->u2_cur_mb_addr--;", "             ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;", " ", "  if(u1_num_mbs)", "  {", "  if (ps_dec->u1_pr_sl_type == P_SLICE", "  || ps_dec->u1_pr_sl_type == B_SLICE)", "  {", "                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);", "                     ps_dec->ps_part = ps_dec->ps_parse_part_params;", "  }", " ", "                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "                 u1_end_of_row = (!u1_num_mbs_next)", "  && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "                 u1_slice_end = 1;", "                 u1_tfr_n_mb = 1;", "                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                     ps_dec->ps_nmb_info += u1_num_mbs;", "  }", "  else", "  {", "                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "  }", "                 ps_dec->u2_total_mbs_coded += u1_num_mbs;", "                 ps_dec->u1_mb_idx = 0;", "                 ps_dec->u4_num_mbs_cur_nmb = 0;", "  }", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "                 ps_dec->u1_pic_decode_done = 1;", "  return 0;", "  }", " ", "             ps_dec->u2_cur_slice_num++;", "              ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "             ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", "             ps_dec->ps_parse_cur_slice++;", " ", "  }", "  else", "  {", "             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf", "  + ps_dec->u2_cur_slice_num;", "  }", "  }", " ", "   ", "   ", "   ", "  {", "         WORD32 num_entries;", "         WORD32 size;", "         UWORD8 *pu1_buf;", " ", "         num_entries = MAX_FRAMES;", "  if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&", "  (0 == ps_dec->i4_display_delay))", "  {", "             num_entries = 1;", "  }", "         num_entries = ((2 * num_entries) + 1);", "  if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)", "  {", "             num_entries *= 2;", "  }", "         size = num_entries * sizeof(void *);", "         size += PAD_MAP_IDX_POC * sizeof(void *);", " ", "         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;", "         pu1_buf += size * ps_dec->u2_cur_slice_num;", "         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;", "  }", " ", "     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;", "     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;", "     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;", " ", "  if(ps_dec->ps_cur_slice->u1_field_pic_flag)", "         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;", " ", "     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;", "     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;", " ", " ", "  if(ps_dec->u1_separate_parse)", "  {", "         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;", "  }", "  else", "  {", "         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;", "  }", " ", "   ", "   ", "   ", "     u1_inter_mb_type = P_MB;", "     u1_deblk_mb_type = D_INTER_MB;", " ", "     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;", "     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;", "     ps_dec->ps_part = ps_dec->ps_parse_part_params;", " ", "   ", "   ", "   ", "     ps_dec->u1_slice_header_done = 2;", "     ps_dec->u1_qp = ps_slice->u1_slice_qp;", "     ih264d_update_qp(ps_dec, 0);", "     u1_mb_idx = ps_dec->u1_mb_idx;", "     ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "     u1_num_mbs = u1_mb_idx;", " ", "     u1_slice_end = 0;", "     u1_tfr_n_mb = 0;", "     u1_decode_nmb = 0;", "     u1_num_mbsNby2 = 0;", "     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;", "     i2_mb_skip_run = num_mb_skip;", " ", "  while(!u1_slice_end)", "  {", "         UWORD8 u1_mb_type;", " ", "  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)", "  break;", " ", "         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;", "         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;", " ", "         ps_cur_mb_info->u1_Mux = 0;", "         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);", "         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;", " ", "         ps_cur_mb_info->u1_end_of_slice = 0;", " ", "   ", "         ps_parse_mb_data->u1_num_part = 1;", "         ps_parse_mb_data->u1_isI_mb = 0;", " ", "   ", "   ", "   ", "   ", "  if (u1_mbaff)", "             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", "  else", "             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", " ", "   ", "  if(ps_dec->u4_app_disable_deblk_frm == 0)", "  {", "             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,", "                                              ps_dec->u1_mb_ngbr_availablity,", "                                              ps_dec->u1_cur_mb_fld_dec_flag);", "  }", " ", "   ", "         ps_dec->i1_prev_mb_qp_delta = 0;", "         ps_dec->u1_sub_mb_num = 0;", "         ps_cur_mb_info->u1_mb_type = MB_SKIP;", "         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;", "         ps_cur_mb_info->u1_cbp = 0;", " ", "   ", "         ps_part_info = ps_dec->ps_part;", "         ps_part_info->u1_is_direct = PART_DIRECT_16x16;", "         ps_part_info->u1_sub_mb_num = 0;", "         ps_dec->ps_part++;", " ", "   ", "         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);", " ", "         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;", "         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;", " ", "         i2_mb_skip_run--;", " ", "         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;", " ", "  if (u1_mbaff)", "  {", "             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);", "  }", " ", "   ", "   ", "   ", "         i2_cur_mb_addr++;", " ", "         u1_num_mbs++;", "         u1_num_mbsNby2++;", "         ps_parse_mb_data++;", " ", "   ", "   ", "   ", "   ", "   ", "         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "         u1_slice_end = !i2_mb_skip_run;", "         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row", "  || u1_slice_end;", "         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;", "         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(u1_decode_nmb)", "  {", "             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);", "             u1_num_mbsNby2 = 0;", " ", "             ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "             ps_dec->ps_part = ps_dec->ps_parse_part_params;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                 ps_dec->ps_nmb_info +=  u1_num_mbs;", "  }", "  else", "  {", "                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,", "                                             u1_tfr_n_mb, u1_end_of_row);", "  }", "             ps_dec->u2_total_mbs_coded += u1_num_mbs;", "  if(u1_tfr_n_mb)", "                 u1_num_mbs = 0;", "             u1_mb_idx = u1_num_mbs;", "             ps_dec->u1_mb_idx = u1_num_mbs;", "  }", "  }", " ", "     ps_dec->u4_num_mbs_cur_nmb = 0;", "     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr", "  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;", " ", "  ", "      H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);", "  ", "    ps_dec->u2_cur_slice_num++;", "  ", "       ", "      if(ps_dec->u4_first_slice_in_pic != 0)", "     {", "          ps_dec->ps_parse_cur_slice++;", "         ps_dec->u2_cur_slice_num++;", "     }", "  ", "      ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "      ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "         ps_dec->u1_pic_decode_done = 1;", "  }", " ", "  return 0;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void ChunkToLayerMapper::SwitchToChunk(const PaintChunk& chunk) {", "    outset_for_raster_effects_ = chunk.outset_for_raster_effects;", "  ", "  const auto& new_chunk_state = chunk.properties.GetPropertyTreeState();", "   const auto& new_chunk_state = chunk.properties;", "    if (new_chunk_state == chunk_state_)", "      return;", "  ", "   if (new_chunk_state == layer_state_) {", "     has_filter_that_moves_pixels_ = false;", "     transform_ = TransformationMatrix().Translate(-layer_offset_.x(),", "                                                   -layer_offset_.y());", "     clip_rect_ = FloatClipRect();", "     chunk_state_ = new_chunk_state;", "     return;", "   }", " ", "   if (new_chunk_state.Transform() != chunk_state_.Transform()) {", "     transform_ = GeometryMapper::SourceToDestinationProjection(", "         new_chunk_state.Transform(), layer_state_.Transform());", "     transform_.PostTranslate(-layer_offset_.x(), -layer_offset_.y());", "   }", " ", "   bool new_has_filter_that_moves_pixels = has_filter_that_moves_pixels_;", "   if (new_chunk_state.Effect() != chunk_state_.Effect()) {", "     new_has_filter_that_moves_pixels = false;", "     for (const auto* effect = new_chunk_state.Effect();", "          effect && effect != layer_state_.Effect(); effect = effect->Parent()) {", "       if (effect->HasFilterThatMovesPixels()) {", "         new_has_filter_that_moves_pixels = true;", "         break;", "       }", "     }", "   }", " ", "   bool needs_clip_recalculation =", "       new_has_filter_that_moves_pixels != has_filter_that_moves_pixels_ ||", "       new_chunk_state.Clip() != chunk_state_.Clip();", "   if (needs_clip_recalculation) {", "     clip_rect_ =", "         GeometryMapper::LocalToAncestorClipRect(new_chunk_state, layer_state_);", "     if (!clip_rect_.IsInfinite())", "       clip_rect_.MoveBy(FloatPoint(-layer_offset_.x(), -layer_offset_.y()));", "   }", " ", "   chunk_state_ = new_chunk_state;", "   has_filter_that_moves_pixels_ = new_has_filter_that_moves_pixels;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)", "{", "if (!iter || !next)", "return -1;", "", "if (iter->in_range)", "{", "if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||", "(!iter->down && (iter->range_cur == (iter->range_end + 1))))", "{", "iter->in_range = 0;", "}", "}", "", "if (!iter->in_range)", "{", "iter->substr_cur = iter->substr_end;", "if (iter->substr_cur == iter->eostr)", "return 1;", "", "while (!*(iter->substr_cur))", "iter->substr_cur++;", "iter->substr_end = strchr(iter->substr_cur, ',');", "if (!iter->substr_end)", "iter->substr_end = iter->eostr;", "else", "*(iter->substr_end) = '\\0';", "", "char *range_sep = strchr(iter->substr_cur, ':');", "if (range_sep)", "*range_sep++ = '\\0';", "", "if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)", "return -1;", "if (range_sep)", "{", "if (mutt_str_atoui(range_sep, &iter->range_end) != 0)", "return -1;", "}", "else", "iter->range_end = iter->range_cur;", "", "iter->down = (iter->range_end < iter->range_cur);", "iter->in_range = 1;", "}", "", "*next = iter->range_cur;", "if (iter->down)", "iter->range_cur--;", "else", "iter->range_cur++;", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int mif_validate(jas_stream_t *in)", "  {", "\tuchar buf[MIF_MAGICLEN];", " \tjas_uchar buf[MIF_MAGICLEN];", "  \tuint_fast32_t magic;", "  \tint i;", "  \tint n;", " ", " \tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);", " ", " \t ", " \tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " ", " \t ", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " ", " \t ", " \tif (n < MIF_MAGICLEN) {", " \t\treturn -1;", " \t}", " ", " \t ", " \tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |", " \t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |", " \t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |", " \t  buf[3];", " ", " \t ", " \tif (magic != MIF_MAGIC) {", " \t\treturn -1;", " \t}", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)", " {", " \tunsigned char l, n = 0;", " \tchar callsign[11];", " ", " \tdo {", " \t\tswitch (*p & 0xC0) {", " \t\tcase 0x00:", " \t\t\tp   += 2;", " \t\t\tn   += 2;", " \t\t\tlen -= 2;", " \t\t\tbreak;", " ", " \t\tcase 0x40:", " \t\t\tp   += 3;", " \t\t\tn   += 3;", " \t\t\tlen -= 3;", " \t\t\tbreak;", " ", " \t\tcase 0x80:", " \t\t\tp   += 4;", " \t\t\tn   += 4;", " \t\t\tlen -= 4;", " \t\t\tbreak;", "  ", "  \t\tcase 0xC0:", "  \t\t\tl = p[1];", " ", " \t\t\t ", " \t\t\tif (l < 10 || l > 20)", " \t\t\t\treturn -1;", " ", "  \t\t\tif (*p == FAC_CCITT_DEST_NSAP) {", "  \t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);", "  \t\t\t\tmemcpy(callsign, p + 12,   l - 10);", " \t\t\t\tcallsign[l - 10] = '\\0';", " \t\t\t\tasc2ax(&facilities->source_call, callsign);", " \t\t\t}", " \t\t\tif (*p == FAC_CCITT_SRC_NSAP) {", " \t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);", " \t\t\t\tmemcpy(callsign, p + 12, l - 10);", " \t\t\t\tcallsign[l - 10] = '\\0';", " \t\t\t\tasc2ax(&facilities->dest_call, callsign);", " \t\t\t}", " \t\t\tp   += l + 2;", " \t\t\tn   += l + 2;", " \t\t\tlen -= l + 2;", " \t\t\tbreak;", " \t\t}", " \t} while (*p != 0x00 && len > 0);", " ", " \treturn n;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" icmp6_rrenum_print(netdissect_options *ndo, const u_char *bp, const u_char *ep)", " {", " \tconst struct icmp6_router_renum *rr6;", " \tconst char *cp;", " \tconst struct rr_pco_match *match;", " \tconst struct rr_pco_use *use;", " \tchar hbuf[NI_MAXHOST];", " \tint n;", " ", " \tif (ep < bp)", " \t\treturn;", " \trr6 = (const struct icmp6_router_renum *)bp;", " \tcp = (const char *)(rr6 + 1);", " ", " \tND_TCHECK(rr6->rr_reserved);", " \tswitch (rr6->rr_code) {", " \tcase ICMP6_ROUTER_RENUMBERING_COMMAND:", " \t\tND_PRINT((ndo,\"router renum: command\"));", " \t\tbreak;", " \tcase ICMP6_ROUTER_RENUMBERING_RESULT:", " \t\tND_PRINT((ndo,\"router renum: result\"));", " \t\tbreak;", " \tcase ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET:", " \t\tND_PRINT((ndo,\"router renum: sequence number reset\"));", " \t\tbreak;", " \tdefault:", " \t\tND_PRINT((ndo,\"router renum: code-#%d\", rr6->rr_code));", " \t\tbreak;", " \t}", " ", "         ND_PRINT((ndo,\", seq=%u\", EXTRACT_32BITS(&rr6->rr_seqnum)));", " ", " \tif (ndo->ndo_vflag) {", " #define F(x, y)\t((rr6->rr_flags) & (x) ? (y) : \"\")", " \t\tND_PRINT((ndo,\"[\"));\t ", " \t\tif (rr6->rr_flags) {", " \t\t\tND_PRINT((ndo,\"%s%s%s%s%s,\", F(ICMP6_RR_FLAGS_TEST, \"T\"),", "                                   F(ICMP6_RR_FLAGS_REQRESULT, \"R\"),", "                                   F(ICMP6_RR_FLAGS_FORCEAPPLY, \"A\"),", "                                   F(ICMP6_RR_FLAGS_SPECSITE, \"S\"),", "                                   F(ICMP6_RR_FLAGS_PREVDONE, \"P\")));", " \t\t}", "                 ND_PRINT((ndo,\"seg=%u,\", rr6->rr_segnum));", "                 ND_PRINT((ndo,\"maxdelay=%u\", EXTRACT_16BITS(&rr6->rr_maxdelay)));", " \t\tif (rr6->rr_reserved)", " \t\t\tND_PRINT((ndo,\"rsvd=0x%x\", EXTRACT_32BITS(&rr6->rr_reserved)));", " \t\t ", " \t\tND_PRINT((ndo,\"]\"));", " #undef F", " \t}", " ", " \tif (rr6->rr_code == ICMP6_ROUTER_RENUMBERING_COMMAND) {", " \t\tmatch = (const struct rr_pco_match *)cp;", " \t\tcp = (const char *)(match + 1);", " ", " \t\tND_TCHECK(match->rpm_prefix);", " ", " \t\tif (ndo->ndo_vflag > 1)", " \t\t\tND_PRINT((ndo,\"\\n\\t\"));", " \t\telse", " \t\t\tND_PRINT((ndo,\" \"));", " \t\tND_PRINT((ndo,\"match(\"));\t ", " \t\tswitch (match->rpm_code) {", " \t\tcase RPM_PCO_ADD:\tND_PRINT((ndo,\"add\")); break;", " \t\tcase RPM_PCO_CHANGE:\tND_PRINT((ndo,\"change\")); break;", " \t\tcase RPM_PCO_SETGLOBAL:\tND_PRINT((ndo,\"setglobal\")); break;", " \t\tdefault:\t\tND_PRINT((ndo,\"#%u\", match->rpm_code)); break;", " \t\t}", " ", " \t\tif (ndo->ndo_vflag) {", " \t\t\tND_PRINT((ndo,\",ord=%u\", match->rpm_ordinal));", " \t\t\tND_PRINT((ndo,\",min=%u\", match->rpm_minlen));", " \t\t\tND_PRINT((ndo,\",max=%u\", match->rpm_maxlen));", " \t\t}", " \t\tif (addrtostr6(&match->rpm_prefix, hbuf, sizeof(hbuf)))", " \t\t\tND_PRINT((ndo,\",%s/%u\", hbuf, match->rpm_matchlen));", " \t\telse", " \t\t\tND_PRINT((ndo,\",?/%u\", match->rpm_matchlen));", " \t\t ", " \t\tND_PRINT((ndo,\")\"));", " ", " \t\tn = match->rpm_len - 3;", " \t\tif (n % 4)", " \t\t\tgoto trunc;", " \t\tn /= 4;", " \t\twhile (n-- > 0) {", " \t\t\tuse = (const struct rr_pco_use *)cp;", " \t\t\tcp = (const char *)(use + 1);", " ", " \t\t\tND_TCHECK(use->rpu_prefix);", " ", " \t\t\tif (ndo->ndo_vflag > 1)", " \t\t\t\tND_PRINT((ndo,\"\\n\\t\"));", " \t\t\telse", " \t\t\t\tND_PRINT((ndo,\" \"));", " \t\t\tND_PRINT((ndo,\"use(\"));\t ", " \t\t\tif (use->rpu_flags) {", " #define F(x, y)\t((use->rpu_flags) & (x) ? (y) : \"\")", " \t\t\t\tND_PRINT((ndo,\"%s%s,\",", "                                           F(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME, \"V\"),", "                                           F(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME, \"P\")));", " #undef F", " \t\t\t}", " \t\t\tif (ndo->ndo_vflag) {", " \t\t\t\tND_PRINT((ndo,\"mask=0x%x,\", use->rpu_ramask));", " \t\t\t\tND_PRINT((ndo,\"raflags=0x%x,\", use->rpu_raflags));", " \t\t\t\tif (~use->rpu_vltime == 0)", " \t\t\t\t\tND_PRINT((ndo,\"vltime=infty,\"));", " \t\t\t\telse", " \t\t\t\t\tND_PRINT((ndo,\"vltime=%u,\",", "                                                   EXTRACT_32BITS(&use->rpu_vltime)));", " \t\t\t\tif (~use->rpu_pltime == 0)", " \t\t\t\t\tND_PRINT((ndo,\"pltime=infty,\"));", " \t\t\t\telse", " \t\t\t\t\tND_PRINT((ndo,\"pltime=%u,\",", "                                                   EXTRACT_32BITS(&use->rpu_pltime)));", " \t\t\t}", " \t\t\tif (addrtostr6(&use->rpu_prefix, hbuf, sizeof(hbuf)))", " \t\t\t\tND_PRINT((ndo,\"%s/%u/%u\", hbuf, use->rpu_uselen,", "                                           use->rpu_keeplen));", " \t\t\telse", " \t\t\t\tND_PRINT((ndo,\"?/%u/%u\", use->rpu_uselen,", "                                           use->rpu_keeplen));", " \t\t\t ", "                         ND_PRINT((ndo,\")\"));", " \t\t}", " \t}", " ", "  \treturn;", "  ", "  trunc:", "\tND_PRINT((ndo,\"[|icmp6]\"));", " \tND_PRINT((ndo, \"%s\", icmp6_tstr));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" gsm_xsmp_client_disconnect (GsmXSMPClient *client)", " {", "         if (client->priv->watch_id > 0) {", "                 g_source_remove (client->priv->watch_id);", "         }", " ", "         if (client->priv->conn != NULL) {", "                 SmsCleanUp (client->priv->conn);", "         }", " ", "         if (client->priv->ice_connection != NULL) {", "                  IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);", "                  IceCloseConnection (client->priv->ice_connection);", "          }", "        if (client->priv->protocol_timeout > 0) {", "                g_source_remove (client->priv->protocol_timeout);", "        }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {", "     _sx_sasl_t ctx = (_sx_sasl_t) p->private;", "     _sx_sasl_sess_t sctx = NULL;", "     char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;", "     char hostname[256];", "     int ret;", " #ifdef HAVE_SSL", "     int i;", " #endif", "     size_t buflen, outlen;", " ", "     assert(ctx);", "     assert(ctx->cb);", " ", "      if(mech != NULL) {", "          _sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);", "  ", "        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {", "         if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {", "               _sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);", "               _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);", "               return;", "         }", " ", "          ", "         ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);", "         if(ret != GSASL_OK) {", "             _sx_debug(ZONE, \"gsasl_server_start failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));", "             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);", "             return;", "         }", " ", "          ", "         (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);", " ", "          ", "         sctx = gsasl_session_hook_get(sd);", "         if (sctx != NULL) free(sctx);", " ", "          ", "         sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));", "         sctx->s = s;", "         sctx->ctx = ctx;", "         gsasl_session_hook_set(sd, (void *) sctx);", "         gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);", "         gsasl_property_set(sd, GSASL_REALM, realm);", " ", "          ", "         hostname[0] = '\\0';", "         gethostname(hostname, 256);", "         hostname[255] = '\\0';", "         gsasl_property_set(sd, GSASL_HOSTNAME, hostname);", " ", "          ", "         ext_id = NULL;", " #ifdef HAVE_SSL", "         for(i = 0; i < s->env->nplugins; i++)", "             if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)", "                 ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;", "         if (ext_id != NULL) {", "              ", "             for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)", "                 if (ext_id[i] != NULL) {", "                     ctx->ext_id[i] = strdup(ext_id[i]);", "                 } else {", "                     ctx->ext_id[i] = NULL;", "                     break;", "                 }", "         }", " #endif", " ", "         _sx_debug(ZONE, \"sasl context initialised for %d\", s->tag);", " ", "         s->plugin_data[p->index] = (void *) sd;", " ", "         if(strcmp(mech, \"ANONYMOUS\") == 0) {", "              ", "             (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);", "             buf = strdup(out);", "             buflen = strlen(buf);", "         } else if (strstr(in, \"<\") != NULL && strncmp(in, \"=\", strstr(in, \"<\") - in ) == 0) {", "              ", "              ", "             _sx_debug(ZONE, \"gsasl auth string is empty\");", "             buf = strdup(\"\");", "             buflen = strlen(buf);", "         } else {", "              ", "             ret = gsasl_base64_from(in, inlen, &buf, &buflen);", "             if (ret != GSASL_OK) {", "                 _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));", "                 _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);", "                 if(buf != NULL) free(buf);", "                 return;", "             }", "         }", " ", "         ret = gsasl_step(sd, buf, buflen, &out, &outlen);", "     }", " ", "     else {", "          ", "         ret = gsasl_base64_from(in, inlen, &buf, &buflen);", "         if (ret != GSASL_OK) {", "             _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));", "             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);", "             return;", "         }", " ", "         if(!sd) {", "             _sx_debug(ZONE, \"response send before auth request enabling mechanism (decoded: %.*s)\", buflen, buf);", "             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, \"response send before auth request enabling mechanism\"), 0);", "             if(buf != NULL) free(buf);", "             return;", "         }", "         _sx_debug(ZONE, \"response from client (decoded: %.*s)\", buflen, buf);", "         ret = gsasl_step(sd, buf, buflen, &out, &outlen);", "     }", " ", "     if(buf != NULL) free(buf);", " ", "      ", "     if(ret == GSASL_OK) {", "         _sx_debug(ZONE, \"sasl handshake completed\");", " ", "          ", "         ret = gsasl_base64_to(out, outlen, &buf, &buflen);", "         if (ret == GSASL_OK) {", "              ", "             _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);", "             free(buf);", " ", "              ", "             ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;", "             ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;", "         }", "         else {", "             _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));", "             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);", "             if(buf != NULL) free(buf);", "         }", " ", "         if(out != NULL) free(out);", " ", "         return;", "     }", " ", "      ", "     if(ret == GSASL_NEEDS_MORE) {", "         _sx_debug(ZONE, \"sasl handshake in progress (challenge: %.*s)\", outlen, out);", " ", "          ", "         ret = gsasl_base64_to(out, outlen, &buf, &buflen);", "         if (ret == GSASL_OK) {", "             _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);", "             free(buf);", "         }", "         else {", "             _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));", "             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);", "             if(buf != NULL) free(buf);", "         }", " ", "         if(out != NULL) free(out);", " ", "         return;", "     }", " ", "     if(out != NULL) free(out);", " ", "      ", "     _sx_debug(ZONE, \"sasl handshake failed; (%d): %s\", ret, gsasl_strerror(ret));", " ", "     switch (ret) {", "         case GSASL_AUTHENTICATION_ERROR:", " \tcase GSASL_NO_ANONYMOUS_TOKEN:", " \tcase GSASL_NO_AUTHID:", " \tcase GSASL_NO_AUTHZID:", " \tcase GSASL_NO_PASSWORD:", " \tcase GSASL_NO_PASSCODE:", " \tcase GSASL_NO_PIN:", " \tcase GSASL_NO_SERVICE:", " \tcase GSASL_NO_HOSTNAME:", "             out = _sasl_err_NOT_AUTHORIZED;", "             break;", " \tcase GSASL_UNKNOWN_MECHANISM:", " \tcase GSASL_MECHANISM_PARSE_ERROR:", "             out = _sasl_err_INVALID_MECHANISM;", "             break;", " \tcase GSASL_BASE64_ERROR:", "             out = _sasl_err_INCORRECT_ENCODING;", "             break;", "         default:", "             out = _sasl_err_MALFORMED_REQUEST;", "     }", "     _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" TEE_Result syscall_asymm_operate(unsigned long state,", " \t\t\tconst struct utee_attribute *usr_params,", " \t\t\tsize_t num_params, const void *src_data, size_t src_len,", " \t\t\tvoid *dst_data, uint64_t *dst_len)", " {", " \tTEE_Result res;", " \tstruct tee_cryp_state *cs;", " \tstruct tee_ta_session *sess;", " \tuint64_t dlen64;", " \tsize_t dlen;", " \tstruct tee_obj *o;", " \tvoid *label = NULL;", " \tsize_t label_len = 0;", " \tsize_t n;", " \tint salt_len;", " \tTEE_Attribute *params = NULL;", " \tstruct user_ta_ctx *utc;", " ", " \tres = tee_ta_get_current_session(&sess);", " \tif (res != TEE_SUCCESS)", " \t\treturn res;", " \tutc = to_user_ta_ctx(sess->ctx);", " ", " \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);", " \tif (res != TEE_SUCCESS)", " \t\treturn res;", " ", " \tres = tee_mmu_check_access_rights(", " \t\tutc,", " \t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER,", " \t\t(uaddr_t) src_data, src_len);", " \tif (res != TEE_SUCCESS)", " \t\treturn res;", " ", " \tres = tee_svc_copy_from_user(&dlen64, dst_len, sizeof(dlen64));", " \tif (res != TEE_SUCCESS)", " \t\treturn res;", " \tdlen = dlen64;", " ", " \tres = tee_mmu_check_access_rights(", " \t\tutc,", " \t\tTEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE |", " \t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,", " \t\t(uaddr_t) dst_data, dlen);", "  \tif (res != TEE_SUCCESS)", "  \t\treturn res;", "  ", "\tparams = malloc(sizeof(TEE_Attribute) * num_params);", " \tsize_t alloc_size = 0;", " ", " \tif (MUL_OVERFLOW(sizeof(TEE_Attribute), num_params, &alloc_size))", " \t\treturn TEE_ERROR_OVERFLOW;", " ", " \tparams = malloc(alloc_size);", "  \tif (!params)", "  \t\treturn TEE_ERROR_OUT_OF_MEMORY;", "  \tres = copy_in_attrs(utc, usr_params, num_params, params);", " \tif (res != TEE_SUCCESS)", " \t\tgoto out;", " ", " \tres = tee_obj_get(utc, cs->key1, &o);", " \tif (res != TEE_SUCCESS)", " \t\tgoto out;", " \tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) {", " \t\tres = TEE_ERROR_GENERIC;", " \t\tgoto out;", " \t}", " ", " \tswitch (cs->algo) {", " \tcase TEE_ALG_RSA_NOPAD:", " \t\tif (cs->mode == TEE_MODE_ENCRYPT) {", " \t\t\tres = crypto_acipher_rsanopad_encrypt(o->attr, src_data,", " \t\t\t\t\t\t\t      src_len, dst_data,", " \t\t\t\t\t\t\t      &dlen);", " \t\t} else if (cs->mode == TEE_MODE_DECRYPT) {", " \t\t\tres = crypto_acipher_rsanopad_decrypt(o->attr, src_data,", " \t\t\t\t\t\t\t      src_len, dst_data,", " \t\t\t\t\t\t\t      &dlen);", " \t\t} else {", " \t\t\t ", " \t\t\tres = TEE_ERROR_GENERIC;", " \t\t}", " \t\tbreak;", " ", " \tcase TEE_ALG_RSAES_PKCS1_V1_5:", " \tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA1:", " \tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA224:", " \tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA256:", " \tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA384:", " \tcase TEE_ALG_RSAES_PKCS1_OAEP_MGF1_SHA512:", " \t\tfor (n = 0; n < num_params; n++) {", " \t\t\tif (params[n].attributeID == TEE_ATTR_RSA_OAEP_LABEL) {", " \t\t\t\tlabel = params[n].content.ref.buffer;", " \t\t\t\tlabel_len = params[n].content.ref.length;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " ", " \t\tif (cs->mode == TEE_MODE_ENCRYPT) {", " \t\t\tres = crypto_acipher_rsaes_encrypt(cs->algo, o->attr,", " \t\t\t\t\t\t\t   label, label_len,", " \t\t\t\t\t\t\t   src_data, src_len,", " \t\t\t\t\t\t\t   dst_data, &dlen);", " \t\t} else if (cs->mode == TEE_MODE_DECRYPT) {", " \t\t\tres = crypto_acipher_rsaes_decrypt(", " \t\t\t\t\tcs->algo, o->attr, label, label_len,", " \t\t\t\t\tsrc_data, src_len, dst_data, &dlen);", " \t\t} else {", " \t\t\tres = TEE_ERROR_BAD_PARAMETERS;", " \t\t}", " \t\tbreak;", " ", " #if defined(CFG_CRYPTO_RSASSA_NA1)", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5:", " #endif", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_MD5:", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA1:", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA224:", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA256:", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA384:", " \tcase TEE_ALG_RSASSA_PKCS1_V1_5_SHA512:", " \tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA1:", " \tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA224:", " \tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA256:", " \tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA384:", " \tcase TEE_ALG_RSASSA_PKCS1_PSS_MGF1_SHA512:", " \t\tif (cs->mode != TEE_MODE_SIGN) {", " \t\t\tres = TEE_ERROR_BAD_PARAMETERS;", " \t\t\tbreak;", " \t\t}", " \t\tsalt_len = pkcs1_get_salt_len(params, num_params, src_len);", " \t\tres = crypto_acipher_rsassa_sign(cs->algo, o->attr, salt_len,", " \t\t\t\t\t\t src_data, src_len, dst_data,", " \t\t\t\t\t\t &dlen);", " \t\tbreak;", " ", " \tcase TEE_ALG_DSA_SHA1:", " \tcase TEE_ALG_DSA_SHA224:", " \tcase TEE_ALG_DSA_SHA256:", " \t\tres = crypto_acipher_dsa_sign(cs->algo, o->attr, src_data,", " \t\t\t\t\t      src_len, dst_data, &dlen);", " \t\tbreak;", " \tcase TEE_ALG_ECDSA_P192:", " \tcase TEE_ALG_ECDSA_P224:", " \tcase TEE_ALG_ECDSA_P256:", " \tcase TEE_ALG_ECDSA_P384:", " \tcase TEE_ALG_ECDSA_P521:", " \t\tres = crypto_acipher_ecc_sign(cs->algo, o->attr, src_data,", " \t\t\t\t\t      src_len, dst_data, &dlen);", " \t\tbreak;", " ", " \tdefault:", " \t\tres = TEE_ERROR_BAD_PARAMETERS;", " \t\tbreak;", " \t}", " ", " out:", " \tfree(params);", " ", " \tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {", " \t\tTEE_Result res2;", " ", " \t\tdlen64 = dlen;", " \t\tres2 = tee_svc_copy_to_user(dst_len, &dlen64, sizeof(*dst_len));", " \t\tif (res2 != TEE_SUCCESS)", " \t\t\treturn res2;", " \t}", " ", " \treturn res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" plan_a (char const *filename)", " {", "   char const *s;", "   char const *lim;", "   char const **ptr;", "   char *buffer;", "   lin iline;", "   size_t size = instat.st_size;", " ", "    ", "   if (! (size == instat.st_size", " \t && (buffer = malloc (size ? size : (size_t) 1))))", "     return false;", " ", "    ", "   if (size)", "      {", "        if (S_ISREG (instat.st_mode))", "          {", "\t  int ifd = safe_open (filename, O_RDONLY|binary_transput, 0);", " \t  int flags = O_RDONLY | binary_transput;", "  \t  size_t buffered = 0, n;", " \t  int ifd;", " ", " \t  if (! follow_symlinks)", " \t    flags |= O_NOFOLLOW;", " \t  ifd = safe_open (filename, flags, 0);", "  \t  if (ifd < 0)", "  \t    pfatal (\"can't open file %s\", quotearg (filename));", "  ", " \t\t   ", " \t\t  size = buffered;", " \t\t  break;", " \t\t}", " \t      if (n == (size_t) -1)", " \t\t{", " \t\t   ", " \t\t  close (ifd);", " \t\t  free (buffer);", " \t\t  return false;", " \t\t}", " \t      buffered += n;", " \t    }", " ", " \t  if (close (ifd) != 0)", " \t    read_fatal ();", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,", "u64 remaining, u64 expires)", "{", "struct cfs_rq *cfs_rq;", "u64 runtime;", "u64 starting_runtime = remaining;", "", "rcu_read_lock();", "list_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,", "throttled_list) {", "struct rq *rq = rq_of(cfs_rq);", "struct rq_flags rf;", "", "rq_lock_irqsave(rq, &rf);", "if (!cfs_rq_throttled(cfs_rq))", "goto next;", "", "runtime = -cfs_rq->runtime_remaining + 1;", "if (runtime > remaining)", "runtime = remaining;", "remaining -= runtime;", "", "cfs_rq->runtime_remaining += runtime;", "cfs_rq->runtime_expires = expires;", "", "", "if (cfs_rq->runtime_remaining > 0)", "unthrottle_cfs_rq(cfs_rq);", "", "next:", "rq_unlock_irqrestore(rq, &rf);", "", "if (!remaining)", "break;", "}", "rcu_read_unlock();", "", "return starting_runtime - remaining;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int venc_dev::venc_output_log_buffers(const char *buffer_addr, int buffer_len)", "  {", "     if (venc_handle->is_secure_session()) {", "         DEBUG_PRINT_ERROR(\"logging secure output buffers is not allowed!\");", "         return -1;", "     }", " ", "      if (!m_debug.outfile) {", "          int size = 0;", "          if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) {", "            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.m4v\",", "                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) {", "            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.264\",", "                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) {", "            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%ld_%ld_%p.265\",", "                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) {", "            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.263\",", "                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) {", "            size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, \"%s/output_enc_%lu_%lu_%p.ivf\",", "                            m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  }", "  if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {", "              DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\",", "                                 m_debug.outfile_name, size);", "  }", "         m_debug.outfile = fopen(m_debug.outfile_name, \"ab\");", "  if (!m_debug.outfile) {", "             DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging errno:%d\",", "                                m_debug.outfile_name, errno);", "             m_debug.outfile_name[0] = '\\0';", "  return -1;", "  }", "  }", "  if (m_debug.outfile && buffer_len) {", "         DEBUG_PRINT_LOW(\"%s buffer_len:%d\", __func__, buffer_len);", "         fwrite(buffer_addr, buffer_len, 1, m_debug.outfile);", "  }", "  return 0;", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int venc_dev::venc_input_log_buffers(OMX_BUFFERHEADERTYPE *pbuffer, int fd, int plane_offset) {", "     if (venc_handle->is_secure_session()) {", "         DEBUG_PRINT_ERROR(\"logging secure input buffers is not allowed!\");", "         return -1;", "     }", " ", "      if (!m_debug.infile) {", "          int size = snprintf(m_debug.infile_name, PROPERTY_VALUE_MAX, \"%s/input_enc_%lu_%lu_%p.yuv\",", "                              m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this);", "  if ((size > PROPERTY_VALUE_MAX) && (size < 0)) {", "              DEBUG_PRINT_ERROR(\"Failed to open output file: %s for logging size:%d\",", "                                 m_debug.infile_name, size);", "  }", "         m_debug.infile = fopen (m_debug.infile_name, \"ab\");", "  if (!m_debug.infile) {", "             DEBUG_PRINT_HIGH(\"Failed to open input file: %s for logging\", m_debug.infile_name);", "             m_debug.infile_name[0] = '\\0';", "  return -1;", "  }", "  }", "  if (m_debug.infile && pbuffer && pbuffer->nFilledLen) {", "  unsigned long i, msize;", "  int stride = VENUS_Y_STRIDE(COLOR_FMT_NV12, m_sVenc_cfg.input_width);", "  int scanlines = VENUS_Y_SCANLINES(COLOR_FMT_NV12, m_sVenc_cfg.input_height);", "  unsigned char *pvirt,*ptemp;", " ", "  char *temp = (char *)pbuffer->pBuffer;", " ", "         msize = VENUS_BUFFER_SIZE(COLOR_FMT_NV12, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height);", "  if (metadatamode == 1) {", "             pvirt= (unsigned char *)mmap(NULL, msize, PROT_READ|PROT_WRITE,MAP_SHARED, fd, plane_offset);", "  if (pvirt) {", "                ptemp = pvirt;", "  for (i = 0; i < m_sVenc_cfg.input_height; i++) {", "                     fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);", "                     ptemp += stride;", "  }", "                ptemp = pvirt + (stride * scanlines);", "  for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {", "                    fwrite(ptemp, m_sVenc_cfg.input_width, 1, m_debug.infile);", "                    ptemp += stride;", "  }", "                munmap(pvirt, msize);", "  } else if (pvirt == MAP_FAILED) {", "                  DEBUG_PRINT_ERROR(\"%s mmap failed\", __func__);", "  return -1;", "  }", "  } else {", "  for (i = 0; i < m_sVenc_cfg.input_height; i++) {", "                  fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);", "                  temp += stride;", "  }", " ", "             temp = (char *)pbuffer->pBuffer + (stride * scanlines);", " ", "  for(i = 0; i < m_sVenc_cfg.input_height/2; i++) {", "                 fwrite(temp, m_sVenc_cfg.input_width, 1, m_debug.infile);", "                 temp += stride;", "  }", "  }", "  }", "  return 0;", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)", " static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred)", "  {", "  \tstruct nfs4_exception exception = { };", "  \tstruct nfs4_state *res;", "  \tint status;", "  ", "  \tdo {", "\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);", " \t\tstatus = _nfs4_do_open(dir, path, fmode, flags, sattr, cred, &res);", "  \t\tif (status == 0)", "  \t\t\tbreak;", "  \t\t ", " \t\tif (status == -NFS4ERR_BAD_SEQID) {", " \t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"", " \t\t\t\t\t\" returned a bad sequence-id error!\\n\",", " \t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);", " \t\t\texception.retry = 1;", " \t\t\tcontinue;", " \t\t}", " \t\t ", " \t\tif (status == -NFS4ERR_BAD_STATEID) {", " \t\t\texception.retry = 1;", " \t\t\tcontinue;", " \t\t}", " \t\tif (status == -EAGAIN) {", " \t\t\t ", " \t\t\texception.retry = 1;", " \t\t\tcontinue;", " \t\t}", " \t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),", " \t\t\t\t\tstatus, &exception));", " \t} while (exception.retry);", " \treturn res;", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  _TIFFmalloc(tmsize_t s)", "  {", "         if (s == 0)", "                 return ((void *) NULL);", " ", "  \treturn (malloc((size_t) s));", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buffer,", "unsigned int &size, const SessionProtocolWorkingState &state, string delta_monotonic)", "{", "char *pos = buffer;", "const char *end = buffer + size;", "", "pos += sizeof(boost::uint32_t);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_URI\"));", "pos = appendData(pos, end, req->path.start->data, req->path.size);", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PATH_INFO\"));", "pos = appendData(pos, end, state.path.data(), state.path.size());", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SCRIPT_NAME\"));", "if (state.hasBaseURI) {", "pos = appendData(pos, end, req->options.baseURI);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"\"));", "}", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"QUERY_STRING\"));", "pos = appendData(pos, end, state.queryString.data(), state.queryString.size());", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REQUEST_METHOD\"));", "pos = appendData(pos, end, state.methodStr);", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_NAME\"));", "pos = appendData(pos, end, state.serverName);", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PORT\"));", "pos = appendData(pos, end, state.serverPort);", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_SOFTWARE\"));", "pos = appendData(pos, end, serverSoftware);", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"SERVER_PROTOCOL\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP/1.1\"));", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_ADDR\"));", "if (state.remoteAddr != NULL) {", "pos = appendData(pos, end, state.remoteAddr);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"127.0.0.1\"));", "}", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_PORT\"));", "if (state.remotePort != NULL) {", "pos = appendData(pos, end, state.remotePort);", "pos = appendData(pos, end, \"\", 1);", "} else {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"0\"));", "}", "", "if (state.remoteUser != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"REMOTE_USER\"));", "pos = appendData(pos, end, state.remoteUser);", "pos = appendData(pos, end, \"\", 1);", "}", "", "if (state.contentType != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_TYPE\"));", "pos = appendData(pos, end, state.contentType);", "pos = appendData(pos, end, \"\", 1);", "}", "", "if (state.contentLength != NULL) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"CONTENT_LENGTH\"));", "pos = appendData(pos, end, state.contentLength);", "pos = appendData(pos, end, \"\", 1);", "}", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_CONNECT_PASSWORD\"));", "pos = appendData(pos, end, req->session->getApiKey().toStaticString());", "pos = appendData(pos, end, \"\", 1);", "", "if (req->https) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTPS\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"on\"));", "}", "", "if (req->options.analytics) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_TXN_ID\"));", "pos = appendData(pos, end, req->options.transaction->getTxnId());", "pos = appendData(pos, end, \"\", 1);", "", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"PASSENGER_DELTA_MONOTONIC\"));", "pos = appendData(pos, end, delta_monotonic);", "pos = appendData(pos, end, \"\", 1);", "}", "", "if (req->upgraded()) {", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"HTTP_CONNECTION\"));", "pos = appendData(pos, end, P_STATIC_STRING_WITH_NULL(\"upgrade\"));", "}", "", "ServerKit::HeaderTable::Iterator it(req->headers);", "while (*it != NULL) {", "if ((it->header->hash == HTTP_CONTENT_LENGTH.hash()", "|| it->header->hash == HTTP_CONTENT_TYPE.hash()", "|| it->header->hash == HTTP_CONNECTION.hash())", "&& (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))", "|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))", "|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))))", "{", "it.next();", "continue;", "}", "", "pos = appendData(pos, end, P_STATIC_STRING(\"HTTP_\"));", "const LString::Part *part = it->header->key.start;", "while (part != NULL) {", "char *start = pos;", "pos = appendData(pos, end, part->data, part->size);", "httpHeaderToScgiUpperCase((unsigned char *) start, pos - start);", "part = part->next;", "}", "pos = appendData(pos, end, \"\", 1);", "", "part = it->header->val.start;", "while (part != NULL) {", "pos = appendData(pos, end, part->data, part->size);", "part = part->next;", "}", "pos = appendData(pos, end, \"\", 1);", "", "it.next();", "}", "", "if (state.environmentVariablesData != NULL) {", "pos = appendData(pos, end, state.environmentVariablesData, state.environmentVariablesSize);", "}", "", "Uint32Message::generate(buffer, pos - buffer - sizeof(boost::uint32_t));", "", "size = pos - buffer;", "return pos < end;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  MediaControlsProgressView::MediaControlsProgressView(", "      base::RepeatingCallback<void(double)> seek_callback)", "      : seek_callback_(std::move(seek_callback)) {", "    SetLayoutManager(std::make_unique<views::BoxLayout>(", "      views::BoxLayout::Orientation::kVertical, kProgressViewInsets));", "       views::BoxLayout::Orientation::kVertical, kProgressViewInsets,", "       kProgressBarAndTimeSpacing));", "  ", "  progress_bar_ = AddChildView(std::make_unique<views::ProgressBar>(5, false));", "  progress_bar_->SetBorder(views::CreateEmptyBorder(kProgressBarInsets));", "   progress_bar_ = AddChildView(", "       std::make_unique<views::ProgressBar>(kProgressBarHeight, false));", "  ", "    gfx::Font default_font;", "   int font_size_delta = kProgressTimeFontSize - default_font.GetFontSize();", "   gfx::Font font = default_font.Derive(font_size_delta, gfx::Font::NORMAL,", "                                        gfx::Font::Weight::NORMAL);", "   gfx::FontList font_list(font);", " ", "   auto time_view = std::make_unique<views::View>();", "   auto* time_view_layout =", "       time_view->SetLayoutManager(std::make_unique<views::FlexLayout>());", "   time_view_layout->SetOrientation(views::LayoutOrientation::kHorizontal)", "       .SetMainAxisAlignment(views::LayoutAlignment::kCenter)", "       .SetCrossAxisAlignment(views::LayoutAlignment::kCenter)", "       .SetCollapseMargins(true);", " ", "   auto progress_time = std::make_unique<views::Label>();", "   progress_time->SetFontList(font_list);", "   progress_time->SetEnabledColor(SK_ColorWHITE);", "   progress_time->SetAutoColorReadabilityEnabled(false);", "   progress_time_ = time_view->AddChildView(std::move(progress_time));", " ", "   auto time_spacing = std::make_unique<views::View>();", "   time_spacing->SetPreferredSize(kTimeSpacingSize);", "   time_spacing->SetProperty(views::kFlexBehaviorKey,", "                             views::FlexSpecification::ForSizeRule(", "                                 views::MinimumFlexSizeRule::kPreferred,", "                                 views::MaximumFlexSizeRule::kUnbounded));", "   time_view->AddChildView(std::move(time_spacing));", " ", "   auto duration = std::make_unique<views::Label>();", "   duration->SetFontList(font_list);", "   duration->SetEnabledColor(SK_ColorWHITE);", "   duration->SetAutoColorReadabilityEnabled(false);", "   duration_ = time_view->AddChildView(std::move(duration));", " ", "   AddChildView(std::move(time_view));", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(", "      mojom::PaymentHandlerResponsePtr response) {", "  DCHECK(delegate_);", "    if (delegate_ != nullptr) {", "      delegate_->OnInstrumentDetailsReady(response->method_name,", "                                          response->stringified_details);", "     delegate_ = nullptr;", "   }", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHP_FUNCTION(openssl_seal)", " {", " \tzval *pubkeys, *pubkey, *sealdata, *ekeys, *iv = NULL;", " \tHashTable *pubkeysht;", " \tEVP_PKEY **pkeys;", " \tzend_resource ** key_resources;\t ", " \tint i, len1, len2, *eksl, nkeys, iv_len;", " \tunsigned char iv_buf[EVP_MAX_IV_LENGTH + 1], *buf = NULL, **eks;", " \tchar * data;", " \tsize_t data_len;", " \tchar *method =NULL;", " \tsize_t method_len = 0;", " \tconst EVP_CIPHER *cipher;", " \tEVP_CIPHER_CTX *ctx;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/z/a/|sz/\", &data, &data_len,", " \t\t\t\t&sealdata, &ekeys, &pubkeys, &method, &method_len, &iv) == FAILURE) {", " \t\treturn;", " \t}", " \tpubkeysht = Z_ARRVAL_P(pubkeys);", " \tnkeys = pubkeysht ? zend_hash_num_elements(pubkeysht) : 0;", " \tif (!nkeys) {", " \t\tphp_error_docref(NULL, E_WARNING, \"Fourth argument to openssl_seal() must be a non-empty array\");", " \t\tRETURN_FALSE;", " \t}", " ", " \tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);", " ", " \tif (method) {", " \t\tcipher = EVP_get_cipherbyname(method);", " \t\tif (!cipher) {", " \t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");", " \t\t\tRETURN_FALSE;", " \t\t}", " \t} else {", " \t\tcipher = EVP_rc4();", " \t}", " ", " \tiv_len = EVP_CIPHER_iv_length(cipher);", " \tif (!iv && iv_len > 0) {", " \t\tphp_error_docref(NULL, E_WARNING,", " \t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");", " \t\tRETURN_FALSE;", " \t}", " ", " \tpkeys = safe_emalloc(nkeys, sizeof(*pkeys), 0);", " \teksl = safe_emalloc(nkeys, sizeof(*eksl), 0);", " \teks = safe_emalloc(nkeys, sizeof(*eks), 0);", " \tmemset(eks, 0, sizeof(*eks) * nkeys);", " \tkey_resources = safe_emalloc(nkeys, sizeof(zend_resource*), 0);", " \tmemset(key_resources, 0, sizeof(zend_resource*) * nkeys);", " \tmemset(pkeys, 0, sizeof(*pkeys) * nkeys);", " ", " \t ", " \ti = 0;", " \tZEND_HASH_FOREACH_VAL(pubkeysht, pubkey) {", " \t\tpkeys[i] = php_openssl_evp_from_zval(pubkey, 1, NULL, 0, 0, &key_resources[i]);", " \t\tif (pkeys[i] == NULL) {", " \t\t\tphp_error_docref(NULL, E_WARNING, \"not a public key (%dth member of pubkeys)\", i+1);", " \t\t\tRETVAL_FALSE;", " \t\t\tgoto clean_exit;", " \t\t}", " \t\teks[i] = emalloc(EVP_PKEY_size(pkeys[i]) + 1);", " \t\ti++;", " \t} ZEND_HASH_FOREACH_END();", " ", " \tctx = EVP_CIPHER_CTX_new();", " \tif (ctx == NULL || !EVP_EncryptInit(ctx,cipher,NULL,NULL)) {", " \t\tEVP_CIPHER_CTX_free(ctx);", " \t\tphp_openssl_store_errors();", " \t\tRETVAL_FALSE;", " \t\tgoto clean_exit;", " \t}", " ", " \t ", "         buf = emalloc(data_len + EVP_CIPHER_CTX_block_size(ctx));", "         EVP_CIPHER_CTX_cleanup(ctx);", "  ", "       if (!EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) ||", "        if (EVP_SealInit(ctx, cipher, eks, eksl, &iv_buf[0], pkeys, nkeys) <= 0 ||", "                         !EVP_SealUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) ||", "                         !EVP_SealFinal(ctx, buf + len1, &len2)) {", "                 efree(buf);", " \t\tEVP_CIPHER_CTX_free(ctx);", " \t\tphp_openssl_store_errors();", " \t\tRETVAL_FALSE;", " \t\tgoto clean_exit;", " \t}", " ", " \tif (len1 + len2 > 0) {", " \t\tzval_dtor(sealdata);", " \t\tZVAL_NEW_STR(sealdata, zend_string_init((char*)buf, len1 + len2, 0));", " \t\tefree(buf);", " ", " \t\tzval_dtor(ekeys);", " \t\tarray_init(ekeys);", " \t\tfor (i=0; i<nkeys; i++) {", " \t\t\teks[i][eksl[i]] = '\\0';", " \t\t\tadd_next_index_stringl(ekeys, (const char*)eks[i], eksl[i]);", " \t\t\tefree(eks[i]);", " \t\t\teks[i] = NULL;", " \t\t}", " ", " \t\tif (iv) {", " \t\t\tzval_dtor(iv);", " \t\t\tiv_buf[iv_len] = '\\0';", " \t\t\tZVAL_NEW_STR(iv, zend_string_init((char*)iv_buf, iv_len, 0));", " \t\t}", " \t} else {", " \t\tefree(buf);", " \t}", " \tRETVAL_LONG(len1 + len2);", " \tEVP_CIPHER_CTX_free(ctx);", " ", " clean_exit:", " \tfor (i=0; i<nkeys; i++) {", " \t\tif (key_resources[i] == NULL && pkeys[i] != NULL) {", " \t\t\tEVP_PKEY_free(pkeys[i]);", " \t\t}", " \t\tif (eks[i]) {", " \t\t\tefree(eks[i]);", " \t\t}", " \t}", " \tefree(eks);", " \tefree(eksl);", " \tefree(pkeys);", " \tefree(key_resources);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool AddPolicyForGPU(CommandLine* cmd_line, sandbox::TargetPolicy* policy) {", " #if !defined(NACL_WIN64)   ", "   if (base::win::GetVersion() > base::win::VERSION_SERVER_2003) {", "     if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==", "         gfx::kGLImplementationDesktopName) {", "       policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                             sandbox::USER_LIMITED);", "       policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);", "       policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);", "     } else {", "       if (cmd_line->GetSwitchValueASCII(switches::kUseGL) ==", "           gfx::kGLImplementationSwiftShaderName ||", "           cmd_line->HasSwitch(switches::kReduceGpuSandbox)) {", "         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                               sandbox::USER_LIMITED);", "         policy->SetJobLevel(sandbox::JOB_LIMITED_USER,", "                             JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS |", "                             JOB_OBJECT_UILIMIT_DESKTOP |", "                             JOB_OBJECT_UILIMIT_EXITWINDOWS |", "                             JOB_OBJECT_UILIMIT_DISPLAYSETTINGS);", "       } else {", "         policy->SetTokenLevel(sandbox::USER_RESTRICTED_SAME_ACCESS,", "                                sandbox::USER_RESTRICTED);", "          policy->SetJobLevel(sandbox::JOB_LOCKDOWN,", "                              JOB_OBJECT_UILIMIT_HANDLES);", "          ", "          ", "          ", "         policy->SetDelayedIntegrityLevel(sandbox::INTEGRITY_LEVEL_UNTRUSTED);", "        }", "  ", "        policy->SetIntegrityLevel(sandbox::INTEGRITY_LEVEL_LOW);", "     }", "   } else {", "     policy->SetJobLevel(sandbox::JOB_UNPROTECTED, 0);", "     policy->SetTokenLevel(sandbox::USER_UNPROTECTED,", "                           sandbox::USER_LIMITED);", "   }", " ", "   sandbox::ResultCode result = policy->AddRule(", "       sandbox::TargetPolicy::SUBSYS_NAMED_PIPES,", "       sandbox::TargetPolicy::NAMEDPIPES_ALLOW_ANY,", "       L\"\\\\\\\\.\\\\pipe\\\\chrome.gpu.*\");", "   if (result != sandbox::SBOX_ALL_OK)", "     return false;", " ", "   result = policy->AddRule(sandbox::TargetPolicy::SUBSYS_HANDLES,", "                            sandbox::TargetPolicy::HANDLES_DUP_ANY,", "                            L\"Section\");", "   if (result != sandbox::SBOX_ALL_OK)", "     return false;", " ", "   AddGenericDllEvictionPolicy(policy);", " #endif", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void sqlite3EndTable(", "Parse *pParse,", "Token *pCons,", "Token *pEnd,", "u8 tabOpts,", "Select *pSelect", "){", "Table *p;", "sqlite3 *db = pParse->db;", "int iDb;", "Index *pIdx;", "", "if( pEnd==0 && pSelect==0 ){", "return;", "}", "assert( !db->mallocFailed );", "p = pParse->pNewTable;", "if( p==0 ) return;", "", "if( pSelect==0 && isShadowTableName(db, p->zName) ){", "p->tabFlags |= TF_Shadow;", "}", "", "", "", "", "", "", "", "", "", "", "if( db->init.busy ){", "if( pSelect ){", "sqlite3ErrorMsg(pParse, \"\");", "return;", "}", "p->tnum = db->init.newTnum;", "if( p->tnum==1 ) p->tabFlags |= TF_Readonly;", "}", "", "assert( (p->tabFlags & TF_HasPrimaryKey)==0", "|| p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );", "assert( (p->tabFlags & TF_HasPrimaryKey)!=0", "|| (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );", "", "", "if( tabOpts & TF_WithoutRowid ){", "if( (p->tabFlags & TF_Autoincrement) ){", "sqlite3ErrorMsg(pParse,", "\"AUTOINCREMENT not allowed on WITHOUT ROWID tables\");", "return;", "}", "if( (p->tabFlags & TF_HasPrimaryKey)==0 ){", "sqlite3ErrorMsg(pParse, \"PRIMARY KEY missing on table %s\", p->zName);", "return;", "}", "p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;", "convertToWithoutRowidTable(pParse, p);", "}", "iDb = sqlite3SchemaToIndex(db, p->pSchema);", "", "#ifndef SQLITE_OMIT_CHECK", "", "", "if( p->pCheck ){", "sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);", "}", "#endif /* !defined(SQLITE_OMIT_CHECK) */", "#ifndef SQLITE_OMIT_GENERATED_COLUMNS", "if( p->tabFlags & TF_HasGenerated ){", "int ii, nNG = 0;", "testcase( p->tabFlags & TF_HasVirtual );", "testcase( p->tabFlags & TF_HasStored );", "for(ii=0; ii<p->nCol; ii++){", "u32 colFlags = p->aCol[ii].colFlags;", "if( (colFlags & COLFLAG_GENERATED)!=0 ){", "testcase( colFlags & COLFLAG_VIRTUAL );", "testcase( colFlags & COLFLAG_STORED );", "sqlite3ResolveSelfReference(pParse, p, NC_GenCol,", "p->aCol[ii].pDflt, 0);", "}else{", "nNG++;", "}", "}", "if( nNG==0 ){", "sqlite3ErrorMsg(pParse, \"must have at least one non-generated column\");", "return;", "}", "}", "#endif", "", "", "estimateTableWidth(p);", "for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){", "estimateIndexWidth(pIdx);", "}", "", "", "", "", "", "", "", "if( !db->init.busy ){", "int n;", "Vdbe *v;", "char *zType;", "char *zType2;", "char *zStmt;", "", "v = sqlite3GetVdbe(pParse);", "if( NEVER(v==0) ) return;", "", "sqlite3VdbeAddOp1(v, OP_Close, 0);", "", "", "", "", "if( p->pSelect==0 ){", "", "zType = \"table\";", "zType2 = \"TABLE\";", "#ifndef SQLITE_OMIT_VIEW", "}else{", "", "zType = \"view\";", "zType2 = \"VIEW\";", "#endif", "}", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "if( pSelect ){", "SelectDest dest;", "int regYield;", "int addrTop;", "int regRec;", "int regRowid;", "int addrInsLoop;", "Table *pSelTab;", "", "regYield = ++pParse->nMem;", "regRec = ++pParse->nMem;", "regRowid = ++pParse->nMem;", "assert(pParse->nTab==1);", "sqlite3MayAbort(pParse);", "sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);", "sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);", "pParse->nTab = 2;", "addrTop = sqlite3VdbeCurrentAddr(v) + 1;", "sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);", "if( pParse->nErr ) return;", "pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);", "if( pSelTab==0 ) return;", "assert( p->aCol==0 );", "p->nCol = p->nNVCol = pSelTab->nCol;", "p->aCol = pSelTab->aCol;", "pSelTab->nCol = 0;", "pSelTab->aCol = 0;", "sqlite3DeleteTable(db, pSelTab);", "sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);", "sqlite3Select(pParse, pSelect, &dest);", "if( pParse->nErr ) return;", "sqlite3VdbeEndCoroutine(v, regYield);", "sqlite3VdbeJumpHere(v, addrTop - 1);", "addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);", "VdbeCoverage(v);", "sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);", "sqlite3TableAffinity(v, p, 0);", "sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);", "sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);", "sqlite3VdbeGoto(v, addrInsLoop);", "sqlite3VdbeJumpHere(v, addrInsLoop);", "sqlite3VdbeAddOp1(v, OP_Close, 1);", "}", "", "", "if( pSelect ){", "zStmt = createTableStmt(db, p);", "}else{", "Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;", "n = (int)(pEnd2->z - pParse->sNameToken.z);", "if( pEnd2->z[0]!=';' ) n += pEnd2->n;", "zStmt = sqlite3MPrintf(db,", "\"CREATE %s %.*s\", zType2, n, pParse->sNameToken.z", ");", "}", "", "", "", "", "", "sqlite3NestedParse(pParse,", "\"UPDATE %Q.%s \"", "\"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"", "\"WHERE rowid=#%d\",", "db->aDb[iDb].zDbSName, MASTER_NAME,", "zType,", "p->zName,", "p->zName,", "pParse->regRoot,", "zStmt,", "pParse->regRowid", ");", "sqlite3DbFree(db, zStmt);", "sqlite3ChangeCookie(pParse, iDb);", "", "#ifndef SQLITE_OMIT_AUTOINCREMENT", "", "", "", "if( (p->tabFlags & TF_Autoincrement)!=0 ){", "Db *pDb = &db->aDb[iDb];", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "if( pDb->pSchema->pSeqTab==0 ){", "sqlite3NestedParse(pParse,", "\"CREATE TABLE %Q.sqlite_sequence(name,seq)\",", "pDb->zDbSName", ");", "}", "}", "#endif", "", "", "sqlite3VdbeAddParseSchemaOp(v, iDb,", "sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName));", "}", "", "", "", "if( db->init.busy ){", "Table *pOld;", "Schema *pSchema = p->pSchema;", "assert( sqlite3SchemaMutexHeld(db, iDb, 0) );", "pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);", "if( pOld ){", "assert( p==pOld );", "sqlite3OomFault(db);", "return;", "}", "pParse->pNewTable = 0;", "db->mDbFlags |= DBFLAG_SchemaChange;", "", "#ifndef SQLITE_OMIT_ALTERTABLE", "if( !p->pSelect ){", "const char *zName = (const char *)pParse->sNameToken.z;", "int nName;", "assert( !pSelect && pCons && pEnd );", "if( pCons->z==0 ){", "pCons = pEnd;", "}", "nName = (int)((const char *)pCons->z - zName);", "p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);", "}", "#endif", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" \t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)", " \t\t{", " \t\t\tstd::string idx = request::findValue(&req, \"idx\");", " \t\t\tif (idx == \"\") {", "  \t\t\t\treturn;", "  \t\t\t}", "  \t\t\tstd::vector<std::vector<std::string> > result;", "\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());", " \t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));", "  \t\t\tif (result.empty())", "  \t\t\t\treturn;", "  \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());", " \t\t\tstd::string oname = \"floorplan\";", " \t\t\tif (result[0][0].size() > 10)", " \t\t\t{", " \t\t\t\tif (result[0][0][0] == 'P')", " \t\t\t\t\toname += \".png\";", " \t\t\t\telse if (result[0][0][0] == -1)", " \t\t\t\t\toname += \".jpg\";", " \t\t\t\telse if (result[0][0][0] == 'B')", " \t\t\t\t\toname += \".bmp\";", " \t\t\t\telse if (result[0][0][0] == 'G')", " \t\t\t\t\toname += \".gif\";", " \t\t\t}", " \t\t\treply::add_header_attachment(&rep, oname);", " \t\t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadOTBImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", " #define GetBit(a,i) (((a) >> (i)) & 1L)", " ", "   Image", "     *image;", " ", "   int", "     byte;", " ", "   MagickBooleanType", "     status;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   ssize_t", "     y;", " ", "   unsigned char", "     bit,", "     info,", "     depth;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   info=(unsigned char) ReadBlobByte(image);", "   if (GetBit(info,4) == 0)", "     {", "       image->columns=(size_t) ReadBlobByte(image);", "       image->rows=(size_t) ReadBlobByte(image);", "     }", "   else", "     {", "       image->columns=(size_t) ReadBlobMSBShort(image);", "       image->rows=(size_t) ReadBlobMSBShort(image);", "     }", "   if ((image->columns == 0) || (image->rows == 0))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   depth=(unsigned char) ReadBlobByte(image);", "   if (depth != 1)", "     ThrowReaderException(CoderError,\"OnlyLevelZerofilesSupported\");", "   if (AcquireImageColormap(image,2) == MagickFalse)", "     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "   if (image_info->ping != MagickFalse)", "     {", "        (void) CloseBlob(image);", "        return(GetFirstImageInList(image));", "      }", "   status=SetImageExtent(image,image->columns,image->rows);", "   if (status == MagickFalse)", "     {", "       InheritException(exception,&image->exception);", "       return(DestroyImageList(image));", "     }", "     ", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "     if (q == (PixelPacket *) NULL)", "       break;", "     indexes=GetAuthenticIndexQueue(image);", "     bit=0;", "     byte=0;", "     for (x=0; x < (ssize_t) image->columns; x++)", "     {", "       if (bit == 0)", "         {", "           byte=ReadBlobByte(image);", "           if (byte == EOF)", "             ThrowReaderException(CorruptImageError,\"CorruptImage\");", "         }", "       SetPixelIndex(indexes+x,(byte & (0x01 << (7-bit))) ?", "         0x00 : 0x01);", "       bit++;", "       if (bit == 8)", "         bit=0;", "     }", "     if (SyncAuthenticPixels(image,exception) == MagickFalse)", "       break;", "     if (image->previous == (Image *) NULL)", "       {", "         status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "         if (status == MagickFalse)", "           break;", "       }", "   }", "   (void) SyncImage(image);", "   if (EOFBlob(image) != MagickFalse)", "     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "       image->filename);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {", "    int number, str_len = 0;", "    xmlChar *str = NULL, *ret = NULL, *tmp;", "     int number, str_len = 0, str_size = 0;", "     xmlChar *str = NULL, *ret = NULL;", "  ", "      if ((nargs < 1) || (nargs > 2)) {", "  \txmlXPathSetArityError(ctxt);", " \treturn;", "     }", " ", "      if (nargs == 2) {", "  \tstr = xmlXPathPopString(ctxt);", "  \tstr_len = xmlUTF8Strlen(str);", " \tstr_size = xmlStrlen(str);", "      }", "      if (str_len == 0) {", "  \tif (str != NULL) xmlFree(str);", "  \tstr = xmlStrdup((const xmlChar *) \" \");", "  \tstr_len = 1;", " \tstr_size = 1;", "      }", "  ", "      number = (int) xmlXPathPopNumber(ctxt);", " ", "     if (number <= 0) {", " \txmlXPathReturnEmptyString(ctxt);", " \txmlFree(str);", " \treturn;", "      }", "  ", "      while (number >= str_len) {", "\tret = xmlStrncat(ret, str, str_len);", " \tret = xmlStrncat(ret, str, str_size);", "  \tnumber -= str_len;", "      }", "    tmp = xmlUTF8Strndup (str, number);", "    ret = xmlStrcat(ret, tmp);", "    if (tmp != NULL)", "\txmlFree (tmp);", "     if (number > 0) {", " \tstr_size = xmlUTF8Strsize(str, number);", " \tret = xmlStrncat(ret, str, str_size);", "     }", "  ", "      xmlXPathReturnString(ctxt, ret);", "  ", "     if (str != NULL)", " \txmlFree(str);", " }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  TransportDIB* TransportDIB::Create(size_t size, uint32 sequence_num) {", "  const int shmkey = shmget(IPC_PRIVATE, size, 0666);", "   const int shmkey = shmget(IPC_PRIVATE, size, 0600);", "    if (shmkey == -1) {", "      DLOG(ERROR) << \"Failed to create SysV shared memory region\"", "                  << \" errno:\" << errno;", "      return NULL;", "   } else {", "     VLOG(1) << \"Created SysV shared memory region \" << shmkey;", "    }", "  ", "    void* address = shmat(shmkey, NULL  , 0  );", "   shmctl(shmkey, IPC_RMID, 0);", "   if (address == kInvalidAddress)", "     return NULL;", " ", "   TransportDIB* dib = new TransportDIB;", " ", "   dib->key_.shmkey = shmkey;", "   dib->address_ = address;", "   dib->size_ = size;", "   return dib;", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext *ctx) override {", "const Tensor *indices_t, *values_t, *shape_t, *dense_t;", "OP_REQUIRES_OK(ctx, ctx->input(\"sp_indices\", &indices_t));", "OP_REQUIRES_OK(ctx, ctx->input(\"sp_values\", &values_t));", "OP_REQUIRES_OK(ctx, ctx->input(\"sp_shape\", &shape_t));", "OP_REQUIRES_OK(ctx, ctx->input(\"dense\", &dense_t));", "", "", "OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices_t->shape()),", "errors::InvalidArgument(", "\"Input sp_indices should be a matrix but received shape: \",", "indices_t->shape().DebugString()));", "OP_REQUIRES(ctx,", "TensorShapeUtils::IsVector(values_t->shape()) &&", "TensorShapeUtils::IsVector(shape_t->shape()),", "errors::InvalidArgument(", "\"Inputs sp_values and sp_shape should be vectors \"", "\"but received shapes: \",", "values_t->shape().DebugString(), \" and \",", "shape_t->shape().DebugString()));", "OP_REQUIRES(", "ctx, TensorShapeUtils::IsVector(shape_t->shape()),", "errors::InvalidArgument(\"Input sp_shape must be a vector. Got: \",", "shape_t->shape().DebugString()));", "OP_REQUIRES(", "ctx, values_t->dim_size(0) == indices_t->dim_size(0),", "errors::InvalidArgument(", "\"The first dimension of values and indices should match. (\",", "values_t->dim_size(0), \" vs. \", indices_t->dim_size(0), \")\"));", "OP_REQUIRES(", "ctx, shape_t->shape().dim_size(0) == indices_t->shape().dim_size(1),", "errors::InvalidArgument(", "\"Number of dimensions must match second dimension of indices. \",", "\"Got \", shape_t->shape().dim_size(0),", "\" dimensions, indices shape: \", indices_t->shape().DebugString()));", "OP_REQUIRES(ctx, shape_t->NumElements() > 0,", "errors::InvalidArgument(", "\"The shape argument requires at least one element.\"));", "", "const auto indices_mat = indices_t->matrix<int64_t>();", "const auto shape_vec = shape_t->vec<int64_t>();", "const auto lhs_dims = BCast::FromShape(TensorShape(shape_vec));", "const auto rhs_dims = BCast::FromShape(dense_t->shape());", "BCast b(lhs_dims, rhs_dims, false);", "", "", "", "auto VecGreaterEq = [](ArraySlice<int64_t> lhs, ArraySlice<int64_t> rhs) {", "if (lhs.size() < rhs.size()) return false;", "for (size_t i = 0; i < rhs.size(); ++i) {", "if (lhs[lhs.size() - 1 - i] < rhs[rhs.size() - 1 - i]) return false;", "}", "return true;", "};", "OP_REQUIRES(ctx, VecGreaterEq(lhs_dims, rhs_dims) && b.IsValid(),", "errors::InvalidArgument(", "\"SparseDenseBinaryOpShared broadcasts dense to sparse \"", "\"only; got incompatible shapes: [\",", "absl::StrJoin(lhs_dims, \",\"), \"] vs. [\",", "absl::StrJoin(rhs_dims, \",\"), \"]\"));", "", "Tensor *output_values = nullptr;", "Tensor dense_gathered;", "const int64_t nnz = indices_t->dim_size(0);", "OP_REQUIRES_OK(ctx,", "ctx->allocate_output(0, TensorShape({nnz}), &output_values));", "OP_REQUIRES_OK(", "ctx, ctx->allocate_temp(DataTypeToEnum<T>::value, TensorShape({nnz}),", "&dense_gathered));", "bool op_is_div = false;", "if (absl::StrContains(ctx->op_kernel().type_string_view(), \"Div\")) {", "op_is_div = true;", "}", "", "", "", "", "", "", "auto dense_gathered_flat = dense_gathered.flat<T>();", "const int ndims = lhs_dims.size();", "switch (ndims) {", "#define CASE(NDIM)                                                             \\", "  case NDIM: {                                                                 \\", "    TensorRef<Eigen::Tensor<const T, NDIM, Eigen::RowMajor>> rhs_ref =         \\", "        dense_t->shaped<T, NDIM>(b.y_reshape())                                \\", "            .broadcast(BCast::ToIndexArray<NDIM>(b.y_bcast()));                \\", "    Eigen::array<Eigen::DenseIndex, NDIM> idx;                                 \\", "    bool indices_valid = true;                                                 \\", "    for (int i = 0; i < nnz; ++i) {                                            \\", "      for (int d = 0; d < NDIM; ++d) {                                         \\", "        idx[d] = internal::SubtleMustCopy(indices_mat(i, d));                  \\", "        if (!FastBoundsCheck(idx[d], rhs_ref.dimension(d))) {                  \\", "          indices_valid = false;                                               \\", "        }                                                                      \\", "      }                                                                        \\", "      OP_REQUIRES(                                                             \\", "          ctx, indices_valid,                                                  \\", "          errors::InvalidArgument(\"Provided indices are out-of-bounds w.r.t. \" \\", "                                  \"dense side with broadcasted shape\"));       \\", "      dense_gathered_flat(i) = rhs_ref.coeff(idx);                             \\", "      if (op_is_div) {                                                         \\", "        OP_REQUIRES(ctx, dense_gathered_flat(i) != 0,                          \\", "                    errors::InvalidArgument(                                   \\", "                        \"SparseDenseCwiseDiv cannot divide by zero,\"           \\", "                        \"but input dense tensor contains zero \"));             \\", "      }                                                                        \\", "    }                                                                          \\", "    break;                                                                     \\", "  }", "", "CASE(1);", "CASE(2);", "CASE(3);", "CASE(4);", "CASE(5);", "default:", "OP_REQUIRES(", "ctx, false,", "errors::InvalidArgument(\"Only tensors with ranks between 1 and 5 \"", "\"are currently supported.  Tensor rank: \",", "ndims));", "#undef CASE", "}", "", "output_values->flat<T>().device(ctx->eigen_device<Device>()) =", "values_t->flat<T>().binaryExpr(dense_gathered_flat,", "typename Functor::func());", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" const SystemProfileProto& MetricsLog::RecordEnvironment(", "     DelegatingProvider* delegating_provider) {", "   DCHECK(!has_environment_);", "   has_environment_ = true;", " ", "   SystemProfileProto* system_profile = uma_proto()->mutable_system_profile();", " ", "   WriteMetricsEnableDefault(client_->GetMetricsReportingDefaultState(),", "                             system_profile);", " ", "   std::string brand_code;", "    if (client_->GetBrand(&brand_code))", "      system_profile->set_brand_code(brand_code);", "  ", "  SystemProfileProto::Hardware::CPU* cpu =", "      system_profile->mutable_hardware()->mutable_cpu();", "  base::CPU cpu_info;", "  cpu->set_vendor_name(cpu_info.vendor_name());", "  cpu->set_signature(cpu_info.signature());", "  cpu->set_num_cores(base::SysInfo::NumberOfProcessors());", "    delegating_provider->ProvideSystemProfileMetrics(system_profile);", "  ", "    return *system_profile;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char **argv) {", "  if (!parse_args(argc, argv)) {", "     usage(argv[0]);", "  }", " ", "  if (bond && discoverable) {", "     fprintf(stderr, \"Can only select either bond or discoverable, not both\\n\");", "     usage(argv[0]);", "  }", " ", "  if (sco_listen && sco_connect) {", "     fprintf(stderr, \"Can only select either sco_listen or sco_connect, not both\\n\");", "     usage(argv[0]);", "  }", " ", "  if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {", "     fprintf(stderr, \"Must specify one command\\n\");", "     usage(argv[0]);", "  }", " ", "  if (signal(SIGINT, sig_handler) == SIG_ERR) {", "     fprintf(stderr, \"Will be unable to catch signals\\n\");", "  }", " ", "   fprintf(stdout, \"Bringing up bluetooth adapter\\n\");", "  if (!hal_open(callbacks_get_adapter_struct())) {", "     fprintf(stderr, \"Unable to open Bluetooth HAL.\\n\");", "  return 1;", " ", "    }", "  ", "    if (discover) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      fprintf(stdout, \"Starting to start discovery\\n\");", "     CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);", "     fprintf(stdout, \"Started discovery for %d seconds\\n\", timeout_in_sec);", " ", "     sleep(timeout_in_sec);", " ", "     fprintf(stdout, \"Starting to cancel discovery\\n\");", "     CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);", "     fprintf(stdout, \"Cancelled discovery after %d seconds\\n\", timeout_in_sec);", " ", "    }", "  ", "    if (discoverable) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);", " ", "  int rc = bt_interface->set_adapter_property(property);", "     fprintf(stdout, \"Set rc:%d device as discoverable for %d seconds\\n\", rc, timeout_in_sec);", " ", "     sleep(timeout_in_sec);", " ", "     property_free(property);", "  }", " ", "  if (bond) {", "  if (bdaddr_is_empty(&bt_remote_bdaddr)) {", "       fprintf(stderr, \"Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\\n\");", " ", "        exit(1);", "      }", "  ", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0  );", "     fprintf(stdout, \"Started bonding:%d for %d seconds\\n\", rc, timeout_in_sec);", " ", "     sleep(timeout_in_sec);", " ", "    }", "  ", "    if (up) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      fprintf(stdout, \"Waiting for %d seconds\\n\", timeout_in_sec);", "     sleep(timeout_in_sec);", " ", "    }", "  ", "    if (get_name) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "      int error;", "      CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to get adapter property\\n\");", "       exit(1);", "  }", "  bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);", "  const bt_bdname_t *name = property_as_name(property);", "  if (name)", "       printf(\"Queried bluetooth device name:%s\\n\", name->name);", "  else", "       printf(\"No name\\n\");", " ", "    }", "  ", "    if (set_name) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      bt_property_t *property = property_new_name(bd_name);", "     printf(\"Setting bluetooth device name to:%s\\n\", bd_name);", "  int error;", "     CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to set adapter property\\n\");", "       exit(1);", "  }", "     CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to get adapter property\\n\");", "       exit(1);", "  }", "     property_free(property);", "     sleep(timeout_in_sec);", " ", "    }", "  ", "    if (sco_listen) {", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);", "     CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);", "     property_free(property);", " ", "  const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);", " ", "  int rfcomm_fd = INVALID_FD;", "  int error = sock->listen(BTSOCK_RFCOMM, \"meow\", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to listen for incoming RFCOMM socket: %d\\n\", error);", "       exit(1);", "  }", " ", "  int sock_fd = INVALID_FD;", "     error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to listen for incoming SCO sockets: %d\\n\", error);", "       exit(1);", "  }", "     fprintf(stdout, \"Waiting for incoming SCO connections...\\n\");", "     sleep(timeout_in_sec);", "  }", " ", "  if (sco_connect) {", "  if (bdaddr_is_empty(&bt_remote_bdaddr)) {", "       fprintf(stderr, \"Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\\n\");", " ", "        exit(1);", "      }", "  ", "    CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed);", "     CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);", "      fprintf(stdout, \"BT adapter is up\\n\");", "  ", "      const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);", " ", "  int rfcomm_fd = INVALID_FD;", "  int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to connect to RFCOMM socket: %d.\\n\", error);", "       exit(1);", "  }", " ", "     WAIT(acl_state_changed);", " ", "     fprintf(stdout, \"Establishing SCO connection...\\n\");", " ", "  int sock_fd = INVALID_FD;", "     error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);", "  if (error != BT_STATUS_SUCCESS) {", "       fprintf(stderr, \"Unable to connect to SCO socket: %d.\\n\", error);", "       exit(1);", "  }", "     sleep(timeout_in_sec);", "  }", " ", "   CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);", "   fprintf(stdout, \"BT adapter is down\\n\");", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" string16 ExtensionInstallUI::Prompt::GetDialogTitle(", "     const Extension* extension) const {", "   if (type_ == INSTALL_PROMPT) {", "      return l10n_util::GetStringUTF16(extension->is_app() ?", "          IDS_EXTENSION_INSTALL_APP_PROMPT_TITLE :", "          IDS_EXTENSION_INSTALL_EXTENSION_PROMPT_TITLE);", "  } else if (type_ == INLINE_INSTALL_PROMPT) {", "    return l10n_util::GetStringFUTF16(", "      kTitleIds[type_], l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));", "    } else {", "      return l10n_util::GetStringUTF16(kTitleIds[type_]);", "    }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)", " {", "    size_t", "      extent;", "  ", "  if (CheckMemoryOverflow(count,quantum) != MagickFalse)", "   if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)", "      return((void *) NULL);", "    extent=count*quantum;", "    return(AcquireMagickMemory(extent));", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["   void StoreExistingGroupExistingCache() {", " ", "      MakeCacheAndGroup(kManifestUrl, 1, 1, true);", "    EXPECT_EQ(kDefaultEntrySize, storage()->usage_map_[kOrigin]);", "     EXPECT_EQ(kDefaultEntrySize + kDefaultEntryPadding,", "               storage()->usage_map_[kOrigin]);", "  ", "      base::Time now = base::Time::Now();", "    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::MASTER, 1, 100));", "     cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT,", "                                                1,", "                                                100,", "                                                10));", "      cache_->set_update_time(now);", "  ", "      PushNextTask(base::BindOnce(", "         &AppCacheStorageImplTest::Verify_StoreExistingGroupExistingCache,", "         base::Unretained(this), now));", " ", "     EXPECT_EQ(cache_.get(), group_->newest_complete_cache());", "     storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());", "     EXPECT_FALSE(delegate()->stored_group_success_);", "   }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PYBIND11_MODULE(_pywrap_tfe, m) {", "py::class_<TFE_Executor> TFE_Executor_class(m, \"TFE_Executor\");", "py::class_<TFE_ContextOptions> TFE_ContextOptions_class(m,", "\"TFE_ContextOptions\");", "py::class_<TFE_MonitoringCounter0> TFE_MonitoringCounter0_class(", "m, \"TFE_MonitoringCounter0\");", "py::class_<TFE_MonitoringCounter1> TFE_MonitoringCounter1_class(", "m, \"TFE_MonitoringCounter1\");", "py::class_<TFE_MonitoringCounter2> TFE_MonitoringCounter2_class(", "m, \"TFE_MonitoringCounter2\");", "py::class_<TFE_MonitoringStringGauge0> TFE_MonitoringStringGauge0_class(", "m, \"TFE_MonitoringStringGauge0\");", "py::class_<TFE_MonitoringStringGauge1> TFE_MonitoringStringGauge1_class(", "m, \"TFE_MonitoringStringGauge1\");", "py::class_<TFE_MonitoringStringGauge2> TFE_MonitoringStringGauge2_class(", "m, \"TFE_MonitoringStringGauge2\");", "py::class_<TFE_MonitoringIntGauge0> TFE_MonitoringIntGauge0_class(", "m, \"TFE_MonitoringIntGauge0\");", "py::class_<TFE_MonitoringIntGauge1> TFE_MonitoringIntGauge1_class(", "m, \"TFE_MonitoringIntGauge1\");", "py::class_<TFE_MonitoringIntGauge2> TFE_MonitoringIntGauge2_class(", "m, \"TFE_MonitoringIntGauge2\");", "py::class_<TFE_MonitoringBoolGauge0> TFE_MonitoringBoolGauge0_class(", "m, \"TFE_MonitoringBoolGauge0\");", "py::class_<TFE_MonitoringBoolGauge1> TFE_MonitoringBoolGauge1_class(", "m, \"TFE_MonitoringBoolGauge1\");", "py::class_<TFE_MonitoringBoolGauge2> TFE_MonitoringBoolGauge2_class(", "m, \"TFE_MonitoringBoolGauge2\");", "py::class_<TFE_MonitoringCounterCell> TFE_MonitoringCounterCell_class(", "m, \"TFE_MonitoringCounterCell\");", "py::class_<TFE_MonitoringIntGaugeCell> TFE_MonitoringIntGaugeCell_class(", "m, \"TFE_MonitoringIntGaugeCell\");", "py::class_<TFE_MonitoringStringGaugeCell> TFE_MonitoringStringGaugeCell_class(", "m, \"TFE_MonitoringStringGaugeCell\");", "py::class_<TFE_MonitoringBoolGaugeCell> TFE_MonitoringBoolGaugeCell_class(", "m, \"TFE_MonitoringBoolGaugeCell\");", "py::class_<TFE_MonitoringSamplerCell> TFE_MonitoringSamplerCell_class(", "m, \"TFE_MonitoringSamplerCell\");", "py::class_<TFE_MonitoringBuckets> TFE_MonitoringBuckets_class(", "m, \"TFE_MonitoringBuckets\");", "py::class_<TFE_MonitoringSampler0> TFE_MonitoringSampler0_class(", "m, \"TFE_MonitoringSampler0\");", "py::class_<TFE_MonitoringSampler1> TFE_MonitoringSampler1_class(", "m, \"TFE_MonitoringSampler1\");", "py::class_<TFE_MonitoringSampler2> TFE_MonitoringSampler2_class(", "m, \"TFE_MonitoringSampler2\");", "py::class_<TFE_CancellationManager> TFE_CancellationManager_class(", "m, \"TFE_CancellationManager\");", "", "py::class_<TF_DeviceList> TF_DeviceList_class(m, \"TF_DeviceList\");", "py::class_<TF_Function> TF_Function_class(m, \"TF_Function\");", "", "m.def(\"TFE_Py_RegisterExceptionClass\", [](const py::handle& e) {", "return tensorflow::PyoOrThrow(TFE_Py_RegisterExceptionClass(e.ptr()));", "});", "m.def(\"TFE_Py_RegisterFallbackExceptionClass\", [](const py::handle& e) {", "return tensorflow::PyoOrThrow(", "TFE_Py_RegisterFallbackExceptionClass(e.ptr()));", "});", "", "m.def(", "\"TFE_GetTotalMemoryUsage\", [](py::handle& ctx, const char* device_name) {", "tensorflow::EagerContext* context = tensorflow::ContextFromInterface(", "reinterpret_cast<tensorflow::ImmediateExecutionContext*>(", "tensorflow::InputTFE_Context(ctx)));", "", "tensorflow::DeviceNameUtils::ParsedName input_device_name;", "if (!tensorflow::DeviceNameUtils::ParseFullOrLocalName(", "device_name, &input_device_name)) {", "tensorflow::ThrowValueError(", "absl::StrFormat(\"Failed parsing device name: '%s'\", device_name)", ".c_str());", "}", "", "std::vector<tensorflow::Device*> devices =", "context->local_device_mgr()->ListDevices();", "", "tensorflow::Device* matched_device = nullptr;", "for (int device_idx = 0; device_idx < devices.size(); device_idx++) {", "tensorflow::Device* device = devices[device_idx];", "", "if (tensorflow::DeviceNameUtils::AreCompatibleDevNames(", "input_device_name, device->parsed_name())) {", "if (device->device_type() == tensorflow::DEVICE_CPU) {", "tensorflow::ThrowValueError(", "\"CPU does not support getting allocator information\");", "}", "", "if (matched_device != nullptr) {", "tensorflow::ThrowValueError(", "absl::StrFormat(", "\"Multiple devices matching the provided string \"", "\"'%s': '%s' and \"", "\"'%s' \",", "device_name, matched_device->name(), device->name())", ".c_str());", "}", "matched_device = device;", "}", "}", "", "if (matched_device == nullptr) {", "tensorflow::ThrowValueError(", "absl::StrFormat(\"No matching devices found for '%s'\", device_name)", ".c_str());", "}", "", "tensorflow::AllocatorAttributes attrs;", "tensorflow::Allocator* allocator = matched_device->GetAllocator(attrs);", "", "if (absl::optional<tensorflow::AllocatorStats> stats =", "allocator->GetStats()) {", "return stats->bytes_in_use;", "}", "", "tensorflow::ThrowTypeError(", "absl::StrFormat(\"Allocator stats not available for device '%s'\",", "matched_device->name())", ".c_str());", "});", "", "", "m.def(\"TF_SetXlaEnableLazyCompilation\", &TF_SetXlaEnableLazyCompilation);", "m.def(\"TF_SetTfXlaCpuGlobalJit\", &TF_SetTfXlaCpuGlobalJit);", "m.def(\"TF_SetXlaAutoJitMode\", &TF_SetXlaAutoJitMode);", "m.def(\"TF_SetXlaConstantFoldingDisabled\", &TF_SetXlaConstantFoldingDisabled);", "m.def(\"TF_GetXlaConstantFoldingDisabled\", &TF_GetXlaConstantFoldingDisabled);", "m.def(\"TF_SetXlaMinClusterSize\", &TF_SetXlaMinClusterSize);", "m.def(\"TF_GetCompilerIr\", &tensorflow::TFE_GetCompilerIr);", "", "", "m.def(\"TF_IsMlirBridgeEnabled\", [] {", "return tensorflow::GetMlirCommonFlags()->tf_mlir_enable_mlir_bridge;", "});", "m.def(\"TF_EnableMlirBridge\", [](bool enabled) {", "tensorflow::GetMlirCommonFlags()->tf_mlir_enable_mlir_bridge = enabled;", "});", "m.def(\"TF_EnableXlaDevices\", [] {", "tensorflow::GetXlaDeviceFlags()->tf_xla_enable_xla_devices = true;", "});", "", "", "m.def(", "\"TFE_NewContext\",", "[](const TFE_ContextOptions* opts) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_Context* context = TFE_NewContext(opts, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return tensorflow::PyoOrThrow(tensorflow::OutputTFE_Context(context));", "},", "py::return_value_policy::reference);", "m.def(\"TFE_DeleteContext\", [](py::handle& o) {", "TFE_DeleteContext(tensorflow::InputTFE_Context(o));", "});", "m.def(", "\"TFE_ContextListDevices\",", "[](py::handle& o) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_ContextListDevices(tensorflow::InputTFE_Context(o),", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_HostAddressSpace\", [](py::handle& o, TF_Buffer& buf) {", "TFE_HostAddressSpace(tensorflow::InputTFE_Context(o), &buf);", "});", "m.def(\"TFE_ContextAddFunction\", [](py::handle& ctx, TF_Function* func) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextAddFunction(tensorflow::InputTFE_Context(ctx), func,", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextAddFunctionDef\",", "[](py::handle& ctx, const char* serialized_function_def, size_t size) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextAddFunctionDef(tensorflow::InputTFE_Context(ctx),", "serialized_function_def, size,", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextGetFunctionDef\",", "[](py::handle& ctx, const char* function_name, TF_Buffer& buf) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextGetFunctionDef(tensorflow::InputTFE_Context(ctx),", "function_name, &buf, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextRemoveFunction\", [](py::handle& ctx, const char* name) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextRemoveFunction(tensorflow::InputTFE_Context(ctx), name,", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextHasFunction\", [](py::handle& ctx, const char* name) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_ContextHasFunction(tensorflow::InputTFE_Context(ctx), name);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "});", "m.def(\"TFE_ContextEnableRunMetadata\", [](py::handle& ctx) {", "TFE_ContextEnableRunMetadata(tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextDisableRunMetadata\", [](py::handle& ctx) {", "TFE_ContextEnableRunMetadata(tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextEnableGraphCollection\", [](py::handle& ctx) {", "TFE_ContextEnableGraphCollection(tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextDisableGraphCollection\", [](py::handle& ctx) {", "TFE_ContextDisableGraphCollection(tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextExportRunMetadata\", [](py::handle& ctx, TF_Buffer& buf) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextExportRunMetadata(tensorflow::InputTFE_Context(ctx), &buf,", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextClearCaches\", [](py::handle& o) {", "TFE_ContextClearCaches(tensorflow::InputTFE_Context(o));", "});", "m.def(\"TFE_GetContextId\", [](py::handle& ctx) {", "return TFE_GetContextId(tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextGetDevicePlacementPolicy\", [](py::handle& ctx) {", "return TFE_ContextGetDevicePlacementPolicy(", "tensorflow::InputTFE_Context(ctx));", "});", "m.def(\"TFE_ContextSetThreadLocalDevicePlacementPolicy\",", "[](py::handle& ctx, TFE_ContextDevicePlacementPolicy policy) {", "TFE_ContextSetThreadLocalDevicePlacementPolicy(", "tensorflow::InputTFE_Context(ctx), policy);", "});", "m.def(\"TFE_ContextSetServerDef\", [](py::handle& ctx, int keep_alive_secs,", "py::bytes proto) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "tensorflow::Safe_TF_BufferPtr buf =", "tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));", "TFE_ContextSetServerDef(tensorflow::InputTFE_Context(ctx), keep_alive_secs,", "buf.get()->data, buf.get()->length, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextUpdateServerDef\", [](py::handle& ctx, int keep_alive_secs,", "py::bytes proto) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "tensorflow::Safe_TF_BufferPtr buf =", "tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));", "Py_BEGIN_ALLOW_THREADS;", "TFE_ContextUpdateServerDef(tensorflow::InputTFE_Context(ctx),", "keep_alive_secs, buf.get()->data,", "buf.get()->length, status.get());", "Py_END_ALLOW_THREADS;", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextCheckAlive\", [](py::handle& ctx, const char* worker_name) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "bool output = TFE_ContextCheckAlive(tensorflow::InputTFE_Context(ctx),", "worker_name, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "});", "m.def(\"TFE_ContextSyncExecutors\", [](py::handle& ctx) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextAsyncWait(tensorflow::InputTFE_Context(ctx), status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextClearExecutors\", [](py::handle& ctx) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextAsyncWait(tensorflow::InputTFE_Context(ctx), status.get());", "", "", "});", "m.def(\"TFE_ContextSetSoftDevicePlacement\", [](py::handle& ctx, bool enable) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextSetSoftDevicePlacement(tensorflow::InputTFE_Context(ctx), enable,", "status.get());", "});", "m.def(\"TFE_ContextSetLogDevicePlacement\", [](py::handle& ctx, bool enable) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_ContextSetSoftDevicePlacement(tensorflow::InputTFE_Context(ctx), enable,", "status.get());", "});", "", "", "m.def(", "\"TFE_NewExecutor\",", "[](const bool is_async) {", "TFE_Executor* exc = TFE_NewExecutor(is_async);", "return exc;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_DeleteExecutor\", &TFE_DeleteExecutor);", "m.def(\"TFE_ExecutorIsAsync\", &TFE_ExecutorIsAsync);", "m.def(\"TFE_ExecutorWaitForAllPendingNodes\", [](TFE_Executor& exc) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "", "Py_BEGIN_ALLOW_THREADS;", "TFE_ExecutorWaitForAllPendingNodes(&exc, status.get());", "Py_END_ALLOW_THREADS;", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ExecutorClearError\", &TFE_ExecutorClearError);", "m.def(\"TFE_ContextSetExecutorForThread\", [](py::handle& ctx,", "TFE_Executor& exc) {", "TFE_ContextSetExecutorForThread(tensorflow::InputTFE_Context(ctx), &exc);", "});", "m.def(", "\"TFE_ContextGetExecutorForThread\",", "[](py::handle& o) {", "return TFE_ContextGetExecutorForThread(tensorflow::InputTFE_Context(o));", "},", "py::return_value_policy::reference);", "", "m.def(\"TFE_OpNameGetAttrType\",", "[](py::handle& ctx, const char* op_or_function_name,", "const char* attr_name) {", "int temp = 0;", "unsigned char* is_list = reinterpret_cast<unsigned char*>(&temp);", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_OpNameGetAttrType(tensorflow::InputTFE_Context(ctx),", "op_or_function_name, attr_name,", "is_list, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "#if PY_MAJOR_VERSION < 3", "PyObject* output_pyo = PyInt_FromLong(output);", "#else", "PyObject* output_pyo = PyLong_FromLong(output);", "#endif", "if (*is_list == 1) {", "PyObject* list = PyList_New(1);", "PyList_SetItem(list, 0, output_pyo);", "return tensorflow::PyoOrThrow(list);", "}", "return tensorflow::PyoOrThrow(output_pyo);", "});", "m.def(\"TFE_Py_InitEagerTensor\", [](const py::handle& o) {", "return tensorflow::PyoOrThrow(TFE_Py_InitEagerTensor(o.ptr()));", "});", "m.def(\"TFE_Py_PackEagerTensors\",", "[](const py::handle& context, const py::handle& handles) {", "return tensorflow::TFE_Py_PackEagerTensors_wrapper(context, handles);", "});", "m.def(\"TFE_Py_SetEagerTensorProfiler\", &TFE_Py_SetEagerTensorProfiler);", "m.def(\"TFE_Py_RegisterJVPFunction\", [](const py::handle& o) {", "return tensorflow::PyoOrThrow(TFE_Py_RegisterJVPFunction(o.ptr()));", "});", "m.def(\"TFE_Py_RegisterGradientFunction\", [](const py::handle& o) {", "return tensorflow::PyoOrThrow(TFE_Py_RegisterGradientFunction(o.ptr()));", "});", "m.def(\"TFE_Py_Execute\",", "[](const py::handle& context, const char* device_name,", "const char* op_name, const py::handle& inputs,", "const py::handle& attrs, const py::handle& num_outputs) {", "return tensorflow::TFE_Py_ExecuteCancelable_wrapper(", "context, device_name, op_name, inputs, attrs.ptr(), nullptr,", "num_outputs);", "});", "m.def(", "\"TFE_Py_ExecuteCancelable\",", "[](const py::handle& context, const char* device_name,", "const char* op_name, const py::handle& inputs, const py::handle& attrs,", "TFE_CancellationManager& cancellation_manager,", "const py::handle& num_outputs) {", "return tensorflow::TFE_Py_ExecuteCancelable_wrapper(", "context, device_name, op_name, inputs, attrs.ptr(),", "&cancellation_manager, num_outputs);", "});", "m.def(\"TFE_Py_FastPathExecute\", [](const py::args args) {", "", "return tensorflow::PyoOrThrow(TFE_Py_FastPathExecute_C(args.ptr()));", "});", "m.def(\"TFE_Py_RecordGradient\",", "[](const py::handle& op_name, const py::handle& inputs,", "const py::handle& attrs, const py::handle& results,", "const py::handle& forward_pass_name_scope) {", "return tensorflow::PyoOrThrow(TFE_Py_RecordGradient(", "op_name.ptr(), inputs.ptr(), attrs.ptr(), results.ptr(),", "forward_pass_name_scope.ptr()));", "});", "m.def(\"TFE_Py_UID\", []() { return tensorflow::PyoOrThrow(TFE_Py_UID()); });", "", "", "m.def(\"TFE_Py_TapeSetNew\", [](const py::handle& persistent,", "const py::handle& watch_accessed_variables) {", "return tensorflow::PyoOrThrow(", "TFE_Py_TapeSetNew(persistent.ptr(), watch_accessed_variables.ptr()));", "});", "m.def(\"TFE_Py_TapeSetAdd\",", "[](const py::handle& tape) { TFE_Py_TapeSetAdd(tape.ptr()); });", "m.def(\"TFE_Py_TapeSetRemove\",", "[](const py::handle& tape) { TFE_Py_TapeSetRemove(tape.ptr()); });", "m.def(\"TFE_Py_TapeSetStopOnThread\", &TFE_Py_TapeSetStopOnThread);", "m.def(\"TFE_Py_TapeSetRestartOnThread\", &TFE_Py_TapeSetRestartOnThread);", "m.def(\"TFE_Py_TapeSetIsStopped\",", "[]() { return tensorflow::PyoOrThrow(TFE_Py_TapeSetIsStopped()); });", "m.def(\"TFE_Py_TapeSetIsEmpty\",", "[]() { return tensorflow::PyoOrThrow(TFE_Py_TapeSetIsEmpty()); });", "m.def(\"TFE_Py_TapeSetShouldRecordBackprop\", [](const py::handle& tensors) {", "return tensorflow::PyoOrThrow(", "TFE_Py_TapeSetShouldRecordBackprop(tensors.ptr()));", "});", "m.def(\"TFE_Py_TapeSetPossibleGradientTypes\", [](const py::handle& tensors) {", "return tensorflow::PyoOrThrow(", "TFE_Py_TapeSetPossibleGradientTypes(tensors.ptr()));", "});", "m.def(\"TFE_Py_TapeSetDeleteTrace\", &TFE_Py_TapeSetDeleteTrace);", "m.def(\"TFE_Py_TapeSetRecordOperation\",", "[](const py::handle& op_type, const py::handle& output_tensors,", "const py::handle& input_tensors, const py::handle& backward_function,", "const py::handle& forward_function) {", "return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperation(", "op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),", "backward_function.ptr(), forward_function.ptr()));", "});", "m.def(", "\"TFE_Py_TapeSetRecordOperationBackprop\",", "[](const py::handle& op_type, const py::handle& output_tensors,", "const py::handle& input_tensors, const py::handle& backward_function) {", "return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperationBackprop(", "op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),", "backward_function.ptr()));", "});", "m.def(", "\"TFE_Py_TapeSetRecordOperationForwardprop\",", "[](const py::handle& op_type, const py::handle& output_tensors,", "const py::handle& input_tensors, const py::handle& backward_function,", "const py::handle& forwardprop_output_indices) {", "return tensorflow::PyoOrThrow(TFE_Py_TapeSetRecordOperationForwardprop(", "op_type.ptr(), output_tensors.ptr(), input_tensors.ptr(),", "backward_function.ptr(), forwardprop_output_indices.ptr()));", "});", "m.def(\"TFE_Py_TapeGradient\",", "[](const py::handle& tape, const py::handle& target,", "const py::handle& sources, const py::handle& output_gradients,", "const py::handle& sources_raw,", "const py::handle& unconnected_gradients) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "PyObject* output = TFE_Py_TapeGradient(", "tape.ptr(), target.ptr(), sources.ptr(), output_gradients.ptr(),", "sources_raw.ptr(), unconnected_gradients.ptr(), status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return tensorflow::PyoOrThrow(output);", "});", "", "m.def(\"TFE_Py_TapeVariableAccessed\", [](const py::handle& variable) {", "TFE_Py_TapeVariableAccessed(variable.ptr());", "});", "m.def(\"TFE_Py_TapeWatch\",", "[](const py::handle& tape, const py::handle& tensor) {", "TFE_Py_TapeWatch(tape.ptr(), tensor.ptr());", "});", "m.def(\"TFE_Py_TapeWatchVariable\",", "[](const py::handle& tape, const py::handle& variable) {", "TFE_Py_TapeWatchVariable(tape.ptr(), variable.ptr());", "});", "m.def(\"TFE_Py_TapeWatchedVariables\", [](const py::handle& tape) {", "return tensorflow::PyoOrThrow(TFE_Py_TapeWatchedVariables(tape.ptr()));", "});", "", "", "m.def(\"TFE_Py_VariableWatcherNew\",", "[]() { return tensorflow::PyoOrThrow(TFE_Py_VariableWatcherNew()); });", "m.def(\"TFE_Py_VariableWatcherRemove\", [](const py::handle& variable_watcher) {", "TFE_Py_VariableWatcherRemove(variable_watcher.ptr());", "});", "m.def(\"TFE_Py_VariableWatcherVariableAccessed\",", "[](const py::handle& variable) {", "TFE_Py_VariableWatcherVariableAccessed(variable.ptr());", "});", "m.def(\"TFE_Py_VariableWatcherWatchedVariables\",", "[](const py::handle& variable_watcher) {", "return tensorflow::PyoOrThrow(", "TFE_Py_VariableWatcherWatchedVariables(variable_watcher.ptr()));", "});", "", "", "m.def(\"TFE_Py_ForwardAccumulatorNew\", [](bool use_batch) {", "return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorNew(use_batch));", "});", "", "m.def(\"TFE_Py_ForwardAccumulatorSetAdd\", [](const py::handle& accumulator) {", "return tensorflow::PyoOrThrow(", "TFE_Py_ForwardAccumulatorSetAdd(accumulator.ptr()));", "});", "m.def(\"TFE_Py_ForwardAccumulatorSetRemove\",", "[](const py::handle& accumulator) {", "TFE_Py_ForwardAccumulatorSetRemove(accumulator.ptr());", "});", "", "m.def(\"TFE_Py_ForwardAccumulatorWatch\",", "[](const py::handle& accumulator, const py::handle& tensor,", "const py::handle& tangent) {", "TFE_Py_ForwardAccumulatorWatch(accumulator.ptr(), tensor.ptr(),", "tangent.ptr());", "});", "m.def(\"TFE_Py_ForwardAccumulatorJVP\",", "[](const py::handle& accumulator, const py::handle& tensor) {", "return tensorflow::PyoOrThrow(", "TFE_Py_ForwardAccumulatorJVP(accumulator.ptr(), tensor.ptr()));", "});", "m.def(\"TFE_Py_ForwardAccumulatorPushState\", []() {", "return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorPushState());", "});", "m.def(\"TFE_Py_ForwardAccumulatorPopState\", []() {", "return tensorflow::PyoOrThrow(TFE_Py_ForwardAccumulatorPopState());", "});", "m.def(\"TFE_Py_PackJVPs\", [](const py::handle& tensors) {", "return tensorflow::PyoOrThrow(TFE_Py_PackJVPs(tensors.ptr()));", "});", "", "", "m.def(\"TFE_NewContextOptions\", &TFE_NewContextOptions,", "py::return_value_policy::reference);", "m.def(\"TFE_ContextOptionsSetConfig\", [](TFE_ContextOptions* options,", "py::bytes proto) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "tensorflow::Safe_TF_BufferPtr buf =", "tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));", "TFE_ContextOptionsSetConfig(options, buf.get()->data, buf.get()->length,", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_ContextOptionsSetDevicePlacementPolicy\",", "&TFE_ContextOptionsSetDevicePlacementPolicy);", "m.def(\"TFE_ContextOptionsSetLazyRemoteInputsCopy\",", "&TFE_ContextOptionsSetLazyRemoteInputsCopy);", "m.def(\"TFE_ContextOptionsSetTfrt\", &TFE_ContextOptionsSetTfrt);", "m.def(\"TFE_ContextOptionsSetAsync\", &TFE_ContextOptionsSetAsync);", "m.def(\"TFE_DeleteContextOptions\", &TFE_DeleteContextOptions,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_Py_TensorShapeSlice\",", "[](const py::handle& tensors, int slice_dim) {", "return tensorflow::PyoOrThrow(", "TFE_Py_TensorShapeSlice(tensors.ptr(), slice_dim));", "});", "m.def(\"TFE_Py_TensorShapeOnDevice\", [](const py::handle& tensors,", "int slice_dim) {", "return tensorflow::PyoOrThrow(TFE_Py_TensorShapeOnDevice(tensors.ptr()));", "});", "m.def(\"TFE_Py_EnableInteractivePythonLogging\",", "&TFE_Py_EnableInteractivePythonLogging);", "", "", "m.def(\"TFE_Py_SetEagerContext\", [](const py::handle& o) {", "return tensorflow::PyoOrThrow(TFE_Py_SetEagerContext(o.ptr()));", "});", "m.def(\"TFE_ContextStartStep\", [](py::handle& o) {", "TFE_ContextStartStep(tensorflow::InputTFE_Context(o.ptr()));", "});", "m.def(\"TFE_ContextEndStep\", [](py::handle& o) {", "TFE_ContextEndStep(tensorflow::InputTFE_Context(o.ptr()));", "});", "m.def(\"TFE_Py_RegisterVSpace\", [](const py::handle& o) {", "return tensorflow::PyoOrThrow(TFE_Py_RegisterVSpace(o.ptr()));", "});", "m.def(\"TFE_Py_EncodeArg\",", "[](const py::handle& o, bool include_tensor_ranks_only) {", "return tensorflow::PyoOrThrow(", "TFE_Py_EncodeArg(o.ptr(), include_tensor_ranks_only));", "});", "m.def(\"TFE_EnableCollectiveOps\", [](const py::handle& ctx, py::bytes proto) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "tensorflow::Safe_TF_BufferPtr buf =", "tensorflow::make_safe(tensorflow::ProtoStringToTFBuffer(proto.ptr()));", "TFE_EnableCollectiveOps(tensorflow::InputTFE_Context(ctx), buf.get()->data,", "buf.get()->length, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TFE_AbortCollectiveOps\", [](const py::handle& ctx, int code,", "const char* message) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TF_SetStatus(status.get(), static_cast<TF_Code>(code), message);", "TFE_AbortCollectiveOps(tensorflow::InputTFE_Context(ctx), status.get());", "});", "m.def(\"TFE_CollectiveOpsCheckPeerHealth\",", "[](const py::handle& ctx, const char* task) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "TFE_CollectiveOpsCheckPeerHealth(tensorflow::InputTFE_Context(ctx),", "task, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "m.def(\"TF_ListPhysicalDevices\", &tensorflow::TF_ListPhysicalDevices);", "m.def(\"TF_GetDeviceDetails\", &tensorflow::TF_GetDeviceDetails);", "m.def(\"TF_DeleteDeviceList\", &TF_DeleteDeviceList,", "py::return_value_policy::reference);", "m.def(\"TF_DeviceListCount\", &TF_DeviceListCount);", "m.def(\"TF_DeviceListName\", [](const TF_DeviceList* list, int index) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TF_DeviceListName(list, index, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "});", "m.def(\"TF_DeviceListType\", [](const TF_DeviceList* list, int index) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TF_DeviceListType(list, index, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "});", "", "m.def(\"TF_PickUnusedPortOrDie\", &TF_PickUnusedPortOrDie);", "", "", "m.def(\"TFE_MonitoringCounterCellIncrementBy\",", "&TFE_MonitoringCounterCellIncrementBy);", "m.def(\"TFE_MonitoringCounterCellValue\", &TFE_MonitoringCounterCellValue);", "m.def(", "\"TFE_MonitoringNewCounter0\",", "[](const char* name, const char* description) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewCounter0(name, status.get(), description);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteCounter0\", &TFE_MonitoringDeleteCounter0,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellCounter0\", &TFE_MonitoringGetCellCounter0,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewCounter1\",", "[](const char* name, const char* description, const char* label1) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewCounter1(name, status.get(), description, label1);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteCounter1\", &TFE_MonitoringDeleteCounter1,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellCounter1\", &TFE_MonitoringGetCellCounter1,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewCounter2\",", "[](const char* name, const char* description, const char* label1,", "const char* label2) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewCounter2(name, status.get(), description,", "label1, label2);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteCounter2\", &TFE_MonitoringDeleteCounter2,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellCounter2\", &TFE_MonitoringGetCellCounter2,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_MonitoringIntGaugeCellSet\", &TFE_MonitoringIntGaugeCellSet);", "m.def(\"TFE_MonitoringIntGaugeCellValue\", &TFE_MonitoringIntGaugeCellValue);", "m.def(", "\"TFE_MonitoringNewIntGauge0\",", "[](const char* name, const char* description) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewIntGauge0(name, status.get(), description);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteIntGauge0\", &TFE_MonitoringDeleteIntGauge0,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellIntGauge0\", &TFE_MonitoringGetCellIntGauge0,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewIntGauge1\",", "[](const char* name, const char* description, const char* label1) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewIntGauge1(name, status.get(), description, label1);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteIntGauge1\", &TFE_MonitoringDeleteIntGauge1,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellIntGauge1\", &TFE_MonitoringGetCellIntGauge1,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewIntGauge2\",", "[](const char* name, const char* description, const char* label1,", "const char* label2) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewIntGauge2(name, status.get(),", "description, label1, label2);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteIntGauge2\", &TFE_MonitoringDeleteIntGauge2,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellIntGauge2\", &TFE_MonitoringGetCellIntGauge2,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringStringGaugeCellSet\", &TFE_MonitoringStringGaugeCellSet);", "m.def(\"TFE_MonitoringStringGaugeCellValue\",", "&TFE_MonitoringStringGaugeCellValue);", "m.def(", "\"TFE_MonitoringNewStringGauge0\",", "[](const char* name, const char* description) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewStringGauge0(name, status.get(), description);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_MonitoringDeleteStringGauge0\", &TFE_MonitoringDeleteStringGauge0);", "m.def(\"TFE_MonitoringGetCellStringGauge0\", &TFE_MonitoringGetCellStringGauge0,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewStringGauge1\",", "[](const char* name, const char* description, const char* label1) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewStringGauge1(name, status.get(),", "description, label1);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteStringGauge1\", &TFE_MonitoringDeleteStringGauge1);", "m.def(\"TFE_MonitoringGetCellStringGauge1\", &TFE_MonitoringGetCellStringGauge1,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewStringGauge2\",", "[](const char* name, const char* description, const char* label1,", "const char* label2) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewStringGauge2(", "name, status.get(), description, label1, label2);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteStringGauge2\", &TFE_MonitoringDeleteStringGauge2);", "m.def(\"TFE_MonitoringGetCellStringGauge2\", &TFE_MonitoringGetCellStringGauge2,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_MonitoringBoolGaugeCellSet\", &TFE_MonitoringBoolGaugeCellSet);", "m.def(\"TFE_MonitoringBoolGaugeCellValue\", &TFE_MonitoringBoolGaugeCellValue);", "m.def(", "\"TFE_MonitoringNewBoolGauge0\",", "[](const char* name, const char* description) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewBoolGauge0(name, status.get(), description);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteBoolGauge0\", &TFE_MonitoringDeleteBoolGauge0,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellBoolGauge0\", &TFE_MonitoringGetCellBoolGauge0,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewBoolGauge1\",", "[](const char* name, const char* description, const char* label1) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewBoolGauge1(name, status.get(),", "description, label1);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteBoolGauge1\", &TFE_MonitoringDeleteBoolGauge1,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellBoolGauge1\", &TFE_MonitoringGetCellBoolGauge1,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewBoolGauge2\",", "[](const char* name, const char* description, const char* label1,", "const char* label2) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewBoolGauge2(name, status.get(),", "description, label1, label2);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteBoolGauge2\", &TFE_MonitoringDeleteBoolGauge2,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellBoolGauge2\", &TFE_MonitoringGetCellBoolGauge2,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_MonitoringSamplerCellAdd\", &TFE_MonitoringSamplerCellAdd);", "m.def(\"TFE_MonitoringSamplerCellValue\", &TFE_MonitoringSamplerCellValue);", "m.def(\"TFE_MonitoringNewExponentialBuckets\",", "&TFE_MonitoringNewExponentialBuckets,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteBuckets\", &TFE_MonitoringDeleteBuckets,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewSampler0\",", "[](const char* name, TFE_MonitoringBuckets* buckets,", "const char* description) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output =", "TFE_MonitoringNewSampler0(name, buckets, status.get(), description);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteSampler0\", &TFE_MonitoringDeleteSampler0,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellSampler0\", &TFE_MonitoringGetCellSampler0,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewSampler1\",", "[](const char* name, TFE_MonitoringBuckets* buckets,", "const char* description, const char* label1) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewSampler1(name, buckets, status.get(),", "description, label1);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteSampler1\", &TFE_MonitoringDeleteSampler1,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellSampler1\", &TFE_MonitoringGetCellSampler1,", "py::return_value_policy::reference);", "m.def(", "\"TFE_MonitoringNewSampler2\",", "[](const char* name, TFE_MonitoringBuckets* buckets,", "const char* description, const char* label1, const char* label2) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "auto output = TFE_MonitoringNewSampler2(name, buckets, status.get(),", "description, label1, label2);", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "return output;", "},", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringDeleteSampler2\", &TFE_MonitoringDeleteSampler2,", "py::return_value_policy::reference);", "m.def(\"TFE_MonitoringGetCellSampler2\", &TFE_MonitoringGetCellSampler2,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_NewCancellationManager\", &TFE_NewCancellationManager,", "py::return_value_policy::reference);", "m.def(\"TFE_CancellationManagerIsCancelled\",", "&TFE_CancellationManagerIsCancelled);", "m.def(\"TFE_CancellationManagerStartCancel\",", "&TFE_CancellationManagerStartCancel);", "m.def(\"TFE_DeleteCancellationManager\", &TFE_DeleteCancellationManager,", "py::return_value_policy::reference);", "", "m.def(\"TFE_ClearScalarCache\", &tensorflow::TFE_ClearScalarCache);", "", "", "m.def(\"TF_NewBufferFromString\", &TF_NewBufferFromString,", "py::return_value_policy::reference);", "", "", "m.def(\"TFE_ToDlpackCapsule\", [](py::handle& o) {", "PyObject* eager_tensor_pyobject_ptr = o.ptr();", "TFE_TensorHandle* thandle = EagerTensor_Handle(eager_tensor_pyobject_ptr);", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "void* dlm_ptr = tensorflow::TFE_HandleToDLPack(thandle, status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "", "py::capsule capsule(", "dlm_ptr, tensorflow::kDlTensorCapsuleName, [](PyObject* capsule) {", "if (PyCapsule_IsValid(capsule, tensorflow::kDlTensorCapsuleName)) {", "void* dlm_rptr =", "PyCapsule_GetPointer(capsule, tensorflow::kDlTensorCapsuleName);", "if (dlm_rptr) {", "tensorflow::TFE_CallDLManagedTensorDeleter(dlm_rptr);", "PyCapsule_SetDestructor(capsule, nullptr);", "}", "}", "});", "return capsule;", "});", "", "m.def(\"TFE_FromDlpackCapsule\", [](const py::capsule& pycapsule,", "const py::handle& context) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "if (absl::string_view(pycapsule.name()) !=", "tensorflow::kDlTensorCapsuleName) {", "status->status = tensorflow::errors::InvalidArgument(", "\"DLPack tensor must be a capsule with name \\\"dltensor\\\", got \\\"%s\\\". \"", "\"Note that a DLPack tensor may be consumed at most once.\",", "absl::string_view(pycapsule.name()));", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "}", "", "TFE_TensorHandle* thandle = tensorflow::TFE_HandleFromDLPack(", "pycapsule, status.get(), tensorflow::InputTFE_Context(context));", "", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "", "PyCapsule_SetName(pycapsule.ptr(), \"used_dltensor\");", "PyCapsule_SetDestructor(pycapsule.ptr(), nullptr);", "", "PyObject* pyhandle = EagerTensorFromHandle(thandle);", "return tensorflow::PyoOrThrow(pyhandle);", "});", "", "m.def(\"TFE_Py_RegisterCustomDevice\", [](const py::handle& context,", "const py::capsule& device,", "const char* device_name,", "const py::capsule& device_info) {", "tensorflow::Safe_TF_StatusPtr status =", "tensorflow::make_safe(TF_NewStatus());", "if (absl::string_view(device.name()) != \"TFE_CustomDevice\") {", "status->status = tensorflow::errors::InvalidArgument(", "\"Expected a capsule named 'TFE_CustomDevice' for the `device` \"", "\"argument, got \",", "absl::string_view(device.name()));", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "}", "if (absl::string_view(device_info.name()) !=", "\"TFE_CustomDevice_DeviceInfo\") {", "status->status = tensorflow::errors::InvalidArgument(", "\"Expected a capsule named 'TFE_CustomDevice_DeviceInfo' for \"", "\"the `device_info` argument, got \",", "absl::string_view(device_info.name()));", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "}", "", "PyCapsule_SetDestructor(device_info.ptr(), nullptr);", "TFE_RegisterCustomDevice(", "tensorflow::InputTFE_Context(context),", "*reinterpret_cast<TFE_CustomDevice*>(", "PyCapsule_GetPointer(device.ptr(), \"TFE_CustomDevice\")),", "device_name,", "PyCapsule_GetPointer(device_info.ptr(), \"TFE_CustomDevice_DeviceInfo\"),", "status.get());", "tensorflow::MaybeRaiseRegisteredFromTFStatus(status.get());", "});", "", "py::class_<EagerContextThreadLocalDataWrapper>(m,", "\"EagerContextThreadLocalData\")", ".def(py::init<py::handle, py::handle, py::handle>(),", "py::arg(\"py_eager_context\"), py::arg(\"is_eager\"),", "py::arg(\"device_spec\"))", ".def_property(\"is_eager\",", "&EagerContextThreadLocalDataWrapper::get_is_eager,", "&EagerContextThreadLocalDataWrapper::set_is_eager)", ".def_property(", "\"invoking_op_callbacks\",", "&EagerContextThreadLocalDataWrapper::get_invoking_op_callbacks,", "&EagerContextThreadLocalDataWrapper::set_invoking_op_callbacks)", ".def_property(\"device_name\",", "&EagerContextThreadLocalDataWrapper::get_device_name,", "&EagerContextThreadLocalDataWrapper::set_device_name)", ".def_property(\"scope_name\",", "&EagerContextThreadLocalDataWrapper::get_scope_name,", "&EagerContextThreadLocalDataWrapper::set_scope_name)", ".def_property(\"device_spec\",", "&EagerContextThreadLocalDataWrapper::get_device_spec,", "&EagerContextThreadLocalDataWrapper::set_device_spec)", ".def_property(", "\"function_call_options\",", "&EagerContextThreadLocalDataWrapper::get_function_call_options,", "&EagerContextThreadLocalDataWrapper::set_function_call_options)", ".def_property(\"executor\",", "&EagerContextThreadLocalDataWrapper::get_executor,", "&EagerContextThreadLocalDataWrapper::set_executor)", ".def_property(\"op_callbacks\",", "&EagerContextThreadLocalDataWrapper::get_op_callbacks,", "&EagerContextThreadLocalDataWrapper::set_op_callbacks);", "", "", "", "py::enum_<TFE_ContextDevicePlacementPolicy>(", "m, \"TFE_ContextDevicePlacementPolicy\")", ".value(\"TFE_DEVICE_PLACEMENT_EXPLICIT\", TFE_DEVICE_PLACEMENT_EXPLICIT)", ".value(\"TFE_DEVICE_PLACEMENT_WARN\", TFE_DEVICE_PLACEMENT_WARN)", ".value(\"TFE_DEVICE_PLACEMENT_SILENT\", TFE_DEVICE_PLACEMENT_SILENT)", ".value(\"TFE_DEVICE_PLACEMENT_SILENT_FOR_INT32\",", "TFE_DEVICE_PLACEMENT_SILENT_FOR_INT32)", ".export_values();", "", "py::enum_<TF_AttrType>(m, \"TF_AttrType\")", ".value(\"TF_ATTR_STRING\", TF_ATTR_STRING)", ".value(\"TF_ATTR_INT\", TF_ATTR_INT)", ".value(\"TF_ATTR_FLOAT\", TF_ATTR_FLOAT)", ".value(\"TF_ATTR_BOOL\", TF_ATTR_BOOL)", ".value(\"TF_ATTR_TYPE\", TF_ATTR_TYPE)", ".value(\"TF_ATTR_SHAPE\", TF_ATTR_SHAPE)", ".value(\"TF_ATTR_TENSOR\", TF_ATTR_TENSOR)", ".value(\"TF_ATTR_PLACEHOLDER\", TF_ATTR_PLACEHOLDER)", ".value(\"TF_ATTR_FUNC\", TF_ATTR_FUNC)", ".export_values();", "};"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" gsicc_open_search(const char* pname, int namelen, gs_memory_t *mem_gc,", "                   const char* dirname, int dirlen, stream**strp)", " {", "     char *buffer;", "     stream* str;", " ", "      ", "     if ( dirname != NULL) {", "          ", "         buffer = (char *) gs_alloc_bytes(mem_gc, namelen + dirlen + 1,", "                                      \"gsicc_open_search\");", "         if (buffer == NULL)", "             return_error(gs_error_VMerror);", "         strcpy(buffer, dirname);", "         strcat(buffer, pname);", "          ", "         buffer[namelen + dirlen] = '\\0';", "         str = sfopen(buffer, \"r\", mem_gc);", "         gs_free_object(mem_gc, buffer, \"gsicc_open_search\");", "         if (str != NULL) {", "             *strp = str;", " \t    return 0;", "         }", "      }", "  ", "       ", "    str = sfopen(pname, \"r\", mem_gc);", "    if (str != NULL) {", "        *strp = str;", "        return 0;", "     if (gs_check_file_permission(mem_gc, pname, namelen, \"r\") >= 0) {", "         str = sfopen(pname, \"r\", mem_gc);", "         if (str != NULL) {", "             *strp = str;", "             return 0;", "         }", "      }", "  ", "         ", "                         strlen(DEFAULT_DIR_ICC),\"gsicc_open_search\");", "     if (buffer == NULL)", "         return_error(gs_error_VMerror);", "     strcpy(buffer, DEFAULT_DIR_ICC);", "     strcat(buffer, pname);", "      ", "     buffer[namelen + strlen(DEFAULT_DIR_ICC)] = '\\0';", "     str = sfopen(buffer, \"r\", mem_gc);", "     gs_free_object(mem_gc, buffer, \"gsicc_open_search\");", "     if (str == NULL) {", "         gs_warn1(\"Could not find %s \",pname);", "     }", "     *strp = str;", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void ManifestChangeNotifier::DidChangeManifest() {", "    ", "   if (!ManifestManager::CanFetchManifest(render_frame()))", "     return;", " ", "    if (weak_factory_.HasWeakPtrs())", "      return;", "  ", "   if (!render_frame()->GetWebFrame()->IsLoading()) {", "     render_frame()", "         ->GetTaskRunner(blink::TaskType::kUnspecedLoading)", "         ->PostTask(FROM_HERE,", "                    base::BindOnce(&ManifestChangeNotifier::ReportManifestChange,", "                                   weak_factory_.GetWeakPtr()));", "     return;", "   }", "   ReportManifestChange();", " }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["fribidi_get_par_embedding_levels_ex (", "", "const FriBidiCharType *bidi_types,", "const FriBidiBracketType *bracket_types,", "const FriBidiStrIndex len,", "", "FriBidiParType *pbase_dir,", "", "FriBidiLevel *embedding_levels", ")", "{", "FriBidiLevel base_level_per_iso_level[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];", "FriBidiLevel base_level, max_level = 0;", "FriBidiParType base_dir;", "FriBidiRun *main_run_list = NULL, *explicits_list = NULL, *pp;", "fribidi_boolean status = false;", "int max_iso_level = 0;", "", "if UNLIKELY", "(!len)", "{", "status = true;", "goto out;", "}", "", "DBG (\"in fribidi_get_par_embedding_levels\");", "", "fribidi_assert (bidi_types);", "fribidi_assert (pbase_dir);", "fribidi_assert (embedding_levels);", "", "", "{", "", "main_run_list = run_list_encode_bidi_types (bidi_types, bracket_types, len);", "if UNLIKELY", "(!main_run_list) goto out;", "}", "", "", "", "", "base_level = FRIBIDI_DIR_TO_LEVEL (*pbase_dir);", "if (!FRIBIDI_IS_STRONG (*pbase_dir))", "", "", "{", "int valid_isolate_count = 0;", "for_run_list (pp, main_run_list)", "{", "if (RL_TYPE(pp) == FRIBIDI_TYPE_PDI)", "{", "", "if (valid_isolate_count>0)", "valid_isolate_count--;", "}", "else if (FRIBIDI_IS_ISOLATE(RL_TYPE(pp)))", "valid_isolate_count++;", "else if (valid_isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (pp)))", "{", "base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (pp));", "*pbase_dir = FRIBIDI_LEVEL_TO_DIR (base_level);", "break;", "}", "}", "}", "base_dir = FRIBIDI_LEVEL_TO_DIR (base_level);", "DBG2 (\"  base level : %c\", fribidi_char_from_level (base_level));", "DBG2 (\"  base dir   : %s\", fribidi_get_bidi_type_name (base_dir));", "", "base_level_per_iso_level[0] = base_level;", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_types_re (main_run_list);", "}", "# endif\t/* DEBUG */", "", "", "DBG (\"explicit levels and directions\");", "{", "FriBidiLevel level, new_level = 0;", "int isolate_level = 0;", "FriBidiCharType override, new_override;", "FriBidiStrIndex i;", "int stack_size, over_pushed, first_interval;", "int valid_isolate_count = 0;", "int isolate_overflow = 0;", "int isolate = 0;", "struct", "{", "FriBidiCharType override;", "FriBidiLevel level;", "int isolate;", "int isolate_level;", "} status_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];", "FriBidiRun temp_link;", "FriBidiRun *run_per_isolate_level[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];", "", "memset(run_per_isolate_level, 0, sizeof(run_per_isolate_level[0])", "* FRIBIDI_BIDI_MAX_RESOLVED_LEVELS);", "", "", "", "", "", "explicits_list = new_run_list ();", "if UNLIKELY", "(!explicits_list) goto out;", "", "", "", "", "", "", "", "", "level = base_level;", "override = FRIBIDI_TYPE_ON;", "", "stack_size = 0;", "over_pushed = 0;", "first_interval = 0;", "valid_isolate_count = 0;", "isolate_overflow = 0;", "", "for_run_list (pp, main_run_list)", "{", "FriBidiCharType this_type = RL_TYPE (pp);", "RL_ISOLATE_LEVEL (pp) = isolate_level;", "", "if (FRIBIDI_IS_EXPLICIT_OR_BN (this_type))", "{", "if (FRIBIDI_IS_STRONG (this_type))", "{", "", "", "", "", "", "", "", "", "", "", "new_override = FRIBIDI_EXPLICIT_TO_OVERRIDE_DIR (this_type);", "for (i = RL_LEN (pp); i; i--)", "{", "new_level =", "((level + FRIBIDI_DIR_TO_LEVEL (this_type) + 2) & ~1) -", "FRIBIDI_DIR_TO_LEVEL (this_type);", "isolate = 0;", "PUSH_STATUS;", "}", "}", "else if (this_type == FRIBIDI_TYPE_PDF)", "{", "", "", "", "for (i = RL_LEN (pp); i; i--)", "{", "if (stack_size && status_stack[stack_size-1].isolate != 0)", "break;", "POP_STATUS;", "}", "}", "", "", "", "RL_LEVEL (pp) = FRIBIDI_SENTINEL;", "temp_link.next = pp->next;", "move_node_before (pp, explicits_list);", "pp = &temp_link;", "}", "else if (this_type == FRIBIDI_TYPE_PDI)", "", "{", "for (i = RL_LEN (pp); i; i--)", "{", "if (isolate_overflow > 0)", "{", "isolate_overflow--;", "RL_LEVEL (pp) = level;", "}", "", "else if (valid_isolate_count > 0)", "{", "", "", "", "while (stack_size && !status_stack[stack_size-1].isolate)", "POP_STATUS;", "over_pushed = 0;", "POP_STATUS;", "isolate_level-- ;", "valid_isolate_count--;", "RL_LEVEL (pp) = level;", "RL_ISOLATE_LEVEL (pp) = isolate_level;", "}", "else", "{", "", "RL_TYPE (pp) = FRIBIDI_TYPE_ON;", "RL_LEVEL (pp) = level;", "}", "}", "}", "else if (FRIBIDI_IS_ISOLATE(this_type))", "{", "", "new_override = FRIBIDI_TYPE_ON;", "isolate = 1;", "if (this_type == FRIBIDI_TYPE_LRI)", "new_level = level + 2 - (level%2);", "else if (this_type == FRIBIDI_TYPE_RLI)", "new_level = level + 1 + (level%2);", "else if (this_type == FRIBIDI_TYPE_FSI)", "{", "", "", "", "FriBidiRun *fsi_pp;", "int isolate_count = 0;", "int fsi_base_level = 0;", "for_run_list (fsi_pp, pp)", "{", "if (RL_TYPE(fsi_pp) == FRIBIDI_TYPE_PDI)", "{", "isolate_count--;", "if (valid_isolate_count < 0)", "break;", "}", "else if (FRIBIDI_IS_ISOLATE(RL_TYPE(fsi_pp)))", "isolate_count++;", "else if (isolate_count==0 && FRIBIDI_IS_LETTER (RL_TYPE (fsi_pp)))", "{", "fsi_base_level = FRIBIDI_DIR_TO_LEVEL (RL_TYPE (fsi_pp));", "break;", "}", "}", "", "", "if (FRIBIDI_LEVEL_IS_RTL (fsi_base_level))", "new_level = level + 1 + (level%2);", "else", "new_level = level + 2 - (level%2);", "}", "", "RL_LEVEL (pp) = level;", "RL_ISOLATE_LEVEL (pp) = isolate_level++;", "base_level_per_iso_level[isolate_level] = new_level;", "", "if (!FRIBIDI_IS_NEUTRAL (override))", "RL_TYPE (pp) = override;", "", "if (new_level <= FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL)", "{", "valid_isolate_count++;", "PUSH_STATUS;", "level = new_level;", "}", "else", "isolate_overflow += 1;", "}", "else if (this_type == FRIBIDI_TYPE_BS)", "{", "", "", "", "break;", "}", "else", "{", "", "", "", "", "", "", "RL_LEVEL (pp) = level;", "if (!FRIBIDI_IS_NEUTRAL (override))", "RL_TYPE (pp) = override;", "}", "}", "", "", "for_run_list (pp, main_run_list)", "{", "int isolate_level = RL_ISOLATE_LEVEL (pp);", "if (run_per_isolate_level[isolate_level])", "{", "run_per_isolate_level[isolate_level]->next_isolate = pp;", "pp->prev_isolate = run_per_isolate_level[isolate_level];", "}", "run_per_isolate_level[isolate_level] = pp;", "}", "", "", "level = base_level;", "override = FRIBIDI_TYPE_ON;", "stack_size = 0;", "over_pushed = 0;", "}", "", "", "", "", "", "", "", "", "", "", "compact_list (main_run_list);", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_types_re (main_run_list);", "print_bidi_string (bidi_types, len);", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "", "max_iso_level = 0;", "DBG (\"resolving weak types\");", "{", "int last_strong_stack[FRIBIDI_BIDI_MAX_RESOLVED_LEVELS];", "FriBidiCharType prev_type_orig;", "fribidi_boolean w4;", "", "last_strong_stack[0] = base_dir;", "", "for_run_list (pp, main_run_list)", "{", "register FriBidiCharType prev_type, this_type, next_type;", "FriBidiRun *ppp_prev, *ppp_next;", "int iso_level;", "", "ppp_prev = get_adjacent_run(pp, false, false);", "ppp_next = get_adjacent_run(pp, true, false);", "", "this_type = RL_TYPE (pp);", "iso_level = RL_ISOLATE_LEVEL(pp);", "", "if (iso_level > max_iso_level)", "max_iso_level = iso_level;", "", "if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))", "prev_type = RL_TYPE(ppp_prev);", "else", "prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));", "", "if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))", "next_type = RL_TYPE(ppp_next);", "else", "next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));", "", "if (FRIBIDI_IS_STRONG (prev_type))", "last_strong_stack[iso_level] = prev_type;", "", "", "", "", "", "", "", "", "", "if (this_type == FRIBIDI_TYPE_NSM)", "{", "", "if (FRIBIDI_IS_ISOLATE (RL_TYPE (pp->prev)))", "RL_TYPE(pp) = FRIBIDI_TYPE_ON;", "", "if (RL_LEVEL (ppp_prev) == RL_LEVEL (pp))", "{", "if (ppp_prev == pp->prev)", "pp = merge_with_prev (pp);", "}", "else", "RL_TYPE (pp) = prev_type;", "", "if (prev_type == next_type && RL_LEVEL (pp) == RL_LEVEL (pp->next))", "{", "if (ppp_next == pp->next)", "pp = merge_with_prev (pp->next);", "}", "continue;", "}", "", "", "if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_AL)", "{", "RL_TYPE (pp) = FRIBIDI_TYPE_AN;", "", "", "", "if (next_type == FRIBIDI_TYPE_NSM)", "RL_TYPE (ppp_next) = FRIBIDI_TYPE_AN;", "}", "}", "", "", "last_strong_stack[0] = base_dir;", "", "", "", "", "w4 = true;", "", "", "", "prev_type_orig = FRIBIDI_TYPE_ON;", "", "", "for_run_list (pp, main_run_list)", "{", "register FriBidiCharType prev_type, this_type, next_type;", "int iso_level;", "FriBidiRun *ppp_prev, *ppp_next;", "", "this_type = RL_TYPE (pp);", "iso_level = RL_ISOLATE_LEVEL(pp);", "", "ppp_prev = get_adjacent_run(pp, false, false);", "ppp_next = get_adjacent_run(pp, true, false);", "", "if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))", "prev_type = RL_TYPE(ppp_prev);", "else", "prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));", "", "if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))", "next_type = RL_TYPE(ppp_next);", "else", "next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));", "", "if (FRIBIDI_IS_STRONG (prev_type))", "last_strong_stack[iso_level] = prev_type;", "", "", "", "", "if (this_type == FRIBIDI_TYPE_AL)", "{", "RL_TYPE (pp) = FRIBIDI_TYPE_RTL;", "w4 = true;", "prev_type_orig = FRIBIDI_TYPE_ON;", "continue;", "}", "", "", "", "", "if (w4", "&& RL_LEN (pp) == 1 && FRIBIDI_IS_ES_OR_CS (this_type)", "&& FRIBIDI_IS_NUMBER (prev_type_orig)", "&& prev_type_orig == next_type", "&& (prev_type_orig == FRIBIDI_TYPE_EN", "|| this_type == FRIBIDI_TYPE_CS))", "{", "RL_TYPE (pp) = prev_type;", "this_type = RL_TYPE (pp);", "}", "w4 = true;", "", "", "", "if (this_type == FRIBIDI_TYPE_ET", "&& (prev_type_orig == FRIBIDI_TYPE_EN", "|| next_type == FRIBIDI_TYPE_EN))", "{", "RL_TYPE (pp) = FRIBIDI_TYPE_EN;", "w4 = false;", "this_type = RL_TYPE (pp);", "}", "", "", "if (FRIBIDI_IS_NUMBER_SEPARATOR_OR_TERMINATOR (this_type))", "RL_TYPE (pp) = FRIBIDI_TYPE_ON;", "", "", "if (this_type == FRIBIDI_TYPE_EN && last_strong_stack[iso_level] == FRIBIDI_TYPE_LTR)", "{", "RL_TYPE (pp) = FRIBIDI_TYPE_LTR;", "prev_type_orig = (RL_LEVEL (pp) == RL_LEVEL (pp->next) ?", "FRIBIDI_TYPE_EN : FRIBIDI_TYPE_ON);", "}", "else", "prev_type_orig = PREV_TYPE_OR_SOR (pp->next);", "}", "}", "", "compact_neutrals (main_run_list);", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "", "", "DBG (\"resolving neutral types - N0\");", "{", "", "int num_iso_levels = max_iso_level + 1;", "FriBidiPairingNode *pairing_nodes = NULL;", "FriBidiRun *local_bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL][LOCAL_BRACKET_SIZE];", "FriBidiRun **bracket_stack[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];", "int bracket_stack_size[FRIBIDI_BIDI_MAX_EXPLICIT_LEVEL];", "int last_level = RL_LEVEL(main_run_list);", "int last_iso_level = 0;", "", "memset(bracket_stack, 0, sizeof(bracket_stack[0])*num_iso_levels);", "memset(bracket_stack_size, 0, sizeof(bracket_stack_size[0])*num_iso_levels);", "", "", "", "", "{", "int iso_level;", "for (iso_level=0; iso_level < LOCAL_BRACKET_SIZE; iso_level++)", "bracket_stack[iso_level] = local_bracket_stack[iso_level];", "", "for (iso_level=LOCAL_BRACKET_SIZE; iso_level < num_iso_levels; iso_level++)", "bracket_stack[iso_level] = fribidi_malloc (sizeof (bracket_stack[0])", "* FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS);", "}", "", "", "for_run_list (pp, main_run_list)", "{", "int level = RL_LEVEL(pp);", "int iso_level = RL_ISOLATE_LEVEL(pp);", "FriBidiBracketType brack_prop = RL_BRACKET_TYPE(pp);", "", "", "", "", "if (level != last_level && last_iso_level == iso_level)", "bracket_stack_size[last_iso_level] = 0;", "", "if (brack_prop!= FRIBIDI_NO_BRACKET", "&& RL_TYPE(pp)==FRIBIDI_TYPE_ON)", "{", "if (FRIBIDI_IS_BRACKET_OPEN(brack_prop))", "{", "if (bracket_stack_size[iso_level]==FRIBIDI_BIDI_MAX_NESTED_BRACKET_PAIRS)", "break;", "", "", "bracket_stack[iso_level][bracket_stack_size[iso_level]++] = pp;", "}", "else", "{", "int stack_idx = bracket_stack_size[iso_level] - 1;", "while (stack_idx >= 0)", "{", "FriBidiBracketType se_brack_prop = RL_BRACKET_TYPE(bracket_stack[iso_level][stack_idx]);", "if (FRIBIDI_BRACKET_ID(se_brack_prop) == FRIBIDI_BRACKET_ID(brack_prop))", "{", "bracket_stack_size[iso_level] = stack_idx;", "", "pairing_nodes = pairing_nodes_push(pairing_nodes,", "bracket_stack[iso_level][stack_idx],", "pp);", "break;", "}", "stack_idx--;", "}", "}", "}", "last_level = level;", "last_iso_level = iso_level;", "}", "", "", "sort_pairing_nodes(&pairing_nodes);", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_pairing_nodes (pairing_nodes);", "}", "# endif\t/* DEBUG */", "", "", "{", "FriBidiPairingNode *ppairs = pairing_nodes;", "while (ppairs)", "{", "int iso_level = ppairs->open->isolate_level;", "int embedding_level = base_level_per_iso_level[iso_level];", "", "", "fribidi_boolean found = false;", "FriBidiRun *ppn;", "for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)", "{", "FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);", "", "", "", "int this_level = RL_LEVEL (ppn) +", "(FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));", "", "", "if (FRIBIDI_IS_STRONG (this_type) && this_level == embedding_level)", "{", "RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = this_level%2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;", "found = true;", "break;", "}", "}", "", "", "", "if (!found)", "{", "", "int prec_strong_level = embedding_level;", "int iso_level = RL_ISOLATE_LEVEL(ppairs->open);", "for (ppn = ppairs->open->prev; ppn->type != FRIBIDI_TYPE_SENTINEL; ppn=ppn->prev)", "{", "FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);", "if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)", "{", "prec_strong_level = RL_LEVEL (ppn) +", "(FRIBIDI_LEVEL_IS_RTL (RL_LEVEL(ppn)) ^ FRIBIDI_DIR_TO_LEVEL (this_type));", "", "break;", "}", "}", "", "for (ppn = ppairs->open; ppn!= ppairs->close; ppn = ppn->next)", "{", "FriBidiCharType this_type = RL_TYPE_AN_EN_AS_RTL(ppn);", "if (FRIBIDI_IS_STRONG (this_type) && RL_ISOLATE_LEVEL(ppn) == iso_level)", "{", "", "", "", "", "RL_TYPE(ppairs->open) = RL_TYPE(ppairs->close) = prec_strong_level % 2 ? FRIBIDI_TYPE_RTL : FRIBIDI_TYPE_LTR;", "RL_LEVEL(ppairs->open) = RL_LEVEL(ppairs->close) = prec_strong_level;", "found = true;", "break;", "}", "}", "}", "", "ppairs = ppairs->next;", "}", "", "free_pairing_nodes(pairing_nodes);", "", "if (num_iso_levels >= LOCAL_BRACKET_SIZE)", "{", "int i;", "", "for (i=LOCAL_BRACKET_SIZE; i<num_iso_levels; i++)", "fribidi_free(bracket_stack[i]);", "}", "", "", "{", "const FriBidiBracketType NoBracket = FRIBIDI_NO_BRACKET;", "for_run_list (pp, main_run_list)", "pp->bracket_type = NoBracket;", "compact_neutrals (main_run_list);", "}", "}", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "}", "", "DBG (\"resolving neutral types - N1+N2\");", "{", "for_run_list (pp, main_run_list)", "{", "FriBidiCharType prev_type, this_type, next_type;", "FriBidiRun *ppp_prev, *ppp_next;", "", "ppp_prev = get_adjacent_run(pp, false, false);", "ppp_next = get_adjacent_run(pp, true, false);", "", "", "", "this_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE (pp));", "", "if (RL_LEVEL(ppp_prev) == RL_LEVEL(pp))", "prev_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_prev));", "else", "prev_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_prev), RL_LEVEL(pp)));", "", "if (RL_LEVEL(ppp_next) == RL_LEVEL(pp))", "next_type = FRIBIDI_CHANGE_NUMBER_TO_RTL (RL_TYPE(ppp_next));", "else", "next_type = FRIBIDI_LEVEL_TO_DIR(MAX(RL_LEVEL(ppp_next), RL_LEVEL(pp)));", "", "if (FRIBIDI_IS_NEUTRAL (this_type))", "RL_TYPE (pp) = (prev_type == next_type) ?", "prev_type :", "FRIBIDI_EMBEDDING_DIRECTION (pp);", "}", "}", "", "compact_list (main_run_list);", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "", "DBG (\"resolving implicit levels\");", "{", "max_level = base_level;", "", "for_run_list (pp, main_run_list)", "{", "FriBidiCharType this_type;", "int level;", "", "this_type = RL_TYPE (pp);", "level = RL_LEVEL (pp);", "", "", "", "if (FRIBIDI_IS_NUMBER (this_type))", "RL_LEVEL (pp) = (level + 2) & ~1;", "else", "RL_LEVEL (pp) =", "level +", "(FRIBIDI_LEVEL_IS_RTL (level) ^ FRIBIDI_DIR_TO_LEVEL (this_type));", "", "if (RL_LEVEL (pp) > max_level)", "max_level = RL_LEVEL (pp);", "}", "}", "", "compact_list (main_run_list);", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_bidi_string (bidi_types, len);", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "", "", "DBG (\"reinserting explicit codes\");", "if UNLIKELY", "(explicits_list->next != explicits_list)", "{", "register FriBidiRun *p;", "register fribidi_boolean stat =", "shadow_run_list (main_run_list, explicits_list, true);", "explicits_list = NULL;", "if UNLIKELY", "(!stat) goto out;", "", "", "", "p = main_run_list->next;", "if (p != main_run_list && p->level == FRIBIDI_SENTINEL)", "p->level = base_level;", "for_run_list (p, main_run_list) if (p->level == FRIBIDI_SENTINEL)", "p->level = p->prev->level;", "}", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_types_re (main_run_list);", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "DBG (\"reset the embedding levels, 1, 2, 3.\");", "{", "register int j, state, pos;", "register FriBidiCharType char_type;", "register FriBidiRun *p, *q, *list;", "", "", "", "", "", "", "", "", "", "list = new_run_list ();", "if UNLIKELY", "(!list) goto out;", "q = list;", "state = 1;", "pos = len - 1;", "for (j = len - 1; j >= -1; j--)", "{", "", "if (j >= 0)", "char_type = bidi_types[j];", "else", "char_type = FRIBIDI_TYPE_ON;", "if (!state && FRIBIDI_IS_SEPARATOR (char_type))", "{", "state = 1;", "pos = j;", "}", "else if (state &&", "!(FRIBIDI_IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS(char_type)", "|| FRIBIDI_IS_ISOLATE(char_type)))", "{", "state = 0;", "p = new_run ();", "if UNLIKELY", "(!p)", "{", "free_run_list (list);", "goto out;", "}", "p->pos = j + 1;", "p->len = pos - j;", "p->type = base_dir;", "p->level = base_level;", "move_node_before (p, q);", "q = p;", "}", "}", "if UNLIKELY", "(!shadow_run_list (main_run_list, list, false)) goto out;", "}", "", "# if DEBUG", "if UNLIKELY", "(fribidi_debug_status ())", "{", "print_types_re (main_run_list);", "print_resolved_levels (main_run_list);", "print_resolved_types (main_run_list);", "}", "# endif\t/* DEBUG */", "", "{", "FriBidiStrIndex pos = 0;", "for_run_list (pp, main_run_list)", "{", "register FriBidiStrIndex l;", "register FriBidiLevel level = pp->level;", "for (l = pp->len; l; l--)", "embedding_levels[pos++] = level;", "}", "}", "", "status = true;", "", "out:", "DBG (\"leaving fribidi_get_par_embedding_levels\");", "", "if (main_run_list)", "free_run_list (main_run_list);", "if UNLIKELY", "(explicits_list) free_run_list (explicits_list);", "", "return status ? max_level + 1 : 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["      PaintPropertyTreeBuilderFragmentContext()", "    : current_effect(EffectPaintPropertyNode::Root()) {", "     : current_effect(&EffectPaintPropertyNode::Root()) {", "    current.clip = absolute_position.clip = fixed_position.clip =", "      ClipPaintPropertyNode::Root();", "       &ClipPaintPropertyNode::Root();", "    current.transform = absolute_position.transform = fixed_position.transform =", "      TransformPaintPropertyNode::Root();", "       &TransformPaintPropertyNode::Root();", "    current.scroll = absolute_position.scroll = fixed_position.scroll =", "      ScrollPaintPropertyNode::Root();", "       &ScrollPaintPropertyNode::Root();", "  }"], "ner_tags": [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0]}
{"tokens": ["  NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(", "      BrowserFrame* browser_frame,", "      BrowserView* browser_view) {", "  if (views::Widget::IsPureViews())", "   if (views::Widget::IsPureViews() &&", "       views::ViewsDelegate::views_delegate->GetDefaultParentView())", "      return new BrowserFrameViews(browser_frame, browser_view);", "    return new BrowserFrameGtk(browser_frame, browser_view);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" RenderFrameHostManager::RenderFrameHostManager(", "     FrameTreeNode* frame_tree_node,", "     RenderFrameHostDelegate* render_frame_delegate,", "     RenderWidgetHostDelegate* render_widget_delegate,", "     Delegate* delegate)", "     : frame_tree_node_(frame_tree_node),", "        delegate_(delegate),", "        render_frame_delegate_(render_frame_delegate),", "        render_widget_delegate_(render_widget_delegate),", "      interstitial_page_(nullptr),", "        weak_factory_(this) {", "    DCHECK(frame_tree_node_);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {", "size_t total_buffer_size = CalculateTotalMessageSize(msg);", "", "MessageWriter input;", "input.Push(sockfd);", "input.Push<uint64_t>(msg->msg_namelen);", "input.Push<uint64_t>(total_buffer_size);", "input.Push<uint64_t>(msg->msg_controllen);", "input.Push(msg->msg_flags);", "input.Push(flags);", "", "MessageReader output;", "", "const auto status = NonSystemCallDispatcher(", "::asylo::host_call::kRecvMsgHandler, &input, &output);", "CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,", "false);", "", "ssize_t result = output.next<ssize_t>();", "int klinux_errno = output.next<int>();", "", "", "", "if (result == -1) {", "errno = FromkLinuxErrorNumber(klinux_errno);", "return result;", "}", "", "auto msg_name_extent = output.next();", "", "if (msg_name_extent.size() <= msg->msg_namelen) {", "msg->msg_namelen = msg_name_extent.size();", "}", "memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);", "", "", "", "auto msg_iov_extent = output.next();", "size_t total_bytes = msg_iov_extent.size();", "size_t bytes_copied = 0;", "for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {", "size_t bytes_to_copy =", "std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);", "memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,", "bytes_to_copy);", "bytes_copied += bytes_to_copy;", "}", "", "auto msg_control_extent = output.next();", "", "if (msg_control_extent.size() <= msg->msg_controllen) {", "msg->msg_controllen = msg_control_extent.size();", "}", "memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);", "", "return result;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long ContentEncoding::ParseEncryptionEntry(", "    long long start,", "    long long size,", "    IMkvReader* pReader,", "    ContentEncryption* encryption) {", " long ContentEncoding::ParseEncryptionEntry(long long start, long long size,", "                                            IMkvReader* pReader,", "                                            ContentEncryption* encryption) {", "    assert(pReader);", "    assert(encryption);", "  ", "  long long pos = start;", "  const long long stop = start + size;", " ", "  ", "    while (pos < stop) {", "      long long id, size;", "    const long status = ParseElementHeader(pReader,", "                                           pos,", "                                           stop,", "                                           id,", "                                           size);", "     const long status = ParseElementHeader(pReader, pos, stop, id, size);", "     if (status < 0)   ", "        return status;", "  ", "      if (id == 0x7E1) {", "       encryption->algo = UnserializeUInt(pReader, pos, size);", "  if (encryption->algo != 5)", " ", "          return E_FILE_FORMAT_INVALID;", "      } else if (id == 0x7E2) {", "      delete[] encryption->key_id;", "       delete[] encryption -> key_id;", "        encryption->key_id = NULL;", "        encryption->key_id_len = 0;", "  ", "  if (size <= 0)", "  return E_FILE_FORMAT_INVALID;", " ", "  const size_t buflen = static_cast<size_t>(size);", "  typedef unsigned char* buf_t;", "  const buf_t buf = new (std::nothrow) unsigned char[buflen];", " ", "        if (buf == NULL)", "          return -1;", "  ", "      const int read_status = pReader->Read(pos, buflen, buf);", "       const int read_status =", "           pReader->Read(pos, static_cast<long>(buflen), buf);", "        if (read_status) {", "        delete [] buf;", "         delete[] buf;", "          return status;", "        }", "  ", "       encryption->key_id = buf;", " ", "        encryption->key_id_len = buflen;", "      } else if (id == 0x7E3) {", "      delete[] encryption->signature;", "       delete[] encryption -> signature;", "        encryption->signature = NULL;", "        encryption->signature_len = 0;", "  ", "  if (size <= 0)", "  return E_FILE_FORMAT_INVALID;", " ", "  const size_t buflen = static_cast<size_t>(size);", "  typedef unsigned char* buf_t;", "  const buf_t buf = new (std::nothrow) unsigned char[buflen];", " ", "        if (buf == NULL)", "          return -1;", "  ", "      const int read_status = pReader->Read(pos, buflen, buf);", "       const int read_status =", "           pReader->Read(pos, static_cast<long>(buflen), buf);", "        if (read_status) {", "        delete [] buf;", "         delete[] buf;", "          return status;", "        }", "  ", "       encryption->signature = buf;", " ", "        encryption->signature_len = buflen;", "      } else if (id == 0x7E4) {", "      delete[] encryption->sig_key_id;", "       delete[] encryption -> sig_key_id;", "        encryption->sig_key_id = NULL;", "        encryption->sig_key_id_len = 0;", "  ", "  if (size <= 0)", "  return E_FILE_FORMAT_INVALID;", " ", "  const size_t buflen = static_cast<size_t>(size);", "  typedef unsigned char* buf_t;", "  const buf_t buf = new (std::nothrow) unsigned char[buflen];", " ", "        if (buf == NULL)", "          return -1;", "  ", "      const int read_status = pReader->Read(pos, buflen, buf);", "       const int read_status =", "           pReader->Read(pos, static_cast<long>(buflen), buf);", "        if (read_status) {", "        delete [] buf;", "         delete[] buf;", "          return status;", "        }", "  ", "       encryption->sig_key_id = buf;", "       encryption->sig_key_id_len = buflen;", "  } else if (id == 0x7E5) {", "       encryption->sig_algo = UnserializeUInt(pReader, pos, size);", "  } else if (id == 0x7E6) {", "       encryption->sig_hash_algo = UnserializeUInt(pReader, pos, size);", " ", "      } else if (id == 0x7E7) {", "        const long status = ParseContentEncAESSettingsEntry(", "          pos,", "          size,", "          pReader,", "          &encryption->aes_settings);", "           pos, size, pReader, &encryption->aes_settings);", "        if (status)", "          return status;", "      }", "  ", "     pos += size;   ", "      assert(pos <= stop);", "    }", "  ", "    return 0;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_parse_bslice(dec_struct_t * ps_dec, UWORD16 u2_first_mb_in_slice)", " {", "  dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;", "  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;", "  dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;", "     UWORD8 u1_ref_idx_re_flag_lx;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;", " ", "     UWORD32 u4_temp, ui_temp1;", "     WORD32 i_temp;", "     WORD32 ret;", " ", "   ", "   ", "   ", "  {", "         WORD8 *pi1_buf;", "         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;", "         WORD32 *pi4_mv = (WORD32*)pi2_mv;", "         WORD16 *pi16_refFrame;", "         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;", "         pi16_refFrame = (WORD16*)pi1_buf;", "  *pi4_mv = 0;", "  *(pi4_mv + 1) = 0;", "  *pi16_refFrame = OUT_OF_RANGE_REF;", "         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8)-1;", "         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8)-1;", "  }", " ", "     ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(", "                     ps_bitstrm);", "     COPYTHECONTEXT(\"SH: num_ref_idx_override_flag\",", "                     ps_slice->u1_num_ref_idx_active_override_flag);", " ", "     u4_temp = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];", "     ui_temp1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];", "  if(ps_slice->u1_num_ref_idx_active_override_flag)", "  {", "         u4_temp = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "         COPYTHECONTEXT(\"SH: num_ref_idx_l0_active_minus1\",", "                         u4_temp - 1);", "         ui_temp1 = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "         COPYTHECONTEXT(\"SH: num_ref_idx_l1_active_minus1\",", "                         ui_temp1 - 1);", "  }", " ", "  {", "         UWORD8 u1_max_ref_idx = MAX_FRAMES;", "  if(ps_slice->u1_field_pic_flag)", "  {", "             u1_max_ref_idx = MAX_FRAMES << 1;", "  }", "  if((u4_temp > u1_max_ref_idx) || (ui_temp1 > u1_max_ref_idx))", "  {", "  return ERROR_NUM_REF;", "  }", "         ps_slice->u1_num_ref_idx_lx_active[0] = u4_temp;", "         ps_slice->u1_num_ref_idx_lx_active[1] = ui_temp1;", "  }", "   ", "   ", "   ", "   ", " ", "  {", "         UWORD8 init_idx_flg = (ps_dec->u1_pr_sl_type", "  != ps_dec->ps_cur_slice->u1_slice_type);", "  if(ps_dec->u1_first_pb_nal_in_pic", "  || (init_idx_flg & !ps_dec->u1_sl_typ_5_9)", "  || ps_dec->u1_num_ref_idx_lx_active_prev", "  != ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0])", "             ih264d_init_ref_idx_lx_b(ps_dec);", "  if(ps_dec->u1_first_pb_nal_in_pic & ps_dec->u1_sl_typ_5_9)", "             ps_dec->u1_first_pb_nal_in_pic = 0;", "  }", "   ", "     ps_dec->u1_num_ref_idx_lx_active_prev =", "                     ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];", " ", "     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);", "     COPYTHECONTEXT(\"SH: ref_pic_list_reordering_flag_l0\",u1_ref_idx_re_flag_lx);", " ", "   ", "  if(u1_ref_idx_re_flag_lx)", "  {", "         WORD8 ret;", "         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];", "         ret = ih264d_ref_idx_reordering(ps_dec, 0);", "  if(ret == -1)", "  return ERROR_REFIDX_ORDER_T;", "  }", "  else", "         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];", " ", "     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);", "     COPYTHECONTEXT(\"SH: ref_pic_list_reordering_flag_l1\",u1_ref_idx_re_flag_lx);", " ", "   ", "  if(u1_ref_idx_re_flag_lx)", "  {", "         WORD8 ret;", "         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];", "         ret = ih264d_ref_idx_reordering(ps_dec, 1);", "  if(ret == -1)", "  return ERROR_REFIDX_ORDER_T;", "  }", "  else", "         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];", " ", "   ", "  {", "  void **ppv_map_ref_idx_to_poc_lx;", "         WORD8 idx;", "  struct pic_buffer_t *ps_pic;", " ", "         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;", "         ppv_map_ref_idx_to_poc_lx[0] = 0;", "         ppv_map_ref_idx_to_poc_lx++;", "  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];", "                         idx++)", "  {", "             ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];", "             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);", "  }", " ", "         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;", " ", "         ppv_map_ref_idx_to_poc_lx[0] = 0;", "         ppv_map_ref_idx_to_poc_lx++;", "  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];", "                         idx++)", "  {", "             ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];", "             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);", "  }", " ", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)", "  {", "  void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;", " ", "  ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc", "  + TOP_LIST_FLD_L0;", "             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc", "  + BOT_LIST_FLD_L0;", " ", "  ppv_map_ref_idx_to_poc_lx_t[0] = 0;", "  ppv_map_ref_idx_to_poc_lx_t++;", "             ppv_map_ref_idx_to_poc_lx_b[0] = 0;", "             ppv_map_ref_idx_to_poc_lx_b++;", "  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];", "                             idx++)", "  {", "                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];", "  ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);", "                 ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);", " ", "                 ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;", "  ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;", " ", "  ppv_map_ref_idx_to_poc_lx_t += 2;", "                 ppv_map_ref_idx_to_poc_lx_b += 2;", "  }", " ", "  ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc", "  + TOP_LIST_FLD_L1;", "             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc", "  + BOT_LIST_FLD_L1;", " ", "  ppv_map_ref_idx_to_poc_lx_t[0] = 0;", "  ppv_map_ref_idx_to_poc_lx_t++;", "             ppv_map_ref_idx_to_poc_lx_b[0] = 0;", "             ppv_map_ref_idx_to_poc_lx_b++;", "  for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];", "                             idx++)", "  {", "                 UWORD8 u1_tmp_idx = idx << 1;", "                 ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];", "  ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);", "                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);", " ", "                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;", "  ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;", " ", "  }", "  }", " ", "  if(ps_dec->u4_num_cores >= 3)", "  {", "             WORD32 num_entries;", "             WORD32 size;", " ", "             num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);", "             num_entries = 2 * ((2 * num_entries) + 1);", " ", "             size = num_entries * sizeof(void *);", "             size += PAD_MAP_IDX_POC * sizeof(void *);", " ", "             memcpy((void *)ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,", "                ps_dec->ppv_map_ref_idx_to_poc,", "                size);", "  }", " ", "  }", " ", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag", "  && (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))", "  {", "         ih264d_convert_frm_mbaff_list(ps_dec);", "  }", " ", "  if(ps_pps->u1_wted_bipred_idc == 1)", "  {", "         ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);", "  if(ret != OK)", "  return ret;", "         ih264d_form_pred_weight_matrix(ps_dec);", "         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;", "  }", "  else if(ps_pps->u1_wted_bipred_idc == 2)", "  {", "   ", "         ps_slice->u2_log2Y_crwd = 0x0505;", "         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;", "         ih264d_get_implicit_weights(ps_dec);", "  }", "  else", "         ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;", " ", "     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =", "                     ps_dec->ps_cur_slice->u2_log2Y_crwd;", " ", "   ", " ", "      if(ps_slice->u1_nal_ref_idc != 0)", "      {", "          if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)", "            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(ps_dec);", "         {", "             i_temp = ih264d_read_mmco_commands(ps_dec);", "             if (i_temp < 0)", "             {", "                 return ERROR_DBP_MANAGER_T;", "             }", "             ps_dec->u4_bitoffset = i_temp;", "         }", "          else", "              ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;", "      }", "   ", " ", "  if(ps_pps->u1_entropy_coding_mode == CABAC)", "  {", "         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "  if(u4_temp > MAX_CABAC_INIT_IDC)", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "         ps_slice->u1_cabac_init_idc = u4_temp;", "         COPYTHECONTEXT(\"SH: cabac_init_idc\",ps_slice->u1_cabac_init_idc);", "  }", " ", "   ", "     i_temp = ps_pps->u1_pic_init_qp", "  + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "  if((i_temp < 0) || (i_temp > 51))", "  {", "  return ERROR_INV_RANGE_QP_T;", "  }", "     ps_slice->u1_slice_qp = i_temp;", "     COPYTHECONTEXT(\"SH: slice_qp_delta\",", "  (WORD8)(ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));", " ", "  if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)", "  {", "         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "  if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  } COPYTHECONTEXT(\"SH: disable_deblocking_filter_idc\", u4_temp);", "         ps_slice->u1_disable_dblk_filter_idc = u4_temp;", "  if(u4_temp != 1)", "  {", "             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)", "  << 1;", "  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "             ps_slice->i1_slice_alpha_c0_offset = i_temp;", "             COPYTHECONTEXT(\"SH: slice_alpha_c0_offset_div2\",", "                             ps_slice->i1_slice_alpha_c0_offset >> 1);", " ", "             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)", "  << 1;", "  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "             ps_slice->i1_slice_beta_offset = i_temp;", "             COPYTHECONTEXT(\"SH: slice_beta_offset_div2\",", "                             ps_slice->i1_slice_beta_offset >> 1);", " ", "  }", "  else", "  {", "             ps_slice->i1_slice_alpha_c0_offset = 0;", "             ps_slice->i1_slice_beta_offset = 0;", "  }", "  }", "  else", "  {", "         ps_slice->u1_disable_dblk_filter_idc = 0;", "         ps_slice->i1_slice_alpha_c0_offset = 0;", "         ps_slice->i1_slice_beta_offset = 0;", "  }", " ", "     ps_dec->u1_slice_header_done = 2;", " ", "  if(ps_pps->u1_entropy_coding_mode)", "  {", "         SWITCHOFFTRACE; SWITCHONTRACECABAC;", "         ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac;", "         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;", "         ih264d_init_cabac_contexts(B_SLICE, ps_dec);", " ", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;", "  else", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;", "  }", "  else", "  {", "         SWITCHONTRACE; SWITCHOFFTRACECABAC;", "         ps_dec->pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc;", "         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;", "  else", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;", "  }", " ", "     ret = ih264d_cal_col_pic(ps_dec);", "  if(ret != OK)", "  return ret;", "     ps_dec->u1_B = 1;", "     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;", "     ret = ps_dec->pf_parse_inter_slice(ps_dec, ps_slice, u2_first_mb_in_slice);", "  if(ret != OK)", "  return ret;", "  return OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void ResourceDispatcherHostImpl::PauseRequest(int child_id,", "                                               int request_id,", "                                               bool pause) {", "   GlobalRequestID global_id(child_id, request_id);", "   PendingRequestList::iterator i = pending_requests_.find(global_id);", "   if (i == pending_requests_.end()) {", "     DVLOG(1) << \"Pausing a request that wasn't found\";", "     return;", "   }", " ", "   ResourceRequestInfoImpl* info =", "       ResourceRequestInfoImpl::ForRequest(i->second);", "   int pause_count = info->pause_count() + (pause ? 1 : -1);", "   if (pause_count < 0) {", "     NOTREACHED();   ", "     return;", "   }", "   info->set_pause_count(pause_count);", " ", "   VLOG(1) << \"To pause (\" << pause << \"): \" << i->second->url().spec();", " ", "    if (info->pause_count() == 0) {", "      MessageLoop::current()->PostTask(FROM_HERE,", "        base::Bind(", "            &ResourceDispatcherHostImpl::ResumeRequest,", "            weak_factory_.GetWeakPtr(),", "            global_id));", "         base::Bind(&ResourceDispatcherHostImpl::ResumeRequest,", "                    AsWeakPtr(), global_id));", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const QString &target, const QByteArray &message) {", "   QByteArray ctcp;", " ", "   QByteArray dequotedMessage = lowLevelDequote(message);", " ", "   CtcpType ctcptype = messageType == Message::Notice", "     ? CtcpReply", "     : CtcpQuery;", " ", "   Message::Flags flags = (messageType == Message::Notice && !network()->isChannelName(target))", "     ? Message::Redirected", "     : Message::None;", " ", "    int xdelimPos = -1;", "    int xdelimEndPos = -1;", "    int spacePos = -1;", "   QList<QByteArray> replies;", "    while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {", "      if(xdelimPos > 0)", "        displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);", "     xdelimEndPos = dequotedMessage.indexOf(XDELIM, xdelimPos + 1);", "     if(xdelimEndPos == -1) {", "       xdelimEndPos = dequotedMessage.count();", "     }", "     ctcp = xdelimDequote(dequotedMessage.mid(xdelimPos + 1, xdelimEndPos - xdelimPos - 1));", "     dequotedMessage = dequotedMessage.mid(xdelimEndPos + 1);", " ", "     QString ctcpcmd = userDecode(target, ctcp.left(spacePos));", "     QString ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));", " ", "     spacePos = ctcp.indexOf(' ');", "     if(spacePos != -1) {", "       ctcpcmd = userDecode(target, ctcp.left(spacePos));", "       ctcpparam = userDecode(target, ctcp.mid(spacePos + 1));", "     } else {", "       ctcpcmd = userDecode(target, ctcp);", "       ctcpparam = QString();", "        ctcpparam = QString();", "      }", "  ", "    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));", "     if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {", "       QString reply_;", "       handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));", "       if(ctcptype == CtcpQuery && !reply_.isNull()) {", "         replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));", "       }", "     }", "   }", "   if(ctcptype == CtcpQuery && !replies.isEmpty()) {", "     packedReply(nickFromMask(prefix), replies);", "    }", "  ", "    if(!dequotedMessage.isEmpty())", " void CtcpHandler::query(const QString &bufname, const QString &ctcpTag, const QString &message) {", "   QList<QByteArray> params;", "   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));", "   emit putCmd(\"PRIVMSG\", params);", " }", " ", " void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QString &message) {", "   QList<QByteArray> params;", "   params << serverEncode(bufname) << lowLevelQuote(pack(serverEncode(ctcpTag), userEncode(bufname, message)));", "   emit putCmd(\"NOTICE\", params);", " }", " ", " void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {", "   Q_UNUSED(ctcptype)", "   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);", " }", "    emit putCmd(\"NOTICE\", params);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" fb_mmap(struct file *file, struct vm_area_struct * vma)", "  {", "  \tstruct fb_info *info = file_fb_info(file);", "  \tstruct fb_ops *fb;", "\tunsigned long off;", " \tunsigned long mmio_pgoff;", "  \tunsigned long start;", "  \tu32 len;", "  ", "  \tif (!info)", "  \t\treturn -ENODEV;", "\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))", "\t\treturn -EINVAL;", "\toff = vma->vm_pgoff << PAGE_SHIFT;", "  \tfb = info->fbops;", "  \tif (!fb)", "  \t\treturn -ENODEV;", " \tmutex_lock(&info->mm_lock);", " \tif (fb->fb_mmap) {", " \t\tint res;", " \t\tres = fb->fb_mmap(info, vma);", " \t\tmutex_unlock(&info->mm_lock);", "  \t\treturn res;", "  \t}", "  ", " \t ", "  \tstart = info->fix.smem_start;", "\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);", "\tif (off >= len) {", "\t\t ", "\t\toff -= len;", "\t\tif (info->var.accel_flags) {", "\t\t\tmutex_unlock(&info->mm_lock);", "\t\t\treturn -EINVAL;", "\t\t}", " \tlen = info->fix.smem_len;", " \tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;", " \tif (vma->vm_pgoff >= mmio_pgoff) {", " \t\tvma->vm_pgoff -= mmio_pgoff;", "  \t\tstart = info->fix.mmio_start;", "\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);", " \t\tlen = info->fix.mmio_len;", "  \t}", "  \tmutex_unlock(&info->mm_lock);", "\tstart &= PAGE_MASK;", "\tif ((vma->vm_end - vma->vm_start + off) > len)", "\t\treturn -EINVAL;", "\toff += start;", "\tvma->vm_pgoff = off >> PAGE_SHIFT;", "\t ", " ", "  \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);", "\tfb_pgprotect(file, vma, off);", "\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,", "\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))", "\t\treturn -EAGAIN;", "\treturn 0;", " \tfb_pgprotect(file, vma, start);", " ", " \treturn vm_iomap_memory(vma, start, len);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" void CairoOutputDev::drawSoftMaskedImage(GfxState *state, Object *ref, Stream *str,", " \t\t\t\tint width, int height,", " \t\t\t\tGfxImageColorMap *colorMap,", " \t\t\t\tStream *maskStr,", " \t\t\t\tint maskWidth, int maskHeight,", " \t\t\t\tGfxImageColorMap *maskColorMap)", " {", "   ImageStream *maskImgStr;", "   maskImgStr = new ImageStream(maskStr, maskWidth,", " \t\t\t\t       maskColorMap->getNumPixelComps(),", " \t\t\t\t       maskColorMap->getBits());", "   maskImgStr->reset();", "  ", "    int row_stride = (maskWidth + 3) & ~3;", "    unsigned char *maskBuffer;", "  maskBuffer = (unsigned char *)gmalloc (row_stride * maskHeight);", "   maskBuffer = (unsigned char *)gmallocn (row_stride, maskHeight);", "    unsigned char *maskDest;", "    cairo_surface_t *maskImage;", "    cairo_pattern_t *maskPattern;", "   Guchar *pix;", "   int y;", "   for (y = 0; y < maskHeight; y++) {", "     maskDest = (unsigned char *) (maskBuffer + y * row_stride);", "     pix = maskImgStr->getLine();", "     maskColorMap->getGrayLine (pix, maskDest, maskWidth);", "   }", " ", "   maskImage = cairo_image_surface_create_for_data (maskBuffer, CAIRO_FORMAT_A8,", " \t\t\t\t\t\t maskWidth, maskHeight, row_stride);", " ", "   delete maskImgStr;", "   maskStr->close();", " ", "   unsigned char *buffer;", "   unsigned int *dest;", "   cairo_surface_t *image;", "   cairo_pattern_t *pattern;", "   ImageStream *imgStr;", "   cairo_matrix_t matrix;", "    cairo_matrix_t maskMatrix;", "    int is_identity_transform;", "  ", "  buffer = (unsigned char *)gmalloc (width * height * 4);", "   buffer = (unsigned char *)gmallocn3 (width, height, 4);", "  ", "     ", "    imgStr = new ImageStream(str, width,", " \t\t\t   colorMap->getNumPixelComps(),", " \t\t\t   colorMap->getBits());", "   imgStr->reset();", "   ", "    ", "   is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||", " \t\t  (colorMap->getColorSpace()->getMode() == csICCBased && ", " \t\t   ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);", " ", "   for (y = 0; y < height; y++) {", "     dest = (unsigned int *) (buffer + y * 4 * width);", "     pix = imgStr->getLine();", "     colorMap->getRGBLine (pix, dest, width);", "   }", " ", "   image = cairo_image_surface_create_for_data (buffer, CAIRO_FORMAT_RGB24,", " \t\t\t\t\t\t width, height, width * 4);", " ", "   if (image == NULL) {", "     delete imgStr;", "     return;", "   }", "   pattern = cairo_pattern_create_for_surface (image);", "   maskPattern = cairo_pattern_create_for_surface (maskImage);", "   if (pattern == NULL) {", "     delete imgStr;", "     return;", "   }", " ", "   LOG (printf (\"drawSoftMaskedImage %dx%d\\n\", width, height));", " ", "   cairo_matrix_init_translate (&matrix, 0, height);", "   cairo_matrix_scale (&matrix, width, -height);", " ", "   cairo_matrix_init_translate (&maskMatrix, 0, maskHeight);", "   cairo_matrix_scale (&maskMatrix, maskWidth, -maskHeight);", " ", "   cairo_pattern_set_matrix (pattern, &matrix);", "   cairo_pattern_set_matrix (maskPattern, &maskMatrix);", " ", "   cairo_pattern_set_filter (pattern, CAIRO_FILTER_BILINEAR);", "   cairo_pattern_set_filter (maskPattern, CAIRO_FILTER_BILINEAR);", "   cairo_set_source (cairo, pattern);", "   cairo_mask (cairo, maskPattern);", " ", "   if (cairo_shape) {", " #if 0", "     cairo_rectangle (cairo_shape, 0., 0., width, height);", "     cairo_fill (cairo_shape);", " #else", "     cairo_save (cairo_shape);", "      ", "      ", "     cairo_set_source (cairo_shape, pattern);", "     cairo_mask (cairo_shape, pattern);", "     cairo_restore (cairo_shape);", " #endif", "   }", " ", "   cairo_pattern_destroy (maskPattern);", "   cairo_surface_destroy (maskImage);", "   cairo_pattern_destroy (pattern);", "   cairo_surface_destroy (image);", "   free (buffer);", "   free (maskBuffer);", " ", "   delete imgStr;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void perf_swevent_overflow(struct perf_event *event, u64 overflow,", "\t\t\t\t    int nmi, struct perf_sample_data *data,", " \t\t\t\t    struct perf_sample_data *data,", "  \t\t\t\t    struct pt_regs *regs)", "  {", "  \tstruct hw_perf_event *hwc = &event->hw;", " \tint throttle = 0;", " ", " \tdata->period = event->hw.last_period;", " \tif (!overflow)", " \t\toverflow = perf_swevent_set_period(event);", " ", " \tif (hwc->interrupts == MAX_INTERRUPTS)", "  \t\treturn;", "  ", "  \tfor (; overflow; overflow--) {", "\t\tif (__perf_event_overflow(event, nmi, throttle,", " \t\tif (__perf_event_overflow(event, throttle,", "  \t\t\t\t\t    data, regs)) {", "  \t\t\t ", " \t\t\tbreak;", " \t\t}", " \t\tthrottle = 1;", " \t}", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,", "     const void *p, size_t tail, int line)", "  {", "  \tconst char *b = (const char *)sst->sst_tab;", "  \tconst char *e = ((const char *)p) + tail;", " \tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?", " \t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);", "  \t(void)&line;", "\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)", " \tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)", "  \t\treturn 0;", "  \tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"", "  \t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"", "  \t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),", "\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));", " \t    ss * sst->sst_len, ss, sst->sst_len));", "  \terrno = EFTYPE;", "  \treturn -1;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" i915_gem_execbuffer2(struct drm_device *dev, void *data,", " \t\t     struct drm_file *file)", " {", " \tstruct drm_i915_gem_execbuffer2 *args = data;", "  \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;", "  \tint ret;", "  ", "\tif (args->buffer_count < 1) {", " \tif (args->buffer_count < 1 ||", " \t    args->buffer_count > UINT_MAX / sizeof(*exec2_list)) {", "  \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);", "  \t\treturn -EINVAL;", "  \t}", " ", " \texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,", " \t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);", " \tif (exec2_list == NULL)", " \t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),", " \t\t\t\t\t   args->buffer_count);", " \tif (exec2_list == NULL) {", " \t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",", " \t\t\t  args->buffer_count);", " \t\treturn -ENOMEM;", " \t}", " \tret = copy_from_user(exec2_list,", " \t\t\t     (struct drm_i915_relocation_entry __user *)", " \t\t\t     (uintptr_t) args->buffers_ptr,", " \t\t\t     sizeof(*exec2_list) * args->buffer_count);", " \tif (ret != 0) {", " \t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",", " \t\t\t  args->buffer_count, ret);", " \t\tdrm_free_large(exec2_list);", " \t\treturn -EFAULT;", " \t}", " ", " \tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);", " \tif (!ret) {", " \t\t ", " \t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)", " \t\t\t\t   (uintptr_t) args->buffers_ptr,", " \t\t\t\t   exec2_list,", " \t\t\t\t   sizeof(*exec2_list) * args->buffer_count);", " \t\tif (ret) {", " \t\t\tret = -EFAULT;", " \t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"", " \t\t\t\t  \"back to user (%d)\\n\",", " \t\t\t\t  args->buffer_count, ret);", " \t\t}", " \t}", " ", " \tdrm_free_large(exec2_list);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["      BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)", "          : mGraphicBuffer(graphicBuffer),", "          mIsBackup(false),", "          mPortIndex(portIndex) {", "           mCopyFromOmx(false),", "           mCopyToOmx(false),", "           mPortIndex(portIndex),", "           mBackup(NULL) {", "      }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["int amf_namf_comm_handle_n1_n2_message_transfer(", "ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg)", "{", "int status;", "", "amf_ue_t *amf_ue = NULL;", "amf_sess_t *sess = NULL;", "", "ogs_pkbuf_t *n1buf = NULL;", "ogs_pkbuf_t *n2buf = NULL;", "", "ogs_pkbuf_t *gmmbuf = NULL;", "ogs_pkbuf_t *ngapbuf = NULL;", "", "char *supi = NULL;", "uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED;", "", "ogs_sbi_message_t sendmsg;", "ogs_sbi_response_t *response = NULL;", "", "OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData;", "OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData;", "OpenAPI_n1_message_container_t *n1MessageContainer = NULL;", "OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL;", "OpenAPI_n2_info_container_t *n2InfoContainer = NULL;", "OpenAPI_n2_sm_information_t *smInfo = NULL;", "OpenAPI_n2_info_content_t *n2InfoContent = NULL;", "OpenAPI_ref_to_binary_data_t *ngapData = NULL;", "", "ogs_assert(stream);", "ogs_assert(recvmsg);", "", "N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData;", "if (!N1N2MessageTransferReqData) {", "ogs_error(\"No N1N2MessageTransferReqData\");", "return OGS_ERROR;", "}", "", "if (N1N2MessageTransferReqData->is_pdu_session_id == false) {", "ogs_error(\"No PDU Session Identity\");", "return OGS_ERROR;", "}", "pdu_session_id = N1N2MessageTransferReqData->pdu_session_id;", "", "supi = recvmsg->h.resource.component[1];", "if (!supi) {", "ogs_error(\"No SUPI\");", "return OGS_ERROR;", "}", "", "amf_ue = amf_ue_find_by_supi(supi);", "if (!amf_ue) {", "ogs_error(\"No UE context [%s]\", supi);", "return OGS_ERROR;", "}", "", "sess = amf_sess_find_by_psi(amf_ue, pdu_session_id);", "if (!sess) {", "ogs_error(\"[%s] No PDU Session Context [%d]\",", "amf_ue->supi, pdu_session_id);", "return OGS_ERROR;", "}", "", "n1MessageContainer = N1N2MessageTransferReqData->n1_message_container;", "if (n1MessageContainer) {", "n1MessageContent = n1MessageContainer->n1_message_content;", "if (!n1MessageContent || !n1MessageContent->content_id) {", "ogs_error(\"No n1MessageContent\");", "return OGS_ERROR;", "}", "", "n1buf = ogs_sbi_find_part_by_content_id(", "recvmsg, n1MessageContent->content_id);", "if (!n1buf) {", "ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "", "", "", "", "", "n1buf = ogs_pkbuf_copy(n1buf);", "ogs_assert(n1buf);", "}", "", "n2InfoContainer = N1N2MessageTransferReqData->n2_info_container;", "if (n2InfoContainer) {", "smInfo = n2InfoContainer->sm_info;", "if (!smInfo) {", "ogs_error(\"No smInfo\");", "return OGS_ERROR;", "}", "n2InfoContent = smInfo->n2_info_content;", "if (!n2InfoContent) {", "ogs_error(\"No n2InfoContent\");", "return OGS_ERROR;", "}", "", "ngapData = n2InfoContent->ngap_data;", "if (!ngapData || !ngapData->content_id) {", "ogs_error(\"No ngapData\");", "return OGS_ERROR;", "}", "n2buf = ogs_sbi_find_part_by_content_id(", "recvmsg, ngapData->content_id);", "if (!n2buf) {", "ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "", "", "", "", "", "n2buf = ogs_pkbuf_copy(n2buf);", "ogs_assert(n2buf);", "}", "", "memset(&sendmsg, 0, sizeof(sendmsg));", "", "status = OGS_SBI_HTTP_STATUS_OK;", "", "memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData));", "N1N2MessageTransferRspData.cause =", "OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED;", "", "sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData;", "", "switch (n2InfoContent->ngap_ie_type) {", "case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ:", "if (!n2buf) {", "ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "", "if (n1buf) {", "gmmbuf = gmm_build_dl_nas_transport(sess,", "OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);", "ogs_assert(gmmbuf);", "}", "", "if (gmmbuf) {", "ran_ue_t *ran_ue = NULL;", "", "", "", "", "", "ran_ue = ran_ue_cycle(amf_ue->ran_ue);", "ogs_assert(ran_ue);", "", "if (sess->pdu_session_establishment_accept) {", "ogs_pkbuf_free(sess->pdu_session_establishment_accept);", "sess->pdu_session_establishment_accept = NULL;", "}", "", "if (ran_ue->initial_context_setup_request_sent == true) {", "ngapbuf = ngap_sess_build_pdu_session_resource_setup_request(", "sess, gmmbuf, n2buf);", "ogs_assert(ngapbuf);", "} else {", "ngapbuf = ngap_sess_build_initial_context_setup_request(", "sess, gmmbuf, n2buf);", "ogs_assert(ngapbuf);", "", "ran_ue->initial_context_setup_request_sent = true;", "}", "", "if (SESSION_CONTEXT_IN_SMF(sess)) {", "", "", "", "", "", "", "", "", "if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)", "ogs_error(\"nas_5gs_send_to_gnb() failed\");", "} else {", "sess->pdu_session_establishment_accept = ngapbuf;", "}", "", "} else {", "", "", "", "", "if (CM_IDLE(amf_ue)) {", "ogs_sbi_server_t *server = NULL;", "ogs_sbi_header_t header;", "ogs_sbi_client_t *client = NULL;", "ogs_sockaddr_t *addr = NULL;", "", "if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) {", "ogs_error(\"[%s:%d] No n1-n2-failure-notification-uri\",", "amf_ue->supi, sess->psi);", "return OGS_ERROR;", "}", "", "addr = ogs_sbi_getaddr_from_uri(", "N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);", "if (!addr) {", "ogs_error(\"[%s:%d] Invalid URI [%s]\",", "amf_ue->supi, sess->psi,", "N1N2MessageTransferReqData->", "n1n2_failure_txf_notif_uri);", "return OGS_ERROR;;", "}", "", "client = ogs_sbi_client_find(addr);", "if (!client) {", "client = ogs_sbi_client_add(addr);", "ogs_assert(client);", "}", "OGS_SETUP_SBI_CLIENT(&sess->paging, client);", "", "ogs_freeaddrinfo(addr);", "", "status = OGS_SBI_HTTP_STATUS_ACCEPTED;", "N1N2MessageTransferRspData.cause =", "OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;", "", "", "server = ogs_sbi_server_from_stream(stream);", "ogs_assert(server);", "", "memset(&header, 0, sizeof(header));", "header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;", "header.api.version = (char *)OGS_SBI_API_V1;", "header.resource.component[0] =", "(char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;", "header.resource.component[1] = amf_ue->supi;", "header.resource.component[2] =", "(char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;", "header.resource.component[3] = sess->sm_context_ref;", "", "sendmsg.http.location = ogs_sbi_server_uri(server, &header);", "", "", "AMF_SESS_STORE_PAGING_INFO(", "sess, sendmsg.http.location,", "N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri);", "", "", "AMF_SESS_STORE_N2_TRANSFER(", "sess, pdu_session_resource_setup_request, n2buf);", "", "ogs_assert(OGS_OK == ngap_send_paging(amf_ue));", "", "} else if (CM_CONNECTED(amf_ue)) {", "ogs_assert(OGS_OK ==", "ngap_send_pdu_resource_setup_request(sess, n2buf));", "", "} else {", "", "ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);", "ogs_assert_if_reached();", "", "}", "", "}", "break;", "", "case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ:", "if (!n1buf) {", "ogs_error(\"[%s] No N1 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "if (!n2buf) {", "ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "", "if (CM_IDLE(amf_ue)) {", "ogs_sbi_server_t *server = NULL;", "ogs_sbi_header_t header;", "", "status = OGS_SBI_HTTP_STATUS_ACCEPTED;", "N1N2MessageTransferRspData.cause =", "OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE;", "", "", "server = ogs_sbi_server_from_stream(stream);", "ogs_assert(server);", "", "memset(&header, 0, sizeof(header));", "header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM;", "header.api.version = (char *)OGS_SBI_API_V1;", "header.resource.component[0] =", "(char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS;", "header.resource.component[1] = amf_ue->supi;", "header.resource.component[2] =", "(char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES;", "header.resource.component[3] = sess->sm_context_ref;", "", "sendmsg.http.location = ogs_sbi_server_uri(server, &header);", "", "", "AMF_SESS_STORE_PAGING_INFO(", "sess, sendmsg.http.location, NULL);", "", "", "AMF_SESS_STORE_5GSM_MESSAGE(sess,", "OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND,", "n1buf, n2buf);", "", "ogs_assert(OGS_OK == ngap_send_paging(amf_ue));", "", "} else if (CM_CONNECTED(amf_ue)) {", "gmmbuf = gmm_build_dl_nas_transport(sess,", "OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0);", "ogs_assert(gmmbuf);", "", "ngapbuf = ngap_build_pdu_session_resource_modify_request(", "sess, gmmbuf, n2buf);", "ogs_assert(ngapbuf);", "", "if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)", "ogs_error(\"nas_5gs_send_to_gnb() failed\");", "", "} else {", "ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);", "ogs_assert_if_reached();", "}", "", "break;", "", "case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD:", "if (!n2buf) {", "ogs_error(\"[%s] No N2 SM Content\", amf_ue->supi);", "return OGS_ERROR;", "}", "", "if (n1buf)", "ogs_pkbuf_free(n1buf);", "", "if (CM_IDLE(amf_ue)) {", "if (n2buf)", "ogs_pkbuf_free(n2buf);", "", "if (N1N2MessageTransferReqData->is_skip_ind == true &&", "N1N2MessageTransferReqData->skip_ind == true) {", "N1N2MessageTransferRspData.cause =", "OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED;", "} else {", "ogs_fatal(\"[%s] No skipInd\", amf_ue->supi);", "ogs_assert_if_reached();", "}", "", "} else if (CM_CONNECTED(amf_ue)) {", "ngapbuf = ngap_build_pdu_session_resource_release_command(", "sess, NULL, n2buf);", "ogs_assert(ngapbuf);", "", "if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK)", "ogs_error(\"nas_5gs_send_to_gnb() failed\");", "", "} else {", "ogs_fatal(\"[%s] Invalid AMF-UE state\", amf_ue->supi);", "ogs_assert_if_reached();", "}", "break;", "", "default:", "ogs_error(\"Not implemented ngap_ie_type[%d]\",", "n2InfoContent->ngap_ie_type);", "ogs_assert_if_reached();", "}", "", "response = ogs_sbi_build_response(&sendmsg, status);", "ogs_assert(response);", "ogs_assert(true == ogs_sbi_server_send_response(stream, response));", "", "if (sendmsg.http.location)", "ogs_free(sendmsg.http.location);", "", "return OGS_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void __xen_evtchn_do_upcall(void)", "{", "struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);", "int cpu = smp_processor_id();", "", "do {", "vcpu_info->evtchn_upcall_pending = 0;", "", "xen_evtchn_handle_events(cpu);", "", "BUG_ON(!irqs_disabled());", "", "virt_rmb();", "", "} while (vcpu_info->evtchn_upcall_pending);", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static void become_daemon(const char *pidfile)", " {", " #ifndef _WIN32", "     pid_t pid, sid;", " ", "     pid = fork();", "     if (pid < 0) {", "         exit(EXIT_FAILURE);", "     }", "     if (pid > 0) {", "         exit(EXIT_SUCCESS);", "     }", " ", "     if (pidfile) {", "         if (!ga_open_pidfile(pidfile)) {", "             g_critical(\"failed to create pidfile\");", "             exit(EXIT_FAILURE);", "          }", "      }", "  ", "    umask(0);", "     umask(S_IRWXG | S_IRWXO);", "      sid = setsid();", "      if (sid < 0) {", "          goto fail;", "     }", "     if ((chdir(\"/\")) < 0) {", "         goto fail;", "     }", " ", "     reopen_fd_to_null(STDIN_FILENO);", "     reopen_fd_to_null(STDOUT_FILENO);", "     reopen_fd_to_null(STDERR_FILENO);", "     return;", " ", " fail:", "     if (pidfile) {", "         unlink(pidfile);", "     }", "     g_critical(\"failed to daemonize\");", "     exit(EXIT_FAILURE);", " #endif", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool OutOfProcessInstance::Init(uint32_t argc,", "                                  const char* argn[],", "                                  const char* argv[]) {", "    ", "    ", "    pp::Var document_url_var = pp::URLUtil_Dev::Get()->GetDocumentURL(this);", "  std::string document_url = document_url_var.is_string() ?", "      document_url_var.AsString() : std::string();", "   if (!document_url_var.is_string())", "     return false;", "   std::string document_url = document_url_var.AsString();", "    std::string extension_url = std::string(kChromeExtension);", "  bool in_extension =", "      !document_url.compare(0, extension_url.size(), extension_url);", "  if (in_extension) {", "    for (uint32_t i = 0; i < argc; ++i) {", "      if (strcmp(argn[i], \"full-frame\") == 0) {", "        full_ = true;", "        break;", "      }", "   std::string print_preview_url = std::string(kChromePrint);", "   if (!base::StringPiece(document_url).starts_with(kChromeExtension) &&", "       !base::StringPiece(document_url).starts_with(kChromePrint)) {", "     return false;", "   }", " ", "    ", "   for (uint32_t i = 0; i < argc; ++i) {", "     if (strcmp(argn[i], \"full-frame\") == 0) {", "       full_ = true;", "       break;", "      }", "    }", "  ", "   if (full_)", "     SetPluginToHandleFindRequests();", " ", "   pp::VarDictionary translated_strings;", "   translated_strings.Set(kType, kJSSetTranslatedStringsType);", "   translated_strings.Set(kJSGetPasswordString,", "       GetLocalizedString(PP_RESOURCESTRING_PDFGETPASSWORD));", "   translated_strings.Set(kJSLoadingString,", "       GetLocalizedString(PP_RESOURCESTRING_PDFLOADING));", "   translated_strings.Set(kJSLoadFailedString,", "       GetLocalizedString(PP_RESOURCESTRING_PDFLOAD_FAILED));", "   PostMessage(translated_strings);", " ", "   text_input_.reset(new pp::TextInput_Dev(this));", " ", "   const char* stream_url = nullptr;", "   const char* original_url = nullptr;", "   const char* headers = nullptr;", "   bool is_material = false;", "   for (uint32_t i = 0; i < argc; ++i) {", "     if (strcmp(argn[i], \"src\") == 0)", "       original_url = argv[i];", "     else if (strcmp(argn[i], \"stream-url\") == 0)", "       stream_url = argv[i];", "     else if (strcmp(argn[i], \"headers\") == 0)", "       headers = argv[i];", "     else if (strcmp(argn[i], \"is-material\") == 0)", "       is_material = true;", "     else if (strcmp(argn[i], \"top-toolbar-height\") == 0)", "       base::StringToInt(argv[i], &top_toolbar_height_);", "   }", " ", "   if (is_material)", "     background_color_ = kBackgroundColorMaterial;", "   else", "     background_color_ = kBackgroundColor;", " ", "   if (!original_url)", "     return false;", " ", "   if (!stream_url)", "     stream_url = original_url;", " ", "   if (IsPrintPreviewUrl(original_url))", "     return true;", " ", "   LoadUrl(stream_url);", "   url_ = original_url;", "   return engine_->New(original_url, headers);", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  decompileAction(int n, SWF_ACTION *actions, int maxn)", "  {", "\tif( n > maxn ) SWF_error(\"Action overflow!!\");", "  ", "  #ifdef DEBUG", "  \tfprintf(stderr,\"%d:\\tACTION[%3.3d]: %s\\n\",", "  \t        actions[n].SWF_ACTIONRECORD.Offset, n, ", "  \t        actionName(actions[n].SWF_ACTIONRECORD.ActionCode));", "  #endif", "  ", "\tswitch(actions[n].SWF_ACTIONRECORD.ActionCode)", " \tswitch(OpCode(actions, n, maxn))", "  \t{", "  \tcase SWFACTION_END:", "  \t\treturn 0;", " ", " \tcase SWFACTION_CONSTANTPOOL:", " \t\tdecompileCONSTANTPOOL(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_GOTOLABEL:", " \t\treturn decompileGOTOFRAME(n, actions, maxn,1);", " ", " \tcase SWFACTION_GOTOFRAME:", " \t\treturn decompileGOTOFRAME(n, actions, maxn,0);", " ", " \tcase SWFACTION_GOTOFRAME2:", " \t\treturn decompileGOTOFRAME2(n, actions, maxn);", " ", " \tcase SWFACTION_WAITFORFRAME:", " \t\tdecompileWAITFORFRAME(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETURL2:", " \t\tdecompileGETURL2(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETURL:", " \t\tdecompileGETURL(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_PUSH:", " \t\tdecompilePUSH(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_PUSHDUP:", " \t\tdecompilePUSHDUP(&actions[n]);", " \t\treturn 0;", " ", " \tcase SWFACTION_STACKSWAP:", " \t\tdecompileSTACKSWAP(&actions[n]);\t", " \t\treturn 0;", " ", " \tcase SWFACTION_SETPROPERTY:", " \t\tdecompileSETPROPERTY(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETPROPERTY:", " \t\tdecompileGETPROPERTY(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETTIME:", " \t\treturn decompileGETTIME(n, actions, maxn);", " ", " \tcase SWFACTION_TRACE:", " \t\tdecompileTRACE(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_CALLFRAME:", " \t\tdecompileCALLFRAME(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_EXTENDS:", " \t\tdecompileEXTENDS(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_INITOBJECT:", " \t\tdecompileINITOBJECT(n, actions, maxn);", " \t\treturn 0;\t        ", " ", " \tcase SWFACTION_NEWOBJECT:", " \t\tdecompileNEWOBJECT(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_NEWMETHOD:", " \t\tdecompileNEWMETHOD(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETMEMBER:", " \t\tdecompileGETMEMBER(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_SETMEMBER:", " \t\tdecompileSETMEMBER(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_GETVARIABLE:", " \t\tdecompileGETVARIABLE(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_SETVARIABLE:", " \t\tdecompileSETVARIABLE(n, actions, maxn, 0);", " \t\treturn 0;", " ", " \tcase SWFACTION_DEFINELOCAL:", " \t\tdecompileSETVARIABLE(n, actions, maxn, 1);", " \t\treturn 0;", " ", " \tcase SWFACTION_DEFINELOCAL2:", " \t\tdecompileDEFINELOCAL2(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_DECREMENT:", " \t\treturn decompileINCR_DECR(n, actions, maxn, 0);", " ", " \tcase SWFACTION_INCREMENT:", " \t\treturn decompileINCR_DECR(n, actions, maxn,1);", " ", " \tcase SWFACTION_STOREREGISTER:", " \t\tdecompileSTOREREGISTER(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_JUMP:", " \t\treturn decompileJUMP(n, actions, maxn);", " ", " \tcase SWFACTION_RETURN:", " \t\tdecompileRETURN(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_LOGICALNOT:", " \t\treturn decompileLogicalNot(n, actions, maxn);", " ", " \tcase SWFACTION_IF:", " \t\treturn decompileIF(n, actions, maxn);", " ", " \tcase SWFACTION_WITH:", " \t\tdecompileWITH(n, actions, maxn);", " \t\treturn 0;", " ", " \tcase SWFACTION_ENUMERATE:", " \t\treturn decompileENUMERATE(n, actions, maxn, 0);", " ", " \tcase SWFACTION_ENUMERATE2 :", " \t\treturn decompileENUMERATE(n, actions, maxn,1);", " ", " \tcase SWFACTION_INITARRAY:", " \t\treturn decompileINITARRAY(n, actions, maxn);", " ", " \tcase SWFACTION_DEFINEFUNCTION:\t", " \t\treturn decompileDEFINEFUNCTION(n, actions, maxn,0);", " ", " \tcase SWFACTION_DEFINEFUNCTION2:", " \t\treturn decompileDEFINEFUNCTION(n, actions, maxn,1);", " ", " \tcase SWFACTION_CALLFUNCTION:", " \t\treturn decompileCALLFUNCTION(n, actions, maxn);", " ", " \tcase SWFACTION_CALLMETHOD:", " \t\treturn decompileCALLMETHOD(n, actions, maxn);", " ", " \tcase SWFACTION_INSTANCEOF:", " \tcase SWFACTION_SHIFTLEFT:", " \tcase SWFACTION_SHIFTRIGHT:", " \tcase SWFACTION_SHIFTRIGHT2:        ", " \tcase SWFACTION_ADD:", " \tcase SWFACTION_ADD2:", " \tcase SWFACTION_SUBTRACT:", " \tcase SWFACTION_MULTIPLY:", " \tcase SWFACTION_DIVIDE:", " \tcase SWFACTION_MODULO:", " \tcase SWFACTION_BITWISEAND:", " \tcase SWFACTION_BITWISEOR:", " \tcase SWFACTION_BITWISEXOR:", " \tcase SWFACTION_EQUAL:", " \tcase SWFACTION_EQUALS2:", " \tcase SWFACTION_LESS2:", " \tcase SWFACTION_LOGICALAND:", " \tcase SWFACTION_LOGICALOR:", " \tcase SWFACTION_GREATER:", " \tcase SWFACTION_LESSTHAN:", " \tcase SWFACTION_STRINGEQ:", " \tcase SWFACTION_STRINGCOMPARE:", " \tcase SWFACTION_STRICTEQUALS:", " \t\treturn decompileArithmeticOp(n, actions, maxn);", " ", " \tcase SWFACTION_POP:", " \t\tpop();", " \t\treturn 0;", " ", " \tcase SWFACTION_STARTDRAG:", " \t\treturn decompileSTARTDRAG(n, actions, maxn);", " ", " \tcase SWFACTION_DELETE:", " \t\treturn decompileDELETE(n, actions, maxn,0);", " ", " \tcase SWFACTION_DELETE2:", " \t\treturn decompileDELETE(n, actions, maxn,1);", " ", " \tcase SWFACTION_TARGETPATH:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"targetPath\");", " ", " \tcase SWFACTION_TYPEOF:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"typeof\");", " ", " \tcase SWFACTION_ORD:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"ord\");", " ", " \tcase SWFACTION_CHR:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"chr\");", " ", " \tcase SWFACTION_INT:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"int\");", " ", " \tcase SWFACTION_TOSTRING:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"String\");     ", " ", " \tcase SWFACTION_TONUMBER:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"Number\");", " ", " \tcase SWFACTION_RANDOMNUMBER:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"random\");", " ", " \tcase SWFACTION_STRINGLENGTH:", " \t\treturn decompileSingleArgBuiltInFunctionCall(n, actions, maxn,\"length\");", " ", " \tcase SWFACTION_PLAY:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"play\");", " ", " \tcase SWFACTION_STOP:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stop\");", " ", " \tcase SWFACTION_NEXTFRAME:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"nextFrame\");", " ", " \tcase SWFACTION_PREVFRAME:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"prevFrame\");", " ", " \tcase SWFACTION_ENDDRAG:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopDrag\");", " ", " \tcase SWFACTION_STOPSOUNDS:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"stopAllSounds\");   ", " ", " \tcase SWFACTION_TOGGLEQUALITY:", " \t\treturn decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,\"toggleHighQuality\");      ", " ", " \tcase SWFACTION_MBSUBSTRING:", " \tcase SWFACTION_SUBSTRING:", " \t\treturn decompileSUBSTRING(n, actions, maxn);", " ", " \tcase SWFACTION_STRINGCONCAT:", " \t\treturn decompileSTRINGCONCAT(n, actions, maxn);", " ", " \tcase SWFACTION_REMOVECLIP:", " \t\treturn decompileREMOVECLIP(n, actions, maxn);", " ", " \tcase SWFACTION_DUPLICATECLIP:", " \t\treturn decompileDUPLICATECLIP(n, actions, maxn);", " ", " \tcase SWFACTION_SETTARGET:", " \t\treturn decompileSETTARGET(n, actions, maxn,0);", " ", " \tcase SWFACTION_SETTARGET2:", " \t\treturn decompileSETTARGET(n, actions, maxn,1);", " ", " \tcase SWFACTION_IMPLEMENTSOP:", " \t\treturn decompileIMPLEMENTS(n, actions, maxn);", " ", " \tcase SWFACTION_CASTOP:", " \t\treturn decompileCAST(n, actions, maxn);", " ", " \tcase SWFACTION_THROW:", " \t\treturn decompileTHROW(n, actions, maxn);", " ", " \tcase SWFACTION_TRY:", " \t\treturn decompileTRY(n, actions, maxn);", " ", " \tdefault:", " \t\toutputSWF_ACTION(n,&actions[n]);", " \t\treturn 0;", " \t}", " }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool AppCacheDatabase::FindEntry(int64_t cache_id,", "                                  const GURL& url,", "                                  EntryRecord* record) {", "   DCHECK(record);", "   if (!LazyOpen(kDontCreate))", "      return false;", "  ", "    static const char kSql[] =", "      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"", "       \"SELECT cache_id, url, flags, response_id, response_size, padding_size \"", "       \"FROM Entries\"", "        \"  WHERE cache_id = ? AND url = ?\";", "  ", "    sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));", "   statement.BindInt64(0, cache_id);", "   statement.BindString(1, url.spec());", " ", "   if (!statement.Step())", "     return false;", " ", "   ReadEntryRecord(statement, record);", "   DCHECK(record->cache_id == cache_id);", "   DCHECK(record->url == url);", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", "   char", "     explicit_vr[MaxTextExtent],", "     implicit_vr[MaxTextExtent],", "     magick[MaxTextExtent],", "     photometric[MaxTextExtent];", " ", "   DCMStreamInfo", "     *stream_info;", " ", "   Image", "     *image;", " ", "   int", "     *bluemap,", "     datum,", "     *greenmap,", "     *graymap,", "     index,", "     *redmap;", " ", "   MagickBooleanType", "     explicit_file,", "     explicit_retry,", "     polarity,", "     sequence,", "     use_explicit;", " ", "   MagickOffsetType", "     offset;", " ", "   Quantum", "     *scale;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   register unsigned char", "     *p;", " ", "   size_t", "     bits_allocated,", "     bytes_per_pixel,", "     colors,", "     depth,", "     height,", "     length,", "     mask,", "     max_value,", "     number_scenes,", "     quantum,", "     samples_per_pixel,", "     signed_data,", "     significant_bits,", "     status,", "     width,", "     window_width;", " ", "   ssize_t", "     count,", "     scene,", "     window_center,", "     y;", " ", "   unsigned char", "     *data;", " ", "   unsigned short", "     group,", "     element;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   image->depth=8UL;", "   image->endian=LSBEndian;", "    ", "   stream_info=(DCMStreamInfo *) AcquireMagickMemory(sizeof(*stream_info));", "   if (stream_info == (DCMStreamInfo *) NULL)", "     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "   (void) ResetMagickMemory(stream_info,0,sizeof(*stream_info));", "   count=ReadBlob(image,128,(unsigned char *) magick);", "   if (count != 128)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   count=ReadBlob(image,4,(unsigned char *) magick);", "   if ((count != 4) || (LocaleNCompare(magick,\"DICM\",4) != 0))", "     {", "       offset=SeekBlob(image,0L,SEEK_SET);", "       if (offset < 0)", "         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     }", "    ", "   (void) CopyMagickString(photometric,\"MONOCHROME1 \",MaxTextExtent);", "   bits_allocated=8;", "   bytes_per_pixel=1;", "   polarity=MagickFalse;", "   data=(unsigned char *) NULL;", "   depth=8;", "   element=0;", "   explicit_vr[2]='\\0';", "   explicit_file=MagickFalse;", "   colors=0;", "   redmap=(int *) NULL;", "   greenmap=(int *) NULL;", "   bluemap=(int *) NULL;", "   graymap=(int *) NULL;", "   height=0;", "   max_value=255UL;", "   mask=0xffff;", "   number_scenes=1;", "   samples_per_pixel=1;", "   scale=(Quantum *) NULL;", "   sequence=MagickFalse;", "   signed_data=(~0UL);", "   significant_bits=0;", "   use_explicit=MagickFalse;", "   explicit_retry = MagickFalse;", "   width=0;", "   window_center=0;", "   window_width=0;", "   for (group=0; (group != 0x7FE0) || (element != 0x0010) ||", "                 (sequence != MagickFalse); )", "   {", "      ", "     image->offset=(ssize_t) TellBlob(image);", "     group=ReadBlobLSBShort(image);", "     element=ReadBlobLSBShort(image);", "     if ((group != 0x0002) && (image->endian == MSBEndian))", "       {", "         group=(unsigned short) ((group << 8) | ((group >> 8) & 0xFF));", "         element=(unsigned short) ((element << 8) | ((element >> 8) & 0xFF));", "       }", "     quantum=0;", "      ", "     for (i=0; dicom_info[i].group < 0xffff; i++)", "       if ((group == dicom_info[i].group) && (element == dicom_info[i].element))", "         break;", "     (void) CopyMagickString(implicit_vr,dicom_info[i].vr,MaxTextExtent);", "     count=ReadBlob(image,2,(unsigned char *) explicit_vr);", "     if (count != 2)", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "      ", "     if ((explicit_file == MagickFalse) && (group != 0x0002))", "       explicit_file=(isupper((unsigned char) *explicit_vr) != MagickFalse) &&", "         (isupper((unsigned char) *(explicit_vr+1)) != MagickFalse) ?", "         MagickTrue : MagickFalse;", "     use_explicit=((group == 0x0002) && (explicit_retry == MagickFalse)) ||", "       (explicit_file != MagickFalse) ? MagickTrue : MagickFalse;", "     if ((use_explicit != MagickFalse) && (strcmp(implicit_vr,\"xs\") == 0))", "       (void) CopyMagickString(implicit_vr,explicit_vr,MaxTextExtent);", "     if ((use_explicit == MagickFalse) || (strcmp(implicit_vr,\"!!\") == 0))", "       {", "         offset=SeekBlob(image,(MagickOffsetType) -2,SEEK_CUR);", "         if (offset < 0)", "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         quantum=4;", "       }", "     else", "       {", "          ", "         quantum=2;", "         if ((strcmp(explicit_vr,\"OB\") == 0) ||", "             (strcmp(explicit_vr,\"UN\") == 0) ||", "             (strcmp(explicit_vr,\"OW\") == 0) || (strcmp(explicit_vr,\"SQ\") == 0))", "           {", "             (void) ReadBlobLSBShort(image);", "             quantum=4;", "           }", "       }", "     datum=0;", "     if (quantum == 4)", "       {", "         if (group == 0x0002)", "           datum=(int) ReadBlobLSBLong(image);", "         else", "           datum=(int) ReadBlobLong(image);", "       }", "     else", "       if (quantum == 2)", "         {", "           if (group == 0x0002)", "             datum=(int) ReadBlobLSBShort(image);", "           else", "             datum=(int) ReadBlobShort(image);", "         }", "     quantum=0;", "     length=1;", "     if (datum != 0)", "       {", "         if ((strcmp(implicit_vr,\"SS\") == 0) ||", "             (strcmp(implicit_vr,\"US\") == 0))", "           quantum=2;", "         else", "           if ((strcmp(implicit_vr,\"UL\") == 0) ||", "               (strcmp(implicit_vr,\"SL\") == 0) ||", "               (strcmp(implicit_vr,\"FL\") == 0))", "             quantum=4;", "           else", "             if (strcmp(implicit_vr,\"FD\") != 0)", "               quantum=1;", "             else", "               quantum=8;", "         if (datum != ~0)", "           length=(size_t) datum/quantum;", "         else", "           {", "              ", "             quantum=0;", "             length=0;", "           }", "       }", "     if (image_info->verbose != MagickFalse)", "       {", "          ", "         if (use_explicit == MagickFalse)", "           explicit_vr[0]='\\0';", "         for (i=0; dicom_info[i].description != (char *) NULL; i++)", "           if ((group == dicom_info[i].group) &&", "               (element == dicom_info[i].element))", "             break;", "         (void) FormatLocaleFile(stdout,\"0x%04lX %4ld %s-%s (0x%04lx,0x%04lx)\",", "           (unsigned long) image->offset,(long) length,implicit_vr,explicit_vr,", "           (unsigned long) group,(unsigned long) element);", "         if (dicom_info[i].description != (char *) NULL)", "           (void) FormatLocaleFile(stdout,\" %s\",dicom_info[i].description);", "         (void) FormatLocaleFile(stdout,\": \");", "       }", "     if ((sequence == MagickFalse) && (group == 0x7FE0) && (element == 0x0010))", "       {", "         if (image_info->verbose != MagickFalse)", "           (void) FormatLocaleFile(stdout,\"\\n\");", "         break;", "       }", "      ", "     data=(unsigned char *) NULL;", "     if ((length == 1) && (quantum == 1))", "       datum=(int) ReadBlobByte(image);", "     else", "       if ((length == 1) && (quantum == 2))", "         {", "           if (group == 0x0002)", "             datum=(int) ReadBlobLSBShort(image);", "           else", "             datum=(int) ReadBlobShort(image);", "         }", "       else", "         if ((length == 1) && (quantum == 4))", "           {", "             if (group == 0x0002)", "               datum=(int) ReadBlobLSBLong(image);", "             else", "               datum=(int) ReadBlobLong(image);", "           }", "         else", "           if ((quantum != 0) && (length != 0))", "             {", "               if (~length >= 1)", "                 data=(unsigned char *) AcquireQuantumMemory(length+1,quantum*", "                   sizeof(*data));", "               if (data == (unsigned char *) NULL)", "                 ThrowReaderException(ResourceLimitError,", "                   \"MemoryAllocationFailed\");", "               count=ReadBlob(image,(size_t) quantum*length,data);", "               if (count != (ssize_t) (quantum*length))", "                 {", "                   if (image_info->verbose != MagickFalse)", "                     (void) FormatLocaleFile(stdout,\"count=%d quantum=%d \"", "                       \"length=%d group=%d\\n\",(int) count,(int) quantum,(int)", "                       length,(int) group);", "                    ThrowReaderException(CorruptImageError,", "                      \"InsufficientImageDataInFile\");", "                 }", "               data[length*quantum]='\\0';", "             }", "           else", "             if ((unsigned int) datum == 0xFFFFFFFFU)", "               {", "                 sequence=MagickTrue;", "                 continue;", "               }", "     if ((unsigned int) ((group << 16) | element) == 0xFFFEE0DD)", "       {", "         if (data != (unsigned char *) NULL)", "           data=(unsigned char *) RelinquishMagickMemory(data);", "         sequence=MagickFalse;", "         continue;", "       }", "     if (sequence != MagickFalse)", "       {", "         if (data != (unsigned char *) NULL)", "           data=(unsigned char *) RelinquishMagickMemory(data);", "         continue;", "       }", "     switch (group)", "     {", "       case 0x0002:", "       {", "         switch (element)", "         {", "           case 0x0010:", "           {", "             char", "               transfer_syntax[MaxTextExtent];", " ", "              ", "             if ((datum == 0) && (explicit_retry == MagickFalse))", "               {", "                 explicit_retry=MagickTrue;", "                 (void) SeekBlob(image,(MagickOffsetType) 0,SEEK_SET);", "                 group=0;", "                 element=0;", "                 if (image_info->verbose != MagickFalse)", "                   (void) FormatLocaleFile(stdout,", "                     \"Corrupted image - trying explicit format\\n\");", "                 break;", "               }", "             *transfer_syntax='\\0';", "             if (data != (unsigned char *) NULL)", "               (void) CopyMagickString(transfer_syntax,(char *) data,", "                 MaxTextExtent);", "             if (image_info->verbose != MagickFalse)", "               (void) FormatLocaleFile(stdout,\"transfer_syntax=%s\\n\",", "                 (const char *) transfer_syntax);", "             if (strncmp(transfer_syntax,\"1.2.840.10008.1.2\",17) == 0)", "               {", "                 int", "                   subtype,", "                   type;", " ", "                 type=0;", "                 subtype=0;", "                 (void) sscanf(transfer_syntax+17,\".%d.%d\",&type,&subtype);", "                 switch (type)", "                 {", "                   case 1:", "                   {", "                     image->endian=LSBEndian;", "                     break;", "                   }", "                   case 2:", "                   {", "                     image->endian=MSBEndian;", "                     break;", "                   }", "                   case 4:", "                   {", "                     if ((subtype >= 80) && (subtype <= 81))", "                       image->compression=JPEGCompression;", "                     else", "                       if ((subtype >= 90) && (subtype <= 93))", "                         image->compression=JPEG2000Compression;", "                       else", "                         image->compression=JPEGCompression;", "                     break;", "                   }", "                   case 5:", "                   {", "                     image->compression=RLECompression;", "                     break;", "                   }", "                 }", "               }", "             break;", "           }", "           default:", "             break;", "         }", "         break;", "       }", "       case 0x0028:", "       {", "         switch (element)", "         {", "           case 0x0002:", "           {", "              ", "             samples_per_pixel=(size_t) datum;", "             break;", "           }", "           case 0x0004:", "           {", "              ", "             for (i=0; i < (ssize_t) MagickMin(length,MaxTextExtent-1); i++)", "               photometric[i]=(char) data[i];", "             photometric[i]='\\0';", "             polarity=LocaleCompare(photometric,\"MONOCHROME1 \") == 0 ?", "               MagickTrue : MagickFalse;", "             break;", "           }", "           case 0x0006:", "           {", "              ", "             if (datum == 1)", "               image->interlace=PlaneInterlace;", "             break;", "           }", "           case 0x0008:", "           {", "              ", "             number_scenes=StringToUnsignedLong((char *) data);", "             break;", "           }", "           case 0x0010:", "           {", "              ", "             height=(size_t) datum;", "             break;", "           }", "           case 0x0011:", "           {", "              ", "             width=(size_t) datum;", "             break;", "           }", "           case 0x0100:", "           {", "              ", "             bits_allocated=(size_t) datum;", "             bytes_per_pixel=1;", "             if (datum > 8)", "               bytes_per_pixel=2;", "             depth=bits_allocated;", "             if (depth > 32)", "               ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "             max_value=(1UL << bits_allocated)-1;", "             break;", "           }", "           case 0x0101:", "           {", "              ", "             significant_bits=(size_t) datum;", "             bytes_per_pixel=1;", "             if (significant_bits > 8)", "               bytes_per_pixel=2;", "             depth=significant_bits;", "             if (depth > 32)", "               ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "             max_value=(1UL << significant_bits)-1;", "             mask=(size_t) GetQuantumRange(significant_bits);", "             break;", "           }", "           case 0x0102:", "           {", "              ", "             break;", "           }", "           case 0x0103:", "           {", "              ", "             signed_data=(size_t) datum;", "             break;", "           }", "           case 0x1050:", "           {", "              ", "             if (data != (unsigned char *) NULL)", "               window_center=(ssize_t) StringToLong((char *) data);", "             break;", "           }", "           case 0x1051:", "           {", "              ", "             if (data != (unsigned char *) NULL)", "               window_width=StringToUnsignedLong((char *) data);", "             break;", "           }", "           case 0x1200:", "           case 0x3006:", "           {", "              ", "             if (data == (unsigned char *) NULL)", "               break;", "             colors=(size_t) (length/bytes_per_pixel);", "             datum=(int) colors;", "             graymap=(int *) AcquireQuantumMemory((size_t) colors,", "               sizeof(*graymap));", "             if (graymap == (int *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             for (i=0; i < (ssize_t) colors; i++)", "               if (bytes_per_pixel == 1)", "                 graymap[i]=(int) data[i];", "               else", "                 graymap[i]=(int) ((short *) data)[i];", "             break;", "           }", "           case 0x1201:", "           {", "             unsigned short", "               index;", " ", "              ", "             if (data == (unsigned char *) NULL)", "               break;", "             colors=(size_t) (length/2);", "             datum=(int) colors;", "             redmap=(int *) AcquireQuantumMemory((size_t) colors,", "               sizeof(*redmap));", "             if (redmap == (int *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             p=data;", "             for (i=0; i < (ssize_t) colors; i++)", "             {", "               if (image->endian == MSBEndian)", "                 index=(unsigned short) ((*p << 8) | *(p+1));", "               else", "                 index=(unsigned short) (*p | (*(p+1) << 8));", "               redmap[i]=(int) index;", "               p+=2;", "             }", "             break;", "           }", "           case 0x1202:", "           {", "             unsigned short", "               index;", " ", "              ", "             if (data == (unsigned char *) NULL)", "               break;", "             colors=(size_t) (length/2);", "             datum=(int) colors;", "             greenmap=(int *) AcquireQuantumMemory((size_t) colors,", "               sizeof(*greenmap));", "             if (greenmap == (int *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             p=data;", "             for (i=0; i < (ssize_t) colors; i++)", "             {", "               if (image->endian == MSBEndian)", "                 index=(unsigned short) ((*p << 8) | *(p+1));", "               else", "                 index=(unsigned short) (*p | (*(p+1) << 8));", "               greenmap[i]=(int) index;", "               p+=2;", "             }", "             break;", "           }", "           case 0x1203:", "           {", "             unsigned short", "               index;", " ", "              ", "             if (data == (unsigned char *) NULL)", "               break;", "             colors=(size_t) (length/2);", "             datum=(int) colors;", "             bluemap=(int *) AcquireQuantumMemory((size_t) colors,", "               sizeof(*bluemap));", "             if (bluemap == (int *) NULL)", "               ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "             p=data;", "             for (i=0; i < (ssize_t) colors; i++)", "             {", "               if (image->endian == MSBEndian)", "                 index=(unsigned short) ((*p << 8) | *(p+1));", "               else", "                 index=(unsigned short) (*p | (*(p+1) << 8));", "               bluemap[i]=(int) index;", "               p+=2;", "             }", "             break;", "           }", "           default:", "             break;", "         }", "         break;", "       }", "       case 0x2050:", "       {", "         switch (element)", "         {", "           case 0x0020:", "           {", "             if ((data != (unsigned char *) NULL) &&", "                 (strncmp((char*) data,\"INVERSE\", 7) == 0))", "               polarity=MagickTrue;", "             break;", "           }", "           default:", "             break;", "         }", "         break;", "       }", "       default:", "         break;", "     }", "     if (data != (unsigned char *) NULL)", "       {", "         char", "           *attribute;", " ", "         for (i=0; dicom_info[i].description != (char *) NULL; i++)", "           if ((group == dicom_info[i].group) &&", "               (element == dicom_info[i].element))", "             break;", "         if (dicom_info[i].description != (char *) NULL)", "           {", "             attribute=AcquireString(\"dcm:\");", "             (void) ConcatenateString(&attribute,dicom_info[i].description);", "             for (i=0; i < (ssize_t) MagickMax(length,4); i++)", "               if (isprint((int) data[i]) == MagickFalse)", "                 break;", "             if ((i == (ssize_t) length) || (length > 4))", "               {", "                 (void) SubstituteString(&attribute,\" \",\"\");", "                 (void) SetImageProperty(image,attribute,(char *) data);", "               }", "             attribute=DestroyString(attribute);", "           }", "       }", "     if (image_info->verbose != MagickFalse)", "       {", "         if (data == (unsigned char *) NULL)", "           (void) FormatLocaleFile(stdout,\"%d\\n\",datum);", "         else", "           {", "              ", "             for (i=0; i < (ssize_t) MagickMax(length,4); i++)", "               if (isprint((int) data[i]) == MagickFalse)", "                 break;", "             if ((i != (ssize_t) length) && (length <= 4))", "               {", "                 ssize_t", "                   j;", " ", "                 datum=0;", "                 for (j=(ssize_t) length-1; j >= 0; j--)", "                   datum=(256*datum+data[j]);", "                 (void) FormatLocaleFile(stdout,\"%d\",datum);", "               }", "             else", "               for (i=0; i < (ssize_t) length; i++)", "                 if (isprint((int) data[i]) != MagickFalse)", "                   (void) FormatLocaleFile(stdout,\"%c\",data[i]);", "                 else", "                   (void) FormatLocaleFile(stdout,\"%c\",'.');", "             (void) FormatLocaleFile(stdout,\"\\n\");", "           }", "       }", "     if (data != (unsigned char *) NULL)", "       data=(unsigned char *) RelinquishMagickMemory(data);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "   }", "   if ((width == 0) || (height == 0))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   image->columns=(size_t) width;", "   image->rows=(size_t) height;", "   if (signed_data == 0xffff)", "     signed_data=(size_t) (significant_bits == 16 ? 1 : 0);", "   if ((image->compression == JPEGCompression) ||", "       (image->compression == JPEG2000Compression))", "     {", "       Image", "         *images;", " ", "       ImageInfo", "         *read_info;", " ", "       int", "         c;", " ", "       size_t", "         length;", " ", "       unsigned int", "         tag;", " ", "        ", "       for (i=0; i < (ssize_t) stream_info->remaining; i++)", "         (void) ReadBlobByte(image);", "       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);", "       (void) tag;", "       length=(size_t) ReadBlobLSBLong(image);", "       stream_info->offset_count=length >> 2;", "       if (stream_info->offset_count != 0)", "         {", "           MagickOffsetType", "             offset;", " ", "           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(", "             stream_info->offset_count,sizeof(*stream_info->offsets));", "           if (stream_info->offsets == (ssize_t *) NULL)", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           for (i=0; i < (ssize_t) stream_info->offset_count; i++)", "             stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));", "           offset=TellBlob(image);", "           for (i=0; i < (ssize_t) stream_info->offset_count; i++)", "             stream_info->offsets[i]+=offset;", "         }", "        ", "       read_info=CloneImageInfo(image_info);", "       SetImageInfoBlob(read_info,(void *) NULL,0);", "       images=NewImageList();", "       for (scene=0; scene < (ssize_t) number_scenes; scene++)", "       {", "         char", "           filename[MaxTextExtent];", " ", "         const char", "           *property;", " ", "         FILE", "           *file;", " ", "         Image", "           *jpeg_image;", " ", "         int", "           unique_file;", " ", "         unsigned int", "           tag;", " ", "         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);", "         length=(size_t) ReadBlobLSBLong(image);", "         if (tag == 0xFFFEE0DD)", "           break;  ", "         if (tag != 0xFFFEE000)", "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         file=(FILE *) NULL;", "         unique_file=AcquireUniqueFileResource(filename);", "         if (unique_file != -1)", "           file=fdopen(unique_file,\"wb\");", "         if (file == (FILE *) NULL)", "           {", "             (void) RelinquishUniqueFileResource(filename);", "             ThrowFileException(exception,FileOpenError,", "               \"UnableToCreateTemporaryFile\",filename);", "             break;", "           }", "         for ( ; length != 0; length--)", "         {", "           c=ReadBlobByte(image);", "           if (c == EOF)", "             {", "               ThrowFileException(exception,CorruptImageError,", "                 \"UnexpectedEndOfFile\",image->filename);", "               break;", "             }", "           (void) fputc(c,file);", "         }", "         (void) fclose(file);", "         (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",", "           filename);", "         if (image->compression == JPEG2000Compression)", "           (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"j2k:%s\",", "             filename);", "         jpeg_image=ReadImage(read_info,exception);", "         if (jpeg_image != (Image *) NULL)", "           {", "             ResetImagePropertyIterator(image);", "             property=GetNextImageProperty(image);", "             while (property != (const char *) NULL)", "             {", "               (void) SetImageProperty(jpeg_image,property,", "                 GetImageProperty(image,property));", "               property=GetNextImageProperty(image);", "             }", "             AppendImageToList(&images,jpeg_image);", "           }", "         (void) RelinquishUniqueFileResource(filename);", "       }", "       read_info=DestroyImageInfo(read_info);", "       image=DestroyImage(image);", "       return(GetFirstImageInList(images));", "     }", "   if (depth != (1UL*MAGICKCORE_QUANTUM_DEPTH))", "     {", "       QuantumAny", "         range;", " ", "       size_t", "         length;", " ", "        ", "       length=(size_t) (GetQuantumRange(depth)+1);", "       scale=(Quantum *) AcquireQuantumMemory(length,sizeof(*scale));", "       if (scale == (Quantum *) NULL)", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       range=GetQuantumRange(depth);", "       for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)", "         scale[i]=ScaleAnyToQuantum((size_t) i,range);", "     }", "   if (image->compression == RLECompression)", "     {", "       size_t", "         length;", " ", "       unsigned int", "         tag;", " ", "        ", "       for (i=0; i < (ssize_t) stream_info->remaining; i++)", "         (void) ReadBlobByte(image);", "       tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);", "       (void) tag;", "       length=(size_t) ReadBlobLSBLong(image);", "       stream_info->offset_count=length >> 2;", "       if (stream_info->offset_count != 0)", "         {", "           MagickOffsetType", "             offset;", " ", "           stream_info->offsets=(ssize_t *) AcquireQuantumMemory(", "             stream_info->offset_count,sizeof(*stream_info->offsets));", "           if (stream_info->offsets == (ssize_t *) NULL)", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           for (i=0; i < (ssize_t) stream_info->offset_count; i++)", "             stream_info->offsets[i]=(ssize_t) ((int) ReadBlobLSBLong(image));", "           offset=TellBlob(image);", "           for (i=0; i < (ssize_t) stream_info->offset_count; i++)", "             stream_info->offsets[i]+=offset;", "         }", "     }", "   for (scene=0; scene < (ssize_t) number_scenes; scene++)", "   {", "     if (image_info->ping != MagickFalse)", "       break;", "      image->columns=(size_t) width;", "      image->rows=(size_t) height;", "      image->depth=depth;", "     status=SetImageExtent(image,image->columns,image->rows);", "     if (status == MagickFalse)", "       {", "         InheritException(exception,&image->exception);", "         break;", "       }", "      image->colorspace=RGBColorspace;", "      if ((image->colormap == (PixelPacket *) NULL) && (samples_per_pixel == 1))", "        {", "         size_t", "           one;", " ", "         one=1;", "         if (colors == 0)", "           colors=one << depth;", "         if (AcquireImageColormap(image,one << depth) == MagickFalse)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         if (redmap != (int *) NULL)", "           for (i=0; i < (ssize_t) colors; i++)", "           {", "             index=redmap[i];", "             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))", "               index=(int) scale[index];", "             image->colormap[i].red=(Quantum) index;", "           }", "         if (greenmap != (int *) NULL)", "           for (i=0; i < (ssize_t) colors; i++)", "           {", "             index=greenmap[i];", "             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))", "               index=(int) scale[index];", "             image->colormap[i].green=(Quantum) index;", "           }", "         if (bluemap != (int *) NULL)", "           for (i=0; i < (ssize_t) colors; i++)", "           {", "             index=bluemap[i];", "             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))", "               index=(int) scale[index];", "             image->colormap[i].blue=(Quantum) index;", "           }", "         if (graymap != (int *) NULL)", "           for (i=0; i < (ssize_t) colors; i++)", "           {", "             index=graymap[i];", "             if ((scale != (Quantum *) NULL) && (index <= (int) max_value))", "               index=(int) scale[index];", "             image->colormap[i].red=(Quantum) index;", "             image->colormap[i].green=(Quantum) index;", "             image->colormap[i].blue=(Quantum) index;", "           }", "       }", "     if (image->compression == RLECompression)", "       {", "         unsigned int", "           tag;", " ", "          ", "         for (i=0; i < (ssize_t) stream_info->remaining; i++)", "           (void) ReadBlobByte(image);", "         tag=(ReadBlobLSBShort(image) << 16) | ReadBlobLSBShort(image);", "         stream_info->remaining=(size_t) ReadBlobLSBLong(image);", "         if ((tag != 0xFFFEE000) || (stream_info->remaining <= 64) ||", "             (EOFBlob(image) != MagickFalse))", "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         stream_info->count=0;", "         stream_info->segment_count=ReadBlobLSBLong(image);", "         if (stream_info->segment_count > 1)", "           {", "             bytes_per_pixel=1;", "             depth=8;", "           }", "         for (i=0; i < 15; i++)", "           stream_info->segments[i]=(ssize_t) ((int) ReadBlobLSBLong(image));", "         stream_info->remaining-=64;", "       }", "     if ((samples_per_pixel > 1) && (image->interlace == PlaneInterlace))", "       {", "          ", "         for (i=0; i < (ssize_t) samples_per_pixel; i++)", "         {", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (PixelPacket *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               switch ((int) i)", "               {", "                 case 0:", "                 {", "                   SetPixelRed(q,ScaleCharToQuantum((unsigned char)", "                     ReadDCMByte(stream_info,image)));", "                   break;", "                 }", "                 case 1:", "                 {", "                   SetPixelGreen(q,ScaleCharToQuantum((unsigned char)", "                     ReadDCMByte(stream_info,image)));", "                   break;", "                 }", "                 case 2:", "                 {", "                   SetPixelBlue(q,ScaleCharToQuantum((unsigned char)", "                     ReadDCMByte(stream_info,image)));", "                   break;", "                 }", "                 case 3:", "                 {", "                   SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)", "                     ReadDCMByte(stream_info,image)));", "                   break;", "                 }", "                 default:", "                   break;", "               }", "               q++;", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                   image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         }", "       }", "     else", "       {", "         const char", "           *option;", " ", "         int", "           byte;", " ", "         LongPixelPacket", "           pixel;", " ", "          ", "         byte=0;", "         i=0;", "         if ((window_center != 0) && (window_width == 0))", "           window_width=(size_t) window_center;", "         option=GetImageOption(image_info,\"dcm:display-range\");", "         if (option != (const char *) NULL)", "           {", "             if (LocaleCompare(option,\"reset\") == 0)", "               window_width=0;", "           }", "         (void) ResetMagickMemory(&pixel,0,sizeof(pixel));", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (PixelPacket *) NULL)", "             break;", "           indexes=GetAuthenticIndexQueue(image);", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             if (samples_per_pixel == 1)", "               {", "                 int", "                   pixel_value;", " ", "                 if (bytes_per_pixel == 1)", "                   pixel_value=polarity != MagickFalse ? ((int) max_value-", "                     ReadDCMByte(stream_info,image)) :", "                     ReadDCMByte(stream_info,image);", "                 else", "                   if ((bits_allocated != 12) || (significant_bits != 12))", "                     pixel_value=(int) (polarity != MagickFalse ? (max_value-", "                       ReadDCMShort(stream_info,image)) :", "                       ReadDCMShort(stream_info,image));", "                   else", "                     {", "                       if ((i & 0x01) != 0)", "                         pixel_value=(ReadDCMByte(stream_info,image) << 8) |", "                           byte;", "                       else", "                         {", "                           pixel_value=(int) ReadDCMShort(stream_info,image);", "                           byte=(int) (pixel_value & 0x0f);", "                           pixel_value>>=4;", "                         }", "                       i++;", "                     }", "                 index=pixel_value;", "                 if (window_width == 0)", "                   {", "                     if (signed_data == 1)", "                       index=pixel_value-32767;", "                   }", "                 else", "                   {", "                     ssize_t", "                       window_max,", "                       window_min;", " ", "                     window_min=(ssize_t) ceil((double) window_center-", "                       (window_width-1.0)/2.0-0.5);", "                     window_max=(ssize_t) floor((double) window_center+", "                       (window_width-1.0)/2.0+0.5);", "                     if ((ssize_t) pixel_value <= window_min)", "                       index=0;", "                     else", "                       if ((ssize_t) pixel_value > window_max)", "                         index=(int) max_value;", "                       else", "                         index=(int) (max_value*(((pixel_value-window_center-", "                           0.5)/(window_width-1))+0.5));", "                   }", "                 index&=mask;", "                 index=(int) ConstrainColormapIndex(image,(size_t) index);", "                 SetPixelIndex(indexes+x,index);", "                 pixel.red=1U*image->colormap[index].red;", "                 pixel.green=1U*image->colormap[index].green;", "                 pixel.blue=1U*image->colormap[index].blue;", "               }", "             else", "               {", "                 if (bytes_per_pixel == 1)", "                   {", "                     pixel.red=(unsigned int) ReadDCMByte(stream_info,image);", "                     pixel.green=(unsigned int) ReadDCMByte(stream_info,image);", "                     pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);", "                   }", "                 else", "                   {", "                     pixel.red=ReadDCMShort(stream_info,image);", "                     pixel.green=ReadDCMShort(stream_info,image);", "                     pixel.blue=ReadDCMShort(stream_info,image);", "                   }", "                 pixel.red&=mask;", "                 pixel.green&=mask;", "                 pixel.blue&=mask;", "                 if (scale != (Quantum *) NULL)", "                   {", "                     pixel.red=scale[pixel.red];", "                     pixel.green=scale[pixel.green];", "                     pixel.blue=scale[pixel.blue];", "                   }", "               }", "             SetPixelRed(q,pixel.red);", "             SetPixelGreen(q,pixel.green);", "             SetPixelBlue(q,pixel.blue);", "             q++;", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         if (stream_info->segment_count > 1)", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (PixelPacket *) NULL)", "               break;", "             indexes=GetAuthenticIndexQueue(image);", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               if (samples_per_pixel == 1)", "                 {", "                   int", "                     pixel_value;", " ", "                   if (bytes_per_pixel == 1)", "                     pixel_value=polarity != MagickFalse ? ((int) max_value-", "                       ReadDCMByte(stream_info,image)) :", "                       ReadDCMByte(stream_info,image);", "                   else", "                     if ((bits_allocated != 12) || (significant_bits != 12))", "                       {", "                         pixel_value=(int) (polarity != MagickFalse ? (max_value-", "                           ReadDCMShort(stream_info,image)) :", "                           ReadDCMShort(stream_info,image));", "                         if (signed_data == 1)", "                           pixel_value=((signed short) pixel_value);", "                       }", "                     else", "                       {", "                         if ((i & 0x01) != 0)", "                           pixel_value=(ReadDCMByte(stream_info,image) << 8) |", "                             byte;", "                         else", "                           {", "                             pixel_value=(int) ReadDCMShort(stream_info,image);", "                             byte=(int) (pixel_value & 0x0f);", "                             pixel_value>>=4;", "                           }", "                         i++;", "                       }", "                   index=pixel_value;", "                   if (window_width == 0)", "                     {", "                       if (signed_data == 1)", "                         index=pixel_value-32767;", "                     }", "                   else", "                     {", "                       ssize_t", "                         window_max,", "                         window_min;", " ", "                       window_min=(ssize_t) ceil((double) window_center-", "                         (window_width-1.0)/2.0-0.5);", "                       window_max=(ssize_t) floor((double) window_center+", "                         (window_width-1.0)/2.0+0.5);", "                       if ((ssize_t) pixel_value <= window_min)", "                         index=0;", "                       else", "                         if ((ssize_t) pixel_value > window_max)", "                           index=(int) max_value;", "                         else", "                           index=(int) (max_value*(((pixel_value-window_center-", "                             0.5)/(window_width-1))+0.5));", "                     }", "                   index&=mask;", "                   index=(int) ConstrainColormapIndex(image,(size_t) index);", "                   SetPixelIndex(indexes+x,(((size_t) GetPixelIndex(indexes+x)) |", "                     (((size_t) index) << 8)));", "                   pixel.red=1U*image->colormap[index].red;", "                   pixel.green=1U*image->colormap[index].green;", "                   pixel.blue=1U*image->colormap[index].blue;", "                 }", "               else", "                 {", "                   if (bytes_per_pixel == 1)", "                     {", "                       pixel.red=(unsigned int) ReadDCMByte(stream_info,image);", "                       pixel.green=(unsigned int) ReadDCMByte(stream_info,image);", "                       pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);", "                     }", "                   else", "                     {", "                       pixel.red=ReadDCMShort(stream_info,image);", "                       pixel.green=ReadDCMShort(stream_info,image);", "                       pixel.blue=ReadDCMShort(stream_info,image);", "                     }", "                   pixel.red&=mask;", "                   pixel.green&=mask;", "                   pixel.blue&=mask;", "                   if (scale != (Quantum *) NULL)", "                     {", "                       pixel.red=scale[pixel.red];", "                       pixel.green=scale[pixel.green];", "                       pixel.blue=scale[pixel.blue];", "                     }", "                 }", "               SetPixelRed(q,(((size_t) GetPixelRed(q)) |", "                 (((size_t) pixel.red) << 8)));", "               SetPixelGreen(q,(((size_t) GetPixelGreen(q)) |", "                 (((size_t) pixel.green) << 8)));", "               SetPixelBlue(q,(((size_t) GetPixelBlue(q)) |", "                 (((size_t) pixel.blue) << 8)));", "               q++;", "             }", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                   image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "       }", "     if (IsGrayImage(image,exception) != MagickFalse)", "       (void) SetImageColorspace(image,GRAYColorspace);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     if (scene < (ssize_t) (number_scenes-1))", "       {", "          ", "         AcquireNextImage(image_info,image);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   }", "    ", "   if (stream_info->offsets != (ssize_t *) NULL)", "     stream_info->offsets=(ssize_t *)", "       RelinquishMagickMemory(stream_info->offsets);", "   stream_info=(DCMStreamInfo *) RelinquishMagickMemory(stream_info);", "   if (scale != (Quantum *) NULL)", "     scale=(Quantum *) RelinquishMagickMemory(scale);", "   if (graymap != (int *) NULL)", "     graymap=(int *) RelinquishMagickMemory(graymap);", "   if (bluemap != (int *) NULL)", "     bluemap=(int *) RelinquishMagickMemory(bluemap);", "   if (greenmap != (int *) NULL)", "     greenmap=(int *) RelinquishMagickMemory(greenmap);", "   if (redmap != (int *) NULL)", "     redmap=(int *) RelinquishMagickMemory(redmap);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)", "  {", "    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));", "     UINT16 buflen = (UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR));", "     if (buflen < len) {", "       android_errorWriteWithInfoLog(0x534e4554, \"28672558\", -1, NULL, 0);", "       return NULL;", "     }", "     BT_HDR* p_buf = GKI_getbuf(buflen);", "  ", "      if (p_buf) {", "          UINT8* pbuf_data;", " ", "         p_buf->len = len;", "         p_buf->offset = BTA_HH_MIN_OFFSET;", " ", "         pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;", "         memcpy(pbuf_data, data, len);", "  }", "  return p_buf;", " }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void WebContentsImpl::CreateNewWindow(", "     RenderFrameHost* opener,", "     int32_t render_view_route_id,", "     int32_t main_frame_route_id,", "     int32_t main_frame_widget_route_id,", "     const mojom::CreateNewWindowParams& params,", "     SessionStorageNamespace* session_storage_namespace) {", "   DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),", "             (main_frame_route_id == MSG_ROUTING_NONE));", "   DCHECK_EQ((render_view_route_id == MSG_ROUTING_NONE),", "             (main_frame_widget_route_id == MSG_ROUTING_NONE));", "   DCHECK(opener);", " ", "   int render_process_id = opener->GetProcess()->GetID();", "   SiteInstance* source_site_instance = opener->GetSiteInstance();", " ", "   DCHECK(!RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id));", " ", "   bool is_guest = BrowserPluginGuest::IsGuest(this);", " ", "   DCHECK(!params.opener_suppressed || render_view_route_id == MSG_ROUTING_NONE);", " ", "   scoped_refptr<SiteInstance> site_instance =", "       params.opener_suppressed && !is_guest", "           ? SiteInstance::CreateForURL(GetBrowserContext(), params.target_url)", "           : source_site_instance;", " ", "   const std::string& partition_id =", "       GetContentClient()->browser()->", "           GetStoragePartitionIdForSite(GetBrowserContext(),", "                                        site_instance->GetSiteURL());", "   StoragePartition* partition = BrowserContext::GetStoragePartition(", "       GetBrowserContext(), site_instance.get());", "   DOMStorageContextWrapper* dom_storage_context =", "       static_cast<DOMStorageContextWrapper*>(partition->GetDOMStorageContext());", "   SessionStorageNamespaceImpl* session_storage_namespace_impl =", "       static_cast<SessionStorageNamespaceImpl*>(session_storage_namespace);", "   CHECK(session_storage_namespace_impl->IsFromContext(dom_storage_context));", " ", "   if (delegate_ &&", "       !delegate_->ShouldCreateWebContents(", "           this, opener, source_site_instance, render_view_route_id,", "           main_frame_route_id, main_frame_widget_route_id,", "           params.window_container_type, opener->GetLastCommittedURL(),", "           params.frame_name, params.target_url, partition_id,", "           session_storage_namespace)) {", "     RenderFrameHostImpl* rfh =", "         RenderFrameHostImpl::FromID(render_process_id, main_frame_route_id);", "     if (rfh) {", "       DCHECK(rfh->IsRenderFrameLive());", "       rfh->Init();", "     }", "     return;", "   }", " ", "   CreateParams create_params(GetBrowserContext(), site_instance.get());", "   create_params.routing_id = render_view_route_id;", "   create_params.main_frame_routing_id = main_frame_route_id;", "   create_params.main_frame_widget_routing_id = main_frame_widget_route_id;", "   create_params.main_frame_name = params.frame_name;", "   create_params.opener_render_process_id = render_process_id;", "   create_params.opener_render_frame_id = opener->GetRoutingID();", "   create_params.opener_suppressed = params.opener_suppressed;", "   if (params.disposition == WindowOpenDisposition::NEW_BACKGROUND_TAB)", "     create_params.initially_hidden = true;", "   create_params.renderer_initiated_creation =", "       main_frame_route_id != MSG_ROUTING_NONE;", " ", "   std::unique_ptr<WebContents> new_contents;", "   if (!is_guest) {", "     create_params.context = view_->GetNativeView();", "     create_params.initial_size = GetContainerBounds().size();", "     new_contents = WebContents::Create(create_params);", "   }  else {", "     new_contents = base::WrapUnique(", "         GetBrowserPluginGuest()->CreateNewGuestWindow(create_params));", "   }", "   WebContentsImpl* raw_new_contents =", "       static_cast<WebContentsImpl*>(new_contents.get());", "   raw_new_contents->GetController().SetSessionStorageNamespace(", "       partition_id, session_storage_namespace);", " ", "   if (!params.frame_name.empty())", "     raw_new_contents->GetRenderManager()->CreateProxiesForNewNamedFrame();", " ", "   if (!params.opener_suppressed) {", "     if (!is_guest) {", "       WebContentsView* new_view = raw_new_contents->view_.get();", " ", "       new_view->CreateViewForWidget(", "           new_contents->GetRenderViewHost()->GetWidget(), false);", "     }", "     DCHECK_NE(MSG_ROUTING_NONE, main_frame_widget_route_id);", "     pending_contents_[std::make_pair(render_process_id,", "                                      main_frame_widget_route_id)] =", "         std::move(new_contents);", "     AddDestructionObserver(raw_new_contents);", "   }", " ", "   if (delegate_) {", "     delegate_->WebContentsCreated(this, render_process_id,", "                                   opener->GetRoutingID(), params.frame_name,", "                                   params.target_url, raw_new_contents);", "   }", " ", "   if (opener) {", "     for (auto& observer : observers_) {", "       observer.DidOpenRequestedURL(raw_new_contents, opener, params.target_url,", "                                    params.referrer, params.disposition,", "                                    ui::PAGE_TRANSITION_LINK,", "                                    false,   ", "                                    true);   ", "     }", "   }", "  ", "  if (IsFullscreenForCurrentTab())", "    ExitFullscreen(true);", "   ForSecurityDropFullscreen();", "  ", "    if (params.opener_suppressed) {", "     bool was_blocked = false;", " ", "     base::WeakPtr<WebContentsImpl> weak_new_contents =", "         raw_new_contents->weak_factory_.GetWeakPtr();", "     if (delegate_) {", "       gfx::Rect initial_rect;", " ", "       delegate_->AddNewContents(this, std::move(new_contents),", "                                 params.disposition, initial_rect,", "                                 params.mimic_user_gesture, &was_blocked);", "       if (!weak_new_contents)", "         return;   ", "     }", " ", "     if (!was_blocked) {", "       OpenURLParams open_params(params.target_url, params.referrer,", "                                 WindowOpenDisposition::CURRENT_TAB,", "                                 ui::PAGE_TRANSITION_LINK,", "                                 true  );", "       open_params.user_gesture = params.mimic_user_gesture;", " ", "       if (delegate_ && !is_guest &&", "           !delegate_->ShouldResumeRequestsForCreatedWindow()) {", "         DCHECK(weak_new_contents);", "         weak_new_contents->delayed_open_url_params_.reset(", "             new OpenURLParams(open_params));", "       } else {", "         weak_new_contents->OpenURL(open_params);", "       }", "     }", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void copyMono24(", "          short *dst,", "        const int *const *src,", "         const int * src[FLACParser::kMaxChannels],", "          unsigned nSamples,", "          unsigned  ) {", "      for (unsigned i = 0; i < nSamples; ++i) {", "  *dst++ = src[0][i] >> 8;", "  }", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)", " {", " \tstruct k_itimer *timr;", " \tint overrun;", " \tunsigned long flags;", " ", " \ttimr = lock_timer(timer_id, &flags);", "  \tif (!timr)", "  \t\treturn -EINVAL;", "  ", "\toverrun = timr->it_overrun_last;", " \toverrun = timer_overrun_to_int(timr, 0);", "  \tunlock_timer(timr, flags);", "  ", "  \treturn overrun;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" download::DownloadInterruptReason DownloadManagerImpl::BeginDownloadRequest(", "     std::unique_ptr<net::URLRequest> url_request,", "     ResourceContext* resource_context,", "     download::DownloadUrlParameters* params) {", "   if (ResourceDispatcherHostImpl::Get()->is_shutdown())", "     return download::DOWNLOAD_INTERRUPT_REASON_USER_SHUTDOWN;", " ", "   ResourceDispatcherHostImpl::Get()->InitializeURLRequest(", "       url_request.get(),", "       Referrer(params->referrer(),", "                Referrer::NetReferrerPolicyToBlinkReferrerPolicy(", "                     params->referrer_policy())),", "        true,   ", "        params->render_process_host_id(), params->render_view_host_routing_id(),", "      params->render_frame_host_routing_id(), PREVIEWS_OFF, resource_context);", "       params->render_frame_host_routing_id(), params->frame_tree_node_id(),", "       PREVIEWS_OFF, resource_context);", "  ", "   url_request->set_first_party_url_policy(", "       net::URLRequest::UPDATE_FIRST_PARTY_URL_ON_REDIRECT);", " ", "   const GURL& url = url_request->original_url();", " ", "   const net::URLRequestContext* request_context = url_request->context();", "   if (!request_context->job_factory()->IsHandledProtocol(url.scheme())) {", "     DVLOG(1) << \"Download request for unsupported protocol: \"", "              << url.possibly_invalid_spec();", "     return download::DOWNLOAD_INTERRUPT_REASON_NETWORK_INVALID_REQUEST;", "   }", " ", "   std::unique_ptr<ResourceHandler> handler(", "       DownloadResourceHandler::CreateForNewRequest(", "           url_request.get(), params->request_origin(),", "           params->download_source(), params->follow_cross_origin_redirects()));", " ", "   ResourceDispatcherHostImpl::Get()->BeginURLRequest(", "       std::move(url_request), std::move(handler), true,   ", "       params->content_initiated(), params->do_not_prompt_for_login(),", "       resource_context);", "   return download::DOWNLOAD_INTERRUPT_REASON_NONE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadTIFFImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   const char", "     *option;", " ", "   float", "     *chromaticity,", "     x_position,", "     y_position,", "     x_resolution,", "     y_resolution;", " ", "   Image", "     *image;", " ", "   int", "     tiff_status;", " ", "   MagickBooleanType", "     status;", " ", "   MagickSizeType", "     number_pixels;", " ", "   QuantumInfo", "     *quantum_info;", " ", "   QuantumType", "     quantum_type;", " ", "   register ssize_t", "     i;", " ", "   size_t", "     pad;", " ", "   ssize_t", "     y;", " ", "   TIFF", "     *tiff;", " ", "   TIFFMethodType", "     method;", " ", "   uint16", "     compress_tag,", "     bits_per_sample,", "     endian,", "     extra_samples,", "     interlace,", "     max_sample_value,", "     min_sample_value,", "     orientation,", "     pages,", "     photometric,", "     *sample_info,", "     sample_format,", "     samples_per_pixel,", "     units,", "     value;", " ", "   uint32", "     height,", "     rows_per_strip,", "     width;", " ", "   unsigned char", "     *pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   (void) SetMagickThreadValue(tiff_exception,exception);", "   tiff=TIFFClientOpen(image->filename,\"rb\",(thandle_t) image,TIFFReadBlob,", "     TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,", "     TIFFUnmapBlob);", "   if (tiff == (TIFF *) NULL)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   if (image_info->number_scenes != 0)", "     {", "        ", "       if (image_info->scene < (size_t) TIFFNumberOfDirectories(tiff))", "         {", "           for (i=0; i < (ssize_t) image_info->scene; i++)", "           {", "             status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;", "             if (status == MagickFalse)", "               {", "                 TIFFClose(tiff);", "                 image=DestroyImageList(image);", "                 return((Image *) NULL);", "               }", "             AcquireNextImage(image_info,image,exception);", "             if (GetNextImageInList(image) == (Image *) NULL)", "               {", "                 TIFFClose(tiff);", "                 image=DestroyImageList(image);", "                 return((Image *) NULL);", "               }", "             image=SyncNextImageInList(image);", "           }", "       }", "   }", "   do", "   {", " DisableMSCWarning(4127)", "     if (0 && (image_info->verbose != MagickFalse))", "       TIFFPrintDirectory(tiff,stdout,MagickFalse);", " RestoreMSCWarning", "     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||", "         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value) != 1) ||", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric) != 1))", "       {", "         TIFFClose(tiff);", "         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "       }", "     if (sample_format == SAMPLEFORMAT_IEEEFP)", "       (void) SetImageProperty(image,\"quantum:format\",\"floating-point\",", "         exception);", "     switch (photometric)", "     {", "       case PHOTOMETRIC_MINISBLACK:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-black\",", "           exception);", "         break;", "       }", "       case PHOTOMETRIC_MINISWHITE:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"min-is-white\",", "           exception);", "         break;", "       }", "       case PHOTOMETRIC_PALETTE:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"palette\",exception);", "         break;", "       }", "       case PHOTOMETRIC_RGB:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"RGB\",exception);", "         break;", "       }", "       case PHOTOMETRIC_CIELAB:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"CIELAB\",exception);", "         break;", "       }", "       case PHOTOMETRIC_LOGL:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"CIE Log2(L)\",", "           exception);", "         break;", "       }", "       case PHOTOMETRIC_LOGLUV:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"LOGLUV\",exception);", "         break;", "       }", " #if defined(PHOTOMETRIC_MASK)", "       case PHOTOMETRIC_MASK:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"MASK\",exception);", "         break;", "       }", " #endif", "       case PHOTOMETRIC_SEPARATED:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"separated\",exception);", "         break;", "       }", "       case PHOTOMETRIC_YCBCR:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"YCBCR\",exception);", "         break;", "       }", "       default:", "       {", "         (void) SetImageProperty(image,\"tiff:photometric\",\"unknown\",exception);", "         break;", "       }", "     }", "     if (image->debug != MagickFalse)", "       {", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %ux%u\",", "           (unsigned int) width,(unsigned int) height);", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Interlace: %u\",", "           interlace);", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Bits per sample: %u\",bits_per_sample);", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Min sample value: %u\",min_sample_value);", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Max sample value: %u\",max_sample_value);", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Photometric \"", "           \"interpretation: %s\",GetImageProperty(image,\"tiff:photometric\",", "           exception));", "       }", "     image->columns=(size_t) width;", "     image->rows=(size_t) height;", "     image->depth=(size_t) bits_per_sample;", "     if (image->debug != MagickFalse)", "       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Image depth: %.20g\",", "         (double) image->depth);", "     image->endian=MSBEndian;", "     if (endian == FILLORDER_LSB2MSB)", "       image->endian=LSBEndian;", " #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)", "     if (TIFFIsBigEndian(tiff) == 0)", "       {", "         (void) SetImageProperty(image,\"tiff:endian\",\"lsb\",exception);", "         image->endian=LSBEndian;", "       }", "     else", "       {", "         (void) SetImageProperty(image,\"tiff:endian\",\"msb\",exception);", "         image->endian=MSBEndian;", "       }", " #endif", "     if ((photometric == PHOTOMETRIC_MINISBLACK) ||", "         (photometric == PHOTOMETRIC_MINISWHITE))", "       SetImageColorspace(image,GRAYColorspace,exception);", "     if (photometric == PHOTOMETRIC_SEPARATED)", "       SetImageColorspace(image,CMYKColorspace,exception);", "     if (photometric == PHOTOMETRIC_CIELAB)", "       SetImageColorspace(image,LabColorspace,exception);", "     TIFFGetProfiles(tiff,image,image_info->ping,exception);", "     TIFFGetProperties(tiff,image,exception);", "     option=GetImageOption(image_info,\"tiff:exif-properties\");", "     if (IsStringFalse(option) == MagickFalse)  ", "       TIFFGetEXIFProperties(tiff,image,exception);", "     (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,", "       &samples_per_pixel);", "     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution) == 1) &&", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution) == 1))", "       {", "         image->resolution.x=x_resolution;", "         image->resolution.y=y_resolution;", "       }", "     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units) == 1)", "       {", "         if (units == RESUNIT_INCH)", "           image->units=PixelsPerInchResolution;", "         if (units == RESUNIT_CENTIMETER)", "           image->units=PixelsPerCentimeterResolution;", "       }", "     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position) == 1) &&", "         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position) == 1))", "       {", "         image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);", "         image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);", "       }", "     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation) == 1)", "       image->orientation=(OrientationType) orientation;", "     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)", "       {", "         if (chromaticity != (float *) NULL)", "           {", "             image->chromaticity.white_point.x=chromaticity[0];", "             image->chromaticity.white_point.y=chromaticity[1];", "           }", "       }", "     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)", "       {", "         if (chromaticity != (float *) NULL)", "           {", "             image->chromaticity.red_primary.x=chromaticity[0];", "             image->chromaticity.red_primary.y=chromaticity[1];", "             image->chromaticity.green_primary.x=chromaticity[2];", "             image->chromaticity.green_primary.y=chromaticity[3];", "             image->chromaticity.blue_primary.x=chromaticity[4];", "             image->chromaticity.blue_primary.y=chromaticity[5];", "           }", "       }", " #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)", "     if ((compress_tag != COMPRESSION_NONE) &&", "         (TIFFIsCODECConfigured(compress_tag) == 0))", "       {", "         TIFFClose(tiff);", "         ThrowReaderException(CoderError,\"CompressNotSupported\");", "       }", " #endif", "     switch (compress_tag)", "     {", "       case COMPRESSION_NONE: image->compression=NoCompression; break;", "       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;", "       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;", "       case COMPRESSION_JPEG:", "       {", "          image->compression=JPEGCompression;", " #if defined(JPEG_SUPPORT)", "          {", "            char", "              sampling_factor[MagickPathExtent];", " ", "            int", "              tiff_status;", " ", "            uint16", "              horizontal,", "              vertical;", " ", "            tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_YCBCRSUBSAMPLING,", "              &horizontal,&vertical);", "            if (tiff_status == 1)", "              {", "                (void) FormatLocaleString(sampling_factor,MagickPathExtent,", "                  \"%dx%d\",horizontal,vertical);", "                (void) SetImageProperty(image,\"jpeg:sampling-factor\",", "                  sampling_factor,exception);", "                (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "                  \"Sampling Factors: %s\",sampling_factor);", "              }", "          }", " #endif", "         break;", "       }", "       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;", " #if defined(COMPRESSION_LZMA)", "       case COMPRESSION_LZMA: image->compression=LZMACompression; break;", " #endif", "       case COMPRESSION_LZW: image->compression=LZWCompression; break;", "       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;", "        case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;", "        default: image->compression=RLECompression; break;", "      }", "     ", "    quantum_info=AcquireQuantumInfo(image_info,image);", "    if (quantum_info == (QuantumInfo *) NULL)", "      {", "        TIFFClose(tiff);", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "      }", "    if (sample_format == SAMPLEFORMAT_UINT)", "      status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);", "    if (sample_format == SAMPLEFORMAT_INT)", "      status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);", "    if (sample_format == SAMPLEFORMAT_IEEEFP)", "      status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);", "    if (status == MagickFalse)", "      {", "        TIFFClose(tiff);", "        quantum_info=DestroyQuantumInfo(quantum_info);", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "      }", "    status=MagickTrue;", "    switch (photometric)", "    {", "      case PHOTOMETRIC_MINISBLACK:", "      {", "        quantum_info->min_is_white=MagickFalse;", "        break;", "      }", "      case PHOTOMETRIC_MINISWHITE:", "      {", "        quantum_info->min_is_white=MagickTrue;", "        break;", "      }", "      default:", "        break;", "    }", "    tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,", "      &sample_info);", "    if (tiff_status == 1)", "      {", "        (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);", "        if (extra_samples == 0)", "          {", "            if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))", "              image->alpha_trait=BlendPixelTrait;", "          }", "        else", "          for (i=0; i < extra_samples; i++)", "          {", "            image->alpha_trait=BlendPixelTrait;", "            if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)", "              {", "                SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);", "                (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",", "                  exception);", "              }", "            else", "              if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)", "                (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",", "                  exception);", "          }", "      }", "     quantum_info=(QuantumInfo *) NULL;", "      if ((photometric == PHOTOMETRIC_PALETTE) &&", "          (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))", "        {", "         size_t", "           colors;", " ", "         colors=(size_t) GetQuantumRange(bits_per_sample)+1;", "         if (AcquireImageColormap(image,colors,exception) == MagickFalse)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "       }", "     value=(unsigned short) image->scene;", "     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages) == 1)", "       image->scene=value;", "     if (image->storage_class == PseudoClass)", "       {", "         int", "           tiff_status;", " ", "         size_t", "           range;", " ", "         uint16", "           *blue_colormap,", "           *green_colormap,", "           *red_colormap;", " ", "          ", "         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,", "           &green_colormap,&blue_colormap);", "         if (tiff_status == 1)", "           {", "             if ((red_colormap != (uint16 *) NULL) &&", "                 (green_colormap != (uint16 *) NULL) &&", "                 (blue_colormap != (uint16 *) NULL))", "               {", "                 range=255;   ", "                 for (i=0; i < (ssize_t) image->colors; i++)", "                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||", "                       (blue_colormap[i] >= 256))", "                     {", "                       range=65535;", "                       break;", "                     }", "                 for (i=0; i < (ssize_t) image->colors; i++)", "                 {", "                   image->colormap[i].red=ClampToQuantum(((double)", "                     QuantumRange*red_colormap[i])/range);", "                   image->colormap[i].green=ClampToQuantum(((double)", "                     QuantumRange*green_colormap[i])/range);", "                   image->colormap[i].blue=ClampToQuantum(((double)", "                     QuantumRange*blue_colormap[i])/range);", "                 }", "               }", "           }", "         if (image->alpha_trait == UndefinedPixelTrait)", "           image->depth=GetImageDepth(image,exception);", "       }", "     if (image_info->ping != MagickFalse)", "        {", "          if (image_info->number_scenes != 0)", "            if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "            {", "              quantum_info=DestroyQuantumInfo(quantum_info);", "              break;", "            }", "             break;", "          goto next_tiff_frame;", "        }", "      status=SetImageExtent(image,image->columns,image->rows,exception);", "      if (status == MagickFalse)", "        return(DestroyImageList(image));", "      ", "     quantum_info=AcquireQuantumInfo(image_info,image);", "     if (quantum_info == (QuantumInfo *) NULL)", "       {", "         TIFFClose(tiff);", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       }", "     if (sample_format == SAMPLEFORMAT_UINT)", "       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);", "     if (sample_format == SAMPLEFORMAT_INT)", "       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);", "     if (sample_format == SAMPLEFORMAT_IEEEFP)", "       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);", "     if (status == MagickFalse)", "       {", "         TIFFClose(tiff);", "         quantum_info=DestroyQuantumInfo(quantum_info);", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       }", "     status=MagickTrue;", "     switch (photometric)", "     {", "       case PHOTOMETRIC_MINISBLACK:", "       {", "         quantum_info->min_is_white=MagickFalse;", "         break;", "       }", "       case PHOTOMETRIC_MINISWHITE:", "       {", "         quantum_info->min_is_white=MagickTrue;", "         break;", "       }", "       default:", "         break;", "     }", "     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,", "       &sample_info);", "     if (tiff_status == 1)", "       {", "         (void) SetImageProperty(image,\"tiff:alpha\",\"unspecified\",exception);", "         if (extra_samples == 0)", "           {", "             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))", "               image->alpha_trait=BlendPixelTrait;", "           }", "         else", "           for (i=0; i < extra_samples; i++)", "           {", "             image->alpha_trait=BlendPixelTrait;", "             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)", "               {", "                 SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);", "                 (void) SetImageProperty(image,\"tiff:alpha\",\"associated\",", "                   exception);", "               }", "             else", "               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)", "                 (void) SetImageProperty(image,\"tiff:alpha\",\"unassociated\",", "                   exception);", "           }", "       }", "      method=ReadGenericMethod;", "      if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)", "        {", "         char", "           value[MagickPathExtent];", " ", "         method=ReadStripMethod;", "         (void) FormatLocaleString(value,MagickPathExtent,\"%u\",", "           (unsigned int) rows_per_strip);", "         (void) SetImageProperty(image,\"tiff:rows-per-strip\",value,exception);", "       }", "     if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_CONTIG))", "       method=ReadRGBAMethod;", "     if ((samples_per_pixel >= 2) && (interlace == PLANARCONFIG_SEPARATE))", "       method=ReadCMYKAMethod;", "     if ((photometric != PHOTOMETRIC_RGB) &&", "         (photometric != PHOTOMETRIC_CIELAB) &&", "         (photometric != PHOTOMETRIC_SEPARATED))", "       method=ReadGenericMethod;", "     if (image->storage_class == PseudoClass)", "       method=ReadSingleSampleMethod;", "     if ((photometric == PHOTOMETRIC_MINISBLACK) ||", "         (photometric == PHOTOMETRIC_MINISWHITE))", "       method=ReadSingleSampleMethod;", "     if ((photometric != PHOTOMETRIC_SEPARATED) &&", "         (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))", "       method=ReadGenericMethod;", "     if (image->compression == JPEGCompression)", "       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,", "         samples_per_pixel);", "     if (compress_tag == COMPRESSION_JBIG)", "       method=ReadStripMethod;", "     if (TIFFIsTiled(tiff) != MagickFalse)", "       method=ReadTileMethod;", "     quantum_info->endian=LSBEndian;", "     quantum_type=RGBQuantum;", "     pixels=(unsigned char *) GetQuantumPixels(quantum_info);", "     switch (method)", "     {", "       case ReadSingleSampleMethod:", "       {", "          ", "         quantum_type=IndexQuantum;", "         pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);", "         if (image->alpha_trait != UndefinedPixelTrait)", "           {", "             if (image->storage_class != PseudoClass)", "               {", "                 quantum_type=samples_per_pixel == 1 ? AlphaQuantum :", "                   GrayAlphaQuantum;", "                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);", "               }", "             else", "               {", "                 quantum_type=IndexAlphaQuantum;", "                 pad=(size_t) MagickMax((size_t) samples_per_pixel-2,0);", "               }", "           }", "         else", "           if (image->storage_class != PseudoClass)", "             {", "               quantum_type=GrayQuantum;", "               pad=(size_t) MagickMax((size_t) samples_per_pixel-1,0);", "             }", "         status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(", "           bits_per_sample)/log(2))));", "         if (status == MagickFalse)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         pixels=(unsigned char *) GetQuantumPixels(quantum_info);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           int", "             status;", " ", "           register Quantum", "             *magick_restrict q;", " ", "           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);", "           if (status == -1)", "             break;", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "             quantum_type,pixels,exception);", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case ReadRGBAMethod:", "       {", "          ", "         pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);", "         quantum_type=RGBQuantum;", "         if (image->alpha_trait != UndefinedPixelTrait)", "           {", "             quantum_type=RGBAQuantum;", "             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);", "           }", "         if (image->colorspace == CMYKColorspace)", "           {", "             pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);", "             quantum_type=CMYKQuantum;", "             if (image->alpha_trait != UndefinedPixelTrait)", "               {", "                 quantum_type=CMYKAQuantum;", "                 pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);", "               }", "           }", "         status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));", "         if (status == MagickFalse)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         pixels=(unsigned char *) GetQuantumPixels(quantum_info);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           int", "             status;", " ", "           register Quantum", "             *magick_restrict q;", " ", "           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);", "           if (status == -1)", "             break;", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "             quantum_type,pixels,exception);", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case ReadCMYKAMethod:", "       {", "          ", "         for (i=0; i < (ssize_t) samples_per_pixel; i++)", "         {", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             register Quantum", "               *magick_restrict q;", " ", "             int", "               status;", " ", "             status=TIFFReadPixels(tiff,bits_per_sample,(tsample_t) i,y,(char *)", "               pixels);", "             if (status == -1)", "               break;", "             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (Quantum *) NULL)", "               break;", "             if (image->colorspace != CMYKColorspace)", "               switch (i)", "               {", "                 case 0: quantum_type=RedQuantum; break;", "                 case 1: quantum_type=GreenQuantum; break;", "                 case 2: quantum_type=BlueQuantum; break;", "                 case 3: quantum_type=AlphaQuantum; break;", "                 default: quantum_type=UndefinedQuantum; break;", "               }", "             else", "               switch (i)", "               {", "                 case 0: quantum_type=CyanQuantum; break;", "                 case 1: quantum_type=MagentaQuantum; break;", "                 case 2: quantum_type=YellowQuantum; break;", "                 case 3: quantum_type=BlackQuantum; break;", "                 case 4: quantum_type=AlphaQuantum; break;", "                 default: quantum_type=UndefinedQuantum; break;", "               }", "             (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,", "               quantum_type,pixels,exception);", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "           }", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case ReadYCCKMethod:", "       {", "         pixels=(unsigned char *) GetQuantumPixels(quantum_info);", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           int", "             status;", " ", "           register Quantum", "             *magick_restrict q;", " ", "           register ssize_t", "             x;", " ", "           unsigned char", "             *p;", " ", "           status=TIFFReadPixels(tiff,bits_per_sample,0,y,(char *) pixels);", "           if (status == -1)", "             break;", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           p=pixels;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+", "               (1.402*(double) *(p+2))-179.456)),q);", "             SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-", "               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+", "               135.45984)),q);", "             SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+", "               (1.772*(double) *(p+1))-226.816)),q);", "             SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);", "             q+=GetPixelChannels(image);", "             p+=4;", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case ReadStripMethod:", "       {", "         register uint32", "           *p;", " ", "          ", "         i=0;", "         p=(uint32 *) NULL;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register ssize_t", "             x;", " ", "           register Quantum", "             *magick_restrict q;", " ", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           if (i == 0)", "             {", "               if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)", "                 break;", "               i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)", "                 image->rows-y);", "             }", "           i--;", "           p=((uint32 *) pixels)+image->columns*i;", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelRed(image,ScaleCharToQuantum((unsigned char)", "               (TIFFGetR(*p))),q);", "             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)", "               (TIFFGetG(*p))),q);", "             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)", "               (TIFFGetB(*p))),q);", "             if (image->alpha_trait != UndefinedPixelTrait)", "               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)", "                 (TIFFGetA(*p))),q);", "             p++;", "             q+=GetPixelChannels(image);", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         break;", "       }", "       case ReadTileMethod:", "       {", "         register uint32", "           *p;", " ", "         uint32", "           *tile_pixels,", "           columns,", "           rows;", " ", "          ", "         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||", "             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(CoderError,\"ImageIsNotTiled\");", "           }", "         (void) SetImageStorageClass(image,DirectClass,exception);", "         number_pixels=(MagickSizeType) columns*rows;", "         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*", "           sizeof(*tile_pixels));", "         if (tile_pixels == (uint32 *) NULL)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         for (y=0; y < (ssize_t) image->rows; y+=rows)", "         {", "           register ssize_t", "             x;", " ", "           register Quantum", "             *magick_restrict q,", "             *magick_restrict tile;", " ", "           size_t", "             columns_remaining,", "             rows_remaining;", " ", "           rows_remaining=image->rows-y;", "           if ((ssize_t) (y+rows) < (ssize_t) image->rows)", "             rows_remaining=rows;", "           tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,", "             exception);", "           if (tile == (Quantum *) NULL)", "             break;", "           for (x=0; x < (ssize_t) image->columns; x+=columns)", "           {", "             size_t", "               column,", "               row;", " ", "             if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)", "               break;", "             columns_remaining=image->columns-x;", "             if ((ssize_t) (x+columns) < (ssize_t) image->columns)", "               columns_remaining=columns;", "             p=tile_pixels+(rows-rows_remaining)*columns;", "             q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+", "               x);", "             for (row=rows_remaining; row > 0; row--)", "             {", "               if (image->alpha_trait != UndefinedPixelTrait)", "                 for (column=columns_remaining; column > 0; column--)", "                 {", "                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetR(*p)),q);", "                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetG(*p)),q);", "                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetB(*p)),q);", "                   SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetA(*p)),q);", "                   p++;", "                   q+=GetPixelChannels(image);", "                 }", "               else", "                 for (column=columns_remaining; column > 0; column--)", "                 {", "                   SetPixelRed(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetR(*p)),q);", "                   SetPixelGreen(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetG(*p)),q);", "                   SetPixelBlue(image,ScaleCharToQuantum((unsigned char)", "                     TIFFGetB(*p)),q);", "                   p++;", "                   q+=GetPixelChannels(image);", "                 }", "               p+=columns-columns_remaining;", "               q-=GetPixelChannels(image)*(image->columns+columns_remaining);", "             }", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);", "         break;", "       }", "       case ReadGenericMethod:", "       default:", "       {", "         MemoryInfo", "           *pixel_info;", " ", "         register uint32", "           *p;", " ", "         uint32", "           *pixels;", " ", "          ", "         number_pixels=(MagickSizeType) image->columns*image->rows;", "         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         pixel_info=AcquireVirtualMemory(image->columns,image->rows*", "           sizeof(uint32));", "         if (pixel_info == (MemoryInfo *) NULL)", "           {", "             TIFFClose(tiff);", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "         pixels=(uint32 *) GetVirtualMemoryBlob(pixel_info);", "         (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)", "           image->rows,(uint32 *) pixels,0);", "          ", "         p=pixels+number_pixels-1;", "         for (y=0; y < (ssize_t) image->rows; y++)", "         {", "           register ssize_t", "             x;", " ", "           register Quantum", "             *magick_restrict q;", " ", "           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "           if (q == (Quantum *) NULL)", "             break;", "           q+=GetPixelChannels(image)*(image->columns-1);", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelRed(image,ScaleCharToQuantum((unsigned char)", "               TIFFGetR(*p)),q);", "             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)", "               TIFFGetG(*p)),q);", "             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)", "               TIFFGetB(*p)),q);", "             if (image->alpha_trait != UndefinedPixelTrait)", "               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)", "                 TIFFGetA(*p)),q);", "             p--;", "             q-=GetPixelChannels(image);", "           }", "           if (SyncAuthenticPixels(image,exception) == MagickFalse)", "             break;", "           if (image->previous == (Image *) NULL)", "             {", "               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "               if (status == MagickFalse)", "                 break;", "             }", "         }", "         pixel_info=RelinquishVirtualMemory(pixel_info);", "         break;", "       }", "      }", "      SetQuantumImageType(image,quantum_type);", "    next_tiff_frame:", "    quantum_info=DestroyQuantumInfo(quantum_info);", "     if (quantum_info != (QuantumInfo *) NULL)", "       quantum_info=DestroyQuantumInfo(quantum_info);", "      if (photometric == PHOTOMETRIC_CIELAB)", "        DecodeLabImage(image,exception);", "      if ((photometric == PHOTOMETRIC_LOGL) ||", "         (photometric == PHOTOMETRIC_MINISBLACK) ||", "         (photometric == PHOTOMETRIC_MINISWHITE))", "       {", "         image->type=GrayscaleType;", "         if (bits_per_sample == 1)", "           image->type=BilevelType;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     status=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;", "     if (status != MagickFalse)", "       {", "          ", "         AcquireNextImage(image_info,image,exception);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,image->scene-1,", "           image->scene);", "         if (status == MagickFalse)", "           break;", "       }", "   } while (status != MagickFalse);", "   TIFFClose(tiff);", "   TIFFReadPhotoshopLayers(image,image_info,exception);", "   if (image_info->number_scenes != 0)", "     {", "       if (image_info->scene >= GetImageListLength(image))", "         {", "            ", "           image=DestroyImageList(image);", "           return((Image *)NULL);", "         }", "     }", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,", "  \t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)", "   \t{", "  \tECDSA_SIG *s;", " \tconst unsigned char *p = sigbuf;", " \tunsigned char *der = NULL;", " \tint derlen = -1;", "  \tint ret=-1;", "  ", "  \ts = ECDSA_SIG_new();", "  \tif (s == NULL) return(ret);", "\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;", " \tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;", " \t ", " \tderlen = i2d_ECDSA_SIG(s, &der);", " \tif (derlen != sig_len || memcmp(sigbuf, der, derlen))", " \t\tgoto err;", "  \tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);", "  err:", " \tif (derlen > 0)", " \t\t{", " \t\tOPENSSL_cleanse(der, derlen);", " \t\tOPENSSL_free(der);", " \t\t}", "  \tECDSA_SIG_free(s);", "  \treturn(ret);", "  \t}"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" void AppCacheUpdateJob::OnDestructionImminent(AppCacheHost* host) {", "    PendingMasters::iterator found =", "        pending_master_entries_.find(host->pending_master_entry_url());", "  DCHECK(found != pending_master_entries_.end());", "   CHECK(found != pending_master_entries_.end());", "    PendingHosts& hosts = found->second;", "    PendingHosts::iterator it = std::find(hosts.begin(), hosts.end(), host);", "  DCHECK(it != hosts.end());", "   CHECK(it != hosts.end());", "    hosts.erase(it);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0]}
{"tokens": ["SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)", "{", "unsigned len;", "int i;", "", "if (!access_ok(VERIFY_WRITE, name, namelen))", "return -EFAULT;", "", "len = namelen;", "if (namelen > 32)", "len = 32;", "", "down_read(&uts_sem);", "for (i = 0; i < len; ++i) {", "__put_user(utsname()->domainname[i], name + i);", "if (utsname()->domainname[i] == '\\0')", "break;", "}", "up_read(&uts_sem);", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   WebsiteSettings* website_settings() {", "      if (!website_settings_.get()) {", "        website_settings_.reset(new WebsiteSettings(", "            mock_ui(), profile(), tab_specific_content_settings(),", "          infobar_service(), url(), ssl(), cert_store()));", "           web_contents(), url(), ssl(), cert_store()));", "      }", "      return website_settings_.get();", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" xfs_da3_fixhashpath(", " \tstruct xfs_da_state\t*state,", " \tstruct xfs_da_state_path *path)", " {", " \tstruct xfs_da_state_blk\t*blk;", " \tstruct xfs_da_intnode\t*node;", " \tstruct xfs_da_node_entry *btree;", " \txfs_dahash_t\t\tlasthash=0;", " \tint\t\t\tlevel;", " \tint\t\t\tcount;", " \tstruct xfs_inode\t*dp = state->args->dp;", " ", " \ttrace_xfs_da_fixhashpath(state->args);", " ", " \tlevel = path->active-1;", " \tblk = &path->blk[ level ];", " \tswitch (blk->magic) {", " \tcase XFS_ATTR_LEAF_MAGIC:", " \t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);", " \t\tif (count == 0)", " \t\t\treturn;", " \t\tbreak;", " \tcase XFS_DIR2_LEAFN_MAGIC:", " \t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);", " \t\tif (count == 0)", " \t\t\treturn;", " \t\tbreak;", " \tcase XFS_DA_NODE_MAGIC:", " \t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);", " \t\tif (count == 0)", " \t\t\treturn;", " \t\tbreak;", " \t}", " \tfor (blk--, level--; level >= 0; blk--, level--) {", " \t\tstruct xfs_da3_icnode_hdr nodehdr;", " ", "  \t\tnode = blk->bp->b_addr;", "  \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);", "  \t\tbtree = dp->d_ops->node_tree_p(node);", "\t\tif (be32_to_cpu(btree->hashval) == lasthash)", " \t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)", "  \t\t\tbreak;", "  \t\tblk->hashval = lasthash;", "  \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);", " \t\txfs_trans_log_buf(state->args->trans, blk->bp,", " \t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],", " \t\t\t\t\t\t  sizeof(*btree)));", " ", " \t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int normal_ecc_mulmod(mp_int* k, ecc_point *G, ecc_point *R,", "mp_int* a, mp_int* modulus, int map,", "void* heap)", "#else", "int wc_ecc_mulmod_ex(mp_int* k, ecc_point *G, ecc_point *R,", "mp_int* a, mp_int* modulus, int map,", "void* heap)", "#endif", "{", "#ifndef WOLFSSL_SP_MATH", "#ifndef ECC_TIMING_RESISTANT", "", "#define WINSIZE  4", "#define M_POINTS 8", "int           first = 1, bitbuf = 0, bitcpy = 0, j;", "#else", "#define M_POINTS 4", "#endif", "", "ecc_point     *tG, *M[M_POINTS];", "int           i, err;", "#ifdef WOLFSSL_SMALL_STACK", "mp_int*       mu = NULL;", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "ecc_key       key;", "#endif", "#else", "mp_int        mu[1];", "#endif", "mp_digit      mp;", "mp_digit      buf;", "int           bitcnt = 0, mode = 0, digidx = 0;", "", "if (k == NULL || G == NULL || R == NULL || modulus == NULL) {", "return ECC_BAD_ARG_E;", "}", "", "", "tG = NULL;", "XMEMSET(M, 0, sizeof(M));", "#ifdef WOLFSSL_SMALL_STACK", "mu = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "if (mu == NULL)", "return MEMORY_E;", "#endif", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "key.t1 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "key.t2 = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "#ifdef ALT_ECC_SIZE", "key.x = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "key.y = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "key.z = (mp_int*)XMALLOC(sizeof(mp_int), heap, DYNAMIC_TYPE_ECC);", "#endif", "if (key.t1 == NULL || key.t2 == NULL", "#ifdef ALT_ECC_SIZE", "|| key.x == NULL || key.y == NULL || key.z == NULL", "#endif", ") {", "#ifdef ALT_ECC_SIZE", "XFREE(key.z, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.y, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.x, heap, DYNAMIC_TYPE_ECC);", "#endif", "XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);", "XFREE(mu, heap, DYNAMIC_TYPE_ECC);", "return MEMORY_E;", "}", "#endif /* WOLFSSL_SMALL_STACK_CACHE */", "", "", "if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "#ifdef ALT_ECC_SIZE", "XFREE(key.z, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.y, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.x, heap, DYNAMIC_TYPE_ECC);", "#endif", "XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);", "#endif /* WOLFSSL_SMALL_STACK_CACHE */", "#ifdef WOLFSSL_SMALL_STACK", "XFREE(mu, heap, DYNAMIC_TYPE_ECC);", "#endif", "return err;", "}", "", "if ((err = mp_init(mu)) != MP_OKAY) {", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "#ifdef ALT_ECC_SIZE", "XFREE(key.z, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.y, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.x, heap, DYNAMIC_TYPE_ECC);", "#endif", "XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);", "#endif /* WOLFSSL_SMALL_STACK_CACHE */", "#ifdef WOLFSSL_SMALL_STACK", "XFREE(mu, heap, DYNAMIC_TYPE_ECC);", "#endif", "return err;", "}", "if ((err = mp_montgomery_calc_normalization(mu, modulus)) != MP_OKAY) {", "mp_clear(mu);", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "#ifdef ALT_ECC_SIZE", "XFREE(key.z, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.y, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.x, heap, DYNAMIC_TYPE_ECC);", "#endif", "XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);", "#endif /* WOLFSSL_SMALL_STACK_CACHE */", "#ifdef WOLFSSL_SMALL_STACK", "XFREE(mu, heap, DYNAMIC_TYPE_ECC);", "#endif", "return err;", "}", "", "", "for (i = 0; i < M_POINTS; i++) {", "M[i] = wc_ecc_new_point_h(heap);", "if (M[i] == NULL) {", "mp_clear(mu);", "err = MEMORY_E; goto exit;", "}", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "M[i]->key = &key;", "#endif", "}", "", "", "tG = wc_ecc_new_point_h(heap);", "if (tG == NULL)", "err = MEMORY_E;", "", "", "if (err == MP_OKAY) {", "if (mp_cmp_d(mu, 1) == MP_EQ) {", "err = mp_copy(G->x, tG->x);", "if (err == MP_OKAY)", "err = mp_copy(G->y, tG->y);", "if (err == MP_OKAY)", "err = mp_copy(G->z, tG->z);", "} else {", "err = mp_mulmod(G->x, mu, modulus, tG->x);", "if (err == MP_OKAY)", "err = mp_mulmod(G->y, mu, modulus, tG->y);", "if (err == MP_OKAY)", "err = mp_mulmod(G->z, mu, modulus, tG->z);", "}", "}", "", "", "mp_clear(mu);", "", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "R->key = &key;", "#endif", "#ifndef ECC_TIMING_RESISTANT", "", "", "", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(tG, M[0], a, modulus, mp);", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[0], M[0], a, modulus, mp);", "", "", "if (err == MP_OKAY)", "for (j = 9; j < 16; j++) {", "err = ecc_projective_add_point(M[j-9], tG, M[j-M_POINTS], a, modulus,", "mp);", "if (err != MP_OKAY) break;", "}", "", "", "if (err == MP_OKAY) {", "mode   = 0;", "bitcnt = 1;", "buf    = 0;", "digidx = get_digit_count(k) - 1;", "bitcpy = bitbuf = 0;", "first  = 1;", "", "", "for (;;) {", "", "if (--bitcnt == 0) {", "if (digidx == -1) {", "break;", "}", "buf    = get_digit(k, digidx);", "bitcnt = (int) DIGIT_BIT;", "--digidx;", "}", "", "", "i = (int)(buf >> (DIGIT_BIT - 1)) & 1;", "buf <<= 1;", "", "", "if (mode == 0 && i == 0)", "continue;", "", "", "if (mode == 1 && i == 0) {", "err = ecc_projective_dbl_point(R, R, a, modulus, mp);", "if (err != MP_OKAY) break;", "continue;", "}", "", "", "bitbuf |= (i << (WINSIZE - ++bitcpy));", "mode = 2;", "", "if (bitcpy == WINSIZE) {", "", "if (first == 1) {", "", "err = mp_copy(M[bitbuf-M_POINTS]->x, R->x);", "if (err != MP_OKAY) break;", "", "err = mp_copy(M[bitbuf-M_POINTS]->y, R->y);", "if (err != MP_OKAY) break;", "", "err = mp_copy(M[bitbuf-M_POINTS]->z, R->z);", "first = 0;", "} else {", "", "", "", "for (j = 0; j < WINSIZE; j++) {", "err = ecc_projective_dbl_point(R, R, a, modulus, mp);", "if (err != MP_OKAY) break;", "}", "if (err != MP_OKAY) break;", "", "", "err = ecc_projective_add_point(R, M[bitbuf-M_POINTS], R, a,", "modulus, mp);", "}", "if (err != MP_OKAY) break;", "", "bitcpy = bitbuf = 0;", "mode = 1;", "}", "}", "}", "", "", "if (err == MP_OKAY) {", "if (mode == 2 && bitcpy > 0) {", "", "for (j = 0; j < bitcpy; j++) {", "", "if (first == 0) {", "err = ecc_projective_dbl_point(R, R, a, modulus, mp);", "if (err != MP_OKAY) break;", "}", "", "bitbuf <<= 1;", "if ((bitbuf & (1 << WINSIZE)) != 0) {", "if (first == 1) {", "", "err = mp_copy(tG->x, R->x);", "if (err != MP_OKAY) break;", "", "err = mp_copy(tG->y, R->y);", "if (err != MP_OKAY) break;", "", "err = mp_copy(tG->z, R->z);", "if (err != MP_OKAY) break;", "first = 0;", "} else {", "", "err = ecc_projective_add_point(R, tG, R, a, modulus, mp);", "if (err != MP_OKAY) break;", "}", "}", "}", "}", "}", "", "#undef WINSIZE", "", "#else /* ECC_TIMING_RESISTANT */", "", "", "", "if (err == MP_OKAY)", "err = mp_copy(tG->x, M[0]->x);", "if (err == MP_OKAY)", "err = mp_copy(tG->y, M[0]->y);", "if (err == MP_OKAY)", "err = mp_copy(tG->z, M[0]->z);", "", "", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(tG, M[1], a, modulus, mp);", "", "", "mode   = 0;", "bitcnt = 1;", "buf    = 0;", "digidx = get_digit_count(modulus) - 1;", "", "digidx += (modulus->dp[digidx] >> (DIGIT_BIT-1));", "", "", "if (err == MP_OKAY) {", "for (;;) {", "", "if (--bitcnt == 0) {", "if (digidx == -1) {", "break;", "}", "buf = get_digit(k, digidx);", "bitcnt = (int)DIGIT_BIT;", "--digidx;", "}", "", "", "i = (buf >> (DIGIT_BIT - 1)) & 1;", "buf <<= 1;", "", "if (mode == 0) {", "mode = i;", "", "if (err == MP_OKAY)", "err = ecc_projective_add_point(M[1], M[2], M[2], a, modulus,", "mp);", "#ifdef WC_NO_CACHE_RESISTANT", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);", "#else", "", "", "", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->x & wc_off_on_addr[i])),", "M[2]->x);", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->y & wc_off_on_addr[i])),", "M[2]->y);", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->z & wc_off_on_addr[i])),", "M[2]->z);", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[2], M[3], a, modulus, mp);", "", "if (err == MP_OKAY)", "err = mp_copy(M[2]->x,", "(mp_int*)", "( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );", "if (err == MP_OKAY)", "err = mp_copy(M[2]->y,", "(mp_int*)", "( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );", "if (err == MP_OKAY)", "err = mp_copy(M[2]->z,", "(mp_int*)", "( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );", "#endif", "if (err == MP_OKAY)", "continue;", "}", "", "if (err == MP_OKAY)", "err = ecc_projective_add_point(M[0], M[1], M[i^1], a, modulus,", "mp);", "#ifdef WC_NO_CACHE_RESISTANT", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[i], M[i], a, modulus, mp);", "#else", "", "", "", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->x & wc_off_on_addr[i])),", "M[2]->x);", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->y & wc_off_on_addr[i])),", "M[2]->y);", "if (err == MP_OKAY)", "err = mp_copy((mp_int*)", "( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->z & wc_off_on_addr[i])),", "M[2]->z);", "if (err == MP_OKAY)", "err = ecc_projective_dbl_point(M[2], M[2], a, modulus, mp);", "", "if (err == MP_OKAY)", "err = mp_copy(M[2]->x,", "(mp_int*)", "( ((wolfssl_word)M[0]->x & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->x & wc_off_on_addr[i])) );", "if (err == MP_OKAY)", "err = mp_copy(M[2]->y,", "(mp_int*)", "( ((wolfssl_word)M[0]->y & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->y & wc_off_on_addr[i])) );", "if (err == MP_OKAY)", "err = mp_copy(M[2]->z,", "(mp_int*)", "( ((wolfssl_word)M[0]->z & wc_off_on_addr[i^1]) +", "((wolfssl_word)M[1]->z & wc_off_on_addr[i])) );", "if (err != MP_OKAY)", "break;", "#endif /* WC_NO_CACHE_RESISTANT */", "}", "}", "", "", "if (err == MP_OKAY)", "err = mp_copy(M[0]->x, R->x);", "if (err == MP_OKAY)", "err = mp_copy(M[0]->y, R->y);", "if (err == MP_OKAY)", "err = mp_copy(M[0]->z, R->z);", "", "#endif /* ECC_TIMING_RESISTANT */", "", "", "if (err == MP_OKAY && map)", "err = ecc_map(R, modulus, mp);", "", "exit:", "", "", "wc_ecc_del_point_h(tG, heap);", "for (i = 0; i < M_POINTS; i++) {", "wc_ecc_del_point_h(M[i], heap);", "}", "#ifdef WOLFSSL_SMALL_STACK_CACHE", "R->key = NULL;", "#ifdef ALT_ECC_SIZE", "XFREE(key.z, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.y, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.x, heap, DYNAMIC_TYPE_ECC);", "#endif", "XFREE(key.t2, heap, DYNAMIC_TYPE_ECC);", "XFREE(key.t1, heap, DYNAMIC_TYPE_ECC);", "#endif /* WOLFSSL_SMALL_STACK_CACHE */", "#ifdef WOLFSSL_SMALL_STACK", "XFREE(mu, heap, DYNAMIC_TYPE_ECC);", "#endif", "", "return err;", "#else", "if (k == NULL || G == NULL || R == NULL || modulus == NULL) {", "return ECC_BAD_ARG_E;", "}", "", "(void)a;", "", "return sp_ecc_mulmod_256(k, G, R, map, heap);", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path,", "unsigned char **out, size_t *out_len,", "int verify_pin)", "{", "struct sc_context *ctx = p15card->card->ctx;", "struct sc_card *card = p15card->card;", "struct sc_file *file = NULL;", "struct sc_path path;", "size_t sz;", "int rv;", "", "LOG_FUNC_CALLED(ctx);", "if (!in_path || !out || !out_len)", "LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, \"Cannot read oberthur file\");", "", "sc_log(ctx, \"read file '%s'; verify_pin:%i\", in_path, verify_pin);", "", "*out = NULL;", "*out_len = 0;", "", "sc_format_path(in_path, &path);", "rv = sc_select_file(card, &path, &file);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, rv, \"Cannot select oberthur file to read\");", "}", "", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)", "sz = file->size;", "else", "sz = (file->record_length + 2) * file->record_count;", "", "*out = calloc(sz, 1);", "if (*out == NULL) {", "sc_file_free(file);", "LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, \"Cannot read oberthur file\");", "}", "", "if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   {", "rv = sc_read_binary(card, 0, *out, sz, 0);", "}", "else {", "size_t rec;", "size_t offs = 0;", "size_t rec_len = file->record_length;", "", "for (rec = 1; ; rec++)   {", "if (rec > file->record_count) {", "rv = 0;", "break;", "}", "rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR);", "if (rv == SC_ERROR_RECORD_NOT_FOUND)   {", "rv = 0;", "break;", "}", "else if (rv < 0)   {", "break;", "}", "", "rec_len = rv;", "", "*(*out + offs) = 'R';", "*(*out + offs + 1) = rv;", "", "offs += rv + 2;", "}", "", "sz = offs;", "}", "", "sc_log(ctx, \"read oberthur file result %i\", rv);", "if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {", "struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL;", "const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ);", "int ii;", "", "if (acl == NULL) {", "sc_file_free(file);", "free(*out);", "*out = NULL;", "LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA);", "}", "", "rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10);", "if (rv != SC_SUCCESS) {", "sc_file_free(file);", "free(*out);", "*out = NULL;", "LOG_TEST_RET(ctx, rv, \"Cannot read oberthur file: get AUTH objects error\");", "}", "", "for (ii=0; ii<rv; ii++)   {", "struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data;", "sc_log(ctx, \"compare PIN/ACL refs:%i/%i, method:%i/%i\",", "auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method);", "if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   {", "pin_obj = objs[ii];", "break;", "}", "}", "", "if (!pin_obj || !pin_obj->content.value)    {", "rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED;", "}", "else    {", "rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len);", "if (!rv)", "rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0);", "}", "}", "", "sc_file_free(file);", "", "if (rv < 0)   {", "free(*out);", "*out = NULL;", "*out_len = 0;", "}", "", "*out_len = sz;", "", "LOG_FUNC_RETURN(ctx, rv);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int filter_frame(AVFilterLink *inlink, AVFrame *in)", " {", "     AVFilterContext *ctx = inlink->dst;", "     BoxBlurContext *s = ctx->priv;", "     AVFilterLink *outlink = inlink->dst->outputs[0];", "     AVFrame *out;", "     int plane;", "     int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);", "     int w[4] = { inlink->w, cw, cw, inlink->w };", "     int h[4] = { in->height, ch, ch, in->height };", " ", "     out = ff_get_video_buffer(outlink, outlink->w, outlink->h);", "     if (!out) {", "         av_frame_free(&in);", "         return AVERROR(ENOMEM);", "      }", "      av_frame_copy_props(out, in);", "  ", "    for (plane = 0; in->data[plane] && plane < 4; plane++)", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)", "          hblur(out->data[plane], out->linesize[plane],", "                in ->data[plane], in ->linesize[plane],", "                w[plane], h[plane], s->radius[plane], s->power[plane],", "                s->temp);", "  ", "    for (plane = 0; in->data[plane] && plane < 4; plane++)", "     for (plane = 0; plane < 4 && in->data[plane] && in->linesize[plane]; plane++)", "          vblur(out->data[plane], out->linesize[plane],", "                out->data[plane], out->linesize[plane],", "                w[plane], h[plane], s->radius[plane], s->power[plane],", "               s->temp);", " ", "     av_frame_free(&in);", " ", "     return ff_filter_frame(outlink, out);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHP_FUNCTION(unserialize)", " {", " \tchar *buf = NULL;", " \tsize_t buf_len;", "  \tconst unsigned char *p;", "  \tphp_unserialize_data_t var_hash;", "  \tzval *options = NULL, *classes = NULL;", " \tzval *retval;", "  \tHashTable *class_hash = NULL;", "  ", "  \tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|a\", &buf, &buf_len, &options) == FAILURE) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tif (buf_len == 0) {", " \t\tRETURN_FALSE;", " \t}", " ", " \tp = (const unsigned char*) buf;", " \tPHP_VAR_UNSERIALIZE_INIT(var_hash);", " \tif(options != NULL) {", " \t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"allowed_classes\", sizeof(\"allowed_classes\")-1);", " \t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {", " \t\t\tALLOC_HASHTABLE(class_hash);", " \t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);", " \t\t}", " \t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {", " \t\t\tzval *entry;", " \t\t\tzend_string *lcname;", " ", " \t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {", " \t\t\t\tconvert_to_string_ex(entry);", " \t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));", " \t\t\t\tzend_hash_add_empty_element(class_hash, lcname);", " \t\t        zend_string_release(lcname);", " \t\t\t} ZEND_HASH_FOREACH_END();", "  \t\t}", "  \t}", "  ", "\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {", " \tretval = var_tmp_var(&var_hash);", " \tif (!php_var_unserialize_ex(retval, &p, p + buf_len, &var_hash, class_hash)) {", "  \t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);", "  \t\tif (class_hash) {", "  \t\t\tzend_hash_destroy(class_hash);", "  \t\t\tFREE_HASHTABLE(class_hash);", "  \t\t}", "\t\tzval_ptr_dtor(return_value);", "  \t\tif (!EG(exception)) {", "  \t\t\tphp_error_docref(NULL, E_NOTICE, \"Error at offset \" ZEND_LONG_FMT \" of %zd bytes\",", "  \t\t\t\t(zend_long)((char*)p - buf), buf_len);", "  \t\t}", "  \t\tRETURN_FALSE;", "  \t}", "\t ", "\tvar_push_dtor(&var_hash, return_value);", " ", " \tZVAL_COPY(return_value, retval);", "  ", "  \tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);", "  \tif (class_hash) {", " \t\tzend_hash_destroy(class_hash);", " \t\tFREE_HASHTABLE(class_hash);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    static bool IsManualFallbackForFillingEnabled() {", "      return base::FeatureList::IsEnabled(", "               password_manager::features::kEnableManualFallbacksFilling) &&", "                password_manager::features::kManualFallbacksFilling) &&", "             !IsPreLollipopAndroid();", "    }"], "ner_tags": [0, 0, 1, 1, 0, 0]}
{"tokens": [" int do_remount_sb(struct super_block *sb, int flags, void *data, int force)", " {", " \tint retval;", " \tint remount_ro;", " ", " \tif (sb->s_writers.frozen != SB_UNFROZEN)", " \t\treturn -EBUSY;", " ", " #ifdef CONFIG_BLOCK", " \tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))", " \t\treturn -EACCES;", " #endif", " ", " \tif (flags & MS_RDONLY)", " \t\tacct_auto_close(sb);", " \tshrink_dcache_sb(sb);", " \tsync_filesystem(sb);", " ", " \tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);", " ", " \t ", "  \tif (remount_ro) {", "  \t\tif (force) {", "\t\t\tmark_files_ro(sb);", " \t\t\tsb->s_readonly_remount = 1;", " \t\t\tsmp_wmb();", "  \t\t} else {", "  \t\t\tretval = sb_prepare_remount_readonly(sb);", "  \t\t\tif (retval)", " \t\t\t\treturn retval;", " \t\t}", " \t}", " ", " \tif (sb->s_op->remount_fs) {", " \t\tretval = sb->s_op->remount_fs(sb, &flags, data);", " \t\tif (retval) {", " \t\t\tif (!force)", " \t\t\t\tgoto cancel_readonly;", " \t\t\t ", " \t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",", " \t\t\t     sb->s_type->name, retval);", " \t\t}", " \t}", " \tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);", " \t ", " \tsmp_wmb();", " \tsb->s_readonly_remount = 0;", " ", " \t ", " \tif (remount_ro && sb->s_bdev)", " \t\tinvalidate_bdev(sb->s_bdev);", " \treturn 0;", " ", " cancel_readonly:", " \tsb->s_readonly_remount = 0;", " \treturn retval;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* ctx) override {", "const Tensor* seq_len_max_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));", "", "const Tensor* x;", "OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));", "OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));", "const int64_t timelen = x->dim_size(0);", "const int64_t batch_size = x->dim_size(1);", "const int64_t input_size = x->dim_size(2);", "", "const Tensor* cs_prev_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));", "", "const Tensor* h_prev_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));", "", "const Tensor* w_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));", "const int64_t cell_size = w_tensor->dim_size(1) / 4;", "OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),", "errors::InvalidArgument(", "\"w matrix rows don't match: \", input_size + cell_size,", "\" vs. \", w_tensor->dim_size(0)));", "", "const Tensor* wci_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));", "", "const Tensor* wcf_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));", "", "const Tensor* wco_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));", "", "const Tensor* b_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));", "OP_REQUIRES(", "ctx, cell_size == b_tensor->dim_size(0) / 4,", "errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,", "\" vs. \", b_tensor->dim_size(0)));", "", "const Tensor* i_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"i\", &i_out));", "", "const Tensor* cs_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"cs\", &cs_out));", "", "const Tensor* f_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"f\", &f_out));", "", "const Tensor* o_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"o\", &o_out));", "", "const Tensor* ci_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"ci\", &ci_out));", "", "const Tensor* co_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"co\", &co_out));", "", "const Tensor* h_out = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"h\", &h_out));", "", "const Tensor* cs_grad = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"cs_grad\", &cs_grad));", "", "const Tensor* h_grad = nullptr;", "OP_REQUIRES_OK(ctx, ctx->input(\"h_grad\", &h_grad));", "", "TensorShape batch_input_shape({timelen, batch_size, input_size});", "Tensor* x_grad;", "OP_REQUIRES_OK(ctx,", "ctx->allocate_output(\"x_grad\", batch_input_shape, &x_grad));", "", "Tensor* cs_prev_grad_tensor = nullptr;", "OP_REQUIRES_OK(ctx,", "ctx->allocate_output(\"cs_prev_grad\", cs_prev_tensor->shape(),", "&cs_prev_grad_tensor));", "", "Tensor* h_prev_grad_tensor = nullptr;", "OP_REQUIRES_OK(ctx,", "ctx->allocate_output(\"h_prev_grad\", h_prev_tensor->shape(),", "&h_prev_grad_tensor));", "", "Tensor* w_grad_tensor = nullptr;", "OP_REQUIRES_OK(", "ctx, ctx->allocate_output(\"w_grad\", w_tensor->shape(), &w_grad_tensor));", "", "Tensor* wci_grad_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wci_grad\", wci_tensor->shape(),", "&wci_grad_tensor));", "", "Tensor* wcf_grad_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wcf_grad\", wcf_tensor->shape(),", "&wcf_grad_tensor));", "", "Tensor* wco_grad_tensor = nullptr;", "OP_REQUIRES_OK(ctx, ctx->allocate_output(\"wco_grad\", wco_tensor->shape(),", "&wco_grad_tensor));", "", "Tensor* b_grad_tensor = nullptr;", "OP_REQUIRES_OK(", "ctx, ctx->allocate_output(\"b_grad\", b_tensor->shape(), &b_grad_tensor));", "", "TensorShape batch_cell_shape({batch_size, cell_size});", "", "Tensor xh_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(", "DataTypeToEnum<T>::v(),", "TensorShape({batch_size, input_size + cell_size}),", "&xh_tensor));", "", "Tensor xh_grad_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "xh_tensor.shape(), &xh_grad_tensor));", "", "Tensor do_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &do_tensor));", "", "Tensor dcs_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &dcs_tensor));", "", "Tensor dci_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &dci_tensor));", "", "Tensor df_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &df_tensor));", "", "Tensor di_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &di_tensor));", "", "Tensor dgates_tensor;", "OP_REQUIRES_OK(ctx,", "ctx->allocate_temp(DataTypeToEnum<T>::v(),", "TensorShape({batch_size, cell_size * 4}),", "&dgates_tensor));", "", "Tensor cs_grad_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &cs_grad_tensor));", "", "Tensor h_grad_tensor;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<T>::v(),", "batch_cell_shape, &h_grad_tensor));", "", "const Device& device = ctx->eigen_device<Device>();", "", "functor::TensorZero<Device, T>()(device, cs_grad_tensor.flat<T>());", "functor::TensorZero<Device, T>()(device, cs_prev_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, h_grad_tensor.flat<T>());", "functor::TensorZero<Device, T>()(device, h_prev_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, w_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, wci_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, wcf_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, wco_grad_tensor->flat<T>());", "functor::TensorZero<Device, T>()(device, b_grad_tensor->flat<T>());", "", "const int64_t seq_len_max = seq_len_max_tensor->scalar<int64_t>()();", "SliceHelper<Device, T> slicer(ctx);", "for (int64_t t = seq_len_max - 1; t >= 0; --t) {", "const Tensor& x_tensor = slicer.InputSlice(*x, t, \"x\");", "const Tensor& cs_prev_tensor2 =", "t == 0 ? *cs_prev_tensor", ": slicer.InputSlice(*cs_out, t - 1, \"cs_prev\");", "const Tensor& h_prev_tensor2 =", "t == 0 ? *h_prev_tensor : slicer.InputSlice(*h_out, t - 1, \"h_prev\");", "const Tensor& i_tensor = slicer.InputSlice(*i_out, t, \"i_out\");", "const Tensor& cs_tensor = slicer.InputSlice(*cs_out, t, \"cs_out\");", "const Tensor& f_tensor = slicer.InputSlice(*f_out, t, \"f_out\");", "const Tensor& o_tensor = slicer.InputSlice(*o_out, t, \"o_out\");", "const Tensor& ci_tensor = slicer.InputSlice(*ci_out, t, \"ci_out\");", "const Tensor& co_tensor = slicer.InputSlice(*co_out, t, \"co_out\");", "", "", "const Tensor& const_cs_prev_grad_tensor = *cs_prev_grad_tensor;", "const Tensor const_cs_grad_slice =", "slicer.InputSlice(*cs_grad, t, \"cs_grad\");", "functor::TensorAdd<Device, T>()(", "device, const_cs_prev_grad_tensor.flat<T>(),", "const_cs_grad_slice.flat<T>(), cs_grad_tensor.flat<T>());", "", "", "const Tensor& const_h_prev_grad_tensor = *h_prev_grad_tensor;", "const Tensor const_h_grad_slice = slicer.InputSlice(*h_grad, t, \"h_grad\");", "functor::TensorAdd<Device, T>()(", "device, const_h_prev_grad_tensor.flat<T>(),", "const_h_grad_slice.flat<T>(), h_grad_tensor.flat<T>());", "", "const Tensor& const_cs_grad_tensor = cs_grad_tensor;", "const Tensor& const_h_grad_tensor = h_grad_tensor;", "", "Tensor x_grad_tensor = slicer.OutputSlice(x_grad, t, \"x_grad\");", "functor::BlockLSTMBprop<Device, T, USE_CUBLAS, gate_layout>(", "batch_size, input_size, cell_size)(", "ctx, device, use_peephole_, x_tensor.matrix<T>(),", "cs_prev_tensor2.matrix<T>(), h_prev_tensor2.matrix<T>(),", "w_tensor->matrix<T>(), wci_tensor->vec<T>(), wcf_tensor->vec<T>(),", "wco_tensor->vec<T>(), b_tensor->vec<T>(), xh_tensor.matrix<T>(),", "i_tensor.matrix<T>(), cs_tensor.matrix<T>(), f_tensor.matrix<T>(),", "o_tensor.matrix<T>(), ci_tensor.matrix<T>(), co_tensor.matrix<T>(),", "const_cs_grad_tensor.matrix<T>(), const_h_grad_tensor.matrix<T>(),", "do_tensor.matrix<T>(), dcs_tensor.matrix<T>(), dci_tensor.matrix<T>(),", "df_tensor.matrix<T>(), di_tensor.matrix<T>(),", "dgates_tensor.matrix<T>(), cs_prev_grad_tensor->matrix<T>(),", "h_prev_grad_tensor->matrix<T>(), xh_grad_tensor.matrix<T>(),", "x_grad_tensor.matrix<T>(), w_grad_tensor->matrix<T>(),", "wci_grad_tensor->vec<T>(), wcf_grad_tensor->vec<T>(),", "wco_grad_tensor->vec<T>(), b_grad_tensor->vec<T>());", "slicer.FinishTimeStep();", "}", "", "if (seq_len_max < timelen) {", "Tensor x_grad_tensor = x_grad->Slice(seq_len_max, timelen);", "functor::TensorUnalignedZero<Device, T>()(", "device, x_grad_tensor.unaligned_flat<T>());", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void MediaControlTimelineElement::defaultEventHandler(Event* event) {", "   if (event->isMouseEvent() &&", "       toMouseEvent(event)->button() !=", "           static_cast<short>(WebPointerProperties::Button::Left))", "     return;", " ", "   if (!isConnected() || !document().isActive())", "     return;", " ", "   if (event->type() == EventTypeNames::mousedown) {", "     Platform::current()->recordAction(", "         UserMetricsAction(\"Media.Controls.ScrubbingBegin\"));", "     mediaControls().beginScrubbing();", "   }", " ", "   if (event->type() == EventTypeNames::mouseup) {", "     Platform::current()->recordAction(", "         UserMetricsAction(\"Media.Controls.ScrubbingEnd\"));", "     mediaControls().endScrubbing();", "   }", "  ", "    MediaControlInputElement::defaultEventHandler(event);", "  ", "  if (event->type() == EventTypeNames::mouseover ||", "      event->type() == EventTypeNames::mouseout ||", "      event->type() == EventTypeNames::mousemove)", "   if (event->type() != EventTypeNames::input)", "      return;", "  ", "    double time = value().toDouble();", "  if (event->type() == EventTypeNames::input) {", "    if (mediaElement().seekable()->contain(time))", "      mediaElement().setCurrentTime(time);", "  }", " ", "    ", "    ", "   if (mediaElement().seekable()->contain(time))", "     mediaElement().setCurrentTime(time);", "  ", "    LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject()));", "    if (!slider.isNull() && slider.inDragMode())", "     mediaControls().updateCurrentTimeDisplay();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)", " {", " \tstruct snd_pcm_runtime *runtime;", " \tunsigned long flags;", " ", " \tif (PCM_RUNTIME_CHECK(substream))", " \t\treturn;", " \truntime = substream->runtime;", " ", " \tsnd_pcm_stream_lock_irqsave(substream, flags);", " \tif (!snd_pcm_running(substream) ||", " \t    snd_pcm_update_hw_ptr0(substream, 1) < 0)", " \t\tgoto _end;", " ", " #ifdef CONFIG_SND_PCM_TIMER", " \tif (substream->timer_running)", "  \t\tsnd_timer_interrupt(substream->timer, 1);", "  #endif", "   _end:", "\tsnd_pcm_stream_unlock_irqrestore(substream, flags);", "  \tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);", " \tsnd_pcm_stream_unlock_irqrestore(substream, flags);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]}
{"tokens": ["  void pin_remove(struct fs_pin *pin)", "  {", "  \tspin_lock(&pin_lock);", "\thlist_del(&pin->m_list);", "\thlist_del(&pin->s_list);", " \thlist_del_init(&pin->m_list);", " \thlist_del_init(&pin->s_list);", "  \tspin_unlock(&pin_lock);", "  \tspin_lock_irq(&pin->wait.lock);", "  \tpin->done = 1;", " \twake_up_locked(&pin->wait);", " \tspin_unlock_irq(&pin->wait.lock);", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,", " \t\t      const char *hookname, const char **chainname,", " \t\t      const char **comment, unsigned int *rulenum)", " {", " \tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);", " ", " \tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {", " \t\t ", " \t\t*chainname = t->target.data;", " \t\t(*rulenum) = 0;", "  \t} else if (s == e) {", "  \t\t(*rulenum)++;", "  ", "\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&", " \t\tif (unconditional(s) &&", "  \t\t    strcmp(t->target.u.kernel.target->name,", "  \t\t\t   XT_STANDARD_TARGET) == 0 &&", "\t\t    t->verdict < 0 &&", "\t\t    unconditional(&s->ipv6)) {", " \t\t    t->verdict < 0) {", "  \t\t\t ", "  \t\t\t*comment = *chainname == hookname", "  \t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]", " \t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];", " \t\t}", " \t\treturn 1;", " \t} else", " \t\t(*rulenum)++;", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> postMessageCallback(const v8::Arguments& args)", "  {", "      INC_STATS(\"DOM.TestActiveDOMObject.postMessage\");", "      if (args.Length() < 1)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "      TestActiveDOMObject* imp = V8TestActiveDOMObject::toNative(args.Holder());", "      STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, message, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));", "      imp->postMessage(message);", "     return v8::Handle<v8::Value>();", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  void add_param_to_argv(char *parsestart, int line)", "  {", "\tint quote_open = 0, escaped = 0, param_len = 0;", "\tchar param_buffer[1024], *curchar;", " \tint quote_open = 0, escaped = 0;", " \tstruct xt_param_buf param = {};", " \tchar *curchar;", "  ", "  \t ", " \t\t\tparam_buffer[param_len++] = *curchar;", " ", " \t\t\tif (param_len >= sizeof(param_buffer))", " \t\t\t\txtables_error(PARAMETER_PROBLEM,", "  \t\tcase ' ':", "  \t\tcase '\\t':", "  \t\tcase '\\n':", "\t\t\tif (!param_len) {", " \t\t\tif (!param.len) {", "  \t\t\t\t ", "  \t\t\t\tcontinue;", "  \t\t\t}", "  \t\t\tbreak;", "  \t\tdefault:", "  \t\t\t ", "\t\t\tparam_buffer[param_len++] = *curchar;", "\t\t\tif (param_len >= sizeof(param_buffer))", "\t\t\t\txtables_error(PARAMETER_PROBLEM,", "\t\t\t\t\t      \"Parameter too long!\");", " \t\t\tadd_param(&param, curchar);", "  \t\t\tcontinue;", "  \t\t}", "  ", "\t\tparam_buffer[param_len] = '\\0';", " \t\tparam.buffer[param.len] = '\\0';", "  ", "  \t\t ", "\t\tif ((param_buffer[0] == '-' &&", "\t\t     param_buffer[1] != '-' &&", "\t\t     strchr(param_buffer, 't')) ||", "\t\t    (!strncmp(param_buffer, \"--t\", 3) &&", "\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {", " \t\tif ((param.buffer[0] == '-' &&", " \t\t     param.buffer[1] != '-' &&", " \t\t     strchr(param.buffer, 't')) ||", " \t\t    (!strncmp(param.buffer, \"--t\", 3) &&", " \t\t     !strncmp(param.buffer, \"--table\", strlen(param.buffer)))) {", "  \t\t\txtables_error(PARAMETER_PROBLEM,", "  \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",", "  \t\t\t\t      line, xt_params->program_name);", "  \t\t}", "  ", "\t\tadd_argv(param_buffer, 0);", "\t\tparam_len = 0;", " \t\tadd_argv(param.buffer, 0);", " \t\tparam.len = 0;", "  \t}"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": ["  int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)", "  {", "\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,", " \treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?", " \t  jpc_tsfb_synthesize2(tsfb,", "  \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),", "  \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),", "  \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["static int php_mb_parse_encoding_list(const char *value, int value_length,", "mbfl_encoding ***return_list,", "int *return_size, int persistent) {", "int n, l, size, bauto, ret = 1;", "char *p, *p1, *p2, *endp, *tmpstr;", "mbfl_encoding *encoding;", "mbfl_no_encoding *src;", "mbfl_encoding **entry, **list;", "", "list = nullptr;", "if (value == nullptr || value_length <= 0) {", "if (return_list) {", "*return_list = nullptr;", "}", "if (return_size) {", "*return_size = 0;", "}", "return 0;", "} else {", "mbfl_no_encoding *identify_list;", "int identify_list_size;", "", "identify_list = MBSTRG(default_detect_order_list);", "identify_list_size = MBSTRG(default_detect_order_list_size);", "", "", "if (value[0]=='\"' && value[value_length-1]=='\"' && value_length>2) {", "tmpstr = (char *)strndup(value+1, value_length-2);", "value_length -= 2;", "}", "else", "tmpstr = (char *)strndup(value, value_length);", "if (tmpstr == nullptr) {", "return 0;", "}", "", "endp = tmpstr + value_length;", "n = 1;", "p1 = tmpstr;", "while ((p2 = (char*)string_memnstr(p1, \",\", 1, endp)) != nullptr) {", "p1 = p2 + 1;", "n++;", "}", "size = n + identify_list_size;", "", "list = (mbfl_encoding **)calloc(size, sizeof(mbfl_encoding*));", "if (list != nullptr) {", "entry = list;", "n = 0;", "bauto = 0;", "p1 = tmpstr;", "do {", "p2 = p = (char*)string_memnstr(p1, \",\", 1, endp);", "if (p == nullptr) {", "p = endp;", "}", "*p = '\\0';", "", "while (p1 < p && (*p1 == ' ' || *p1 == '\\t')) {", "p1++;", "}", "p--;", "while (p > p1 && (*p == ' ' || *p == '\\t')) {", "*p = '\\0';", "p--;", "}", "", "if (strcasecmp(p1, \"auto\") == 0) {", "if (!bauto) {", "bauto = 1;", "l = identify_list_size;", "src = identify_list;", "for (int i = 0; i < l; i++) {", "*entry++ = (mbfl_encoding*) mbfl_no2encoding(*src++);", "n++;", "}", "}", "} else {", "encoding = (mbfl_encoding*) mbfl_name2encoding(p1);", "if (encoding != nullptr) {", "*entry++ = encoding;", "n++;", "} else {", "ret = 0;", "}", "}", "p1 = p2 + 1;", "} while (n < size && p2 != nullptr);", "if (n > 0) {", "if (return_list) {", "*return_list = list;", "} else {", "free(list);", "}", "} else {", "free(list);", "if (return_list) {", "*return_list = nullptr;", "}", "ret = 0;", "}", "if (return_size) {", "*return_size = n;", "}", "} else {", "if (return_list) {", "*return_list = nullptr;", "}", "if (return_size) {", "*return_size = 0;", "}", "ret = 0;", "}", "free(tmpstr);", "}", "", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" int exfat_mount(struct exfat* ef, const char* spec, const char* options)", " {", " \tint rc;", " \tenum exfat_mode mode;", " ", " \texfat_tzset();", " \tmemset(ef, 0, sizeof(struct exfat));", " ", " \tparse_options(ef, options);", " ", " \tif (match_option(options, \"ro\"))", " \t\tmode = EXFAT_MODE_RO;", " \telse if (match_option(options, \"ro_fallback\"))", " \t\tmode = EXFAT_MODE_ANY;", " \telse", " \t\tmode = EXFAT_MODE_RW;", " \tef->dev = exfat_open(spec, mode);", " \tif (ef->dev == NULL)", " \t\treturn -EIO;", " \tif (exfat_get_mode(ef->dev) == EXFAT_MODE_RO)", " \t{", " \t\tif (mode == EXFAT_MODE_ANY)", " \t\t\tef->ro = -1;", " \t\telse", " \t\t\tef->ro = 1;", " \t}", " ", " \tef->sb = malloc(sizeof(struct exfat_super_block));", " \tif (ef->sb == NULL)", " \t{", " \t\texfat_close(ef->dev);", " \t\texfat_error(\"failed to allocate memory for the super block\");", " \t\treturn -ENOMEM;", " \t}", " \tmemset(ef->sb, 0, sizeof(struct exfat_super_block));", " ", " \tif (exfat_pread(ef->dev, ef->sb, sizeof(struct exfat_super_block), 0) < 0)", " \t{", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", " \t\texfat_error(\"failed to read boot sector\");", " \t\treturn -EIO;", " \t}", " \tif (memcmp(ef->sb->oem_name, \"EXFAT   \", 8) != 0)", " \t{", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", "  \t\texfat_error(\"exFAT file system is not found\");", "  \t\treturn -EIO;", "  \t}", " \t ", " \tif (ef->sb->sector_bits < 9)", " \t{", " \t\texfat_close(ef->dev);", " \t\texfat_error(\"too small sector size: 2^%hhd\", ef->sb->sector_bits);", " \t\tfree(ef->sb);", " \t\treturn -EIO;", " \t}", " \t ", " \tif ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)", " \t{", " \t\texfat_close(ef->dev);", " \t\texfat_error(\"too big cluster size: 2^(%hhd+%hhd)\",", " \t\t\t\tef->sb->sector_bits, ef->sb->spc_bits);", " \t\tfree(ef->sb);", " \t\treturn -EIO;", " \t}", "  \tef->zero_cluster = malloc(CLUSTER_SIZE(*ef->sb));", "  \tif (ef->zero_cluster == NULL)", "  \t{", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", " \t\texfat_error(\"failed to allocate zero sector\");", " \t\treturn -ENOMEM;", " \t}", " \t ", " \tif (!verify_vbr_checksum(ef->dev, ef->zero_cluster, SECTOR_SIZE(*ef->sb)))", " \t{", " \t\tfree(ef->zero_cluster);", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", " \t\treturn -EIO;", " \t}", " \tmemset(ef->zero_cluster, 0, CLUSTER_SIZE(*ef->sb));", " \tif (ef->sb->version.major != 1 || ef->sb->version.minor != 0)", " \t{", " \t\tfree(ef->zero_cluster);", " \t\texfat_close(ef->dev);", " \t\texfat_error(\"unsupported exFAT version: %hhu.%hhu\",", " \t\t\t\tef->sb->version.major, ef->sb->version.minor);", " \t\tfree(ef->sb);", " \t\treturn -EIO;", " \t}", " \tif (ef->sb->fat_count != 1)", " \t{", " \t\tfree(ef->zero_cluster);", " \t\texfat_close(ef->dev);", " \t\texfat_error(\"unsupported FAT count: %hhu\", ef->sb->fat_count);", "  \t\tfree(ef->sb);", "  \t\treturn -EIO;", "  \t}", "\t ", "\tif ((int) ef->sb->sector_bits + (int) ef->sb->spc_bits > 25)", "\t{", "\t\tfree(ef->zero_cluster);", "\t\texfat_close(ef->dev);", "\t\texfat_error(\"too big cluster size: 2^%d\",", "\t\t\t\t(int) ef->sb->sector_bits + (int) ef->sb->spc_bits);", "\t\tfree(ef->sb);", "\t\treturn -EIO;", "\t}", "  \tif (le64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb) >", "  \t\t\texfat_get_size(ef->dev))", "  \t{", " \t\t ", " \t\texfat_warn(\"file system is larger than underlying device: \"", " \t\t\t\t\"%\"PRIu64\" > %\"PRIu64,", " \t\t\t\tle64_to_cpu(ef->sb->sector_count) * SECTOR_SIZE(*ef->sb),", " \t\t\t\texfat_get_size(ef->dev));", " \t}", " ", " \tef->root = malloc(sizeof(struct exfat_node));", " \tif (ef->root == NULL)", " \t{", " \t\tfree(ef->zero_cluster);", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", " \t\texfat_error(\"failed to allocate root node\");", " \t\treturn -ENOMEM;", " \t}", " \tmemset(ef->root, 0, sizeof(struct exfat_node));", " \tef->root->flags = EXFAT_ATTRIB_DIR;", " \tef->root->start_cluster = le32_to_cpu(ef->sb->rootdir_cluster);", " \tef->root->fptr_cluster = ef->root->start_cluster;", " \tef->root->name[0] = cpu_to_le16('\\0');", " \tef->root->size = rootdir_size(ef);", " \tif (ef->root->size == 0)", " \t{", " \t\tfree(ef->root);", " \t\tfree(ef->zero_cluster);", " \t\texfat_close(ef->dev);", " \t\tfree(ef->sb);", " \t\treturn -EIO;", " \t}", " \t ", " \tef->root->mtime = 0;", " \tef->root->atime = 0;", " \t ", " \texfat_get_node(ef->root);", " ", " \trc = exfat_cache_directory(ef, ef->root);", " \tif (rc != 0)", " \t\tgoto error;", " \tif (ef->upcase == NULL)", " \t{", " \t\texfat_error(\"upcase table is not found\");", " \t\tgoto error;", " \t}", " \tif (ef->cmap.chunk == NULL)", " \t{", " \t\texfat_error(\"clusters bitmap is not found\");", " \t\tgoto error;", " \t}", " ", " \tif (prepare_super_block(ef) != 0)", " \t\tgoto error;", " ", " \treturn 0;", " ", " error:", " \texfat_put_node(ef, ef->root);", " \texfat_reset_cache(ef);", " \tfree(ef->root);", " \tfree(ef->zero_cluster);", " \texfat_close(ef->dev);", " \tfree(ef->sb);", " \treturn -EIO;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char **argv) {", "  int frame_cnt = 0;", "  FILE *outfile = NULL;", "  vpx_codec_ctx_t codec;", "  VpxVideoReader *reader = NULL;", "  const VpxVideoInfo *info = NULL;", "  const VpxInterface *decoder = NULL;", " ", "   exec_name = argv[0];", " ", "  if (argc != 3)", "     die(\"Invalid number of arguments.\");", " ", "   reader = vpx_video_reader_open(argv[1]);", "  if (!reader)", "     die(\"Failed to open %s for reading.\", argv[1]);", " ", "  if (!(outfile = fopen(argv[2], \"wb\")))", "     die(\"Failed to open %s for writing.\", argv[2]);", " ", "   info = vpx_video_reader_get_info(reader);", " ", "   decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);", " ", "    if (!decoder)", "      die(\"Unknown input codec.\");", "  ", "  printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->interface()));", "   printf(\"Using %s\\n\", vpx_codec_iface_name(decoder->codec_interface()));", "  ", "  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))", "   if (vpx_codec_dec_init(&codec, decoder->codec_interface(), NULL, 0))", "      die_codec(&codec, \"Failed to initialize decoder\");", "  ", "    while (vpx_video_reader_read_frame(reader)) {", "  vpx_codec_iter_t iter = NULL;", "  vpx_image_t *img = NULL;", "  size_t frame_size = 0;", "  const unsigned char *frame = vpx_video_reader_get_frame(reader,", "  &frame_size);", "  if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))", "       die_codec(&codec, \"Failed to decode frame\");", " ", "  while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {", "  unsigned char digest[16];", " ", "       get_image_md5(img, digest);", "       print_md5(outfile, digest);", "       fprintf(outfile, \"  img-%dx%d-%04d.i420\\n\",", "               img->d_w, img->d_h, ++frame_cnt);", "  }", "  }", " ", "   printf(\"Processed %d frames.\\n\", frame_cnt);", "  if (vpx_codec_destroy(&codec))", "     die_codec(&codec, \"Failed to destroy codec.\");", " ", "   vpx_video_reader_close(reader);", " ", "   fclose(outfile);", "  return EXIT_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,", "const Tensor& in, Tensor* out) {", "", "const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);", "auto device = ctx->eigen_device<CPUDevice>();", "auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();", "const auto input_dims = input.dimensions();", "", "", "Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;", "input_slice_sizes[0] = input_dims[0];", "TensorShape temp_shape{input_dims[0]};", "for (int i = 1; i <= FFTRank; ++i) {", "input_slice_sizes[i] = fft_shape[i - 1];", "temp_shape.AddDim(fft_shape[i - 1]);", "}", "", "auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();", "const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;", "", "", "Tensor temp;", "OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),", "temp_shape, &temp));", "auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();", "full_fft.device(device) =", "input.slice(zero_start_indices, input_slice_sizes)", ".template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);", "", "", "output.device(device) =", "full_fft.slice(zero_start_indices, output.dimensions());", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {", "ut64 offset = 6;", "RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);", "if (attr) {", "attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;", "attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);", "offset += 2;", "attr->size = offset;", "}", "", "return attr;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)", "{", "struct snd_msnd *chip = dev_id;", "void *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;", "", "", "", "", "", "while (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {", "u16 wTmp;", "", "snd_msnd_eval_dsp_msg(chip,", "readw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));", "", "wTmp = readw(chip->DSPQ + JQS_wHead) + 1;", "if (wTmp > readw(chip->DSPQ + JQS_wSize))", "writew(0, chip->DSPQ + JQS_wHead);", "else", "writew(wTmp, chip->DSPQ + JQS_wHead);", "}", "", "inb(chip->io + HP_RXL);", "return IRQ_HANDLED;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0]}
{"tokens": [" static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)", " {", "     cJSON *current_element = NULL;", " ", "     if ((object == NULL) || (name == NULL))", "     {", "         return NULL;", "     }", " ", "      current_element = object->child;", "      if (case_sensitive)", "      {", "        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))", "         while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))", "          {", "              current_element = current_element->next;", "          }", "     }", "     else", "     {", "         while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))", "         {", "             current_element = current_element->next;", "          }", "      }", "  ", "     if ((current_element == NULL) || (current_element->string == NULL)) {", "         return NULL;", "     }", " ", "      return current_element;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static void usb_xhci_exit(PCIDevice *dev)", " {", "     int i;", "     XHCIState *xhci = XHCI(dev);", " ", "     trace_usb_xhci_exit();", " ", "     for (i = 0; i < xhci->numslots; i++) {", "         xhci_disable_slot(xhci, i + 1);", "     }", " ", "     if (xhci->mfwrap_timer) {", "         timer_del(xhci->mfwrap_timer);", "         timer_free(xhci->mfwrap_timer);", "         xhci->mfwrap_timer = NULL;", "     }", " ", "     memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);", "     memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);", "     memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);", "     memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);", " ", "     for (i = 0; i < xhci->numports; i++) {", "         XHCIPort *port = &xhci->ports[i];", "         memory_region_del_subregion(&xhci->mem, &port->mem);", "     }", " ", "       ", "      if (dev->msix_table && dev->msix_pba", "          && dev->msix_entry_used) {", "        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);", "        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);", "         msix_uninit(dev, &xhci->mem, &xhci->mem);", "      }", "  ", "      usb_bus_release(&xhci->bus);", "     usb_bus_release(&xhci->bus);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "const Tensor& start_in = context->input(0);", "const Tensor& limit_in = context->input(1);", "const Tensor& delta_in = context->input(2);", "", "OP_REQUIRES(context,", "TensorShapeUtils::IsScalar(start_in.shape()) ||", "(TensorShapeUtils::IsVector(start_in.shape()) &&", "start_in.shape().dim_size(0) == 1),", "errors::InvalidArgument(\"start must be a scalar, not shape \",", "start_in.shape().DebugString()));", "OP_REQUIRES(context,", "TensorShapeUtils::IsScalar(limit_in.shape()) ||", "(TensorShapeUtils::IsVector(limit_in.shape()) &&", "limit_in.shape().dim_size(0) == 1),", "errors::InvalidArgument(\"limit must be a scalar, not shape \",", "limit_in.shape().DebugString()));", "OP_REQUIRES(context,", "TensorShapeUtils::IsScalar(delta_in.shape()) ||", "(TensorShapeUtils::IsVector(delta_in.shape()) &&", "delta_in.shape().dim_size(0) == 1),", "errors::InvalidArgument(\"delta must be a scalar, not shape \",", "delta_in.shape().DebugString()));", "const T start = start_in.scalar<T>()();", "const T limit = limit_in.scalar<T>()();", "const T delta = delta_in.scalar<T>()();", "OP_REQUIRES(context, delta != 0,", "errors::InvalidArgument(\"Requires delta != 0: \", delta));", "if (delta > 0) {", "OP_REQUIRES(", "context, start <= limit,", "errors::InvalidArgument(", "\"Requires start <= limit when delta > 0: \", start, \"/\", limit));", "} else {", "OP_REQUIRES(", "context, start >= limit,", "errors::InvalidArgument(", "\"Requires start >= limit when delta < 0: \", start, \"/\", limit));", "}", "int64_t size = (std::is_integral<T>::value", "? ((std::abs(limit - start) + std::abs(delta) - 1) /", "std::abs(delta))", ": std::ceil(std::abs((limit - start) / delta)));", "Tensor* out = nullptr;", "OP_REQUIRES_OK(context,", "context->allocate_output(0, TensorShape({size}), &out));", "auto flat = out->flat<T>();", "T val = start;", "for (int64_t i = 0; i < size; ++i) {", "flat(i) = T(val);", "val += delta;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> methodReturningSequenceCallback(const v8::Arguments& args)", "  {", "      INC_STATS(\"DOM.TestObj.methodReturningSequence\");", "      if (args.Length() < 1)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "      TestObj* imp = V8TestObj::toNative(args.Holder());", "      EXCEPTION_BLOCK(int, intArg, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));", "      return v8Array(imp->methodReturningSequence(intArg), args.GetIsolate());", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) {", " \tconst char *section_name = \"\";", " \tconst char *link_section_name = \"\";", " \tchar *end = NULL;", " \tElf_(Shdr) *link_shdr = NULL;", " \tut8 dfs[sizeof (Elf_(Verdef))] = {0};", " \tSdb *sdb;", " \tint cnt, i;", " \tif (shdr->sh_link > bin->ehdr.e_shnum) {", "  \t\treturn false;", "  \t}", "  \tlink_shdr = &bin->shdr[shdr->sh_link];", "\tif (shdr->sh_size < 1) {", " \tif (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {", "  \t\treturn false;", "  \t}", "  \tElf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char));", " \tif (!defs) {", " \t\treturn false;", " \t}", " \tif (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) {", " \t\tsection_name = &bin->shstrtab[shdr->sh_name];", " \t}", " \tif (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) {", " \t\tlink_section_name = &bin->shstrtab[link_shdr->sh_name];", " \t}", " \tif (!defs) {", " \t\tbprintf (\"Warning: Cannot allocate memory (Check Elf_(Verdef))\\n\");", " \t\treturn NULL;", " \t}", " \tsdb = sdb_new0 ();", " \tend = (char *)defs + shdr->sh_size;", " \tsdb_set (sdb, \"section_name\", section_name, 0);", " \tsdb_num_set (sdb, \"entries\", shdr->sh_info, 0);", " \tsdb_num_set (sdb, \"addr\", shdr->sh_addr, 0);", " \tsdb_num_set (sdb, \"offset\", shdr->sh_offset, 0);", " \tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);", " \tsdb_set (sdb, \"link_section_name\", link_section_name, 0);", " ", " \tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {", " \t\tSdb *sdb_verdef = sdb_new0 ();", " \t\tchar *vstart = ((char*)defs) + i;", " \t\tchar key[32] = {0};", " \t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;", " \t\tElf_(Verdaux) aux = {0};", " \t\tint j = 0;", " \t\tint isum = 0;", " ", " \t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));", " \t\tverdef->vd_version = READ16 (dfs, j)", " \t\tverdef->vd_flags = READ16 (dfs, j)", " \t\tverdef->vd_ndx = READ16 (dfs, j)", " \t\tverdef->vd_cnt = READ16 (dfs, j)", " \t\tverdef->vd_hash = READ32 (dfs, j)", " \t\tverdef->vd_aux = READ32 (dfs, j)", " \t\tverdef->vd_next = READ32 (dfs, j)", " \t\tint vdaux = verdef->vd_aux;", " \t\tif (vdaux < 1) {", " \t\t\tsdb_free (sdb_verdef);", " \t\t\tgoto out_error;", " \t\t}", " \t\tvstart += vdaux;", " \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {", " \t\t\tsdb_free (sdb_verdef);", " \t\t\tgoto out_error;", " \t\t}", " ", " \t\tj = 0;", " \t\taux.vda_name = READ32 (vstart, j)", " \t\taux.vda_next = READ32 (vstart, j)", " ", " \t\tisum = i + verdef->vd_aux;", " \t\tif (aux.vda_name > bin->dynstr_size) {", " \t\t\tsdb_free (sdb_verdef);", " \t\t\tgoto out_error;", " \t\t}", " ", " \t\tsdb_num_set (sdb_verdef, \"idx\", i, 0);", " \t\tsdb_num_set (sdb_verdef, \"vd_version\", verdef->vd_version, 0);", " \t\tsdb_num_set (sdb_verdef, \"vd_ndx\", verdef->vd_ndx, 0);", " \t\tsdb_num_set (sdb_verdef, \"vd_cnt\", verdef->vd_cnt, 0);", " \t\tsdb_set (sdb_verdef, \"vda_name\", &bin->dynstr[aux.vda_name], 0);", " \t\tsdb_set (sdb_verdef, \"flags\", get_ver_flags (verdef->vd_flags), 0);", " ", " \t\tfor (j = 1; j < verdef->vd_cnt; ++j) {", " \t\t\tint k;", " \t\t\tSdb *sdb_parent = sdb_new0 ();", " \t\t\tisum += aux.vda_next;", " \t\t\tvstart += aux.vda_next;", " \t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {", " \t\t\t\tsdb_free (sdb_verdef);", " \t\t\t\tsdb_free (sdb_parent);", " \t\t\t\tgoto out_error;", " \t\t\t}", " \t\t\tk = 0;", " \t\t\taux.vda_name = READ32 (vstart, k)", " \t\t\taux.vda_next = READ32 (vstart, k)", " \t\t\tif (aux.vda_name > bin->dynstr_size) {", " \t\t\t\tsdb_free (sdb_verdef);", " \t\t\t\tsdb_free (sdb_parent);", " \t\t\t\tgoto out_error;", " \t\t\t}", " \t\t\tsdb_num_set (sdb_parent, \"idx\", isum, 0);", " \t\t\tsdb_num_set (sdb_parent, \"parent\", j, 0);", " \t\t\tsdb_set (sdb_parent, \"vda_name\", &bin->dynstr[aux.vda_name], 0);", " \t\t\tsnprintf (key, sizeof (key), \"parent%d\", j - 1);", " \t\t\tsdb_ns_set (sdb_verdef, key, sdb_parent);", " \t\t}", " ", " \t\tsnprintf (key, sizeof (key), \"verdef%d\", cnt);", " \t\tsdb_ns_set (sdb, key, sdb_verdef);", " \t\tif (!verdef->vd_next) {", " \t\t\tsdb_free (sdb_verdef);", " \t\t\tgoto out_error;", " \t\t}", " \t\tif ((st32)verdef->vd_next < 1) {", " \t\t\teprintf (\"Warning: Invalid vd_next in the ELF version\\n\");", " \t\t\tbreak;", " \t\t}", " \t\ti += verdef->vd_next;", " \t}", " \tfree (defs);", " \treturn sdb;", " out_error:", " \tfree (defs);", " \tsdb_free (sdb);", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void HTMLFormElement::scheduleFormSubmission(FormSubmission* submission) {", "   DCHECK(submission->method() == FormSubmission::PostMethod ||", "          submission->method() == FormSubmission::GetMethod);", "   DCHECK(submission->data());", "   DCHECK(submission->form());", "   if (submission->action().isEmpty())", "     return;", "   if (document().isSandboxed(SandboxForms)) {", "     document().addConsoleMessage(ConsoleMessage::create(", "         SecurityMessageSource, ErrorMessageLevel,", "         \"Blocked form submission to '\" + submission->action().elidedString() +", "             \"' because the form's frame is sandboxed and the 'allow-forms' \"", "             \"permission is not set.\"));", "      return;", "    }", "  ", "   if (!document().contentSecurityPolicy()->allowFormAction(", "           submission->action())) {", "     return;", "   }", " ", "    if (protocolIsJavaScript(submission->action())) {", "    if (!document().contentSecurityPolicy()->allowFormAction(", "            submission->action()))", "      return;", "      document().frame()->script().executeScriptIfJavaScriptURL(", "          submission->action(), this);", "      return;", "   }", " ", "   Frame* targetFrame = document().frame()->findFrameForNavigation(", "       submission->target(), *document().frame());", "   if (!targetFrame) {", "     if (!LocalDOMWindow::allowPopUp(*document().frame()) &&", "         !UserGestureIndicator::utilizeUserGesture())", "       return;", "     targetFrame = document().frame();", "   } else {", "     submission->clearTarget();", "   }", "   if (!targetFrame->host())", "     return;", " ", "   UseCounter::count(document(), UseCounter::FormsSubmitted);", "   if (MixedContentChecker::isMixedFormAction(document().frame(),", "                                              submission->action()))", "     UseCounter::count(document().frame(),", "                       UseCounter::MixedContentFormsSubmitted);", " ", "   if (targetFrame->isLocalFrame()) {", "     toLocalFrame(targetFrame)", "         ->navigationScheduler()", "         .scheduleFormSubmission(&document(), submission);", "   } else {", "     FrameLoadRequest frameLoadRequest =", "         submission->createFrameLoadRequest(&document());", "     toRemoteFrame(targetFrame)->navigate(frameLoadRequest);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void FFmpegVideoDecodeEngine::Initialize(", "     MessageLoop* message_loop,", "     VideoDecodeEngine::EventHandler* event_handler,", "     VideoDecodeContext* context,", "     const VideoDecoderConfig& config) {", "   static const int kDecodeThreads = 2;", "   static const int kMaxDecodeThreads = 16;", " ", "   codec_context_ = avcodec_alloc_context();", " ", "   codec_context_->pix_fmt = PIX_FMT_YUV420P;", "   codec_context_->codec_type = AVMEDIA_TYPE_VIDEO;", "   codec_context_->codec_id = VideoCodecToCodecID(config.codec());", "   codec_context_->coded_width = config.width();", "   codec_context_->coded_height = config.height();", " ", "   frame_rate_numerator_ = config.frame_rate_numerator();", "   frame_rate_denominator_ = config.frame_rate_denominator();", "  ", "    if (config.extra_data() != NULL) {", "      codec_context_->extradata_size = config.extra_data_size();", "    codec_context_->extradata =", "        reinterpret_cast<uint8_t*>(av_malloc(config.extra_data_size()));", "     codec_context_->extradata = reinterpret_cast<uint8_t*>(", "         av_malloc(config.extra_data_size() + FF_INPUT_BUFFER_PADDING_SIZE));", "      memcpy(codec_context_->extradata, config.extra_data(),", "             config.extra_data_size());", "     memset(codec_context_->extradata + config.extra_data_size(), '\\0',", "            FF_INPUT_BUFFER_PADDING_SIZE);", "    }", "  ", "   codec_context_->error_concealment = FF_EC_GUESS_MVS | FF_EC_DEBLOCK;", "   codec_context_->error_recognition = FF_ER_CAREFUL;", " ", "   AVCodec* codec = avcodec_find_decoder(codec_context_->codec_id);", " ", "   int decode_threads = (codec_context_->codec_id == CODEC_ID_THEORA) ?", "       1 : kDecodeThreads;", " ", "   const CommandLine* cmd_line = CommandLine::ForCurrentProcess();", "   std::string threads(cmd_line->GetSwitchValueASCII(switches::kVideoThreads));", "   if ((!threads.empty() &&", "       !base::StringToInt(threads, &decode_threads)) ||", "       decode_threads < 0 || decode_threads > kMaxDecodeThreads) {", "     decode_threads = kDecodeThreads;", "   }", " ", "   av_frame_.reset(avcodec_alloc_frame());", "   VideoCodecInfo info;", "   info.success = false;", "   info.provides_buffers = true;", "   info.stream_info.surface_type = VideoFrame::TYPE_SYSTEM_MEMORY;", "   info.stream_info.surface_format = GetSurfaceFormat();", "   info.stream_info.surface_width = config.surface_width();", "   info.stream_info.surface_height = config.surface_height();", " ", "   bool buffer_allocated = true;", "   frame_queue_available_.clear();", " ", "   for (size_t i = 0; i < Limits::kMaxVideoFrames; ++i) {", "     scoped_refptr<VideoFrame> video_frame;", "     VideoFrame::CreateFrame(VideoFrame::YV12,", "                             config.width(),", "                             config.height(),", "                             kNoTimestamp,", "                             kNoTimestamp,", "                             &video_frame);", "     if (!video_frame.get()) {", "       buffer_allocated = false;", "       break;", "     }", "     frame_queue_available_.push_back(video_frame);", "   }", " ", "   if (codec &&", "       avcodec_thread_init(codec_context_, decode_threads) >= 0 &&", "       avcodec_open(codec_context_, codec) >= 0 &&", "       av_frame_.get() &&", "       buffer_allocated) {", "     info.success = true;", "   }", "   event_handler_ = event_handler;", "   event_handler_->OnInitializeComplete(info);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {", "TFLITE_DCHECK(node->user_data != nullptr);", "", "OpData* data = static_cast<OpData*>(node->user_data);", "", "const TfLiteTensor* input = GetInput(context, node, kInputTensor);", "data->input_zero_point = input->params.zero_point;", "return CalculateArithmeticOpData(context, node, data);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static void spl_filesystem_object_free_storage(void *object TSRMLS_DC)  ", " {", " \tspl_filesystem_object *intern = (spl_filesystem_object*)object;", " ", "  \tif (intern->oth_handler && intern->oth_handler->dtor) {", "  \t\tintern->oth_handler->dtor(intern TSRMLS_CC);", "  \t}", " ", "  \tzend_object_std_dtor(&intern->std TSRMLS_CC);", " ", "  \tif (intern->_path) {", "  \t\tefree(intern->_path);", "  \t}", " \tif (intern->file_name) {", " \t\tefree(intern->file_name);", " \t}", " \tswitch(intern->type) {", " \tcase SPL_FS_INFO:", " \t\tbreak;", " \tcase SPL_FS_DIR:", " \t\tif (intern->u.dir.dirp) {", " \t\t\tphp_stream_close(intern->u.dir.dirp);", " \t\t\tintern->u.dir.dirp = NULL;", "  \t\t}", "  \t\tif (intern->u.dir.sub_path) {", "  \t\t\tefree(intern->u.dir.sub_path);", "\t\t}\t\t", " \t\t}", "  \t\tbreak;", "  \tcase SPL_FS_FILE:", "  \t\tif (intern->u.file.stream) {", " \t\t\tif (intern->u.file.zcontext) {", "  ", " \t\t\t}", " \t\t\tif (!intern->u.file.stream->is_persistent) {", " \t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);", " \t\t\t} else {", " \t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);", " \t\t\t}", " \t\t\tif (intern->u.file.open_mode) {", " \t\t\t\tefree(intern->u.file.open_mode);", " \t\t\t}", " \t\t\tif (intern->orig_path) {", " \t\t\t\tefree(intern->orig_path);", " \t\t\t}", " \t\t}", " \t\tspl_filesystem_file_free_line(intern TSRMLS_CC);", " \t\tbreak;", " \t}", " ", " \t{", " \t\tzend_object_iterator *iterator;", " \t\titerator = (zend_object_iterator*)", " \t\t\t\tspl_filesystem_object_to_iterator(intern);", " \t\tif (iterator->data != NULL) {", " \t\t\titerator->data = NULL;", " \t\t\titerator->funcs->dtor(iterator TSRMLS_CC);", " \t\t}", " \t}", " \tefree(object);", "  }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)", " cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)", "  {", "\tstruct list_head *tmp;", "  \tstruct cifsSesInfo *ses;", "  ", "  \twrite_lock(&cifs_tcp_ses_lock);", "\tlist_for_each(tmp, &server->smb_ses_list) {", "\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);", "\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))", "\t\t\tcontinue;", " \tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {", " \t\tswitch (server->secType) {", " \t\tcase Kerberos:", " \t\t\tif (vol->linux_uid != ses->linux_uid)", " \t\t\t\tcontinue;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\t ", " \t\t\tif (strncmp(ses->userName, vol->username,", " \t\t\t\t    MAX_USERNAME_SIZE))", " \t\t\t\tcontinue;", " \t\t\tif (strlen(vol->username) != 0 &&", " \t\t\t    strncmp(ses->password, vol->password,", " \t\t\t\t    MAX_PASSWORD_SIZE))", " \t\t\t\tcontinue;", " \t\t}", "  \t\t++ses->ses_count;", "  \t\twrite_unlock(&cifs_tcp_ses_lock);", "  \t\treturn ses;", " \t}", " \twrite_unlock(&cifs_tcp_ses_lock);", " \treturn NULL;", " }"], "ner_tags": [0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,", "                      mbedtls_x509_crt *trust_ca,", "                      mbedtls_x509_crl *ca_crl,", "                      const mbedtls_x509_crt_profile *profile,", "                      const char *cn, uint32_t *flags,", "                      int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),", "                      void *p_vrfy )", " {", "     size_t cn_len;", "     int ret;", "     int pathlen = 0, selfsigned = 0;", "     mbedtls_x509_crt *parent;", "     mbedtls_x509_name *name;", "      mbedtls_x509_sequence *cur = NULL;", "      mbedtls_pk_type_t pk_type;", "  ", "    if( profile == NULL )", "        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );", "      *flags = 0;", "  ", "     if( profile == NULL )", "     {", "         ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;", "         goto exit;", "     }", " ", "      if( cn != NULL )", "      {", "          name = &crt->subject;", "         cn_len = strlen( cn );", " ", "         if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )", "         {", "             cur = &crt->subject_alt_names;", " ", "             while( cur != NULL )", "             {", "                 if( cur->buf.len == cn_len &&", "                     x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )", "                     break;", " ", "                 if( cur->buf.len > 2 &&", "                     memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&", "                     x509_check_wildcard( cn, &cur->buf ) == 0 )", "                 {", "                     break;", "                 }", " ", "                 cur = cur->next;", "             }", " ", "             if( cur == NULL )", "                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;", "         }", "         else", "         {", "             while( name != NULL )", "             {", "                 if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )", "                 {", "                     if( name->val.len == cn_len &&", "                         x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )", "                         break;", " ", "                     if( name->val.len > 2 &&", "                         memcmp( name->val.p, \"*.\", 2 ) == 0 &&", "                         x509_check_wildcard( cn, &name->val ) == 0 )", "                         break;", "                 }", " ", "                 name = name->next;", "             }", " ", "             if( name == NULL )", "                 *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;", "         }", "     }", " ", "      ", "     pk_type = mbedtls_pk_get_type( &crt->pk );", " ", "     if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )", "         *flags |= MBEDTLS_X509_BADCERT_BAD_PK;", " ", "     if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )", "         *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;", " ", "      ", "     for( parent = trust_ca; parent != NULL; parent = parent->next )", "     {", "         if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )", "             break;", "     }", " ", "     if( parent != NULL )", "     {", "          ret = x509_crt_verify_top( crt, parent, ca_crl, profile,", "                                     pathlen, selfsigned, flags, f_vrfy, p_vrfy );", "          if( ret != 0 )", "            return( ret );", "             goto exit;", "      }", "      else", "      {", "          ", "         for( parent = crt->next; parent != NULL; parent = parent->next )", "             if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )", "                 break;", " ", "          ", "         if( parent != NULL )", "         {", "              ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,", "                                           pathlen, selfsigned, flags, f_vrfy, p_vrfy );", "              if( ret != 0 )", "                return( ret );", "                 goto exit;", "          }", "          else", "          {", "              ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,", "                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );", "              if( ret != 0 )", "                return( ret );", "                 goto exit;", "          }", "      }", "  ", " exit:", "     if( ret != 0 )", "     {", "         *flags = (uint32_t) -1;", "         return( ret );", "     }", " ", "      if( *flags != 0 )", "          return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );", "  ", "     return( 0 );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a,", " \t\tASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)", " \t{", " \tEVP_MD_CTX ctx;", " \tunsigned char *buf_in=NULL;", " \tint ret= -1,inl;", " ", " \tint mdnid, pknid;", " ", " \tif (!pkey)", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);", "  \t\treturn -1;", "  \t\t}", "  ", " \tif (signature->type == V_ASN1_BIT_STRING && signature->flags & 0x7)", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_VERIFY, ASN1_R_INVALID_BIT_STRING_BITS_LEFT);", " \t\treturn -1;", " \t\t}", " ", "  \tEVP_MD_CTX_init(&ctx);", "  ", "  \t ", " \tif (!OBJ_find_sigid_algs(OBJ_obj2nid(a->algorithm), &mdnid, &pknid))", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);", " \t\tgoto err;", " \t\t}", " \tif (mdnid == NID_undef)", " \t\t{", " \t\tif (!pkey->ameth || !pkey->ameth->item_verify)", " \t\t\t{", " \t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);", " \t\t\tgoto err;", " \t\t\t}", " \t\tret = pkey->ameth->item_verify(&ctx, it, asn, a,", " \t\t\t\t\t\t\tsignature, pkey);", " \t\t ", " \t\tif (ret != 2)", " \t\t\tgoto err;", " \t\tret = -1;", " \t\t}", " \telse", " \t\t{", " \t\tconst EVP_MD *type;", " \t\ttype=EVP_get_digestbynid(mdnid);", " \t\tif (type == NULL)", " \t\t\t{", " \t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);", " \t\t\tgoto err;", " \t\t\t}", " ", " \t\t ", " \t\tif (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)", " \t\t\t{", " \t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);", " \t\t\tgoto err;", " \t\t\t}", " ", " \t\tif (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))", " \t\t\t{", " \t\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);", " \t\t\tret=0;", " \t\t\tgoto err;", " \t\t\t}", " ", " \t\t}", " ", " \tinl = ASN1_item_i2d(asn, &buf_in, it);", " \t", " \tif (buf_in == NULL)", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);", " \t\tgoto err;", " \t\t}", " ", " \tret = EVP_DigestVerifyUpdate(&ctx,buf_in,inl);", " ", " \tOPENSSL_cleanse(buf_in,(unsigned int)inl);", " \tOPENSSL_free(buf_in);", " ", " \tif (!ret)", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);", " \t\tgoto err;", " \t\t}", " \tret = -1;", " ", " \tif (EVP_DigestVerifyFinal(&ctx,signature->data,", " \t\t\t(size_t)signature->length) <= 0)", " \t\t{", " \t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);", " \t\tret=0;", " \t\tgoto err;", " \t\t}", " \t ", " \t ", " \tret=1;", " err:", " \tEVP_MD_CTX_cleanup(&ctx);", " \treturn(ret);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)", " {", "  \tstruct sem_array *sma;", "  \tstruct sem_undo_list *ulp;", "  \tstruct sem_undo *un, *new;", "\tint nsems;", "\tint error;", " \tint nsems, error;", "  ", "  \terror = get_undo_list(&ulp);", "  \tif (error)", " \t\treturn ERR_PTR(error);", " ", " \trcu_read_lock();", " \tspin_lock(&ulp->lock);", " \tun = lookup_undo(ulp, semid);", " \tspin_unlock(&ulp->lock);", " \tif (likely(un!=NULL))", " \t\tgoto out;", " ", " \t ", " \t ", " \tsma = sem_obtain_object_check(ns, semid);", " \tif (IS_ERR(sma)) {", " \t\trcu_read_unlock();", " \t\treturn ERR_CAST(sma);", "  \t}", "  ", "  \tnsems = sma->sem_nsems;", "\tipc_rcu_getref(sma);", " \tif (!ipc_rcu_getref(sma)) {", " \t\trcu_read_unlock();", " \t\tun = ERR_PTR(-EIDRM);", " \t\tgoto out;", " \t}", "  \trcu_read_unlock();", "  ", "  \t ", " \tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);", " \tif (!new) {", " \t\tsem_putref(sma);", " \t\treturn ERR_PTR(-ENOMEM);", " \t}", " ", "  \t ", "  \tsem_lock_and_putref(sma);", "  \tif (sma->sem_perm.deleted) {", "\t\tsem_unlock(sma);", " \t\tsem_unlock(sma, -1);", "  \t\tkfree(new);", "  \t\tun = ERR_PTR(-EIDRM);", "  \t\tgoto out;", " \t}", " \tspin_lock(&ulp->lock);", " ", " \t ", " \tun = lookup_undo(ulp, semid);", " \tif (un) {", " \t\tkfree(new);", " \t\tgoto success;", " \t}", " \t ", " \tnew->semadj = (short *) &new[1];", " \tnew->ulp = ulp;", " \tnew->semid = semid;", " \tassert_spin_locked(&ulp->lock);", " \tlist_add_rcu(&new->list_proc, &ulp->list_proc);", " \tassert_spin_locked(&sma->sem_perm.lock);", " \tlist_add(&new->list_id, &sma->list_id);", " \tun = new;", " ", "  success:", "  \tspin_unlock(&ulp->lock);", "  \trcu_read_lock();", "\tsem_unlock(sma);", " \tsem_unlock(sma, -1);", "  out:", "  \treturn un;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" void HttpBridge::MakeAsynchronousPost() {", "   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));", "   base::AutoLock lock(fetch_state_lock_);", "   DCHECK(!fetch_state_.request_completed);", "    if (fetch_state_.aborted)", "      return;", "  ", "  fetch_state_.url_poster = new URLFetcher(url_for_request_,", "                                           URLFetcher::POST, this);", "   fetch_state_.url_poster = URLFetcher::Create(0, url_for_request_,", "                                                URLFetcher::POST, this);", "    fetch_state_.url_poster->set_request_context(context_getter_for_request_);", "    fetch_state_.url_poster->set_upload_data(content_type_, request_content_);", "    fetch_state_.url_poster->set_extra_request_headers(extra_headers_);", "   fetch_state_.url_poster->set_load_flags(net::LOAD_DO_NOT_SEND_COOKIES);", "   fetch_state_.url_poster->Start();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" TracingControllerImpl::TracingControllerImpl()", "     : delegate_(GetContentClient()->browser()->GetTracingDelegate()),", "       weak_ptr_factory_(this) {", "   DCHECK(!g_tracing_controller);", "   DCHECK_CURRENTLY_ON(BrowserThread::UI);", "   base::FileTracing::SetProvider(new FileTracingProviderImpl);", "   AddAgents();", "    base::trace_event::TraceLog::GetInstance()->AddAsyncEnabledStateObserver(", "        weak_ptr_factory_.GetWeakPtr());", "    g_tracing_controller = this;", " ", "    ", "    ", "   ConnectToServiceIfNeeded();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": [" void PrintWebViewHelper::OnPrintForPrintPreview(", "     const DictionaryValue& job_settings) {", "   DCHECK(is_preview_);", "   if (print_web_view_)", "     return;", " ", "   if (!render_view()->webview())", "     return;", "   WebFrame* main_frame = render_view()->webview()->mainFrame();", "   if (!main_frame)", "     return;", " ", "   WebDocument document = main_frame->document();", "   WebElement pdf_element = document.getElementById(\"pdf-viewer\");", "   if (pdf_element.isNull()) {", "     NOTREACHED();", "      return;", "    }", "  ", "  WebFrame* pdf_frame = pdf_element.document().frame();", "  scoped_ptr<PrepareFrameAndViewForPrint> prepare;", "  if (!InitPrintSettingsAndPrepareFrame(pdf_frame, &pdf_element, &prepare)) {", "    LOG(ERROR) << \"Failed to initialize print page settings\";", "    return;", "  }", "    if (!UpdatePrintSettings(job_settings, false)) {", "      LOG(ERROR) << \"UpdatePrintSettings failed\";", "      DidFinishPrinting(FAIL_PRINT);", "      return;", "    }", "  ", "   WebFrame* pdf_frame = pdf_element.document().frame();", "   scoped_ptr<PrepareFrameAndViewForPrint> prepare;", "   prepare.reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,", "                                                 pdf_frame, &pdf_element));", "   UpdatePrintableSizeInPrintParameters(pdf_frame, &pdf_element, prepare.get(),", "                                        &print_pages_params_->params);", " ", "    if (!RenderPagesForPrint(pdf_frame, &pdf_element, prepare.get())) {", "      LOG(ERROR) << \"RenderPagesForPrint failed\";", "     DidFinishPrinting(FAIL_PRINT);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void FolderHeaderView::ContentsChanged(views::Textfield* sender,", "                                        const base::string16& new_contents) {", "    if (!folder_item_)", "      return;", "  ", "   folder_name_view_->Update();", "    folder_item_->RemoveObserver(this);", "  std::string name = base::UTF16ToUTF8(folder_name_view_->text());", "  delegate_->SetItemName(folder_item_, name);", "    ", "   std::string name = base::UTF16ToUTF8(", "       folder_name_view_->text().substr(0, kMaxFolderNameChars));", "   if (name != folder_item_->name())", "     delegate_->SetItemName(folder_item_, name);", "    folder_item_->AddObserver(this);", "  ", "    Layout();", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,", " \t\tconst URI_TYPE(QueryList) * queryList,", " \t\tint maxChars, int * charsWritten, int * charsRequired,", " \t\tUriBool spaceToPlus, UriBool normalizeBreaks) {", " \tUriBool firstItem = URI_TRUE;", " \tint ampersandLen = 0;   ", " \tURI_CHAR * write = dest;", " ", " \t ", " \tif (dest == NULL) {", " \t\t*charsRequired = 0;", " \t} else {", " \t\tmaxChars--;", " \t}", " \t\t\t", " \twhile (queryList != NULL) {", " \t\tconst URI_CHAR * const key = queryList->key;", " \t\tconst URI_CHAR * const value = queryList->value;", " \t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);", " \t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);", " \t\tconst int keyRequiredChars = worstCase * keyLen;", " \t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);", " \t\tconst int valueRequiredChars = worstCase * valueLen;", " ", " \t\tif (dest == NULL) {", " \t\t\tif (firstItem == URI_TRUE) {", " \t\t\t\tampersandLen = 1;", " \t\t\t\tfirstItem = URI_FALSE;", " \t\t\t}", " ", " \t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)", " \t\t\t\t\t\t? 0", " \t\t\t\t\t\t: 1 + valueRequiredChars);", " \t\t} else {", " \t\t\tURI_CHAR * afterKey;", " ", " \t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {", " \t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;", " \t\t\t}", "  ", "  \t\t\t ", "  \t\t\tif (firstItem == URI_TRUE) {", " \t\t\t\tampersandLen = 1;", "  \t\t\t\tfirstItem = URI_FALSE;", "  \t\t\t} else {", "  \t\t\t\twrite[0] = _UT('&');", " \t\t\t\twrite++;", " \t\t\t}", " \t\t\tafterKey = URI_FUNC(EscapeEx)(key, key + keyLen,", " \t\t\t\t\twrite, spaceToPlus, normalizeBreaks);", " \t\t\twrite += (afterKey - write);", " ", " \t\t\tif (value != NULL) {", " \t\t\t\tURI_CHAR * afterValue;", " ", " \t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {", " \t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\twrite[0] = _UT('=');", " \t\t\t\twrite++;", " \t\t\t\tafterValue = URI_FUNC(EscapeEx)(value, value + valueLen,", " \t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);", " \t\t\t\twrite += (afterValue - write);", " \t\t\t}", " \t\t}", " ", " \t\tqueryList = queryList->next;", " \t}", " ", " \tif (dest != NULL) {", " \t\twrite[0] = _UT('\\0');", " \t\tif (charsWritten != NULL) {", " \t\t\t*charsWritten = (int)(write - dest) + 1;  ", " \t\t}", " \t}", " ", " \treturn URI_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int klsi_105_get_line_state(struct usb_serial_port *port,", " \t\t\t\t   unsigned long *line_state_p)", " {", " \tint rc;", " \tu8 *status_buf;", " \t__u16 status;", " ", " \tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");", " ", " \tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);", " \tif (!status_buf)", " \t\treturn -ENOMEM;", " ", " \tstatus_buf[0] = 0xff;", " \tstatus_buf[1] = 0xff;", " \trc = usb_control_msg(port->serial->dev,", " \t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),", " \t\t\t     KL5KUSB105A_SIO_POLL,", " \t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,", " \t\t\t     0,  ", " \t\t\t     0,  ", "  \t\t\t     status_buf, KLSI_STATUSBUF_LEN,", "  \t\t\t     10000", "  \t\t\t     );", "\tif (rc < 0)", "\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",", "\t\t\trc);", "\telse {", " \tif (rc != KLSI_STATUSBUF_LEN) {", " \t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);", " \t\tif (rc >= 0)", " \t\t\trc = -EIO;", " \t} else {", "  \t\tstatus = get_unaligned_le16(status_buf);", "  ", "  \t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",", " \t\t\t status_buf[0], status_buf[1]);", " ", " \t\t*line_state_p = klsi_105_status2linestate(status);", " \t}", " ", " \tkfree(status_buf);", " \treturn rc;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int oidc_handle_session_management_iframe_rp(request_rec *r, oidc_cfg *c,", "oidc_session_t *session, const char *client_id,", "const char *check_session_iframe) {", "", "oidc_debug(r, \"enter\");", "", "const char *java_script =", "\"    <script type=\\\"text/javascript\\\">\\n\"", "\"      var targetOrigin  = '%s';\\n\"", "\"      var message = '%s' + ' ' + '%s';\\n\"", "\"\t   var timerID;\\n\"", "\"\\n\"", "\"      function checkSession() {\\n\"", "\"        console.debug('checkSession: posting ' + message + ' to ' + targetOrigin);\\n\"", "\"        var win = window.parent.document.getElementById('%s').contentWindow;\\n\"", "\"        win.postMessage( message, targetOrigin);\\n\"", "\"      }\\n\"", "\"\\n\"", "\"      function setTimer() {\\n\"", "\"        checkSession();\\n\"", "\"        timerID = setInterval('checkSession()', %s);\\n\"", "\"      }\\n\"", "\"\\n\"", "\"      function receiveMessage(e) {\\n\"", "\"        console.debug('receiveMessage: ' + e.data + ' from ' + e.origin);\\n\"", "\"        if (e.origin !== targetOrigin ) {\\n\"", "\"          console.debug('receiveMessage: cross-site scripting attack?');\\n\"", "\"          return;\\n\"", "\"        }\\n\"", "\"        if (e.data != 'unchanged') {\\n\"", "\"          clearInterval(timerID);\\n\"", "\"          if (e.data == 'changed') {\\n\"", "\"\t\t     window.location.href = '%s?session=check';\\n\"", "\"          } else {\\n\"", "\"\t\t     window.location.href = '%s?session=logout';\\n\"", "\"          }\\n\"", "\"        }\\n\"", "\"      }\\n\"", "\"\\n\"", "\"      window.addEventListener('message', receiveMessage, false);\\n\"", "\"\\n\"", "\"    </script>\\n\";", "", "", "char *origin = apr_pstrdup(r->pool, check_session_iframe);", "apr_uri_t uri;", "apr_uri_parse(r->pool, check_session_iframe, &uri);", "char *p = strstr(origin, uri.path);", "*p = '\\0';", "", "", "const char *op_iframe_id = \"openidc-op\";", "", "", "const char *session_state = oidc_session_get_session_state(r, session);", "if (session_state == NULL) {", "oidc_warn(r,", "\"no session_state found in the session; the OP does probably not support session management!?\");", "return DONE;", "}", "", "char *s_poll_interval = NULL;", "oidc_util_get_request_parameter(r, \"poll\", &s_poll_interval);", "if (s_poll_interval == NULL)", "s_poll_interval = \"3000\";", "", "const char *redirect_uri = oidc_get_redirect_uri(r, c);", "java_script = apr_psprintf(r->pool, java_script, origin, client_id,", "session_state, op_iframe_id, s_poll_interval, redirect_uri,", "redirect_uri);", "", "return oidc_util_html_send(r, NULL, java_script, \"setTimer\", NULL, DONE);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" ext4_xattr_create_cache(char *name)", " struct mb2_cache *", " ext4_xattr_create_cache(void)", "  {", "\treturn mb_cache_create(name, HASH_BUCKET_BITS);", " \treturn mb2_cache_create(HASH_BUCKET_BITS);", "  }"], "ner_tags": [0, 1, 1, 0, 1, 1, 0]}
{"tokens": ["yyparse (void *scanner, struct yang_parameter *param)", "{", "", "int yychar;", "char *s = NULL, *tmp_s = NULL, *ext_name = NULL;", "struct lys_module *trg = NULL;", "struct lys_node *tpdf_parent = NULL, *data_node = NULL;", "struct lys_ext_instance_complex *ext_instance = NULL;", "int is_ext_instance;", "void *actual = NULL;", "enum yytokentype backup_type, actual_type = MODULE_KEYWORD;", "int64_t cnt_val = 0;", "int is_value = 0;", "void *yang_type = NULL;", "", "", "", "", "", "YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", "YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", "", "", "static YYLTYPE yyloc_default", "# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL", "= { 1, 1, 1, 1 }", "# endif", ";", "YYLTYPE yylloc = yyloc_default;", "", "", "int yynerrs;", "", "int yystate;", "", "int yyerrstatus;", "", "", "", "", "", "", "", "", "", "", "yytype_int16 yyssa[YYINITDEPTH];", "yytype_int16 *yyss;", "yytype_int16 *yyssp;", "", "", "YYSTYPE yyvsa[YYINITDEPTH];", "YYSTYPE *yyvs;", "YYSTYPE *yyvsp;", "", "", "YYLTYPE yylsa[YYINITDEPTH];", "YYLTYPE *yyls;", "YYLTYPE *yylsp;", "", "", "YYLTYPE yyerror_range[3];", "", "YYSIZE_T yystacksize;", "", "int yyn;", "int yyresult;", "", "int yytoken = 0;", "", "", "YYSTYPE yyval;", "YYLTYPE yyloc;", "", "#if YYERROR_VERBOSE", "", "char yymsgbuf[128];", "char *yymsg = yymsgbuf;", "YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", "#endif", "", "#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))", "", "", "", "int yylen = 0;", "", "yyssp = yyss = yyssa;", "yyvsp = yyvs = yyvsa;", "yylsp = yyls = yylsa;", "yystacksize = YYINITDEPTH;", "", "YYDPRINTF ((stderr, \"Starting parse\\n\"));", "", "yystate = 0;", "yyerrstatus = 0;", "yynerrs = 0;", "yychar = YYEMPTY;", "", "", "", "{ yylloc.last_column = 0;", "if (param->flags & EXT_INSTANCE_SUBSTMT) {", "is_ext_instance = 1;", "ext_instance = (struct lys_ext_instance_complex *)param->actual_node;", "ext_name = (char *)param->data_node;", "} else {", "is_ext_instance = 0;", "}", "yylloc.last_line = is_ext_instance;", "param->value = &s;", "param->data_node = (void **)&data_node;", "param->actual_node = &actual;", "backup_type = NODE;", "trg = (param->submodule) ? (struct lys_module *)param->submodule : param->module;", "}", "", "", "yylsp[0] = yylloc;", "goto yysetstate;", "", "", "", "", "yynewstate:", "", "", "yyssp++;", "", "yysetstate:", "*yyssp = (yytype_int16) yystate;", "", "if (yyss + yystacksize - 1 <= yyssp)", "{", "", "YYSIZE_T yysize = (YYSIZE_T) (yyssp - yyss + 1);", "", "#ifdef yyoverflow", "{", "", "", "", "YYSTYPE *yyvs1 = yyvs;", "yytype_int16 *yyss1 = yyss;", "YYLTYPE *yyls1 = yyls;", "", "", "", "", "", "yyoverflow (YY_(\"memory exhausted\"),", "&yyss1, yysize * sizeof (*yyssp),", "&yyvs1, yysize * sizeof (*yyvsp),", "&yyls1, yysize * sizeof (*yylsp),", "&yystacksize);", "yyss = yyss1;", "yyvs = yyvs1;", "yyls = yyls1;", "}", "#else /* no yyoverflow */", "# ifndef YYSTACK_RELOCATE", "goto yyexhaustedlab;", "# else", "", "if (YYMAXDEPTH <= yystacksize)", "goto yyexhaustedlab;", "yystacksize *= 2;", "if (YYMAXDEPTH < yystacksize)", "yystacksize = YYMAXDEPTH;", "", "{", "yytype_int16 *yyss1 = yyss;", "union yyalloc *yyptr =", "(union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "if (! yyptr)", "goto yyexhaustedlab;", "YYSTACK_RELOCATE (yyss_alloc, yyss);", "YYSTACK_RELOCATE (yyvs_alloc, yyvs);", "YYSTACK_RELOCATE (yyls_alloc, yyls);", "#  undef YYSTACK_RELOCATE", "if (yyss1 != yyssa)", "YYSTACK_FREE (yyss1);", "}", "# endif", "#endif /* no yyoverflow */", "", "yyssp = yyss + yysize - 1;", "yyvsp = yyvs + yysize - 1;", "yylsp = yyls + yysize - 1;", "", "YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "(unsigned long) yystacksize));", "", "if (yyss + yystacksize - 1 <= yyssp)", "YYABORT;", "}", "", "YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", "", "if (yystate == YYFINAL)", "YYACCEPT;", "", "goto yybackup;", "", "", "", "", "yybackup:", "", "", "", "", "", "yyn = yypact[yystate];", "if (yypact_value_is_default (yyn))", "goto yydefault;", "", "", "", "", "if (yychar == YYEMPTY)", "{", "YYDPRINTF ((stderr, \"Reading a token: \"));", "yychar = yylex (&yylval, &yylloc, scanner);", "}", "", "if (yychar <= YYEOF)", "{", "yychar = yytoken = YYEOF;", "YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "}", "else", "{", "yytoken = YYTRANSLATE (yychar);", "YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "}", "", "", "", "yyn += yytoken;", "if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "goto yydefault;", "yyn = yytable[yyn];", "if (yyn <= 0)", "{", "if (yytable_value_is_error (yyn))", "goto yyerrlab;", "yyn = -yyn;", "goto yyreduce;", "}", "", "", "", "if (yyerrstatus)", "yyerrstatus--;", "", "", "YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", "", "", "yychar = YYEMPTY;", "", "yystate = yyn;", "YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "*++yyvsp = yylval;", "YY_IGNORE_MAYBE_UNINITIALIZED_END", "*++yylsp = yylloc;", "goto yynewstate;", "", "", "", "", "", "yydefault:", "yyn = yydefact[yystate];", "if (yyn == 0)", "goto yyerrlab;", "goto yyreduce;", "", "", "", "", "", "yyreduce:", "", "yylen = yyr2[yyn];", "", "", "", "", "", "", "", "", "", "yyval = yyvsp[1-yylen];", "", "", "YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);", "yyerror_range[1] = yyloc;", "YY_REDUCE_PRINT (yyn);", "switch (yyn)", "{", "case 5:", "", "{ if (yyget_text(scanner)[0] == '\"') {", "char *tmp;", "", "s = malloc(yyget_leng(scanner) - 1 + 7 * yylval.i);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, yyget_leng(scanner) - 2, 0, yylloc.first_column))) {", "YYABORT;", "}", "s = tmp;", "} else {", "s = calloc(1, yyget_leng(scanner) - 1);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "memcpy(s, yyget_text(scanner) + 1, yyget_leng(scanner) - 2);", "}", "(yyval.p_str) = &s;", "}", "", "break;", "", "case 8:", "", "{ if (yyget_leng(scanner) > 2) {", "int length_s = strlen(s), length_tmp = yyget_leng(scanner);", "char *tmp;", "", "tmp = realloc(s, length_s + length_tmp - 1);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "s = tmp;", "if (yyget_text(scanner)[0] == '\"') {", "if (!(tmp = yang_read_string(trg->ctx, yyget_text(scanner) + 1, s, length_tmp - 2, length_s, yylloc.first_column))) {", "YYABORT;", "}", "s = tmp;", "} else {", "memcpy(s + length_s, yyget_text(scanner) + 1, length_tmp - 2);", "s[length_s + length_tmp - 2] = '\\0';", "}", "}", "}", "", "break;", "", "case 10:", "", "{ if (param->submodule) {", "free(s);", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"module\");", "YYABORT;", "}", "trg = param->module;", "yang_read_common(trg,s,MODULE_KEYWORD);", "s = NULL;", "actual_type = MODULE_KEYWORD;", "}", "", "break;", "", "case 12:", "", "{ if (!param->module->ns) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"namespace\", \"module\");", "YYABORT;", "}", "if (!param->module->prefix) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"prefix\", \"module\");", "YYABORT;", "}", "}", "", "break;", "", "case 13:", "", "{ (yyval.i) = 0; }", "", "break;", "", "case 14:", "", "{ if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {", "YYABORT;", "}", "(yyval.i) = 1;", "s = NULL;", "}", "", "break;", "", "case 15:", "", "{ if (yang_read_common(param->module, s, NAMESPACE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 16:", "", "{ if (yang_read_prefix(trg, NULL, s)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 17:", "", "{ if (!param->submodule) {", "free(s);", "LOGVAL(trg->ctx, LYE_SUBMODULE, LY_VLOG_NONE, NULL);", "YYABORT;", "}", "trg = (struct lys_module *)param->submodule;", "yang_read_common(trg,s,MODULE_KEYWORD);", "s = NULL;", "actual_type = SUBMODULE_KEYWORD;", "}", "", "break;", "", "case 19:", "", "{ if (!param->submodule->prefix) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");", "YYABORT;", "}", "if (!(yyvsp[0].i)) {", "", "if (param->module->version > 1) {", "LOGVAL(trg->ctx, LYE_INVER, LY_VLOG_NONE, NULL);", "YYABORT;", "}", "}", "}", "", "break;", "", "case 20:", "", "{ (yyval.i) = 0; }", "", "break;", "", "case 21:", "", "{ if (yang_check_version(param->module, param->submodule, s, (yyvsp[-1].i))) {", "YYABORT;", "}", "(yyval.i) = 1;", "s = NULL;", "}", "", "break;", "", "case 23:", "", "{ backup_type = actual_type;", "actual_type = YANG_VERSION_KEYWORD;", "}", "", "break;", "", "case 25:", "", "{ backup_type = actual_type;", "actual_type = NAMESPACE_KEYWORD;", "}", "", "break;", "", "case 30:", "", "{ actual_type = (yyvsp[-4].token);", "backup_type = NODE;", "actual = NULL;", "}", "", "break;", "", "case 31:", "", "{ YANG_ADDELEM(trg->imp, trg->imp_size, \"imports\");", "", "((struct lys_import *)actual)->module = (struct lys_module *)s;", "s = NULL;", "(yyval.token) = actual_type;", "actual_type = IMPORT_KEYWORD;", "}", "", "break;", "", "case 32:", "", "{ (yyval.i) = 0; }", "", "break;", "", "case 33:", "", "{ if (yang_read_prefix(trg, actual, s)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 34:", "", "{ if (trg->version != 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");", "free(s);", "YYABORT;", "}", "if (yang_read_description(trg, actual, s, \"import\", IMPORT_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.i) = (yyvsp[-1].i);", "}", "", "break;", "", "case 35:", "", "{ if (trg->version != 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");", "free(s);", "YYABORT;", "}", "if (yang_read_reference(trg, actual, s, \"import\", IMPORT_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.i) = (yyvsp[-1].i);", "}", "", "break;", "", "case 36:", "", "{ if ((yyvsp[-1].i)) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"import\");", "free(s);", "YYABORT;", "}", "memcpy(((struct lys_import *)actual)->rev, s, LY_REV_SIZE-1);", "free(s);", "s = NULL;", "(yyval.i) = 1;", "}", "", "break;", "", "case 37:", "", "{ YANG_ADDELEM(trg->inc, trg->inc_size, \"includes\");", "", "((struct lys_include *)actual)->submodule = (struct lys_submodule *)s;", "s = NULL;", "(yyval.token) = actual_type;", "actual_type = INCLUDE_KEYWORD;", "}", "", "break;", "", "case 38:", "", "{ actual_type = (yyvsp[-1].token);", "backup_type = NODE;", "actual = NULL;", "}", "", "break;", "", "case 41:", "", "{ (yyval.i) = 0; }", "", "break;", "", "case 42:", "", "{ if (trg->version != 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"description\");", "free(s);", "YYABORT;", "}", "if (yang_read_description(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.i) = (yyvsp[-1].i);", "}", "", "break;", "", "case 43:", "", "{ if (trg->version != 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"reference\");", "free(s);", "YYABORT;", "}", "if (yang_read_reference(trg, actual, s, \"include\", INCLUDE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.i) = (yyvsp[-1].i);", "}", "", "break;", "", "case 44:", "", "{ if ((yyvsp[-1].i)) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"revision-date\", \"include\");", "free(s);", "YYABORT;", "}", "memcpy(((struct lys_include *)actual)->rev, s, LY_REV_SIZE-1);", "free(s);", "s = NULL;", "(yyval.i) = 1;", "}", "", "break;", "", "case 45:", "", "{ backup_type = actual_type;", "actual_type = REVISION_DATE_KEYWORD;", "}", "", "break;", "", "case 47:", "", "{ (yyval.token) = actual_type;", "if (is_ext_instance) {", "if (yang_read_extcomplex_str(trg, ext_instance, \"belongs-to\", ext_name, &s,", "0, LY_STMT_BELONGSTO)) {", "YYABORT;", "}", "} else {", "if (param->submodule->prefix) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"belongs-to\", \"submodule\");", "free(s);", "YYABORT;", "}", "if (!ly_strequal(s, param->submodule->belongsto->name, 0)) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"belongs-to\");", "free(s);", "YYABORT;", "}", "free(s);", "}", "s = NULL;", "actual_type = BELONGS_TO_KEYWORD;", "}", "", "break;", "", "case 48:", "", "{ if (is_ext_instance) {", "if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", \"belongs-to\", &s,", "LY_STMT_BELONGSTO, LY_STMT_PREFIX)) {", "YYABORT;", "}", "} else {", "if (yang_read_prefix(trg, NULL, s)) {", "YYABORT;", "}", "}", "s = NULL;", "actual_type = (yyvsp[-4].token);", "}", "", "break;", "", "case 49:", "", "{ backup_type = actual_type;", "actual_type = PREFIX_KEYWORD;", "}", "", "break;", "", "case 52:", "", "{ if (yang_read_common(trg, s, ORGANIZATION_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 53:", "", "{ if (yang_read_common(trg, s, CONTACT_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 54:", "", "{ if (yang_read_description(trg, NULL, s, NULL, MODULE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 55:", "", "{ if (yang_read_reference(trg, NULL, s, NULL, MODULE_KEYWORD)) {", "YYABORT;", "}", "s=NULL;", "}", "", "break;", "", "case 56:", "", "{ backup_type = actual_type;", "actual_type = ORGANIZATION_KEYWORD;", "}", "", "break;", "", "case 58:", "", "{ backup_type = actual_type;", "actual_type = CONTACT_KEYWORD;", "}", "", "break;", "", "case 60:", "", "{ backup_type = actual_type;", "actual_type = DESCRIPTION_KEYWORD;", "}", "", "break;", "", "case 62:", "", "{ backup_type = actual_type;", "actual_type = REFERENCE_KEYWORD;", "}", "", "break;", "", "case 64:", "", "{ if (trg->rev_size) {", "struct lys_revision *tmp;", "", "tmp = realloc(trg->rev, trg->rev_size * sizeof *trg->rev);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->rev = tmp;", "}", "}", "", "break;", "", "case 65:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!is_ext_instance) {", "YANG_ADDELEM(trg->rev, trg->rev_size, \"revisions\");", "}", "memcpy(((struct lys_revision *)actual)->date, s, LY_REV_SIZE);", "free(s);", "s = NULL;", "actual_type = REVISION_KEYWORD;", "}", "", "break;", "", "case 67:", "", "{ int i;", "", "", "for (i = 0; i < (trg->rev_size - 1); i++) {", "if (!strcmp(trg->rev[i].date, trg->rev[trg->rev_size - 1].date)) {", "LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\",", "trg->rev[trg->rev_size - 1].date);", "break;", "}", "}", "}", "", "break;", "", "case 68:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 72:", "", "{ if (yang_read_description(trg, actual, s, \"revision\",REVISION_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 73:", "", "{ if (yang_read_reference(trg, actual, s, \"revision\", REVISION_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 74:", "", "{ s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "if (lyp_check_date(trg->ctx, s)) {", "free(s);", "YYABORT;", "}", "}", "", "break;", "", "case 76:", "", "{ if (lyp_check_date(trg->ctx, s)) {", "free(s);", "YYABORT;", "}", "}", "", "break;", "", "case 77:", "", "{ void *tmp;", "", "if (trg->tpdf_size) {", "tmp = realloc(trg->tpdf, trg->tpdf_size * sizeof *trg->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->tpdf = tmp;", "}", "", "if (trg->features_size) {", "tmp = realloc(trg->features, trg->features_size * sizeof *trg->features);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->features = tmp;", "}", "", "if (trg->ident_size) {", "tmp = realloc(trg->ident, trg->ident_size * sizeof *trg->ident);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->ident = tmp;", "}", "", "if (trg->augment_size) {", "tmp = realloc(trg->augment, trg->augment_size * sizeof *trg->augment);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->augment = tmp;", "}", "", "if (trg->extensions_size) {", "tmp = realloc(trg->extensions, trg->extensions_size * sizeof *trg->extensions);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "trg->extensions = tmp;", "}", "}", "", "break;", "", "case 78:", "", "{", "if (!param->submodule) {", "switch (lyp_ctx_check_module(trg)) {", "case -1:", "YYABORT;", "case 0:", "break;", "case 1:", "", "param->flags |= YANG_EXIST_MODULE;", "YYABORT;", "}", "}", "param->flags &= (~YANG_REMOVE_IMPORT);", "if (yang_check_imports(trg, param->unres)) {", "YYABORT;", "}", "actual = NULL;", "}", "", "break;", "", "case 79:", "", "{ actual = NULL; }", "", "break;", "", "case 90:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(trg->extensions, trg->extensions_size, \"extensions\");", "trg->extensions_size--;", "((struct lys_ext *)actual)->name = lydict_insert_zc(param->module->ctx, s);", "((struct lys_ext *)actual)->module = trg;", "if (lyp_check_identifier(trg->ctx, ((struct lys_ext *)actual)->name, LY_IDENT_EXTENSION, trg, NULL)) {", "trg->extensions_size++;", "YYABORT;", "}", "trg->extensions_size++;", "s = NULL;", "actual_type = EXTENSION_KEYWORD;", "}", "", "break;", "", "case 91:", "", "{ struct lys_ext *ext = actual;", "ext->plugin = ext_get_plugin(ext->name, ext->module->name, ext->module->rev ? ext->module->rev[0].date : NULL);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 96:", "", "{ if (((struct lys_ext *)actual)->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"extension\");", "YYABORT;", "}", "((struct lys_ext *)actual)->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 97:", "", "{ if (yang_read_description(trg, actual, s, \"extension\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 98:", "", "{ if (yang_read_reference(trg, actual, s, \"extension\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 99:", "", "{ (yyval.token) = actual_type;", "if (is_ext_instance) {", "if (yang_read_extcomplex_str(trg, ext_instance, \"argument\", ext_name, &s,", "0, LY_STMT_ARGUMENT)) {", "YYABORT;", "}", "} else {", "if (((struct lys_ext *)actual)->argument) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"argument\", \"extension\");", "free(s);", "YYABORT;", "}", "((struct lys_ext *)actual)->argument = lydict_insert_zc(param->module->ctx, s);", "}", "s = NULL;", "actual_type = ARGUMENT_KEYWORD;", "}", "", "break;", "", "case 100:", "", "{ actual_type = (yyvsp[-1].token); }", "", "break;", "", "case 103:", "", "{ (yyval.uint) = (yyvsp[0].uint);", "backup_type = actual_type;", "actual_type = YIN_ELEMENT_KEYWORD;", "}", "", "break;", "", "case 105:", "", "{ if (is_ext_instance) {", "int c;", "const char ***p;", "uint8_t *val;", "struct lyext_substmt *info;", "", "c = 0;", "p = lys_ext_complex_get_substmt(LY_STMT_ARGUMENT, ext_instance, &info);", "if (info->cardinality >= LY_STMT_CARD_SOME) {", "", "for (c = 0; p[0][c + 1]; c++);", "val = (uint8_t *)p[1];", "} else {", "val = (uint8_t *)(p + 1);", "}", "val[c] = ((yyvsp[-1].uint) == LYS_YINELEM) ? 1 : 2;", "} else {", "((struct lys_ext *)actual)->flags |= (yyvsp[-1].uint);", "}", "}", "", "break;", "", "case 106:", "", "{ (yyval.uint) = LYS_YINELEM; }", "", "break;", "", "case 107:", "", "{ (yyval.uint) = 0; }", "", "break;", "", "case 108:", "", "{ if (!strcmp(s, \"true\")) {", "(yyval.uint) = LYS_YINELEM;", "} else if (!strcmp(s, \"false\")) {", "(yyval.uint) = 0;", "} else {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 109:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = STATUS_KEYWORD;", "}", "", "break;", "", "case 110:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 111:", "", "{ (yyval.i) = LYS_STATUS_CURR; }", "", "break;", "", "case 112:", "", "{ (yyval.i) = LYS_STATUS_OBSLT; }", "", "break;", "", "case 113:", "", "{ (yyval.i) = LYS_STATUS_DEPRC; }", "", "break;", "", "case 114:", "", "{ if (!strcmp(s, \"current\")) {", "(yyval.i) = LYS_STATUS_CURR;", "} else if (!strcmp(s, \"obsolete\")) {", "(yyval.i) = LYS_STATUS_OBSLT;", "} else if (!strcmp(s, \"deprecated\")) {", "(yyval.i) = LYS_STATUS_DEPRC;", "} else {", "LOGVAL(trg->ctx,LYE_INSTMT, LY_VLOG_NONE, NULL, s);", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 115:", "", "{", "if (lyp_check_identifier(trg->ctx, s, LY_IDENT_FEATURE, trg, NULL)) {", "free(s);", "YYABORT;", "}", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(trg->features, trg->features_size, \"features\");", "((struct lys_feature *)actual)->name = lydict_insert_zc(trg->ctx, s);", "((struct lys_feature *)actual)->module = trg;", "s = NULL;", "actual_type = FEATURE_KEYWORD;", "}", "", "break;", "", "case 116:", "", "{ actual = (yyvsp[-1].backup_token).actual;", "actual_type = (yyvsp[-1].backup_token).token;", "}", "", "break;", "", "case 118:", "", "{ struct lys_iffeature *tmp;", "", "if (((struct lys_feature *)actual)->iffeature_size) {", "tmp = realloc(((struct lys_feature *)actual)->iffeature,", "((struct lys_feature *)actual)->iffeature_size * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_feature *)actual)->iffeature = tmp;", "}", "}", "", "break;", "", "case 121:", "", "{ if (((struct lys_feature *)actual)->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"feature\");", "YYABORT;", "}", "((struct lys_feature *)actual)->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 122:", "", "{ if (yang_read_description(trg, actual, s, \"feature\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 123:", "", "{ if (yang_read_reference(trg, actual, s, \"feature\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 124:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "switch (actual_type) {", "case FEATURE_KEYWORD:", "YANG_ADDELEM(((struct lys_feature *)actual)->iffeature,", "((struct lys_feature *)actual)->iffeature_size, \"if-features\");", "break;", "case IDENTITY_KEYWORD:", "if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"identity\");", "free(s);", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_ident *)actual)->iffeature,", "((struct lys_ident *)actual)->iffeature_size, \"if-features\");", "break;", "case ENUM_KEYWORD:", "if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");", "free(s);", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_type_enum *)actual)->iffeature,", "((struct lys_type_enum *)actual)->iffeature_size, \"if-features\");", "break;", "case BIT_KEYWORD:", "if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"bit\");", "free(s);", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_type_bit *)actual)->iffeature,", "((struct lys_type_bit *)actual)->iffeature_size, \"if-features\");", "break;", "case REFINE_KEYWORD:", "if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"if-feature\");", "free(s);", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_refine *)actual)->iffeature,", "((struct lys_refine *)actual)->iffeature_size, \"if-features\");", "break;", "case EXTENSION_INSTANCE:", "", "break;", "default:", "", "YANG_ADDELEM(((struct lys_node *)actual)->iffeature,", "((struct lys_node *)actual)->iffeature_size, \"if-features\");", "break;", "}", "((struct lys_iffeature *)actual)->features = (struct lys_feature **)s;", "s = NULL;", "actual_type = IF_FEATURE_KEYWORD;", "}", "", "break;", "", "case 125:", "", "{ actual = (yyvsp[-1].backup_token).actual;", "actual_type = (yyvsp[-1].backup_token).token;", "}", "", "break;", "", "case 128:", "", "{ const char *tmp;", "", "tmp = lydict_insert_zc(trg->ctx, s);", "s = NULL;", "if (dup_identities_check(tmp, trg)) {", "lydict_remove(trg->ctx, tmp);", "YYABORT;", "}", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(trg->ident, trg->ident_size, \"identities\");", "((struct lys_ident *)actual)->name = tmp;", "((struct lys_ident *)actual)->module = trg;", "actual_type = IDENTITY_KEYWORD;", "}", "", "break;", "", "case 129:", "", "{ actual = (yyvsp[-1].backup_token).actual;", "actual_type = (yyvsp[-1].backup_token).token;", "}", "", "break;", "", "case 131:", "", "{ void *tmp;", "", "if (((struct lys_ident *)actual)->base_size) {", "tmp = realloc(((struct lys_ident *)actual)->base,", "((struct lys_ident *)actual)->base_size * sizeof *((struct lys_ident *)actual)->base);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_ident *)actual)->base = tmp;", "}", "", "if (((struct lys_ident *)actual)->iffeature_size) {", "tmp = realloc(((struct lys_ident *)actual)->iffeature,", "((struct lys_ident *)actual)->iffeature_size * sizeof *((struct lys_ident *)actual)->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_ident *)actual)->iffeature = tmp;", "}", "}", "", "break;", "", "case 133:", "", "{ void *identity;", "", "if ((trg->version < 2) && ((struct lys_ident *)actual)->base_size) {", "free(s);", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"base\", \"identity\");", "YYABORT;", "}", "identity = actual;", "YANG_ADDELEM(((struct lys_ident *)actual)->base,", "((struct lys_ident *)actual)->base_size, \"bases\");", "*((struct lys_ident **)actual) = (struct lys_ident *)s;", "s = NULL;", "actual = identity;", "}", "", "break;", "", "case 135:", "", "{ if (((struct lys_ident *)actual)->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"identity\");", "YYABORT;", "}", "((struct lys_ident *)actual)->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 136:", "", "{ if (yang_read_description(trg, actual, s, \"identity\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 137:", "", "{ if (yang_read_reference(trg, actual, s, \"identity\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 138:", "", "{ backup_type = actual_type;", "actual_type = BASE_KEYWORD;", "}", "", "break;", "", "case 140:", "", "{ tpdf_parent = (actual_type == EXTENSION_INSTANCE) ? ext_instance : actual;", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (lyp_check_identifier(trg->ctx, s, LY_IDENT_TYPE, trg, tpdf_parent)) {", "free(s);", "YYABORT;", "}", "switch (actual_type) {", "case MODULE_KEYWORD:", "case SUBMODULE_KEYWORD:", "YANG_ADDELEM(trg->tpdf, trg->tpdf_size, \"typedefs\");", "break;", "case GROUPING_KEYWORD:", "YANG_ADDELEM(((struct lys_node_grp *)tpdf_parent)->tpdf,", "((struct lys_node_grp *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case CONTAINER_KEYWORD:", "YANG_ADDELEM(((struct lys_node_container *)tpdf_parent)->tpdf,", "((struct lys_node_container *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case LIST_KEYWORD:", "YANG_ADDELEM(((struct lys_node_list *)tpdf_parent)->tpdf,", "((struct lys_node_list *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case RPC_KEYWORD:", "case ACTION_KEYWORD:", "YANG_ADDELEM(((struct lys_node_rpc_action *)tpdf_parent)->tpdf,", "((struct lys_node_rpc_action *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case INPUT_KEYWORD:", "case OUTPUT_KEYWORD:", "YANG_ADDELEM(((struct lys_node_inout *)tpdf_parent)->tpdf,", "((struct lys_node_inout *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case NOTIFICATION_KEYWORD:", "YANG_ADDELEM(((struct lys_node_notif *)tpdf_parent)->tpdf,", "((struct lys_node_notif *)tpdf_parent)->tpdf_size, \"typedefs\");", "break;", "case EXTENSION_INSTANCE:", "", "break;", "default:", "", "LOGINT(trg->ctx);", "free(s);", "YYABORT;", "}", "((struct lys_tpdf *)actual)->name = lydict_insert_zc(param->module->ctx, s);", "((struct lys_tpdf *)actual)->module = trg;", "s = NULL;", "actual_type = TYPEDEF_KEYWORD;", "}", "", "break;", "", "case 141:", "", "{ if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"typedef\");", "YYABORT;", "}", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 142:", "", "{ (yyval.nodes).node.ptr_tpdf = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 143:", "", "{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;", "(yyval.nodes) = (yyvsp[-2].nodes);", "}", "", "break;", "", "case 144:", "", "{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 145:", "", "{ if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, TYPEDEF_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 146:", "", "{ if ((yyvsp[-1].nodes).node.ptr_tpdf->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"typedef\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_tpdf->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 147:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 148:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_tpdf, s, \"typedef\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 149:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 150:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_type(trg->ctx, actual, s, actual_type))) {", "YYABORT;", "}", "s = NULL;", "actual_type = TYPE_KEYWORD;", "}", "", "break;", "", "case 153:", "", "{ if (((struct yang_type *)actual)->base == LY_TYPE_STRING &&", "((struct yang_type *)actual)->type->info.str.pat_count) {", "void *tmp;", "", "tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns,", "((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.str.patterns = tmp;", "", "#ifdef LY_ENABLED_CACHE", "if (!(trg->ctx->models.flags & LY_CTX_TRUSTED) && ((struct yang_type *)actual)->type->info.str.patterns_pcre) {", "tmp = realloc(((struct yang_type *)actual)->type->info.str.patterns_pcre,", "2 * ((struct yang_type *)actual)->type->info.str.pat_count * sizeof *((struct yang_type *)actual)->type->info.str.patterns_pcre);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.str.patterns_pcre = tmp;", "}", "#endif", "}", "if (((struct yang_type *)actual)->base == LY_TYPE_UNION) {", "struct lys_type *tmp;", "", "tmp = realloc(((struct yang_type *)actual)->type->info.uni.types,", "((struct yang_type *)actual)->type->info.uni.count * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.uni.types = tmp;", "}", "if (((struct yang_type *)actual)->base == LY_TYPE_IDENT) {", "struct lys_ident **tmp;", "", "tmp = realloc(((struct yang_type *)actual)->type->info.ident.ref,", "((struct yang_type *)actual)->type->info.ident.count* sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.ident.ref = tmp;", "}", "}", "", "break;", "", "case 157:", "", "{ if (yang_read_require_instance(trg->ctx, actual, (yyvsp[0].i))) {", "YYABORT;", "}", "}", "", "break;", "", "case 158:", "", "{", "if (yang_read_leafref_path(trg, actual, s)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 159:", "", "{", "if (((struct yang_type *)actual)->base && ((struct yang_type *)actual)->base != LY_TYPE_IDENT) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"base\");", "return EXIT_FAILURE;", "}", "((struct yang_type *)actual)->base = LY_TYPE_IDENT;", "yang_type = actual;", "YANG_ADDELEM(((struct yang_type *)actual)->type->info.ident.ref,", "((struct yang_type *)actual)->type->info.ident.count, \"identity refs\");", "*((struct lys_ident **)actual) = (struct lys_ident *)s;", "actual = yang_type;", "s = NULL;", "}", "", "break;", "", "case 162:", "", "{ if (yang_read_fraction(trg->ctx, actual, (yyvsp[0].uint))) {", "YYABORT;", "}", "}", "", "break;", "", "case 165:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 166:", "", "{ struct yang_type *stype = (struct yang_type *)actual;", "", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (stype->base != 0 && stype->base != LY_TYPE_UNION) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected type statement.\");", "YYABORT;", "}", "stype->base = LY_TYPE_UNION;", "if (strcmp(stype->name, \"union\")) {", "", "LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"type\", \"derived type\");", "YYABORT;", "}", "YANG_ADDELEM(stype->type->info.uni.types, stype->type->info.uni.count, \"union types\")", "actual_type = UNION_KEYWORD;", "}", "", "break;", "", "case 167:", "", "{ (yyval.uint) = (yyvsp[0].uint);", "backup_type = actual_type;", "actual_type = FRACTION_DIGITS_KEYWORD;", "}", "", "break;", "", "case 168:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 169:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 170:", "", "{ char *endptr = NULL;", "unsigned long val;", "errno = 0;", "", "val = strtoul(s, &endptr, 10);", "if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"fraction-digits\");", "free(s);", "s = NULL;", "YYABORT;", "}", "(yyval.uint) = (uint32_t) val;", "free(s);", "s =NULL;", "}", "", "break;", "", "case 171:", "", "{ actual = (yyvsp[-1].backup_token).actual;", "actual_type = (yyvsp[-1].backup_token).token;", "}", "", "break;", "", "case 172:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_length(trg->ctx, actual, s, is_ext_instance))) {", "YYABORT;", "}", "actual_type = LENGTH_KEYWORD;", "s = NULL;", "}", "", "break;", "", "case 175:", "", "{ switch (actual_type) {", "case MUST_KEYWORD:", "(yyval.str) = \"must\";", "break;", "case LENGTH_KEYWORD:", "(yyval.str) = \"length\";", "break;", "case RANGE_KEYWORD:", "(yyval.str) = \"range\";", "break;", "default:", "LOGINT(trg->ctx);", "YYABORT;", "break;", "}", "}", "", "break;", "", "case 176:", "", "{ if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_MESSAGE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 177:", "", "{ if (yang_read_message(trg, actual, s, (yyvsp[-1].str), ERROR_APP_TAG_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 178:", "", "{ if (yang_read_description(trg, actual, s, (yyvsp[-1].str), NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 179:", "", "{ if (yang_read_reference(trg, actual, s, (yyvsp[-1].str), NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 180:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "}", "", "break;", "", "case 181:", "", "{struct lys_restr *pattern = actual;", "actual = NULL;", "#ifdef LY_ENABLED_CACHE", "if ((yyvsp[-2].backup_token).token != EXTENSION_INSTANCE &&", "!(data_node && data_node->nodetype != LYS_GROUPING && lys_ingrouping(data_node))) {", "unsigned int c = 2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1);", "YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");", "++c;", "YANG_ADDELEM(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre, c, \"patterns\");", "actual = &(((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.patterns_pcre)[2 * (((struct yang_type *)(yyvsp[-2].backup_token).actual)->type->info.str.pat_count - 1)];", "}", "#endif", "if (yang_read_pattern(trg->ctx, pattern, actual, (yyvsp[-1].str), (yyvsp[0].ch))) {", "YYABORT;", "}", "actual_type = (yyvsp[-2].backup_token).token;", "actual = (yyvsp[-2].backup_token).actual;", "}", "", "break;", "", "case 182:", "", "{ if (actual_type != EXTENSION_INSTANCE) {", "if (((struct yang_type *)actual)->base != 0 && ((struct yang_type *)actual)->base != LY_TYPE_STRING) {", "free(s);", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Unexpected pattern statement.\");", "YYABORT;", "}", "((struct yang_type *)actual)->base = LY_TYPE_STRING;", "YANG_ADDELEM(((struct yang_type *)actual)->type->info.str.patterns,", "((struct yang_type *)actual)->type->info.str.pat_count, \"patterns\");", "}", "(yyval.str) = s;", "s = NULL;", "actual_type = PATTERN_KEYWORD;", "}", "", "break;", "", "case 183:", "", "{ (yyval.ch) = 0x06; }", "", "break;", "", "case 184:", "", "{ (yyval.ch) = (yyvsp[-1].ch); }", "", "break;", "", "case 185:", "", "{ (yyval.ch) = 0x06;           }", "", "break;", "", "case 186:", "", "{ if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"modifier\");", "YYABORT;", "}", "if ((yyvsp[-1].ch) != 0x06) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"modifier\", \"pattern\");", "YYABORT;", "}", "(yyval.ch) = (yyvsp[0].ch);", "}", "", "break;", "", "case 187:", "", "{ if (yang_read_message(trg, actual, s, \"pattern\", ERROR_MESSAGE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 188:", "", "{ if (yang_read_message(trg, actual, s, \"pattern\", ERROR_APP_TAG_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 189:", "", "{ if (yang_read_description(trg, actual, s, \"pattern\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 190:", "", "{ if (yang_read_reference(trg, actual, s, \"pattern\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 191:", "", "{ backup_type = actual_type;", "actual_type = MODIFIER_KEYWORD;", "}", "", "break;", "", "case 192:", "", "{ if (!strcmp(s, \"invert-match\")) {", "(yyval.ch) = 0x15;", "free(s);", "s = NULL;", "} else {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, s);", "free(s);", "YYABORT;", "}", "}", "", "break;", "", "case 193:", "", "{ struct lys_type_enum * tmp;", "", "cnt_val = 0;", "tmp = realloc(((struct yang_type *)actual)->type->info.enums.enm,", "((struct yang_type *)actual)->type->info.enums.count * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.enums.enm = tmp;", "}", "", "break;", "", "case 196:", "", "{ if (yang_check_enum(trg->ctx, yang_type, actual, &cnt_val, is_value)) {", "YYABORT;", "}", "actual = (yyvsp[-1].backup_token).actual;", "actual_type = (yyvsp[-1].backup_token).token;", "}", "", "break;", "", "case 197:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = yang_type = actual;", "YANG_ADDELEM(((struct yang_type *)actual)->type->info.enums.enm, ((struct yang_type *)actual)->type->info.enums.count, \"enums\");", "if (yang_read_enum(trg->ctx, yang_type, actual, s)) {", "YYABORT;", "}", "s = NULL;", "is_value = 0;", "actual_type = ENUM_KEYWORD;", "}", "", "break;", "", "case 199:", "", "{ if (((struct lys_type_enum *)actual)->iffeature_size) {", "struct lys_iffeature *tmp;", "", "tmp = realloc(((struct lys_type_enum *)actual)->iffeature,", "((struct lys_type_enum *)actual)->iffeature_size * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_type_enum *)actual)->iffeature = tmp;", "}", "}", "", "break;", "", "case 202:", "", "{ if (is_value) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"value\", \"enum\");", "YYABORT;", "}", "((struct lys_type_enum *)actual)->value = (yyvsp[0].i);", "", "", "if ((yyvsp[0].i) >= cnt_val) {", "cnt_val = (yyvsp[0].i) + 1;", "}", "is_value = 1;", "}", "", "break;", "", "case 203:", "", "{ if (((struct lys_type_enum *)actual)->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"enum\");", "YYABORT;", "}", "((struct lys_type_enum *)actual)->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 204:", "", "{ if (yang_read_description(trg, actual, s, \"enum\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 205:", "", "{ if (yang_read_reference(trg, actual, s, \"enum\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 206:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = VALUE_KEYWORD;", "}", "", "break;", "", "case 207:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 208:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 209:", "", "{", "int64_t val;", "char *endptr;", "", "val = strtoll(s, &endptr, 10);", "if (val < INT32_MIN || val > INT32_MAX || *endptr) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"value\");", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "(yyval.i) = (int32_t) val;", "}", "", "break;", "", "case 210:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 213:", "", "{ backup_type = actual_type;", "actual_type = PATH_KEYWORD;", "}", "", "break;", "", "case 215:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = REQUIRE_INSTANCE_KEYWORD;", "}", "", "break;", "", "case 216:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 217:", "", "{ (yyval.i) = 1; }", "", "break;", "", "case 218:", "", "{ (yyval.i) = -1; }", "", "break;", "", "case 219:", "", "{ if (!strcmp(s,\"true\")) {", "(yyval.i) = 1;", "} else if (!strcmp(s,\"false\")) {", "(yyval.i) = -1;", "} else {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"require-instance\");", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 220:", "", "{ struct lys_type_bit * tmp;", "", "cnt_val = 0;", "tmp = realloc(((struct yang_type *)actual)->type->info.bits.bit,", "((struct yang_type *)actual)->type->info.bits.count * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct yang_type *)actual)->type->info.bits.bit = tmp;", "}", "", "break;", "", "case 223:", "", "{ if (yang_check_bit(trg->ctx, yang_type, actual, &cnt_val, is_value)) {", "YYABORT;", "}", "actual = (yyvsp[-2].backup_token).actual;", "actual_type = (yyvsp[-2].backup_token).token;", "}", "", "break;", "", "case 224:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = yang_type = actual;", "YANG_ADDELEM(((struct yang_type *)actual)->type->info.bits.bit,", "((struct yang_type *)actual)->type->info.bits.count, \"bits\");", "if (yang_read_bit(trg->ctx, yang_type, actual, s)) {", "YYABORT;", "}", "s = NULL;", "is_value = 0;", "actual_type = BIT_KEYWORD;", "}", "", "break;", "", "case 226:", "", "{ if (((struct lys_type_bit *)actual)->iffeature_size) {", "struct lys_iffeature *tmp;", "", "tmp = realloc(((struct lys_type_bit *)actual)->iffeature,", "((struct lys_type_bit *)actual)->iffeature_size * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_type_bit *)actual)->iffeature = tmp;", "}", "}", "", "break;", "", "case 229:", "", "{ if (is_value) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"position\", \"bit\");", "YYABORT;", "}", "((struct lys_type_bit *)actual)->pos = (yyvsp[0].uint);", "", "", "if ((yyvsp[0].uint) >= cnt_val) {", "cnt_val = (yyvsp[0].uint) + 1;", "}", "is_value = 1;", "}", "", "break;", "", "case 230:", "", "{ if (((struct lys_type_bit *)actual)->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"status\", \"bit\");", "YYABORT;", "}", "((struct lys_type_bit *)actual)->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 231:", "", "{ if (yang_read_description(trg, actual, s, \"bit\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 232:", "", "{ if (yang_read_reference(trg, actual, s, \"bit\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 233:", "", "{ (yyval.uint) = (yyvsp[0].uint);", "backup_type = actual_type;", "actual_type = POSITION_KEYWORD;", "}", "", "break;", "", "case 234:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 235:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 236:", "", "{", "unsigned long val;", "char *endptr = NULL;", "errno = 0;", "", "val = strtoul(s, &endptr, 10);", "if (s[0] == '-' || *endptr || errno || val > UINT32_MAX) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"position\");", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "(yyval.uint) = (uint32_t) val;", "}", "", "break;", "", "case 237:", "", "{ backup_type = actual_type;", "actual_type = ERROR_MESSAGE_KEYWORD;", "}", "", "break;", "", "case 239:", "", "{ backup_type = actual_type;", "actual_type = ERROR_APP_TAG_KEYWORD;", "}", "", "break;", "", "case 241:", "", "{ backup_type = actual_type;", "actual_type = UNITS_KEYWORD;", "}", "", "break;", "", "case 243:", "", "{ backup_type = actual_type;", "actual_type = DEFAULT_KEYWORD;", "}", "", "break;", "", "case 245:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_GROUPING, sizeof(struct lys_node_grp)))) {", "YYABORT;", "}", "s = NULL;", "data_node = actual;", "actual_type = GROUPING_KEYWORD;", "}", "", "break;", "", "case 246:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing grouping statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 249:", "", "{ (yyval.nodes).grouping = actual; }", "", "break;", "", "case 250:", "", "{ if ((yyvsp[-1].nodes).grouping->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).grouping, \"status\", \"grouping\");", "YYABORT;", "}", "(yyvsp[-1].nodes).grouping->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 251:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 252:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).grouping, s, \"grouping\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 257:", "", "{ if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).grouping, \"notification\");", "YYABORT;", "}", "}", "", "break;", "", "case 266:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CONTAINER, sizeof(struct lys_node_container)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = CONTAINER_KEYWORD;", "}", "", "break;", "", "case 267:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing container statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 269:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).container->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).container->iffeature, (yyvsp[-1].nodes).container->iffeature_size * sizeof *(yyvsp[-1].nodes).container->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).container->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).container->must_size) {", "tmp = realloc((yyvsp[-1].nodes).container->must, (yyvsp[-1].nodes).container->must_size * sizeof *(yyvsp[-1].nodes).container->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).container->must = tmp;", "}", "}", "", "break;", "", "case 270:", "", "{ (yyval.nodes).container = actual; }", "", "break;", "", "case 274:", "", "{ if (yang_read_presence(trg, (yyvsp[-1].nodes).container, s)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 275:", "", "{ if ((yyvsp[-1].nodes).container->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"config\", \"container\");", "YYABORT;", "}", "(yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 276:", "", "{ if ((yyvsp[-1].nodes).container->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).container, \"status\", \"container\");", "YYABORT;", "}", "(yyvsp[-1].nodes).container->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 277:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 278:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).container, s, \"container\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 281:", "", "{ if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).container, \"notification\");", "YYABORT;", "}", "}", "", "break;", "", "case 284:", "", "{ void *tmp;", "", "if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"type\", \"leaf\");", "YYABORT;", "}", "if ((yyvsp[-1].nodes).node.ptr_leaf->dflt && ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_TRUE)) {", "", "LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");", "YYABORT;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_leaf->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->iffeature, (yyvsp[-1].nodes).node.ptr_leaf->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaf->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_leaf->must_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_leaf->must, (yyvsp[-1].nodes).node.ptr_leaf->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaf->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaf->must = tmp;", "}", "", "LOGDBG(LY_LDGYANG, \"finished parsing leaf statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 285:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAF, sizeof(struct lys_node_leaf)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = LEAF_KEYWORD;", "}", "", "break;", "", "case 286:", "", "{ (yyval.nodes).node.ptr_leaf = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 289:", "", "{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;", "(yyval.nodes) = (yyvsp[-2].nodes);", "}", "", "break;", "", "case 290:", "", "{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 292:", "", "{ if (yang_read_default(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, LEAF_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 293:", "", "{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"config\", \"leaf\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 294:", "", "{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"mandatory\", \"leaf\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 295:", "", "{ if ((yyvsp[-1].nodes).node.ptr_leaf->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaf, \"status\", \"leaf\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaf->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 296:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 297:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaf, s, \"leaf\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 298:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LEAFLIST, sizeof(struct lys_node_leaflist)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = LEAF_LIST_KEYWORD;", "}", "", "break;", "", "case 299:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_R) {", "", "", "", "(yyvsp[-1].nodes).node.ptr_leaflist->flags &= 0x7F;", "}", "if (!((yyvsp[-1].nodes).node.flag & LYS_TYPE_DEF)) {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"type\", \"leaf-list\");", "YYABORT;", "}", "if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size && (yyvsp[-1].nodes).node.ptr_leaflist->min) {", "LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist,", "\"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");", "YYABORT;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->iffeature, (yyvsp[-1].nodes).node.ptr_leaflist->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_leaflist->must_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->must, (yyvsp[-1].nodes).node.ptr_leaflist->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->must = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_leaflist->dflt_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_leaflist->dflt, (yyvsp[-1].nodes).node.ptr_leaflist->dflt_size * sizeof *(yyvsp[-1].nodes).node.ptr_leaflist->dflt);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->dflt = tmp;", "}", "", "LOGDBG(LY_LDGYANG, \"finished parsing leaf-list statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 300:", "", "{ (yyval.nodes).node.ptr_leaflist = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 303:", "", "{ (yyvsp[-2].nodes).node.flag |= LYS_TYPE_DEF;", "(yyval.nodes) = (yyvsp[-2].nodes);", "}", "", "break;", "", "case 304:", "", "{ if (trg->version < 2) {", "free(s);", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"default\");", "YYABORT;", "}", "YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_leaflist->dflt,", "(yyvsp[-1].nodes).node.ptr_leaflist->dflt_size, \"defaults\");", "(*(const char **)actual) = lydict_insert_zc(param->module->ctx, s);", "s = NULL;", "actual = (yyvsp[-1].nodes).node.ptr_leaflist;", "}", "", "break;", "", "case 305:", "", "{ if (yang_read_units(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, LEAF_LIST_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 307:", "", "{ if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"config\", \"leaf-list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 308:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"min-elements\", \"leaf-list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->min = (yyvsp[0].uint);", "(yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;", "(yyval.nodes) = (yyvsp[-1].nodes);", "if ((yyvsp[-1].nodes).node.ptr_leaflist->max && ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max)) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");", "YYABORT;", "}", "}", "", "break;", "", "case 309:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"max-elements\", \"leaf-list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->max = (yyvsp[0].uint);", "(yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;", "(yyval.nodes) = (yyvsp[-1].nodes);", "if ((yyvsp[-1].nodes).node.ptr_leaflist->min > (yyvsp[-1].nodes).node.ptr_leaflist->max) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"max-elements\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");", "YYABORT;", "}", "}", "", "break;", "", "case 310:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"ordered by\", \"leaf-list\");", "YYABORT;", "}", "if ((yyvsp[0].i) & LYS_USERORDERED) {", "(yyvsp[-1].nodes).node.ptr_leaflist->flags |= LYS_USERORDERED;", "}", "(yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 311:", "", "{ if ((yyvsp[-1].nodes).node.ptr_leaflist->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_leaflist, \"status\", \"leaf-list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_leaflist->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 312:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 313:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_leaflist, s, \"leaf-list\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 314:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_LIST, sizeof(struct lys_node_list)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = LIST_KEYWORD;", "}", "", "break;", "", "case 315:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).node.ptr_list->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_list->iffeature, (yyvsp[-1].nodes).node.ptr_list->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_list->must_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_list->must, (yyvsp[-1].nodes).node.ptr_list->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->must = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_list->tpdf_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_list->tpdf, (yyvsp[-1].nodes).node.ptr_list->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->tpdf = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_list->unique_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size * sizeof *(yyvsp[-1].nodes).node.ptr_list->unique);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->unique = tmp;", "}", "", "LOGDBG(LY_LDGYANG, \"finished parsing list statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 316:", "", "{ (yyval.nodes).node.ptr_list = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 320:", "", "{ if ((yyvsp[-1].nodes).node.ptr_list->keys) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"key\", \"list\");", "free(s);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->keys = (struct lys_node_leaf **)s;", "(yyval.nodes) = (yyvsp[-1].nodes);", "s = NULL;", "}", "", "break;", "", "case 321:", "", "{ YANG_ADDELEM((yyvsp[-1].nodes).node.ptr_list->unique, (yyvsp[-1].nodes).node.ptr_list->unique_size, \"uniques\");", "((struct lys_unique *)actual)->expr = (const char **)s;", "(yyval.nodes) = (yyvsp[-1].nodes);", "s = NULL;", "actual = (yyvsp[-1].nodes).node.ptr_list;", "}", "", "break;", "", "case 322:", "", "{ if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"config\", \"list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 323:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_MIN_ELEMENTS) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"min-elements\", \"list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->min = (yyvsp[0].uint);", "(yyvsp[-1].nodes).node.flag |= LYS_MIN_ELEMENTS;", "(yyval.nodes) = (yyvsp[-1].nodes);", "if ((yyvsp[-1].nodes).node.ptr_list->max && ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max)) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");", "YYABORT;", "}", "}", "", "break;", "", "case 324:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_MAX_ELEMENTS) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"max-elements\", \"list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->max = (yyvsp[0].uint);", "(yyvsp[-1].nodes).node.flag |= LYS_MAX_ELEMENTS;", "(yyval.nodes) = (yyvsp[-1].nodes);", "if ((yyvsp[-1].nodes).node.ptr_list->min > (yyvsp[-1].nodes).node.ptr_list->max) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"min-elements\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");", "YYABORT;", "}", "}", "", "break;", "", "case 325:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_ORDERED_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"ordered by\", \"list\");", "YYABORT;", "}", "if ((yyvsp[0].i) & LYS_USERORDERED) {", "(yyvsp[-1].nodes).node.ptr_list->flags |= LYS_USERORDERED;", "}", "(yyvsp[-1].nodes).node.flag |= (yyvsp[0].i);", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 326:", "", "{ if ((yyvsp[-1].nodes).node.ptr_list->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_list, \"status\", \"list\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_list->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 327:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 328:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_list, s, \"list\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 332:", "", "{ if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_list, \"notification\");", "YYABORT;", "}", "}", "", "break;", "", "case 334:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CHOICE, sizeof(struct lys_node_choice)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = CHOICE_KEYWORD;", "}", "", "break;", "", "case 335:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing choice statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 337:", "", "{ struct lys_iffeature *tmp;", "", "if (((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_TRUE) && (yyvsp[-1].nodes).node.ptr_choice->dflt) {", "LOGVAL(trg->ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"The \\\"default\\\" statement is forbidden on choices with \\\"mandatory\\\".\");", "YYABORT;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_choice->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_choice->iffeature, (yyvsp[-1].nodes).node.ptr_choice->iffeature_size * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_choice->iffeature = tmp;", "}", "}", "", "break;", "", "case 338:", "", "{ (yyval.nodes).node.ptr_choice = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 341:", "", "{ if ((yyvsp[-1].nodes).node.flag & LYS_CHOICE_DEFAULT) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"default\", \"choice\");", "free(s);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_choice->dflt = (struct lys_node *) s;", "s = NULL;", "(yyval.nodes) = (yyvsp[-1].nodes);", "(yyval.nodes).node.flag |= LYS_CHOICE_DEFAULT;", "}", "", "break;", "", "case 342:", "", "{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"config\", \"choice\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 343:", "", "{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"mandatory\", \"choice\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 344:", "", "{ if ((yyvsp[-1].nodes).node.ptr_choice->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_choice, \"status\", \"choice\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_choice->flags |= (yyvsp[0].i);", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 345:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 346:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_choice, s, \"choice\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 356:", "", "{ if (trg->version < 2 ) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"choice\");", "YYABORT;", "}", "}", "", "break;", "", "case 357:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_CASE, sizeof(struct lys_node_case)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = CASE_KEYWORD;", "}", "", "break;", "", "case 358:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing case statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 360:", "", "{ struct lys_iffeature *tmp;", "", "if ((yyvsp[-1].nodes).cs->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).cs->iffeature, (yyvsp[-1].nodes).cs->iffeature_size * sizeof *tmp);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).cs->iffeature = tmp;", "}", "}", "", "break;", "", "case 361:", "", "{ (yyval.nodes).cs = actual; }", "", "break;", "", "case 364:", "", "{ if ((yyvsp[-1].nodes).cs->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).cs, \"status\", \"case\");", "YYABORT;", "}", "(yyvsp[-1].nodes).cs->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 365:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 366:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).cs, s, \"case\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 368:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYXML, sizeof(struct lys_node_anydata)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = ANYXML_KEYWORD;", "}", "", "break;", "", "case 369:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing anyxml statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 370:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ANYDATA, sizeof(struct lys_node_anydata)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = ANYDATA_KEYWORD;", "}", "", "break;", "", "case 371:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing anydata statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 373:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).node.ptr_anydata->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->iffeature, (yyvsp[-1].nodes).node.ptr_anydata->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_anydata->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_anydata->must_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_anydata->must, (yyvsp[-1].nodes).node.ptr_anydata->must_size * sizeof *(yyvsp[-1].nodes).node.ptr_anydata->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_anydata->must = tmp;", "}", "}", "", "break;", "", "case 374:", "", "{ (yyval.nodes).node.ptr_anydata = actual;", "(yyval.nodes).node.flag = actual_type;", "}", "", "break;", "", "case 378:", "", "{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"config\",", "((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 379:", "", "{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"mandatory\",", "((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 380:", "", "{ if ((yyvsp[-1].nodes).node.ptr_anydata->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_anydata, \"status\",", "((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_anydata->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 381:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 382:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_anydata, s, ((yyvsp[-1].nodes).node.flag == ANYXML_KEYWORD) ? \"anyxml\" : \"anydata\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 383:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_USES, sizeof(struct lys_node_uses)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = USES_KEYWORD;", "}", "", "break;", "", "case 384:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing uses statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 386:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).uses->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).uses->iffeature, (yyvsp[-1].nodes).uses->iffeature_size * sizeof *(yyvsp[-1].nodes).uses->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).uses->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).uses->refine_size) {", "tmp = realloc((yyvsp[-1].nodes).uses->refine, (yyvsp[-1].nodes).uses->refine_size * sizeof *(yyvsp[-1].nodes).uses->refine);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).uses->refine = tmp;", "}", "", "if ((yyvsp[-1].nodes).uses->augment_size) {", "tmp = realloc((yyvsp[-1].nodes).uses->augment, (yyvsp[-1].nodes).uses->augment_size * sizeof *(yyvsp[-1].nodes).uses->augment);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).uses->augment = tmp;", "}", "}", "", "break;", "", "case 387:", "", "{ (yyval.nodes).uses = actual; }", "", "break;", "", "case 390:", "", "{ if ((yyvsp[-1].nodes).uses->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).uses, \"status\", \"uses\");", "YYABORT;", "}", "(yyvsp[-1].nodes).uses->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 391:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 392:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).uses, s, \"uses\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 397:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(((struct lys_node_uses *)actual)->refine,", "((struct lys_node_uses *)actual)->refine_size, \"refines\");", "((struct lys_refine *)actual)->target_name = transform_schema2json(trg, s);", "free(s);", "s = NULL;", "if (!((struct lys_refine *)actual)->target_name) {", "YYABORT;", "}", "actual_type = REFINE_KEYWORD;", "}", "", "break;", "", "case 398:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 400:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).refine->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).refine->iffeature, (yyvsp[-1].nodes).refine->iffeature_size * sizeof *(yyvsp[-1].nodes).refine->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).refine->must_size) {", "tmp = realloc((yyvsp[-1].nodes).refine->must, (yyvsp[-1].nodes).refine->must_size * sizeof *(yyvsp[-1].nodes).refine->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->must = tmp;", "}", "", "if ((yyvsp[-1].nodes).refine->dflt_size) {", "tmp = realloc((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size * sizeof *(yyvsp[-1].nodes).refine->dflt);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->dflt = tmp;", "}", "}", "", "break;", "", "case 401:", "", "{ (yyval.nodes).refine = actual;", "actual_type = REFINE_KEYWORD;", "}", "", "break;", "", "case 402:", "", "{ actual = (yyvsp[-2].nodes).refine;", "actual_type = REFINE_KEYWORD;", "if ((yyvsp[-2].nodes).refine->target_type) {", "if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML)) {", "(yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML);", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"must\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYXML;", "}", "}", "", "break;", "", "case 403:", "", "{", "", "if ((yyvsp[-2].nodes).refine->target_type) {", "if ((yyvsp[-2].nodes).refine->target_type & (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA)) {", "(yyvsp[-2].nodes).refine->target_type &= (LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA);", "} else {", "free(s);", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"if-feature\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-2].nodes).refine->target_type = LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_CONTAINER | LYS_ANYDATA;", "}", "}", "", "break;", "", "case 404:", "", "{ if ((yyvsp[-1].nodes).refine->target_type) {", "if ((yyvsp[-1].nodes).refine->target_type & LYS_CONTAINER) {", "if ((yyvsp[-1].nodes).refine->mod.presence) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"presence\", \"refine\");", "free(s);", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;", "(yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);", "} else {", "free(s);", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"presence\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-1].nodes).refine->target_type = LYS_CONTAINER;", "(yyvsp[-1].nodes).refine->mod.presence = lydict_insert_zc(trg->ctx, s);", "}", "s = NULL;", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 405:", "", "{ int i;", "", "if ((yyvsp[-1].nodes).refine->dflt_size) {", "if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"default\", \"refine\");", "YYABORT;", "}", "if ((yyvsp[-1].nodes).refine->target_type & LYS_LEAFLIST) {", "(yyvsp[-1].nodes).refine->target_type = LYS_LEAFLIST;", "} else {", "free(s);", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "if ((yyvsp[-1].nodes).refine->target_type) {", "if (trg->version < 2 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE))) {", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE);", "} if (trg->version > 1 && ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE))) {", "", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE);", "} else {", "free(s);", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "if (trg->version < 2) {", "(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE;", "} else {", "", "(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_LEAFLIST | LYS_CHOICE;", "}", "}", "}", "", "for (i = 0; i < (yyvsp[-1].nodes).refine->dflt_size; ++i) {", "if (ly_strequal((yyvsp[-1].nodes).refine->dflt[i], s, 0)) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"default\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Duplicated default value \\\"%s\\\".\", s);", "YYABORT;", "}", "}", "YANG_ADDELEM((yyvsp[-1].nodes).refine->dflt, (yyvsp[-1].nodes).refine->dflt_size, \"defaults\");", "*((const char **)actual) = lydict_insert_zc(trg->ctx, s);", "actual = (yyvsp[-1].nodes).refine;", "s = NULL;", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 406:", "", "{ if ((yyvsp[-1].nodes).refine->target_type) {", "if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST)) {", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST);", "if ((yyvsp[-1].nodes).refine->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"refine\");", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"config\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_LIST | LYS_CONTAINER | LYS_LEAFLIST;", "(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);", "}", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 407:", "", "{ if ((yyvsp[-1].nodes).refine->target_type) {", "if ((yyvsp[-1].nodes).refine->target_type & (LYS_LEAF | LYS_CHOICE | LYS_ANYXML)) {", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LEAF | LYS_CHOICE | LYS_ANYXML);", "if ((yyvsp[-1].nodes).refine->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"mandatory\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-1].nodes).refine->target_type = LYS_LEAF | LYS_CHOICE | LYS_ANYXML;", "(yyvsp[-1].nodes).refine->flags |= (yyvsp[0].i);", "}", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 408:", "", "{ if ((yyvsp[-1].nodes).refine->target_type) {", "if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);", "if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MINSET) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;", "(yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"min-elements\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;", "(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MINSET;", "(yyvsp[-1].nodes).refine->mod.list.min = (yyvsp[0].uint);", "}", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 409:", "", "{ if ((yyvsp[-1].nodes).refine->target_type) {", "if ((yyvsp[-1].nodes).refine->target_type & (LYS_LIST | LYS_LEAFLIST)) {", "(yyvsp[-1].nodes).refine->target_type &= (LYS_LIST | LYS_LEAFLIST);", "if ((yyvsp[-1].nodes).refine->flags & LYS_RFN_MAXSET) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");", "YYABORT;", "}", "(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;", "(yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"max-elements\", \"refine\");", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid refine target nodetype for the substatements.\");", "YYABORT;", "}", "} else {", "(yyvsp[-1].nodes).refine->target_type = LYS_LIST | LYS_LEAFLIST;", "(yyvsp[-1].nodes).refine->flags |= LYS_RFN_MAXSET;", "(yyvsp[-1].nodes).refine->mod.list.max = (yyvsp[0].uint);", "}", "(yyval.nodes) = (yyvsp[-1].nodes);", "}", "", "break;", "", "case 410:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 411:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).refine, s, \"refine\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 414:", "", "{ void *parent;", "", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "parent = actual;", "YANG_ADDELEM(((struct lys_node_uses *)actual)->augment,", "((struct lys_node_uses *)actual)->augment_size, \"augments\");", "if (yang_read_augment(trg, parent, actual, s)) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = AUGMENT_KEYWORD;", "}", "", "break;", "", "case 415:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 418:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(trg->augment, trg->augment_size, \"augments\");", "if (yang_read_augment(trg, NULL, actual, s)) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = AUGMENT_KEYWORD;", "}", "", "break;", "", "case 419:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing augment statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 420:", "", "{ (yyval.nodes).augment = actual; }", "", "break;", "", "case 423:", "", "{ if ((yyvsp[-1].nodes).augment->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).augment, \"status\", \"augment\");", "YYABORT;", "}", "(yyvsp[-1].nodes).augment->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 424:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 425:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).augment, s, \"augment\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 428:", "", "{ if (trg->version < 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, (yyvsp[-2].nodes).augment, \"notification\");", "YYABORT;", "}", "}", "", "break;", "", "case 430:", "", "{ if (param->module->version != 2) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"action\");", "free(s);", "YYABORT;", "}", "(yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_ACTION, sizeof(struct lys_node_rpc_action)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = ACTION_KEYWORD;", "}", "", "break;", "", "case 431:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing action statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 432:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, NULL, param->node, s, LYS_RPC, sizeof(struct lys_node_rpc_action)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = RPC_KEYWORD;", "}", "", "break;", "", "case 433:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing rpc statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 435:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).node.ptr_rpc->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->iffeature, (yyvsp[-1].nodes).node.ptr_rpc->iffeature_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_rpc->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).node.ptr_rpc->tpdf_size) {", "tmp = realloc((yyvsp[-1].nodes).node.ptr_rpc->tpdf, (yyvsp[-1].nodes).node.ptr_rpc->tpdf_size * sizeof *(yyvsp[-1].nodes).node.ptr_rpc->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_rpc->tpdf = tmp;", "}", "}", "", "break;", "", "case 436:", "", "{ (yyval.nodes).node.ptr_rpc = actual;", "(yyval.nodes).node.flag = 0;", "}", "", "break;", "", "case 438:", "", "{ if ((yyvsp[-1].nodes).node.ptr_rpc->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).node.ptr_rpc, \"status\", \"rpc\");", "YYABORT;", "}", "(yyvsp[-1].nodes).node.ptr_rpc->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 439:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 440:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).node.ptr_rpc, s, \"rpc\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 443:", "", "{ if ((yyvsp[-2].nodes).node.flag & LYS_RPC_INPUT) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"input\", \"rpc\");", "YYABORT;", "}", "(yyvsp[-2].nodes).node.flag |= LYS_RPC_INPUT;", "(yyval.nodes) = (yyvsp[-2].nodes);", "}", "", "break;", "", "case 444:", "", "{ if ((yyvsp[-2].nodes).node.flag & LYS_RPC_OUTPUT) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-2].nodes).node.ptr_rpc, \"output\", \"rpc\");", "YYABORT;", "}", "(yyvsp[-2].nodes).node.flag |= LYS_RPC_OUTPUT;", "(yyval.nodes) = (yyvsp[-2].nodes);", "}", "", "break;", "", "case 445:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "s = strdup(\"input\");", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_INPUT, sizeof(struct lys_node_inout)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = INPUT_KEYWORD;", "}", "", "break;", "", "case 446:", "", "{ void *tmp;", "struct lys_node_inout *input = actual;", "", "if (input->must_size) {", "tmp = realloc(input->must, input->must_size * sizeof *input->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "input->must = tmp;", "}", "", "if (input->tpdf_size) {", "tmp = realloc(input->tpdf, input->tpdf_size * sizeof *input->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "input->tpdf = tmp;", "}", "", "LOGDBG(LY_LDGYANG, \"finished parsing input statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 452:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "s = strdup(\"output\");", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_OUTPUT, sizeof(struct lys_node_inout)))) {", "YYABORT;", "}", "data_node = actual;", "s = NULL;", "actual_type = OUTPUT_KEYWORD;", "}", "", "break;", "", "case 453:", "", "{ void *tmp;", "struct lys_node_inout *output = actual;", "", "if (output->must_size) {", "tmp = realloc(output->must, output->must_size * sizeof *output->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "output->must = tmp;", "}", "", "if (output->tpdf_size) {", "tmp = realloc(output->tpdf, output->tpdf_size * sizeof *output->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "output->tpdf = tmp;", "}", "", "LOGDBG(LY_LDGYANG, \"finished parsing output statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "data_node = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 454:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_node(trg, actual, param->node, s, LYS_NOTIF, sizeof(struct lys_node_notif)))) {", "YYABORT;", "}", "data_node = actual;", "actual_type = NOTIFICATION_KEYWORD;", "}", "", "break;", "", "case 455:", "", "{ LOGDBG(LY_LDGYANG, \"finished parsing notification statement \\\"%s\\\"\", data_node->name);", "actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "data_node = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 457:", "", "{ void *tmp;", "", "if ((yyvsp[-1].nodes).notif->must_size) {", "tmp = realloc((yyvsp[-1].nodes).notif->must, (yyvsp[-1].nodes).notif->must_size * sizeof *(yyvsp[-1].nodes).notif->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).notif->must = tmp;", "}", "", "if ((yyvsp[-1].nodes).notif->iffeature_size) {", "tmp = realloc((yyvsp[-1].nodes).notif->iffeature, (yyvsp[-1].nodes).notif->iffeature_size * sizeof *(yyvsp[-1].nodes).notif->iffeature);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).notif->iffeature = tmp;", "}", "", "if ((yyvsp[-1].nodes).notif->tpdf_size) {", "tmp = realloc((yyvsp[-1].nodes).notif->tpdf, (yyvsp[-1].nodes).notif->tpdf_size * sizeof *(yyvsp[-1].nodes).notif->tpdf);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].nodes).notif->tpdf = tmp;", "}", "}", "", "break;", "", "case 458:", "", "{ (yyval.nodes).notif = actual; }", "", "break;", "", "case 461:", "", "{ if ((yyvsp[-1].nodes).notif->flags & LYS_STATUS_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_LYS, (yyvsp[-1].nodes).notif, \"status\", \"notification\");", "YYABORT;", "}", "(yyvsp[-1].nodes).notif->flags |= (yyvsp[0].i);", "}", "", "break;", "", "case 462:", "", "{ if (yang_read_description(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 463:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].nodes).notif, s, \"notification\", NODE_PRINT)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 467:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "YANG_ADDELEM(trg->deviation, trg->deviation_size, \"deviations\");", "((struct lys_deviation *)actual)->target_name = transform_schema2json(trg, s);", "free(s);", "if (!((struct lys_deviation *)actual)->target_name) {", "YYABORT;", "}", "s = NULL;", "actual_type = DEVIATION_KEYWORD;", "}", "", "break;", "", "case 468:", "", "{ void *tmp;", "", "if ((yyvsp[-1].dev)->deviate_size) {", "tmp = realloc((yyvsp[-1].dev)->deviate, (yyvsp[-1].dev)->deviate_size * sizeof *(yyvsp[-1].dev)->deviate);", "if (!tmp) {", "LOGINT(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].dev)->deviate = tmp;", "} else {", "LOGVAL(trg->ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, \"deviate\", \"deviation\");", "YYABORT;", "}", "actual_type = (yyvsp[-4].backup_token).token;", "actual = (yyvsp[-4].backup_token).actual;", "}", "", "break;", "", "case 469:", "", "{ (yyval.dev) = actual; }", "", "break;", "", "case 470:", "", "{ if (yang_read_description(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {", "YYABORT;", "}", "s = NULL;", "(yyval.dev) = (yyvsp[-1].dev);", "}", "", "break;", "", "case 471:", "", "{ if (yang_read_reference(trg, (yyvsp[-1].dev), s, \"deviation\", NODE)) {", "YYABORT;", "}", "s = NULL;", "(yyval.dev) = (yyvsp[-1].dev);", "}", "", "break;", "", "case 477:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_deviate_unsupported(trg->ctx, actual))) {", "YYABORT;", "}", "actual_type = NOT_SUPPORTED_KEYWORD;", "}", "", "break;", "", "case 478:", "", "{ actual_type = (yyvsp[-2].backup_token).token;", "actual = (yyvsp[-2].backup_token).actual;", "}", "", "break;", "", "case 484:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_ADD))) {", "YYABORT;", "}", "actual_type = ADD_KEYWORD;", "}", "", "break;", "", "case 485:", "", "{ actual_type = (yyvsp[-2].backup_token).token;", "actual = (yyvsp[-2].backup_token).actual;", "}", "", "break;", "", "case 487:", "", "{ void *tmp;", "", "if ((yyvsp[-1].deviate)->must_size) {", "tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->must = tmp;", "}", "", "if ((yyvsp[-1].deviate)->unique_size) {", "tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->unique = tmp;", "}", "", "if ((yyvsp[-1].deviate)->dflt_size) {", "tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->dflt = tmp;", "}", "}", "", "break;", "", "case 488:", "", "{ (yyval.deviate) = actual; }", "", "break;", "", "case 489:", "", "{ if (yang_read_units(trg, actual, s, ADD_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 491:", "", "{ YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");", "((struct lys_unique *)actual)->expr = (const char **)s;", "s = NULL;", "actual = (yyvsp[-1].deviate);", "(yyval.deviate)= (yyvsp[-1].deviate);", "}", "", "break;", "", "case 492:", "", "{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");", "*((const char **)actual) = lydict_insert_zc(trg->ctx, s);", "s = NULL;", "actual = (yyvsp[-1].deviate);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 493:", "", "{ if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->flags = (yyvsp[0].i);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 494:", "", "{ if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->flags = (yyvsp[0].i);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 495:", "", "{ if ((yyvsp[-1].deviate)->min_set) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->min = (yyvsp[0].uint);", "(yyvsp[-1].deviate)->min_set = 1;", "(yyval.deviate) =  (yyvsp[-1].deviate);", "}", "", "break;", "", "case 496:", "", "{ if ((yyvsp[-1].deviate)->max_set) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->max = (yyvsp[0].uint);", "(yyvsp[-1].deviate)->max_set = 1;", "(yyval.deviate) =  (yyvsp[-1].deviate);", "}", "", "break;", "", "case 497:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_DEL))) {", "YYABORT;", "}", "actual_type = DELETE_KEYWORD;", "}", "", "break;", "", "case 498:", "", "{ actual_type = (yyvsp[-2].backup_token).token;", "actual = (yyvsp[-2].backup_token).actual;", "}", "", "break;", "", "case 500:", "", "{ void *tmp;", "", "if ((yyvsp[-1].deviate)->must_size) {", "tmp = realloc((yyvsp[-1].deviate)->must, (yyvsp[-1].deviate)->must_size * sizeof *(yyvsp[-1].deviate)->must);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->must = tmp;", "}", "", "if ((yyvsp[-1].deviate)->unique_size) {", "tmp = realloc((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size * sizeof *(yyvsp[-1].deviate)->unique);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->unique = tmp;", "}", "", "if ((yyvsp[-1].deviate)->dflt_size) {", "tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->dflt = tmp;", "}", "}", "", "break;", "", "case 501:", "", "{ (yyval.deviate) = actual; }", "", "break;", "", "case 502:", "", "{ if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 504:", "", "{ YANG_ADDELEM((yyvsp[-1].deviate)->unique, (yyvsp[-1].deviate)->unique_size, \"uniques\");", "((struct lys_unique *)actual)->expr = (const char **)s;", "s = NULL;", "actual = (yyvsp[-1].deviate);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 505:", "", "{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");", "*((const char **)actual) = lydict_insert_zc(trg->ctx, s);", "s = NULL;", "actual = (yyvsp[-1].deviate);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 506:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_deviate(trg->ctx, actual, LY_DEVIATE_RPL))) {", "YYABORT;", "}", "actual_type = REPLACE_KEYWORD;", "}", "", "break;", "", "case 507:", "", "{ actual_type = (yyvsp[-2].backup_token).token;", "actual = (yyvsp[-2].backup_token).actual;", "}", "", "break;", "", "case 509:", "", "{ void *tmp;", "", "if ((yyvsp[-1].deviate)->dflt_size) {", "tmp = realloc((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size * sizeof *(yyvsp[-1].deviate)->dflt);", "if (!tmp) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyvsp[-1].deviate)->dflt = tmp;", "}", "}", "", "break;", "", "case 510:", "", "{ (yyval.deviate) = actual; }", "", "break;", "", "case 512:", "", "{ if (yang_read_units(trg, actual, s, DELETE_KEYWORD)) {", "YYABORT;", "}", "s = NULL;", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 513:", "", "{ YANG_ADDELEM((yyvsp[-1].deviate)->dflt, (yyvsp[-1].deviate)->dflt_size, \"defaults\");", "*((const char **)actual) = lydict_insert_zc(trg->ctx, s);", "s = NULL;", "actual = (yyvsp[-1].deviate);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 514:", "", "{ if ((yyvsp[-1].deviate)->flags & LYS_CONFIG_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"config\", \"deviate\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->flags = (yyvsp[0].i);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 515:", "", "{ if ((yyvsp[-1].deviate)->flags & LYS_MAND_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"mandatory\", \"deviate\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->flags = (yyvsp[0].i);", "(yyval.deviate) = (yyvsp[-1].deviate);", "}", "", "break;", "", "case 516:", "", "{ if ((yyvsp[-1].deviate)->min_set) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"min-elements\", \"deviation\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->min = (yyvsp[0].uint);", "(yyvsp[-1].deviate)->min_set = 1;", "(yyval.deviate) =  (yyvsp[-1].deviate);", "}", "", "break;", "", "case 517:", "", "{ if ((yyvsp[-1].deviate)->max_set) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"max-elements\", \"deviation\");", "YYABORT;", "}", "(yyvsp[-1].deviate)->max = (yyvsp[0].uint);", "(yyvsp[-1].deviate)->max_set = 1;", "(yyval.deviate) =  (yyvsp[-1].deviate);", "}", "", "break;", "", "case 518:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_when(trg, actual, actual_type, s))) {", "YYABORT;", "}", "s = NULL;", "actual_type = WHEN_KEYWORD;", "}", "", "break;", "", "case 519:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 523:", "", "{ if (yang_read_description(trg, actual, s, \"when\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 524:", "", "{ if (yang_read_reference(trg, actual, s, \"when\", NODE)) {", "YYABORT;", "}", "s = NULL;", "}", "", "break;", "", "case 525:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = CONFIG_KEYWORD;", "}", "", "break;", "", "case 526:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 527:", "", "{ (yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET; }", "", "break;", "", "case 528:", "", "{ (yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET; }", "", "break;", "", "case 529:", "", "{ if (!strcmp(s, \"true\")) {", "(yyval.i) = LYS_CONFIG_W | LYS_CONFIG_SET;", "} else if (!strcmp(s, \"false\")) {", "(yyval.i) = LYS_CONFIG_R | LYS_CONFIG_SET;", "} else {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"config\");", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 530:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = MANDATORY_KEYWORD;", "}", "", "break;", "", "case 531:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 532:", "", "{ (yyval.i) = LYS_MAND_TRUE; }", "", "break;", "", "case 533:", "", "{ (yyval.i) = LYS_MAND_FALSE; }", "", "break;", "", "case 534:", "", "{ if (!strcmp(s, \"true\")) {", "(yyval.i) = LYS_MAND_TRUE;", "} else if (!strcmp(s, \"false\")) {", "(yyval.i) = LYS_MAND_FALSE;", "} else {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"mandatory\");", "free(s);", "YYABORT;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 535:", "", "{ backup_type = actual_type;", "actual_type = PRESENCE_KEYWORD;", "}", "", "break;", "", "case 537:", "", "{ (yyval.uint) = (yyvsp[0].uint);", "backup_type = actual_type;", "actual_type = MIN_ELEMENTS_KEYWORD;", "}", "", "break;", "", "case 538:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 539:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 540:", "", "{ if (strlen(s) == 1 && s[0] == '0') {", "(yyval.uint) = 0;", "} else {", "", "uint64_t val;", "char *endptr = NULL;", "errno = 0;", "", "val = strtoul(s, &endptr, 10);", "if (*endptr || s[0] == '-' || errno || val > UINT32_MAX) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"min-elements\");", "free(s);", "YYABORT;", "}", "(yyval.uint) = (uint32_t) val;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 541:", "", "{ (yyval.uint) = (yyvsp[0].uint);", "backup_type = actual_type;", "actual_type = MAX_ELEMENTS_KEYWORD;", "}", "", "break;", "", "case 542:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 543:", "", "{ (yyval.uint) = 0; }", "", "break;", "", "case 544:", "", "{ (yyval.uint) = (yyvsp[-1].uint); }", "", "break;", "", "case 545:", "", "{ if (!strcmp(s, \"unbounded\")) {", "(yyval.uint) = 0;", "} else {", "", "uint64_t val;", "char *endptr = NULL;", "errno = 0;", "", "val = strtoul(s, &endptr, 10);", "if (*endptr || s[0] == '-' || errno || val == 0 || val > UINT32_MAX) {", "LOGVAL(trg->ctx, LYE_INARG, LY_VLOG_NONE, NULL, s, \"max-elements\");", "free(s);", "YYABORT;", "}", "(yyval.uint) = (uint32_t) val;", "}", "free(s);", "s = NULL;", "}", "", "break;", "", "case 546:", "", "{ (yyval.i) = (yyvsp[0].i);", "backup_type = actual_type;", "actual_type = ORDERED_BY_KEYWORD;", "}", "", "break;", "", "case 547:", "", "{ (yyval.i) = (yyvsp[-1].i); }", "", "break;", "", "case 548:", "", "{ (yyval.i) = LYS_USERORDERED; }", "", "break;", "", "case 549:", "", "{ (yyval.i) = LYS_SYSTEMORDERED; }", "", "break;", "", "case 550:", "", "{ if (!strcmp(s, \"user\")) {", "(yyval.i) = LYS_USERORDERED;", "} else if (!strcmp(s, \"system\")) {", "(yyval.i) = LYS_SYSTEMORDERED;", "} else {", "free(s);", "YYABORT;", "}", "free(s);", "s=NULL;", "}", "", "break;", "", "case 551:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "switch (actual_type) {", "case CONTAINER_KEYWORD:", "YANG_ADDELEM(((struct lys_node_container *)actual)->must,", "((struct lys_node_container *)actual)->must_size, \"musts\");", "break;", "case ANYDATA_KEYWORD:", "case ANYXML_KEYWORD:", "YANG_ADDELEM(((struct lys_node_anydata *)actual)->must,", "((struct lys_node_anydata *)actual)->must_size, \"musts\");", "break;", "case LEAF_KEYWORD:", "YANG_ADDELEM(((struct lys_node_leaf *)actual)->must,", "((struct lys_node_leaf *)actual)->must_size, \"musts\");", "break;", "case LEAF_LIST_KEYWORD:", "YANG_ADDELEM(((struct lys_node_leaflist *)actual)->must,", "((struct lys_node_leaflist *)actual)->must_size, \"musts\");", "break;", "case LIST_KEYWORD:", "YANG_ADDELEM(((struct lys_node_list *)actual)->must,", "((struct lys_node_list *)actual)->must_size, \"musts\");", "break;", "case REFINE_KEYWORD:", "YANG_ADDELEM(((struct lys_refine *)actual)->must,", "((struct lys_refine *)actual)->must_size, \"musts\");", "break;", "case ADD_KEYWORD:", "case DELETE_KEYWORD:", "YANG_ADDELEM(((struct lys_deviate *)actual)->must,", "((struct lys_deviate *)actual)->must_size, \"musts\");", "break;", "case NOTIFICATION_KEYWORD:", "if (trg->version < 2) {", "free(s);", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_node_notif *)actual)->must,", "((struct lys_node_notif *)actual)->must_size, \"musts\");", "break;", "case INPUT_KEYWORD:", "case OUTPUT_KEYWORD:", "if (trg->version < 2) {", "free(s);", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_LYS, actual, \"must\");", "YYABORT;", "}", "YANG_ADDELEM(((struct lys_node_inout *)actual)->must,", "((struct lys_node_inout *)actual)->must_size, \"musts\");", "break;", "case EXTENSION_INSTANCE:", "", "break;", "default:", "free(s);", "LOGINT(trg->ctx);", "YYABORT;", "}", "((struct lys_restr *)actual)->expr = transform_schema2json(trg, s);", "free(s);", "if (!((struct lys_restr *)actual)->expr) {", "YYABORT;", "}", "s = NULL;", "actual_type = MUST_KEYWORD;", "}", "", "break;", "", "case 552:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 555:", "", "{ backup_type = actual_type;", "actual_type = UNIQUE_KEYWORD;", "}", "", "break;", "", "case 559:", "", "{ backup_type = actual_type;", "actual_type = KEY_KEYWORD;", "}", "", "break;", "", "case 561:", "", "{ s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "}", "", "break;", "", "case 564:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_range(trg->ctx, actual, s, is_ext_instance))) {", "YYABORT;", "}", "actual_type = RANGE_KEYWORD;", "s = NULL;", "}", "", "break;", "", "case 565:", "", "{ if (s) {", "s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 2);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "strcat(s,\"/\");", "strcat(s, yyget_text(scanner));", "} else {", "s = malloc(yyget_leng(scanner) + 2);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "s[0]='/';", "memcpy(s + 1, yyget_text(scanner), yyget_leng(scanner) + 1);", "}", "}", "", "break;", "", "case 569:", "", "{ if (s) {", "s = ly_realloc(s,strlen(s) + yyget_leng(scanner) + 1);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "strcat(s, yyget_text(scanner));", "} else {", "s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "}", "}", "", "break;", "", "case 571:", "", "{ tmp_s = yyget_text(scanner); }", "", "break;", "", "case 572:", "", "{ s = strdup(tmp_s);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "s[strlen(s) - 1] = '\\0';", "}", "", "break;", "", "case 573:", "", "{ tmp_s = yyget_text(scanner); }", "", "break;", "", "case 574:", "", "{ s = strdup(tmp_s);", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "s[strlen(s) - 1] = '\\0';", "}", "", "break;", "", "case 598:", "", "{", "unsigned long val;", "", "val = strtoul(yyget_text(scanner), NULL, 10);", "if (val > UINT32_MAX) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Converted number is very long.\");", "YYABORT;", "}", "(yyval.uint) = (uint32_t) val;", "}", "", "break;", "", "case 599:", "", "{ (yyval.uint) = 0; }", "", "break;", "", "case 600:", "", "{ (yyval.uint) = (yyvsp[0].uint); }", "", "break;", "", "case 601:", "", "{ (yyval.i) = 0; }", "", "break;", "", "case 602:", "", "{", "int64_t val;", "", "val = strtoll(yyget_text(scanner), NULL, 10);", "if (val < INT32_MIN || val > INT32_MAX) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,", "\"The number is not in the correct range (INT32_MIN..INT32_MAX): \\\"%d\\\"\",val);", "YYABORT;", "}", "(yyval.i) = (int32_t) val;", "}", "", "break;", "", "case 608:", "", "{ if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {", "free(s);", "YYABORT;", "}", "}", "", "break;", "", "case 613:", "", "{ char *tmp;", "", "if ((tmp = strchr(s, ':'))) {", "*tmp = '\\0';", "", "if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {", "free(s);", "YYABORT;", "}", "", "if (lyp_check_identifier(trg->ctx, tmp + 1, LY_IDENT_SIMPLE, trg, NULL)) {", "free(s);", "YYABORT;", "}", "*tmp = ':';", "} else {", "", "if (lyp_check_identifier(trg->ctx, s, LY_IDENT_SIMPLE, trg, NULL)) {", "free(s);", "YYABORT;", "}", "}", "}", "", "break;", "", "case 614:", "", "{ s = (yyvsp[-1].str); }", "", "break;", "", "case 615:", "", "{ s = (yyvsp[-3].str); }", "", "break;", "", "case 616:", "", "{ actual_type = backup_type;", "backup_type = NODE;", "(yyval.str) = s;", "s = NULL;", "}", "", "break;", "", "case 617:", "", "{ actual_type = backup_type;", "backup_type = NODE;", "}", "", "break;", "", "case 618:", "", "{ (yyval.str) = s;", "s = NULL;", "}", "", "break;", "", "case 622:", "", "{ actual_type = (yyvsp[-1].backup_token).token;", "actual = (yyvsp[-1].backup_token).actual;", "}", "", "break;", "", "case 623:", "", "{ (yyval.backup_token).token = actual_type;", "(yyval.backup_token).actual = actual;", "if (!(actual = yang_read_ext(trg, (actual) ? actual : trg, (yyvsp[-1].str), s,", "actual_type, backup_type, is_ext_instance))) {", "YYABORT;", "}", "s = NULL;", "actual_type = EXTENSION_INSTANCE;", "}", "", "break;", "", "case 624:", "", "{ (yyval.str) = s; s = NULL; }", "", "break;", "", "case 639:", "", "{  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;", "int32_t length = 0, old_length = 0;", "char *tmp_value;", "", "if (!substmt) {", "substmt = calloc(1, sizeof *substmt);", "if (!substmt) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_ext_instance *)actual)->parent = substmt;", "}", "length = strlen((yyvsp[-2].str));", "old_length = (substmt->ext_substmt) ? strlen(substmt->ext_substmt) + 2 : 2;", "tmp_value = realloc(substmt->ext_substmt, old_length + length + 1);", "if (!tmp_value) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "substmt->ext_substmt = tmp_value;", "tmp_value += old_length - 2;", "memcpy(tmp_value, (yyvsp[-2].str), length);", "tmp_value[length] = ' ';", "tmp_value[length + 1] = '\\0';", "tmp_value[length + 2] = '\\0';", "}", "", "break;", "", "case 640:", "", "{  struct yang_ext_substmt *substmt = ((struct lys_ext_instance *)actual)->parent;", "int32_t length;", "char *tmp_value, **array;", "int i = 0;", "", "if (!substmt) {", "substmt = calloc(1, sizeof *substmt);", "if (!substmt) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "((struct lys_ext_instance *)actual)->parent = substmt;", "}", "length = strlen((yyvsp[-2].str));", "if (!substmt->ext_modules) {", "array = malloc(2 * sizeof *substmt->ext_modules);", "} else {", "for (i = 0; substmt->ext_modules[i]; ++i);", "array = realloc(substmt->ext_modules, (i + 2) * sizeof *substmt->ext_modules);", "}", "if (!array) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "substmt->ext_modules = array;", "array[i + 1] = NULL;", "tmp_value = malloc(length + 2);", "if (!tmp_value) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "array[i] = tmp_value;", "memcpy(tmp_value, (yyvsp[-2].str), length);", "tmp_value[length] = '\\0';", "tmp_value[length + 1] = '\\0';", "}", "", "break;", "", "case 643:", "", "{ (yyval.str) = yyget_text(scanner); }", "", "break;", "", "case 644:", "", "{ (yyval.str) = yyget_text(scanner); }", "", "break;", "", "case 656:", "", "{ s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "}", "", "break;", "", "case 749:", "", "{ s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "}", "", "break;", "", "case 750:", "", "{ s = strdup(yyget_text(scanner));", "if (!s) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "}", "", "break;", "", "case 751:", "", "{ struct lys_type **type;", "", "type = (struct lys_type **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"type\", LY_STMT_TYPE);", "if (!type) {", "YYABORT;", "}", "", "(*type) = calloc(1, sizeof **type);", "if (!*type) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "", "", "(*type)->parent = (struct lys_tpdf *)ext_instance;", "(yyval.v) = actual = *type;", "is_ext_instance = 0;", "}", "", "break;", "", "case 752:", "", "{ struct lys_tpdf **tpdf;", "", "tpdf = (struct lys_tpdf **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"typedef\", LY_STMT_TYPEDEF);", "if (!tpdf) {", "YYABORT;", "}", "", "(*tpdf) = calloc(1, sizeof **tpdf);", "if (!*tpdf) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "", "(yyval.v) = actual = *tpdf;", "is_ext_instance = 0;", "}", "", "break;", "", "case 753:", "", "{ struct lys_iffeature **iffeature;", "", "iffeature = (struct lys_iffeature **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"if-feature\", LY_STMT_IFFEATURE);", "if (!iffeature) {", "YYABORT;", "}", "", "(*iffeature) = calloc(1, sizeof **iffeature);", "if (!*iffeature) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyval.v) = actual = *iffeature;", "}", "", "break;", "", "case 754:", "", "{ struct lys_restr **restr;", "LY_STMT stmt;", "", "s = yyget_text(scanner);", "if (!strcmp(s, \"must\")) {", "stmt = LY_STMT_MUST;", "} else if (!strcmp(s, \"pattern\")) {", "stmt = LY_STMT_PATTERN;", "} else if (!strcmp(s, \"range\")) {", "stmt = LY_STMT_RANGE;", "} else {", "stmt = LY_STMT_LENGTH;", "}", "restr = (struct lys_restr **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, s, stmt);", "if (!restr) {", "YYABORT;", "}", "", "(*restr) = calloc(1, sizeof(struct lys_restr));", "if (!*restr) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "(yyval.v) = actual = *restr;", "s = NULL;", "}", "", "break;", "", "case 755:", "", "{ actual = yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name, \"when\", LY_STMT_WHEN);", "if (!actual) {", "YYABORT;", "}", "(yyval.v) = actual;", "}", "", "break;", "", "case 756:", "", "{ struct lys_revision **rev;", "int i;", "", "rev = (struct lys_revision **)yang_getplace_for_extcomplex_struct(ext_instance, &i, ext_name,", "\"revision\", LY_STMT_REVISION);", "if (!rev) {", "YYABORT;", "}", "rev[i] = calloc(1, sizeof **rev);", "if (!rev[i]) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "actual = rev[i];", "(yyval.revisions).revision = rev;", "(yyval.revisions).index = i;", "}", "", "break;", "", "case 757:", "", "{ LY_STMT stmt;", "", "s = yyget_text(scanner);", "if (!strcmp(s, \"action\")) {", "stmt = LY_STMT_ACTION;", "} else if (!strcmp(s, \"anydata\")) {", "stmt = LY_STMT_ANYDATA;", "} else if (!strcmp(s, \"anyxml\")) {", "stmt = LY_STMT_ANYXML;", "} else if (!strcmp(s, \"case\")) {", "stmt = LY_STMT_CASE;", "} else if (!strcmp(s, \"choice\")) {", "stmt = LY_STMT_CHOICE;", "} else if (!strcmp(s, \"container\")) {", "stmt = LY_STMT_CONTAINER;", "} else if (!strcmp(s, \"grouping\")) {", "stmt = LY_STMT_GROUPING;", "} else if (!strcmp(s, \"input\")) {", "stmt = LY_STMT_INPUT;", "} else if (!strcmp(s, \"leaf\")) {", "stmt = LY_STMT_LEAF;", "} else if (!strcmp(s, \"leaf-list\")) {", "stmt = LY_STMT_LEAFLIST;", "} else if (!strcmp(s, \"list\")) {", "stmt = LY_STMT_LIST;", "} else if (!strcmp(s, \"notification\")) {", "stmt = LY_STMT_NOTIFICATION;", "} else if (!strcmp(s, \"output\")) {", "stmt = LY_STMT_OUTPUT;", "} else {", "stmt = LY_STMT_USES;", "}", "if (yang_extcomplex_node(ext_instance, ext_name, s, *param->node, stmt)) {", "YYABORT;", "}", "actual = NULL;", "s = NULL;", "is_ext_instance = 0;", "}", "", "break;", "", "case 758:", "", "{ LOGERR(trg->ctx, ly_errno, \"Extension's substatement \\\"%s\\\" not supported.\", yyget_text(scanner)); }", "", "break;", "", "case 790:", "", "{ actual_type = EXTENSION_INSTANCE;", "actual = ext_instance;", "if (!is_ext_instance) {", "LOGVAL(trg->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));", "YYABORT;", "}", "(yyval.i) = 0;", "}", "", "break;", "", "case 792:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"prefix\", ext_name, &s,", "0, LY_STMT_PREFIX)) {", "YYABORT;", "}", "}", "", "break;", "", "case 793:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"description\", ext_name, &s,", "0, LY_STMT_DESCRIPTION)) {", "YYABORT;", "}", "}", "", "break;", "", "case 794:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"reference\", ext_name, &s,", "0, LY_STMT_REFERENCE)) {", "YYABORT;", "}", "}", "", "break;", "", "case 795:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"units\", ext_name, &s,", "0, LY_STMT_UNITS)) {", "YYABORT;", "}", "}", "", "break;", "", "case 796:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"base\", ext_name, &s,", "0, LY_STMT_BASE)) {", "YYABORT;", "}", "}", "", "break;", "", "case 797:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"contact\", ext_name, &s,", "0, LY_STMT_CONTACT)) {", "YYABORT;", "}", "}", "", "break;", "", "case 798:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"default\", ext_name, &s,", "0, LY_STMT_DEFAULT)) {", "YYABORT;", "}", "}", "", "break;", "", "case 799:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"error-message\", ext_name, &s,", "0, LY_STMT_ERRMSG)) {", "YYABORT;", "}", "}", "", "break;", "", "case 800:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"error-app-tag\", ext_name, &s,", "0, LY_STMT_ERRTAG)) {", "YYABORT;", "}", "}", "", "break;", "", "case 801:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"key\", ext_name, &s,", "0, LY_STMT_KEY)) {", "YYABORT;", "}", "}", "", "break;", "", "case 802:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"namespace\", ext_name, &s,", "0, LY_STMT_NAMESPACE)) {", "YYABORT;", "}", "}", "", "break;", "", "case 803:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"organization\", ext_name, &s,", "0, LY_STMT_ORGANIZATION)) {", "YYABORT;", "}", "}", "", "break;", "", "case 804:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"path\", ext_name, &s,", "0, LY_STMT_PATH)) {", "YYABORT;", "}", "}", "", "break;", "", "case 805:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"presence\", ext_name, &s,", "0, LY_STMT_PRESENCE)) {", "YYABORT;", "}", "}", "", "break;", "", "case 806:", "", "{ if (yang_read_extcomplex_str(trg, ext_instance, \"revision-date\", ext_name, &s,", "0, LY_STMT_REVISIONDATE)) {", "YYABORT;", "}", "}", "", "break;", "", "case 807:", "", "{ struct lys_type *type = (yyvsp[-2].v);", "", "if (yang_fill_type(trg, type, (struct yang_type *)type->der, ext_instance, param->unres)) {", "yang_type_free(trg->ctx, type);", "YYABORT;", "}", "if (unres_schema_add_node(trg, param->unres, type, UNRES_TYPE_DER_EXT, NULL) == -1) {", "yang_type_free(trg->ctx, type);", "YYABORT;", "}", "actual = ext_instance;", "is_ext_instance = 1;", "}", "", "break;", "", "case 808:", "", "{ struct lys_tpdf *tpdf = (yyvsp[-2].v);", "", "if (yang_fill_type(trg, &tpdf->type, (struct yang_type *)tpdf->type.der, tpdf, param->unres)) {", "yang_type_free(trg->ctx, &tpdf->type);", "}", "if (yang_check_ext_instance(trg, &tpdf->ext, tpdf->ext_size, tpdf, param->unres)) {", "YYABORT;", "}", "if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DER_TPDF, (struct lys_node *)ext_instance) == -1) {", "yang_type_free(trg->ctx, &tpdf->type);", "YYABORT;", "}", "", "if (unres_schema_add_node(trg, param->unres, &tpdf->type, UNRES_TYPE_DFLT, (struct lys_node *)(&tpdf->dflt)) == -1)  {", "YYABORT;", "}", "actual = ext_instance;", "is_ext_instance = 1;", "}", "", "break;", "", "case 809:", "", "{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"status\", LY_STMT_STATUS,", "(yyvsp[0].i), LYS_STATUS_MASK)) {", "YYABORT;", "}", "}", "", "break;", "", "case 810:", "", "{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"config\", LY_STMT_CONFIG,", "(yyvsp[0].i), LYS_CONFIG_MASK)) {", "YYABORT;", "}", "}", "", "break;", "", "case 811:", "", "{ if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"mandatory\", LY_STMT_MANDATORY,", "(yyvsp[0].i), LYS_MAND_MASK)) {", "YYABORT;", "}", "}", "", "break;", "", "case 812:", "", "{ if ((yyvsp[-1].i) & LYS_ORDERED_MASK) {", "LOGVAL(trg->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, \"ordered by\", ext_name);", "YYABORT;", "}", "if ((yyvsp[0].i) & LYS_USERORDERED) {", "if (yang_fill_extcomplex_flags(ext_instance, ext_name, \"ordered-by\", LY_STMT_ORDEREDBY,", "(yyvsp[0].i), LYS_USERORDERED)) {", "YYABORT;", "}", "}", "(yyvsp[-1].i) |= (yyvsp[0].i);", "(yyval.i) = (yyvsp[-1].i);", "}", "", "break;", "", "case 813:", "", "{ if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"require-instance\",", "LY_STMT_REQINSTANCE, (yyvsp[0].i))) {", "YYABORT;", "}", "}", "", "break;", "", "case 814:", "", "{ if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"modifier\", LY_STMT_MODIFIER, 0)) {", "YYABORT;", "}", "}", "", "break;", "", "case 815:", "", "{", "if ((yyvsp[0].uint) < 1 || (yyvsp[0].uint) > 18) {", "LOGVAL(trg->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", (yyvsp[0].uint), \"fraction-digits\");", "YYABORT;", "}", "if (yang_fill_extcomplex_uint8(ext_instance, ext_name, \"fraction-digits\", LY_STMT_DIGITS, (yyvsp[0].uint))) {", "YYABORT;", "}", "}", "", "break;", "", "case 816:", "", "{ uint32_t **val;", "", "val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"min-elements\", LY_STMT_MIN);", "if (!val) {", "YYABORT;", "}", "", "*val = malloc(sizeof(uint32_t));", "if (!*val) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "**val = (yyvsp[0].uint);", "}", "", "break;", "", "case 817:", "", "{ uint32_t **val;", "", "val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"max-elements\", LY_STMT_MAX);", "if (!val) {", "YYABORT;", "}", "", "*val = malloc(sizeof(uint32_t));", "if (!*val) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "**val = (yyvsp[0].uint);", "}", "", "break;", "", "case 818:", "", "{ uint32_t **val;", "", "val = (uint32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"position\", LY_STMT_POSITION);", "if (!val) {", "YYABORT;", "}", "", "*val = malloc(sizeof(uint32_t));", "if (!*val) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "**val = (yyvsp[0].uint);", "}", "", "break;", "", "case 819:", "", "{ int32_t **val;", "", "val = (int32_t **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"value\", LY_STMT_VALUE);", "if (!val) {", "YYABORT;", "}", "", "*val = malloc(sizeof(int32_t));", "if (!*val) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "**val = (yyvsp[0].i);", "}", "", "break;", "", "case 820:", "", "{ struct lys_unique **unique;", "int rc;", "", "unique = (struct lys_unique **)yang_getplace_for_extcomplex_struct(ext_instance, NULL, ext_name,", "\"unique\", LY_STMT_UNIQUE);", "if (!unique) {", "YYABORT;", "}", "*unique = calloc(1, sizeof(struct lys_unique));", "if (!*unique) {", "LOGMEM(trg->ctx);", "YYABORT;", "}", "rc = yang_fill_unique(trg, (struct lys_node_list *)ext_instance, *unique, s, param->unres);", "free(s);", "s = NULL;", "if (rc) {", "YYABORT;", "}", "}", "", "break;", "", "case 821:", "", "{ struct lys_iffeature *iffeature;", "", "iffeature = (yyvsp[-2].v);", "s = (char *)iffeature->features;", "iffeature->features = NULL;", "if (yang_fill_iffeature(trg, iffeature, ext_instance, s, param->unres, 0)) {", "YYABORT;", "}", "if (yang_check_ext_instance(trg, &iffeature->ext, iffeature->ext_size, iffeature, param->unres)) {", "YYABORT;", "}", "s = NULL;", "actual = ext_instance;", "}", "", "break;", "", "case 823:", "", "{ if (yang_check_ext_instance(trg, &((struct lys_restr *)(yyvsp[-2].v))->ext, ((struct lys_restr *)(yyvsp[-2].v))->ext_size, (yyvsp[-2].v), param->unres)) {", "YYABORT;", "}", "actual = ext_instance;", "}", "", "break;", "", "case 824:", "", "{ if (yang_check_ext_instance(trg, &(*(struct lys_when **)(yyvsp[-2].v))->ext, (*(struct lys_when **)(yyvsp[-2].v))->ext_size,", "*(struct lys_when **)(yyvsp[-2].v), param->unres)) {", "YYABORT;", "}", "actual = ext_instance;", "}", "", "break;", "", "case 825:", "", "{ int i;", "", "for (i = 0; i < (yyvsp[-2].revisions).index; ++i) {", "if (!strcmp((yyvsp[-2].revisions).revision[i]->date, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->date)) {", "LOGWRN(trg->ctx, \"Module's revisions are not unique (%s).\", (yyvsp[-2].revisions).revision[i]->date);", "break;", "}", "}", "if (yang_check_ext_instance(trg, &(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext, (yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index]->ext_size,", "&(yyvsp[-2].revisions).revision[(yyvsp[-2].revisions).index], param->unres)) {", "YYABORT;", "}", "actual = ext_instance;", "}", "", "break;", "", "case 826:", "", "{ actual = ext_instance;", "is_ext_instance = 1;", "}", "", "break;", "", "", "", "default: break;", "}", "", "", "", "", "", "", "", "", "", "", "", "YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", "", "YYPOPSTACK (yylen);", "yylen = 0;", "YY_STACK_PRINT (yyss, yyssp);", "", "*++yyvsp = yyval;", "*++yylsp = yyloc;", "", "", "", "", "{", "const int yylhs = yyr1[yyn] - YYNTOKENS;", "const int yyi = yypgoto[yylhs] + *yyssp;", "yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp", "? yytable[yyi]", ": yydefgoto[yylhs]);", "}", "", "goto yynewstate;", "", "", "", "", "", "yyerrlab:", "", "", "yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", "", "", "if (!yyerrstatus)", "{", "++yynerrs;", "#if ! YYERROR_VERBOSE", "yyerror (&yylloc, scanner, param, YY_(\"syntax error\"));", "#else", "# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                        yyssp, yytoken)", "{", "char const *yymsgp = YY_(\"syntax error\");", "int yysyntax_error_status;", "yysyntax_error_status = YYSYNTAX_ERROR;", "if (yysyntax_error_status == 0)", "yymsgp = yymsg;", "else if (yysyntax_error_status == 1)", "{", "if (yymsg != yymsgbuf)", "YYSTACK_FREE (yymsg);", "yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "if (!yymsg)", "{", "yymsg = yymsgbuf;", "yymsg_alloc = sizeof yymsgbuf;", "yysyntax_error_status = 2;", "}", "else", "{", "yysyntax_error_status = YYSYNTAX_ERROR;", "yymsgp = yymsg;", "}", "}", "yyerror (&yylloc, scanner, param, yymsgp);", "if (yysyntax_error_status == 2)", "goto yyexhaustedlab;", "}", "# undef YYSYNTAX_ERROR", "#endif", "}", "", "yyerror_range[1] = yylloc;", "", "if (yyerrstatus == 3)", "{", "", "", "", "if (yychar <= YYEOF)", "{", "", "if (yychar == YYEOF)", "YYABORT;", "}", "else", "{", "yydestruct (\"Error: discarding\",", "yytoken, &yylval, &yylloc, scanner, param);", "yychar = YYEMPTY;", "}", "}", "", "", "", "goto yyerrlab1;", "", "", "", "", "", "yyerrorlab:", "", "", "", "", "if (              0)", "goto yyerrorlab;", "", "", "", "YYPOPSTACK (yylen);", "yylen = 0;", "YY_STACK_PRINT (yyss, yyssp);", "yystate = *yyssp;", "goto yyerrlab1;", "", "", "", "", "", "yyerrlab1:", "yyerrstatus = 3;", "", "for (;;)", "{", "yyn = yypact[yystate];", "if (!yypact_value_is_default (yyn))", "{", "yyn += YYTERROR;", "if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "{", "yyn = yytable[yyn];", "if (0 < yyn)", "break;", "}", "}", "", "", "if (yyssp == yyss)", "YYABORT;", "", "yyerror_range[1] = *yylsp;", "yydestruct (\"Error: popping\",", "yystos[yystate], yyvsp, yylsp, scanner, param);", "YYPOPSTACK (1);", "yystate = *yyssp;", "YY_STACK_PRINT (yyss, yyssp);", "}", "", "YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "*++yyvsp = yylval;", "YY_IGNORE_MAYBE_UNINITIALIZED_END", "", "yyerror_range[2] = yylloc;", "", "", "YYLLOC_DEFAULT (yyloc, yyerror_range, 2);", "*++yylsp = yyloc;", "", "", "YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", "", "yystate = yyn;", "goto yynewstate;", "", "", "", "", "", "yyacceptlab:", "yyresult = 0;", "goto yyreturn;", "", "", "", "", "yyabortlab:", "yyresult = 1;", "goto yyreturn;", "", "#if !defined yyoverflow || YYERROR_VERBOSE", "", "", "", "yyexhaustedlab:", "yyerror (&yylloc, scanner, param, YY_(\"memory exhausted\"));", "yyresult = 2;", "", "#endif", "", "yyreturn:", "if (yychar != YYEMPTY)", "{", "", "", "yytoken = YYTRANSLATE (yychar);", "yydestruct (\"Cleanup: discarding lookahead\",", "yytoken, &yylval, &yylloc, scanner, param);", "}", "", "", "YYPOPSTACK (yylen);", "YY_STACK_PRINT (yyss, yyssp);", "while (yyssp != yyss)", "{", "yydestruct (\"Cleanup: popping\",", "yystos[*yyssp], yyvsp, yylsp, scanner, param);", "YYPOPSTACK (1);", "}", "#ifndef yyoverflow", "if (yyss != yyssa)", "YYSTACK_FREE (yyss);", "#endif", "#if YYERROR_VERBOSE", "if (yymsg != yymsgbuf)", "YYSTACK_FREE (yymsg);", "#endif", "return yyresult;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Perl_my_setenv(pTHX_ const char *nam, const char *val)", "{", "dVAR;", "char *envstr;", "const int nlen = strlen(nam);", "int vlen;", "", "if (!val) {", "val = \"\";", "}", "vlen = strlen(val);", "Newx(envstr, nlen+vlen+2, char);", "my_setenv_format(envstr, nam, nlen, val, vlen);", "(void)PerlEnv_putenv(envstr);", "Safefree(envstr);", "}"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["int main (int argc, char **argv) {", "int c;", "bool lock_memory = false;", "bool do_daemonize = false;", "bool preallocate = false;", "int maxcore = 0;", "char *username = NULL;", "char *pid_file = NULL;", "struct passwd *pw;", "struct rlimit rlim;", "char *buf;", "char unit = '\\0';", "int size_max = 0;", "int retval = EXIT_SUCCESS;", "", "static int *l_socket = NULL;", "", "", "static int *u_socket = NULL;", "bool protocol_specified = false;", "bool tcp_specified = false;", "bool udp_specified = false;", "bool start_lru_maintainer = true;", "bool start_lru_crawler = true;", "bool start_assoc_maint = true;", "enum hashfunc_type hash_type = MURMUR3_HASH;", "uint32_t tocrawl;", "uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];", "bool use_slab_sizes = false;", "char *slab_sizes_unparsed = NULL;", "bool slab_chunk_size_changed = false;", "#ifdef EXTSTORE", "void *storage = NULL;", "char *storage_file = NULL;", "struct extstore_conf ext_cf;", "#endif", "char *subopts, *subopts_orig;", "char *subopts_value;", "enum {", "MAXCONNS_FAST = 0,", "HASHPOWER_INIT,", "NO_HASHEXPAND,", "SLAB_REASSIGN,", "SLAB_AUTOMOVE,", "SLAB_AUTOMOVE_RATIO,", "SLAB_AUTOMOVE_WINDOW,", "TAIL_REPAIR_TIME,", "HASH_ALGORITHM,", "LRU_CRAWLER,", "LRU_CRAWLER_SLEEP,", "LRU_CRAWLER_TOCRAWL,", "LRU_MAINTAINER,", "HOT_LRU_PCT,", "WARM_LRU_PCT,", "HOT_MAX_FACTOR,", "WARM_MAX_FACTOR,", "TEMPORARY_TTL,", "IDLE_TIMEOUT,", "WATCHER_LOGBUF_SIZE,", "WORKER_LOGBUF_SIZE,", "SLAB_SIZES,", "SLAB_CHUNK_MAX,", "TRACK_SIZES,", "NO_INLINE_ASCII_RESP,", "MODERN,", "NO_MODERN,", "NO_CHUNKED_ITEMS,", "NO_SLAB_REASSIGN,", "NO_SLAB_AUTOMOVE,", "NO_MAXCONNS_FAST,", "INLINE_ASCII_RESP,", "NO_LRU_CRAWLER,", "NO_LRU_MAINTAINER,", "NO_DROP_PRIVILEGES,", "#ifdef MEMCACHED_DEBUG", "RELAXED_PRIVILEGES,", "#endif", "#ifdef EXTSTORE", "EXT_PAGE_SIZE,", "EXT_PAGE_COUNT,", "EXT_WBUF_SIZE,", "EXT_THREADS,", "EXT_IO_DEPTH,", "EXT_PATH,", "EXT_ITEM_SIZE,", "EXT_ITEM_AGE,", "EXT_LOW_TTL,", "EXT_RECACHE_RATE,", "EXT_COMPACT_UNDER,", "EXT_DROP_UNDER,", "EXT_MAX_FRAG,", "EXT_DROP_UNREAD,", "SLAB_AUTOMOVE_FREERATIO,", "#endif", "};", "char *const subopts_tokens[] = {", "[MAXCONNS_FAST] = \"maxconns_fast\",", "[HASHPOWER_INIT] = \"hashpower\",", "[NO_HASHEXPAND] = \"no_hashexpand\",", "[SLAB_REASSIGN] = \"slab_reassign\",", "[SLAB_AUTOMOVE] = \"slab_automove\",", "[SLAB_AUTOMOVE_RATIO] = \"slab_automove_ratio\",", "[SLAB_AUTOMOVE_WINDOW] = \"slab_automove_window\",", "[TAIL_REPAIR_TIME] = \"tail_repair_time\",", "[HASH_ALGORITHM] = \"hash_algorithm\",", "[LRU_CRAWLER] = \"lru_crawler\",", "[LRU_CRAWLER_SLEEP] = \"lru_crawler_sleep\",", "[LRU_CRAWLER_TOCRAWL] = \"lru_crawler_tocrawl\",", "[LRU_MAINTAINER] = \"lru_maintainer\",", "[HOT_LRU_PCT] = \"hot_lru_pct\",", "[WARM_LRU_PCT] = \"warm_lru_pct\",", "[HOT_MAX_FACTOR] = \"hot_max_factor\",", "[WARM_MAX_FACTOR] = \"warm_max_factor\",", "[TEMPORARY_TTL] = \"temporary_ttl\",", "[IDLE_TIMEOUT] = \"idle_timeout\",", "[WATCHER_LOGBUF_SIZE] = \"watcher_logbuf_size\",", "[WORKER_LOGBUF_SIZE] = \"worker_logbuf_size\",", "[SLAB_SIZES] = \"slab_sizes\",", "[SLAB_CHUNK_MAX] = \"slab_chunk_max\",", "[TRACK_SIZES] = \"track_sizes\",", "[NO_INLINE_ASCII_RESP] = \"no_inline_ascii_resp\",", "[MODERN] = \"modern\",", "[NO_MODERN] = \"no_modern\",", "[NO_CHUNKED_ITEMS] = \"no_chunked_items\",", "[NO_SLAB_REASSIGN] = \"no_slab_reassign\",", "[NO_SLAB_AUTOMOVE] = \"no_slab_automove\",", "[NO_MAXCONNS_FAST] = \"no_maxconns_fast\",", "[INLINE_ASCII_RESP] = \"inline_ascii_resp\",", "[NO_LRU_CRAWLER] = \"no_lru_crawler\",", "[NO_LRU_MAINTAINER] = \"no_lru_maintainer\",", "[NO_DROP_PRIVILEGES] = \"no_drop_privileges\",", "#ifdef MEMCACHED_DEBUG", "[RELAXED_PRIVILEGES] = \"relaxed_privileges\",", "#endif", "#ifdef EXTSTORE", "[EXT_PAGE_SIZE] = \"ext_page_size\",", "[EXT_PAGE_COUNT] = \"ext_page_count\",", "[EXT_WBUF_SIZE] = \"ext_wbuf_size\",", "[EXT_THREADS] = \"ext_threads\",", "[EXT_IO_DEPTH] = \"ext_io_depth\",", "[EXT_PATH] = \"ext_path\",", "[EXT_ITEM_SIZE] = \"ext_item_size\",", "[EXT_ITEM_AGE] = \"ext_item_age\",", "[EXT_LOW_TTL] = \"ext_low_ttl\",", "[EXT_RECACHE_RATE] = \"ext_recache_rate\",", "[EXT_COMPACT_UNDER] = \"ext_compact_under\",", "[EXT_DROP_UNDER] = \"ext_drop_under\",", "[EXT_MAX_FRAG] = \"ext_max_frag\",", "[EXT_DROP_UNREAD] = \"ext_drop_unread\",", "[SLAB_AUTOMOVE_FREERATIO] = \"slab_automove_freeratio\",", "#endif", "NULL", "};", "", "if (!sanitycheck()) {", "return EX_OSERR;", "}", "", "", "signal(SIGINT, sig_handler);", "signal(SIGTERM, sig_handler);", "", "", "settings_init();", "#ifdef EXTSTORE", "settings.ext_item_size = 512;", "settings.ext_item_age = UINT_MAX;", "settings.ext_low_ttl = 0;", "settings.ext_recache_rate = 2000;", "settings.ext_max_frag = 0.8;", "settings.ext_drop_unread = false;", "settings.ext_wbuf_size = 1024 * 1024 * 4;", "settings.ext_compact_under = 0;", "settings.ext_drop_under = 0;", "settings.slab_automove_freeratio = 0.01;", "ext_cf.page_size = 1024 * 1024 * 64;", "ext_cf.page_count = 64;", "ext_cf.wbuf_size = settings.ext_wbuf_size;", "ext_cf.io_threadcount = 1;", "ext_cf.io_depth = 1;", "ext_cf.page_buckets = 4;", "ext_cf.wbuf_count = ext_cf.page_buckets;", "#endif", "", "", "init_lru_maintainer();", "", "", "setbuf(stderr, NULL);", "", "char *shortopts =", "\"a:\"", "\"A\"", "\"p:\"", "\"s:\"", "\"U:\"", "\"m:\"", "\"M\"", "\"c:\"", "\"k\"", "\"hiV\"", "\"r\"", "\"v\"", "\"d\"", "\"l:\"", "\"u:\"", "\"P:\"", "\"f:\"", "\"n:\"", "\"t:\"", "\"D:\"", "\"L\"", "\"R:\"", "\"C\"", "\"b:\"", "\"B:\"", "\"I:\"", "\"S\"", "\"F\"", "\"X\"", "\"o:\"", ";", "", "", "#ifdef HAVE_GETOPT_LONG", "const struct option longopts[] = {", "{\"unix-mask\", required_argument, 0, 'a'},", "{\"enable-shutdown\", no_argument, 0, 'A'},", "{\"port\", required_argument, 0, 'p'},", "{\"unix-socket\", required_argument, 0, 's'},", "{\"udp-port\", required_argument, 0, 'U'},", "{\"memory-limit\", required_argument, 0, 'm'},", "{\"disable-evictions\", no_argument, 0, 'M'},", "{\"conn-limit\", required_argument, 0, 'c'},", "{\"lock-memory\", no_argument, 0, 'k'},", "{\"help\", no_argument, 0, 'h'},", "{\"license\", no_argument, 0, 'i'},", "{\"version\", no_argument, 0, 'V'},", "{\"enable-coredumps\", no_argument, 0, 'r'},", "{\"verbose\", optional_argument, 0, 'v'},", "{\"daemon\", no_argument, 0, 'd'},", "{\"listen\", required_argument, 0, 'l'},", "{\"user\", required_argument, 0, 'u'},", "{\"pidfile\", required_argument, 0, 'P'},", "{\"slab-growth-factor\", required_argument, 0, 'f'},", "{\"slab-min-size\", required_argument, 0, 'n'},", "{\"threads\", required_argument, 0, 't'},", "{\"enable-largepages\", no_argument, 0, 'L'},", "{\"max-reqs-per-event\", required_argument, 0, 'R'},", "{\"disable-cas\", no_argument, 0, 'C'},", "{\"listen-backlog\", required_argument, 0, 'b'},", "{\"protocol\", required_argument, 0, 'B'},", "{\"max-item-size\", required_argument, 0, 'I'},", "{\"enable-sasl\", no_argument, 0, 'S'},", "{\"disable-flush-all\", no_argument, 0, 'F'},", "{\"disable-dumping\", no_argument, 0, 'X'},", "{\"extended\", required_argument, 0, 'o'},", "{0, 0, 0, 0}", "};", "int optindex;", "while (-1 != (c = getopt_long(argc, argv, shortopts,", "longopts, &optindex))) {", "#else", "while (-1 != (c = getopt(argc, argv, shortopts))) {", "#endif", "switch (c) {", "case 'A':", "", "settings.shutdown_command = true;", "break;", "", "case 'a':", "", "settings.access= strtol(optarg,NULL,8);", "break;", "", "case 'U':", "settings.udpport = atoi(optarg);", "udp_specified = true;", "break;", "case 'p':", "settings.port = atoi(optarg);", "tcp_specified = true;", "break;", "case 's':", "settings.socketpath = optarg;", "break;", "case 'm':", "settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;", "break;", "case 'M':", "settings.evict_to_free = 0;", "break;", "case 'c':", "settings.maxconns = atoi(optarg);", "if (settings.maxconns <= 0) {", "fprintf(stderr, \"Maximum connections must be greater than 0\\n\");", "return 1;", "}", "break;", "case 'h':", "usage();", "exit(EXIT_SUCCESS);", "case 'i':", "usage_license();", "exit(EXIT_SUCCESS);", "case 'V':", "printf(PACKAGE \" \" VERSION \"\\n\");", "exit(EXIT_SUCCESS);", "case 'k':", "lock_memory = true;", "break;", "case 'v':", "settings.verbose++;", "break;", "case 'l':", "if (settings.inter != NULL) {", "if (strstr(settings.inter, optarg) != NULL) {", "break;", "}", "size_t len = strlen(settings.inter) + strlen(optarg) + 2;", "char *p = malloc(len);", "if (p == NULL) {", "fprintf(stderr, \"Failed to allocate memory\\n\");", "return 1;", "}", "snprintf(p, len, \"%s,%s\", settings.inter, optarg);", "free(settings.inter);", "settings.inter = p;", "} else {", "settings.inter= strdup(optarg);", "}", "break;", "case 'd':", "do_daemonize = true;", "break;", "case 'r':", "maxcore = 1;", "break;", "case 'R':", "settings.reqs_per_event = atoi(optarg);", "if (settings.reqs_per_event == 0) {", "fprintf(stderr, \"Number of requests per event must be greater than 0\\n\");", "return 1;", "}", "break;", "case 'u':", "username = optarg;", "break;", "case 'P':", "pid_file = optarg;", "break;", "case 'f':", "settings.factor = atof(optarg);", "if (settings.factor <= 1.0) {", "fprintf(stderr, \"Factor must be greater than 1\\n\");", "return 1;", "}", "break;", "case 'n':", "settings.chunk_size = atoi(optarg);", "if (settings.chunk_size == 0) {", "fprintf(stderr, \"Chunk size must be greater than 0\\n\");", "return 1;", "}", "break;", "case 't':", "settings.num_threads = atoi(optarg);", "if (settings.num_threads <= 0) {", "fprintf(stderr, \"Number of threads must be greater than 0\\n\");", "return 1;", "}", "", "", "", "", "if (settings.num_threads > 64) {", "fprintf(stderr, \"WARNING: Setting a high number of worker\"", "\"threads is not recommended.\\n\"", "\" Set this value to the number of cores in\"", "\" your machine or less.\\n\");", "}", "break;", "case 'D':", "if (! optarg || ! optarg[0]) {", "fprintf(stderr, \"No delimiter specified\\n\");", "return 1;", "}", "settings.prefix_delimiter = optarg[0];", "settings.detail_enabled = 1;", "break;", "case 'L' :", "if (enable_large_pages() == 0) {", "preallocate = true;", "} else {", "fprintf(stderr, \"Cannot enable large pages on this system\\n\"", "\"(There is no Linux support as of this version)\\n\");", "return 1;", "}", "break;", "case 'C' :", "settings.use_cas = false;", "break;", "case 'b' :", "settings.backlog = atoi(optarg);", "break;", "case 'B':", "protocol_specified = true;", "if (strcmp(optarg, \"auto\") == 0) {", "settings.binding_protocol = negotiating_prot;", "} else if (strcmp(optarg, \"binary\") == 0) {", "settings.binding_protocol = binary_prot;", "} else if (strcmp(optarg, \"ascii\") == 0) {", "settings.binding_protocol = ascii_prot;", "} else {", "fprintf(stderr, \"Invalid value for binding protocol: %s\\n\"", "\" -- should be one of auto, binary, or ascii\\n\", optarg);", "exit(EX_USAGE);", "}", "break;", "case 'I':", "buf = strdup(optarg);", "unit = buf[strlen(buf)-1];", "if (unit == 'k' || unit == 'm' ||", "unit == 'K' || unit == 'M') {", "buf[strlen(buf)-1] = '\\0';", "size_max = atoi(buf);", "if (unit == 'k' || unit == 'K')", "size_max *= 1024;", "if (unit == 'm' || unit == 'M')", "size_max *= 1024 * 1024;", "settings.item_size_max = size_max;", "} else {", "settings.item_size_max = atoi(buf);", "}", "free(buf);", "break;", "case 'S':", "#ifndef ENABLE_SASL", "fprintf(stderr, \"This server is not built with SASL support.\\n\");", "exit(EX_USAGE);", "#endif", "settings.sasl = true;", "break;", "case 'F' :", "settings.flush_enabled = false;", "break;", "case 'X' :", "settings.dump_enabled = false;", "break;", "case 'o':", "subopts_orig = subopts = strdup(optarg);", "", "while (*subopts != '\\0') {", "", "switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {", "case MAXCONNS_FAST:", "settings.maxconns_fast = true;", "break;", "case HASHPOWER_INIT:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing numeric argument for hashpower\\n\");", "return 1;", "}", "settings.hashpower_init = atoi(subopts_value);", "if (settings.hashpower_init < 12) {", "fprintf(stderr, \"Initial hashtable multiplier of %d is too low\\n\",", "settings.hashpower_init);", "return 1;", "} else if (settings.hashpower_init > 32) {", "fprintf(stderr, \"Initial hashtable multiplier of %d is too high\\n\"", "\"Choose a value based on \\\"STAT hash_power_level\\\" from a running instance\\n\",", "settings.hashpower_init);", "return 1;", "}", "break;", "case NO_HASHEXPAND:", "start_assoc_maint = false;", "break;", "case SLAB_REASSIGN:", "settings.slab_reassign = true;", "break;", "case SLAB_AUTOMOVE:", "if (subopts_value == NULL) {", "settings.slab_automove = 1;", "break;", "}", "settings.slab_automove = atoi(subopts_value);", "if (settings.slab_automove < 0 || settings.slab_automove > 2) {", "fprintf(stderr, \"slab_automove must be between 0 and 2\\n\");", "return 1;", "}", "break;", "case SLAB_AUTOMOVE_RATIO:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing slab_automove_ratio argument\\n\");", "return 1;", "}", "settings.slab_automove_ratio = atof(subopts_value);", "if (settings.slab_automove_ratio <= 0 || settings.slab_automove_ratio > 1) {", "fprintf(stderr, \"slab_automove_ratio must be > 0 and < 1\\n\");", "return 1;", "}", "break;", "case SLAB_AUTOMOVE_WINDOW:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing slab_automove_window argument\\n\");", "return 1;", "}", "settings.slab_automove_window = atoi(subopts_value);", "if (settings.slab_automove_window < 3) {", "fprintf(stderr, \"slab_automove_window must be > 2\\n\");", "return 1;", "}", "break;", "case TAIL_REPAIR_TIME:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing numeric argument for tail_repair_time\\n\");", "return 1;", "}", "settings.tail_repair_time = atoi(subopts_value);", "if (settings.tail_repair_time < 10) {", "fprintf(stderr, \"Cannot set tail_repair_time to less than 10 seconds\\n\");", "return 1;", "}", "break;", "case HASH_ALGORITHM:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing hash_algorithm argument\\n\");", "return 1;", "};", "if (strcmp(subopts_value, \"jenkins\") == 0) {", "hash_type = JENKINS_HASH;", "} else if (strcmp(subopts_value, \"murmur3\") == 0) {", "hash_type = MURMUR3_HASH;", "} else {", "fprintf(stderr, \"Unknown hash_algorithm option (jenkins, murmur3)\\n\");", "return 1;", "}", "break;", "case LRU_CRAWLER:", "start_lru_crawler = true;", "break;", "case LRU_CRAWLER_SLEEP:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing lru_crawler_sleep value\\n\");", "return 1;", "}", "settings.lru_crawler_sleep = atoi(subopts_value);", "if (settings.lru_crawler_sleep > 1000000 || settings.lru_crawler_sleep < 0) {", "fprintf(stderr, \"LRU crawler sleep must be between 0 and 1 second\\n\");", "return 1;", "}", "break;", "case LRU_CRAWLER_TOCRAWL:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing lru_crawler_tocrawl value\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &tocrawl)) {", "fprintf(stderr, \"lru_crawler_tocrawl takes a numeric 32bit value\\n\");", "return 1;", "}", "settings.lru_crawler_tocrawl = tocrawl;", "break;", "case LRU_MAINTAINER:", "start_lru_maintainer = true;", "settings.lru_segmented = true;", "break;", "case HOT_LRU_PCT:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing hot_lru_pct argument\\n\");", "return 1;", "}", "settings.hot_lru_pct = atoi(subopts_value);", "if (settings.hot_lru_pct < 1 || settings.hot_lru_pct >= 80) {", "fprintf(stderr, \"hot_lru_pct must be > 1 and < 80\\n\");", "return 1;", "}", "break;", "case WARM_LRU_PCT:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing warm_lru_pct argument\\n\");", "return 1;", "}", "settings.warm_lru_pct = atoi(subopts_value);", "if (settings.warm_lru_pct < 1 || settings.warm_lru_pct >= 80) {", "fprintf(stderr, \"warm_lru_pct must be > 1 and < 80\\n\");", "return 1;", "}", "break;", "case HOT_MAX_FACTOR:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing hot_max_factor argument\\n\");", "return 1;", "}", "settings.hot_max_factor = atof(subopts_value);", "if (settings.hot_max_factor <= 0) {", "fprintf(stderr, \"hot_max_factor must be > 0\\n\");", "return 1;", "}", "break;", "case WARM_MAX_FACTOR:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing warm_max_factor argument\\n\");", "return 1;", "}", "settings.warm_max_factor = atof(subopts_value);", "if (settings.warm_max_factor <= 0) {", "fprintf(stderr, \"warm_max_factor must be > 0\\n\");", "return 1;", "}", "break;", "case TEMPORARY_TTL:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing temporary_ttl argument\\n\");", "return 1;", "}", "settings.temp_lru = true;", "settings.temporary_ttl = atoi(subopts_value);", "break;", "case IDLE_TIMEOUT:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing numeric argument for idle_timeout\\n\");", "return 1;", "}", "settings.idle_timeout = atoi(subopts_value);", "break;", "case WATCHER_LOGBUF_SIZE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing watcher_logbuf_size argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.logger_watcher_buf_size)) {", "fprintf(stderr, \"could not parse argument to watcher_logbuf_size\\n\");", "return 1;", "}", "settings.logger_watcher_buf_size *= 1024;", "break;", "case WORKER_LOGBUF_SIZE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing worker_logbuf_size argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.logger_buf_size)) {", "fprintf(stderr, \"could not parse argument to worker_logbuf_size\\n\");", "return 1;", "}", "settings.logger_buf_size *= 1024;", "case SLAB_SIZES:", "slab_sizes_unparsed = subopts_value;", "break;", "case SLAB_CHUNK_MAX:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing slab_chunk_max argument\\n\");", "}", "if (!safe_strtol(subopts_value, &settings.slab_chunk_size_max)) {", "fprintf(stderr, \"could not parse argument to slab_chunk_max\\n\");", "}", "slab_chunk_size_changed = true;", "break;", "case TRACK_SIZES:", "item_stats_sizes_init();", "break;", "case NO_INLINE_ASCII_RESP:", "settings.inline_ascii_response = false;", "break;", "case INLINE_ASCII_RESP:", "settings.inline_ascii_response = true;", "break;", "case NO_CHUNKED_ITEMS:", "settings.slab_chunk_size_max = settings.slab_page_size;", "break;", "case NO_SLAB_REASSIGN:", "settings.slab_reassign = false;", "break;", "case NO_SLAB_AUTOMOVE:", "settings.slab_automove = 0;", "break;", "case NO_MAXCONNS_FAST:", "settings.maxconns_fast = false;", "break;", "case NO_LRU_CRAWLER:", "settings.lru_crawler = false;", "start_lru_crawler = false;", "break;", "case NO_LRU_MAINTAINER:", "start_lru_maintainer = false;", "settings.lru_segmented = false;", "break;", "#ifdef EXTSTORE", "case EXT_PAGE_SIZE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_page_size argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {", "fprintf(stderr, \"could not parse argument to ext_page_size\\n\");", "return 1;", "}", "ext_cf.page_size *= 1024 * 1024;", "break;", "case EXT_PAGE_COUNT:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_page_count argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &ext_cf.page_count)) {", "fprintf(stderr, \"could not parse argument to ext_page_count\\n\");", "return 1;", "}", "break;", "case EXT_WBUF_SIZE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_wbuf_size argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {", "fprintf(stderr, \"could not parse argument to ext_wbuf_size\\n\");", "return 1;", "}", "ext_cf.wbuf_size *= 1024 * 1024;", "settings.ext_wbuf_size = ext_cf.wbuf_size;", "break;", "case EXT_THREADS:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_threads argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {", "fprintf(stderr, \"could not parse argument to ext_threads\\n\");", "return 1;", "}", "break;", "case EXT_IO_DEPTH:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_io_depth argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {", "fprintf(stderr, \"could not parse argument to ext_io_depth\\n\");", "return 1;", "}", "break;", "case EXT_ITEM_SIZE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_item_size argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {", "fprintf(stderr, \"could not parse argument to ext_item_size\\n\");", "return 1;", "}", "break;", "case EXT_ITEM_AGE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_item_age argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {", "fprintf(stderr, \"could not parse argument to ext_item_age\\n\");", "return 1;", "}", "break;", "case EXT_LOW_TTL:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_low_ttl argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {", "fprintf(stderr, \"could not parse argument to ext_low_ttl\\n\");", "return 1;", "}", "break;", "case EXT_RECACHE_RATE:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_recache_rate argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {", "fprintf(stderr, \"could not parse argument to ext_recache_rate\\n\");", "return 1;", "}", "break;", "case EXT_COMPACT_UNDER:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_compact_under argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {", "fprintf(stderr, \"could not parse argument to ext_compact_under\\n\");", "return 1;", "}", "break;", "case EXT_DROP_UNDER:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_drop_under argument\\n\");", "return 1;", "}", "if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {", "fprintf(stderr, \"could not parse argument to ext_drop_under\\n\");", "return 1;", "}", "break;", "case EXT_MAX_FRAG:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing ext_max_frag argument\\n\");", "return 1;", "}", "if (!safe_strtod(subopts_value, &settings.ext_max_frag)) {", "fprintf(stderr, \"could not parse argument to ext_max_frag\\n\");", "return 1;", "}", "break;", "case SLAB_AUTOMOVE_FREERATIO:", "if (subopts_value == NULL) {", "fprintf(stderr, \"Missing slab_automove_freeratio argument\\n\");", "return 1;", "}", "if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {", "fprintf(stderr, \"could not parse argument to slab_automove_freeratio\\n\");", "return 1;", "}", "break;", "case EXT_DROP_UNREAD:", "settings.ext_drop_unread = true;", "break;", "case EXT_PATH:", "storage_file = strdup(subopts_value);", "break;", "#endif", "case MODERN:", "", "break;", "case NO_MODERN:", "if (!slab_chunk_size_changed) {", "settings.slab_chunk_size_max = settings.slab_page_size;", "}", "settings.slab_reassign = false;", "settings.slab_automove = 0;", "settings.maxconns_fast = false;", "settings.inline_ascii_response = true;", "settings.lru_segmented = false;", "hash_type = JENKINS_HASH;", "start_lru_crawler = false;", "start_lru_maintainer = false;", "break;", "case NO_DROP_PRIVILEGES:", "settings.drop_privileges = false;", "break;", "#ifdef MEMCACHED_DEBUG", "case RELAXED_PRIVILEGES:", "settings.relaxed_privileges = true;", "break;", "#endif", "default:", "printf(\"Illegal suboption \\\"%s\\\"\\n\", subopts_value);", "return 1;", "}", "", "}", "free(subopts_orig);", "break;", "default:", "fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);", "return 1;", "}", "}", "", "if (settings.item_size_max < 1024) {", "fprintf(stderr, \"Item max size cannot be less than 1024 bytes.\\n\");", "exit(EX_USAGE);", "}", "if (settings.item_size_max > (settings.maxbytes / 2)) {", "fprintf(stderr, \"Cannot set item size limit higher than 1/2 of memory max.\\n\");", "exit(EX_USAGE);", "}", "if (settings.item_size_max > (1024 * 1024 * 1024)) {", "fprintf(stderr, \"Cannot set item size limit higher than a gigabyte.\\n\");", "exit(EX_USAGE);", "}", "if (settings.item_size_max > 1024 * 1024) {", "if (!slab_chunk_size_changed) {", "", "settings.slab_chunk_size_max = settings.slab_page_size / 2;", "}", "}", "", "if (settings.slab_chunk_size_max > settings.item_size_max) {", "fprintf(stderr, \"slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\\n\",", "settings.slab_chunk_size_max, settings.item_size_max);", "exit(EX_USAGE);", "}", "", "if (settings.item_size_max % settings.slab_chunk_size_max != 0) {", "fprintf(stderr, \"-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\\n\",", "settings.item_size_max, settings.slab_chunk_size_max);", "exit(EX_USAGE);", "}", "", "if (settings.slab_page_size % settings.slab_chunk_size_max != 0) {", "fprintf(stderr, \"slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\\n\",", "settings.slab_chunk_size_max, settings.slab_page_size);", "exit(EX_USAGE);", "}", "#ifdef EXTSTORE", "if (storage_file) {", "if (settings.item_size_max > ext_cf.wbuf_size) {", "fprintf(stderr, \"-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\\n\",", "settings.item_size_max, ext_cf.wbuf_size);", "exit(EX_USAGE);", "}", "", "", "", "", "", "if (settings.inline_ascii_response) {", "fprintf(stderr, \"Cannot use inline_ascii_response with extstore enabled\\n\");", "exit(EX_USAGE);", "}", "", "if (settings.udpport) {", "fprintf(stderr, \"Cannot use UDP with extstore enabled (-U 0 to disable)\\n\");", "exit(EX_USAGE);", "}", "}", "#endif", "", "", "", "", "", "", "if (slab_sizes_unparsed != NULL) {", "if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {", "use_slab_sizes = true;", "} else {", "exit(EX_USAGE);", "}", "}", "", "if (settings.hot_lru_pct + settings.warm_lru_pct > 80) {", "fprintf(stderr, \"hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\\n\");", "exit(EX_USAGE);", "}", "", "if (settings.temp_lru && !start_lru_maintainer) {", "fprintf(stderr, \"temporary_ttl requires lru_maintainer to be enabled\\n\");", "exit(EX_USAGE);", "}", "", "if (hash_init(hash_type) != 0) {", "fprintf(stderr, \"Failed to initialize hash_algorithm!\\n\");", "exit(EX_USAGE);", "}", "", "", "", "", "", "if (settings.inter != NULL && strchr(settings.inter, ',')) {", "settings.num_threads_per_udp = 1;", "} else {", "settings.num_threads_per_udp = settings.num_threads;", "}", "", "if (settings.sasl) {", "if (!protocol_specified) {", "settings.binding_protocol = binary_prot;", "} else {", "if (settings.binding_protocol != binary_prot) {", "fprintf(stderr, \"ERROR: You cannot allow the ASCII protocol while using SASL.\\n\");", "exit(EX_USAGE);", "}", "}", "}", "", "if (tcp_specified && settings.port != 0 && !udp_specified) {", "settings.udpport = settings.port;", "} else if (udp_specified && settings.udpport != 0 && !tcp_specified) {", "settings.port = settings.udpport;", "}", "", "if (maxcore != 0) {", "struct rlimit rlim_new;", "", "", "", "", "if (getrlimit(RLIMIT_CORE, &rlim) == 0) {", "rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;", "if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {", "", "rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;", "(void)setrlimit(RLIMIT_CORE, &rlim_new);", "}", "}", "", "", "", "", "", "", "if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {", "fprintf(stderr, \"failed to ensure corefile creation\\n\");", "exit(EX_OSERR);", "}", "}", "", "", "", "", "", "", "if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {", "fprintf(stderr, \"failed to getrlimit number of files\\n\");", "exit(EX_OSERR);", "} else {", "rlim.rlim_cur = settings.maxconns;", "rlim.rlim_max = settings.maxconns;", "if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {", "fprintf(stderr, \"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\\n\");", "exit(EX_OSERR);", "}", "}", "", "", "if (getuid() == 0 || geteuid() == 0) {", "if (username == 0 || *username == '\\0') {", "fprintf(stderr, \"can't run as root without the -u switch\\n\");", "exit(EX_USAGE);", "}", "if ((pw = getpwnam(username)) == 0) {", "fprintf(stderr, \"can't find the user %s to switch to\\n\", username);", "exit(EX_NOUSER);", "}", "if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {", "fprintf(stderr, \"failed to assume identity of user %s\\n\", username);", "exit(EX_OSERR);", "}", "}", "", "", "if (settings.sasl) {", "init_sasl();", "}", "", "", "", "if (do_daemonize) {", "if (sigignore(SIGHUP) == -1) {", "perror(\"Failed to ignore SIGHUP\");", "}", "if (daemonize(maxcore, settings.verbose) == -1) {", "fprintf(stderr, \"failed to daemon() in order to daemonize\\n\");", "exit(EXIT_FAILURE);", "}", "}", "", "", "if (lock_memory) {", "#ifdef HAVE_MLOCKALL", "int res = mlockall(MCL_CURRENT | MCL_FUTURE);", "if (res != 0) {", "fprintf(stderr, \"warning: -k invalid, mlockall() failed: %s\\n\",", "strerror(errno));", "}", "#else", "fprintf(stderr, \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");", "#endif", "}", "", "", "#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101", "", "struct event_config *ev_config;", "ev_config = event_config_new();", "event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);", "main_base = event_base_new_with_config(ev_config);", "event_config_free(ev_config);", "#else", "", "main_base = event_init();", "#endif", "", "", "logger_init();", "stats_init();", "assoc_init(settings.hashpower_init);", "conn_init();", "slabs_init(settings.maxbytes, settings.factor, preallocate,", "use_slab_sizes ? slab_sizes : NULL);", "#ifdef EXTSTORE", "if (storage_file) {", "enum extstore_res eres;", "if (settings.ext_compact_under == 0) {", "settings.ext_compact_under = ext_cf.page_count / 4;", "", "settings.ext_drop_under = ext_cf.page_count / 4;", "}", "crc32c_init();", "", "for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {", "settings.ext_free_memchunks[x] = 0;", "}", "storage = extstore_init(storage_file, &ext_cf, &eres);", "if (storage == NULL) {", "fprintf(stderr, \"Failed to initialize external storage: %s\\n\",", "extstore_err(eres));", "if (eres == EXTSTORE_INIT_OPEN_FAIL) {", "perror(\"extstore open\");", "}", "exit(EXIT_FAILURE);", "}", "ext_storage = storage;", "", "slabs_prefill_global();", "}", "#endif", "", "", "", "", "if (sigignore(SIGPIPE) == -1) {", "perror(\"failed to ignore SIGPIPE; sigaction\");", "exit(EX_OSERR);", "}", "", "#ifdef EXTSTORE", "slabs_set_storage(storage);", "memcached_thread_init(settings.num_threads, storage);", "init_lru_crawler(storage);", "#else", "memcached_thread_init(settings.num_threads, NULL);", "init_lru_crawler(NULL);", "#endif", "", "if (start_assoc_maint && start_assoc_maintenance_thread() == -1) {", "exit(EXIT_FAILURE);", "}", "if (start_lru_crawler && start_item_crawler_thread() != 0) {", "fprintf(stderr, \"Failed to enable LRU crawler thread\\n\");", "exit(EXIT_FAILURE);", "}", "#ifdef EXTSTORE", "if (storage && start_storage_compact_thread(storage) != 0) {", "fprintf(stderr, \"Failed to start storage compaction thread\\n\");", "exit(EXIT_FAILURE);", "}", "", "if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {", "#else", "if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {", "#endif", "fprintf(stderr, \"Failed to enable LRU maintainer thread\\n\");", "return 1;", "}", "", "if (settings.slab_reassign &&", "start_slab_maintenance_thread() == -1) {", "exit(EXIT_FAILURE);", "}", "", "if (settings.idle_timeout && start_conn_timeout_thread() == -1) {", "exit(EXIT_FAILURE);", "}", "", "", "clock_handler(0, 0, 0);", "", "", "if (settings.socketpath != NULL) {", "errno = 0;", "if (server_socket_unix(settings.socketpath,settings.access)) {", "vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);", "exit(EX_OSERR);", "}", "}", "", "", "if (settings.socketpath == NULL) {", "const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");", "char *temp_portnumber_filename = NULL;", "size_t len;", "FILE *portnumber_file = NULL;", "", "if (portnumber_filename != NULL) {", "len = strlen(portnumber_filename)+4+1;", "temp_portnumber_filename = malloc(len);", "snprintf(temp_portnumber_filename,", "len,", "\"%s.lck\", portnumber_filename);", "", "portnumber_file = fopen(temp_portnumber_filename, \"a\");", "if (portnumber_file == NULL) {", "fprintf(stderr, \"Failed to open \\\"%s\\\": %s\\n\",", "temp_portnumber_filename, strerror(errno));", "}", "}", "", "errno = 0;", "if (settings.port && server_sockets(settings.port, tcp_transport,", "portnumber_file)) {", "vperror(\"failed to listen on TCP port %d\", settings.port);", "exit(EX_OSERR);", "}", "", "", "", "", "", "", "", "", "", "errno = 0;", "if (settings.udpport && server_sockets(settings.udpport, udp_transport,", "portnumber_file)) {", "vperror(\"failed to listen on UDP port %d\", settings.udpport);", "exit(EX_OSERR);", "}", "", "if (portnumber_file) {", "fclose(portnumber_file);", "rename(temp_portnumber_filename, portnumber_filename);", "}", "if (temp_portnumber_filename)", "free(temp_portnumber_filename);", "}", "", "", "", "", "usleep(1000);", "if (stats_state.curr_conns + stats_state.reserved_fds >= settings.maxconns - 1) {", "fprintf(stderr, \"Maxconns setting is too low, use -c to increase.\\n\");", "exit(EXIT_FAILURE);", "}", "", "if (pid_file != NULL) {", "save_pid(pid_file);", "}", "", "", "if (settings.drop_privileges) {", "drop_privileges();", "}", "", "", "uriencode_init();", "", "", "if (event_base_loop(main_base, 0) != 0) {", "retval = EXIT_FAILURE;", "}", "", "stop_assoc_maintenance_thread();", "", "", "if (do_daemonize)", "remove_pidfile(pid_file);", "", "if (settings.inter)", "free(settings.inter);", "if (l_socket)", "free(l_socket);", "if (u_socket)", "free(u_socket);", "", "", "event_base_free(main_base);", "", "return retval;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)", " {", " \tint n;", " \tuint_fast32_t v;", " \tint c;", " \tfor (n = 4, v = 0;;) {", "  \t\tif ((c = jas_stream_getc(in)) == EOF) {", "  \t\t\treturn -1;", "  \t\t}", "\t\tv |= (c << 24);", " \t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);", "  \t\tif (--n <= 0) {", "  \t\t\tbreak;", "  \t\t}", " \t\tv >>= 8;", " \t}", " \tif (val) {", " \t\t*val = v;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void InputMethodBase::OnInputMethodChanged() const {", "    TextInputClient* client = GetTextInputClient();", "  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)", "   if (!IsTextInputTypeNone())", "      client->OnInputMethodChanged();", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0]}
{"tokens": ["  static void __exit exit_ext2_fs(void)", "  {", "  \tunregister_filesystem(&ext2_fs_type);", "  \tdestroy_inodecache();", "\texit_ext2_xattr();", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0]}
{"tokens": [" int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,", " \t\t\t    struct mem_access *ma, int expected,", " \t\t\t    unsigned long address)", " {", " \tu_int rm;", " \tint ret, index;", " ", " \t ", " \tif (instruction_size(instruction) != 2)", " \t\treturn -EINVAL;", " ", " \tindex = (instruction>>8)&15;\t ", " \trm = regs->regs[index];", " ", " \t ", "  \tif (!expected) {", "  \t\tunaligned_fixups_notify(current, instruction, regs);", "\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,", " \t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,", "  \t\t\t      regs, address);", "  \t}", "  ", " \tret = -EFAULT;", " \tswitch (instruction&0xF000) {", " \tcase 0x0000:", " \t\tif (instruction==0x000B) {", " \t\t\t ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0)", " \t\t\t\tregs->pc = regs->pr;", " \t\t}", " \t\telse if ((instruction&0x00FF)==0x0023) {", " \t\t\t ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0)", " \t\t\t\tregs->pc += rm + 4;", " \t\t}", " \t\telse if ((instruction&0x00FF)==0x0003) {", " \t\t\t ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0) {", " \t\t\t\tregs->pr = regs->pc + 4;", " \t\t\t\tregs->pc += rm + 4;", " \t\t\t}", " \t\t}", " \t\telse {", " \t\t\t ", " \t\t\tgoto simple;", " \t\t}", " \t\tbreak;", " ", " \tcase 0x1000:  ", " \t\tgoto simple;", " ", " \tcase 0x2000:  ", " \t\tgoto simple;", " ", " \tcase 0x4000:", " \t\tif ((instruction&0x00FF)==0x002B) {", " \t\t\t ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0)", " \t\t\t\tregs->pc = rm;", " \t\t}", " \t\telse if ((instruction&0x00FF)==0x000B) {", " \t\t\t ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0) {", " \t\t\t\tregs->pr = regs->pc + 4;", " \t\t\t\tregs->pc = rm;", " \t\t\t}", " \t\t}", " \t\telse {", " \t\t\t ", " \t\t\tgoto simple;", " \t\t}", " \t\tbreak;", " ", " \tcase 0x5000:  ", " \t\tgoto simple;", " ", " \tcase 0x6000:  ", " \t\tgoto simple;", " ", " \tcase 0x8000:  ", " \t\tswitch (instruction&0x0F00) {", " \t\tcase 0x0100:  ", " \t\t\tgoto simple;", " \t\tcase 0x0500:  ", " \t\t\tgoto simple;", " \t\tcase 0x0B00:  ", " \t\t\tbreak;", " \t\tcase 0x0F00:  ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0) {", " #if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)", " \t\t\t\tif ((regs->sr & 0x00000001) != 0)", " \t\t\t\t\tregs->pc += 4;  ", " \t\t\t\telse", " #endif", " \t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 0x0900:  ", " \t\t\tbreak;", " \t\tcase 0x0D00:  ", " \t\t\tret = handle_delayslot(regs, instruction, ma);", " \t\t\tif (ret==0) {", " #if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)", " \t\t\t\tif ((regs->sr & 0x00000001) == 0)", " \t\t\t\t\tregs->pc += 4;  ", " \t\t\t\telse", " #endif", " \t\t\t\t\tregs->pc += SH_PC_8BIT_OFFSET(instruction);", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t\tbreak;", " ", " \tcase 0xA000:  ", " \t\tret = handle_delayslot(regs, instruction, ma);", " \t\tif (ret==0)", " \t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);", " \t\tbreak;", " ", " \tcase 0xB000:  ", " \t\tret = handle_delayslot(regs, instruction, ma);", " \t\tif (ret==0) {", " \t\t\tregs->pr = regs->pc + 4;", " \t\t\tregs->pc += SH_PC_12BIT_OFFSET(instruction);", " \t\t}", " \t\tbreak;", " \t}", " \treturn ret;", " ", " \t ", "  simple:", " \tret = handle_unaligned_ins(instruction, regs, ma);", " \tif (ret==0)", " \t\tregs->pc += instruction_size(instruction);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)", " {", " \tstruct hidp_connadd_req ca;", " \tstruct hidp_conndel_req cd;", " \tstruct hidp_connlist_req cl;", " \tstruct hidp_conninfo ci;", " \tstruct socket *csock;", " \tstruct socket *isock;", " \tint err;", " ", " \tBT_DBG(\"cmd %x arg %p\", cmd, argp);", " ", " \tswitch (cmd) {", " \tcase HIDPCONNADD:", " \t\tif (!capable(CAP_NET_ADMIN))", " \t\t\treturn -EPERM;", " ", " \t\tif (copy_from_user(&ca, argp, sizeof(ca)))", " \t\t\treturn -EFAULT;", " ", " \t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);", " \t\tif (!csock)", " \t\t\treturn err;", " ", " \t\tisock = sockfd_lookup(ca.intr_sock, &err);", " \t\tif (!isock) {", "  \t\t\tsockfd_put(csock);", "  \t\t\treturn err;", "  \t\t}", " \t\tca.name[sizeof(ca.name)-1] = 0;", "  ", "  \t\terr = hidp_connection_add(&ca, csock, isock);", "  \t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))", " \t\t\terr = -EFAULT;", " ", " \t\tsockfd_put(csock);", " \t\tsockfd_put(isock);", " ", " \t\treturn err;", " ", " \tcase HIDPCONNDEL:", " \t\tif (!capable(CAP_NET_ADMIN))", " \t\t\treturn -EPERM;", " ", " \t\tif (copy_from_user(&cd, argp, sizeof(cd)))", " \t\t\treturn -EFAULT;", " ", " \t\treturn hidp_connection_del(&cd);", " ", " \tcase HIDPGETCONNLIST:", " \t\tif (copy_from_user(&cl, argp, sizeof(cl)))", " \t\t\treturn -EFAULT;", " ", " \t\tif (cl.cnum <= 0)", " \t\t\treturn -EINVAL;", " ", " \t\terr = hidp_get_connlist(&cl);", " \t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))", " \t\t\treturn -EFAULT;", " ", " \t\treturn err;", " ", " \tcase HIDPGETCONNINFO:", " \t\tif (copy_from_user(&ci, argp, sizeof(ci)))", " \t\t\treturn -EFAULT;", " ", " \t\terr = hidp_get_conninfo(&ci);", " \t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))", " \t\t\treturn -EFAULT;", " ", " \t\treturn err;", " \t}", " ", " \treturn -EINVAL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" yyparse (void *yyscanner, YR_COMPILER* compiler)", " {", "  ", " int yychar;", " ", " ", "  ", "  ", " YY_INITIAL_VALUE (static YYSTYPE yyval_default;)", " YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);", " ", "      ", "     int yynerrs;", " ", "     int yystate;", "      ", "     int yyerrstatus;", " ", "      ", " ", "      ", "     yytype_int16 yyssa[YYINITDEPTH];", "     yytype_int16 *yyss;", "     yytype_int16 *yyssp;", " ", "      ", "     YYSTYPE yyvsa[YYINITDEPTH];", "     YYSTYPE *yyvs;", "     YYSTYPE *yyvsp;", " ", "     YYSIZE_T yystacksize;", " ", "   int yyn;", "   int yyresult;", "    ", "   int yytoken = 0;", "    ", "   YYSTYPE yyval;", " ", " #if YYERROR_VERBOSE", "    ", "   char yymsgbuf[128];", "   char *yymsg = yymsgbuf;", "   YYSIZE_T yymsg_alloc = sizeof yymsgbuf;", " #endif", " ", " #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))", " ", "    ", "   int yylen = 0;", " ", "   yyssp = yyss = yyssa;", "   yyvsp = yyvs = yyvsa;", "   yystacksize = YYINITDEPTH;", " ", "   YYDPRINTF ((stderr, \"Starting parse\\n\"));", " ", "   yystate = 0;", "   yyerrstatus = 0;", "   yynerrs = 0;", "   yychar = YYEMPTY;  ", "   goto yysetstate;", " ", "  ", "  yynewstate:", "    ", "   yyssp++;", " ", "  yysetstate:", "   *yyssp = yystate;", " ", "   if (yyss + yystacksize - 1 <= yyssp)", "     {", "        ", "       YYSIZE_T yysize = yyssp - yyss + 1;", " ", " #ifdef yyoverflow", "       {", "          ", "         YYSTYPE *yyvs1 = yyvs;", "         yytype_int16 *yyss1 = yyss;", " ", "          ", "         yyoverflow (YY_(\"memory exhausted\"),", "                     &yyss1, yysize * sizeof (*yyssp),", "                     &yyvs1, yysize * sizeof (*yyvsp),", "                     &yystacksize);", " ", "         yyss = yyss1;", "         yyvs = yyvs1;", "       }", " #else  ", " # ifndef YYSTACK_RELOCATE", "       goto yyexhaustedlab;", " # else", "        ", "       if (YYMAXDEPTH <= yystacksize)", "         goto yyexhaustedlab;", "       yystacksize *= 2;", "       if (YYMAXDEPTH < yystacksize)", "         yystacksize = YYMAXDEPTH;", " ", "       {", "         yytype_int16 *yyss1 = yyss;", "         union yyalloc *yyptr =", "           (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));", "         if (! yyptr)", "           goto yyexhaustedlab;", "         YYSTACK_RELOCATE (yyss_alloc, yyss);", "         YYSTACK_RELOCATE (yyvs_alloc, yyvs);", " #  undef YYSTACK_RELOCATE", "         if (yyss1 != yyssa)", "           YYSTACK_FREE (yyss1);", "       }", " # endif", " #endif  ", " ", "       yyssp = yyss + yysize - 1;", "       yyvsp = yyvs + yysize - 1;", " ", "       YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",", "                   (unsigned long int) yystacksize));", " ", "       if (yyss + yystacksize - 1 <= yyssp)", "         YYABORT;", "     }", " ", "   YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));", " ", "   if (yystate == YYFINAL)", "     YYACCEPT;", " ", "   goto yybackup;", " ", "  ", " yybackup:", " ", "    ", " ", "    ", "   yyn = yypact[yystate];", "   if (yypact_value_is_default (yyn))", "     goto yydefault;", " ", "    ", " ", "    ", "   if (yychar == YYEMPTY)", "     {", "       YYDPRINTF ((stderr, \"Reading a token: \"));", "       yychar = yylex (&yylval, yyscanner, compiler);", "     }", " ", "   if (yychar <= YYEOF)", "     {", "       yychar = yytoken = YYEOF;", "       YYDPRINTF ((stderr, \"Now at end of input.\\n\"));", "     }", "   else", "     {", "       yytoken = YYTRANSLATE (yychar);", "       YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);", "     }", " ", "    ", "   yyn += yytoken;", "   if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)", "     goto yydefault;", "   yyn = yytable[yyn];", "   if (yyn <= 0)", "     {", "       if (yytable_value_is_error (yyn))", "         goto yyerrlab;", "       yyn = -yyn;", "       goto yyreduce;", "     }", " ", "    ", "   if (yyerrstatus)", "     yyerrstatus--;", " ", "    ", "   YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);", " ", "    ", "   yychar = YYEMPTY;", " ", "   yystate = yyn;", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", " ", "   goto yynewstate;", " ", " ", "  ", " yydefault:", "   yyn = yydefact[yystate];", "   if (yyn == 0)", "     goto yyerrlab;", "   goto yyreduce;", " ", " ", "  ", " yyreduce:", "    ", "   yylen = yyr2[yyn];", " ", "    ", "   yyval = yyvsp[1-yylen];", " ", " ", "   YY_REDUCE_PRINT (yyn);", "   switch (yyn)", "     {", "         case 8:", " #line 230 \"grammar.y\"  ", "     {", "         int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));", " ", "         yr_free((yyvsp[0].sized_string));", " ", "         ERROR_IF(result != ERROR_SUCCESS);", "       }", " #line 1661 \"grammar.c\"  ", "     break;", " ", "   case 9:", " #line 242 \"grammar.y\"  ", "     {", "         YR_RULE* rule = yr_parser_reduce_rule_declaration_phase_1(", "             yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string));", " ", "         ERROR_IF(rule == NULL);", " ", "         (yyval.rule) = rule;", "       }", " #line 1674 \"grammar.c\"  ", "     break;", " ", "   case 10:", " #line 251 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-4].rule);  ", " ", "         rule->tags = (yyvsp[-3].c_string);", "         rule->metas = (yyvsp[-1].meta);", "         rule->strings = (yyvsp[0].string);", "       }", " #line 1686 \"grammar.c\"  ", "     break;", " ", "   case 11:", " #line 259 \"grammar.y\"  ", "     {", "         YR_RULE* rule = (yyvsp[-7].rule);  ", " ", "         compiler->last_result = yr_parser_reduce_rule_declaration_phase_2(", "             yyscanner, rule);", " ", "         yr_free((yyvsp[-8].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1701 \"grammar.c\"  ", "     break;", " ", "   case 12:", " #line 274 \"grammar.y\"  ", "     {", "         (yyval.meta) = NULL;", "       }", " #line 1709 \"grammar.c\"  ", "     break;", " ", "   case 13:", " #line 278 \"grammar.y\"  ", "     {", " ", "         YR_META null_meta;", " ", "         memset(&null_meta, 0xFF, sizeof(YR_META));", "         null_meta.type = META_TYPE_NULL;", " ", "         compiler->last_result = yr_arena_write_data(", "             compiler->metas_arena,", "             &null_meta,", "             sizeof(YR_META),", "             NULL);", " ", "         (yyval.meta) = (yyvsp[0].meta);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 1736 \"grammar.c\"  ", "     break;", " ", "   case 14:", " #line 305 \"grammar.y\"  ", "     {", "         (yyval.string) = NULL;", "       }", " #line 1744 \"grammar.c\"  ", "     break;", " ", "   case 15:", " #line 309 \"grammar.y\"  ", "     {", " ", "         YR_STRING null_string;", " ", "         memset(&null_string, 0xFF, sizeof(YR_STRING));", "         null_string.g_flags = STRING_GFLAGS_NULL;", " ", "         compiler->last_result = yr_arena_write_data(", "             compiler->strings_arena,", "             &null_string,", "             sizeof(YR_STRING),", "             NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.string) = (yyvsp[0].string);", "       }", " #line 1771 \"grammar.c\"  ", "     break;", " ", "   case 17:", " #line 340 \"grammar.y\"  ", "     { (yyval.integer) = 0;  }", " #line 1777 \"grammar.c\"  ", "     break;", " ", "   case 18:", " #line 341 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 1783 \"grammar.c\"  ", "     break;", " ", "   case 19:", " #line 346 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }", " #line 1789 \"grammar.c\"  ", "     break;", " ", "   case 20:", " #line 347 \"grammar.y\"  ", "     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }", " #line 1795 \"grammar.c\"  ", "     break;", " ", "   case 21:", " #line 353 \"grammar.y\"  ", "     {", "         (yyval.c_string) = NULL;", "       }", " #line 1803 \"grammar.c\"  ", "     break;", " ", "   case 22:", " #line 357 \"grammar.y\"  ", "     {", " ", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, \"\", NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.c_string) = (yyvsp[0].c_string);", "       }", " #line 1821 \"grammar.c\"  ", "     break;", " ", "   case 23:", " #line 375 \"grammar.y\"  ", "     {", "         char* identifier;", " ", "         compiler->last_result = yr_arena_write_string(", "             yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &identifier);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.c_string) = identifier;", "       }", " #line 1838 \"grammar.c\"  ", "     break;", " ", "   case 24:", " #line 388 \"grammar.y\"  ", "     {", "         char* tag_name = (yyvsp[-1].c_string);", "         size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;", " ", "         while (tag_length > 0)", "         {", "           if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)", "           {", "             yr_compiler_set_error_extra_info(compiler, tag_name);", "             compiler->last_result = ERROR_DUPLICATED_TAG_IDENTIFIER;", "             break;", "           }", " ", "           tag_name = (char*) yr_arena_next_address(", "               yyget_extra(yyscanner)->sz_arena,", "               tag_name,", "               tag_length + 1);", " ", "           tag_length = tag_name != NULL ? strlen(tag_name) : 0;", "         }", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_arena_write_string(", "               yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.c_string) = (yyvsp[-1].c_string);", "       }", " #line 1874 \"grammar.c\"  ", "     break;", " ", "   case 25:", " #line 424 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[0].meta); }", " #line 1880 \"grammar.c\"  ", "     break;", " ", "   case 26:", " #line 425 \"grammar.y\"  ", "     {  (yyval.meta) = (yyvsp[-1].meta); }", " #line 1886 \"grammar.c\"  ", "     break;", " ", "   case 27:", " #line 431 \"grammar.y\"  ", "     {", "         SIZED_STRING* sized_string = (yyvsp[0].sized_string);", " ", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_STRING,", "             (yyvsp[-2].c_string),", "             sized_string->c_string,", "             0);", " ", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", " ", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1906 \"grammar.c\"  ", "     break;", " ", "   case 28:", " #line 447 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-2].c_string),", "             NULL,", "             (yyvsp[0].integer));", " ", "         yr_free((yyvsp[-2].c_string));", " ", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1923 \"grammar.c\"  ", "     break;", " ", "   case 29:", " #line 460 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_INTEGER,", "             (yyvsp[-3].c_string),", "             NULL,", "             -(yyvsp[0].integer));", " ", "         yr_free((yyvsp[-3].c_string));", " ", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1940 \"grammar.c\"  ", "     break;", " ", "   case 30:", " #line 473 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             TRUE);", " ", "         yr_free((yyvsp[-2].c_string));", " ", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1957 \"grammar.c\"  ", "     break;", " ", "   case 31:", " #line 486 \"grammar.y\"  ", "     {", "         (yyval.meta) = yr_parser_reduce_meta_declaration(", "             yyscanner,", "             META_TYPE_BOOLEAN,", "             (yyvsp[-2].c_string),", "             NULL,", "             FALSE);", " ", "         yr_free((yyvsp[-2].c_string));", " ", "         ERROR_IF((yyval.meta) == NULL);", "       }", " #line 1974 \"grammar.c\"  ", "     break;", " ", "   case 32:", " #line 502 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[0].string); }", " #line 1980 \"grammar.c\"  ", "     break;", " ", "   case 33:", " #line 503 \"grammar.y\"  ", "     { (yyval.string) = (yyvsp[-1].string); }", " #line 1986 \"grammar.c\"  ", "     break;", " ", "   case 34:", " #line 509 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 1994 \"grammar.c\"  ", "     break;", " ", "   case 35:", " #line 513 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", " ", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", " ", "         ERROR_IF((yyval.string) == NULL);", "         compiler->error_line = 0;", "       }", " #line 2009 \"grammar.c\"  ", "     break;", " ", "   case 36:", " #line 524 \"grammar.y\"  ", "     {", "         compiler->error_line = yyget_lineno(yyscanner);", "       }", " #line 2017 \"grammar.c\"  ", "     break;", " ", "   case 37:", " #line 528 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string));", " ", "         yr_free((yyvsp[-4].c_string));", "         yr_free((yyvsp[-1].sized_string));", " ", "         ERROR_IF((yyval.string) == NULL);", " ", "         compiler->error_line = 0;", "       }", " #line 2033 \"grammar.c\"  ", "     break;", " ", "   case 38:", " #line 540 \"grammar.y\"  ", "     {", "         (yyval.string) = yr_parser_reduce_string_declaration(", "             yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string));", " ", "         yr_free((yyvsp[-2].c_string));", "         yr_free((yyvsp[0].sized_string));", " ", "         ERROR_IF((yyval.string) == NULL);", "       }", " #line 2047 \"grammar.c\"  ", "     break;", " ", "   case 39:", " #line 553 \"grammar.y\"  ", "     { (yyval.integer) = 0; }", " #line 2053 \"grammar.c\"  ", "     break;", " ", "   case 40:", " #line 554 \"grammar.y\"  ", "     { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }", " #line 2059 \"grammar.c\"  ", "     break;", " ", "   case 41:", " #line 559 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_WIDE; }", " #line 2065 \"grammar.c\"  ", "     break;", " ", "   case 42:", " #line 560 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_ASCII; }", " #line 2071 \"grammar.c\"  ", "     break;", " ", "   case 43:", " #line 561 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_NO_CASE; }", " #line 2077 \"grammar.c\"  ", "     break;", " ", "   case 44:", " #line 562 \"grammar.y\"  ", "     { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }", " #line 2083 \"grammar.c\"  ", "     break;", " ", "   case 45:", " #line 568 \"grammar.y\"  ", "     {", "         int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));", " ", "         if (var_index >= 0)", "         {", "           compiler->last_result = yr_parser_emit_with_arg(", "               yyscanner,", "               OP_PUSH_M,", "               LOOP_LOCAL_VARS * var_index,", "               NULL,", "               NULL);", " ", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "           (yyval.expression).identifier = compiler->loop_identifier[var_index];", "         }", "         else", "         {", " ", "           YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(", "               compiler->objects_table, (yyvsp[0].c_string), NULL);", " ", "           if (object == NULL)", "           {", "             char* ns = compiler->current_namespace->name;", " ", "             object = (YR_OBJECT*) yr_hash_table_lookup(", "                 compiler->objects_table, (yyvsp[0].c_string), ns);", "           }", " ", "           if (object != NULL)", "           {", "             char* id;", " ", "             compiler->last_result = yr_arena_write_string(", "                 compiler->sz_arena, (yyvsp[0].c_string), &id);", " ", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_LOAD,", "                   id,", "                   NULL,", "                   NULL);", " ", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = object;", "             (yyval.expression).identifier = object->identifier;", "           }", "           else", "           {", "             YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(", "                 compiler->rules_table,", "                 (yyvsp[0].c_string),", "                 compiler->current_namespace->name);", " ", "             if (rule != NULL)", "             {", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_PUSH_RULE,", "                   rule,", "                   NULL,", "                   NULL);", " ", "               (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "               (yyval.expression).value.integer = UNDEFINED;", "               (yyval.expression).identifier = rule->identifier;", "             }", "             else", "             {", "               yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "               compiler->last_result = ERROR_UNDEFINED_IDENTIFIER;", "             }", "           }", "         }", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2172 \"grammar.c\"  ", "     break;", " ", "   case 46:", " #line 653 \"grammar.y\"  ", "     {", "         YR_OBJECT* field = NULL;", " ", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)", "         {", "           field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));", " ", "           if (field != NULL)", "           {", "             char* ident;", " ", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[0].c_string), &ident);", " ", "             if (compiler->last_result == ERROR_SUCCESS)", "               compiler->last_result = yr_parser_emit_with_arg_reloc(", "                   yyscanner,", "                   OP_OBJ_FIELD,", "                   ident,", "                   NULL,", "                   NULL);", " ", "             (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "             (yyval.expression).value.object = field;", "             (yyval.expression).identifier = field->identifier;", "           }", "           else", "           {", "             yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));", "             compiler->last_result = ERROR_INVALID_FIELD_NAME;", "           }", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-2].expression).identifier);", " ", "           compiler->last_result = ERROR_NOT_A_STRUCTURE;", "         }", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2222 \"grammar.c\"  ", "     break;", " ", "   case 47:", " #line 699 \"grammar.y\"  ", "     {", "         YR_OBJECT_ARRAY* array;", "         YR_OBJECT_DICTIONARY* dict;", " ", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"array indexes must be of integer type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", " ", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_INDEX_ARRAY, NULL);", " ", "           array = (YR_OBJECT_ARRAY*) (yyvsp[-3].expression).value.object;", " ", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = array->prototype_item;", "           (yyval.expression).identifier = array->identifier;", "         }", "         else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "                  (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)", "         {", "           if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)", "           {", "             yr_compiler_set_error_extra_info(", "                 compiler, \"dictionary keys must be of string type\");", "             compiler->last_result = ERROR_WRONG_TYPE;", "           }", " ", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_LOOKUP_DICT, NULL);", " ", "           dict = (YR_OBJECT_DICTIONARY*) (yyvsp[-3].expression).value.object;", " ", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = dict->prototype_item;", "           (yyval.expression).identifier = dict->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", " ", "           compiler->last_result = ERROR_NOT_INDEXABLE;", "         }", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2283 \"grammar.c\"  ", "     break;", " ", "   case 48:", " #line 757 \"grammar.y\"  ", "     {", "         YR_OBJECT_FUNCTION* function;", "         char* args_fmt;", " ", "         if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&", "             (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)", "         {", "           compiler->last_result = yr_parser_check_types(", "               compiler, (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object, (yyvsp[-1].c_string));", " ", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_arena_write_string(", "               compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);", " ", "           if (compiler->last_result == ERROR_SUCCESS)", "             compiler->last_result = yr_parser_emit_with_arg_reloc(", "                 yyscanner,", "                 OP_CALL,", "                 args_fmt,", "                 NULL,", "                 NULL);", " ", "           function = (YR_OBJECT_FUNCTION*) (yyvsp[-3].expression).value.object;", " ", "           (yyval.expression).type = EXPRESSION_TYPE_OBJECT;", "           (yyval.expression).value.object = function->return_obj;", "           (yyval.expression).identifier = function->identifier;", "         }", "         else", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-3].expression).identifier);", " ", "           compiler->last_result = ERROR_NOT_A_FUNCTION;", "         }", " ", "         yr_free((yyvsp[-1].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "       }", " #line 2328 \"grammar.c\"  ", "     break;", " ", "   case 49:", " #line 801 \"grammar.y\"  ", "     { (yyval.c_string) = yr_strdup(\"\"); }", " #line 2334 \"grammar.c\"  ", "     break;", " ", "   case 50:", " #line 802 \"grammar.y\"  ", "     { (yyval.c_string) = (yyvsp[0].c_string); }", " #line 2340 \"grammar.c\"  ", "     break;", " ", "   case 51:", " #line 807 \"grammar.y\"  ", "     {", "         (yyval.c_string) = (char*) yr_malloc(MAX_FUNCTION_ARGS + 1);", " ", "         switch((yyvsp[0].expression).type)", "         {", "           case EXPRESSION_TYPE_INTEGER:", "             strlcpy((yyval.c_string), \"i\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_FLOAT:", "             strlcpy((yyval.c_string), \"f\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_BOOLEAN:", "             strlcpy((yyval.c_string), \"b\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_STRING:", "             strlcpy((yyval.c_string), \"s\", MAX_FUNCTION_ARGS);", "             break;", "           case EXPRESSION_TYPE_REGEXP:", "             strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);", "             break;", "         }", " ", "         ERROR_IF((yyval.c_string) == NULL);", "       }", " #line 2369 \"grammar.c\"  ", "     break;", " ", "   case 52:", " #line 832 \"grammar.y\"  ", "     {", "         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)", "         {", "           compiler->last_result = ERROR_TOO_MANY_ARGUMENTS;", "         }", "         else", "         {", "           switch((yyvsp[0].expression).type)", "           {", "             case EXPRESSION_TYPE_INTEGER:", "               strlcat((yyvsp[-2].c_string), \"i\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_FLOAT:", "               strlcat((yyvsp[-2].c_string), \"f\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_BOOLEAN:", "               strlcat((yyvsp[-2].c_string), \"b\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_STRING:", "               strlcat((yyvsp[-2].c_string), \"s\", MAX_FUNCTION_ARGS);", "               break;", "             case EXPRESSION_TYPE_REGEXP:", "               strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);", "               break;", "           }", "         }", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.c_string) = (yyvsp[-2].c_string);", "       }", " #line 2405 \"grammar.c\"  ", "     break;", " ", "   case 53:", " #line 868 \"grammar.y\"  ", "     {", "         SIZED_STRING* sized_string = (yyvsp[0].sized_string);", "         RE* re;", "         RE_ERROR error;", " ", "         int re_flags = 0;", " ", "         if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)", "           re_flags |= RE_FLAGS_NO_CASE;", " ", "         if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)", "           re_flags |= RE_FLAGS_DOT_ALL;", " ", "         compiler->last_result = yr_re_compile(", "             sized_string->c_string,", "             re_flags,", "             compiler->re_code_arena,", "             &re,", "             &error);", " ", "         yr_free((yyvsp[0].sized_string));", " ", "         if (compiler->last_result == ERROR_INVALID_REGULAR_EXPRESSION)", "           yr_compiler_set_error_extra_info(compiler, error.message);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               re->root_node->forward_code,", "               NULL,", "               NULL);", " ", "         yr_re_destroy(re);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;", "       }", " #line 2451 \"grammar.c\"  ", "     break;", " ", "   case 54:", " #line 914 \"grammar.y\"  ", "     {", "         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)", "         {", "           if ((yyvsp[0].expression).value.sized_string != NULL)", "           {", "             yywarning(yyscanner,", "               \"Using literal string \\\"%s\\\" in a boolean operation.\",", "               (yyvsp[0].expression).value.sized_string->c_string);", "           }", " ", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_STR_TO_BOOL, NULL);", " ", "           ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "         }", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2474 \"grammar.c\"  ", "     break;", " ", "   case 55:", " #line 936 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, 1, NULL, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2487 \"grammar.c\"  ", "     break;", " ", "   case 56:", " #line 945 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, 0, NULL, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2500 \"grammar.c\"  ", "     break;", " ", "   case 57:", " #line 954 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit(", "               yyscanner,", "               OP_MATCHES,", "               NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2519 \"grammar.c\"  ", "     break;", " ", "   case 58:", " #line 969 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");", " ", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_CONTAINS, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2535 \"grammar.c\"  ", "     break;", " ", "   case 59:", " #line 981 \"grammar.y\"  ", "     {", "         int result = yr_parser_reduce_string_identifier(", "             yyscanner,", "             (yyvsp[0].c_string),", "             OP_FOUND,", "             UNDEFINED);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2553 \"grammar.c\"  ", "     break;", " ", "   case 60:", " #line 995 \"grammar.y\"  ", "     {", "         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");", " ", "         compiler->last_result = yr_parser_reduce_string_identifier(", "             yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);", " ", "         yr_free((yyvsp[-2].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2570 \"grammar.c\"  ", "     break;", " ", "   case 61:", " #line 1008 \"grammar.y\"  ", "     {", "         compiler->last_result = yr_parser_reduce_string_identifier(", "             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);", " ", "         yr_free((yyvsp[-2].c_string));", " ", "         ERROR_IF(compiler->last_result!= ERROR_SUCCESS);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "       }", " #line 2585 \"grammar.c\"  ", "     break;", "  ", "    case 62:", "  #line 1019 \"grammar.y\"  ", "     {", "         compiler->loop_depth--;", "         compiler->loop_identifier[compiler->loop_depth] = NULL;", "       }", " #line 2594 \"grammar.c\"  ", "     break;", " ", "   case 63:", " #line 1024 \"grammar.y\"  ", "      {", "          int var_index;", "  ", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "               ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         var_index = yr_parser_lookup_loop_variable(", "             yyscanner, (yyvsp[-1].c_string));", " ", "         if (var_index >= 0)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, (yyvsp[-1].c_string));", " ", "           compiler->last_result = \\", "               ERROR_DUPLICATED_LOOP_IDENTIFIER;", "         }", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         compiler->last_result = yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 2619 \"grammar.c\"  ", " #line 2628 \"grammar.c\"  ", "      break;", "  ", "  case 63:", "#line 1049 \"grammar.y\"  ", "   case 64:", " #line 1054 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", " ", "         if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, &addr, NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);", " ", "           yr_parser_emit_with_arg(", "               yyscanner, OP_POP_M, mem_offset, NULL, NULL);", "         }", " ", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);", "          compiler->loop_depth++;", "        }", "#line 2658 \"grammar.c\"  ", " #line 2667 \"grammar.c\"  ", "      break;", "  ", "  case 64:", "#line 1084 \"grammar.y\"  ", "   case 65:", " #line 1089 \"grammar.y\"  ", "      {", "          int mem_offset;", "  ", "         compiler->loop_depth--;", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", " ", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", " ", "         if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)", "         {", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JNUNDEF,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", "         }", "         else  ", "         {", "           yr_parser_emit_with_arg(", "               yyscanner, OP_INCR_M, mem_offset, NULL, NULL);", " ", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);", " ", "           yr_parser_emit_with_arg(", "               yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);", " ", "           yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_JLE,", "               compiler->loop_address[compiler->loop_depth],", "               NULL,", "               NULL);", " ", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "           yr_parser_emit(yyscanner, OP_POP, NULL);", "         }", " ", "         yr_parser_emit(yyscanner, OP_POP, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", " ", "         compiler->loop_identifier[compiler->loop_depth] = NULL;", "         yr_free((yyvsp[-8].c_string));", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2741 \"grammar.c\"  ", " #line 2750 \"grammar.c\"  ", "      break;", "  ", "  case 65:", "#line 1163 \"grammar.y\"  ", "   case 66:", " #line 1168 \"grammar.y\"  ", "      {", "          int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", "          uint8_t* addr;", " ", "         if (compiler->loop_depth == MAX_LOOP_NESTING)", "           compiler->last_result = \\", "             ERROR_LOOP_NESTING_LIMIT_EXCEEDED;", " ", "         if (compiler->loop_for_of_mem_offset != -1)", "           compiler->last_result = \\", "             ERROR_NESTED_FOR_OF_LOOP;", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_POP_M, mem_offset, &addr, NULL);", " ", "         compiler->loop_for_of_mem_offset = mem_offset;", "         compiler->loop_address[compiler->loop_depth] = addr;", "          compiler->loop_identifier[compiler->loop_depth] = NULL;", "          compiler->loop_depth++;", "        }", "#line 2775 \"grammar.c\"  ", " #line 2784 \"grammar.c\"  ", "      break;", "  ", "  case 66:", "#line 1193 \"grammar.y\"  ", "   case 67:", " #line 1198 \"grammar.y\"  ", "      {", "          int mem_offset;", "  ", "         compiler->loop_depth--;", "         compiler->loop_for_of_mem_offset = -1;", " ", "         mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;", " ", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);", " ", "         yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JNUNDEF,", "             compiler->loop_address[compiler->loop_depth],", "             NULL,", "             NULL);", " ", "         yr_parser_emit(yyscanner, OP_POP, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);", " ", "         yr_parser_emit_with_arg(", "             yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);", " ", "         yr_parser_emit(yyscanner, OP_INT_LE, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "  ", "        }", "#line 2828 \"grammar.c\"  ", " #line 2837 \"grammar.c\"  ", "      break;", "  ", "  case 67:", "#line 1242 \"grammar.y\"  ", "   case 68:", " #line 1247 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_OF, NULL);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2838 \"grammar.c\"  ", " #line 2847 \"grammar.c\"  ", "      break;", "  ", "  case 68:", "#line 1248 \"grammar.y\"  ", "   case 69:", " #line 1253 \"grammar.y\"  ", "      {", "          yr_parser_emit(yyscanner, OP_NOT, NULL);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2848 \"grammar.c\"  ", " #line 2857 \"grammar.c\"  ", "      break;", "  ", "  case 69:", "#line 1254 \"grammar.y\"  ", "   case 70:", " #line 1259 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", " ", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JFALSE,", "             0,           ", "             NULL,", "             &jmp_destination_addr);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", " ", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2878 \"grammar.c\"  ", " #line 2887 \"grammar.c\"  ", "      break;", "  ", "  case 70:", "#line 1280 \"grammar.y\"  ", "   case 71:", " #line 1285 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* and_addr;", " ", " ", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         compiler->last_result = yr_parser_emit(yyscanner, OP_AND, &and_addr);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", " ", "         fixup = compiler->fixup_stack_head;", " ", " ", "         *(void**)(fixup->address) = (void*)(and_addr + 1);", " ", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2918 \"grammar.c\"  ", " #line 2927 \"grammar.c\"  ", "      break;", "  ", "  case 71:", "#line 1316 \"grammar.y\"  ", "   case 72:", " #line 1321 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          void* jmp_destination_addr;", " ", "         compiler->last_result = yr_parser_emit_with_arg_reloc(", "             yyscanner,", "             OP_JTRUE,", "             0,          ", "             NULL,", "             &jmp_destination_addr);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));", " ", "         if (fixup == NULL)", "           compiler->last_error = ERROR_INSUFFICIENT_MEMORY;", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         fixup->address = jmp_destination_addr;", "          fixup->next = compiler->fixup_stack_head;", "          compiler->fixup_stack_head = fixup;", "        }", "#line 2947 \"grammar.c\"  ", " #line 2956 \"grammar.c\"  ", "      break;", "  ", "  case 72:", "#line 1341 \"grammar.y\"  ", "   case 73:", " #line 1346 \"grammar.y\"  ", "      {", "          YR_FIXUP* fixup;", "          uint8_t* or_addr;", " ", " ", "         compiler->last_result = yr_arena_reserve_memory(", "             compiler->code_arena, 2);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         compiler->last_result = yr_parser_emit(yyscanner, OP_OR, &or_addr);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", " ", "         fixup = compiler->fixup_stack_head;", " ", " ", "         *(void**)(fixup->address) = (void*)(or_addr + 1);", " ", "         compiler->fixup_stack_head = fixup->next;", "         yr_free(fixup);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 2987 \"grammar.c\"  ", " #line 2996 \"grammar.c\"  ", "      break;", "  ", "  case 73:", "#line 1377 \"grammar.y\"  ", "   case 74:", " #line 1382 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3000 \"grammar.c\"  ", " #line 3009 \"grammar.c\"  ", "      break;", "  ", "  case 74:", "#line 1386 \"grammar.y\"  ", "   case 75:", " #line 1391 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3013 \"grammar.c\"  ", " #line 3022 \"grammar.c\"  ", "      break;", "  ", "  case 75:", "#line 1395 \"grammar.y\"  ", "   case 76:", " #line 1400 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3026 \"grammar.c\"  ", " #line 3035 \"grammar.c\"  ", "      break;", "  ", "  case 76:", "#line 1404 \"grammar.y\"  ", "   case 77:", " #line 1409 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3039 \"grammar.c\"  ", " #line 3048 \"grammar.c\"  ", "      break;", "  ", "  case 77:", "#line 1413 \"grammar.y\"  ", "   case 78:", " #line 1418 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3052 \"grammar.c\"  ", " #line 3061 \"grammar.c\"  ", "      break;", "  ", "  case 78:", "#line 1422 \"grammar.y\"  ", "   case 79:", " #line 1427 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "        }", "#line 3065 \"grammar.c\"  ", " #line 3074 \"grammar.c\"  ", "      break;", "  ", "  case 79:", "#line 1431 \"grammar.y\"  ", "   case 80:", " #line 1436 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3073 \"grammar.c\"  ", " #line 3082 \"grammar.c\"  ", "      break;", "  ", "  case 80:", "#line 1435 \"grammar.y\"  ", "   case 81:", " #line 1440 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3081 \"grammar.c\"  ", " #line 3090 \"grammar.c\"  ", "      break;", "  ", "  case 81:", "#line 1442 \"grammar.y\"  ", "   case 82:", " #line 1447 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_ENUMERATION; }", "#line 3087 \"grammar.c\"  ", " #line 3096 \"grammar.c\"  ", "      break;", "  ", "  case 82:", "#line 1443 \"grammar.y\"  ", "   case 83:", " #line 1448 \"grammar.y\"  ", "      { (yyval.integer) = INTEGER_SET_RANGE; }", "#line 3093 \"grammar.c\"  ", " #line 3102 \"grammar.c\"  ", "      break;", "  ", "  case 83:", "#line 1449 \"grammar.y\"  ", "   case 84:", " #line 1454 \"grammar.y\"  ", "      {", "          if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's lower bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", " ", "         if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)", "         {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for range's upper bound\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3115 \"grammar.c\"  ", " #line 3124 \"grammar.c\"  ", "      break;", "  ", "  case 84:", "#line 1471 \"grammar.y\"  ", "   case 85:", " #line 1476 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", " ", "         }", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3131 \"grammar.c\"  ", " #line 3140 \"grammar.c\"  ", "      break;", "  ", "  case 85:", "#line 1483 \"grammar.y\"  ", "   case 86:", " #line 1488 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)", "          {", "           yr_compiler_set_error_extra_info(", "               compiler, \"wrong type for enumeration item\");", "           compiler->last_result = ERROR_WRONG_TYPE;", "         }", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3146 \"grammar.c\"  ", " #line 3155 \"grammar.c\"  ", "      break;", "  ", "  case 86:", "#line 1498 \"grammar.y\"  ", "   case 87:", " #line 1503 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3155 \"grammar.c\"  ", " #line 3164 \"grammar.c\"  ", "      break;", "  ", "  case 88:", "#line 1504 \"grammar.y\"  ", "   case 89:", " #line 1509 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "          yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3166 \"grammar.c\"  ", " #line 3175 \"grammar.c\"  ", "      break;", "  ", "  case 91:", "#line 1521 \"grammar.y\"  ", "   case 92:", " #line 1526 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3177 \"grammar.c\"  ", " #line 3186 \"grammar.c\"  ", "      break;", "  ", "  case 92:", "#line 1528 \"grammar.y\"  ", "   case 93:", " #line 1533 \"grammar.y\"  ", "      {", "          yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));", "          yr_free((yyvsp[0].c_string));", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3188 \"grammar.c\"  ", " #line 3197 \"grammar.c\"  ", "      break;", "  ", "  case 94:", "#line 1540 \"grammar.y\"  ", "   case 95:", " #line 1545 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);", "        }", "#line 3196 \"grammar.c\"  ", " #line 3205 \"grammar.c\"  ", "      break;", "  ", "  case 95:", "#line 1544 \"grammar.y\"  ", "   case 96:", " #line 1549 \"grammar.y\"  ", "      {", "          yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);", "        }", "#line 3204 \"grammar.c\"  ", " #line 3213 \"grammar.c\"  ", "      break;", "  ", "  case 96:", "#line 1552 \"grammar.y\"  ", "   case 97:", " #line 1557 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[-1].expression);", "        }", "#line 3212 \"grammar.c\"  ", " #line 3221 \"grammar.c\"  ", "      break;", "  ", "  case 97:", "#line 1556 \"grammar.y\"  ", "   case 98:", " #line 1561 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit(", "              yyscanner, OP_FILESIZE, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3226 \"grammar.c\"  ", " #line 3235 \"grammar.c\"  ", "      break;", "  ", "  case 98:", "#line 1566 \"grammar.y\"  ", "   case 99:", " #line 1571 \"grammar.y\"  ", "      {", "          yywarning(yyscanner,", "              \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"", "             \"function from PE module instead.\");", " ", "         compiler->last_result = yr_parser_emit(", "             yyscanner, OP_ENTRYPOINT, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3244 \"grammar.c\"  ", " #line 3253 \"grammar.c\"  ", "      break;", "  ", "  case 99:", "#line 1580 \"grammar.y\"  ", "   case 100:", " #line 1585 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");", "  ", " ", "         compiler->last_result = yr_parser_emit(", "             yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3264 \"grammar.c\"  ", " #line 3273 \"grammar.c\"  ", "      break;", "  ", "  case 100:", "#line 1596 \"grammar.y\"  ", "   case 101:", " #line 1601 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = (yyvsp[0].integer);", "        }", "#line 3278 \"grammar.c\"  ", " #line 3287 \"grammar.c\"  ", "      break;", "  ", "  case 101:", "#line 1606 \"grammar.y\"  ", "   case 102:", " #line 1611 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg_double(", "              yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "  ", "          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "        }", "#line 3291 \"grammar.c\"  ", " #line 3300 \"grammar.c\"  ", "      break;", "  ", "  case 102:", "#line 1615 \"grammar.y\"  ", "   case 103:", " #line 1620 \"grammar.y\"  ", "      {", "          SIZED_STRING* sized_string;", "  ", "         compiler->last_result = yr_arena_write_data(", "             compiler->sz_arena,", "             (yyvsp[0].sized_string),", "             (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),", "             (void**) &sized_string);", " ", "         yr_free((yyvsp[0].sized_string));", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_emit_with_arg_reloc(", "               yyscanner,", "               OP_PUSH,", "               sized_string,", "               NULL,", "               NULL);", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_STRING;", "          (yyval.expression).value.sized_string = sized_string;", "        }", "#line 3320 \"grammar.c\"  ", " #line 3329 \"grammar.c\"  ", "      break;", "  ", "  case 103:", "#line 1640 \"grammar.y\"  ", "   case 104:", " #line 1645 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3336 \"grammar.c\"  ", " #line 3345 \"grammar.c\"  ", "      break;", "  ", "  case 104:", "#line 1652 \"grammar.y\"  ", "   case 105:", " #line 1657 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);", " ", "         yr_free((yyvsp[-3].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3352 \"grammar.c\"  ", " #line 3361 \"grammar.c\"  ", "      break;", "  ", "  case 105:", "#line 1664 \"grammar.y\"  ", "   case 106:", " #line 1669 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3372 \"grammar.c\"  ", " #line 3381 \"grammar.c\"  ", "      break;", "  ", "  case 106:", "#line 1680 \"grammar.y\"  ", "   case 107:", " #line 1685 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_string_identifier(", "              yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);", " ", "         yr_free((yyvsp[-3].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3388 \"grammar.c\"  ", " #line 3397 \"grammar.c\"  ", "      break;", "  ", "  case 107:", "#line 1692 \"grammar.y\"  ", "   case 108:", " #line 1697 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_emit_with_arg(", "              yyscanner, OP_PUSH, 1, NULL, NULL);", " ", "         if (compiler->last_result == ERROR_SUCCESS)", "           compiler->last_result = yr_parser_reduce_string_identifier(", "               yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);", " ", "         yr_free((yyvsp[0].c_string));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = UNDEFINED;", "        }", "#line 3408 \"grammar.c\"  ", " #line 3417 \"grammar.c\"  ", "      break;", "  ", "  case 108:", "#line 1708 \"grammar.y\"  ", "   case 109:", " #line 1713 \"grammar.y\"  ", "      {", "          if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)   ", "          {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)   ", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;", "           (yyval.expression).value.integer = UNDEFINED;", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)", "         {", "           compiler->last_result = yr_parser_emit(", "               yyscanner, OP_OBJ_VALUE, NULL);", " ", "           switch((yyvsp[0].expression).value.object->type)", "           {", "             case OBJECT_TYPE_INTEGER:", "               (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "               (yyval.expression).value.integer = UNDEFINED;", "               break;", "             case OBJECT_TYPE_FLOAT:", "               (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "               break;", "             case OBJECT_TYPE_STRING:", "               (yyval.expression).type = EXPRESSION_TYPE_STRING;", "               (yyval.expression).value.sized_string = NULL;", "               break;", "             default:", "               yr_compiler_set_error_extra_info_fmt(", "                   compiler,", "                   \"wrong usage of identifier \\\"%s\\\"\",", "                   (yyvsp[0].expression).identifier);", "               compiler->last_result = ERROR_WRONG_TYPE;", "           }", "         }", "         else", "         {", "           assert(FALSE);", "         }", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3457 \"grammar.c\"  ", " #line 3466 \"grammar.c\"  ", "      break;", "  ", "  case 109:", "#line 1753 \"grammar.y\"  ", "   case 110:", " #line 1758 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");", "  ", "         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "               UNDEFINED : -((yyvsp[0].expression).value.integer);", "           compiler->last_result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);", "         }", "         else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)", "         {", "           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "           compiler->last_result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);", "         }", "  ", "          ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "        }", "#line 3480 \"grammar.c\"  ", " #line 3489 \"grammar.c\"  ", "      break;", "  ", "  case 110:", "#line 1772 \"grammar.y\"  ", "   case 111:", " #line 1777 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(+, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3502 \"grammar.c\"  ", " #line 3511 \"grammar.c\"  ", "      break;", "  ", "  case 111:", "#line 1790 \"grammar.y\"  ", "   case 112:", " #line 1795 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(-, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3524 \"grammar.c\"  ", " #line 3533 \"grammar.c\"  ", "      break;", "  ", "  case 112:", "#line 1808 \"grammar.y\"  ", "   case 113:", " #line 1813 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           (yyval.expression).value.integer = OPERATION(*, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3546 \"grammar.c\"  ", " #line 3555 \"grammar.c\"  ", "      break;", "  ", "  case 113:", "#line 1826 \"grammar.y\"  ", "   case 114:", " #line 1831 \"grammar.y\"  ", "      {", "          compiler->last_result = yr_parser_reduce_operation(", "              yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));", " ", "         ERROR_IF(compiler->last_result != ERROR_SUCCESS);", " ", "         if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&", "             (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)", "         {", "           if ((yyvsp[0].expression).value.integer != 0)", "           {", "             (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "             (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "           }", "           else", "           {", "             compiler->last_result = ERROR_DIVISION_BY_ZERO;", "             ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "           }", "         }", "         else", "         {", "            (yyval.expression).type = EXPRESSION_TYPE_FLOAT;", "          }", "        }", "#line 3576 \"grammar.c\"  ", " #line 3585 \"grammar.c\"  ", "      break;", "  ", "  case 114:", "#line 1852 \"grammar.y\"  ", "   case 115:", " #line 1857 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");", " ", "         yr_parser_emit(yyscanner, OP_MOD, NULL);", " ", "         if ((yyvsp[0].expression).value.integer != 0)", "         {", "           (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "           (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "         }", "         else", "         {", "           compiler->last_result = ERROR_DIVISION_BY_ZERO;", "            ERROR_IF(compiler->last_result != ERROR_SUCCESS);", "          }", "        }", "#line 3598 \"grammar.c\"  ", " #line 3607 \"grammar.c\"  ", "      break;", "  ", "  case 115:", "#line 1870 \"grammar.y\"  ", "   case 116:", " #line 1875 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", " ", "         yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3612 \"grammar.c\"  ", " #line 3621 \"grammar.c\"  ", "      break;", "  ", "  case 116:", "#line 1880 \"grammar.y\"  ", "   case 117:", " #line 1885 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");", " ", "         yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3626 \"grammar.c\"  ", " #line 3635 \"grammar.c\"  ", "      break;", "  ", "  case 117:", "#line 1890 \"grammar.y\"  ", "   case 118:", " #line 1895 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");", " ", "         yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3640 \"grammar.c\"  ", " #line 3649 \"grammar.c\"  ", "      break;", "  ", "  case 118:", "#line 1900 \"grammar.y\"  ", "   case 119:", " #line 1905 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");", "  ", "         yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL);", " ", "         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?", "              UNDEFINED : ~((yyvsp[0].expression).value.integer);", "        }", "#line 3654 \"grammar.c\"  ", " #line 3663 \"grammar.c\"  ", "      break;", "  ", "  case 119:", "#line 1910 \"grammar.y\"  ", "   case 120:", " #line 1915 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");", " ", "         yr_parser_emit(yyscanner, OP_SHL, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3668 \"grammar.c\"  ", " #line 3677 \"grammar.c\"  ", "      break;", "  ", "  case 120:", "#line 1920 \"grammar.y\"  ", "   case 121:", " #line 1925 \"grammar.y\"  ", "      {", "          CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");", "          CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");", " ", "         yr_parser_emit(yyscanner, OP_SHR, NULL);", " ", "          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;", "          (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);", "        }", "#line 3682 \"grammar.c\"  ", " #line 3691 \"grammar.c\"  ", "      break;", "  ", "  case 121:", "#line 1930 \"grammar.y\"  ", "   case 122:", " #line 1935 \"grammar.y\"  ", "      {", "          (yyval.expression) = (yyvsp[0].expression);", "        }", "#line 3690 \"grammar.c\"  ", " #line 3699 \"grammar.c\"  ", "      break;", "  ", "  ", "#line 3694 \"grammar.c\"  ", " #line 3703 \"grammar.c\"  ", "        default: break;", "      }", "     ", "   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);", " ", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", " ", "   *++yyvsp = yyval;", " ", "    ", " ", "   yyn = yyr1[yyn];", " ", "   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;", "   if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)", "     yystate = yytable[yystate];", "   else", "     yystate = yydefgoto[yyn - YYNTOKENS];", " ", "   goto yynewstate;", " ", " ", "  ", " yyerrlab:", "    ", "   yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);", " ", "    ", "   if (!yyerrstatus)", "     {", "       ++yynerrs;", " #if ! YYERROR_VERBOSE", "       yyerror (yyscanner, compiler, YY_(\"syntax error\"));", " #else", " # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \\", "                                         yyssp, yytoken)", "       {", "         char const *yymsgp = YY_(\"syntax error\");", "         int yysyntax_error_status;", "         yysyntax_error_status = YYSYNTAX_ERROR;", "         if (yysyntax_error_status == 0)", "           yymsgp = yymsg;", "         else if (yysyntax_error_status == 1)", "           {", "             if (yymsg != yymsgbuf)", "               YYSTACK_FREE (yymsg);", "             yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);", "             if (!yymsg)", "               {", "                 yymsg = yymsgbuf;", "                 yymsg_alloc = sizeof yymsgbuf;", "                 yysyntax_error_status = 2;", "               }", "             else", "               {", "                 yysyntax_error_status = YYSYNTAX_ERROR;", "                 yymsgp = yymsg;", "               }", "           }", "         yyerror (yyscanner, compiler, yymsgp);", "         if (yysyntax_error_status == 2)", "           goto yyexhaustedlab;", "       }", " # undef YYSYNTAX_ERROR", " #endif", "     }", " ", " ", " ", "   if (yyerrstatus == 3)", "     {", "        ", " ", "       if (yychar <= YYEOF)", "         {", "            ", "           if (yychar == YYEOF)", "             YYABORT;", "         }", "       else", "         {", "           yydestruct (\"Error: discarding\",", "                       yytoken, &yylval, yyscanner, compiler);", "           yychar = YYEMPTY;", "         }", "     }", " ", "    ", "   goto yyerrlab1;", " ", " ", "  ", " yyerrorlab:", " ", "    ", "   if (  0)", "      goto yyerrorlab;", " ", "    ", "   YYPOPSTACK (yylen);", "   yylen = 0;", "   YY_STACK_PRINT (yyss, yyssp);", "   yystate = *yyssp;", "   goto yyerrlab1;", " ", " ", "  ", " yyerrlab1:", "   yyerrstatus = 3;       ", " ", "   for (;;)", "     {", "       yyn = yypact[yystate];", "       if (!yypact_value_is_default (yyn))", "         {", "           yyn += YYTERROR;", "           if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)", "             {", "               yyn = yytable[yyn];", "               if (0 < yyn)", "                 break;", "             }", "         }", " ", "        ", "       if (yyssp == yyss)", "         YYABORT;", " ", " ", "       yydestruct (\"Error: popping\",", "                   yystos[yystate], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "       yystate = *yyssp;", "       YY_STACK_PRINT (yyss, yyssp);", "     }", " ", "   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN", "   *++yyvsp = yylval;", "   YY_IGNORE_MAYBE_UNINITIALIZED_END", " ", " ", "    ", "   YY_SYMBOL_PRINT (\"Shifting\", yystos[yyn], yyvsp, yylsp);", " ", "   yystate = yyn;", "   goto yynewstate;", " ", " ", "  ", " yyacceptlab:", "   yyresult = 0;", "   goto yyreturn;", " ", "  ", " yyabortlab:", "   yyresult = 1;", "   goto yyreturn;", " ", " #if !defined yyoverflow || YYERROR_VERBOSE", "  ", " yyexhaustedlab:", "   yyerror (yyscanner, compiler, YY_(\"memory exhausted\"));", "   yyresult = 2;", "    ", " #endif", " ", " yyreturn:", "   if (yychar != YYEMPTY)", "     {", "        ", "       yytoken = YYTRANSLATE (yychar);", "       yydestruct (\"Cleanup: discarding lookahead\",", "                   yytoken, &yylval, yyscanner, compiler);", "     }", "    ", "   YYPOPSTACK (yylen);", "   YY_STACK_PRINT (yyss, yyssp);", "   while (yyssp != yyss)", "     {", "       yydestruct (\"Cleanup: popping\",", "                   yystos[*yyssp], yyvsp, yyscanner, compiler);", "       YYPOPSTACK (1);", "     }", " #ifndef yyoverflow", "   if (yyss != yyssa)", "     YYSTACK_FREE (yyss);", " #endif", " #if YYERROR_VERBOSE", "   if (yymsg != yymsgbuf)", "     YYSTACK_FREE (yymsg);", "  #endif", "    return yyresult;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool ASessionDescription::getDimensions(", "  size_t index, unsigned long PT,", "  int32_t *width, int32_t *height) const {", " ", "      *width = 0;", "      *height = 0;", "  ", "    char key[20];", "    sprintf(key, \"a=framesize:%lu\", PT);", "     char key[33];", "     snprintf(key, sizeof(key), \"a=framesize:%lu\", PT);", "     if (PT > 9999999) {", "         android_errorWriteLog(0x534e4554, \"25747670\");", "     }", "      AString value;", "      if (!findAttribute(index, key, &value)) {", "          return false;", "  }", " ", "  const char *s = value.c_str();", "  char *end;", "  *width = strtoul(s, &end, 10);", "     CHECK_GT(end, s);", "     CHECK_EQ(*end, '-');", " ", "     s = end + 1;", "  *height = strtoul(s, &end, 10);", "     CHECK_GT(end, s);", "     CHECK_EQ(*end, '\\0');", " ", "  return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["create_worker_threads(uint n)", "{", "comp_thread_ctxt_t *threads;", "uint    i;", "", "threads = (comp_thread_ctxt_t *)", "my_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));", "", "for (i = 0; i < n; i++) {", "comp_thread_ctxt_t *thd = threads + i;", "", "thd->num = i + 1;", "thd->started = FALSE;", "thd->cancelled = FALSE;", "thd->data_avail = FALSE;", "", "thd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +", "MY_QLZ_COMPRESS_OVERHEAD,", "MYF(MY_FAE));", "", "", "if (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||", "pthread_cond_init(&thd->ctrl_cond, NULL)) {", "goto err;", "}", "", "", "if (pthread_mutex_init(&thd->data_mutex, NULL) ||", "pthread_cond_init(&thd->data_cond, NULL)) {", "goto err;", "}", "", "pthread_mutex_lock(&thd->ctrl_mutex);", "", "if (pthread_create(&thd->id, NULL, compress_worker_thread_func,", "thd)) {", "msg(\"compress: pthread_create() failed: \"", "\"errno = %d\", errno);", "pthread_mutex_unlock(&thd->ctrl_mutex);", "goto err;", "}", "}", "", "", "for (i = 0; i < n; i++) {", "comp_thread_ctxt_t *thd = threads + i;", "", "while (thd->started == FALSE)", "pthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);", "pthread_mutex_unlock(&thd->ctrl_mutex);", "}", "", "return threads;", "", "err:", "my_free(threads);", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)", " {", " \tstruct svcxprt_rdma *listen_rdma;", " \tstruct svcxprt_rdma *newxprt = NULL;", " \tstruct rdma_conn_param conn_param;", " \tstruct rpcrdma_connect_private pmsg;", " \tstruct ib_qp_init_attr qp_attr;", " \tstruct ib_device *dev;", " \tstruct sockaddr *sap;", " \tunsigned int i;", " \tint ret = 0;", " ", " \tlisten_rdma = container_of(xprt, struct svcxprt_rdma, sc_xprt);", " \tclear_bit(XPT_CONN, &xprt->xpt_flags);", " \t ", " \tspin_lock_bh(&listen_rdma->sc_lock);", " \tif (!list_empty(&listen_rdma->sc_accept_q)) {", " \t\tnewxprt = list_entry(listen_rdma->sc_accept_q.next,", " \t\t\t\t     struct svcxprt_rdma, sc_accept_q);", " \t\tlist_del_init(&newxprt->sc_accept_q);", " \t}", " \tif (!list_empty(&listen_rdma->sc_accept_q))", " \t\tset_bit(XPT_CONN, &listen_rdma->sc_xprt.xpt_flags);", " \tspin_unlock_bh(&listen_rdma->sc_lock);", " \tif (!newxprt)", " \t\treturn NULL;", " ", " \tdprintk(\"svcrdma: newxprt from accept queue = %p, cm_id=%p\\n\",", "  \t\tnewxprt, newxprt->sc_cm_id);", "  ", "  \tdev = newxprt->sc_cm_id->device;", " \tnewxprt->sc_port_num = newxprt->sc_cm_id->port_num;", "  ", "  \t ", " \tnewxprt->sc_max_sge = min((size_t)dev->attrs.max_sge,", " \t\t\t\t  (size_t)RPCSVC_MAXPAGES);", " \tnewxprt->sc_max_sge_rd = min_t(size_t, dev->attrs.max_sge_rd,", " \t\t\t\t       RPCSVC_MAXPAGES);", " \tnewxprt->sc_max_req_size = svcrdma_max_req_size;", " \tnewxprt->sc_max_requests = min_t(u32, dev->attrs.max_qp_wr,", " \t\t\t\t\t svcrdma_max_requests);", " \tnewxprt->sc_fc_credits = cpu_to_be32(newxprt->sc_max_requests);", " \tnewxprt->sc_max_bc_requests = min_t(u32, dev->attrs.max_qp_wr,", "  \t\t\t\t\t    svcrdma_max_bc_requests);", "  \tnewxprt->sc_rq_depth = newxprt->sc_max_requests +", "  \t\t\t       newxprt->sc_max_bc_requests;", "\tnewxprt->sc_sq_depth = RPCRDMA_SQ_DEPTH_MULT * newxprt->sc_rq_depth;", " \tnewxprt->sc_sq_depth = newxprt->sc_rq_depth;", "  \tatomic_set(&newxprt->sc_sq_avail, newxprt->sc_sq_depth);", "  ", "  \tif (!svc_rdma_prealloc_ctxts(newxprt))", "  \t\tgoto errout;", "\tif (!svc_rdma_prealloc_maps(newxprt))", "\t\tgoto errout;", "  ", "  \t ", " \tnewxprt->sc_ord = min_t(size_t, dev->attrs.max_qp_rd_atom, newxprt->sc_ord);", " \tnewxprt->sc_ord = min_t(size_t,\tsvcrdma_ord, newxprt->sc_ord);", " ", " \tnewxprt->sc_pd = ib_alloc_pd(dev, 0);", " \tif (IS_ERR(newxprt->sc_pd)) {", " \t\tdprintk(\"svcrdma: error creating PD for connect request\\n\");", " \t\tgoto errout;", " \t}", " \tnewxprt->sc_sq_cq = ib_alloc_cq(dev, newxprt, newxprt->sc_sq_depth,", " \t\t\t\t\t0, IB_POLL_WORKQUEUE);", " \tif (IS_ERR(newxprt->sc_sq_cq)) {", " \t\tdprintk(\"svcrdma: error creating SQ CQ for connect request\\n\");", " \t\tgoto errout;", " \t}", " \tnewxprt->sc_rq_cq = ib_alloc_cq(dev, newxprt, newxprt->sc_rq_depth,", " \t\t\t\t\t0, IB_POLL_WORKQUEUE);", " \tif (IS_ERR(newxprt->sc_rq_cq)) {", " \t\tdprintk(\"svcrdma: error creating RQ CQ for connect request\\n\");", " \t\tgoto errout;", " \t}", " ", "  \tmemset(&qp_attr, 0, sizeof qp_attr);", "  \tqp_attr.event_handler = qp_event_handler;", "  \tqp_attr.qp_context = &newxprt->sc_xprt;", " \tqp_attr.port_num = newxprt->sc_cm_id->port_num;", " \tqp_attr.cap.max_rdma_ctxs = newxprt->sc_max_requests;", "  \tqp_attr.cap.max_send_wr = newxprt->sc_sq_depth;", "  \tqp_attr.cap.max_recv_wr = newxprt->sc_rq_depth;", "  \tqp_attr.cap.max_send_sge = newxprt->sc_max_sge;", " \tqp_attr.cap.max_recv_sge = newxprt->sc_max_sge;", " \tqp_attr.sq_sig_type = IB_SIGNAL_REQ_WR;", " \tqp_attr.qp_type = IB_QPT_RC;", " \tqp_attr.send_cq = newxprt->sc_sq_cq;", " \tqp_attr.recv_cq = newxprt->sc_rq_cq;", " \tdprintk(\"svcrdma: newxprt->sc_cm_id=%p, newxprt->sc_pd=%p\\n\",", " \t\tnewxprt->sc_cm_id, newxprt->sc_pd);", " \tdprintk(\"    cap.max_send_wr = %d, cap.max_recv_wr = %d\\n\",", " \t\tqp_attr.cap.max_send_wr, qp_attr.cap.max_recv_wr);", " \tdprintk(\"    cap.max_send_sge = %d, cap.max_recv_sge = %d\\n\",", " \t\tqp_attr.cap.max_send_sge, qp_attr.cap.max_recv_sge);", " ", " \tret = rdma_create_qp(newxprt->sc_cm_id, newxprt->sc_pd, &qp_attr);", " \tif (ret) {", " \t\tdprintk(\"svcrdma: failed to create QP, ret=%d\\n\", ret);", " \t\tgoto errout;", " \t}", " \tnewxprt->sc_qp = newxprt->sc_cm_id->qp;", " ", " \t ", " \tnewxprt->sc_reader = rdma_read_chunk_lcl;", " \tif (dev->attrs.device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {", " \t\tnewxprt->sc_frmr_pg_list_len =", " \t\t\tdev->attrs.max_fast_reg_page_list_len;", " \t\tnewxprt->sc_dev_caps |= SVCRDMA_DEVCAP_FAST_REG;", " \t\tnewxprt->sc_reader = rdma_read_chunk_frmr;", " \t} else", " \t\tnewxprt->sc_snd_w_inv = false;", " ", " \t ", " \tif (!rdma_protocol_iwarp(dev, newxprt->sc_cm_id->port_num) &&", " \t    !rdma_ib_or_roce(dev, newxprt->sc_cm_id->port_num))", " \t\tgoto errout;", " ", " \tif (rdma_protocol_iwarp(dev, newxprt->sc_cm_id->port_num))", " \t\tnewxprt->sc_dev_caps |= SVCRDMA_DEVCAP_READ_W_INV;", " ", " \t ", " \tfor (i = 0; i < newxprt->sc_max_requests; i++) {", " \t\tret = svc_rdma_post_recv(newxprt, GFP_KERNEL);", " \t\tif (ret) {", " \t\t\tdprintk(\"svcrdma: failure posting receive buffers\\n\");", " \t\t\tgoto errout;", " \t\t}", " \t}", " ", " \t ", " \tnewxprt->sc_cm_id->event_handler = rdma_cma_handler;", " ", " \t ", " \tpmsg.cp_magic = rpcrdma_cmp_magic;", " \tpmsg.cp_version = RPCRDMA_CMP_VERSION;", " \tpmsg.cp_flags = 0;", " \tpmsg.cp_send_size = pmsg.cp_recv_size =", " \t\trpcrdma_encode_buffer_size(newxprt->sc_max_req_size);", " ", " \t ", " \tset_bit(RDMAXPRT_CONN_PENDING, &newxprt->sc_flags);", " \tmemset(&conn_param, 0, sizeof conn_param);", " \tconn_param.responder_resources = 0;", " \tconn_param.initiator_depth = newxprt->sc_ord;", " \tconn_param.private_data = &pmsg;", " \tconn_param.private_data_len = sizeof(pmsg);", " \tret = rdma_accept(newxprt->sc_cm_id, &conn_param);", " \tif (ret) {", " \t\tdprintk(\"svcrdma: failed to accept new connection, ret=%d\\n\",", " \t\t       ret);", " \t\tgoto errout;", " \t}", " ", " \tdprintk(\"svcrdma: new connection %p accepted:\\n\", newxprt);", " \tsap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.src_addr;", " \tdprintk(\"    local address   : %pIS:%u\\n\", sap, rpc_get_port(sap));", " \tsap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.dst_addr;", " \tdprintk(\"    remote address  : %pIS:%u\\n\", sap, rpc_get_port(sap));", " \tdprintk(\"    max_sge         : %d\\n\", newxprt->sc_max_sge);", " \tdprintk(\"    max_sge_rd      : %d\\n\", newxprt->sc_max_sge_rd);", " \tdprintk(\"    sq_depth        : %d\\n\", newxprt->sc_sq_depth);", " \tdprintk(\"    max_requests    : %d\\n\", newxprt->sc_max_requests);", " \tdprintk(\"    ord             : %d\\n\", newxprt->sc_ord);", " ", " \treturn &newxprt->sc_xprt;", " ", "  errout:", " \tdprintk(\"svcrdma: failure accepting new connection rc=%d.\\n\", ret);", " \t ", " \tsvc_xprt_get(&newxprt->sc_xprt);", " \tif (newxprt->sc_qp && !IS_ERR(newxprt->sc_qp))", " \t\tib_destroy_qp(newxprt->sc_qp);", " \trdma_destroy_id(newxprt->sc_cm_id);", " \t ", " \tsvc_xprt_put(&newxprt->sc_xprt);", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void set_own_dir(const char *argv0) {", " \tsize_t l = strlen(argv0);", "  \twhile(l && argv0[l - 1] != '/')", "  \t\tl--;", "  \tif(l == 0)", " #ifdef SUPER_SECURE", " \t\tmemcpy(own_dir, \"/dev/null/\", 2);", " #else", "  \t\tmemcpy(own_dir, \".\", 2);", " #endif", "  \telse {", "  \t\tmemcpy(own_dir, argv0, l - 1);", "  \t\town_dir[l] = 0;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void GpuProcessHost::OnAcceleratedSurfaceBuffersSwapped(", "     const GpuHostMsg_AcceleratedSurfaceBuffersSwapped_Params& params) {", "   TRACE_EVENT0(\"gpu\", \"GpuProcessHost::OnAcceleratedSurfaceBuffersSwapped\");", " ", "   gfx::PluginWindowHandle handle =", "       GpuSurfaceTracker::Get()->GetSurfaceWindowHandle(params.surface_id);", "   if (handle != gfx::kNullPluginWindow) {", "     RouteOnUIThread(GpuHostMsg_AcceleratedSurfaceBuffersSwapped(params));", "     return;", "   }", " ", "    base::ScopedClosureRunner scoped_completion_runner(", "        base::Bind(&AcceleratedSurfaceBuffersSwappedCompletedForGPU,", "                   host_id_, params.route_id,", "                 true  , false  ));", "                  true  , params.surface_handle));", "  ", "    int render_process_id = 0;", "    int render_widget_id = 0;", "   if (!GpuSurfaceTracker::Get()->GetRenderWidgetIDForSurface(", "       params.surface_id, &render_process_id, &render_widget_id)) {", "     return;", "   }", "   RenderWidgetHelper* helper =", "       RenderWidgetHelper::FromProcessHostID(render_process_id);", "   if (!helper)", "     return;", " ", "   scoped_completion_runner.Release();", "   helper->DidReceiveBackingStoreMsg(ViewHostMsg_CompositorSurfaceBuffersSwapped(", "       render_widget_id,", "       params.surface_id,", "       params.surface_handle,", "       params.route_id,", "       params.size,", "       host_id_));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec,", "  dec_slice_params_t * ps_slice,", "                                            UWORD16 u2_first_mb_in_slice)", " {", "     UWORD32 uc_more_data_flag;", "     WORD32 i2_cur_mb_addr;", "     UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx;", "     UWORD32 i2_mb_skip_run;", "     UWORD32 u1_read_mb_type;", " ", "     UWORD32 u1_mbaff;", "     UWORD32 u1_num_mbs_next, u1_end_of_row;", "  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;", "     UWORD32 u1_slice_end = 0;", "     UWORD32 u1_tfr_n_mb = 0;", "     UWORD32 u1_decode_nmb = 0;", " ", "  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;", "  deblk_mb_t *ps_cur_deblk_mb;", "  dec_mb_info_t *ps_cur_mb_info;", "  parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "     UWORD32 u1_inter_mb_type;", "     UWORD32 u1_deblk_mb_type;", "     UWORD32 u1_mb_threshold;", "     WORD32 ret = OK;", " ", "   ", "   ", "   ", " ", "  if(ps_slice->u1_slice_type == P_SLICE)", "  {", "         u1_inter_mb_type = P_MB;", "         u1_deblk_mb_type = D_INTER_MB;", "         u1_mb_threshold = 5;", "  }", "  else  ", "  {", "         u1_inter_mb_type = B_MB;", "         u1_deblk_mb_type = D_B_SLICE;", "         u1_mb_threshold = 23;", "  }", "   ", "   ", "   ", "     ps_dec->u1_qp = ps_slice->u1_slice_qp;", "     ih264d_update_qp(ps_dec, 0);", "     u1_mb_idx = ps_dec->u1_mb_idx;", "     u1_num_mbs = u1_mb_idx;", " ", "     u1_num_mbsNby2 = 0;", "     u1_mbaff = ps_slice->u1_mbaff_frame_flag;", "     i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff;", "     i2_mb_skip_run = 0;", "     uc_more_data_flag = 1;", "     u1_read_mb_type = 0;", " ", "  while(!u1_slice_end)", "  {", "         UWORD8 u1_mb_type;", " ", "         ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;", " ", "  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)", "  {", "             ret = ERROR_MB_ADDRESS_T;", "  break;", "  }", " ", " ", "         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;", "         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;", " ", "         ps_cur_mb_info->u1_Mux = 0;", "         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);", "         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;", " ", "         ps_cur_mb_info->u1_end_of_slice = 0;", " ", "   ", "         ps_parse_mb_data->u1_num_part = 1;", "         ps_parse_mb_data->u1_isI_mb = 0;", " ", "  if((!i2_mb_skip_run) && (!u1_read_mb_type))", "  {", " ", "             UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;", "             UWORD32 u4_word, u4_ldz;", " ", "   ", "   ", "   ", "             NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);", " ", "             u4_ldz = CLZ(u4_word);", " ", "   ", "             u4_bitstream_offset += (u4_ldz + 1);", "   ", "             u4_word = 0;", "  if(u4_ldz)", "  {", "                 GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,", "                         u4_ldz);", "  }", "  *pu4_bitstrm_ofst = u4_bitstream_offset;", "             i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1);", "             COPYTHECONTEXT(\"mb_skip_run\", i2_mb_skip_run);", "             uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);", "             u1_read_mb_type = uc_more_data_flag;", "  }", " ", "   ", "   ", "   ", "   ", "         ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", " ", "   ", "   ", "   ", "  if(ps_dec->u4_app_disable_deblk_frm == 0)", "             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,", "                                              ps_dec->u1_mb_ngbr_availablity,", "                                              ps_dec->u1_cur_mb_fld_dec_flag);", " ", "  if(i2_mb_skip_run)", "  {", "   ", "             ps_dec->i1_prev_mb_qp_delta = 0;", "             ps_dec->u1_sub_mb_num = 0;", "             ps_cur_mb_info->u1_mb_type = MB_SKIP;", "             ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;", "             ps_cur_mb_info->u1_cbp = 0;", " ", "  {", "   ", "  parse_part_params_t *ps_part_info = ps_dec->ps_part;", "                 ps_part_info->u1_is_direct = PART_DIRECT_16x16;", "                 ps_part_info->u1_sub_mb_num = 0;", "                 ps_dec->ps_part++;", "  }", " ", "   ", "             ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);", " ", "             ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;", "             ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;", " ", "             i2_mb_skip_run--;", "  }", "  else", "  {", "             u1_read_mb_type = 0;", "   ", "   ", "   ", "  {", "                 UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst;", "                 UWORD32 u4_word, u4_ldz, u4_temp;", " ", " ", "   ", "   ", "   ", "                 NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf);", "                 u4_ldz = CLZ(u4_word);", "   ", "                 u4_bitstream_offset += (u4_ldz + 1);", "   ", "                 u4_word = 0;", "  if(u4_ldz)", "                     GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf,", "                             u4_ldz);", "  *pu4_bitstrm_ofst = u4_bitstream_offset;", "                 u4_temp = ((1 << u4_ldz) + u4_word - 1);", "  if(u4_temp > (UWORD32)(25 + u1_mb_threshold))", "  return ERROR_MB_TYPE;", "                 u1_mb_type = u4_temp;", "                 COPYTHECONTEXT(\"u1_mb_type\", u1_mb_type);", "  }", "             ps_cur_mb_info->u1_mb_type = u1_mb_type;", " ", "   ", "   ", "   ", "  if(u1_mb_type < u1_mb_threshold)", "  {", "                 ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;", " ", "                 ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs,", "                                           u1_num_mbsNby2);", "  if(ret != OK)", "  return ret;", "                 ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;", "  }", "  else", "  {", "   ", "                 ps_parse_mb_data->u1_num_part = 0;", "                 ps_parse_mb_data->u1_isI_mb = 1;", " ", "  if((25 + u1_mb_threshold) == u1_mb_type)", "  {", "   ", "                     ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB;", "                     ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs);", "  if(ret != OK)", "  return ret;", "                     ps_dec->u1_qp = 0;", "  }", "  else", "  {", "                     ret = ih264d_parse_imb_cavlc(", "                                     ps_dec, ps_cur_mb_info, u1_num_mbs,", "  (UWORD8)(u1_mb_type - u1_mb_threshold));", "  if(ret != OK)", "  return ret;", "  }", " ", "                 ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB;", "  }", "             uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm);", "  }", "         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;", " ", " ", "          if(u1_mbaff)", "          {", "              ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);", "             if(!uc_more_data_flag && !i2_mb_skip_run && (0 == (i2_cur_mb_addr & 1)))", "             {", "                 return ERROR_EOB_FLUSHBITS_T;", "             }", "          }", "           ", "           ", "   ", "         i2_cur_mb_addr++;", " ", "         u1_num_mbs++;", "         u1_num_mbsNby2++;", "         ps_parse_mb_data++;", " ", "   ", "   ", "   ", "   ", "   ", "         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "         u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run));", "         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row", "  || u1_slice_end;", "         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;", "         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "   ", " ", "  if(u1_decode_nmb)", "  {", "             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);", "             u1_num_mbsNby2 = 0;", " ", "  {", "                 ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "                 ps_dec->ps_part = ps_dec->ps_parse_part_params;", "  }", "  }", " ", "   ", "  if(u1_decode_nmb)", "  {", " ", " ", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                 ps_dec->ps_nmb_info +=  u1_num_mbs;", "  }", "  else", "  {", "                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                                             u1_num_mbs_next, u1_tfr_n_mb,", "                                             u1_end_of_row);", "  }", "             ps_dec->u2_total_mbs_coded += u1_num_mbs;", "  if(u1_tfr_n_mb)", "                 u1_num_mbs = 0;", "             u1_mb_idx = u1_num_mbs;", "             ps_dec->u1_mb_idx = u1_num_mbs;", " ", "  }", "  }", " ", "     ps_dec->u4_num_mbs_cur_nmb = 0;", "     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr", "  - (u2_first_mb_in_slice << u1_mbaff);", " ", " ", "  return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TEST_F(QuantizedConv2DTest, OddPadding) {", "const int stride = 2;", "TF_ASSERT_OK(NodeDefBuilder(\"quantized_conv_op\", \"QuantizedConv2D\")", ".Input(FakeInput(DT_QUINT8))", ".Input(FakeInput(DT_QUINT8))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Input(FakeInput(DT_FLOAT))", ".Attr(\"out_type\", DataTypeToEnum<qint32>::v())", ".Attr(\"strides\", {1, stride, stride, 1})", ".Attr(\"padding\", \"SAME\")", ".Finalize(node_def()));", "TF_ASSERT_OK(InitOp());", "", "const int depth = 1;", "const int image_width = 4;", "const int image_height = 4;", "const int image_batch_count = 1;", "AddInputFromArray<quint8>(", "TensorShape({image_batch_count, image_height, image_width, depth}),", "{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16});", "const int filter_size = 3;", "const int filter_count = 1;", "AddInputFromArray<quint8>(", "TensorShape({filter_size, filter_size, depth, filter_count}),", "{1, 2, 3, 4, 5, 6, 7, 8, 9});", "AddInputFromArray<float>(TensorShape({1}), {0});", "AddInputFromArray<float>(TensorShape({1}), {255.0f});", "AddInputFromArray<float>(TensorShape({1}), {0});", "AddInputFromArray<float>(TensorShape({1}), {255.0f});", "", "TF_ASSERT_OK(RunOpKernel());", "const int expected_width = image_width / stride;", "const int expected_height = (image_height * filter_count) / stride;", "Tensor expected(DT_QINT32, TensorShape({image_batch_count, expected_height,", "expected_width, filter_count}));", "test::FillValues<qint32>(&expected, {348, 252, 274, 175});", "test::ExpectTensorEqual<qint32>(expected, *GetOutput(0));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" MagickExport Image *AdaptiveThresholdImage(const Image *image,", "   const size_t width,const size_t height,const ssize_t offset,", "   ExceptionInfo *exception)", " {", " #define ThresholdImageTag  \"Threshold/Image\"", " ", "   CacheView", "     *image_view,", "     *threshold_view;", " ", "   Image", "     *threshold_image;", " ", "   MagickBooleanType", "     status;", " ", "   MagickOffsetType", "     progress;", " ", "   MagickPixelPacket", "     zero;", " ", "   MagickRealType", "     number_pixels;", " ", "   ssize_t", "     y;", " ", "   assert(image != (const Image *) NULL);", "   assert(image->signature == MagickCoreSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "    threshold_image=CloneImage(image,0,0,MagickTrue,exception);", "    if (threshold_image == (Image *) NULL)", "      return((Image *) NULL);", "  if (width == 0)", "   if ((width == 0) || (height == 0))", "      return(threshold_image);", "    if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)", "      {", "       InheritException(exception,&threshold_image->exception);", "       threshold_image=DestroyImage(threshold_image);", "       return((Image *) NULL);", "     }", "    ", "   status=MagickTrue;", "   progress=0;", "   GetMagickPixelPacket(image,&zero);", "   number_pixels=(MagickRealType) (width*height);", "   image_view=AcquireVirtualCacheView(image,exception);", "   threshold_view=AcquireAuthenticCacheView(threshold_image,exception);", " #if defined(MAGICKCORE_OPENMP_SUPPORT)", "   #pragma omp parallel for schedule(static) shared(progress,status) \\", "     magick_number_threads(image,threshold_image,image->rows,1)", " #endif", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     MagickBooleanType", "       sync;", " ", "     MagickPixelPacket", "       channel_bias,", "       channel_sum;", " ", "     register const IndexPacket", "       *magick_restrict indexes;", " ", "     register const PixelPacket", "       *magick_restrict p,", "       *magick_restrict r;", " ", "     register IndexPacket", "       *magick_restrict threshold_indexes;", " ", "     register PixelPacket", "       *magick_restrict q;", " ", "     register ssize_t", "       x;", " ", "     ssize_t", "       u,", "       v;", " ", "     if (status == MagickFalse)", "       continue;", "     p=GetCacheViewVirtualPixels(image_view,-((ssize_t) width/2L),y-(ssize_t)", "       height/2L,image->columns+width,height,exception);", "     q=GetCacheViewAuthenticPixels(threshold_view,0,y,threshold_image->columns,1,", "       exception);", "     if ((p == (const PixelPacket *) NULL) || (q == (PixelPacket *) NULL))", "       {", "         status=MagickFalse;", "         continue;", "       }", "     indexes=GetCacheViewVirtualIndexQueue(image_view);", "     threshold_indexes=GetCacheViewAuthenticIndexQueue(threshold_view);", "     channel_bias=zero;", "     channel_sum=zero;", "     r=p;", "     for (v=0; v < (ssize_t) height; v++)", "     {", "       for (u=0; u < (ssize_t) width; u++)", "       {", "         if (u == (ssize_t) (width-1))", "           {", "             channel_bias.red+=r[u].red;", "             channel_bias.green+=r[u].green;", "             channel_bias.blue+=r[u].blue;", "             channel_bias.opacity+=r[u].opacity;", "             if (image->colorspace == CMYKColorspace)", "               channel_bias.index=(MagickRealType)", "                 GetPixelIndex(indexes+(r-p)+u);", "           }", "         channel_sum.red+=r[u].red;", "         channel_sum.green+=r[u].green;", "         channel_sum.blue+=r[u].blue;", "         channel_sum.opacity+=r[u].opacity;", "         if (image->colorspace == CMYKColorspace)", "           channel_sum.index=(MagickRealType) GetPixelIndex(indexes+(r-p)+u);", "       }", "       r+=image->columns+width;", "     }", "     for (x=0; x < (ssize_t) image->columns; x++)", "     {", "       MagickPixelPacket", "         mean;", " ", "       mean=zero;", "       r=p;", "       channel_sum.red-=channel_bias.red;", "       channel_sum.green-=channel_bias.green;", "       channel_sum.blue-=channel_bias.blue;", "       channel_sum.opacity-=channel_bias.opacity;", "       channel_sum.index-=channel_bias.index;", "       channel_bias=zero;", "       for (v=0; v < (ssize_t) height; v++)", "       {", "         channel_bias.red+=r[0].red;", "         channel_bias.green+=r[0].green;", "         channel_bias.blue+=r[0].blue;", "         channel_bias.opacity+=r[0].opacity;", "         if (image->colorspace == CMYKColorspace)", "           channel_bias.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+0);", "         channel_sum.red+=r[width-1].red;", "         channel_sum.green+=r[width-1].green;", "         channel_sum.blue+=r[width-1].blue;", "         channel_sum.opacity+=r[width-1].opacity;", "         if (image->colorspace == CMYKColorspace)", "           channel_sum.index=(MagickRealType) GetPixelIndex(indexes+x+(r-p)+", "             width-1);", "         r+=image->columns+width;", "       }", "       mean.red=(MagickRealType) (channel_sum.red/number_pixels+offset);", "       mean.green=(MagickRealType) (channel_sum.green/number_pixels+offset);", "       mean.blue=(MagickRealType) (channel_sum.blue/number_pixels+offset);", "       mean.opacity=(MagickRealType) (channel_sum.opacity/number_pixels+offset);", "       if (image->colorspace == CMYKColorspace)", "         mean.index=(MagickRealType) (channel_sum.index/number_pixels+offset);", "       SetPixelRed(q,((MagickRealType) GetPixelRed(q) <= mean.red) ?", "         0 : QuantumRange);", "       SetPixelGreen(q,((MagickRealType) GetPixelGreen(q) <= mean.green) ?", "         0 : QuantumRange);", "       SetPixelBlue(q,((MagickRealType) GetPixelBlue(q) <= mean.blue) ?", "         0 : QuantumRange);", "       SetPixelOpacity(q,((MagickRealType) GetPixelOpacity(q) <= mean.opacity) ?", "         0 : QuantumRange);", "       if (image->colorspace == CMYKColorspace)", "         SetPixelIndex(threshold_indexes+x,(((MagickRealType) GetPixelIndex(", "           threshold_indexes+x) <= mean.index) ? 0 : QuantumRange));", "       p++;", "       q++;", "     }", "     sync=SyncCacheViewAuthenticPixels(threshold_view,exception);", "     if (sync == MagickFalse)", "       status=MagickFalse;", "     if (image->progress_monitor != (MagickProgressMonitor) NULL)", "       {", "         MagickBooleanType", "           proceed;", " ", " #if defined(MAGICKCORE_OPENMP_SUPPORT)", "         #pragma omp atomic", " #endif", "         progress++;", "         proceed=SetImageProgress(image,ThresholdImageTag,progress,image->rows);", "         if (proceed == MagickFalse)", "           status=MagickFalse;", "       }", "   }", "   threshold_view=DestroyCacheView(threshold_view);", "   image_view=DestroyCacheView(image_view);", "   if (status == MagickFalse)", "     threshold_image=DestroyImage(threshold_image);", "   return(threshold_image);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,", "                            Entry* pEntry) {", "    if (size_ <= 0)", "  return false;", " ", "  long long pos = start;", "  const long long stop = start + size_;", " ", "  long len;", " ", "  ", "  ", "  const long long seekIdId = ReadUInt(pReader, pos, len);", "   const long long seekIdId = ReadID(pReader, pos, len);", "   if (seekIdId < 0)", "     return false;", "  ", "    if (seekIdId != 0x13AB)   ", "      return false;", " ", "  if ((pos + len) > stop)", "  return false;", " ", "   pos += len;  ", " ", "  const long long seekIdSize = ReadUInt(pReader, pos, len);", " ", "  if (seekIdSize <= 0)", "  return false;", " ", "  if ((pos + len) > stop)", "  return false;", " ", "   pos += len;  ", " ", "  if ((pos + seekIdSize) > stop)", "  return false;", " ", " ", "   pEntry->id = ReadUInt(pReader, pos, len);  ", " ", "  if (pEntry->id <= 0)", "  return false;", " ", "  if (len != seekIdSize)", "  return false;", " ", "   pos += seekIdSize;  ", " ", "  const long long seekPosId = ReadUInt(pReader, pos, len);", " ", "  if (seekPosId != 0x13AC)  ", "  return false;", " ", "  if ((pos + len) > stop)", "  return false;", " ", "   pos += len;  ", " ", "  const long long seekPosSize = ReadUInt(pReader, pos, len);", " ", "  if (seekPosSize <= 0)", "  return false;", " ", "  if ((pos + len) > stop)", "  return false;", " ", "   pos += len;  ", " ", "  if ((pos + seekPosSize) > stop)", "  return false;", " ", "   pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);", " ", "  if (pEntry->pos < 0)", "  return false;", " ", "   pos += seekPosSize;  ", " ", "  if (pos != stop)", "  return false;", " ", "  ", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int perf_output_begin(struct perf_output_handle *handle,", "  \t\t      struct perf_event *event, unsigned int size,", "\t\t      int nmi, int sample)", " \t\t      int sample)", "  {", "  \tstruct ring_buffer *rb;", "  \tunsigned long tail, offset, head;", " \tint have_lost;", " \tstruct perf_sample_data sample_data;", " \tstruct {", " \t\tstruct perf_event_header header;", " \t\tu64\t\t\t id;", " \t\tu64\t\t\t lost;", " \t} lost_event;", " ", " \trcu_read_lock();", " \t ", " \tif (event->parent)", " \t\tevent = event->parent;", " ", " \trb = rcu_dereference(event->rb);", " \tif (!rb)", " \t\tgoto out;", "  ", "  \thandle->rb\t= rb;", "  \thandle->event\t= event;", "\thandle->nmi\t= nmi;", "  \thandle->sample\t= sample;", "  ", "  \tif (!rb->nr_pages)", " \t\tgoto out;", " ", " \thave_lost = local_read(&rb->lost);", " \tif (have_lost) {", " \t\tlost_event.header.size = sizeof(lost_event);", " \t\tperf_event_header__init_id(&lost_event.header, &sample_data,", " \t\t\t\t\t   event);", " \t\tsize += lost_event.header.size;", " \t}", " ", " \tperf_output_get_handle(handle);", " ", " \tdo {", " \t\t ", " \t\ttail = ACCESS_ONCE(rb->user_page->data_tail);", " \t\tsmp_rmb();", " \t\toffset = head = local_read(&rb->head);", " \t\thead += size;", " \t\tif (unlikely(!perf_output_space(rb, tail, offset, head)))", " \t\t\tgoto fail;", " \t} while (local_cmpxchg(&rb->head, offset, head) != offset);", " ", " \tif (head - local_read(&rb->wakeup) > rb->watermark)", " \t\tlocal_add(rb->watermark, &rb->wakeup);", " ", " \thandle->page = offset >> (PAGE_SHIFT + page_order(rb));", " \thandle->page &= rb->nr_pages - 1;", " \thandle->size = offset & ((PAGE_SIZE << page_order(rb)) - 1);", " \thandle->addr = rb->data_pages[handle->page];", " \thandle->addr += handle->size;", " \thandle->size = (PAGE_SIZE << page_order(rb)) - handle->size;", " ", " \tif (have_lost) {", " \t\tlost_event.header.type = PERF_RECORD_LOST;", " \t\tlost_event.header.misc = 0;", " \t\tlost_event.id          = event->id;", " \t\tlost_event.lost        = local_xchg(&rb->lost, 0);", " ", " \t\tperf_output_put(handle, lost_event);", " \t\tperf_event__output_id_sample(event, handle, &sample_data);", " \t}", " ", " \treturn 0;", " ", " fail:", " \tlocal_inc(&rb->lost);", " \tperf_output_put_handle(handle);", " out:", " \trcu_read_unlock();", " ", " \treturn -ENOSPC;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)", "{", "int channelCount = m_track->f.channelCount;", "", "for (int c=0; c<channelCount; c++)", "{", "m_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];", "if (encoded[1] & 0x80)", "m_adpcmState[c].previousValue -= 0x10000;", "", "m_adpcmState[c].index = encoded[2];", "", "*decoded++ = m_adpcmState[c].previousValue;", "", "encoded += 4;", "}", "", "for (int n=0; n<m_framesPerPacket - 1; n += 8)", "{", "for (int c=0; c<channelCount; c++)", "{", "int16_t *output = decoded + c;", "for (int s=0; s<4; s++)", "{", "*output = decodeSample(m_adpcmState[c], *encoded & 0xf);", "output += channelCount;", "*output = decodeSample(m_adpcmState[c], *encoded >> 4);", "output += channelCount;", "encoded++;", "}", "}", "", "decoded += channelCount * 8;", "}", "", "return m_framesPerPacket * channelCount * sizeof (int16_t);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" untrusted_launcher_response_callback (GtkDialog                 *dialog,", "                                       int                        response_id,", "                                       ActivateParametersDesktop *parameters)", " {", "     GdkScreen *screen;", "     char *uri;", "     GFile *file;", "  ", "      switch (response_id)", "      {", "        case RESPONSE_RUN:", "         case GTK_RESPONSE_OK:", "          {", "             file = nautilus_file_get_location (parameters->file);", " ", "              ", "             nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,", "                                         NULL,", "                                         \"yes\");", " ", "             nautilus_file_mark_desktop_file_executable (file,", "                                                         parameters->parent_window,", "                                                         TRUE,", "                                                         NULL, NULL);", " ", "              ", "             nautilus_file_invalidate_all_attributes (parameters->file);", " ", "              screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));", "              uri = nautilus_file_get_uri (parameters->file);", "              DEBUG (\"Launching untrusted launcher %s\", uri);", "              nautilus_launch_desktop_file (screen, uri, NULL,", "                                            parameters->parent_window);", "              g_free (uri);", "        }", "        break;", "        case RESPONSE_MARK_TRUSTED:", "        {", "            file = nautilus_file_get_location (parameters->file);", "            nautilus_file_mark_desktop_file_trusted (file,", "                                                     parameters->parent_window,", "                                                     TRUE,", "                                                     NULL, NULL);", "              g_object_unref (file);", "          }", "          break;", " ", "         default:", "         {", "              ", "         }", "         break;", "     }", " ", "     gtk_widget_destroy (GTK_WIDGET (dialog));", "     activate_parameters_desktop_free (parameters);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int misaligned_load(struct pt_regs *regs,", " \t\t\t   __u32 opcode,", " \t\t\t   int displacement_not_indexed,", " \t\t\t   int width_shift,", " \t\t\t   int do_sign_extend)", " {", " \t ", " \tint error;", " \tint destreg;", " \t__u64 address;", " ", " \terror = generate_and_check_address(regs, opcode,", " \t\t\tdisplacement_not_indexed, width_shift, &address);", " \tif (error < 0) {", "  \t\treturn error;", "  \t}", "  ", "\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);", " \tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);", "  ", "  \tdestreg = (opcode >> 4) & 0x3f;", "  \tif (user_mode(regs)) {", " \t\t__u64 buffer;", " ", " \t\tif (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) {", " \t\t\treturn -1;", " \t\t}", " ", " \t\tif (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) {", " \t\t\treturn -1;  ", " \t\t}", " \t\tswitch (width_shift) {", " \t\tcase 1:", " \t\t\tif (do_sign_extend) {", " \t\t\t\tregs->regs[destreg] = (__u64)(__s64) *(__s16 *) &buffer;", " \t\t\t} else {", " \t\t\t\tregs->regs[destreg] = (__u64) *(__u16 *) &buffer;", " \t\t\t}", " \t\t\tbreak;", " \t\tcase 2:", " \t\t\tregs->regs[destreg] = (__u64)(__s64) *(__s32 *) &buffer;", " \t\t\tbreak;", " \t\tcase 3:", " \t\t\tregs->regs[destreg] = buffer;", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tprintk(\"Unexpected width_shift %d in misaligned_load, PC=%08lx\\n\",", " \t\t\t\twidth_shift, (unsigned long) regs->pc);", " \t\t\tbreak;", " \t\t}", " \t} else {", " \t\t ", " \t\t__u64 lo, hi;", " ", " \t\tswitch (width_shift) {", " \t\tcase 1:", " \t\t\tmisaligned_kernel_word_load(address, do_sign_extend, &regs->regs[destreg]);", " \t\t\tbreak;", " \t\tcase 2:", " \t\t\tasm (\"ldlo.l %1, 0, %0\" : \"=r\" (lo) : \"r\" (address));", " \t\t\tasm (\"ldhi.l %1, 3, %0\" : \"=r\" (hi) : \"r\" (address));", " \t\t\tregs->regs[destreg] = lo | hi;", " \t\t\tbreak;", " \t\tcase 3:", " \t\t\tasm (\"ldlo.q %1, 0, %0\" : \"=r\" (lo) : \"r\" (address));", " \t\t\tasm (\"ldhi.q %1, 7, %0\" : \"=r\" (hi) : \"r\" (address));", " \t\t\tregs->regs[destreg] = lo | hi;", " \t\t\tbreak;", " ", " \t\tdefault:", " \t\t\tprintk(\"Unexpected width_shift %d in misaligned_load, PC=%08lx\\n\",", " \t\t\t\twidth_shift, (unsigned long) regs->pc);", " \t\t\tbreak;", " \t\t}", " \t}", " ", " \treturn 0;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GURL DevToolsWindow::GetDevToolsURL(Profile* profile,", "                                     const GURL& base_url,", "                                     bool shared_worker_frontend,", "                                     bool v8_only_frontend,", "                                     const std::string& remote_frontend,", "                                     bool can_dock,", "                                     const std::string& panel) {", "   if (base_url.SchemeIs(\"data\"))", "     return base_url;", " ", "   std::string frontend_url(", "       !remote_frontend.empty() ?", "           remote_frontend :", "           base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());", "   std::string url_string(", "       frontend_url +", "       ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));", "   if (shared_worker_frontend)", "     url_string += \"&isSharedWorker=true\";", "   if (v8_only_frontend)", "     url_string += \"&v8only=true\";", "   if (remote_frontend.size()) {", "     url_string += \"&remoteFrontend=true\";", "   } else {", "     url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();", "   }", "   if (can_dock)", "      url_string += \"&can_dock=true\";", "    if (panel.size())", "      url_string += \"&panel=\" + panel;", "  return DevToolsUI::SanitizeFrontendURL(GURL(url_string));", "   return DevToolsUIBindings::SanitizeFrontendURL(GURL(url_string));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,", "  uint32_t cmdSize,", "  void *pCmdData,", "  uint32_t *replySize,", "  void *pReplyData)", " {", "  Mutex::Autolock _l(mLock);", "     ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);", " ", "  if (mState == DESTROYED || mEffectInterface == NULL) {", "  return NO_INIT;", "  }", " ", "      if (mStatus != NO_ERROR) {", "          return mStatus;", "      }", "     if (cmdCode == EFFECT_CMD_GET_PARAM &&", "             (*replySize < sizeof(effect_param_t) ||", "                     ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {", "         android_errorWriteLog(0x534e4554, \"29251553\");", "         return -EINVAL;", "     }", "      status_t status = (*mEffectInterface)->command(mEffectInterface,", "                                                     cmdCode,", "                                                     cmdSize,", "                                                    pCmdData,", "                                                    replySize,", "                                                    pReplyData);", "  if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {", "  uint32_t size = (replySize == NULL) ? 0 : *replySize;", "  for (size_t i = 1; i < mHandles.size(); i++) {", "  EffectHandle *h = mHandles[i];", "  if (h != NULL && !h->destroyed_l()) {", "                 h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);", "  }", "  }", "  }", "  return status;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void SupervisedUserService::InitSync(const std::string& refresh_token) {", "    ProfileOAuth2TokenService* token_service =", "        ProfileOAuth2TokenServiceFactory::GetForProfile(profile_);", "  token_service->UpdateCredentials(supervised_users::kSupervisedUserPseudoEmail,", "                                   refresh_token);", "   token_service->UpdateCredentials(", "       supervised_users::kSupervisedUserPseudoEmail, refresh_token,", "       signin_metrics::SourceForRefreshTokenOperation::kSupervisedUser_InitSync);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": ["void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,", "const struct pcap_pkthdr *header, const u_char * packet)", "{", "", "if (startTime == TIME_NONE) {", "startTime = header->ts;", "lastPrintTime = header->ts;", "}", "", "if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {", "if (verbose) {", "int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;", "int days  = hours/24;", "int left  = hours%24;", "fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\",", "days, left, packetsProcessed);", "}", "lastPrintTime = header->ts;", "}", "packetsProcessed++;", "", "", "WifiPacket pkt(cbs,header_type,header,packet);", "", "", "cbs->PacketBegin(pkt, packet, header->caplen, header->len);", "", "switch(header_type) {", "case DLT_PRISM_HEADER:", "pkt.handle_prism(packet,header->caplen);", "break;", "case DLT_IEEE802_11_RADIO:", "pkt.handle_radiotap(packet,header->caplen);", "break;", "case DLT_IEEE802_11:", "pkt.handle_80211(packet,header->caplen);", "break;", "case DLT_EN10MB:", "pkt.handle_ether(packet,header->caplen);", "break;", "default:", "#if 0", "", "", "pkt.handle_ip(packet,header->caplen);", "#endif", "break;", "}", "cbs->PacketEnd(pkt);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" dhcpv4_print(netdissect_options *ndo,", "              const u_char *cp, u_int length, int indent)", " {", "     u_int i, t;", "     const u_char *tlv, *value;", "     uint8_t type, optlen;", "  ", "      i = 0;", "      while (i < length) {", "         if (i + 2 > length)", "             return -1;", "          tlv = cp + i;", "          type = (uint8_t)tlv[0];", "          optlen = (uint8_t)tlv[1];", "         value = tlv + 2;", " ", "         ND_PRINT((ndo, \"\\n\"));", "         for (t = indent; t > 0; t--)", "             ND_PRINT((ndo, \"\\t\"));", "  ", "          ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));", "          ND_PRINT((ndo,\" (%u)\", optlen + 2 ));", "         if (i + 2 + optlen > length)", "             return -1;", "  ", "          switch (type) {", "          case DH4OPT_DNS_SERVERS:", "         case DH4OPT_NTP_SERVERS: {", "             if (optlen < 4 || optlen % 4 != 0) {", "                 return -1;", "             }", "             for (t = 0; t < optlen; t += 4)", "                 ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));", "         }", "             break;", "         case DH4OPT_DOMAIN_SEARCH: {", "             const u_char *tp = value;", "             while (tp < value + optlen) {", "                 ND_PRINT((ndo, \" \"));", "                 if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)", "                     return -1;", "             }", "         }", "             break;", "         }", " ", "         i += 2 + optlen;", "     }", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,", "const TfLiteTensor* input,", "const TfLiteTensor* filter,", "int16* depth_multiplier) {", "int num_filter_channels = SizeOfDimension(filter, 3);", "int num_input_channels = SizeOfDimension(input, 3);", "TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);", "", "*depth_multiplier = num_filter_channels / num_input_channels;", "return kTfLiteOk;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,", "socklen_t size) {", "if (!src || !dst) {", "errno = EFAULT;", "return nullptr;", "}", "size_t src_size = 0;", "if (af == AF_INET) {", "src_size = sizeof(struct in_addr);", "} else if (af == AF_INET6) {", "src_size = sizeof(struct in6_addr);", "} else {", "errno = EAFNOSUPPORT;", "return nullptr;", "}", "", "MessageWriter input;", "input.Push<int>(TokLinuxAfFamily(af));", "input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});", "input.Push(size);", "MessageReader output;", "", "const auto status = NonSystemCallDispatcher(", "::asylo::host_call::kInetNtopHandler, &input, &output);", "CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);", "", "auto result = output.next();", "int klinux_errno = output.next<int>();", "if (result.empty()) {", "errno = FromkLinuxErrorNumber(klinux_errno);", "return nullptr;", "}", "", "memcpy(dst, result.data(),", "std::min(static_cast<size_t>(size),", "static_cast<size_t>(INET6_ADDRSTRLEN)));", "return dst;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": [" WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,", "                                 WORD32 num_mb_skip,", "                                 UWORD8 u1_is_idr_slice,", "                                 UWORD16 u2_frame_num,", "  pocstruct_t *ps_cur_poc,", "                                 WORD32 prev_slice_err)", " {", "     WORD32 i2_cur_mb_addr;", "     UWORD32 u1_num_mbs, u1_num_mbsNby2;", "     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;", "     UWORD32 i2_mb_skip_run;", " ", "     UWORD32 u1_num_mbs_next, u1_end_of_row;", "  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;", "     UWORD32 u1_slice_end;", "     UWORD32 u1_tfr_n_mb;", "     UWORD32 u1_decode_nmb;", "  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;", "  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;", "  deblk_mb_t *ps_cur_deblk_mb;", "  dec_mb_info_t *ps_cur_mb_info;", "  parse_pmbarams_t *ps_parse_mb_data;", "     UWORD32 u1_inter_mb_type;", "     UWORD32 u1_deblk_mb_type;", "     UWORD16 u2_total_mbs_coded;", "     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;", "  parse_part_params_t *ps_part_info;", "     WORD32 ret;", " ", " ", "  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)", "  {", "         ih264d_err_pic_dispbuf_mgr(ps_dec);", "  return 0;", "  }", "     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;", "  if(prev_slice_err == 1)", "  {", "   ", "         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;", " ", " ", "  if(!ps_dec->u1_first_slice_in_stream)", "  {", "             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,", "                 ps_dec->ps_cur_slice->u2_frame_num);", "             ps_dec->s_cur_pic_poc.u2_frame_num =", "                 ps_dec->ps_cur_slice->u2_frame_num;", "  }", " ", "  {", "             WORD32 i, j, poc = 0;", " ", "             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;", " ", "             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;", "             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;", "             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;", " ", "  if(ps_dec->ps_cur_pic != NULL)", "                 poc = ps_dec->ps_cur_pic->i4_poc + 2;", " ", "             j = 0;", "  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)", "  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)", " ", "                         j = i;", "              {", "                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;", "                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;", "                  ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "                  ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;", "                  ps_dec->ps_cur_slice->u1_nal_unit_type = 1;", "                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,", "                         ps_dec->ps_cur_slice->u2_frame_num,", "  &ps_dec->ps_pps[j]);", " ", "  if(ret != OK)", "  {", "  return ret;", "  }", "  }", " ", "             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;", " ", "             ps_dec->u4_output_present = 0;", " ", "  {", "                 ih264d_get_next_display_field(ps_dec,", "                                               ps_dec->ps_out_buffer,", "  &(ps_dec->s_disp_op));", "   ", " ", "  if(0 != ps_dec->s_disp_op.u4_error_code)", "  {", "                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;", "  }", "  else", "                     ps_dec->u4_output_present = 1;", "  }", " ", "  if(ps_dec->u1_separate_parse == 1)", "  {", "  if(ps_dec->u4_dec_thread_created == 0)", "  {", "                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,", "  (void *)ih264d_decode_picture_thread,", "  (void *)ps_dec);", " ", "                     ps_dec->u4_dec_thread_created = 1;", "  }", " ", "  if((ps_dec->u4_num_cores == 3) &&", "  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)", "  && (ps_dec->u4_bs_deblk_thread_created == 0))", "  {", "                     ps_dec->u4_start_recon_deblk = 0;", "                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,", "  (void *)ih264d_recon_deblk_thread,", "  (void *)ps_dec);", "                     ps_dec->u4_bs_deblk_thread_created = 1;", "  }", "  }", "  }", "  }", "  else", "  {", " ", "  dec_slice_struct_t *ps_parse_cur_slice;", "         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;", " ", "  if(ps_dec->u1_slice_header_done", "  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)", "  {", "             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;", " ", "  if(u1_num_mbs)", "  {", "                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;", "  }", "  else", "  {", "  if(ps_dec->u1_separate_parse)", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info - 1;", "  }", "  else", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info", "  + ps_dec->u4_num_mbs_prev_nmb - 1;", "  }", "  }", " ", "             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;", "             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;", " ", "             ps_dec->u1_mb_ngbr_availablity =", "                     ps_cur_mb_info->u1_mb_ngbr_availablity;", " ", "             ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;", "             ps_dec->u2_cur_mb_addr--;", "             ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;", " ", "  if(u1_num_mbs)", "  {", "  if (ps_dec->u1_pr_sl_type == P_SLICE", "  || ps_dec->u1_pr_sl_type == B_SLICE)", "  {", "                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);", "                     ps_dec->ps_part = ps_dec->ps_parse_part_params;", "  }", " ", "                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "                 u1_end_of_row = (!u1_num_mbs_next)", "  && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "                 u1_slice_end = 1;", "                 u1_tfr_n_mb = 1;", "                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                     ps_dec->ps_nmb_info += u1_num_mbs;", "  }", "  else", "  {", "                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "  }", "                 ps_dec->u2_total_mbs_coded += u1_num_mbs;", "                 ps_dec->u1_mb_idx = 0;", "                 ps_dec->u4_num_mbs_cur_nmb = 0;", "  }", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "                 ps_dec->u1_pic_decode_done = 1;", "  return 0;", "  }", " ", "             ps_dec->u2_cur_slice_num++;", "              ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "             ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", "             ps_dec->ps_parse_cur_slice++;", " ", "  }", "  else", "  {", "             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf", "  + ps_dec->u2_cur_slice_num;", "  }", "  }", " ", "   ", "   ", "   ", "  {", "         WORD32 num_entries;", "         WORD32 size;", "         UWORD8 *pu1_buf;", " ", "         num_entries = MAX_FRAMES;", "  if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&", "  (0 == ps_dec->i4_display_delay))", "  {", "             num_entries = 1;", "  }", "         num_entries = ((2 * num_entries) + 1);", "  if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)", "  {", "             num_entries *= 2;", "  }", "         size = num_entries * sizeof(void *);", "         size += PAD_MAP_IDX_POC * sizeof(void *);", " ", "         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;", "         pu1_buf += size * ps_dec->u2_cur_slice_num;", "         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;", "  }", " ", "     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;", "     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;", "     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;", " ", "  if(ps_dec->ps_cur_slice->u1_field_pic_flag)", "         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;", " ", "     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;", "     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;", " ", " ", "  if(ps_dec->u1_separate_parse)", "  {", "         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;", "  }", "  else", "  {", "         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;", "  }", " ", "   ", "   ", "   ", "     u1_inter_mb_type = P_MB;", "     u1_deblk_mb_type = D_INTER_MB;", " ", "     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;", "     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;", "     ps_dec->ps_part = ps_dec->ps_parse_part_params;", " ", "   ", "   ", "   ", "     ps_dec->u1_slice_header_done = 2;", "     ps_dec->u1_qp = ps_slice->u1_slice_qp;", "     ih264d_update_qp(ps_dec, 0);", "     u1_mb_idx = ps_dec->u1_mb_idx;", "     ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "     u1_num_mbs = u1_mb_idx;", " ", "     u1_slice_end = 0;", "     u1_tfr_n_mb = 0;", "     u1_decode_nmb = 0;", "     u1_num_mbsNby2 = 0;", "     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;", "     i2_mb_skip_run = num_mb_skip;", " ", "  while(!u1_slice_end)", "  {", "         UWORD8 u1_mb_type;", " ", "  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)", "  break;", " ", "         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;", "         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;", " ", "         ps_cur_mb_info->u1_Mux = 0;", "         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);", "         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;", " ", "         ps_cur_mb_info->u1_end_of_slice = 0;", " ", "   ", "         ps_parse_mb_data->u1_num_part = 1;", "         ps_parse_mb_data->u1_isI_mb = 0;", " ", "   ", "   ", "   ", "   ", "  if (u1_mbaff)", "             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", "  else", "             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", " ", "   ", "  if(ps_dec->u4_app_disable_deblk_frm == 0)", "  {", "             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,", "                                              ps_dec->u1_mb_ngbr_availablity,", "                                              ps_dec->u1_cur_mb_fld_dec_flag);", "  }", " ", "   ", "         ps_dec->i1_prev_mb_qp_delta = 0;", "         ps_dec->u1_sub_mb_num = 0;", "         ps_cur_mb_info->u1_mb_type = MB_SKIP;", "         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;", "         ps_cur_mb_info->u1_cbp = 0;", " ", "   ", "         ps_part_info = ps_dec->ps_part;", "         ps_part_info->u1_is_direct = PART_DIRECT_16x16;", "         ps_part_info->u1_sub_mb_num = 0;", "         ps_dec->ps_part++;", " ", "   ", "         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);", " ", "         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;", "         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;", " ", "         i2_mb_skip_run--;", " ", "         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;", " ", "  if (u1_mbaff)", "  {", "             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);", "  }", " ", "   ", "   ", "   ", "         i2_cur_mb_addr++;", " ", "         u1_num_mbs++;", "         u1_num_mbsNby2++;", "         ps_parse_mb_data++;", " ", "   ", "   ", "   ", "   ", "   ", "         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "         u1_slice_end = !i2_mb_skip_run;", "         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row", "  || u1_slice_end;", "         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;", "         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(u1_decode_nmb)", "  {", "             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);", "             u1_num_mbsNby2 = 0;", " ", "             ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "             ps_dec->ps_part = ps_dec->ps_parse_part_params;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                 ps_dec->ps_nmb_info +=  u1_num_mbs;", "  }", "  else", "  {", "                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,", "                                             u1_tfr_n_mb, u1_end_of_row);", "  }", "             ps_dec->u2_total_mbs_coded += u1_num_mbs;", "  if(u1_tfr_n_mb)", "                 u1_num_mbs = 0;", "             u1_mb_idx = u1_num_mbs;", "             ps_dec->u1_mb_idx = u1_num_mbs;", "  }", "  }", " ", "     ps_dec->u4_num_mbs_cur_nmb = 0;", "     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr", "  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;", " ", "     H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);", " ", "     ps_dec->u2_cur_slice_num++;", " ", "   ", "  if(ps_dec->u4_first_slice_in_pic != 0)", "         ps_dec->ps_parse_cur_slice++;", " ", "     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "         ps_dec->u1_pic_decode_done = 1;", "  }", " ", "  return 0;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int udp_v6_push_pending_frames(struct sock *sk)", " {", " \tstruct sk_buff *skb;", "  \tstruct udphdr *uh;", "  \tstruct udp_sock  *up = udp_sk(sk);", "  \tstruct inet_sock *inet = inet_sk(sk);", "\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;", " \tstruct flowi6 *fl6;", "  \tint err = 0;", "  \tint is_udplite = IS_UDPLITE(sk);", "  \t__wsum csum = 0;", "  ", " \tif (up->pending == AF_INET)", " \t\treturn udp_push_pending_frames(sk);", " ", " \tfl6 = &inet->cork.fl.u.ip6;", " ", "  \t ", "  \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)", "  \t\tgoto out;", " ", " \t ", " \tuh = udp_hdr(skb);", " \tuh->source = fl6->fl6_sport;", " \tuh->dest = fl6->fl6_dport;", " \tuh->len = htons(up->len);", " \tuh->check = 0;", " ", " \tif (is_udplite)", " \t\tcsum = udplite_csum_outgoing(sk, skb);", " \telse if (skb->ip_summed == CHECKSUM_PARTIAL) {  ", " \t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,", " \t\t\t\t     up->len);", " \t\tgoto send;", " \t} else", " \t\tcsum = udp_csum_outgoing(sk, skb);", " ", " \t ", " \tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,", " \t\t\t\t    up->len, fl6->flowi6_proto, csum);", " \tif (uh->check == 0)", " \t\tuh->check = CSUM_MANGLED_0;", " ", " send:", " \terr = ip6_push_pending_frames(sk);", " \tif (err) {", " \t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {", " \t\t\tUDP6_INC_STATS_USER(sock_net(sk),", " \t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);", " \t\t\terr = 0;", " \t\t}", " \t} else", " \t\tUDP6_INC_STATS_USER(sock_net(sk),", " \t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);", " out:", " \tup->len = 0;", " \tup->pending = 0;", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) {", "RList *segments = bin->segments;", "if (!segments) {", "return NULL;", "}", "RList *entries = bin->entries;", "if (!entries) {", "return NULL;", "}", "RList *symbols = bin->symbols;", "if (!symbols) {", "return NULL;", "}", "", "ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));", "if (!modref) {", "return NULL;", "}", "r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16));", "", "RList *relocs = r_list_newf (free);", "if (!relocs) {", "free (modref);", "return NULL;", "}", "", "RListIter *it;", "RBinSection *seg;", "int index = -1;", "r_list_foreach (segments, it, seg) {", "index++;", "if (!(bin->segment_entries[index].flags & RELOCINFO)) {", "continue;", "}", "ut32 off, start = off = seg->paddr + seg->size;", "ut16 length = r_buf_read_le16_at (bin->buf, off);", "if (!length) {", "continue;", "}", "off += 2;", "while (off < start + length * sizeof (NE_image_reloc_item)) {", "RBinReloc *reloc = R_NEW0 (RBinReloc);", "if (!reloc) {", "return NULL;", "}", "NE_image_reloc_item rel;", "r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel));", "reloc->paddr = seg->paddr + rel.offset;", "switch (rel.type) {", "case LOBYTE:", "reloc->type = R_BIN_RELOC_8;", "break;", "case SEL_16:", "case OFF_16:", "reloc->type = R_BIN_RELOC_16;", "break;", "case POI_32:", "case OFF_32:", "reloc->type = R_BIN_RELOC_32;", "break;", "case POI_48:", "reloc->type = R_BIN_RELOC_64;", "break;", "}", "", "ut32 offset;", "if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) {", "RBinImport *imp = R_NEW0 (RBinImport);", "if (!imp) {", "free (reloc);", "break;", "}", "char *name;", "if (rel.index > bin->ne_header->ModRefs) {", "name = r_str_newf (\"UnknownModule%d_%x\", rel.index, off);", "} else {", "offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;", "name = __read_nonnull_str_at (bin->buf, offset);", "}", "if (rel.flags & IMPORTED_ORD) {", "imp->ordinal = rel.func_ord;", "imp->name = r_str_newf (\"%s.%s\", name, __func_name_from_ord(name, rel.func_ord));", "} else {", "offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off;", "char *func = __read_nonnull_str_at (bin->buf, offset);", "imp->name = r_str_newf (\"%s.%s\", name, func);", "free (func);", "}", "free (name);", "reloc->import = imp;", "} else if (rel.flags & OSFIXUP) {", "", "} else {", "if (strstr (seg->name, \"FIXED\")) {", "RBinSection *s = r_list_get_n (segments, rel.segnum - 1);", "if (s) {", "offset = s->paddr + rel.segoff;", "} else {", "offset = -1;", "}", "} else {", "RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1);", "if (entry) {", "offset = entry->paddr;", "} else {", "offset = -1;", "}", "}", "reloc->addend = offset;", "RBinSymbol *sym = NULL;", "RListIter *sit;", "r_list_foreach (symbols, sit, sym) {", "if (sym->paddr == reloc->addend) {", "reloc->symbol = sym;", "break;", "}", "}", "}", "", "if (rel.flags & ADDITIVE) {", "reloc->additive = 1;", "r_list_append (relocs, reloc);", "} else {", "do {", "r_list_append (relocs, reloc);", "", "offset = r_buf_read_le16_at (bin->buf, reloc->paddr);", "RBinReloc *tmp = reloc;", "reloc = R_NEW0 (RBinReloc);", "if (!reloc) {", "break;", "}", "*reloc = *tmp;", "reloc->paddr = seg->paddr + offset;", "} while (offset != 0xFFFF);", "free (reloc);", "}", "", "off += sizeof (NE_image_reloc_item);", "}", "}", "free (modref);", "return relocs;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm,", " \t\t\t    pte_t *dst_pte,", " \t\t\t    struct vm_area_struct *dst_vma,", " \t\t\t    unsigned long dst_addr,", "  \t\t\t    unsigned long src_addr,", "  \t\t\t    struct page **pagep)", "  {", " \tstruct address_space *mapping;", " \tpgoff_t idx;", " \tunsigned long size;", "  \tint vm_shared = dst_vma->vm_flags & VM_SHARED;", "  \tstruct hstate *h = hstate_vma(dst_vma);", "  \tpte_t _dst_pte;", " \tspinlock_t *ptl;", " \tint ret;", " \tstruct page *page;", " ", " \tif (!*pagep) {", " \t\tret = -ENOMEM;", " \t\tpage = alloc_huge_page(dst_vma, dst_addr, 0);", " \t\tif (IS_ERR(page))", " \t\t\tgoto out;", " ", " \t\tret = copy_huge_page_from_user(page,", " \t\t\t\t\t\t(const void __user *) src_addr,", " \t\t\t\t\t\tpages_per_huge_page(h), false);", " ", " \t\t ", " \t\tif (unlikely(ret)) {", " \t\t\tret = -EFAULT;", " \t\t\t*pagep = page;", " \t\t\t ", " \t\t\tgoto out;", " \t\t}", " \t} else {", " \t\tpage = *pagep;", " \t\t*pagep = NULL;", " \t}", " ", " \t ", "  \t__SetPageUptodate(page);", "  \tset_page_huge_active(page);", "  ", " \tmapping = dst_vma->vm_file->f_mapping;", " \tidx = vma_hugecache_offset(h, dst_vma, dst_addr);", " ", "  \t ", "  \tif (vm_shared) {", "\t\tstruct address_space *mapping = dst_vma->vm_file->f_mapping;", "\t\tpgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);", " \t\tsize = i_size_read(mapping->host) >> huge_page_shift(h);", " \t\tret = -EFAULT;", " \t\tif (idx >= size)", " \t\t\tgoto out_release_nounlock;", "  ", " \t\t ", "  \t\tret = huge_add_to_page_cache(page, mapping, idx);", "  \t\tif (ret)", "  \t\t\tgoto out_release_nounlock;", " \t}", " ", "  \tptl = huge_pte_lockptr(h, dst_mm, dst_pte);", "  \tspin_lock(ptl);", "  ", " \t ", " \tsize = i_size_read(mapping->host) >> huge_page_shift(h);", " \tret = -EFAULT;", " \tif (idx >= size)", " \t\tgoto out_release_unlock;", " ", "  \tret = -EEXIST;", "  \tif (!huge_pte_none(huge_ptep_get(dst_pte)))", "  \t\tgoto out_release_unlock;", " ", " \tif (vm_shared) {", " \t\tpage_dup_rmap(page, true);", " \t} else {", " \t\tClearPagePrivate(page);", " \t\thugepage_add_new_anon_rmap(page, dst_vma, dst_addr);", " \t}", " ", " \t_dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE);", " \tif (dst_vma->vm_flags & VM_WRITE)", " \t\t_dst_pte = huge_pte_mkdirty(_dst_pte);", " \t_dst_pte = pte_mkyoung(_dst_pte);", " ", " \tset_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte);", " ", " \t(void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte,", " \t\t\t\t\tdst_vma->vm_flags & VM_WRITE);", " \thugetlb_count_add(pages_per_huge_page(h), dst_mm);", " ", " \t ", " \tupdate_mmu_cache(dst_vma, dst_addr, dst_pte);", " ", " \tspin_unlock(ptl);", " \tif (vm_shared)", " \t\tunlock_page(page);", " \tret = 0;", " out:", " \treturn ret;", " out_release_unlock:", " \tspin_unlock(ptl);", " \tif (vm_shared)", " \t\tunlock_page(page);", " out_release_nounlock:", " \tput_page(page);", " \tgoto out;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(tensorflow::OpKernelContext* context) override {", "for (int ngram_width : ngram_widths_) {", "OP_REQUIRES(", "context, ngram_width > 0,", "errors::InvalidArgument(\"ngram_widths must contain positive values\"));", "}", "", "const tensorflow::Tensor* data;", "OP_REQUIRES_OK(context, context->input(\"data\", &data));", "const auto& input_data = data->flat<tstring>().data();", "", "const tensorflow::Tensor* splits;", "OP_REQUIRES_OK(context, context->input(\"data_splits\", &splits));", "const auto& splits_vec = splits->flat<SPLITS_TYPE>();", "", "", "", "const int input_data_size = data->flat<tstring>().size();", "const int splits_vec_size = splits_vec.size();", "if (splits_vec_size > 0) {", "int prev_split = splits_vec(0);", "OP_REQUIRES(context, prev_split == 0,", "errors::InvalidArgument(\"First split value must be 0, got \",", "prev_split));", "for (int i = 1; i < splits_vec_size; ++i) {", "bool valid_splits = splits_vec(i) >= prev_split;", "valid_splits = valid_splits && (splits_vec(i) <= input_data_size);", "OP_REQUIRES(context, valid_splits,", "errors::InvalidArgument(", "\"Invalid split value \", splits_vec(i), \", must be in [\",", "prev_split, \", \", input_data_size, \"]\"));", "prev_split = splits_vec(i);", "}", "OP_REQUIRES(context, prev_split == input_data_size,", "errors::InvalidArgument(", "\"Last split value must be data size. Expected \",", "input_data_size, \", got \", prev_split));", "}", "", "int num_batch_items = splits_vec.size() - 1;", "tensorflow::Tensor* ngrams_splits;", "OP_REQUIRES_OK(", "context, context->allocate_output(1, splits->shape(), &ngrams_splits));", "auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data();", "", "", "if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) {", "tensorflow::Tensor* empty;", "OP_REQUIRES_OK(context,", "context->allocate_output(0, data->shape(), &empty));", "for (int i = 0; i <= num_batch_items; ++i) {", "ngrams_splits_data[i] = 0;", "}", "return;", "}", "", "ngrams_splits_data[0] = 0;", "for (int i = 1; i <= num_batch_items; ++i) {", "int length = splits_vec(i) - splits_vec(i - 1);", "int num_ngrams = 0;", "for (int ngram_width : ngram_widths_)", "num_ngrams += get_num_ngrams(length, ngram_width);", "if (preserve_short_ && length > 0 && num_ngrams == 0) {", "num_ngrams = 1;", "}", "ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams;", "}", "", "tensorflow::Tensor* ngrams;", "OP_REQUIRES_OK(", "context,", "context->allocate_output(", "0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams));", "auto ngrams_data = ngrams->flat<tstring>().data();", "", "for (int i = 0; i < num_batch_items; ++i) {", "auto data_start = &input_data[splits_vec(i)];", "int output_start_idx = ngrams_splits_data[i];", "for (int ngram_width : ngram_widths_) {", "auto output_start = &ngrams_data[output_start_idx];", "int length = splits_vec(i + 1) - splits_vec(i);", "int num_ngrams = get_num_ngrams(length, ngram_width);", "CreateNgrams(data_start, output_start, num_ngrams, ngram_width);", "output_start_idx += num_ngrams;", "}", "", "", "", "", "", "if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) {", "int data_length = splits_vec(i + 1) - splits_vec(i);", "", "", "if (data_length == 0) {", "continue;", "}", "", "", "", "int ngram_width = data_length + 2 * pad_width_;", "auto output_start = &ngrams_data[output_start_idx];", "int num_ngrams = 1;", "CreateNgrams(data_start, output_start, num_ngrams, ngram_width);", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WebView* RenderViewImpl::createView(", "     WebFrame* creator,", "     const WebURLRequest& request,", "     const WebWindowFeatures& features,", "     const WebString& frame_name,", "     WebNavigationPolicy policy) {", "   if (shared_popup_counter_->data > kMaximumNumberOfUnacknowledgedPopups)", "     return NULL;", " ", "   ViewHostMsg_CreateWindow_Params params;", "   params.opener_id = routing_id_;", "   params.user_gesture = creator->isProcessingUserGesture();", "   params.window_container_type = WindowFeaturesToContainerType(features);", "   params.session_storage_namespace_id = session_storage_namespace_id_;", "    params.frame_name = frame_name;", "    params.opener_frame_id = creator->identifier();", "    params.opener_url = creator->document().url();", "  params.opener_security_origin =", "      creator->document().securityOrigin().toString().utf8();", "   GURL security_url(creator->document().securityOrigin().toString().utf8());", "   if (!security_url.is_valid())", "     security_url = GURL();", "   params.opener_security_origin = security_url;", "    params.opener_suppressed = creator->willSuppressOpenerInNewFrame();", "    params.disposition = NavigationPolicyToDisposition(policy);", "    if (!request.isNull())", "     params.target_url = request.url();", " ", "   int32 routing_id = MSG_ROUTING_NONE;", "   int32 surface_id = 0;", "   int64 cloned_session_storage_namespace_id;", " ", "   RenderThread::Get()->Send(", "       new ViewHostMsg_CreateWindow(params,", "                                    &routing_id,", "                                    &surface_id,", "                                    &cloned_session_storage_namespace_id));", "   if (routing_id == MSG_ROUTING_NONE)", "     return NULL;", " ", "   creator->consumeUserGesture();", " ", "   RenderViewImpl* view = RenderViewImpl::Create(", "       routing_id_,", "       renderer_preferences_,", "       webkit_preferences_,", "       shared_popup_counter_,", "       routing_id,", "       surface_id,", "       cloned_session_storage_namespace_id,", "       frame_name,", "       true,", "       false,", "       1,", "       screen_info_,", "       accessibility_mode_);", "   view->opened_by_user_gesture_ = params.user_gesture;", " ", "   view->opener_suppressed_ = params.opener_suppressed;", " ", "   view->alternate_error_page_url_ = alternate_error_page_url_;", " ", "   return view->webview();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int parse_packet (sockent_t *se,  ", " \t\tvoid *buffer, size_t buffer_size, int flags,", " \t\tconst char *username)", " {", " \tint status;", " ", " \tvalue_list_t vl = VALUE_LIST_INIT;", " \tnotification_t n;", " ", " #if HAVE_LIBGCRYPT", " \tint packet_was_signed = (flags & PP_SIGNED);", "         int packet_was_encrypted = (flags & PP_ENCRYPTED);", " \tint printed_ignore_warning = 0;", " #endif  ", " ", " ", " \tmemset (&vl, '\\0', sizeof (vl));", " \tmemset (&n, '\\0', sizeof (n));", " \tstatus = 0;", " ", " \twhile ((status == 0) && (0 < buffer_size)", " \t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))", " \t{", " \t\tuint16_t pkg_length;", " \t\tuint16_t pkg_type;", " ", " \t\tmemcpy ((void *) &pkg_type,", " \t\t\t\t(void *) buffer,", " \t\t\t\tsizeof (pkg_type));", " \t\tmemcpy ((void *) &pkg_length,", " \t\t\t\t(void *) (buffer + sizeof (pkg_type)),", " \t\t\t\tsizeof (pkg_length));", " ", " \t\tpkg_length = ntohs (pkg_length);", " \t\tpkg_type = ntohs (pkg_type);", " ", " \t\tif (pkg_length > buffer_size)", " \t\t\tbreak;", " \t\t ", " \t\tif (pkg_length < (2 * sizeof (uint16_t)))", " \t\t\tbreak;", " ", " \t\tif (pkg_type == TYPE_ENCR_AES256)", " \t\t{", " \t\t\tstatus = parse_part_encr_aes256 (se,", " \t\t\t\t\t&buffer, &buffer_size, flags);", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t\tERROR (\"network plugin: Decrypting AES256 \"", " \t\t\t\t\t\t\"part failed \"", " \t\t\t\t\t\t\"with status %i.\", status);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " #if HAVE_LIBGCRYPT", " \t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)", " \t\t\t\t&& (packet_was_encrypted == 0))", " \t\t{", " \t\t\tif (printed_ignore_warning == 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: Unencrypted packet or \"", " \t\t\t\t\t\t\"part has been ignored.\");", "  \t\t\t\tprinted_ignore_warning = 1;", "  \t\t\t}", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t\tcontinue;", "  \t\t}", "  #endif  ", " \t\telse if (pkg_type == TYPE_SIGN_SHA256)", " \t\t{", " \t\t\tstatus = parse_part_sign_sha256 (se,", "                                         &buffer, &buffer_size, flags);", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"", " \t\t\t\t\t\t\"signature failed \"", " \t\t\t\t\t\t\"with status %i.\", status);", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " #if HAVE_LIBGCRYPT", " \t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)", " \t\t\t\t&& (packet_was_encrypted == 0)", " \t\t\t\t&& (packet_was_signed == 0))", " \t\t{", " \t\t\tif (printed_ignore_warning == 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: Unsigned packet or \"", " \t\t\t\t\t\t\"part has been ignored.\");", "  \t\t\t\tprinted_ignore_warning = 1;", "  \t\t\t}", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t\tcontinue;", "  \t\t}", "  #endif  ", " \t\telse if (pkg_type == TYPE_VALUES)", " \t\t{", " \t\t\tstatus = parse_part_values (&buffer, &buffer_size,", " \t\t\t\t\t&vl.values, &vl.values_len);", " \t\t\tif (status != 0)", " \t\t\t\tbreak;", " ", " \t\t\tnetwork_dispatch_values (&vl, username);", " ", " \t\t\tsfree (vl.values);", " \t\t}", " \t\telse if (pkg_type == TYPE_TIME)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t{", " \t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);", " \t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_TIME_HR)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t{", " \t\t\t\tvl.time = (cdtime_t) tmp;", " \t\t\t\tn.time  = (cdtime_t) tmp;", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_INTERVAL)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);", " \t\t}", " \t\telse if (pkg_type == TYPE_INTERVAL_HR)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tvl.interval = (cdtime_t) tmp;", " \t\t}", " \t\telse if (pkg_type == TYPE_HOST)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.host, sizeof (vl.host));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));", " \t\t}", " \t\telse if (pkg_type == TYPE_PLUGIN)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.plugin, sizeof (vl.plugin));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.plugin, vl.plugin,", " \t\t\t\t\t\tsizeof (n.plugin));", " \t\t}", " \t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.plugin_instance,", " \t\t\t\t\tsizeof (vl.plugin_instance));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.plugin_instance,", " \t\t\t\t\t\tvl.plugin_instance,", " \t\t\t\t\t\tsizeof (n.plugin_instance));", " \t\t}", " \t\telse if (pkg_type == TYPE_TYPE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.type, sizeof (vl.type));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));", " \t\t}", " \t\telse if (pkg_type == TYPE_TYPE_INSTANCE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tvl.type_instance,", " \t\t\t\t\tsizeof (vl.type_instance));", " \t\t\tif (status == 0)", " \t\t\t\tsstrncpy (n.type_instance, vl.type_instance,", " \t\t\t\t\t\tsizeof (n.type_instance));", " \t\t}", " \t\telse if (pkg_type == TYPE_MESSAGE)", " \t\t{", " \t\t\tstatus = parse_part_string (&buffer, &buffer_size,", " \t\t\t\t\tn.message, sizeof (n.message));", " ", " \t\t\tif (status != 0)", " \t\t\t{", " \t\t\t\t ", " \t\t\t}", " \t\t\telse if ((n.severity != NOTIF_FAILURE)", " \t\t\t\t\t&& (n.severity != NOTIF_WARNING)", " \t\t\t\t\t&& (n.severity != NOTIF_OKAY))", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"unknown severity %i.\",", " \t\t\t\t\t\tn.severity);", " \t\t\t}", " \t\t\telse if (n.time <= 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"time == 0.\");", " \t\t\t}", " \t\t\telse if (strlen (n.message) <= 0)", " \t\t\t{", " \t\t\t\tINFO (\"network plugin: \"", " \t\t\t\t\t\t\"Ignoring notification with \"", " \t\t\t\t\t\t\"an empty message.\");", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\tnetwork_dispatch_notification (&n);", " \t\t\t}", " \t\t}", " \t\telse if (pkg_type == TYPE_SEVERITY)", " \t\t{", " \t\t\tuint64_t tmp = 0;", " \t\t\tstatus = parse_part_number (&buffer, &buffer_size,", " \t\t\t\t\t&tmp);", " \t\t\tif (status == 0)", " \t\t\t\tn.severity = (int) tmp;", " \t\t}", " \t\telse", " \t\t{", "  \t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"", "  \t\t\t\t\t\" type: 0x%04hx\", pkg_type);", "  \t\t\tbuffer = ((char *) buffer) + pkg_length;", " \t\t\tbuffer_size -= (size_t) pkg_length;", "  \t\t}", "  \t}  ", "  ", " \tif (status == 0 && buffer_size > 0)", " \t\tWARNING (\"network plugin: parse_packet: Received truncated \"", " \t\t\t\t\"packet, try increasing `MaxPacketSize'\");", " ", " \treturn (status);", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void locationAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)", "  {", "      TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());", "    TestNode* imp = WTF::getPtr(proxyImp->location());", "     RefPtr<TestNode> imp = WTF::getPtr(proxyImp->location());", "      if (!imp)", "          return;", "      V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);", "     imp->setHref(cppValue);", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" _xfs_buf_find(", " \tstruct xfs_buftarg\t*btp,", " \tstruct xfs_buf_map\t*map,", " \tint\t\t\tnmaps,", " \txfs_buf_flags_t\t\tflags,", " \txfs_buf_t\t\t*new_bp)", " {", " \tsize_t\t\t\tnumbytes;", " \tstruct xfs_perag\t*pag;", " \tstruct rb_node\t\t**rbp;", "  \tstruct rb_node\t\t*parent;", "  \txfs_buf_t\t\t*bp;", "  \txfs_daddr_t\t\tblkno = map[0].bm_bn;", " \txfs_daddr_t\t\teofs;", "  \tint\t\t\tnumblks = 0;", "  \tint\t\t\ti;", "  ", " \tfor (i = 0; i < nmaps; i++)", " \t\tnumblks += map[i].bm_len;", " \tnumbytes = BBTOB(numblks);", " ", " \t ", "  \tASSERT(!(numbytes < (1 << btp->bt_sshift)));", "  \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));", "  ", " \t ", " \teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);", " \tif (blkno >= eofs) {", " \t\t ", " \t\txfs_alert(btp->bt_mount,", " \t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",", " \t\t\t  __func__, blkno, eofs);", " \t\treturn NULL;", " \t}", " ", "  \t ", "  \tpag = xfs_perag_get(btp->bt_mount,", "  \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));", " ", " \t ", " \tspin_lock(&pag->pag_buf_lock);", " \trbp = &pag->pag_buf_tree.rb_node;", " \tparent = NULL;", " \tbp = NULL;", " \twhile (*rbp) {", " \t\tparent = *rbp;", " \t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);", " ", " \t\tif (blkno < bp->b_bn)", " \t\t\trbp = &(*rbp)->rb_left;", " \t\telse if (blkno > bp->b_bn)", " \t\t\trbp = &(*rbp)->rb_right;", " \t\telse {", " \t\t\t ", " \t\t\tif (bp->b_length != numblks) {", " \t\t\t\tASSERT(bp->b_flags & XBF_STALE);", " \t\t\t\trbp = &(*rbp)->rb_right;", " \t\t\t\tcontinue;", " \t\t\t}", " \t\t\tatomic_inc(&bp->b_hold);", " \t\t\tgoto found;", " \t\t}", " \t}", " ", " \t ", " \tif (new_bp) {", " \t\trb_link_node(&new_bp->b_rbnode, parent, rbp);", " \t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);", " \t\t ", " \t\tnew_bp->b_pag = pag;", " \t\tspin_unlock(&pag->pag_buf_lock);", " \t} else {", " \t\tXFS_STATS_INC(xb_miss_locked);", " \t\tspin_unlock(&pag->pag_buf_lock);", " \t\txfs_perag_put(pag);", " \t}", " \treturn new_bp;", " ", " found:", " \tspin_unlock(&pag->pag_buf_lock);", " \txfs_perag_put(pag);", " ", " \tif (!xfs_buf_trylock(bp)) {", " \t\tif (flags & XBF_TRYLOCK) {", " \t\t\txfs_buf_rele(bp);", " \t\t\tXFS_STATS_INC(xb_busy_locked);", " \t\t\treturn NULL;", " \t\t}", " \t\txfs_buf_lock(bp);", " \t\tXFS_STATS_INC(xb_get_locked_waited);", " \t}", " ", " \t ", " \tif (bp->b_flags & XBF_STALE) {", " \t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);", " \t\tASSERT(bp->b_iodone == NULL);", " \t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;", " \t\tbp->b_ops = NULL;", " \t}", " ", " \ttrace_xfs_buf_find(bp, flags, _RET_IP_);", " \tXFS_STATS_INC(xb_get_locked);", " \treturn bp;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)", " {", " \tstruct mmu_gather tlb;", " \tstruct vm_area_struct *vma;", " \tbool ret = true;", " ", " \t ", " \tmutex_lock(&oom_lock);", " ", " \tif (!down_read_trylock(&mm->mmap_sem)) {", " \t\tret = false;", " \t\ttrace_skip_task_reaping(tsk->pid);", " \t\tgoto unlock_oom;", " \t}", " ", " \t ", " \tif (mm_has_notifiers(mm)) {", " \t\tup_read(&mm->mmap_sem);", " \t\tschedule_timeout_idle(HZ);", " \t\tgoto unlock_oom;", " \t}", " ", " \t ", " \tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {", " \t\tup_read(&mm->mmap_sem);", " \t\ttrace_skip_task_reaping(tsk->pid);", " \t\tgoto unlock_oom;", " \t}", " ", " \ttrace_start_task_reaping(tsk->pid);", " ", " \t ", "  \tset_bit(MMF_UNSTABLE, &mm->flags);", "  ", "\ttlb_gather_mmu(&tlb, mm, 0, -1);", "  \tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {", "  \t\tif (!can_madv_dontneed_vma(vma))", "  \t\t\tcontinue;", " ", " \t\t ", "\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))", " \t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {", " \t\t\ttlb_gather_mmu(&tlb, mm, vma->vm_start, vma->vm_end);", "  \t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,", "  \t\t\t\t\t NULL);", " \t\t\ttlb_finish_mmu(&tlb, vma->vm_start, vma->vm_end);", " \t\t}", "  \t}", "\ttlb_finish_mmu(&tlb, 0, -1);", "  \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",", "  \t\t\ttask_pid_nr(tsk), tsk->comm,", "  \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),", " \t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),", " \t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));", " \tup_read(&mm->mmap_sem);", " ", " \ttrace_finish_task_reaping(tsk->pid);", " unlock_oom:", " \tmutex_unlock(&oom_lock);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)", "  {", "\tstruct serial_icounter_struct icount;", " \tstruct serial_icounter_struct icount = {};", "  \tstruct sb_uart_icount cnow;", "  \tstruct sb_uart_port *port = state->port;", "  ", " \tspin_lock_irq(&port->lock);", " \tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));", " \tspin_unlock_irq(&port->lock);", " ", " \ticount.cts         = cnow.cts;", " \ticount.dsr         = cnow.dsr;", " \ticount.rng         = cnow.rng;", " \ticount.dcd         = cnow.dcd;", " \ticount.rx          = cnow.rx;", " \ticount.tx          = cnow.tx;", " \ticount.frame       = cnow.frame;", " \ticount.overrun     = cnow.overrun;", " \ticount.parity      = cnow.parity;", " \ticount.brk         = cnow.brk;", " \ticount.buf_overrun = cnow.buf_overrun;", " ", " \treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long kvm_arch_vcpu_ioctl(struct file *filp,", " \t\t\t unsigned int ioctl, unsigned long arg)", " {", " \tstruct kvm_vcpu *vcpu = filp->private_data;", " \tvoid __user *argp = (void __user *)arg;", " ", " \tswitch (ioctl) {", " \tcase KVM_ARM_VCPU_INIT: {", " \t\tstruct kvm_vcpu_init init;", " ", " \t\tif (copy_from_user(&init, argp, sizeof(init)))", " \t\t\treturn -EFAULT;", " ", " \t\treturn kvm_vcpu_set_target(vcpu, &init);", " ", " \t}", "  \tcase KVM_SET_ONE_REG:", "  \tcase KVM_GET_ONE_REG: {", "  \t\tstruct kvm_one_reg reg;", " ", " \t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))", " \t\t\treturn -ENOEXEC;", " ", "  \t\tif (copy_from_user(&reg, argp, sizeof(reg)))", "  \t\t\treturn -EFAULT;", "  \t\tif (ioctl == KVM_SET_ONE_REG)", " \t\t\treturn kvm_arm_set_reg(vcpu, &reg);", " \t\telse", " \t\t\treturn kvm_arm_get_reg(vcpu, &reg);", " \t}", " \tcase KVM_GET_REG_LIST: {", " \t\tstruct kvm_reg_list __user *user_list = argp;", "  \t\tstruct kvm_reg_list reg_list;", "  \t\tunsigned n;", "  ", " \t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))", " \t\t\treturn -ENOEXEC;", " ", "  \t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))", "  \t\t\treturn -EFAULT;", "  \t\tn = reg_list.n;", " \t\treg_list.n = kvm_arm_num_regs(vcpu);", " \t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))", " \t\t\treturn -EFAULT;", " \t\tif (n < reg_list.n)", " \t\t\treturn -E2BIG;", " \t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);", " \t}", " \tdefault:", " \t\treturn -EINVAL;", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void AutoFillQueryXmlParser::StartElement(buzz::XmlParseContext* context,", "                                            const char* name,", "                                            const char** attrs) {", "    buzz::QName qname = context->ResolveQName(name, false);", "  const std::string &element = qname.LocalPart();", "   const std::string& element = qname.LocalPart();", "    if (element.compare(\"autofillqueryresponse\") == 0) {", "      ", "      ", "      ", "      *upload_required_ = USE_UPLOAD_RATES;", "    if (*attrs) {", "     *experiment_id_ = std::string();", " ", "      ", "     while (*attrs) {", "        buzz::QName attribute_qname = context->ResolveQName(attrs[0], true);", "      const std::string &attribute_name = attribute_qname.LocalPart();", "       const std::string& attribute_name = attribute_qname.LocalPart();", "        if (attribute_name.compare(\"uploadrequired\") == 0) {", "          if (strcmp(attrs[1], \"true\") == 0)", "            *upload_required_ = UPLOAD_REQUIRED;", "          else if (strcmp(attrs[1], \"false\") == 0)", "            *upload_required_ = UPLOAD_NOT_REQUIRED;", "       } else if (attribute_name.compare(\"experimentid\") == 0) {", "         *experiment_id_ = attrs[1];", "        }", " ", "        ", "       attrs += 2;", "      }", "    } else if (element.compare(\"field\") == 0) {", "      if (!attrs[0]) {", "       context->RaiseError(XML_ERROR_ABORTED);", "       return;", "     }", " ", "      AutoFillFieldType field_type = UNKNOWN_TYPE;", "      buzz::QName attribute_qname = context->ResolveQName(attrs[0], true);", "    const std::string &attribute_name = attribute_qname.LocalPart();", "     const std::string& attribute_name = attribute_qname.LocalPart();", "  ", "      if (attribute_name.compare(\"autofilltype\") == 0) {", "        int value = GetIntValue(context, attrs[1]);", "       field_type = static_cast<AutoFillFieldType>(value);", "       if (field_type < 0 || field_type > MAX_VALID_FIELD_TYPE) {", "         field_type = NO_SERVER_DATA;", "       }", "     }", " ", "     field_types_->push_back(field_type);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)", " {", "   CompressionType", "      compression;", "  ", "    const char", "     *comment,", "      *value;", "  ", "    const double", "     midpoint = QuantumRange/2.0;", " ", "   MagickBooleanType", "     status;", " ", "   QuantumAny", "     range;", " ", "   register const IndexPacket", "     *indexes;", " ", "   register const PixelPacket", "     *p;", " ", "   register ssize_t", "     x;", " ", "   register ssize_t", "     i;", " ", "   register unsigned char", "     *q;", " ", "   ssize_t", "     count,", "     y;", " ", "   TGAInfo", "     tga_info;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);", "   if (status == MagickFalse)", "     return(status);", "    ", "   if ((image->columns > 65535L) || (image->rows > 65535L))", "     ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");", "   (void) TransformImageColorspace(image,sRGBColorspace);", "   compression=image->compression;", "   if (image_info->compression != UndefinedCompression)", "      compression=image_info->compression;", "    range=GetQuantumRange(5UL);", "    tga_info.id_length=0;", "  value=GetImageProperty(image,\"comment\");", "  if (value != (const char *) NULL)", "    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);", "   comment=GetImageProperty(image,\"comment\");", "   if (comment != (const char *) NULL)", "     tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);", "    tga_info.colormap_type=0;", "    tga_info.colormap_index=0;", "    tga_info.colormap_length=0;", "   tga_info.colormap_size=0;", "   tga_info.x_origin=0;", "   tga_info.y_origin=0;", "   tga_info.width=(unsigned short) image->columns;", "   tga_info.height=(unsigned short) image->rows;", "   tga_info.bits_per_pixel=8;", "   tga_info.attributes=0;", "   if ((image_info->type != TrueColorType) &&", "       (image_info->type != TrueColorMatteType) &&", "       (image_info->type != PaletteType) &&", "       (image->matte == MagickFalse) &&", "       (SetImageGray(image,&image->exception) != MagickFalse))", "     tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :", "       TGAMonochrome;", "   else", "     if ((image->storage_class == DirectClass) || (image->colors > 256))", "       {", "          ", "         tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;", "         if (image_info->depth == 5)", "           {", "             tga_info.bits_per_pixel=16;", "             if (image->matte != MagickFalse)", "               tga_info.attributes=1;   ", "           }", "         else", "           {", "             tga_info.bits_per_pixel=24;", "             if (image->matte != MagickFalse)", "               {", "                 tga_info.bits_per_pixel=32;", "                 tga_info.attributes=8;   ", "               }", "           }", "       }", "     else", "       {", "          ", "         tga_info.image_type=compression == RLECompression ? TGARLEColormap :", "           TGAColormap;", "         tga_info.colormap_type=1;", "         tga_info.colormap_length=(unsigned short) image->colors;", "         if (image_info->depth == 5)", "           tga_info.colormap_size=16;", "         else", "           tga_info.colormap_size=24;", "       }", "   value=GetImageArtifact(image,\"tga:image-origin\");", "   if (value != (const char *) NULL)", "     {", "       OrientationType", "         origin;", " ", "       origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,", "         MagickFalse,value);", "       if (origin == BottomRightOrientation || origin == TopRightOrientation)", "         tga_info.attributes|=(1UL << 4);", "       if (origin == TopLeftOrientation || origin == TopRightOrientation)", "         tga_info.attributes|=(1UL << 5);", "     }", "    ", "   (void) WriteBlobByte(image,tga_info.id_length);", "   (void) WriteBlobByte(image,tga_info.colormap_type);", "   (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);", "   (void) WriteBlobLSBShort(image,tga_info.colormap_index);", "   (void) WriteBlobLSBShort(image,tga_info.colormap_length);", "   (void) WriteBlobByte(image,tga_info.colormap_size);", "   (void) WriteBlobLSBShort(image,tga_info.x_origin);", "   (void) WriteBlobLSBShort(image,tga_info.y_origin);", "   (void) WriteBlobLSBShort(image,tga_info.width);", "   (void) WriteBlobLSBShort(image,tga_info.height);", "    (void) WriteBlobByte(image,tga_info.bits_per_pixel);", "    (void) WriteBlobByte(image,tga_info.attributes);", "    if (tga_info.id_length != 0)", "    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);", "     (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);", "    if (tga_info.colormap_type != 0)", "      {", "        unsigned char", "         green,", "         *targa_colormap;", " ", "        ", "       targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)", "         tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(", "         *targa_colormap));", "       if (targa_colormap == (unsigned char *) NULL)", "         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       q=targa_colormap;", "       for (i=0; i < (ssize_t) image->colors; i++)", "       {", "         if (image_info->depth == 5)", "           {", "             green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,", "               range);", "             *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,", "               range)) | ((green & 0x07) << 5);", "             *q++=(((image->matte != MagickFalse) && (", "               (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |", "               ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,", "               range) << 2) | ((green & 0x18) >> 3);", "           }", "         else", "           {", "             *q++=ScaleQuantumToChar(image->colormap[i].blue);", "             *q++=ScaleQuantumToChar(image->colormap[i].green);", "             *q++=ScaleQuantumToChar(image->colormap[i].red);", "           }", "       }", "       (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*", "         tga_info.colormap_length),targa_colormap);", "       targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);", "     }", "    ", "   for (y=(ssize_t) (image->rows-1); y >= 0; y--)", "   {", "     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "     if (p == (const PixelPacket *) NULL)", "       break;", "     indexes=GetVirtualIndexQueue(image);", "     if (compression == RLECompression)", "       {", "         x=0;", "         count=0;", "         while (x < (ssize_t) image->columns)", "         {", "           i=1;", "           while ((i < 128) && (count + i < 128) &&", "                  ((x + i) < (ssize_t) image->columns))", "           {", "             if (tga_info.image_type == TGARLEColormap)", "               {", "                 if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))", "                   break;", "               }", "             else", "               if (tga_info.image_type == TGARLEMonochrome)", "                 {", "                   if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))", "                     break;", "                 }", "               else", "                 {", "                   if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||", "                       (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||", "                       (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))", "                     break;", "                   if ((image->matte != MagickFalse) &&", "                       (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))", "                     break;", "                 }", "             i++;", "           }", "           if (i < 3)", "             {", "               count+=i;", "               p+=i;", "               indexes+=i;", "             }", "           if ((i >= 3) || (count == 128) ||", "               ((x + i) == (ssize_t) image->columns))", "             {", "               if (count > 0)", "                 {", "                   (void) WriteBlobByte(image,(unsigned char) (--count));", "                   while (count >= 0)", "                   {", "                     WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),", "                       p-(count+1),range,midpoint);", "                     count--;", "                   }", "                   count=0;", "                 }", "             }", "           if (i >= 3)", "             {", "               (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));", "               WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);", "               p+=i;", "               indexes+=i;", "             }", "           x+=i;", "         }", "       }", "     else", "       {", "         for (x=0; x < (ssize_t) image->columns; x++)", "           WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);", "       }", "     if (image->previous == (Image *) NULL)", "       {", "         status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "           image->rows);", "         if (status == MagickFalse)", "           break;", "       }", "   }", "   (void) CloseBlob(image);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  GLboolean WebGLRenderingContextBase::isRenderbuffer(", "      WebGLRenderbuffer* renderbuffer) {", "  if (!renderbuffer || isContextLost())", "   if (!renderbuffer || isContextLost() ||", "       !renderbuffer->Validate(ContextGroup(), this))", "      return 0;", "  ", "    if (!renderbuffer->HasEverBeenBound())", "     return 0;", "   if (renderbuffer->IsDeleted())", "     return 0;", " ", "   return ContextGL()->IsRenderbuffer(renderbuffer->Object());", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)", " {", " \tgdIOCtx *out = gdNewFileCtx(outFile);", "  \tif (out == NULL) {", "  \t\treturn;", "  \t}", "\tgdImageWebpCtx(im, out, quality);", " \t_gdImageWebpCtx(im, out, quality);", "  \tout->gd_free(out);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["evtchn_port_t evtchn_from_irq(unsigned irq)", "{", "if (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))", "return 0;", "", "return info_for_irq(irq)->evtchn;", "}"], "ner_tags": [0, 0, 1, 0, 0, 1, 0]}
{"tokens": ["  void GpuCommandBufferStub::OnRegisterTransferBuffer(", "      base::SharedMemoryHandle transfer_buffer,", "    size_t size,", "     uint32 size,", "      int32 id_request,", "      IPC::Message* reply_message) {", "    TRACE_EVENT0(\"gpu\", \"GpuCommandBufferStub::OnRegisterTransferBuffer\");", "   base::SharedMemory shared_memory(transfer_buffer, false);", " ", "   if (command_buffer_.get()) {", "     int32 id = command_buffer_->RegisterTransferBuffer(&shared_memory,", "                                                        size,", "                                                        id_request);", "     GpuCommandBufferMsg_RegisterTransferBuffer::WriteReplyParams(reply_message,", "                                                                  id);", "   } else {", "     reply_message->set_reply_error();", "   }", " ", "   Send(reply_message);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void WebContentsImpl::SetAsFocusedWebContentsIfNecessary() {", "   WebContentsImpl* old_contents = GetFocusedWebContents();", "   if (old_contents == this)", "     return;", " ", "   GetOutermostWebContents()->node_.SetFocusedWebContents(this);", " ", "   if (!GuestMode::IsCrossProcessFrameGuest(this) && browser_plugin_guest_)", "     return;", " ", "   if (old_contents)", "     old_contents->GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(false);", " ", "   if (GetRenderManager()->GetProxyToOuterDelegate())", "      GetRenderManager()->GetProxyToOuterDelegate()->SetFocusedFrame();", "  ", "    if (ShowingInterstitialPage()) {", "    static_cast<RenderFrameHostImpl*>(", "        GetRenderManager()->interstitial_page()->GetMainFrame())", "     static_cast<RenderFrameHostImpl*>(interstitial_page_->GetMainFrame())", "          ->GetRenderWidgetHost()", "          ->SetPageFocus(true);", "    } else {", "     GetMainFrame()->GetRenderWidgetHost()->SetPageFocus(true);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,", " \t\t\t   int addr_len)", " {", " \tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *)uaddr;", " \tstruct inet_connection_sock *icsk = inet_csk(sk);", " \tstruct inet_sock *inet = inet_sk(sk);", "  \tstruct ipv6_pinfo *np = inet6_sk(sk);", "  \tstruct dccp_sock *dp = dccp_sk(sk);", "  \tstruct in6_addr *saddr = NULL, *final_p, final;", " \tstruct ipv6_txoptions *opt;", "  \tstruct flowi6 fl6;", "  \tstruct dst_entry *dst;", "  \tint addr_type;", " \tint err;", " ", " \tdp->dccps_role = DCCP_ROLE_CLIENT;", " ", " \tif (addr_len < SIN6_LEN_RFC2133)", " \t\treturn -EINVAL;", " ", " \tif (usin->sin6_family != AF_INET6)", " \t\treturn -EAFNOSUPPORT;", " ", " \tmemset(&fl6, 0, sizeof(fl6));", " ", " \tif (np->sndflow) {", " \t\tfl6.flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;", " \t\tIP6_ECN_flow_init(fl6.flowlabel);", " \t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {", " \t\t\tstruct ip6_flowlabel *flowlabel;", " \t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);", " \t\t\tif (flowlabel == NULL)", " \t\t\t\treturn -EINVAL;", " \t\t\tfl6_sock_release(flowlabel);", " \t\t}", " \t}", " \t ", " \tif (ipv6_addr_any(&usin->sin6_addr))", " \t\tusin->sin6_addr.s6_addr[15] = 1;", " ", " \taddr_type = ipv6_addr_type(&usin->sin6_addr);", " ", " \tif (addr_type & IPV6_ADDR_MULTICAST)", " \t\treturn -ENETUNREACH;", " ", " \tif (addr_type & IPV6_ADDR_LINKLOCAL) {", " \t\tif (addr_len >= sizeof(struct sockaddr_in6) &&", " \t\t    usin->sin6_scope_id) {", " \t\t\t ", " \t\t\tif (sk->sk_bound_dev_if &&", " \t\t\t    sk->sk_bound_dev_if != usin->sin6_scope_id)", " \t\t\t\treturn -EINVAL;", " ", " \t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;", " \t\t}", " ", " \t\t ", " \t\tif (!sk->sk_bound_dev_if)", " \t\t\treturn -EINVAL;", " \t}", " ", " \tsk->sk_v6_daddr = usin->sin6_addr;", " \tnp->flow_label = fl6.flowlabel;", " ", " \t ", " \tif (addr_type == IPV6_ADDR_MAPPED) {", " \t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;", " \t\tstruct sockaddr_in sin;", " ", " \t\tSOCK_DEBUG(sk, \"connect: ipv4 mapped\\n\");", " ", " \t\tif (__ipv6_only_sock(sk))", " \t\t\treturn -ENETUNREACH;", " ", " \t\tsin.sin_family = AF_INET;", " \t\tsin.sin_port = usin->sin6_port;", " \t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];", " ", " \t\ticsk->icsk_af_ops = &dccp_ipv6_mapped;", " \t\tsk->sk_backlog_rcv = dccp_v4_do_rcv;", " ", " \t\terr = dccp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));", " \t\tif (err) {", " \t\t\ticsk->icsk_ext_hdr_len = exthdrlen;", " \t\t\ticsk->icsk_af_ops = &dccp_ipv6_af_ops;", " \t\t\tsk->sk_backlog_rcv = dccp_v6_do_rcv;", " \t\t\tgoto failure;", " \t\t}", " \t\tnp->saddr = sk->sk_v6_rcv_saddr;", " \t\treturn err;", " \t}", " ", " \tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))", " \t\tsaddr = &sk->sk_v6_rcv_saddr;", " ", " \tfl6.flowi6_proto = IPPROTO_DCCP;", " \tfl6.daddr = sk->sk_v6_daddr;", " \tfl6.saddr = saddr ? *saddr : np->saddr;", " \tfl6.flowi6_oif = sk->sk_bound_dev_if;", " \tfl6.fl6_dport = usin->sin6_port;", "  \tfl6.fl6_sport = inet->inet_sport;", "  \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));", "  ", "\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);", " \topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));", " \tfinal_p = fl6_update_dst(&fl6, opt, &final);", "  ", "  \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);", "  \tif (IS_ERR(dst)) {", " \t\terr = PTR_ERR(dst);", " \t\tgoto failure;", " \t}", " ", " \tif (saddr == NULL) {", " \t\tsaddr = &fl6.saddr;", " \t\tsk->sk_v6_rcv_saddr = *saddr;", " \t}", " ", " \t ", " \tnp->saddr = *saddr;", " \tinet->inet_rcv_saddr = LOOPBACK4_IPV6;", " ", "  \t__ip6_dst_store(sk, dst, NULL, NULL);", "  ", "  \ticsk->icsk_ext_hdr_len = 0;", "\tif (np->opt != NULL)", "\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +", "\t\t\t\t\t  np->opt->opt_nflen);", " \tif (opt)", " \t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;", "  ", "  \tinet->inet_dport = usin->sin6_port;", "  ", " \tdccp_set_state(sk, DCCP_REQUESTING);", " \terr = inet6_hash_connect(&dccp_death_row, sk);", " \tif (err)", " \t\tgoto late_failure;", " ", " \tdp->dccps_iss = secure_dccpv6_sequence_number(np->saddr.s6_addr32,", " \t\t\t\t\t\t      sk->sk_v6_daddr.s6_addr32,", " \t\t\t\t\t\t      inet->inet_sport,", " \t\t\t\t\t\t      inet->inet_dport);", " \terr = dccp_connect(sk);", " \tif (err)", " \t\tgoto late_failure;", " ", " \treturn 0;", " ", " late_failure:", " \tdccp_set_state(sk, DCCP_CLOSED);", " \t__sk_dst_reset(sk);", " failure:", " \tinet->inet_dport = 0;", " \tsk->sk_route_caps = 0;", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["CmdResult Handle (const std::vector<std::string>& parameters, User *user)", "{", "", "if (user->registered != REG_ALL)", "{", "if (!cap.ext.get(user))", "return CMD_FAILURE;", "", "SaslAuthenticator *sasl = authExt.get(user);", "if (!sasl)", "authExt.set(user, new SaslAuthenticator(user, parameters[0]));", "else if (sasl->SendClientMessage(parameters) == false)", "{", "sasl->AnnounceState();", "authExt.unset(user);", "}", "}", "return CMD_FAILURE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void PrintPreviewUI::SetPrintPreviewDataForIndex(", "      int index,", "      const base::RefCountedBytes* data) {", "  print_preview_data_service()->SetDataEntry(preview_ui_addr_str_, index, data);", "   print_preview_data_service()->SetDataEntry(id_, index, data);", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0]}
{"tokens": [" static void parse_content_range(URLContext *h, const char *p)", " {", "     HTTPContext *s = h->priv_data;", "     const char *slash;", "  ", "      if (!strncmp(p, \"bytes \", 6)) {", "          p     += 6;", "        s->off = strtoll(p, NULL, 10);", "         s->off = strtoull(p, NULL, 10);", "          if ((slash = strchr(p, '/')) && strlen(slash) > 0)", "            s->filesize = strtoll(slash + 1, NULL, 10);", "             s->filesize = strtoull(slash + 1, NULL, 10);", "      }", "      if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))", "          h->is_streamed = 0;  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "const Tensor& input = context->input(0);", "const Tensor& filter_sizes = context->input(1);", "const Tensor& out_backprop = context->input(2);", "OP_REQUIRES(", "context, TensorShapeUtils::IsVector(filter_sizes.shape()),", "errors::InvalidArgument(", "\"Conv2DCustomBackpropFilter: filter_sizes input must be 1-dim, \"", "\"not \",", "filter_sizes.dims()));", "TensorShape filter_shape;", "OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(", "filter_sizes.vec<int32>(), &filter_shape));", "", "ConvBackpropDimensions dims;", "OP_REQUIRES_OK(", "context,", "ConvBackpropComputeDimensionsV2(", "\"Conv2DCustomBackpropFilter\",                      2, input.shape(),", "filter_shape, out_backprop.shape(), dilations_, strides_, padding_,", "explicit_paddings_, data_format_, &dims));", "", "Tensor* filter_backprop;", "OP_REQUIRES_OK(context,", "context->allocate_output(0, filter_shape, &filter_backprop));", "", "", "if (filter_shape.num_elements() == 0) {", "return;", "}", "", "int64 pad_top, pad_bottom;", "int64 pad_left, pad_right;", "if (padding_ == Padding::EXPLICIT) {", "pad_top = explicit_paddings_[2];", "pad_bottom = explicit_paddings_[3];", "pad_left = explicit_paddings_[4];", "pad_right = explicit_paddings_[5];", "}", "OP_REQUIRES_OK(", "context,", "GetWindowedOutputSizeVerbose(", "dims.spatial_dims[0].input_size, dims.spatial_dims[0].filter_size,", "dims.spatial_dims[0].stride, padding_,", "&dims.spatial_dims[0].output_size, &pad_top, &pad_bottom));", "OP_REQUIRES_OK(", "context,", "GetWindowedOutputSizeVerbose(", "dims.spatial_dims[1].input_size, dims.spatial_dims[1].filter_size,", "dims.spatial_dims[1].stride, padding_,", "&dims.spatial_dims[1].output_size, &pad_left, &pad_right));", "#if defined TENSORFLOW_USE_LIBXSMM_CONVOLUTIONS && \\", "    defined TENSORFLOW_USE_LIBXSMM_BACKWARD_CONVOLUTIONS", "if (pad_left == pad_right && pad_top == pad_bottom) {", "if (LaunchXsmmBackwardFilter<Device, T>()(", "context, context->eigen_device<Device>(), input.tensor<T, 4>(),", "filter_backprop->tensor<T, 4>(), out_backprop.tensor<T, 4>(),", "dims.spatial_dims[0].input_size, dims.spatial_dims[1].input_size,", "static_cast<int>(dims.spatial_dims[0].stride),", "static_cast<int>(dims.spatial_dims[1].stride),", "static_cast<int>(pad_top), static_cast<int>(pad_left),", "data_format_)) {", "return;", "}", "}", "#endif", "", "", "const int filter_total_size = dims.spatial_dims[0].filter_size *", "dims.spatial_dims[1].filter_size *", "dims.in_depth;", "", "const int output_image_size =", "dims.spatial_dims[0].output_size * dims.spatial_dims[1].output_size;", "", "", "", "", "", "", "", "", "", "", "const size_t target_working_set_size = (30LL << 20) / sizeof(T);", "", "const size_t size_A = output_image_size * filter_total_size;", "", "const size_t size_B = output_image_size * dims.out_depth;", "", "const size_t size_C = filter_total_size * dims.out_depth;", "", "const size_t work_unit_size = size_A + size_B + size_C;", "", "const size_t shard_size =", "(target_working_set_size + work_unit_size - 1) / work_unit_size;", "", "Tensor col_buffer;", "OP_REQUIRES_OK(context,", "context->allocate_temp(", "DataTypeToEnum<T>::value,", "TensorShape({static_cast<int64>(shard_size),", "static_cast<int64>(output_image_size),", "static_cast<int64>(filter_total_size)}),", "&col_buffer));", "", "", "const int input_offset = dims.spatial_dims[0].input_size *", "dims.spatial_dims[1].input_size * dims.in_depth;", "", "const int output_offset = dims.spatial_dims[0].output_size *", "dims.spatial_dims[1].output_size * dims.out_depth;", "", "const T* input_data = input.template flat<T>().data();", "T* col_buffer_data = col_buffer.template flat<T>().data();", "const T* out_backprop_data = out_backprop.template flat<T>().data();", "T* filter_backprop_data = filter_backprop->template flat<T>().data();", "", "typedef Eigen::TensorMap<Eigen::Tensor<T, 2, Eigen::RowMajor>,", "Eigen::Unaligned>", "TensorMap;", "typedef Eigen::TensorMap<Eigen::Tensor<const T, 2, Eigen::RowMajor>,", "Eigen::Unaligned>", "ConstTensorMap;", "", "TensorMap C(filter_backprop_data, filter_total_size, dims.out_depth);", "C.setZero();", "", "", "Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> contract_dims;", "contract_dims[0].first = 0;", "contract_dims[0].second = 0;", "", "auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());", "", "for (int image_id = 0; image_id < dims.batch_size; image_id += shard_size) {", "const int shard_limit =", "std::min(static_cast<int>(shard_size),", "static_cast<int>(dims.batch_size) - image_id);", "", "auto shard = [&input_data, &col_buffer_data, &dims, &pad_top, &pad_left,", "&pad_bottom, &pad_right, &input_offset,", "&size_A](int64 start, int64 limit) {", "for (int shard_id = start; shard_id < limit; ++shard_id) {", "const T* input_data_shard = input_data + shard_id * input_offset;", "T* col_data_shard = col_buffer_data + shard_id * size_A;", "", "", "", "Im2col<T>(", "input_data_shard, dims.in_depth, dims.spatial_dims[0].input_size,", "dims.spatial_dims[1].input_size, dims.spatial_dims[0].filter_size,", "dims.spatial_dims[1].filter_size, pad_top, pad_left, pad_bottom,", "pad_right, dims.spatial_dims[0].stride,", "dims.spatial_dims[1].stride, col_data_shard);", "}", "};", "Shard(worker_threads.num_threads, worker_threads.workers, shard_limit,", "size_A, shard);", "", "ConstTensorMap A(col_buffer_data, output_image_size * shard_limit,", "filter_total_size);", "ConstTensorMap B(out_backprop_data, output_image_size * shard_limit,", "dims.out_depth);", "", "", "C.device(context->eigen_cpu_device()) += A.contract(B, contract_dims);", "", "input_data += input_offset * shard_limit;", "out_backprop_data += output_offset * shard_limit;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int remarkupvals (global_State *g) {", "lua_State *thread;", "lua_State **p = &g->twups;", "int work = 0;", "while ((thread = *p) != NULL) {", "work++;", "lua_assert(!isblack(thread));", "if (isgray(thread) && thread->openupval != NULL)", "p = &thread->twups;", "else {", "UpVal *uv;", "*p = thread->twups;", "thread->twups = thread;", "for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {", "work++;", "if (!iswhite(uv))", "markvalue(g, uv->v);", "}", "}", "}", "return work;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" CreateDataReductionProxyChromeIOData(", "     Profile* profile,", "     const scoped_refptr<base::SingleThreadTaskRunner>& io_task_runner,", "     const scoped_refptr<base::SingleThreadTaskRunner>& ui_task_runner) {", "   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);", "    DCHECK(profile);", "    DCHECK(profile->GetPrefs());", "  ", "  data_reduction_proxy::DataReductionProxySettings*", "      data_reduction_proxy_settings =", "          DataReductionProxyChromeSettingsFactory::GetForBrowserContext(", "              profile);", "  bool enabled = data_reduction_proxy_settings &&", "                 data_reduction_proxy_settings->IsDataSaverEnabledByUser();", "   bool enabled = data_reduction_proxy::DataReductionProxySettings::", "       IsDataSaverEnabledByUser(profile->GetPrefs());", "  ", "    std::unique_ptr<data_reduction_proxy::DataReductionProxyIOData>", "        data_reduction_proxy_io_data(", "           new data_reduction_proxy::DataReductionProxyIOData(", "               DataReductionProxyChromeSettings::GetClient(),", "               profile->GetPrefs(), content::GetNetworkConnectionTracker(),", "               io_task_runner, ui_task_runner, enabled, GetUserAgent(),", "               version_info::GetChannelString(chrome::GetChannel())));", " ", "   data_reduction_proxy_io_data->set_lofi_decider(", "       std::make_unique<data_reduction_proxy::ContentLoFiDecider>());", "   data_reduction_proxy_io_data->set_resource_type_provider(", "       std::make_unique<data_reduction_proxy::ContentResourceTypeProvider>());", "   data_reduction_proxy_io_data->set_lofi_ui_service(", "       std::make_unique<data_reduction_proxy::ContentLoFiUIService>(", "           ui_task_runner, base::Bind(&OnLoFiResponseReceivedOnUI)));", " ", "   return data_reduction_proxy_io_data;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" do_command (unsigned char c)", " {", " \tstatic int dtr_up = 0;", " \tint newbaud, newflow, newparity, newbits;", " \tconst char *xfr_cmd;", " \tchar *fname;", " \tint r;", " ", " \tswitch (c) {", " \tcase KEY_EXIT:", " \t\treturn 1;", " \tcase KEY_QUIT:", " \t\tterm_set_hupcl(tty_fd, 0);", " \t\tterm_flush(tty_fd);", " \t\tterm_apply(tty_fd);", " \t\tterm_erase(tty_fd);", " \t\treturn 1;", " \tcase KEY_STATUS:", " \t\tshow_status(dtr_up);", " \t\tbreak;", " \tcase KEY_PULSE:", " \t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");", " \t\tif ( term_pulse_dtr(tty_fd) < 0 )", " \t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");", " \t\tbreak;", " \tcase KEY_TOGGLE:", " \t\tif ( dtr_up )", " \t\t\tr = term_lower_dtr(tty_fd);", " \t\telse", " \t\t\tr = term_raise_dtr(tty_fd);", " \t\tif ( r >= 0 ) dtr_up = ! dtr_up;", " \t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", ", " \t\t\t\t  dtr_up ? \"up\" : \"down\");", " \t\tbreak;", " \tcase KEY_BAUD_UP:", " \tcase KEY_BAUD_DN:", " \t\tif (c == KEY_BAUD_UP)", " \t\t\topts.baud = baud_up(opts.baud);", " \t\telse ", " \t\t\topts.baud = baud_down(opts.baud);", " \t\tterm_set_baudrate(tty_fd, opts.baud);", " \t\ttty_q.len = 0; term_flush(tty_fd);", " \t\tterm_apply(tty_fd);", " \t\tnewbaud = term_get_baudrate(tty_fd, NULL);", " \t\tif ( opts.baud != newbaud ) {", " \t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", ", " \t\t\t\t\t  opts.baud, newbaud);", " \t\t} else {", " \t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);", " \t\t}", " \t\tset_tty_write_sz(newbaud);", " \t\tbreak;", " \tcase KEY_FLOW:", " \t\topts.flow = flow_next(opts.flow);", " \t\tterm_set_flowcntrl(tty_fd, opts.flow);", " \t\ttty_q.len = 0; term_flush(tty_fd);", " \t\tterm_apply(tty_fd);", " \t\tnewflow = term_get_flowcntrl(tty_fd);", " \t\tif ( opts.flow != newflow ) {", " \t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", ", " \t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);", " \t\t} else {", " \t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", ", " \t\t\t\t\t  flow_str[opts.flow]);", " \t\t}", " \t\tbreak;", " \tcase KEY_PARITY:", " \t\topts.parity = parity_next(opts.parity);", " \t\tterm_set_parity(tty_fd, opts.parity);", " \t\ttty_q.len = 0; term_flush(tty_fd);", " \t\tterm_apply(tty_fd);", " \t\tnewparity = term_get_parity(tty_fd);", " \t\tif (opts.parity != newparity ) {", " \t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",", " \t\t\t\t\t  parity_str[opts.parity], ", " \t\t\t\t\t  parity_str[newparity]);", " \t\t} else {", " \t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", ", " \t\t\t\t\t  parity_str[opts.parity]);", " \t\t}", " \t\tbreak;", " \tcase KEY_BITS:", " \t\topts.databits = bits_next(opts.databits);", " \t\tterm_set_databits(tty_fd, opts.databits);", " \t\ttty_q.len = 0; term_flush(tty_fd);", " \t\tterm_apply(tty_fd);", " \t\tnewbits = term_get_databits(tty_fd);", " \t\tif (opts.databits != newbits ) {", " \t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",", " \t\t\t\t\t  opts.databits, newbits);", " \t\t} else {", " \t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", ", " \t\t\t\t\t  opts.databits);", " \t\t}", " \t\tbreak;", " \tcase KEY_LECHO:", " \t\topts.lecho = ! opts.lecho;", " \t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", ", " \t\t\t\t  opts.lecho ? \"yes\" : \"no\");", " \t\tbreak;", " \tcase KEY_SEND:", " \tcase KEY_RECEIVE:", " \t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;", " \t\tif ( xfr_cmd[0] == '\\0' ) {", " \t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");", " \t\t\tbreak;", " \t\t}", " \t\tfname = read_filename();", " \t\tif (fname == NULL) {", "  \t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");", "  \t\t\tbreak;", "  \t\t}", "\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);", " \t\trun_cmd(tty_fd, xfr_cmd, fname);", "  \t\tfree(fname);", "  \t\tbreak;", "  \tcase KEY_BREAK:", " \t\tterm_break(tty_fd);", " \t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");", " \t\tbreak;", " \tdefault:", " \t\tbreak;", " \t}", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,", " \t\tunsigned long arg)", " {", " \tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");", " ", " \tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))", " \t\treturn -ENOSYS;", "  \tif (!CDROM_CAN(CDC_SELECT_DISC) ||", "  \t    (arg == CDSL_CURRENT || arg == CDSL_NONE))", "  \t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);", "\tif (((int)arg >= cdi->capacity))", " \tif (arg >= cdi->capacity)", "  \t\treturn -EINVAL;", "  \treturn cdrom_slot_status(cdi, arg);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" pkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,", "                      const uint8_t *cert, size_t cert_len,", "                      krb5_const_principal princ, const void *opts,", "                      const struct _krb5_db_entry_new *db_entry,", "                      char ***authinds_out)", " {", "     krb5_error_code ret;", "     int valid_eku;", "     const struct certauth_req_opts *req_opts = opts;", " ", "     *authinds_out = NULL;", " ", "      ", "     ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,", "                             &valid_eku);", "     if (ret)", "         return ret;", " ", "     if (!valid_eku) {", "         TRACE_PKINIT_SERVER_EKU_REJECT(context);", "          return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;", "      }", "  ", "    return 0;", "     return KRB5_PLUGIN_NO_HANDLE;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static void copy_xauthority(void) {", " \tchar *src = RUN_XAUTHORITY_FILE ;", "  \tchar *dest;", "  \tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)", "  \t\terrExit(\"asprintf\");", " \t", "  \tif (is_link(dest)) {", "  \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);", "  \t\texit(1);", "  \t}", "  ", "\tpid_t child = fork();", "\tif (child < 0)", "\t\terrExit(\"fork\");", "\tif (child == 0) {", "\t\tdrop_privs(0);", "\t\tint rv = copy_file(src, dest);", "\t\tif (rv)", "\t\t\tfprintf(stderr, \"Warning: cannot transfer .Xauthority in private home directory\\n\");", "\t\telse {", "\t\t\tfs_logger2(\"clone\", dest);", "\t\t}", "\t\t_exit(0);", "\t}", "\twaitpid(child, NULL, 0);", "\tif (chown(dest, getuid(), getgid()) < 0)", "\t\terrExit(\"chown\");", "\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)", "\t\terrExit(\"chmod\");", " \tcopy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR);  ", " \tfs_logger2(\"clone\", dest);", " \t", "  \tunlink(src);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["   void DetachWebContentsTest(DiscardReason reason) {", "     LifecycleUnit* first_lifecycle_unit = nullptr;", "     LifecycleUnit* second_lifecycle_unit = nullptr;", "     CreateTwoTabs(true  , &first_lifecycle_unit,", "                   &second_lifecycle_unit);", " ", "     ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);", "     std::unique_ptr<content::WebContents> owned_contents =", "         tab_strip_model_->DetachWebContentsAt(0);", "     ExpectCanDiscardFalseTrivialAllReasons(first_lifecycle_unit);", " ", "     NoUnloadListenerTabStripModelDelegate other_tab_strip_model_delegate;", "     TabStripModel other_tab_strip_model(&other_tab_strip_model_delegate,", "                                         profile());", "      other_tab_strip_model.AddObserver(source_);", "  ", "    EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(testing::_));", "     EXPECT_CALL(source_observer_, OnLifecycleUnitCreated(::testing::_));", "      other_tab_strip_model.AppendWebContents(CreateTestWebContents(),", "                                               true);", "  ", "     other_tab_strip_model.AppendWebContents(std::move(owned_contents), false);", "      ExpectCanDiscardTrueAllReasons(first_lifecycle_unit);", "  ", "      EXPECT_EQ(LifecycleUnitState::ACTIVE, first_lifecycle_unit->GetState());", "    EXPECT_CALL(tab_observer_, OnDiscardedStateChange(testing::_, true));", "     EXPECT_CALL(tab_observer_, OnDiscardedStateChange(::testing::_, true));", "      first_lifecycle_unit->Discard(reason);", "  ", "    testing::Mock::VerifyAndClear(&tab_observer_);", "     ::testing::Mock::VerifyAndClear(&tab_observer_);", "      TransitionFromPendingDiscardToDiscardedIfNeeded(reason,", "                                                      first_lifecycle_unit);", "  ", "     CloseTabsAndExpectNotifications(&other_tab_strip_model,", "                                     {first_lifecycle_unit});", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" struct key *key_get_instantiation_authkey(key_serial_t target_id)", " {", " \tchar description[16];", " \tstruct keyring_search_context ctx = {", "  \t\t.index_key.type\t\t= &key_type_request_key_auth,", "  \t\t.index_key.description\t= description,", "  \t\t.cred\t\t\t= current_cred(),", "\t\t.match_data.cmp\t\t= user_match,", " \t\t.match_data.cmp\t\t= key_default_cmp,", "  \t\t.match_data.raw_data\t= description,", "  \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,", "  \t};", " \tstruct key *authkey;", " \tkey_ref_t authkey_ref;", " ", " \tsprintf(description, \"%x\", target_id);", " ", " \tauthkey_ref = search_process_keyrings(&ctx);", " ", " \tif (IS_ERR(authkey_ref)) {", " \t\tauthkey = ERR_CAST(authkey_ref);", " \t\tif (authkey == ERR_PTR(-EAGAIN))", " \t\t\tauthkey = ERR_PTR(-ENOKEY);", " \t\tgoto error;", " \t}", " ", " \tauthkey = key_ref_to_ptr(authkey_ref);", " \tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {", " \t\tkey_put(authkey);", " \t\tauthkey = ERR_PTR(-EKEYREVOKED);", " \t}", " ", " error:", " \treturn authkey;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static long restore_tm_sigcontexts(struct pt_regs *regs,", " \t\t\t\t   struct sigcontext __user *sc,", " \t\t\t\t   struct sigcontext __user *tm_sc)", " {", " #ifdef CONFIG_ALTIVEC", " \telf_vrreg_t __user *v_regs, *tm_v_regs;", " #endif", " \tunsigned long err = 0;", " \tunsigned long msr;", " #ifdef CONFIG_VSX", " \tint i;", " #endif", " \t ", " \terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));", " \terr |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,", " \t\t\t\tsizeof(regs->gpr));", " ", " \t ", " \terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);", " \terr |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);", "  ", "  \t ", "  \terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);", " \t ", " \tif (MSR_TM_RESV(msr))", " \t\treturn -EINVAL;", " ", "  \t ", "  \tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);", "  ", " \t ", " \tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);", " ", " \t ", " \terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);", " \terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);", " \terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);", " \terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);", " \terr |= __get_user(current->thread.ckpt_regs.ctr,", " \t\t\t  &sc->gp_regs[PT_CTR]);", " \terr |= __get_user(current->thread.ckpt_regs.link,", " \t\t\t  &sc->gp_regs[PT_LNK]);", " \terr |= __get_user(current->thread.ckpt_regs.xer,", " \t\t\t  &sc->gp_regs[PT_XER]);", " \terr |= __get_user(current->thread.ckpt_regs.ccr,", " \t\t\t  &sc->gp_regs[PT_CCR]);", " ", " \t ", " \terr |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);", " \terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);", " \terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);", " \terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);", " ", " \t ", " \tdiscard_lazy_cpu_state();", " ", " \t ", " \tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);", " ", " #ifdef CONFIG_ALTIVEC", " \terr |= __get_user(v_regs, &sc->v_regs);", " \terr |= __get_user(tm_v_regs, &tm_sc->v_regs);", " \tif (err)", " \t\treturn err;", " \tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))", " \t\treturn -EFAULT;", " \tif (tm_v_regs && !access_ok(VERIFY_READ,", " \t\t\t\t    tm_v_regs, 34 * sizeof(vector128)))", " \t\treturn -EFAULT;", " \t ", " \tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {", " \t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,", " \t\t\t\t\t33 * sizeof(vector128));", " \t\terr |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,", " \t\t\t\t\t33 * sizeof(vector128));", " \t}", " \telse if (current->thread.used_vr) {", " \t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));", " \t\tmemset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));", " \t}", " \t ", " \tif (v_regs != NULL && tm_v_regs != NULL) {", " \t\terr |= __get_user(current->thread.vrsave,", " \t\t\t\t  (u32 __user *)&v_regs[33]);", " \t\terr |= __get_user(current->thread.transact_vrsave,", " \t\t\t\t  (u32 __user *)&tm_v_regs[33]);", " \t}", " \telse {", " \t\tcurrent->thread.vrsave = 0;", " \t\tcurrent->thread.transact_vrsave = 0;", " \t}", " \tif (cpu_has_feature(CPU_FTR_ALTIVEC))", " \t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);", " #endif  ", " \t ", " \terr |= copy_fpr_from_user(current, &sc->fp_regs);", " \terr |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);", " #ifdef CONFIG_VSX", " \t ", " \tif (v_regs && ((msr & MSR_VSX) != 0)) {", " \t\tv_regs += ELF_NVRREG;", " \t\ttm_v_regs += ELF_NVRREG;", " \t\terr |= copy_vsx_from_user(current, v_regs);", " \t\terr |= copy_transact_vsx_from_user(current, tm_v_regs);", " \t} else {", " \t\tfor (i = 0; i < 32 ; i++) {", " \t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;", " \t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;", " \t\t}", " \t}", " #endif", " \ttm_enable();", " \t ", " \tcurrent->thread.tm_texasr |= TEXASR_FS;", " \t ", " \ttm_recheckpoint(&current->thread, msr);", " ", " \t ", " \tif (msr & MSR_FP) {", " \t\tdo_load_up_transact_fpu(&current->thread);", " \t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);", " \t}", " #ifdef CONFIG_ALTIVEC", " \tif (msr & MSR_VEC) {", " \t\tdo_load_up_transact_altivec(&current->thread);", " \t\tregs->msr |= MSR_VEC;", " \t}", " #endif", " ", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void FrameLoader::StartNavigation(const FrameLoadRequest& passed_request,", "                                   WebFrameLoadType frame_load_type,", "                                   NavigationPolicy policy) {", "   CHECK(!IsBackForwardLoadType(frame_load_type));", "   DCHECK(passed_request.TriggeringEventInfo() !=", "          WebTriggeringEventInfo::kUnknown);", " ", "   DCHECK(frame_->GetDocument());", "   if (HTMLFrameOwnerElement* element = frame_->DeprecatedLocalOwner())", "     element->CancelPendingLazyLoad();", " ", "   if (in_stop_all_loaders_)", "     return;", " ", "   FrameLoadRequest request(passed_request);", "   ResourceRequest& resource_request = request.GetResourceRequest();", "   const KURL& url = resource_request.Url();", "   Document* origin_document = request.OriginDocument();", " ", "   resource_request.SetHasUserGesture(", "       LocalFrame::HasTransientUserActivation(frame_));", " ", "   if (!PrepareRequestForThisFrame(request))", "     return;", " ", "   Frame* target_frame =", "       request.Form() ? nullptr", "                      : frame_->FindFrameForNavigation(", "                            AtomicString(request.FrameName()), *frame_, url);", " ", "   bool should_navigate_target_frame = policy == kNavigationPolicyCurrentTab;", " ", "   if (target_frame && target_frame != frame_ && should_navigate_target_frame) {", "     if (target_frame->IsLocalFrame() &&", "         !ToLocalFrame(target_frame)->IsNavigationAllowed()) {", "       return;", "     }", " ", "     bool was_in_same_page = target_frame->GetPage() == frame_->GetPage();", " ", "     request.SetFrameName(\"_self\");", "     target_frame->Navigate(request, frame_load_type);", "     Page* page = target_frame->GetPage();", "     if (!was_in_same_page && page)", "       page->GetChromeClient().Focus(frame_);", "     return;", "   }", " ", "   SetReferrerForFrameRequest(request);", " ", "   if (!target_frame && !request.FrameName().IsEmpty()) {", "     if (policy == kNavigationPolicyDownload) {", "       Client()->DownloadURL(resource_request,", "                             DownloadCrossOriginRedirects::kFollow);", "       return;   ", "     } else if (should_navigate_target_frame) {", "       resource_request.SetFrameType(", "           network::mojom::RequestContextFrameType::kAuxiliary);", "       CreateWindowForRequest(request, *frame_);", "       return;   ", "     }", "   }", " ", "   if (!frame_->IsNavigationAllowed() ||", "       frame_->GetDocument()->PageDismissalEventBeingDispatched() !=", "           Document::kNoDismissal) {", "     return;", "   }", " ", "   frame_load_type = DetermineFrameLoadType(resource_request, origin_document,", "                                            KURL(), frame_load_type);", " ", "   bool same_document_navigation =", "       policy == kNavigationPolicyCurrentTab &&", "       ShouldPerformFragmentNavigation(", "           request.Form(), resource_request.HttpMethod(), frame_load_type, url);", " ", "   if (same_document_navigation) {", "     CommitSameDocumentNavigation(", "         url, frame_load_type, nullptr, request.ClientRedirect(),", "         origin_document,", "         request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent,", "         nullptr  );", "     return;", "   }", " ", "   WebNavigationType navigation_type = DetermineNavigationType(", "       frame_load_type, resource_request.HttpBody() || request.Form(),", "       request.TriggeringEventInfo() != WebTriggeringEventInfo::kNotFromEvent);", "   resource_request.SetRequestContext(", "       DetermineRequestContextFromNavigationType(navigation_type));", "   resource_request.SetFrameType(", "       frame_->IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel", "                             : network::mojom::RequestContextFrameType::kNested);", " ", "   mojom::blink::NavigationInitiatorPtr navigation_initiator;", "   if (origin_document && origin_document->GetContentSecurityPolicy()", "                              ->ExperimentalFeaturesEnabled()) {", "     WebContentSecurityPolicyList initiator_csp =", "         origin_document->GetContentSecurityPolicy()", "             ->ExposeForNavigationalChecks();", "     resource_request.SetInitiatorCSP(initiator_csp);", "     auto request = mojo::MakeRequest(&navigation_initiator);", "      origin_document->BindNavigationInitiatorRequest(std::move(request));", "    }", "  ", "   last_origin_document_ = origin_document;", " ", "    RecordLatestRequiredCSP();", " ", " ", " ", "   ModifyRequestForCSP(resource_request, origin_document);", " ", "   DCHECK(Client()->HasWebView());", "   if (url.PotentiallyDanglingMarkup() && url.ProtocolIsInHTTPFamily()) {", "     Deprecation::CountDeprecation(", "         frame_, WebFeature::kCanRequestURLHTTPContainingNewline);", "     return;", "   }", " ", "   bool has_transient_activation =", "       LocalFrame::HasTransientUserActivation(frame_);", "   if (frame_->IsMainFrame() && origin_document &&", "       frame_->GetPage() == origin_document->GetPage()) {", "     LocalFrame::ConsumeTransientUserActivation(frame_);", "   }", " ", "   Client()->BeginNavigation(", "       resource_request, origin_document, nullptr  ,", "       navigation_type, policy, has_transient_activation, frame_load_type,", "       request.ClientRedirect() == ClientRedirectPolicy::kClientRedirect,", "       request.TriggeringEventInfo(), request.Form(),", "       request.ShouldCheckMainWorldContentSecurityPolicy(),", "       request.GetBlobURLToken(), request.GetInputStartTime(),", "       request.HrefTranslate().GetString(), std::move(navigation_initiator));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,", "                             UWORD16 u2_first_mb_in_slice)", " {", "  dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;", "  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;", "     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;", "     UWORD32 u4_temp;", "     WORD32 i_temp;", "     WORD32 ret;", " ", "   ", "   ", "   ", "   ", "   ", " ", "      if(ps_slice->u1_nal_ref_idc != 0)", "      {", "          if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)", "            ps_dec->u4_bitoffset = ih264d_read_mmco_commands(", "                            ps_dec);", "         {", "             i_temp = ih264d_read_mmco_commands(ps_dec);", "             if (i_temp < 0)", "             {", "                 return ERROR_DBP_MANAGER_T;", "             }", "             ps_dec->u4_bitoffset = i_temp;", "         }", "          else", "              ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;", "      }", "   ", " ", "   ", "     i_temp = ps_pps->u1_pic_init_qp", "  + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "  if((i_temp < 0) || (i_temp > 51))", "  return ERROR_INV_RANGE_QP_T;", "     ps_slice->u1_slice_qp = i_temp;", "     COPYTHECONTEXT(\"SH: slice_qp_delta\",", "                     ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);", " ", "  if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)", "  {", "         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);", "         COPYTHECONTEXT(\"SH: disable_deblocking_filter_idc\", u4_temp);", " ", "  if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "         ps_slice->u1_disable_dblk_filter_idc = u4_temp;", "  if(u4_temp != 1)", "  {", "             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)", "  << 1;", "  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "             ps_slice->i1_slice_alpha_c0_offset = i_temp;", "             COPYTHECONTEXT(\"SH: slice_alpha_c0_offset_div2\",", "                             ps_slice->i1_slice_alpha_c0_offset >> 1);", " ", "             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)", "  << 1;", "  if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))", "  {", "  return ERROR_INV_SLICE_HDR_T;", "  }", "             ps_slice->i1_slice_beta_offset = i_temp;", "             COPYTHECONTEXT(\"SH: slice_beta_offset_div2\",", "                             ps_slice->i1_slice_beta_offset >> 1);", " ", "  }", "  else", "  {", "             ps_slice->i1_slice_alpha_c0_offset = 0;", "             ps_slice->i1_slice_beta_offset = 0;", "  }", "  }", "  else", "  {", "         ps_slice->u1_disable_dblk_filter_idc = 0;", "         ps_slice->i1_slice_alpha_c0_offset = 0;", "         ps_slice->i1_slice_beta_offset = 0;", "  }", " ", "   ", "   ", "     ps_dec->u2_mv_2mb[0] = 0;", "     ps_dec->u2_mv_2mb[1] = 0;", " ", " ", "   ", "     ps_dec->u1_slice_header_done = 2;", " ", "  if(ps_pps->u1_entropy_coding_mode)", "  {", "         SWITCHOFFTRACE; SWITCHONTRACECABAC;", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)", "  {", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;", "  }", "  else", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;", " ", "         ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,", "                                              u2_first_mb_in_slice);", "  if(ret != OK)", "  return ret;", "         SWITCHONTRACE; SWITCHOFFTRACECABAC;", "  }", "  else", "  {", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)", "  {", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;", "  }", "  else", "             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;", "         ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,", "                                        u2_first_mb_in_slice);", "  if(ret != OK)", "  return ret;", "  }", " ", "  return OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void do_pclose(FILE *fin, FILE *fout) {", "char buf[BUFFER_SIZE];", "", "int64_t fptr = 0;", "read_buf(fin, buf);", "sscanf(buf, \"%\" PRId64, &fptr);", "FILE *f = (FILE *)fptr;", "int ret = ::pclose(f);", "", "fprintf(fout, \"%d\\n\", ret);", "if (ret < 0) {", "fprintf(fout, \"%d\\n\", errno);", "}", "fflush(fout);", "}"], "ner_tags": [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0]}
{"tokens": ["GF_Err latm_dmx_process(GF_Filter *filter)", "{", "GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);", "GF_FilterPacket *pck, *dst_pck;", "u32 pos;", "u8 *data, *output;", "u32 pck_size, prev_pck_size;", "u64 cts = GF_FILTER_NO_TS;", "", "if (ctx->in_error)", "return ctx->in_error;", "", "", "if (!ctx->duration.num)", "latm_dmx_check_dur(filter, ctx);", "", "if (ctx->opid && !ctx->is_playing)", "return GF_OK;", "", "pck = gf_filter_pid_get_packet(ctx->ipid);", "if (!pck) {", "if (gf_filter_pid_is_eos(ctx->ipid)) {", "if (!ctx->latm_buffer_size) {", "if (ctx->opid)", "gf_filter_pid_set_eos(ctx->opid);", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = NULL;", "return GF_EOS;", "}", "} else {", "return GF_OK;", "}", "}", "", "data = (char *) gf_filter_pck_get_data(pck, &pck_size);", "", "", "if (ctx->timescale && pck) {", "cts = gf_filter_pck_get_cts(pck);", "}", "", "prev_pck_size = ctx->latm_buffer_size;", "", "if (pck && !ctx->resume_from) {", "if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {", "ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;", "ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);", "}", "memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);", "ctx->latm_buffer_size += pck_size;", "}", "", "if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);", "else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);", "", "if (ctx->resume_from) {", "gf_bs_seek(ctx->bs, ctx->resume_from-1);", "ctx->resume_from = 0;", "}", "", "if (cts == GF_FILTER_NO_TS)", "prev_pck_size = 0;", "", "", "while (1) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "u8 latm_buffer[4096];", "u32 latm_frame_size = 4096;", "if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;", "", "if (ctx->in_seek) {", "u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);", "if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {", "", "ctx->in_seek = GF_FALSE;", "}", "}", "", "latm_dmx_check_pid(filter, ctx);", "", "if (!ctx->is_playing) {", "ctx->resume_from = pos+1;", "return GF_OK;", "}", "", "if (!ctx->in_seek) {", "GF_FilterSAPType sap = GF_FILTER_SAP_1;", "", "dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);", "if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);", "", "memcpy(output, latm_buffer, latm_frame_size);", "", "gf_filter_pck_set_cts(dst_pck, ctx->cts);", "gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);", "gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);", "", "", "if (ctx->acfg.base_object_type==GF_CODECID_USAC) {", "if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {", "sap = GF_FILTER_SAP_1;", "ctx->prev_sap = GF_TRUE;", "} else {", "sap = GF_FILTER_SAP_NONE;", "ctx->prev_sap = GF_FALSE;", "}", "}", "gf_filter_pck_set_sap(dst_pck, sap);", "", "gf_filter_pck_send(dst_pck);", "}", "latm_dmx_update_cts(ctx);", "", "if (prev_pck_size) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "if (prev_pck_size<=pos) {", "prev_pck_size=0;", "if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);", "ctx->src_pck = pck;", "if (pck)", "gf_filter_pck_ref_props(&ctx->src_pck);", "}", "}", "}", "", "if (pck) {", "pos = (u32) gf_bs_get_position(ctx->bs);", "assert(ctx->latm_buffer_size >= pos);", "memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);", "ctx->latm_buffer_size -= pos;", "gf_filter_pid_drop_packet(ctx->ipid);", "assert(!ctx->resume_from);", "} else {", "ctx->latm_buffer_size = 0;", "return latm_dmx_process(filter);", "}", "return GF_OK;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int Effect_command(effect_handle_t  self,", "  uint32_t            cmdCode,", "  uint32_t            cmdSize,", "  void *pCmdData,", "  uint32_t *replySize,", "  void *pReplyData){", "  EffectContext * pContext = (EffectContext *) self;", "  int retsize;", " ", " ", "  if(pContext->EffectType == LVM_BASS_BOOST){", "  }", "  if(pContext->EffectType == LVM_VIRTUALIZER){", "  }", "  if(pContext->EffectType == LVM_EQUALIZER){", "  }", "  if(pContext->EffectType == LVM_VOLUME){", "  }", " ", "  if (pContext == NULL){", "         ALOGV(\"\\tLVM_ERROR : Effect_command ERROR pContext == NULL\");", "  return -EINVAL;", "  }", " ", " ", " ", " ", "  ", "      switch (cmdCode){", "          case EFFECT_CMD_INIT:", "            if (pReplyData == NULL || *replySize != sizeof(int)){", "             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){", "                  ALOGV(\"\\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d\",", "                          pContext->EffectType);", "                  return -EINVAL;", "  }", "  *(int *) pReplyData = 0;", "  if(pContext->EffectType == LVM_BASS_BOOST){", "                 android::BassSetStrength(pContext, 0);", "  }", "  if(pContext->EffectType == LVM_VIRTUALIZER){", "                 android::VirtualizerSetStrength(pContext, 0);", "  }", "  if(pContext->EffectType == LVM_EQUALIZER){", "                 android::EqualizerSetPreset(pContext, 0);", "  }", "  if(pContext->EffectType == LVM_VOLUME){", "  *(int *) pReplyData = android::VolumeSetVolumeLevel(pContext, 0);", "  }", "  break;", " ", "  ", "          case EFFECT_CMD_SET_CONFIG:", "            if (pCmdData    == NULL||", "                cmdSize     != sizeof(effect_config_t)||", "                pReplyData  == NULL||", "                *replySize  != sizeof(int)){", "             if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||", "                     pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {", "                  ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"", "                          \"EFFECT_CMD_SET_CONFIG: ERROR\");", "                  return -EINVAL;", "  }", "  *(int *) pReplyData = android::Effect_setConfig(pContext, (effect_config_t *) pCmdData);", " ", "              break;", "  ", "          case EFFECT_CMD_GET_CONFIG:", "            if (pReplyData == NULL ||", "                *replySize != sizeof(effect_config_t)) {", "             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {", "                  ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"", "                          \"EFFECT_CMD_GET_CONFIG: ERROR\");", "                  return -EINVAL;", "  }", " ", "             android::Effect_getConfig(pContext, (effect_config_t *)pReplyData);", "  break;", " ", "  case EFFECT_CMD_RESET:", "             android::Effect_setConfig(pContext, &pContext->config);", "  break;", " ", " ", "          case EFFECT_CMD_GET_PARAM:{", "  ", "             effect_param_t *p = (effect_param_t *)pCmdData;", " ", "             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||", "                     cmdSize < (sizeof(effect_param_t) + p->psize) ||", "                     pReplyData == NULL || replySize == NULL ||", "                     *replySize < (sizeof(effect_param_t) + p->psize)) {", "                 ALOGV(\"\\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR\");", "                 return -EINVAL;", "             }", " ", "             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", " ", "             p = (effect_param_t *)pReplyData;", " ", "             int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);", " ", "              if(pContext->EffectType == LVM_BASS_BOOST){", "                if (pCmdData == NULL ||", "                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                        pReplyData == NULL ||", "                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){", "                    ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"", "                            \"EFFECT_CMD_GET_PARAM: ERROR\");", "                    return -EINVAL;", "                }", "                effect_param_t *p = (effect_param_t *)pCmdData;", "                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", "                p = (effect_param_t *)pReplyData;", "                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);", "                  p->status = android::BassBoost_getParameter(pContext,", "                                                              p->data,", "                                                              &p->vsize,", "                                                              p->data + voffset);", "                *replySize = sizeof(effect_param_t) + voffset + p->vsize;", " ", "              }", "  ", "              if(pContext->EffectType == LVM_VIRTUALIZER){", "                if (pCmdData == NULL ||", "                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                        pReplyData == NULL ||", "                        *replySize < (sizeof(effect_param_t) + sizeof(int32_t))){", "                    ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"", "                            \"EFFECT_CMD_GET_PARAM: ERROR\");", "                    return -EINVAL;", "                }", "                effect_param_t *p = (effect_param_t *)pCmdData;", "                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", "                p = (effect_param_t *)pReplyData;", "                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);", "                  p->status = android::Virtualizer_getParameter(pContext,", "                                                                (void *)p->data,", "                                                                &p->vsize,", "                                                                p->data + voffset);", "                *replySize = sizeof(effect_param_t) + voffset + p->vsize;", "  ", "  }", " ", "              if(pContext->EffectType == LVM_EQUALIZER){", "                if (pCmdData == NULL ||", "                    cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                    pReplyData == NULL ||", "                    *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))) {", "                    ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"", "                            \"EFFECT_CMD_GET_PARAM\");", "                    return -EINVAL;", "                }", "                effect_param_t *p = (effect_param_t *)pCmdData;", "                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", "                p = (effect_param_t *)pReplyData;", "                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);", "                  p->status = android::Equalizer_getParameter(pContext,", "                                                              p->data,", "                                                              &p->vsize,", "                                                              p->data + voffset);", "  ", "                *replySize = sizeof(effect_param_t) + voffset + p->vsize;", " ", "              }", "              if(pContext->EffectType == LVM_VOLUME){", "                if (pCmdData == NULL ||", "                        cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                        pReplyData == NULL ||", "                        *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){", "                    ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"", "                            \"EFFECT_CMD_GET_PARAM: ERROR\");", "                    return -EINVAL;", "                }", "                effect_param_t *p = (effect_param_t *)pCmdData;", "                memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);", "                p = (effect_param_t *)pReplyData;", "                int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);", "                  p->status = android::Volume_getParameter(pContext,", "                                                           (void *)p->data,", "                                                           &p->vsize,", "                                                           p->data + voffset);", "  ", "                *replySize = sizeof(effect_param_t) + voffset + p->vsize;", "              }", "             *replySize = sizeof(effect_param_t) + voffset + p->vsize;", " ", "          } break;", "          case EFFECT_CMD_SET_PARAM:{", "  if(pContext->EffectType == LVM_BASS_BOOST){", " ", "  ", "                if (pCmdData   == NULL||", "                    cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||", "                    pReplyData == NULL||", "                    *replySize != sizeof(int32_t)){", "                 if (pCmdData   == NULL ||", "                         cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||", "                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {", "                      ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"", "                              \"EFFECT_CMD_SET_PARAM: ERROR\");", "                      return -EINVAL;", "  }", "  effect_param_t *p = (effect_param_t *) pCmdData;", " ", "  if (p->psize != sizeof(int32_t)){", "                     ALOGV(\"\\tLVM_ERROR : BassBoost_command cmdCode Case: \"", "  \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");", "  return -EINVAL;", "  }", " ", " ", "  *(int *)pReplyData = android::BassBoost_setParameter(pContext,", "  (void *)p->data,", "                                                                     p->data + p->psize);", "  }", "  if(pContext->EffectType == LVM_VIRTUALIZER){", " ", "  ", "                  if (pCmdData   == NULL ||", "                    cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||", "                    cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||", "                    pReplyData == NULL ||", "                    *replySize != sizeof(int32_t)){", "                          ", "                         cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||", "                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||", "                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {", "                      ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"", "                              \"EFFECT_CMD_SET_PARAM: ERROR\");", "                      return -EINVAL;", "  }", "  effect_param_t *p = (effect_param_t *) pCmdData;", " ", "  if (p->psize != sizeof(int32_t)){", "                     ALOGV(\"\\tLVM_ERROR : Virtualizer_command cmdCode Case: \"", "  \"EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)\");", "  return -EINVAL;", "  }", " ", " ", "  *(int *)pReplyData = android::Virtualizer_setParameter(pContext,", "  (void *)p->data,", "                                                                        p->data + p->psize);", "  }", "  if(pContext->EffectType == LVM_EQUALIZER){", " ", "  ", "                  if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                    pReplyData == NULL || *replySize != sizeof(int32_t)) {", "                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {", "                      ALOGV(\"\\tLVM_ERROR : Equalizer_command cmdCode Case: \"", "                              \"EFFECT_CMD_SET_PARAM: ERROR\");", "                      return -EINVAL;", "  }", "  effect_param_t *p = (effect_param_t *) pCmdData;", " ", "  *(int *)pReplyData = android::Equalizer_setParameter(pContext,", "  (void *)p->data,", "                                                                      p->data + p->psize);", "  }", "  if(pContext->EffectType == LVM_VOLUME){", " ", "  ", "                if (    pCmdData   == NULL||", "                        cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t))||", "                        pReplyData == NULL||", "                        *replySize != sizeof(int32_t)){", "                 if (pCmdData   == NULL ||", "                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||", "                         pReplyData == NULL || replySize == NULL ||", "                         *replySize != sizeof(int32_t)) {", "                      ALOGV(\"\\tLVM_ERROR : Volume_command cmdCode Case: \"", "                              \"EFFECT_CMD_SET_PARAM: ERROR\");", "                      return -EINVAL;", "  }", "  effect_param_t *p = (effect_param_t *) pCmdData;", " ", "  *(int *)pReplyData = android::Volume_setParameter(pContext,", "  (void *)p->data,", "                                                                  p->data + p->psize);", "  }", "  } break;", " ", "  ", "          case EFFECT_CMD_ENABLE:", "              ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start\");", "            if (pReplyData == NULL || *replySize != sizeof(int)){", "             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {", "                  ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR\");", "                  return -EINVAL;", "              }", " ", "  *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_TRUE);", "  break;", " ", "  ", "          case EFFECT_CMD_DISABLE:", "            if (pReplyData == NULL || *replySize != sizeof(int)){", "             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {", "                  ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR\");", "                  return -EINVAL;", "              }", "  *(int *)pReplyData = android::Effect_setEnabled(pContext, LVM_FALSE);", "  break;", " ", " ", "          case EFFECT_CMD_SET_DEVICE:", "          {", "              ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start\");", "             if (pCmdData   == NULL){", "                 ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR\");", "                 return -EINVAL;", "             }", " ", "              uint32_t device = *(uint32_t *)pCmdData;", "              pContext->pBundledContext->nOutputDevice = (audio_devices_t) device;", "  ", "  if (pContext->EffectType == LVM_BASS_BOOST) {", "  if((device == AUDIO_DEVICE_OUT_SPEAKER) ||", "  (device == AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT) ||", "  (device == AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER)){", "                     ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_BASS_BOOST %d\",", "  *(int32_t *)pCmdData);", "                     ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_BAS_BOOST\");", " ", " ", "  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {", "                         ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_BASS_BOOST %d\",", "  *(int32_t *)pCmdData);", "                         android::LvmEffect_disable(pContext);", "  }", "                     pContext->pBundledContext->bBassTempDisabled = LVM_TRUE;", "  } else {", "                     ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_BASS_BOOST %d\",", "  *(int32_t *)pCmdData);", " ", " ", "  if (pContext->pBundledContext->bBassEnabled == LVM_TRUE) {", "                         ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_BASS_BOOST %d\",", "  *(int32_t *)pCmdData);", "                         android::LvmEffect_enable(pContext);", "  }", "                     pContext->pBundledContext->bBassTempDisabled = LVM_FALSE;", "  }", "  }", "  if (pContext->EffectType == LVM_VIRTUALIZER) {", "  if (pContext->pBundledContext->nVirtualizerForcedDevice == AUDIO_DEVICE_NONE) {", "  if (android::VirtualizerIsDeviceSupported(device) != 0) {", "                         ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is invalid for LVM_VIRTUALIZER %d\",", "  *(int32_t *)pCmdData);", "                         ALOGV(\"\\tEFFECT_CMD_SET_DEVICE temporary disable LVM_VIRTUALIZER\");", " ", " ", "  if (pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE) {", "                             ALOGV(\"\\tEFFECT_CMD_SET_DEVICE disable LVM_VIRTUALIZER %d\",", "  *(int32_t *)pCmdData);", "                             android::LvmEffect_disable(pContext);", "  }", "                         pContext->pBundledContext->bVirtualizerTempDisabled = LVM_TRUE;", "  } else {", "                         ALOGV(\"\\tEFFECT_CMD_SET_DEVICE device is valid for LVM_VIRTUALIZER %d\",", "  *(int32_t *)pCmdData);", " ", " ", "  if(pContext->pBundledContext->bVirtualizerEnabled == LVM_TRUE){", "                             ALOGV(\"\\tEFFECT_CMD_SET_DEVICE re-enable LVM_VIRTUALIZER %d\",", "  *(int32_t *)pCmdData);", "                             android::LvmEffect_enable(pContext);", "  }", "                         pContext->pBundledContext->bVirtualizerTempDisabled = LVM_FALSE;", "  }", "  }  ", "  }", "             ALOGV(\"\\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE end\");", "  break;", "  }", "  case EFFECT_CMD_SET_VOLUME:", "  {", "  uint32_t leftVolume, rightVolume;", "  int16_t  leftdB, rightdB;", "  int16_t  maxdB, pandB;", "  int32_t  vol_ret[2] = {1<<24,1<<24};  ", "  int      status = 0;", "  LVM_ControlParams_t ActiveParams;  ", "             LVM_ReturnStatus_en     LvmStatus=LVM_SUCCESS;  ", " ", "  if(pReplyData == LVM_NULL){", " ", "                  break;", "              }", "  ", "            if (pCmdData == NULL ||", "                cmdSize != 2 * sizeof(uint32_t)) {", "             if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||", "                     replySize == NULL || *replySize < 2*sizeof(int32_t)) {", "                  ALOGV(\"\\tLVM_ERROR : Effect_command cmdCode Case: \"", "                          \"EFFECT_CMD_SET_VOLUME: ERROR\");", "                  return -EINVAL;", "  }", " ", "             leftVolume  = ((*(uint32_t *)pCmdData));", "             rightVolume = ((*((uint32_t *)pCmdData + 1)));", " ", "  if(leftVolume == 0x1000000){", "                 leftVolume -= 1;", "  }", "  if(rightVolume == 0x1000000){", "                 rightVolume -= 1;", "  }", " ", "             leftdB  = android::LVC_Convert_VolToDb(leftVolume);", "             rightdB = android::LVC_Convert_VolToDb(rightVolume);", " ", "             pandB = rightdB - leftdB;", " ", "             maxdB = leftdB;", "  if(rightdB > maxdB){", "                 maxdB = rightdB;", "  }", " ", "             memcpy(pReplyData, vol_ret, sizeof(int32_t)*2);", "             android::VolumeSetVolumeLevel(pContext, (int16_t)(maxdB*100));", " ", "   ", "  LvmStatus =LVM_GetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);", "             LVM_ERROR_CHECK(LvmStatus, \"LVM_GetControlParameters\", \"VolumeSetStereoPosition\")", "  if(LvmStatus != LVM_SUCCESS) return -EINVAL;", " ", "   ", "  ActiveParams.VC_Balance  = pandB;", "             ALOGV(\"\\t\\tVolumeSetStereoPosition() (-96dB -> +96dB)-> %d\\n\", ActiveParams.VC_Balance );", " ", "   ", "  LvmStatus =LVM_SetControlParameters(pContext->pBundledContext->hInstance,&ActiveParams);", "             LVM_ERROR_CHECK(LvmStatus, \"LVM_SetControlParameters\", \"VolumeSetStereoPosition\")", "  if(LvmStatus != LVM_SUCCESS) return -EINVAL;", "  break;", "  }", "  case EFFECT_CMD_SET_AUDIO_MODE:", "  break;", "  default:", "  return -EINVAL;", "  }", " ", "  return 0;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)", "  {", "         pdf_gstate *gstate = pr->gstate + pr->gtop;", "         fz_matrix image_ctm;", "         fz_rect bbox;", "       softmask_save softmask = { NULL };", "  ", "         if (pr->super.hidden)", "                 return;", " \t\t\tbreak;", " \t\tcase PDF_MAT_SHADE:", " \t\t\tif (gstate->fill.shade)", " \t\t\t{", " \t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);", "         bbox = fz_unit_rect;", "         fz_transform_rect(&bbox, &image_ctm);", "  ", "       if (image->mask)", "        if (image->mask && gstate->blendmode)", "         {", "                  ", "               if (gstate->blendmode)", "                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);", "               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);", "       }", "       else", "               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);", "                fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);", "  ", "       if (!image->colorspace)", "       {", "               switch (gstate->fill.kind)", "                fz_try(ctx)", "                        fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);", "                fz_catch(ctx)", "                 {", "               case PDF_MAT_NONE:", "                       break;", "               case PDF_MAT_COLOR:", "                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,", "                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);", "                       break;", "               case PDF_MAT_PATTERN:", "                       if (gstate->fill.pattern)", "                       {", "                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);", "                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);", "                               fz_pop_clip(ctx, pr->dev);", "                       }", "                       break;", "               case PDF_MAT_SHADE:", "                       if (gstate->fill.shade)", "                       {", "                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);", "                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);", "                               fz_pop_clip(ctx, pr->dev);", "                       }", "                       break;", "                        fz_end_group(ctx, pr->dev);", "                        fz_rethrow(ctx);", "                 }", " ", "                fz_try(ctx)", "                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);", "                fz_always(ctx)", "                {", "                        fz_pop_clip(ctx, pr->dev);", "                        fz_end_group(ctx, pr->dev);", "                }", "                fz_catch(ctx)", "                        fz_rethrow(ctx);", "         }", "       else", "        else if (image->mask)", "         {", "               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);", "                fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);", "                fz_try(ctx)", "                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);", "                fz_always(ctx)", "                        fz_pop_clip(ctx, pr->dev);", "                fz_catch(ctx)", "                        fz_rethrow(ctx);", "         }", "       if (image->mask)", "        else", "         {", "               fz_pop_clip(ctx, pr->dev);", "               if (gstate->blendmode)", "                       fz_end_group(ctx, pr->dev);", "                softmask_save softmask = { NULL };", " ", "                gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);", " ", "                fz_try(ctx)", "                        pdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);", "                fz_always(ctx)", "                        pdf_end_group(ctx, pr, &softmask);", "                fz_catch(ctx)", "                        fz_rethrow(ctx);", "         }", "       else", "               pdf_end_group(ctx, pr, &softmask);", "  }", "  ", "  static void", " ", " \t\tif (pr->clip)", " \t\t{", " \t\t\tgstate->clip_depth++;", " \t\t\tfz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);", " \t\t\tpr->clip = 0;", " \t\t}", " ", " \t\tif (pr->super.hidden)", " \t\t\tdostroke = dofill = 0;", " ", " \t\tif (dofill || dostroke)", " \t\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);", " ", " \t\tif (dofill && dostroke)", " \t\t{", " \t\t\t ", " \t\t\tif (gstate->stroke.alpha == 0)", " \t\t\t{", " \t\t\t\t ", " \t\t\t}", " \t\t\telse if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)", " \t\t\t{", " \t\t\t\t ", " \t\t\t}", " \t\t\telse", " \t\t\t{", " \t\t\t\tknockout_group = 1;", " \t\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);", " \t\t\t}", " \t\t}", " ", " \t\tif (dofill)", " \t\t{", " \t\t\tswitch (gstate->fill.kind)", " \t\t\t{", " \t\t\tcase PDF_MAT_NONE:", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_COLOR:", " \t\t\t\tfz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,", " \t\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_PATTERN:", " \t\t\t\tif (gstate->fill.pattern)", " \t\t\t\t{", " \t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);", " \t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);", " \t\t\t\t\tfz_pop_clip(ctx, pr->dev);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_SHADE:", " \t\t\t\tif (gstate->fill.shade)", " \t\t\t\t{", " \t\t\t\t\tfz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);", " \t\t\t\t\t ", " \t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);", " \t\t\t\t\tfz_pop_clip(ctx, pr->dev);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " ", " \t\tif (dostroke)", " \t\t{", " \t\t\tswitch (gstate->stroke.kind)", " \t\t\t{", " \t\t\tcase PDF_MAT_NONE:", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_COLOR:", " \t\t\t\tfz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,", " \t\t\t\t\tgstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_PATTERN:", " \t\t\t\tif (gstate->stroke.pattern)", " \t\t\t\t{", " \t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);", " \t\t\t\t\tpdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);", " \t\t\t\t\tfz_pop_clip(ctx, pr->dev);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\tcase PDF_MAT_SHADE:", " \t\t\t\tif (gstate->stroke.shade)", " \t\t\t\t{", " \t\t\t\t\tfz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);", " \t\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);", " \t\t\t\t\tfz_pop_clip(ctx, pr->dev);", " \t\t\t\t}", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " ", " \t\tif (knockout_group)", " \t\t\tfz_end_group(ctx, pr->dev);", " ", " \t\tif (dofill || dostroke)", " \t\t\tpdf_end_group(ctx, pr, &softmask);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void Huff_Compress(msg_t *mbuf, int offset) {", " \tint\t\t\ti, ch, size;", " \tbyte\t\tseq[65536];", " \tbyte*\t\tbuffer;", " \thuff_t\t\thuff;", " ", " \tsize = mbuf->cursize - offset;", " \tbuffer = mbuf->data+ + offset;", " ", " \tif (size<=0) {", " \t\treturn;", " \t}", " ", " \tCom_Memset(&huff, 0, sizeof(huff_t));", " \thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);", " \thuff.tree->symbol = NYT;", " \thuff.tree->weight = 0;", " \thuff.lhead->next = huff.lhead->prev = NULL;", " \thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;", " ", " \tseq[0] = (size>>8);", " \tseq[1] = size&0xff;", " ", " \tbloc = 16;", "  ", "  \tfor (i=0; i<size; i++ ) {", "  \t\tch = buffer[i];", "\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t ", " \t\tHuff_transmit(&huff, ch, seq, size<<3);\t\t\t\t\t\t ", "  \t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t ", "  \t}", "  ", " \tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t ", " ", " \tmbuf->cursize = (bloc>>3) + offset;", " \tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool ScreenLayoutObserver::GetDisplayMessageForNotification(", "     const ScreenLayoutObserver::DisplayInfoMap& old_info,", "     base::string16* out_message,", "     base::string16* out_additional_message) {", "   if (old_display_mode_ != current_display_mode_) {", "     if (current_display_mode_ == DisplayMode::MIRRORING) {", "       *out_message = GetEnterMirrorModeMessage();", "       return true;", "     }", "     if (old_display_mode_ == DisplayMode::MIRRORING &&", "         GetExitMirrorModeMessage(out_message, out_additional_message)) {", "       return true;", "     }", " ", "     if (current_display_mode_ == DisplayMode::UNIFIED) {", "       *out_message = GetEnterUnifiedModeMessage();", "       return true;", "     }", "     if (old_display_mode_ == DisplayMode::UNIFIED) {", "       *out_message = GetExitUnifiedModeMessage();", "       return true;", "     }", " ", "     if (current_display_mode_ == DisplayMode::DOCKED ||", "         old_display_mode_ == DisplayMode::DOCKED) {", "       return false;", "     }", "   }", " ", "   if (display_info_.size() < old_info.size()) {", "     for (const auto& iter : old_info) {", "       if (display_info_.count(iter.first))", "         continue;", " ", "       *out_message =", "           GetDisplayRemovedMessage(iter.second, out_additional_message);", "       return true;", "     }", "   } else if (display_info_.size() > old_info.size()) {", "     for (const auto& iter : display_info_) {", "       if (old_info.count(iter.first))", "         continue;", " ", "       *out_message = GetDisplayAddedMessage(iter.first, out_additional_message);", "       return true;", "     }", "   }", " ", "   for (const auto& iter : display_info_) {", "     DisplayInfoMap::const_iterator old_iter = old_info.find(iter.first);", "     if (old_iter == old_info.end()) {", "       NOTREACHED() << \"A display mode transition that should have been handled\"", "                       \"earlier.\";", "       return false;", "     }", " ", "     if (iter.second.configured_ui_scale() !=", "         old_iter->second.configured_ui_scale()) {", "       *out_additional_message = l10n_util::GetStringFUTF16(", "           IDS_ASH_STATUS_TRAY_DISPLAY_RESOLUTION_CHANGED,", "            GetDisplayName(iter.first), GetDisplaySize(iter.first));", "        return true;", "      }", "    if (iter.second.GetActiveRotation() !=", "        old_iter->second.GetActiveRotation()) {", "      ", "      ", "     if (iter.second.active_rotation_source() !=", "             display::Display::ROTATION_SOURCE_ACCELEROMETER &&", "         iter.second.GetActiveRotation() !=", "             old_iter->second.GetActiveRotation()) {", "        int rotation_text_id = 0;", "        switch (iter.second.GetActiveRotation()) {", "          case display::Display::ROTATE_0:", "           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_STANDARD_ORIENTATION;", "           break;", "         case display::Display::ROTATE_90:", "           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_90;", "           break;", "         case display::Display::ROTATE_180:", "           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_180;", "           break;", "         case display::Display::ROTATE_270:", "           rotation_text_id = IDS_ASH_STATUS_TRAY_DISPLAY_ORIENTATION_270;", "           break;", "       }", "       *out_additional_message = l10n_util::GetStringFUTF16(", "           IDS_ASH_STATUS_TRAY_DISPLAY_ROTATED, GetDisplayName(iter.first),", "           l10n_util::GetStringUTF16(rotation_text_id));", "       return true;", "     }", "   }", " ", "   return false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)", " {", " \tflush_fp_to_thread(src);", "  \tflush_altivec_to_thread(src);", "  \tflush_vsx_to_thread(src);", "  \tflush_spe_to_thread(src);", " \t ", " \t__switch_to_tm(src);", " \ttm_recheckpoint_new_task(src);", "  ", "  \t*dst = *src;", "  ", " \tclear_task_ebb(dst);", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h)", "{", "TIFF* tif = img->tif;", "tileContigRoutine put = img->put.contig;", "uint32 row, y, nrow, nrowsub, rowstoread;", "tmsize_t pos;", "unsigned char* buf = NULL;", "uint32 rowsperstrip;", "uint16 subsamplinghor,subsamplingver;", "uint32 imagewidth = img->width;", "tmsize_t scanline;", "int32 fromskew, toskew;", "int ret = 1, flip;", "tmsize_t maxstripsize;", "", "TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver);", "if( subsamplingver == 0 ) {", "TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), \"Invalid vertical YCbCr subsampling\");", "return (0);", "}", "", "maxstripsize = TIFFStripSize(tif);", "", "flip = setorientation(img);", "if (flip & FLIP_VERTICALLY) {", "y = h - 1;", "toskew = -(int32)(w + w);", "} else {", "y = 0;", "toskew = -(int32)(w - w);", "}", "", "TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);", "", "scanline = TIFFScanlineSize(tif);", "fromskew = (w < imagewidth ? imagewidth - w : 0);", "for (row = 0; row < h; row += nrow)", "{", "rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip;", "nrow = (row + rowstoread > h ? h - row : rowstoread);", "nrowsub = nrow;", "if ((nrowsub%subsamplingver)!=0)", "nrowsub+=subsamplingver-nrowsub%subsamplingver;", "if (_TIFFReadEncodedStripAndAllocBuffer(tif,", "TIFFComputeStrip(tif,row+img->row_offset, 0),", "(void**)(&buf),", "maxstripsize,", "((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1)", "&& (buf == NULL || img->stoponerr))", "{", "ret = 0;", "break;", "}", "", "pos = ((row + img->row_offset) % rowsperstrip) * scanline +", "((tmsize_t) img->col_offset * img->samplesperpixel);", "(*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos);", "y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow);", "}", "", "if (flip & FLIP_HORIZONTALLY) {", "uint32 line;", "", "for (line = 0; line < h; line++) {", "uint32 *left = raster + (line * w);", "uint32 *right = left + w - 1;", "", "while ( left < right ) {", "uint32 temp = *left;", "*left = *right;", "*right = temp;", "left++;", "right--;", "}", "}", "}", "", "_TIFFfree(buf);", "return (ret);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,", " \t\t    struct nfs_getaclres *res)", " {", " \tstruct compound_hdr hdr;", " \tint status;", " ", " \tstatus = decode_compound_hdr(xdr, &hdr);", " \tif (status)", " \t\tgoto out;", " \tstatus = decode_sequence(xdr, &res->seq_res, rqstp);", " \tif (status)", " \t\tgoto out;", "  \tstatus = decode_putfh(xdr);", "  \tif (status)", "  \t\tgoto out;", "\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);", " \tstatus = decode_getacl(xdr, rqstp, res);", "  ", "  out:", "  \treturn status;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int wddx_stack_destroy(wddx_stack *stack)", " {", " \tregister int i;", "  ", "  \tif (stack->elements) {", "  \t\tfor (i = 0; i < stack->top; i++) {", "\t\t\tif (((st_entry *)stack->elements[i])->data)\t{", " \t\t\tif (((st_entry *)stack->elements[i])->data", " \t\t\t\t\t&& ((st_entry *)stack->elements[i])->type != ST_FIELD)\t{", "  \t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);", "  \t\t\t}", "  \t\t\tif (((st_entry *)stack->elements[i])->varname) {", " \t\t\t\tefree(((st_entry *)stack->elements[i])->varname);", " \t\t\t}", " \t\t\tefree(stack->elements[i]);", " \t\t}", " \t\tefree(stack->elements);", " \t}", " \treturn SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)", " {", " \tstruct session_state *state = ssh->state;", " \tu_int padlen, need;", " \tu_char *cp;", " \tu_int maclen, aadlen = 0, authlen = 0, block_size;", " \tstruct sshenc *enc   = NULL;", " \tstruct sshmac *mac   = NULL;", " \tstruct sshcomp *comp = NULL;", " \tint r;", " ", " \t*typep = SSH_MSG_NONE;", " ", " \tif (state->packet_discard)", " \t\treturn 0;", " ", " \tif (state->newkeys[MODE_IN] != NULL) {", " \t\tenc  = &state->newkeys[MODE_IN]->enc;", " \t\tmac  = &state->newkeys[MODE_IN]->mac;", " \t\tcomp = &state->newkeys[MODE_IN]->comp;", " \t\t ", " \t\tif ((authlen = cipher_authlen(enc->cipher)) != 0)", " \t\t\tmac = NULL;", " \t}", " \tmaclen = mac && mac->enabled ? mac->mac_len : 0;", " \tblock_size = enc ? enc->block_size : 8;", " \taadlen = (mac && mac->enabled && mac->etm) || authlen ? 4 : 0;", " ", " \tif (aadlen && state->packlen == 0) {", " \t\tif (cipher_get_length(state->receive_context,", " \t\t    &state->packlen, state->p_read.seqnr,", " \t\t    sshbuf_ptr(state->input), sshbuf_len(state->input)) != 0)", " \t\t\treturn 0;", " \t\tif (state->packlen < 1 + 4 ||", " \t\t    state->packlen > PACKET_MAX_SIZE) {", " #ifdef PACKET_DEBUG", " \t\t\tsshbuf_dump(state->input, stderr);", " #endif", " \t\t\tlogit(\"Bad packet length %u.\", state->packlen);", " \t\t\tif ((r = sshpkt_disconnect(ssh, \"Packet corrupt\")) != 0)", " \t\t\t\treturn r;", " \t\t\treturn SSH_ERR_CONN_CORRUPT;", " \t\t}", " \t\tsshbuf_reset(state->incoming_packet);", " \t} else if (state->packlen == 0) {", " \t\t ", " \t\tif (sshbuf_len(state->input) < block_size)", " \t\t\treturn 0;", " \t\tsshbuf_reset(state->incoming_packet);", " \t\tif ((r = sshbuf_reserve(state->incoming_packet, block_size,", " \t\t    &cp)) != 0)", " \t\t\tgoto out;", " \t\tif ((r = cipher_crypt(state->receive_context,", " \t\t    state->p_send.seqnr, cp, sshbuf_ptr(state->input),", " \t\t    block_size, 0, 0)) != 0)", " \t\t\tgoto out;", " \t\tstate->packlen = PEEK_U32(sshbuf_ptr(state->incoming_packet));", " \t\tif (state->packlen < 1 + 4 ||", " \t\t    state->packlen > PACKET_MAX_SIZE) {", " #ifdef PACKET_DEBUG", " \t\t\tfprintf(stderr, \"input: \\n\");", " \t\t\tsshbuf_dump(state->input, stderr);", " \t\t\tfprintf(stderr, \"incoming_packet: \\n\");", " \t\t\tsshbuf_dump(state->incoming_packet, stderr);", " #endif", " \t\t\tlogit(\"Bad packet length %u.\", state->packlen);", " \t\t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,", " \t\t\t    PACKET_MAX_SIZE);", " \t\t}", " \t\tif ((r = sshbuf_consume(state->input, block_size)) != 0)", " \t\t\tgoto out;", " \t}", " \tDBG(debug(\"input: packet len %u\", state->packlen+4));", " ", " \tif (aadlen) {", " \t\t ", " \t\tneed = state->packlen;", " \t} else {", " \t\t ", " \t\tneed = 4 + state->packlen - block_size;", " \t}", " \tDBG(debug(\"partial packet: block %d, need %d, maclen %d, authlen %d,\"", " \t    \" aadlen %d\", block_size, need, maclen, authlen, aadlen));", " \tif (need % block_size != 0) {", " \t\tlogit(\"padding error: need %d block %d mod %d\",", " \t\t    need, block_size, need % block_size);", " \t\treturn ssh_packet_start_discard(ssh, enc, mac, 0,", " \t\t    PACKET_MAX_SIZE - block_size);", " \t}", " \t ", " \tif (sshbuf_len(state->input) < aadlen + need + authlen + maclen)", " \t\treturn 0;  ", " #ifdef PACKET_DEBUG", " \tfprintf(stderr, \"read_poll enc/full: \");", " \tsshbuf_dump(state->input, stderr);", " #endif", " \t ", " \tif (mac && mac->enabled && mac->etm) {", " \t\tif ((r = mac_check(mac, state->p_read.seqnr,", " \t\t    sshbuf_ptr(state->input), aadlen + need,", " \t\t    sshbuf_ptr(state->input) + aadlen + need + authlen,", " \t\t    maclen)) != 0) {", " \t\t\tif (r == SSH_ERR_MAC_INVALID)", " \t\t\t\tlogit(\"Corrupted MAC on input.\");", " \t\t\tgoto out;", " \t\t}", " \t}", " \tif ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,", " \t    &cp)) != 0)", " \t\tgoto out;", " \tif ((r = cipher_crypt(state->receive_context, state->p_read.seqnr, cp,", " \t    sshbuf_ptr(state->input), need, aadlen, authlen)) != 0)", " \t\tgoto out;", " \tif ((r = sshbuf_consume(state->input, aadlen + need + authlen)) != 0)", " \t\tgoto out;", " \tif (mac && mac->enabled) {", " \t\t ", " \t\tif (!mac->etm && (r = mac_check(mac, state->p_read.seqnr,", " \t\t    sshbuf_ptr(state->incoming_packet),", " \t\t    sshbuf_len(state->incoming_packet),", " \t\t    sshbuf_ptr(state->input), maclen)) != 0) {", " \t\t\tif (r != SSH_ERR_MAC_INVALID)", " \t\t\t\tgoto out;", " \t\t\tlogit(\"Corrupted MAC on input.\");", " \t\t\tif (need > PACKET_MAX_SIZE)", " \t\t\t\treturn SSH_ERR_INTERNAL_ERROR;", " \t\t\treturn ssh_packet_start_discard(ssh, enc, mac,", " \t\t\t    sshbuf_len(state->incoming_packet),", " \t\t\t    PACKET_MAX_SIZE - need);", " \t\t}", " \t\t ", " \t\tDBG(debug(\"MAC #%d ok\", state->p_read.seqnr));", " \t\tif ((r = sshbuf_consume(state->input, mac->mac_len)) != 0)", " \t\t\tgoto out;", " \t}", " \tif (seqnr_p != NULL)", " \t\t*seqnr_p = state->p_read.seqnr;", " \tif (++state->p_read.seqnr == 0)", " \t\tlogit(\"incoming seqnr wraps around\");", " \tif (++state->p_read.packets == 0)", " \t\tif (!(ssh->compat & SSH_BUG_NOREKEY))", " \t\t\treturn SSH_ERR_NEED_REKEY;", " \tstate->p_read.blocks += (state->packlen + 4) / block_size;", " \tstate->p_read.bytes += state->packlen + 4;", " ", " \t ", " \tpadlen = sshbuf_ptr(state->incoming_packet)[4];", " \tDBG(debug(\"input: padlen %d\", padlen));", " \tif (padlen < 4)\t{", " \t\tif ((r = sshpkt_disconnect(ssh,", " \t\t    \"Corrupted padlen %d on input.\", padlen)) != 0 ||", " \t\t    (r = ssh_packet_write_wait(ssh)) != 0)", " \t\t\treturn r;", " \t\treturn SSH_ERR_CONN_CORRUPT;", " \t}", " ", " \t ", " \tif ((r = sshbuf_consume(state->incoming_packet, 4 + 1)) != 0 ||", " \t    ((r = sshbuf_consume_end(state->incoming_packet, padlen)) != 0))", " \t\tgoto out;", " ", " \tDBG(debug(\"input: len before de-compress %zd\",", " \t    sshbuf_len(state->incoming_packet)));", " \tif (comp && comp->enabled) {", " \t\tsshbuf_reset(state->compression_buffer);", " \t\tif ((r = uncompress_buffer(ssh, state->incoming_packet,", " \t\t    state->compression_buffer)) != 0)", " \t\t\tgoto out;", " \t\tsshbuf_reset(state->incoming_packet);", " \t\tif ((r = sshbuf_putb(state->incoming_packet,", " \t\t    state->compression_buffer)) != 0)", " \t\t\tgoto out;", " \t\tDBG(debug(\"input: len after de-compress %zd\",", " \t\t    sshbuf_len(state->incoming_packet)));", " \t}", " \t ", " \tif ((r = sshbuf_get_u8(state->incoming_packet, typep)) != 0)", " \t\tgoto out;", " \tif (ssh_packet_log_type(*typep))", " \t\tdebug3(\"receive packet: type %u\", *typep);", " \tif (*typep < SSH2_MSG_MIN || *typep >= SSH2_MSG_LOCAL_MIN) {", " \t\tif ((r = sshpkt_disconnect(ssh,", " \t\t    \"Invalid ssh2 packet type: %d\", *typep)) != 0 ||", " \t\t    (r = ssh_packet_write_wait(ssh)) != 0)", "  \t\t\treturn r;", "  \t\treturn SSH_ERR_PROTOCOL_ERROR;", "  \t}", "\tif (*typep == SSH2_MSG_NEWKEYS)", "\t\tr = ssh_set_newkeys(ssh, MODE_IN);", "\telse if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)", " \tif (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)", "  \t\tr = ssh_packet_enable_delayed_compress(ssh);", "  \telse", "  \t\tr = 0;", " \telse", " \t\tr = 0;", " #ifdef PACKET_DEBUG", " \tfprintf(stderr, \"read/plain[%d]:\\r\\n\", *typep);", " \tsshbuf_dump(state->incoming_packet, stderr);", " #endif", " \t ", " \tstate->packlen = 0;", " ", " \t ", " \tif (ssh_packet_need_rekeying(ssh, 0)) {", " \t\tdebug3(\"%s: rekex triggered\", __func__);", " \t\tif ((r = kex_start_rekex(ssh)) != 0)", " \t\t\treturn r;", " \t}", "  out:", " \treturn r;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)", " {", "     RenderStyle* oldStyle = style();", "  ", "      setReplaced(newStyle.isDisplayInlineType());", "  ", "    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {", "     if (oldStyle && parent() && diff.needsFullLayout() && oldStyle->position() != newStyle.position()) {", "          if (newStyle.position() == StaticPosition)", "             removePositionedObjects(0, NewContainingBlock);", "         else if (oldStyle->position() == StaticPosition) {", "             RenderObject* cb = parent();", "             while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {", "                 if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {", "                     cb = cb->containingBlock();", "                     break;", "                 }", "                 cb = cb->parent();", "             }", " ", "             if (cb->isRenderBlock())", "                 toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);", "         }", "     }", " ", "     RenderBox::styleWillChange(diff, newStyle);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool ExecuteTranspose(LocalFrame& frame,", "                               Event*,", "                               EditorCommandSource,", "                               const String&) {", "  frame.GetEditor().Transpose();", "   Transpose(frame);", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["  void PrintViewManager::PrintPreviewDone() {", "    DCHECK_CURRENTLY_ON(BrowserThread::UI);", "  DCHECK_NE(NOT_PREVIEWING, print_preview_state_);", "   if (print_preview_state_ == NOT_PREVIEWING)", "     return;", "  ", "    if (print_preview_state_ == SCRIPTED_PREVIEW) {", "      auto& map = g_scripted_print_preview_closure_map.Get();", "     auto it = map.find(scripted_print_preview_rph_);", "     CHECK(it != map.end());", "     it->second.Run();", "     map.erase(it);", "     scripted_print_preview_rph_ = nullptr;", "   }", "   print_preview_state_ = NOT_PREVIEWING;", "   print_preview_rfh_ = nullptr;", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int yr_re_match(", "     RE* re,", "     const char* target)", " {", "   return yr_re_exec(", "        re->code,", "        (uint8_t*) target,", "        strlen(target),", "       0,", "        re->flags | RE_FLAGS_SCAN,", "        NULL,", "        NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["   ReleaseAccelerator(ui::KeyboardCode keycode,", "                     bool shift_pressed,", "                     bool ctrl_pressed,", "                     bool alt_pressed)", "      : ui::Accelerator(keycode, shift_pressed, ctrl_pressed, alt_pressed) {", "   ReleaseAccelerator(ui::KeyboardCode keycode, int modifiers)", "       : ui::Accelerator(keycode, modifiers) {", "      set_type(ui::ET_KEY_RELEASED);", "    }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,", " \t\t       size_t len)", " {", " \tstruct inet_sock *inet = inet_sk(sk);", " \tstruct ipcm_cookie ipc;", " \tstruct rtable *rt = NULL;", " \tint free = 0;", " \t__be32 daddr;", "  \t__be32 saddr;", "  \tu8  tos;", "  \tint err;", " \tstruct ip_options_data opt_copy;", "  ", "  \terr = -EMSGSIZE;", "  \tif (len > 0xFFFF)", " \t\tgoto out;", " ", " \t ", " ", " \terr = -EOPNOTSUPP;", " \tif (msg->msg_flags & MSG_OOB)\t ", " \t\tgoto out;                ", " ", " \t ", " ", " \tif (msg->msg_namelen) {", " \t\tstruct sockaddr_in *usin = (struct sockaddr_in *)msg->msg_name;", " \t\terr = -EINVAL;", " \t\tif (msg->msg_namelen < sizeof(*usin))", " \t\t\tgoto out;", " \t\tif (usin->sin_family != AF_INET) {", " \t\t\tstatic int complained;", " \t\t\tif (!complained++)", " \t\t\t\tprintk(KERN_INFO \"%s forgot to set AF_INET in \"", " \t\t\t\t\t\t \"raw sendmsg. Fix it!\\n\",", " \t\t\t\t\t\t current->comm);", " \t\t\terr = -EAFNOSUPPORT;", " \t\t\tif (usin->sin_family)", " \t\t\t\tgoto out;", " \t\t}", " \t\tdaddr = usin->sin_addr.s_addr;", " \t\t ", " \t} else {", " \t\terr = -EDESTADDRREQ;", " \t\tif (sk->sk_state != TCP_ESTABLISHED)", " \t\t\tgoto out;", " \t\tdaddr = inet->inet_daddr;", " \t}", " ", " \tipc.addr = inet->inet_saddr;", " \tipc.opt = NULL;", " \tipc.tx_flags = 0;", " \tipc.oif = sk->sk_bound_dev_if;", " ", " \tif (msg->msg_controllen) {", " \t\terr = ip_cmsg_send(sock_net(sk), msg, &ipc);", " \t\tif (err)", " \t\t\tgoto out;", " \t\tif (ipc.opt)", " \t\t\tfree = 1;", " \t}", " ", "  \tsaddr = ipc.addr;", "  \tipc.addr = daddr;", "  ", "\tif (!ipc.opt)", "\t\tipc.opt = inet->opt;", " \tif (!ipc.opt) {", " \t\tstruct ip_options_rcu *inet_opt;", " ", " \t\trcu_read_lock();", " \t\tinet_opt = rcu_dereference(inet->inet_opt);", " \t\tif (inet_opt) {", " \t\t\tmemcpy(&opt_copy, inet_opt,", " \t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);", " \t\t\tipc.opt = &opt_copy.opt;", " \t\t}", " \t\trcu_read_unlock();", " \t}", "  ", "  \tif (ipc.opt) {", "  \t\terr = -EINVAL;", " \t\t ", "  \t\tif (inet->hdrincl)", "  \t\t\tgoto done;", "\t\tif (ipc.opt->srr) {", " \t\tif (ipc.opt->opt.srr) {", "  \t\t\tif (!daddr)", "  \t\t\t\tgoto done;", "\t\t\tdaddr = ipc.opt->faddr;", " \t\t\tdaddr = ipc.opt->opt.faddr;", "  \t\t}", "  \t}", "  \ttos = RT_CONN_FLAGS(sk);", " \tif (msg->msg_flags & MSG_DONTROUTE)", " \t\ttos |= RTO_ONLINK;", " ", " \tif (ipv4_is_multicast(daddr)) {", " \t\tif (!ipc.oif)", " \t\t\tipc.oif = inet->mc_index;", " \t\tif (!saddr)", " \t\t\tsaddr = inet->mc_addr;", " \t}", " ", " \t{", " \t\tstruct flowi4 fl4;", " ", " \t\tflowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,", " \t\t\t\t   RT_SCOPE_UNIVERSE,", " \t\t\t\t   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,", " \t\t\t\t   FLOWI_FLAG_CAN_SLEEP, daddr, saddr, 0, 0);", " ", " \t\tif (!inet->hdrincl) {", " \t\t\terr = raw_probe_proto_opt(&fl4, msg);", " \t\t\tif (err)", " \t\t\t\tgoto done;", " \t\t}", " ", " \t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi(&fl4));", " \t\trt = ip_route_output_flow(sock_net(sk), &fl4, sk);", " \t\tif (IS_ERR(rt)) {", " \t\t\terr = PTR_ERR(rt);", " \t\t\trt = NULL;", " \t\t\tgoto done;", " \t\t}", " \t}", " ", " \terr = -EACCES;", " \tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))", " \t\tgoto done;", " ", " \tif (msg->msg_flags & MSG_CONFIRM)", " \t\tgoto do_confirm;", " back_from_confirm:", " ", " \tif (inet->hdrincl)", " \t\terr = raw_send_hdrinc(sk, msg->msg_iov, len,", " \t\t\t\t\t&rt, msg->msg_flags);", " ", " \t else {", " \t\tif (!ipc.addr)", " \t\t\tipc.addr = rt->rt_dst;", " \t\tlock_sock(sk);", " \t\terr = ip_append_data(sk, ip_generic_getfrag, msg->msg_iov, len, 0,", " \t\t\t\t\t&ipc, &rt, msg->msg_flags);", " \t\tif (err)", " \t\t\tip_flush_pending_frames(sk);", " \t\telse if (!(msg->msg_flags & MSG_MORE)) {", " \t\t\terr = ip_push_pending_frames(sk);", " \t\t\tif (err == -ENOBUFS && !inet->recverr)", " \t\t\t\terr = 0;", " \t\t}", " \t\trelease_sock(sk);", " \t}", " done:", " \tif (free)", " \t\tkfree(ipc.opt);", " \tip_rt_put(rt);", " ", " out:", " \tif (err < 0)", " \t\treturn err;", " \treturn len;", " ", " do_confirm:", " \tdst_confirm(&rt->dst);", " \tif (!(msg->msg_flags & MSG_PROBE) || len)", " \t\tgoto back_from_confirm;", " \terr = 0;", " \tgoto done;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)", " {", " \tzval *IM, *POINTS;", " \tlong NPOINTS, COL;", " \tzval **var = NULL;", " \tgdImagePtr im;", " \tgdPointPtr points;", " \tint npoints, col, nelem, i;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);", " ", " \tnpoints = NPOINTS;", " \tcol = COL;", " ", " \tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));", " \tif (nelem < 6) {", " \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");", " \t\tRETURN_FALSE;", " \t}", " \tif (npoints <= 0) {", " \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");", " \t\tRETURN_FALSE;", " \t}", " \tif (nelem < npoints * 2) {", " \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);", " \t\tRETURN_FALSE;", " \t}", " ", " \tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);", "  ", "  \tfor (i = 0; i < npoints; i++) {", "  \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {", "\t\t\tSEPARATE_ZVAL((var));", "\t\t\tconvert_to_long(*var);", "\t\t\tpoints[i].x = Z_LVAL_PP(var);", " \t\t\tif (Z_TYPE_PP(var) != IS_LONG) {", " \t\t\t\tzval lval;", " \t\t\t\tlval = **var;", " \t\t\t\tzval_copy_ctor(&lval);", " \t\t\t\tconvert_to_long(&lval);", " \t\t\t\tpoints[i].x = Z_LVAL(lval);", " \t\t\t} else {", " \t\t\t\tpoints[i].x = Z_LVAL_PP(var);", " \t\t\t}", "  \t\t}", "  \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {", "\t\t\tSEPARATE_ZVAL(var);", "\t\t\tconvert_to_long(*var);", "\t\t\tpoints[i].y = Z_LVAL_PP(var);", " \t\t\tif (Z_TYPE_PP(var) != IS_LONG) {", " \t\t\t\tzval lval;", " \t\t\t\tlval = **var;", " \t\t\t\tzval_copy_ctor(&lval);", " \t\t\t\tconvert_to_long(&lval);", " \t\t\t\tpoints[i].y = Z_LVAL(lval);", " \t\t\t} else {", " \t\t\t\tpoints[i].y = Z_LVAL_PP(var);", " \t\t\t}", "  \t\t}", "  \t}", "  ", " \tif (filled) {", " \t\tgdImageFilledPolygon(im, points, npoints, col);", " \t} else {", " \t\tgdImagePolygon(im, points, npoints, col);", " \t}", " ", " \tefree(points);", " \tRETURN_TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static s32 gf_media_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc)", "{", "u32 i;", "s32 pps_id;", "VVC_PPS *pps;", "", "", "pps_id = gf_bs_read_int_log(bs, 6, \"pps_id\");", "", "if ((pps_id < 0) || (pps_id >= 64)) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));", "return -1;", "}", "pps = &vvc->pps[pps_id];", "", "if (!pps->state) {", "pps->id = pps_id;", "pps->state = 1;", "}", "pps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");", "if (pps->sps_id >= 16) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));", "pps->sps_id=0;", "return -1;", "}", "vvc->sps_active_idx = pps->sps_id;", "pps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");", "pps->width = gf_bs_read_ue_log(bs, \"width\");", "pps->height = gf_bs_read_ue_log(bs, \"height\");", "pps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");", "if (pps->conf_window) {", "pps->cw_left = gf_bs_read_ue_log(bs, \"conf_win_left_offset\");", "pps->cw_right = gf_bs_read_ue_log(bs, \"conf_win_right_offset\");", "pps->cw_top = gf_bs_read_ue_log(bs, \"conf_win_top_offset\");", "pps->cw_bottom = gf_bs_read_ue_log(bs, \"conf_win_bottom_offset\");", "}", "", "if (gf_bs_read_int_log(bs, 1, \"scaling_window_explicit_signalling_flag\")) {", "gf_bs_read_se_log(bs, \"scaling_win_left_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_right_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_top_offset\");", "gf_bs_read_se_log(bs, \"scaling_win_bottom_offset\");", "}", "pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, \"output_flag_present_flag\");", "pps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, \"no_pic_partition_flag\");", "pps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, \"subpic_id_mapping_present_flag\");", "if (pps->subpic_id_mapping_present_flag) {", "u32 pps_subpic_id_len, pps_num_subpics=0;", "if (!pps->no_pic_partition_flag) {", "pps_num_subpics = 1+gf_bs_read_ue_log(bs, \"pps_num_subpics_minus1\");", "}", "pps_subpic_id_len = 1 + gf_bs_read_ue(bs);", "for (i=0; i<pps_num_subpics; i++) {", "gf_bs_read_int_log_idx(bs, pps_subpic_id_len, \"subpic_id\", i);", "}", "}", "if (!pps->no_pic_partition_flag) {", "gf_bs_read_int_log(bs, 2, \"pps_log2_ctu_size_minus5\");", "u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_columns_minus1\");", "u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, \"num_exp_tile_rows_minus1\");", "for (i=0; i<num_exp_tile_columns; i++)", "gf_bs_read_ue_log_idx(bs, \"tile_column_width_minus1\", i);", "for (i=0; i<num_exp_tile_rows; i++)", "gf_bs_read_ue_log_idx(bs, \"tile_row_height_minus1\", i);", "", "", "return pps_id;", "}", "", "", "", "", "return pps_id;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" safe_fprintf(FILE *f, const char *fmt, ...)", " {", " \tchar fmtbuff_stack[256];  ", " \tchar outbuff[256];  ", " \tchar *fmtbuff_heap;  ", " \tchar *fmtbuff;   ", " \tint fmtbuff_length;", " \tint length, n;", " \tva_list ap;", " \tconst char *p;", " \tunsigned i;", " \twchar_t wc;", " \tchar try_wc;", " ", " \t ", " \tfmtbuff_heap = NULL;", " \tfmtbuff_length = sizeof(fmtbuff_stack);", " \tfmtbuff = fmtbuff_stack;", " ", " \t ", " \tva_start(ap, fmt);", " \tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);", " \tva_end(ap);", " ", " \t ", " \twhile (length < 0 || length >= fmtbuff_length) {", " \t\tif (length >= fmtbuff_length)", " \t\t\tfmtbuff_length = length+1;", " \t\telse if (fmtbuff_length < 8192)", " \t\t\tfmtbuff_length *= 2;", " \t\telse if (fmtbuff_length < 1000000)", " \t\t\tfmtbuff_length += fmtbuff_length / 4;", " \t\telse {", " \t\t\tlength = fmtbuff_length;", " \t\t\tfmtbuff_heap[length-1] = '\\0';", " \t\t\tbreak;", " \t\t}", " \t\tfree(fmtbuff_heap);", " \t\tfmtbuff_heap = malloc(fmtbuff_length);", " ", " \t\t ", " \t\tif (fmtbuff_heap != NULL) {", " \t\t\tfmtbuff = fmtbuff_heap;", " \t\t\tva_start(ap, fmt);", " \t\t\tlength = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);", " \t\t\tva_end(ap);", " \t\t} else {", " \t\t\t ", " \t\t\tlength = sizeof(fmtbuff_stack) - 1;", " \t\t\tbreak;", " \t\t}", " \t}", " ", " \t ", " \tif (mbtowc(NULL, NULL, 1) == -1) {  ", " \t\t ", " \t\tfree(fmtbuff_heap);", " \t\treturn;", " \t}", " ", " \t ", " \tp = fmtbuff;", " \ti = 0;", " \ttry_wc = 1;", " \twhile (*p != '\\0') {", " ", " \t\t ", " \t\tif (try_wc && (n = mbtowc(&wc, p, length)) != -1) {", " \t\t\tlength -= n;", " \t\t\tif (iswprint(wc) && wc != L'\\\\') {", " \t\t\t\t ", " \t\t\t\twhile (n-- > 0)", " \t\t\t\t\toutbuff[i++] = *p++;", " \t\t\t} else {", " \t\t\t\t ", " \t\t\t\twhile (n-- > 0)", " \t\t\t\t\ti += (unsigned)bsdtar_expand_char(", " \t\t\t\t\t    outbuff, i, *p++);", " \t\t\t}", " \t\t} else {", " \t\t\t ", " \t\t\ti += (unsigned)bsdtar_expand_char(outbuff, i, *p++);", " \t\t\ttry_wc = 0;", "  \t\t}", "  ", "  \t\t ", "\t\tif (i > (sizeof(outbuff) - 20)) {", " \t\tif (i > (sizeof(outbuff) - 128)) {", "  \t\t\toutbuff[i] = '\\0';", "  \t\t\tfprintf(f, \"%s\", outbuff);", "  \t\t\ti = 0;", " \t\t}", " \t}", " \toutbuff[i] = '\\0';", " \tfprintf(f, \"%s\", outbuff);", " ", " \t ", " \tfree(fmtbuff_heap);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" QTN2QT(QTNode *in)", " {", " \tTSQuery\t\tout;", " \tint\t\t\tlen;", " \tint\t\t\tsumlen = 0,", " \t\t\t\tnnode = 0;", "  \tQTN2QTState state;", "  ", "  \tcntsize(in, &sumlen, &nnode);", " ", " \tif (TSQUERY_TOO_BIG(nnode, sumlen))", " \t\tereport(ERROR,", " \t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),", " \t\t\t\t errmsg(\"tsquery is too large\")));", "  \tlen = COMPUTESIZE(nnode, sumlen);", "  ", "  \tout = (TSQuery) palloc0(len);", " \tSET_VARSIZE(out, len);", " \tout->size = nnode;", " ", " \tstate.curitem = GETQUERY(out);", " \tstate.operand = state.curoperand = GETOPERAND(out);", " ", " \tfillQT(&state, in);", " \treturn out;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(", "         OMX_BUFFERHEADERTYPE **header,", "         OMX_U32 portIndex,", "         OMX_PTR appPrivate,", "         OMX_U32 size,", "         OMX_U8 *ptr) {", " ", "      Mutex::Autolock autoLock(mLock);", "      CHECK_LT(portIndex, mPorts.size());", "  ", "     PortInfo *port = &mPorts.editItemAt(portIndex);", "     if (size < port->mDef.nBufferSize) {", "         ALOGE(\"b/63522430, Buffer size is too small.\");", "         android_errorWriteLog(0x534e4554, \"63522430\");", "         return OMX_ErrorBadParameter;", "     }", " ", "      *header = new OMX_BUFFERHEADERTYPE;", "      (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);", "      (*header)->nVersion.s.nVersionMajor = 1;", "  (*header)->nVersion.s.nVersionMinor = 0;", "  (*header)->nVersion.s.nRevision = 0;", "  (*header)->nVersion.s.nStep = 0;", "  (*header)->pBuffer = ptr;", "  (*header)->nAllocLen = size;", "  (*header)->nFilledLen = 0;", "  (*header)->nOffset = 0;", "  (*header)->pAppPrivate = appPrivate;", "  (*header)->pPlatformPrivate = NULL;", "  (*header)->pInputPortPrivate = NULL;", "  (*header)->pOutputPortPrivate = NULL;", "  (*header)->hMarkTargetComponent = NULL;", "  (*header)->pMarkData = NULL;", "  (*header)->nTickCount = 0;", "  (*header)->nTimeStamp = 0;", "  (*header)->nFlags = 0;", " ", "      (*header)->nOutputPortIndex = portIndex;", "      (*header)->nInputPortIndex = portIndex;", "  ", "    PortInfo *port = &mPorts.editItemAt(portIndex);", "      CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);", "  ", "      CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);", " ", "     port->mBuffers.push();", " ", "  BufferInfo *buffer =", "  &port->mBuffers.editItemAt(port->mBuffers.size() - 1);", " ", "     buffer->mHeader = *header;", "     buffer->mOwnedByUs = false;", " ", "  if (port->mBuffers.size() == port->mDef.nBufferCountActual) {", "         port->mDef.bPopulated = OMX_TRUE;", "         checkTransitions();", "  }", " ", "  return OMX_ErrorNone;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long Track::GetNext(const BlockEntry* pCurrEntry,", "  const BlockEntry*& pNextEntry) const {", "   assert(pCurrEntry);", "   assert(!pCurrEntry->EOS());  ", " ", "  const Block* const pCurrBlock = pCurrEntry->GetBlock();", "   assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);", "  if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)", "  return -1;", " ", "  const Cluster* pCluster = pCurrEntry->GetCluster();", "   assert(pCluster);", "   assert(!pCluster->EOS());", " ", "  long status = pCluster->GetNext(pCurrEntry, pNextEntry);", " ", "  if (status < 0)  ", "  return status;", " ", "  for (int i = 0;;) {", "  while (pNextEntry) {", "  const Block* const pNextBlock = pNextEntry->GetBlock();", "       assert(pNextBlock);", " ", "  if (pNextBlock->GetTrackNumber() == m_info.number)", "  return 0;", " ", "       pCurrEntry = pNextEntry;", " ", "       status = pCluster->GetNext(pCurrEntry, pNextEntry);", " ", "  if (status < 0)  ", "  return status;", "  }", " ", "     pCluster = m_pSegment->GetNext(pCluster);", " ", "  if (pCluster == NULL) {", "       pNextEntry = GetEOS();", "  return 1;", " ", "      }", "  ", "      if (pCluster->EOS()) {", "#if 0", "            if (m_pSegment->Unparsed() <= 0)    ", "            {", "                pNextEntry = GetEOS();", "                return 1;", "            }", "#else", "        if (m_pSegment->DoneParsing()) {", "          pNextEntry = GetEOS();", "          return 1;", "        }", "#endif", "  ", " ", "       pNextEntry = NULL;", "  return E_BUFFER_NOT_FULL;", "  }", " ", "     status = pCluster->GetFirst(pNextEntry);", " ", "  if (status < 0)  ", "  return status;", " ", "  if (pNextEntry == NULL)  ", "  continue;", " ", "  ++i;", " ", "  if (i >= 100)", "  break;", "  }", " ", " ", "   pNextEntry = GetEOS();  ", "  return 1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int cipso_v4_sock_setattr(struct sock *sk,", " \t\t\t  const struct cipso_v4_doi *doi_def,", " \t\t\t  const struct netlbl_lsm_secattr *secattr)", " {", " \tint ret_val = -EPERM;", "  \tunsigned char *buf = NULL;", "  \tu32 buf_len;", "  \tu32 opt_len;", "\tstruct ip_options *opt = NULL;", " \tstruct ip_options_rcu *old, *opt = NULL;", "  \tstruct inet_sock *sk_inet;", "  \tstruct inet_connection_sock *sk_conn;", "  ", " \t ", " \tif (sk == NULL)", " \t\treturn 0;", " ", " \t ", " \tbuf_len = CIPSO_V4_OPT_LEN_MAX;", " \tbuf = kmalloc(buf_len, GFP_ATOMIC);", " \tif (buf == NULL) {", " \t\tret_val = -ENOMEM;", " \t\tgoto socket_setattr_failure;", " \t}", " ", " \tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);", " \tif (ret_val < 0)", " \t\tgoto socket_setattr_failure;", " \tbuf_len = ret_val;", " ", " \t ", " \topt_len = (buf_len + 3) & ~3;", " \topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);", " \tif (opt == NULL) {", "  \t\tret_val = -ENOMEM;", "  \t\tgoto socket_setattr_failure;", "  \t}", "\tmemcpy(opt->__data, buf, buf_len);", "\topt->optlen = opt_len;", "\topt->cipso = sizeof(struct iphdr);", " \tmemcpy(opt->opt.__data, buf, buf_len);", " \topt->opt.optlen = opt_len;", " \topt->opt.cipso = sizeof(struct iphdr);", "  \tkfree(buf);", "  \tbuf = NULL;", "  ", "  \tsk_inet = inet_sk(sk);", " ", " \told = rcu_dereference_protected(sk_inet->inet_opt, sock_owned_by_user(sk));", "  \tif (sk_inet->is_icsk) {", "  \t\tsk_conn = inet_csk(sk);", "\t\tif (sk_inet->opt)", "\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;", "\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;", " \t\tif (old)", " \t\t\tsk_conn->icsk_ext_hdr_len -= old->opt.optlen;", " \t\tsk_conn->icsk_ext_hdr_len += opt->opt.optlen;", "  \t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);", "  \t}", "\topt = xchg(&sk_inet->opt, opt);", "\tkfree(opt);", " \trcu_assign_pointer(sk_inet->inet_opt, opt);", " \tif (old)", " \t\tcall_rcu(&old->rcu, opt_kfree_rcu);", "  ", "  \treturn 0;", "  ", " socket_setattr_failure:", " \tkfree(buf);", " \tkfree(opt);", " \treturn ret_val;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)", " {", " \tstruct ucma_multicast *mc;", " ", " \tmc = kzalloc(sizeof(*mc), GFP_KERNEL);", " \tif (!mc)", "  \t\treturn NULL;", "  ", "  \tmutex_lock(&mut);", "\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);", " \tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);", "  \tmutex_unlock(&mut);", "  \tif (mc->id < 0)", "  \t\tgoto error;", " ", " \tmc->ctx = ctx;", " \tlist_add_tail(&mc->list, &ctx->mc_list);", " \treturn mc;", " ", " error:", " \tkfree(mc);", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,", " \t\t\t\t\t      struct sk_buff *skb,", " \t\t\t\t\t      struct request_sock *req,", " \t\t\t\t\t      struct dst_entry *dst,", " \t\t\t\t\t      struct request_sock *req_unhash,", " \t\t\t\t\t      bool *own_req)", " {", "  \tstruct inet_request_sock *ireq = inet_rsk(req);", "  \tstruct ipv6_pinfo *newnp;", "  \tconst struct ipv6_pinfo *np = inet6_sk(sk);", " \tstruct ipv6_txoptions *opt;", "  \tstruct inet_sock *newinet;", "  \tstruct dccp6_sock *newdp6;", "  \tstruct sock *newsk;", " ", " \tif (skb->protocol == htons(ETH_P_IP)) {", " \t\t ", " \t\tnewsk = dccp_v4_request_recv_sock(sk, skb, req, dst,", " \t\t\t\t\t\t  req_unhash, own_req);", " \t\tif (newsk == NULL)", " \t\t\treturn NULL;", " ", " \t\tnewdp6 = (struct dccp6_sock *)newsk;", " \t\tnewinet = inet_sk(newsk);", " \t\tnewinet->pinet6 = &newdp6->inet6;", " \t\tnewnp = inet6_sk(newsk);", " ", " \t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));", " ", " \t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;", " ", " \t\tinet_csk(newsk)->icsk_af_ops = &dccp_ipv6_mapped;", " \t\tnewsk->sk_backlog_rcv = dccp_v4_do_rcv;", " \t\tnewnp->pktoptions  = NULL;", " \t\tnewnp->opt\t   = NULL;", " \t\tnewnp->mcast_oif   = inet6_iif(skb);", " \t\tnewnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;", " ", " \t\t ", " ", " \t\t ", " \t\tdccp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);", " ", " \t\treturn newsk;", " \t}", " ", " ", " \tif (sk_acceptq_is_full(sk))", " \t\tgoto out_overflow;", " ", " \tif (!dst) {", " \t\tstruct flowi6 fl6;", " ", " \t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_DCCP);", " \t\tif (!dst)", " \t\t\tgoto out;", " \t}", " ", " \tnewsk = dccp_create_openreq_child(sk, req, skb);", " \tif (newsk == NULL)", " \t\tgoto out_nonewsk;", " ", " \t ", " ", " \t__ip6_dst_store(newsk, dst, NULL, NULL);", " \tnewsk->sk_route_caps = dst->dev->features & ~(NETIF_F_IP_CSUM |", " \t\t\t\t\t\t      NETIF_F_TSO);", " \tnewdp6 = (struct dccp6_sock *)newsk;", " \tnewinet = inet_sk(newsk);", " \tnewinet->pinet6 = &newdp6->inet6;", " \tnewnp = inet6_sk(newsk);", " ", " \tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));", " ", " \tnewsk->sk_v6_daddr\t= ireq->ir_v6_rmt_addr;", " \tnewnp->saddr\t\t= ireq->ir_v6_loc_addr;", " \tnewsk->sk_v6_rcv_saddr\t= ireq->ir_v6_loc_addr;", " \tnewsk->sk_bound_dev_if\t= ireq->ir_iif;", " ", " \t ", " \tnewinet->inet_opt = NULL;", " ", " \t ", " \tnewnp->rxopt.all = np->rxopt.all;", " ", " \tnewnp->pktoptions = NULL;", " \tnewnp->opt\t  = NULL;", " \tnewnp->mcast_oif  = inet6_iif(skb);", " \tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;", " ", " \t ", "\tif (np->opt != NULL)", "\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);", " \topt = rcu_dereference(np->opt);", " \tif (opt) {", " \t\topt = ipv6_dup_options(newsk, opt);", " \t\tRCU_INIT_POINTER(newnp->opt, opt);", " \t}", "  \tinet_csk(newsk)->icsk_ext_hdr_len = 0;", "\tif (newnp->opt != NULL)", "\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +", "\t\t\t\t\t\t     newnp->opt->opt_flen);", " \tif (opt)", " \t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +", " \t\t\t\t\t\t    opt->opt_flen;", "  ", "  \tdccp_sync_mss(newsk, dst_mtu(dst));", "  ", " \tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;", " \tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;", " ", " \tif (__inet_inherit_port(sk, newsk) < 0) {", " \t\tinet_csk_prepare_forced_close(newsk);", " \t\tdccp_done(newsk);", " \t\tgoto out;", " \t}", " \t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));", " \t ", " \tif (*own_req && ireq->pktopts) {", " \t\tnewnp->pktoptions = skb_clone(ireq->pktopts, GFP_ATOMIC);", " \t\tconsume_skb(ireq->pktopts);", " \t\tireq->pktopts = NULL;", " \t\tif (newnp->pktoptions)", " \t\t\tskb_set_owner_r(newnp->pktoptions, newsk);", " \t}", " ", " \treturn newsk;", " ", " out_overflow:", " \tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);", " out_nonewsk:", " \tdst_release(dst);", " out:", " \tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   bool ChangeInputMethodViaIBus(const std::string& input_method_id) {", "     if (!initialized_successfully_)", "       return false;", " ", "     std::string input_method_id_to_switch = input_method_id;", " ", "     if (!InputMethodIsActivated(input_method_id)) {", "      scoped_ptr<InputMethodDescriptors> input_methods(GetActiveInputMethods());", "       scoped_ptr<input_method::InputMethodDescriptors> input_methods(", "           GetActiveInputMethods());", "        DCHECK(!input_methods->empty());", "        if (!input_methods->empty()) {", "          input_method_id_to_switch = input_methods->at(0).id;", "         LOG(INFO) << \"Can't change the current input method to \"", "                   << input_method_id << \" since the engine is not preloaded. \"", "                   << \"Switch to \" << input_method_id_to_switch << \" instead.\";", "        }", "      }", "  ", "    if (chromeos::ChangeInputMethod(input_method_status_connection_,", "                                    input_method_id_to_switch.c_str())) {", "     if (ibus_controller_->ChangeInputMethod(input_method_id_to_switch)) {", "        return true;", "      }", "  ", "     LOG(ERROR) << \"Can't switch input method to \" << input_method_id_to_switch;", "     return false;", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PassRefPtr<DocumentFragment> createFragmentFromSource(const String& markup, Element* contextElement, ExceptionCode& ec)", " PassRefPtr<DocumentFragment> createFragmentForInnerOuterHTML(const String& markup, Element* contextElement, ExceptionCode& ec)", "  {", "      Document* document = contextElement->document();", "      RefPtr<DocumentFragment> fragment = DocumentFragment::create(document);", " ", "     if (document->isHTMLDocument()) {", "         fragment->parseHTML(markup, contextElement);", "         return fragment;", "     }", " ", "     bool wasValid = fragment->parseXML(markup, contextElement);", "     if (!wasValid) {", "         ec = INVALID_STATE_ERR;", "         return 0;", "     }", "      return fragment.release();", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void PlatformSensorProviderMac::CreateSensorInternal(", "      mojom::SensorType type,", "    mojo::ScopedSharedBufferMapping mapping,", "     SensorReadingSharedBuffer* reading_buffer,", "      const CreateSensorCallback& callback) {", "    switch (type) {", "      case mojom::SensorType::AMBIENT_LIGHT: {", "        scoped_refptr<PlatformSensor> sensor =", "          new PlatformSensorAmbientLightMac(std::move(mapping), this);", "           new PlatformSensorAmbientLightMac(reading_buffer, this);", "        callback.Run(std::move(sensor));", "        break;", "      }", "      case mojom::SensorType::ACCELEROMETER: {", "        callback.Run(base::MakeRefCounted<PlatformSensorAccelerometerMac>(", "          std::move(mapping), this));", "           reading_buffer, this));", "        break;", "      }", "      case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES: {", "        auto fusion_algorithm = std::make_unique<", "            RelativeOrientationEulerAnglesFusionAlgorithmUsingAccelerometer>();", "      PlatformSensorFusion::Create(std::move(mapping), this,", "       PlatformSensorFusion::Create(reading_buffer, this,", "                                     std::move(fusion_algorithm), callback);", "        break;", "      }", "     case mojom::SensorType::RELATIVE_ORIENTATION_QUATERNION: {", "       auto orientation_quaternion_fusion_algorithm_using_euler_angles =", "           std::make_unique<", "               OrientationQuaternionFusionAlgorithmUsingEulerAngles>(", "               false  );", "        PlatformSensorFusion::Create(", "          std::move(mapping), this,", "           reading_buffer, this,", "            std::move(orientation_quaternion_fusion_algorithm_using_euler_angles),", "            callback);", "        break;", "     }", "     default:", "       callback.Run(nullptr);", "   }", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void listdir(unsigned int depth, int f, void * const tls_fd,", "const char *name)", "{", "PureFileInfo *dir;", "char *names;", "PureFileInfo *s;", "PureFileInfo *r;", "int d;", "", "if (depth >= max_ls_depth || matches >= max_ls_files) {", "return;", "}", "if ((dir = sreaddir(&names)) == NULL) {", "addreply(226, MSG_CANT_READ_FILE, name);", "return;", "}", "s = dir;", "while (s->name_offset != (size_t) -1) {", "d = 0;", "if (FI_NAME(s)[0] != '.') {", "d = listfile(s, NULL);", "} else if (opt_a) {", "if (FI_NAME(s)[1] == 0 ||", "(FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {", "listfile(s, NULL);", "} else {", "d = listfile(s, NULL);", "}", "}", "if (!d) {", "s->name_offset = (size_t) -1;", "}", "s++;", "}", "outputfiles(f, tls_fd);", "r = dir;", "while (opt_R && r != s) {", "if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {", "char *alloca_subdir;", "const size_t sizeof_subdir = PATH_MAX + 1U;", "", "if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {", "goto toomany;", "}", "if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",", "name, FI_NAME(r)), sizeof_subdir)) {", "goto nolist;", "}", "wrstr(f, tls_fd, \"\\r\\n\\r\\n\");", "wrstr(f, tls_fd, alloca_subdir);", "wrstr(f, tls_fd, \":\\r\\n\\r\\n\");", "listdir(depth + 1U, f, tls_fd, alloca_subdir);", "nolist:", "ALLOCA_FREE(alloca_subdir);", "if (matches >= max_ls_files) {", "goto toomany;", "}", "if (chdir(\"..\")) {", "if (chdir(wd) || chdir(name)) {", "die(421, LOG_ERR, \"chdir: %s\", strerror(errno));", "}", "}", "}", "r++;", "}", "toomany:", "free(names);", "free(dir);", "names = NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["  PHP_FUNCTION(radius_get_vendor_attr)", "  {", "\tint res;", "\tconst void *data;", " \tconst void *data, *raw;", "  \tint len;", "  \tu_int32_t vendor;", " \tunsigned char type;", " \tsize_t data_len;", "  ", "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &raw, &len) == FAILURE) {", "  \t\treturn;", "  \t}", "  ", "\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);", "\tif (res == -1) {", " \tif (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {", "  \t\tRETURN_FALSE;", "  \t} else {", "  ", "  \t\tarray_init(return_value);", "\t\tadd_assoc_long(return_value, \"attr\", res);", " \t\tadd_assoc_long(return_value, \"attr\", type);", "  \t\tadd_assoc_long(return_value, \"vendor\", vendor);", "\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);", " \t\tadd_assoc_stringl(return_value, \"data\", (char *) data, data_len, 1);", "  \t\treturn;", "  \t}", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0]}
{"tokens": [" static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image,", "   const size_t data_size)", " {", " #define MaxCode(number_bits)  ((one << (number_bits))-1)", " #define MaxHashTable  5003", " #define MaxGIFBits  12UL", " #define MaxGIFTable  (1UL << MaxGIFBits)", " #define GIFOutputCode(code) \\", " { \\", "     \\", "   if (bits > 0) \\", "     datum|=(size_t) (code) << bits; \\", "   else \\", "     datum=(size_t) (code); \\", "   bits+=number_bits; \\", "   while (bits >= 8) \\", "   { \\", "       \\", "     packet[length++]=(unsigned char) (datum & 0xff); \\", "     if (length >= 254) \\", "       { \\", "         (void) WriteBlobByte(image,(unsigned char) length); \\", "         (void) WriteBlob(image,length,packet); \\", "         length=0; \\", "       } \\", "     datum>>=8; \\", "     bits-=8; \\", "   } \\", "   if (free_code > max_code)  \\", "     { \\", "       number_bits++; \\", "       if (number_bits == MaxGIFBits) \\", "         max_code=MaxGIFTable; \\", "       else \\", "         max_code=MaxCode(number_bits); \\", "     } \\", " }", " ", "   IndexPacket", "     index;", " ", "   short", "     *hash_code,", "     *hash_prefix,", "     waiting_code;", " ", "   size_t", "     bits,", "     clear_code,", "     datum,", "     end_of_information_code,", "     free_code,", "     length,", "     max_code,", "     next_pixel,", "     number_bits,", "     one,", "     pass;", " ", "   ssize_t", "     displacement,", "     offset,", "     k,", "     y;", " ", "   unsigned char", "     *packet,", "     *hash_suffix;", " ", "    ", "   assert(image != (Image *) NULL);", "   one=1;", "   packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet));", "   hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code));", "   hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix));", "   hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable,", "     sizeof(*hash_suffix));", "   if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) ||", "       (hash_prefix == (short *) NULL) ||", "       (hash_suffix == (unsigned char *) NULL))", "     {", "       if (packet != (unsigned char *) NULL)", "         packet=(unsigned char *) RelinquishMagickMemory(packet);", "       if (hash_code != (short *) NULL)", "         hash_code=(short *) RelinquishMagickMemory(hash_code);", "       if (hash_prefix != (short *) NULL)", "         hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);", "       if (hash_suffix != (unsigned char *) NULL)", "         hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);", "       return(MagickFalse);", "     }", "    ", "   (void) memset(packet,0,256*sizeof(*packet));", "   (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code));", "   (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix));", "   (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix));", "   number_bits=data_size;", "   max_code=MaxCode(number_bits);", "   clear_code=((short) one << (data_size-1));", "   end_of_information_code=clear_code+1;", "   free_code=clear_code+2;", "   length=0;", "   datum=0;", "   bits=0;", "   GIFOutputCode(clear_code);", "    ", "   offset=0;", "   pass=0;", "   waiting_code=0;", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     register const IndexPacket", "       *magick_restrict indexes;", " ", "     register const PixelPacket", "       *magick_restrict p;", " ", "     register ssize_t", "       x;", " ", "     p=GetVirtualPixels(image,0,offset,image->columns,1,&image->exception);", "     if (p == (const PixelPacket *) NULL)", "       break;", "     indexes=GetVirtualIndexQueue(image);", "     if (y == 0)", "       {", "         waiting_code=(short) (*indexes);", "         p++;", "       }", "     for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++)", "     {", "         ", "       next_pixel=MagickFalse;", "       displacement=1;", "        index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff);", "        p++;", "        k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code);", "        if (k >= MaxHashTable)", "          k-=MaxHashTable;", "      next_pixel=MagickFalse;", "      displacement=1;", "       if (k < 0)", "         continue;", "        if (hash_code[k] > 0)", "          {", "            if ((hash_prefix[k] == waiting_code) &&", "               (hash_suffix[k] == (unsigned char) index))", "             {", "               waiting_code=hash_code[k];", "               continue;", "             }", "           if (k != 0)", "             displacement=MaxHashTable-k;", "           for ( ; ; )", "           {", "             k-=displacement;", "             if (k < 0)", "               k+=MaxHashTable;", "             if (hash_code[k] == 0)", "               break;", "             if ((hash_prefix[k] == waiting_code) &&", "                 (hash_suffix[k] == (unsigned char) index))", "               {", "                 waiting_code=hash_code[k];", "                 next_pixel=MagickTrue;", "                 break;", "               }", "           }", "           if (next_pixel != MagickFalse)", "             continue;", "         }", "       GIFOutputCode(waiting_code);", "       if (free_code < MaxGIFTable)", "         {", "           hash_code[k]=(short) free_code++;", "           hash_prefix[k]=waiting_code;", "           hash_suffix[k]=(unsigned char) index;", "         }", "       else", "         {", "            ", "           for (k=0; k < MaxHashTable; k++)", "             hash_code[k]=0;", "            ", "           free_code=clear_code+2;", "           GIFOutputCode(clear_code);", "           number_bits=data_size;", "           max_code=MaxCode(number_bits);", "         }", "       waiting_code=(short) index;", "     }", "     if (image_info->interlace == NoInterlace)", "       offset++;", "     else", "       switch (pass)", "       {", "         case 0:", "         default:", "         {", "           offset+=8;", "           if (offset >= (ssize_t) image->rows)", "             {", "               pass++;", "               offset=4;", "             }", "           break;", "         }", "         case 1:", "         {", "           offset+=8;", "           if (offset >= (ssize_t) image->rows)", "             {", "               pass++;", "               offset=2;", "             }", "           break;", "         }", "         case 2:", "         {", "           offset+=4;", "           if (offset >= (ssize_t) image->rows)", "             {", "               pass++;", "               offset=1;", "             }", "           break;", "         }", "         case 3:", "         {", "           offset+=2;", "           break;", "         }", "       }", "   }", "    ", "   GIFOutputCode(waiting_code);", "   GIFOutputCode(end_of_information_code);", "   if (bits > 0)", "     {", "        ", "       packet[length++]=(unsigned char) (datum & 0xff);", "       if (length >= 254)", "         {", "           (void) WriteBlobByte(image,(unsigned char) length);", "           (void) WriteBlob(image,length,packet);", "           length=0;", "         }", "     }", "    ", "   if (length > 0)", "     {", "       (void) WriteBlobByte(image,(unsigned char) length);", "       (void) WriteBlob(image,length,packet);", "     }", "    ", "   hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix);", "   hash_prefix=(short *) RelinquishMagickMemory(hash_prefix);", "   hash_code=(short *) RelinquishMagickMemory(hash_code);", "   packet=(unsigned char *) RelinquishMagickMemory(packet);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)", " {", " \t ", "  \tu64 nsec = (u64)jiffies * TICK_NSEC;", "\tlong rem;", "\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);", " \tu32 rem;", " \tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);", "  \tvalue->tv_usec = rem / NSEC_PER_USEC;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", " #define RMT_EQUAL_RGB  1", " #define RMT_NONE  0", " #define RMT_RAW  2", " #define RT_STANDARD  1", " #define RT_ENCODED  2", " #define RT_FORMAT_RGB  3", " ", "   typedef struct _SUNInfo", "   {", "     unsigned int", "       magic,", "       width,", "       height,", "       depth,", "       length,", "       type,", "       maptype,", "       maplength;", "   } SUNInfo;", " ", "   Image", "     *image;", " ", "   int", "     bit;", " ", "   MagickBooleanType", "     status;", " ", "   MagickSizeType", "     number_pixels;", " ", "   register Quantum", "     *q;", " ", "   register ssize_t", "     i,", "     x;", " ", "   register unsigned char", "     *p;", " ", "    size_t", "      bytes_per_line,", "      extent,", "    height,", "    length;", "     height;", "  ", "    ssize_t", "      count,", "     y;", " ", "   SUNInfo", "     sun_info;", " ", "   unsigned char", "     *sun_data,", "     *sun_pixels;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));", "   sun_info.magic=ReadBlobMSBLong(image);", "   do", "   {", "      ", "     if (sun_info.magic != 0x59a66a95)", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     sun_info.width=ReadBlobMSBLong(image);", "     sun_info.height=ReadBlobMSBLong(image);", "     sun_info.depth=ReadBlobMSBLong(image);", "     sun_info.length=ReadBlobMSBLong(image);", "     sun_info.type=ReadBlobMSBLong(image);", "     sun_info.maptype=ReadBlobMSBLong(image);", "     sun_info.maplength=ReadBlobMSBLong(image);", "     extent=sun_info.height*sun_info.width;", "     if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&", "         (sun_info.type != RT_FORMAT_RGB))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if ((sun_info.depth == 0) || (sun_info.depth > 32))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&", "         (sun_info.maptype != RMT_RAW))", "       ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");", "     image->columns=sun_info.width;", "     image->rows=sun_info.height;", "     image->depth=sun_info.depth <= 8 ? sun_info.depth :", "       MAGICKCORE_QUANTUM_DEPTH;", "     if (sun_info.depth < 24)", "       {", "         size_t", "           one;", " ", "         image->colors=sun_info.maplength;", "         one=1;", "         if (sun_info.maptype == RMT_NONE)", "           image->colors=one << sun_info.depth;", "         if (sun_info.maptype == RMT_EQUAL_RGB)", "           image->colors=sun_info.maplength/3;", "         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       }", "     switch (sun_info.maptype)", "     {", "       case RMT_NONE:", "         break;", "       case RMT_EQUAL_RGB:", "       {", "         unsigned char", "           *sun_colormap;", " ", "          ", "         sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,", "           sizeof(*sun_colormap));", "         if (sun_colormap == (unsigned char *) NULL)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         count=ReadBlob(image,image->colors,sun_colormap);", "         if (count != (ssize_t) image->colors)", "           ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "         for (i=0; i < (ssize_t) image->colors; i++)", "           image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(", "             sun_colormap[i]);", "         count=ReadBlob(image,image->colors,sun_colormap);", "         if (count != (ssize_t) image->colors)", "           ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "         for (i=0; i < (ssize_t) image->colors; i++)", "           image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(", "             sun_colormap[i]);", "         count=ReadBlob(image,image->colors,sun_colormap);", "         if (count != (ssize_t) image->colors)", "           ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "         for (i=0; i < (ssize_t) image->colors; i++)", "           image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(", "             sun_colormap[i]);", "         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);", "         break;", "       }", "       case RMT_RAW:", "       {", "         unsigned char", "           *sun_colormap;", " ", "          ", "         sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,", "           sizeof(*sun_colormap));", "         if (sun_colormap == (unsigned char *) NULL)", "           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "         count=ReadBlob(image,sun_info.maplength,sun_colormap);", "         if (count != (ssize_t) sun_info.maplength)", "           ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");", "         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);", "         break;", "       }", "       default:", "         ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");", "     }", "     image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :", "       UndefinedPixelTrait;", "     image->columns=sun_info.width;", "     image->rows=sun_info.height;", "     if (image_info->ping != MagickFalse)", "       {", "         (void) CloseBlob(image);", "         return(GetFirstImageInList(image));", "       }", "     status=SetImageExtent(image,image->columns,image->rows,exception);", "     if (status == MagickFalse)", "       return(DestroyImageList(image));", "     if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) !=", "         sun_info.length || !sun_info.length)", "       ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");", "     number_pixels=(MagickSizeType) image->columns*image->rows;", "     if ((sun_info.type != RT_ENCODED) && ", "         ((number_pixels*sun_info.depth) > (8*sun_info.length)))", "       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "     bytes_per_line=sun_info.width*sun_info.depth;", "     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(", "       sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data));", "     if (sun_data == (unsigned char *) NULL)", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);", "     if (count != (ssize_t) sun_info.length)", "       ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "     height=sun_info.height;", "     if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||", "         ((bytes_per_line/sun_info.depth) != sun_info.width))", "       ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");", "     bytes_per_line+=15;", "     bytes_per_line<<=1;", "     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))", "       ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");", "     bytes_per_line>>=4;", "     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,", "       bytes_per_line*sizeof(*sun_pixels));", "     if (sun_pixels == (unsigned char *) NULL)", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     if (sun_info.type == RT_ENCODED)", "       (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*", "         height);", "     else", "       {", "         if (sun_info.length > (height*bytes_per_line))", "           ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");", "         (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);", "       }", "     sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);", "      ", "     p=sun_pixels;", "     if (sun_info.depth == 1)", "       for (y=0; y < (ssize_t) image->rows; y++)", "       {", "         q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "         if (q == (Quantum *) NULL)", "           break;", "         for (x=0; x < ((ssize_t) image->columns-7); x+=8)", "         {", "           for (bit=7; bit >= 0; bit--)", "           {", "             SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),", "               q);", "             q+=GetPixelChannels(image);", "           }", "           p++;", "         }", "         if ((image->columns % 8) != 0)", "           {", "             for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)", "             {", "               SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :", "                 0x01),q);", "               q+=GetPixelChannels(image);", "             }", "             p++;", "           }", "         if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)", "           p++;", "         if (SyncAuthenticPixels(image,exception) == MagickFalse)", "           break;", "         if (image->previous == (Image *) NULL)", "           {", "             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "               image->rows);", "             if (status == MagickFalse)", "               break;", "           }", "       }", "      else", "        if (image->storage_class == PseudoClass)", "          {", "          if (bytes_per_line == 0)", "            bytes_per_line=image->columns;", "          length=image->rows*(image->columns+image->columns % 2);", "          if (((sun_info.type == RT_ENCODED) &&", "               (length > (bytes_per_line*image->rows))) ||", "              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))", "            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "            for (y=0; y < (ssize_t) image->rows; y++)", "            {", "              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               SetPixelIndex(image,*p++,q);", "               q+=GetPixelChannels(image);", "             }", "             if ((image->columns % 2) != 0)", "               p++;", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         }", "       else", "         {", "           size_t", "             bytes_per_pixel;", " ", "           bytes_per_pixel=3;", "           if (image->alpha_trait != UndefinedPixelTrait)", "              bytes_per_pixel++;", "            if (bytes_per_line == 0)", "              bytes_per_line=bytes_per_pixel*image->columns;", "          length=image->rows*(bytes_per_line+bytes_per_line % 2);", "          if (((sun_info.type == RT_ENCODED) &&", "               (length > (bytes_per_line*image->rows))) ||", "              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))", "            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");", "            for (y=0; y < (ssize_t) image->rows; y++)", "            {", "              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "             if (q == (Quantum *) NULL)", "               break;", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               if (image->alpha_trait != UndefinedPixelTrait)", "                 SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);", "               if (sun_info.type == RT_STANDARD)", "                 {", "                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);", "                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);", "                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);", "                 }", "               else", "                 {", "                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);", "                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);", "                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);", "                 }", "               if (image->colors != 0)", "                 {", "                   SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)", "                     GetPixelRed(image,q)].red),q);", "                   SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)", "                     GetPixelGreen(image,q)].green),q);", "                   SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)", "                     GetPixelBlue(image,q)].blue),q);", "                 }", "               q+=GetPixelChannels(image);", "             }", "             if (((bytes_per_pixel*image->columns) % 2) != 0)", "               p++;", "             if (SyncAuthenticPixels(image,exception) == MagickFalse)", "               break;", "             if (image->previous == (Image *) NULL)", "               {", "                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "                 image->rows);", "                 if (status == MagickFalse)", "                   break;", "               }", "           }", "         }", "     if (image->storage_class == PseudoClass)", "       (void) SyncImage(image,exception);", "     sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);", "     if (EOFBlob(image) != MagickFalse)", "       {", "         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "           image->filename);", "         break;", "       }", "      ", "     if (image_info->number_scenes != 0)", "       if (image->scene >= (image_info->scene+image_info->number_scenes-1))", "         break;", "     sun_info.magic=ReadBlobMSBLong(image);", "     if (sun_info.magic == 0x59a66a95)", "       {", "          ", "         AcquireNextImage(image_info,image,exception);", "         if (GetNextImageInList(image) == (Image *) NULL)", "           {", "             image=DestroyImageList(image);", "             return((Image *) NULL);", "           }", "         image=SyncNextImageInList(image);", "         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),", "           GetBlobSize(image));", "         if (status == MagickFalse)", "           break;", "       }", "   } while (sun_info.magic == 0x59a66a95);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {", "   assert(data != NULL);", "   assert(length > 0);", " ", "  ", "    uint16_t transmitted_length = 0;", "    while (length > 0) {", "    ssize_t ret = write(fd, data + transmitted_length, length);", "     ssize_t ret = TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));", "      switch (ret) {", "        case -1:", "          LOG_ERROR(\"In %s, error writing to the serial port with fd %d: %s\", __func__, fd, strerror(errno));", "  return transmitted_length;", "  case 0:", "  return transmitted_length;", "  default:", "         transmitted_length += ret;", "         length -= ret;", "  break;", "  }", "  }", " ", "  return transmitted_length;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" parse_wbxml_attribute_list (proto_tree *tree, tvbuff_t *tvb,", "  \t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr)", "  {", "  \tguint32 tvb_len = tvb_reported_length (tvb);", "\tguint32 off     = offset;", " \tguint32 off     = offset, last_off;", "  \tguint32 len;", "  \tguint   str_len;", "  \tguint32 ent;", " \tguint32 idx;", " \tguint8  peek;", "  ", "  \tDebugLog((\"parse_wbxml_attr (level = %u, offset = %u)\\n\", level, offset));", "  \t ", " \tlast_off = off;", "  \twhile (off < tvb_len) {", "  \t\tpeek = tvb_get_guint8 (tvb, off);", "  \t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"", " \t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));", " \t\tif ((peek & 0x3F) < 5) switch (peek) {  ", " \t\tcase 0x00:  ", " \t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);", " \t\t\tproto_tree_add_text (tree, tvb, off, 2,", " \t\t\t\t\t     \"      |  Attr | A -->%3d \"", " \t\t\t\t\t     \"| SWITCH_PAGE (Attr code page)    |\",", " \t\t\t\t\t     *codepage_attr);", " \t\t\toff += 2;", " \t\t\tbreak;", " \t\tcase 0x01:  ", " \t\t\t ", " \t\t\toff++;", " \t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",", " \t\t\t\t  level, off - offset));", " \t\t\treturn (off - offset);", " \t\tcase 0x02:  ", " \t\t\tent = tvb_get_guintvar (tvb, off+1, &len);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| ENTITY                          \"", " \t\t\t\t\t     \"|     %s'&#%u;'\",", " \t\t\t\t\t     level, *codepage_attr, Indent (level), ent);", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\tcase 0x03:  ", " \t\t\tlen = tvb_strsize (tvb, off+1);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| STR_I (Inline string)           \"", " \t\t\t\t\t     \"|     %s\\'%s\\'\",", " \t\t\t\t\t     level, *codepage_attr, Indent (level),", " \t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\tcase 0x04:  ", " \t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);", " \t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| LITERAL (Literal Attribute)     \"", " \t\t\t\t\t     \"|   %s<%s />\",", " \t\t\t\t\t     level, *codepage_attr, Indent (level),", " \t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\tcase 0x40:  ", " \t\tcase 0x41:  ", " \t\tcase 0x42:  ", " \t\t\t ", " \t\t\tlen = tvb_strsize (tvb, off+1);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| EXT_I_%1x    (Extension Token)    \"", " \t\t\t\t\t     \"|     %s(Inline string extension: \\'%s\\')\",", " \t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),", " \t\t\t\t\t     tvb_format_text (tvb, off+1, len-1));", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\t\t ", " \t\t\t ", " \t\tcase 0x80:  ", " \t\tcase 0x81:  ", " \t\tcase 0x82:  ", " \t\t\t ", " \t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| EXT_T_%1x    (Extension Token)    \"", " \t\t\t\t\t     \"|     %s(Extension Token, integer value: %u)\",", " \t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),", " \t\t\t\t\t     idx);", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\tcase 0x83:  ", " \t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);", " \t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);", " \t\t\tproto_tree_add_text (tree, tvb, off, 1+len,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| STR_T (Tableref string)         \"", " \t\t\t\t\t     \"|     %s\\'%s\\'\",", " \t\t\t\t\t     level, *codepage_attr, Indent (level),", " \t\t\t\t\t     tvb_format_text (tvb, str_tbl+idx, str_len-1));", " \t\t\toff += 1+len;", " \t\t\tbreak;", " \t\t\t ", " \t\tcase 0xC0:  ", " \t\tcase 0xC1:  ", " \t\tcase 0xC2:  ", " \t\t\t ", " \t\t\tproto_tree_add_text (tree, tvb, off, 1,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| EXT_%1x      (Extension Token)    \"", " \t\t\t\t\t     \"|     %s(Single-byte extension)\",", " \t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level));", " \t\t\toff++;", " \t\t\tbreak;", " \t\tcase 0xC3:  ", " \t\t\tif (tvb_get_guint8 (tvb, 0)) {  ", " \t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len);", " \t\t\t\tproto_tree_add_text (tree, tvb, off, 1 + len + idx,", " \t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t\t     \"| OPAQUE (Opaque data)            \"", " \t\t\t\t\t\t     \"|       %s(%d bytes of opaque data)\",", " \t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);", " \t\t\t\toff += 1+len+idx;", " \t\t\t} else {  ", " \t\t\t\tproto_tree_add_text (tree, tvb, off, 1,", " \t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t\t     \"| RESERVED_2     (Invalid Token!) \"", " \t\t\t\t\t\t     \"| WBXML 1.0 parsing stops here.\",", " \t\t\t\t\t\t     level, *codepage_attr);", " \t\t\t\t ", " \t\t\t\toff = tvb_len;", " \t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",", " \t\t\t\t\t  level, off - offset));", " \t\t\t\treturn (off - offset);", " \t\t\t}", " \t\t\tbreak;", " \t\t\t ", " \t\tdefault:", " \t\t\tproto_tree_add_text (tree, tvb, off, 1,", " \t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t     \"| %-10s     (Invalid Token!) \"", " \t\t\t\t\t     \"| WBXML parsing stops here.\",", " \t\t\t\t\t     level, *codepage_attr,", " \t\t\t\t\t     val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));", " \t\t\t ", " \t\t\toff = tvb_len;", " \t\t\tbreak;", " \t\t} else {  ", " \t\t\tif (peek & 0x80) {  ", " \t\t\t\tproto_tree_add_text (tree, tvb, off, 1,", " \t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t\t     \"|   Known attrValue 0x%02X          \"", " \t\t\t\t\t\t     \"|       %sattrValue_0x%02X\",", " \t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),", " \t\t\t\t\t\t     peek);", " \t\t\t\toff++;", " \t\t\t} else {  ", " \t\t\t\tproto_tree_add_text (tree, tvb, off, 1,", " \t\t\t\t\t\t     \"  %3d |  Attr | A %3d    \"", " \t\t\t\t\t\t     \"|   Known attrStart 0x%02X          \"", " \t\t\t\t\t\t     \"|   %sattrStart_0x%02X\",", " \t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),", " \t\t\t\t\t\t     peek);", "  \t\t\t\toff++;", "  \t\t\t}", "  \t\t}", " \t\tif (off < last_off) {", " \t\t\tTHROW(ReportedBoundsError);", " \t\t}", " \t\tlast_off = off;", "  \t}  ", "  \tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",", "  \t\t  level, off - offset));", " \treturn (off - offset);", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  main(void)", "  {", "  unsigned int i;", "  unsigned char buf[MAX_LENGTH];", "  unsigned long crc;", "  unsigned char c;", "  int inchar;", " ", " ", "   ", "     for (i=8; i; i--)", "     {", "      c=GETBREAK;", "       GETBREAK;", "        putchar(c);", "     }", "  ", "if (inchar != EOF)", " if (inchar == c)  ", "  for (;;)", "   {", "      ", "     unsigned long length;  ", "   c=GETBREAK; buf[0] = c; length  = c; length <<= 8;", "   c=GETBREAK; buf[1] = c; length += c; length <<= 8;", "   c=GETBREAK; buf[2] = c; length += c; length <<= 8;", "   c=GETBREAK; buf[3] = c; length += c;", "    GETBREAK; buf[0] = c; length  = c; length <<= 8;", "    GETBREAK; buf[1] = c; length += c; length <<= 8;", "    GETBREAK; buf[2] = c; length += c; length <<= 8;", "    GETBREAK; buf[3] = c; length += c;", "  ", "      ", "   c=GETBREAK; buf[4] = c;", "   c=GETBREAK; buf[5] = c;", "   c=GETBREAK; buf[6] = c;", "   c=GETBREAK; buf[7] = c;", "    GETBREAK; buf[4] = c;", "    GETBREAK; buf[5] = c;", "    GETBREAK; buf[6] = c;", "    GETBREAK; buf[7] = c;", "  ", "  ", "      ", "  if (buf[4] == 105 && buf[5] == 84 && buf[6] == 88 && buf[7] == 116)", "  {", "  if (length >= MAX_LENGTH-12)", "  break;  ", " ", "   ", "       crc = crc32(0, Z_NULL, 0);", " ", " ", "         ", "        for (i=8; i < length + 12; i++)", "        {", "         c=GETBREAK; buf[i] = c;", "          GETBREAK; buf[i] = c;", "        }", "  ", "       if (inchar != c)  ", "          break;", " ", "         ", "        crc = crc32(crc, buf+4, (uInt)length+4);", "  ", "        for (;;)", "        {", "           ", "        if (((crc >> 24) & 0xff) == buf[length+8] &&", "            ((crc >> 16) & 0xff) == buf[length+9] &&", "            ((crc >>  8) & 0xff) == buf[length+10] &&", "            ((crc      ) & 0xff) == buf[length+11])", "         if (((crc >> 24) & 0xffU) == buf[length+8] &&", "             ((crc >> 16) & 0xffU) == buf[length+9] &&", "             ((crc >>  8) & 0xffU) == buf[length+10] &&", "             ((crc      ) & 0xffU) == buf[length+11])", "             break;", "  ", "          length++;", " ", " ", "          if (length >= MAX_LENGTH-12)", "             break;", "  ", "        c=GETBREAK;", "        buf[length+11]=c;", "         GETBREAK;", "         buf[length+11] = c;", "  ", "           ", "          crc = crc32(crc, buf+7+length, 1);", "        }", "  ", "       if (inchar != c)  ", "          break;", " ", "         ", "      buf[0] = (unsigned char)((length << 24) & 0xff);", "      buf[1] = (unsigned char)((length << 16) & 0xff);", "      buf[2] = (unsigned char)((length <<  8) & 0xff);", "      buf[3] = (unsigned char)((length      ) & 0xff);", "       buf[0] = (unsigned char)((length >> 24) & 0xffU);", "       buf[1] = (unsigned char)((length >> 16) & 0xffU);", "       buf[2] = (unsigned char)((length >>  8) & 0xffU);", "       buf[3] = (unsigned char)((length      ) & 0xffU);", "  ", "         ", "        for (i=0; i<length+12; i++)", "          putchar(buf[i]);", "  }", " ", "  ", "     else", "     {", "       if (inchar != c)  ", "          break;", " ", "         ", "        for (i=0; i<8; i++)", "           putchar(buf[i]);", " ", " ", "         ", "        for (i=8; i< length+12; i++)", "        {", "         c=GETBREAK;", "          GETBREAK;", "           putchar(c);", "        }", "  ", "      if (inchar == EOF)", "       if (inchar != c)  ", "        {", "           break;", "        }", " ", "   ", "  if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)", " ", "           break;", "     }", "  ", "   if (inchar == EOF)", "    if (inchar != c)  ", "        break;", "  ", "     if (buf[4] == 73 && buf[5] == 69 && buf[6] == 78 && buf[7] == 68)", "  break;", "  }", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  WorkerProcessLauncherTest::WorkerProcessLauncherTest()", "    : message_loop_(MessageLoop::TYPE_IO) {", "     : message_loop_(MessageLoop::TYPE_IO),", "       client_pid_(GetCurrentProcessId()),", "       permanent_error_(false) {", "  }"], "ner_tags": [0, 1, 1, 1, 1, 0]}
{"tokens": [" print_lcp_config_options(netdissect_options *ndo,", "                          const u_char *p, int length)", " {", " \tint len, opt;", " ", " \tif (length < 2)", " \t\treturn 0;", " \tND_TCHECK2(*p, 2);", " \tlen = p[1];", " \topt = p[0];", " \tif (length < len)", " \t\treturn 0;", " \tif (len < 2) {", " \t\tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))", " \t\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",", " \t\t\t          lcpconfopts[opt], opt, len));", " \t\telse", " \t\t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));", " \t\treturn 0;", " \t}", " \tif ((opt >= LCPOPT_MIN) && (opt <= LCPOPT_MAX))", " \t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\", lcpconfopts[opt], opt, len));", " \telse {", " \t\tND_PRINT((ndo, \"\\n\\tunknown LCP option 0x%02x\", opt));", " \t\treturn len;", " \t}", " ", " \tswitch (opt) {", " \tcase LCPOPT_VEXT:", " \t\tif (len < 6) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be >= 6)\"));", "  \t\t\treturn len;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 3);", " \t\tND_TCHECK_24BITS(p + 2);", "  \t\tND_PRINT((ndo, \": Vendor: %s (%u)\",", "  \t\t\ttok2str(oui_values,\"Unknown\",EXTRACT_24BITS(p+2)),", "  \t\t\tEXTRACT_24BITS(p + 2)));", " #if 0", " \t\tND_TCHECK(p[5]);", " \t\tND_PRINT((ndo, \", kind: 0x%02x\", p[5]));", " \t\tND_PRINT((ndo, \", Value: 0x\"));", " \t\tfor (i = 0; i < len - 6; i++) {", " \t\t\tND_TCHECK(p[6 + i]);", " \t\t\tND_PRINT((ndo, \"%02x\", p[6 + i]));", " \t\t}", " #endif", " \t\tbreak;", " \tcase LCPOPT_MRU:", " \t\tif (len != 4) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));", "  \t\t\treturn len;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 2);", " \t\tND_TCHECK_16BITS(p + 2);", "  \t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));", "  \t\tbreak;", "  \tcase LCPOPT_ACCM:", "  \t\tif (len != 6) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));", "  \t\t\treturn len;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 4);", " \t\tND_TCHECK_32BITS(p + 2);", "  \t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));", "  \t\tbreak;", "  \tcase LCPOPT_AP:", "  \t\tif (len < 4) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));", "  \t\t\treturn len;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 2);", " \t\tND_TCHECK_16BITS(p + 2);", "  \t\tND_PRINT((ndo, \": %s\", tok2str(ppptype2str, \"Unknown Auth Proto (0x04x)\", EXTRACT_16BITS(p + 2))));", "  ", "  \t\tswitch (EXTRACT_16BITS(p+2)) {", " \t\tcase PPP_CHAP:", " \t\t\tND_TCHECK(p[4]);", " \t\t\tND_PRINT((ndo, \", %s\", tok2str(authalg_values, \"Unknown Auth Alg %u\", p[4])));", " \t\t\tbreak;", " \t\tcase PPP_PAP:  ", " \t\tcase PPP_EAP:", " \t\tcase PPP_SPAP:", " \t\tcase PPP_SPAP_OLD:", "                         break;", " \t\tdefault:", " \t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", len);", " \t\t}", " \t\tbreak;", " \tcase LCPOPT_QP:", " \t\tif (len < 4) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be >= 4)\"));", "  \t\t\treturn 0;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 2);", " \t\tND_TCHECK_16BITS(p+2);", "  \t\tif (EXTRACT_16BITS(p+2) == PPP_LQM)", "  \t\t\tND_PRINT((ndo, \": LQR\"));", "  \t\telse", " \t\t\tND_PRINT((ndo, \": unknown\"));", " \t\tbreak;", " \tcase LCPOPT_MN:", " \t\tif (len != 6) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));", "  \t\t\treturn 0;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 4);", " \t\tND_TCHECK_32BITS(p + 2);", "  \t\tND_PRINT((ndo, \": 0x%08x\", EXTRACT_32BITS(p + 2)));", "  \t\tbreak;", "  \tcase LCPOPT_PFC:", " \t\tbreak;", " \tcase LCPOPT_ACFC:", " \t\tbreak;", " \tcase LCPOPT_LD:", " \t\tif (len != 4) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));", "  \t\t\treturn 0;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 2);", " \t\tND_TCHECK_16BITS(p + 2);", "  \t\tND_PRINT((ndo, \": 0x%04x\", EXTRACT_16BITS(p + 2)));", "  \t\tbreak;", "  \tcase LCPOPT_CBACK:", " \t\tif (len < 3) {", " \t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));", " \t\t\treturn 0;", " \t\t}", " \t\tND_PRINT((ndo, \": \"));", " \t\tND_TCHECK(p[2]);", " \t\tND_PRINT((ndo, \": Callback Operation %s (%u)\",", "                        tok2str(ppp_callback_values, \"Unknown\", p[2]),", "                        p[2]));", " \t\tbreak;", " \tcase LCPOPT_MLMRRU:", " \t\tif (len != 4) {", "  \t\t\tND_PRINT((ndo, \" (length bogus, should be = 4)\"));", "  \t\t\treturn 0;", "  \t\t}", "\t\tND_TCHECK2(*(p + 2), 2);", " \t\tND_TCHECK_16BITS(p + 2);", "  \t\tND_PRINT((ndo, \": %u\", EXTRACT_16BITS(p + 2)));", "  \t\tbreak;", "  \tcase LCPOPT_MLED:", " \t\tif (len < 3) {", " \t\t\tND_PRINT((ndo, \" (length bogus, should be >= 3)\"));", " \t\t\treturn 0;", " \t\t}", " \t\tND_TCHECK(p[2]);", " \t\tswitch (p[2]) {\t\t ", " \t\tcase MEDCLASS_NULL:", " \t\t\tND_PRINT((ndo, \": Null\"));", " \t\t\tbreak;", " \t\tcase MEDCLASS_LOCAL:", " \t\t\tND_PRINT((ndo, \": Local\"));  ", " \t\t\tbreak;", " \t\tcase MEDCLASS_IPV4:", " \t\t\tif (len != 7) {", " \t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 7)\"));", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\tND_TCHECK2(*(p + 3), 4);", " \t\t\tND_PRINT((ndo, \": IPv4 %s\", ipaddr_string(ndo, p + 3)));", " \t\t\tbreak;", " \t\tcase MEDCLASS_MAC:", " \t\t\tif (len != 9) {", " \t\t\t\tND_PRINT((ndo, \" (length bogus, should be = 9)\"));", " \t\t\t\treturn 0;", " \t\t\t}", " \t\t\tND_TCHECK2(*(p + 3), 6);", " \t\t\tND_PRINT((ndo, \": MAC %s\", etheraddr_string(ndo, p + 3)));", " \t\t\tbreak;", " \t\tcase MEDCLASS_MNB:", " \t\t\tND_PRINT((ndo, \": Magic-Num-Block\"));  ", " \t\t\tbreak;", " \t\tcase MEDCLASS_PSNDN:", " \t\t\tND_PRINT((ndo, \": PSNDN\"));  ", " \t\t\tbreak;", " \t\tdefault:", " \t\t\tND_PRINT((ndo, \": Unknown class %u\", p[2]));", " \t\t\tbreak;", " \t\t}", " \t\tbreak;", " ", "  ", " #if 0", " \tcase LCPOPT_DEP6:", " \tcase LCPOPT_FCSALT:", " \tcase LCPOPT_SDP:", " \tcase LCPOPT_NUMMODE:", " \tcase LCPOPT_DEP12:", " \tcase LCPOPT_DEP14:", " \tcase LCPOPT_DEP15:", " \tcase LCPOPT_DEP16:", "         case LCPOPT_MLSSNHF:", " \tcase LCPOPT_PROP:", " \tcase LCPOPT_DCEID:", " \tcase LCPOPT_MPP:", " \tcase LCPOPT_LCPAOPT:", " \tcase LCPOPT_COBS:", " \tcase LCPOPT_PE:", " \tcase LCPOPT_MLHF:", " \tcase LCPOPT_I18N:", " \tcase LCPOPT_SDLOS:", " \tcase LCPOPT_PPPMUX:", " \t\tbreak;", " #endif", " \tdefault:", " \t\t ", " \t\tif (ndo->ndo_vflag < 2)", " \t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);", " \t\tbreak;", " \t}", " ", " \tif (ndo->ndo_vflag > 1)", " \t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);  ", " ", " \treturn len;", " ", " trunc:", " \tND_PRINT((ndo, \"[|lcp]\"));", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["MagickExport void RegisterStaticModules(void)", "{", "size_t", "extent;", "", "ssize_t", "i;", "", "extent=sizeof(MagickModules)/sizeof(MagickModules[0]);", "for (i=0; i < (ssize_t) extent; i++)", "{", "if (MagickModules[i].registered == MagickFalse)", "{", "(void) (MagickModules[i].register_module)();", "MagickModules[i].registered=MagickTrue;", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": [" void BaseRenderingContext2D::setStrokeStyle(", "     const StringOrCanvasGradientOrCanvasPattern& style) {", "   DCHECK(!style.IsNull());", " ", "   String color_string;", "   CanvasStyle* canvas_style = nullptr;", "   if (style.IsString()) {", "     color_string = style.GetAsString();", "     if (color_string == GetState().UnparsedStrokeColor())", "       return;", "     Color parsed_color = 0;", "     if (!ParseColorOrCurrentColor(parsed_color, color_string))", "       return;", "     if (GetState().StrokeStyle()->IsEquivalentRGBA(parsed_color.Rgb())) {", "       ModifiableState().SetUnparsedStrokeColor(color_string);", "       return;", "     }", "     canvas_style = CanvasStyle::CreateFromRGBA(parsed_color.Rgb());", "   } else if (style.IsCanvasGradient()) {", "     canvas_style = CanvasStyle::CreateFromGradient(style.GetAsCanvasGradient());", "    } else if (style.IsCanvasPattern()) {", "      CanvasPattern* canvas_pattern = style.GetAsCanvasPattern();", "  ", "    if (OriginClean() && !canvas_pattern->OriginClean()) {", "      SetOriginTainted();", "      ClearResolvedFilters();", "    }", "     if (!origin_tainted_by_content_ && !canvas_pattern->OriginClean())", "       SetOriginTaintedByContent();", "  ", "      canvas_style = CanvasStyle::CreateFromPattern(canvas_pattern);", "    }", " ", "   DCHECK(canvas_style);", " ", "   ModifiableState().SetStrokeStyle(canvas_style);", "   ModifiableState().SetUnparsedStrokeColor(color_string);", "   ModifiableState().ClearResolvedFilter();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" CmdBufferImageTransportFactory::CreateSharedSurfaceHandle() {", "   if (!context_->makeContextCurrent()) {", "     NOTREACHED() << \"Failed to make shared graphics context current\";", "     return gfx::GLSurfaceHandle();", "   }", " ", "    gfx::GLSurfaceHandle handle = gfx::GLSurfaceHandle(", "        gfx::kNullPluginWindow, true);", "    handle.parent_gpu_process_id = context_->GetGPUProcessID();", "  handle.parent_client_id = context_->GetChannelID();", "  handle.parent_context_id = context_->GetContextID();", "  handle.parent_texture_id[0] = context_->createTexture();", "  handle.parent_texture_id[1] = context_->createTexture();", "  handle.sync_point = context_->insertSyncPoint();", "    context_->flush();", "    return handle;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" void GraphicsContext::fillRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight, const IntSize& bottomLeft, const IntSize& bottomRight, const Color& color, ColorSpace colorSpace)", " {", "      if (paintingDisabled())", "          return;", "      ", "    notImplemented();", " #if USE(WXGC)", "     Path path;", "     path.addRoundedRect(rect, topLeft, topRight, bottomLeft, bottomRight);", "     m_data->context->SetBrush(wxBrush(color));", "     wxGraphicsContext* gc = m_data->context->GetGraphicsContext();", "     gc->FillPath(*path.platformPath());", " #endif", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)", " {", "     AVIOContext *pb      = s->pb;", "     AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar;", "     FLVContext *flv      = s->priv_data;", "     FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;", "     unsigned ts;", "     int size = pkt->size;", "     uint8_t *data = NULL;", "      int flags = -1, flags_size, ret;", "      int64_t cur_offset = avio_tell(pb);", "  ", "     if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {", "         av_log(s, AV_LOG_WARNING, \"Empty audio Packet\\n\");", "         return AVERROR(EINVAL);", "     }", " ", "      if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||", "          par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)", "          flags_size = 2;", "     else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4)", "         flags_size = 5;", "     else", "         flags_size = 1;", " ", "     if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264", "             || par->codec_id == AV_CODEC_ID_MPEG4) {", "         int side_size = 0;", "         uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);", "         if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {", "             av_free(par->extradata);", "             par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);", "             if (!par->extradata) {", "                 par->extradata_size = 0;", "                 return AVERROR(ENOMEM);", "             }", "             memcpy(par->extradata, side, side_size);", "             par->extradata_size = side_size;", "             flv_write_codec_header(s, par, pkt->dts);", "         }", "     }", " ", "     if (flv->delay == AV_NOPTS_VALUE)", "         flv->delay = -pkt->dts;", " ", "     if (pkt->dts < -flv->delay) {", "         av_log(s, AV_LOG_WARNING,", "                \"Packets are not in the proper order with respect to DTS\\n\");", "         return AVERROR(EINVAL);", "     }", " ", "     ts = pkt->dts;", " ", "     if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) {", "         write_metadata(s, ts);", "         s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED;", "     }", " ", "     avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000),", "                       pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT);", " ", "     switch (par->codec_type) {", "     case AVMEDIA_TYPE_VIDEO:", "         avio_w8(pb, FLV_TAG_TYPE_VIDEO);", " ", "         flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id);", " ", "         flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;", "         break;", "     case AVMEDIA_TYPE_AUDIO:", "         flags = get_audio_flags(s, par);", " ", "         av_assert0(size);", " ", "         avio_w8(pb, FLV_TAG_TYPE_AUDIO);", "         break;", "     case AVMEDIA_TYPE_SUBTITLE:", "     case AVMEDIA_TYPE_DATA:", "         avio_w8(pb, FLV_TAG_TYPE_META);", "         break;", "     default:", "         return AVERROR(EINVAL);", "     }", " ", "     if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {", "          ", "         if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1)", "             if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0)", "                 return ret;", "     } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 &&", "                (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) {", "         if (!s->streams[pkt->stream_index]->nb_frames) {", "         av_log(s, AV_LOG_ERROR, \"Malformed AAC bitstream detected: \"", "                \"use the audio bitstream filter 'aac_adtstoasc' to fix it \"", "                \"('-bsf:a aac_adtstoasc' option with ffmpeg)\\n\");", "         return AVERROR_INVALIDDATA;", "         }", "         av_log(s, AV_LOG_WARNING, \"aac bitstream error\\n\");", "     }", " ", "      ", "     if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)", "         av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"", "                                   \"8 frames per packet. Adobe Flash \"", "                                   \"Player cannot handle this!\\n\");", " ", "     if (sc->last_ts < ts)", "         sc->last_ts = ts;", " ", "     if (size + flags_size >= 1<<24) {", "         av_log(s, AV_LOG_ERROR, \"Too large packet with size %u >= %u\\n\",", "                size + flags_size, 1<<24);", "         return AVERROR(EINVAL);", "     }", " ", "     avio_wb24(pb, size + flags_size);", "     put_timestamp(pb, ts);", "     avio_wb24(pb, flv->reserved);", " ", "     if (par->codec_type == AVMEDIA_TYPE_DATA ||", "         par->codec_type == AVMEDIA_TYPE_SUBTITLE ) {", "         int data_size;", "         int64_t metadata_size_pos = avio_tell(pb);", "         if (par->codec_id == AV_CODEC_ID_TEXT) {", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, \"onTextData\");", "             avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);", "             avio_wb32(pb, 2);", "             put_amf_string(pb, \"type\");", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, \"Text\");", "             put_amf_string(pb, \"text\");", "             avio_w8(pb, AMF_DATA_TYPE_STRING);", "             put_amf_string(pb, pkt->data);", "             put_amf_string(pb, \"\");", "             avio_w8(pb, AMF_END_OF_OBJECT);", "         } else {", "             avio_write(pb, data ? data : pkt->data, size);", "         }", "          ", "         data_size = avio_tell(pb) - metadata_size_pos;", "         avio_seek(pb, metadata_size_pos - 10, SEEK_SET);", "         avio_wb24(pb, data_size);", "         avio_seek(pb, data_size + 10 - 3, SEEK_CUR);", "         avio_wb32(pb, data_size + 11);", "     } else {", "         av_assert1(flags>=0);", "         avio_w8(pb,flags);", "         if (par->codec_id == AV_CODEC_ID_VP6)", "             avio_w8(pb,0);", "         if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) {", "             if (par->extradata_size)", "                 avio_w8(pb, par->extradata[0]);", "             else", "                 avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) |", "                              (FFALIGN(par->height, 16) - par->height));", "         } else if (par->codec_id == AV_CODEC_ID_AAC)", "             avio_w8(pb, 1);  ", "         else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) {", "             avio_w8(pb, 1);  ", "             avio_wb24(pb, pkt->pts - pkt->dts);", "         }", " ", "         avio_write(pb, data ? data : pkt->data, size);", " ", "         avio_wb32(pb, size + flags_size + 11);  ", "         flv->duration = FFMAX(flv->duration,", "                               pkt->pts + flv->delay + pkt->duration);", "     }", " ", "     if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {", "         switch (par->codec_type) {", "             case AVMEDIA_TYPE_VIDEO:", "                 flv->videosize += (avio_tell(pb) - cur_offset);", "                 flv->lasttimestamp = flv->acurframeindex / flv->framerate;", "                 if (pkt->flags & AV_PKT_FLAG_KEY) {", "                     double ts = flv->acurframeindex / flv->framerate;", "                     int64_t pos = cur_offset;", " ", "                     flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate;", "                     flv->lastkeyframelocation = pos;", "                     flv_append_keyframe_info(s, flv, ts, pos);", "                 }", "                 flv->acurframeindex++;", "                 break;", " ", "             case AVMEDIA_TYPE_AUDIO:", "                 flv->audiosize += (avio_tell(pb) - cur_offset);", "                 break;", " ", "             default:", "                 av_log(s, AV_LOG_WARNING, \"par->codec_type is type = [%d]\\n\", par->codec_type);", "                 break;", "         }", "     }", " ", "     av_free(data);", " ", "     return pb->error;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,", "                               vpx_codec_ctx_t *codec) {", "  vpx_active_map_t map = {0};", "   vpx_active_map_t map = {0, 0, 0};", "  ", "    map.rows = (cfg->g_h + 15) / 16;", "    map.cols = (cfg->g_w + 15) / 16;", "  map.active_map = NULL;", " ", "  if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))", " ", "      die_codec(codec, \"Failed to set active map\");", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)", "{", "u32 i;", "char str[1024];", "GF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;", "", "i=0;", "str[0]=0;", "while (1) {", "str[i] = gf_bs_read_u8(bs);", "if (!str[i]) break;", "i++;", "}", "ISOM_DECREASE_SIZE(p, i);", "", "p->content_script_types = gf_strdup(str);", "return GF_OK;", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0]}
{"tokens": [" static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,", "\t\t\t      struct btrfs_path *path,", "\t\t\t      const char *name, int name_len)", " struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,", " \t\t\t\t\t\t struct btrfs_path *path,", " \t\t\t\t\t\t const char *name, int name_len)", "  {", "  \tstruct btrfs_dir_item *dir_item;", "  \tunsigned long name_ptr;", " \tu32 total_len;", " \tu32 cur = 0;", " \tu32 this_len;", " \tstruct extent_buffer *leaf;", " ", " \tleaf = path->nodes[0];", " \tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);", " \tif (verify_dir_item(root, leaf, dir_item))", " \t\treturn NULL;", " ", " \ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);", " \twhile (cur < total_len) {", " \t\tthis_len = sizeof(*dir_item) +", " \t\t\tbtrfs_dir_name_len(leaf, dir_item) +", " \t\t\tbtrfs_dir_data_len(leaf, dir_item);", " \t\tname_ptr = (unsigned long)(dir_item + 1);", " ", " \t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&", " \t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)", " \t\t\treturn dir_item;", " ", " \t\tcur += this_len;", " \t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +", " \t\t\t\t\t\t     this_len);", " \t}", " \treturn NULL;", " }"], "ner_tags": [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)", " void nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)", "  {", "\t__nfs4_close(path, state, mode, 1);", " \t__nfs4_close(path, state, fmode, 1);", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0]}
{"tokens": [" parse_device(dev_t *pdev, struct archive *a, char *val)", " {", " #define MAX_PACK_ARGS 3", " \tunsigned long numbers[MAX_PACK_ARGS];", " \tchar *p, *dev;", " \tint argc;", " \tpack_t *pack;", " \tdev_t result;", " \tconst char *error = NULL;", " ", " \tmemset(pdev, 0, sizeof(*pdev));", " \tif ((dev = strchr(val, ',')) != NULL) {", " \t\t ", " \t\t*dev++ = '\\0';", " \t\tif ((pack = pack_find(val)) == NULL) {", " \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Unknown format `%s'\", val);", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t\targc = 0;", " \t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {", " \t\t\tif (*p == '\\0') {", " \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", "  \t\t\t\t    \"Missing number\");", "  \t\t\t\treturn ARCHIVE_WARN;", "  \t\t\t}", "\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);", "\t\t\tif (argc > MAX_PACK_ARGS) {", " \t\t\tif (argc >= MAX_PACK_ARGS) {", "  \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", "  \t\t\t\t    \"Too many arguments\");", "  \t\t\t\treturn ARCHIVE_WARN;", "  \t\t\t}", " \t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);", "  \t\t}", "  \t\tif (argc < 2) {", "  \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"Not enough arguments\");", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t\tresult = (*pack)(argc, numbers, &error);", " \t\tif (error != NULL) {", " \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,", " \t\t\t    \"%s\", error);", " \t\t\treturn ARCHIVE_WARN;", " \t\t}", " \t} else {", " \t\t ", " \t\tresult = (dev_t)mtree_atol(&val);", " \t}", " \t*pdev = result;", " \treturn ARCHIVE_OK;", " #undef MAX_PACK_ARGS", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool BaseSettingChange::Init(Profile* profile) {", "  DCHECK(profile);", "   DCHECK(profile && !profile_);", "    profile_ = profile;", "    return true;", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0]}
{"tokens": ["void LinearAlgebraOp<InputScalar, OutputScalar>::AnalyzeInputs(", "OpKernelContext* context, TensorInputs* inputs,", "TensorShapes* input_matrix_shapes, TensorShape* batch_shape) {", "int input_rank = -1;", "for (int i = 0; i < NumMatrixInputs(context); ++i) {", "const Tensor& in = context->input(i);", "if (i == 0) {", "input_rank = in.dims();", "OP_REQUIRES(", "context, input_rank >= 2,", "errors::InvalidArgument(\"Input tensor \", i,", "\" must have rank >= 2, got \", input_rank));", "", "", "", "for (int dim = 0; dim < input_rank - 2; ++dim) {", "batch_shape->AddDim(in.dim_size(dim));", "}", "} else {", "", "OP_REQUIRES(context, input_rank == in.dims(),", "errors::InvalidArgument(", "\"All input tensors must have the same rank.\"));", "for (int dim = 0; dim < input_rank - 2; ++dim) {", "OP_REQUIRES(", "context, in.dim_size(dim) == batch_shape->dim_size(dim),", "errors::InvalidArgument(", "\"All input tensors must have the same outer dimensions.\"));", "}", "}", "", "const int row_dimension = input_rank - 2;", "const int col_dimension = input_rank - 1;", "const int64_t num_rows = in.dim_size(row_dimension);", "const int64_t num_cols = in.dim_size(col_dimension);", "input_matrix_shapes->emplace_back(", "std::initializer_list<int64_t>({num_rows, num_cols}));", "inputs->emplace_back(&in);", "}", "", "ValidateInputMatrixShapes(context, *input_matrix_shapes);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void ASessionDescription::getFormatType(", "  size_t index, unsigned long *PT,", "  AString *desc, AString *params) const {", "  AString format;", "     getFormat(index, &format);", " ", "  const char *lastSpacePos = strrchr(format.c_str(), ' ');", "     CHECK(lastSpacePos != NULL);", " ", "  char *end;", "  unsigned long x = strtoul(lastSpacePos + 1, &end, 10);", "     CHECK_GT(end, lastSpacePos + 1);", "     CHECK_EQ(*end, '\\0');", " ", "  ", "      *PT = x;", "  ", "    char key[20];", "    sprintf(key, \"a=rtpmap:%lu\", x);", "     char key[32];", "     snprintf(key, sizeof(key), \"a=rtpmap:%lu\", x);", "  ", "      CHECK(findAttribute(index, key, desc));", "  ", "    sprintf(key, \"a=fmtp:%lu\", x);", "     snprintf(key, sizeof(key), \"a=fmtp:%lu\", x);", "      if (!findAttribute(index, key, params)) {", "          params->clear();", "      }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["static void perf_remove_from_owner(struct perf_event *event)", "{", "struct task_struct *owner;", "", "rcu_read_lock();", "owner = ACCESS_ONCE(event->owner);", "", "", "", "", "", "", "smp_read_barrier_depends();", "if (owner) {", "", "", "", "", "", "get_task_struct(owner);", "}", "rcu_read_unlock();", "", "if (owner) {", "mutex_lock(&owner->perf_event_mutex);", "", "", "", "", "", "", "if (event->owner)", "list_del_init(&event->owner_entry);", "mutex_unlock(&owner->perf_event_mutex);", "put_task_struct(owner);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void fpm_child_init(struct fpm_worker_pool_s *wp)  ", "  {", "  \tfpm_globals.max_requests = wp->config->pm_max_requests;", " \tfpm_globals.listening_socket = dup(wp->listening_socket);", "  ", "  \tif (0 > fpm_stdio_init_child(wp)  ||", "  \t    0 > fpm_log_init_child(wp)    ||", " \t    0 > fpm_status_init_child(wp) ||", " \t    0 > fpm_unix_init_child(wp)   ||", " \t    0 > fpm_signals_init_child()  ||", " \t    0 > fpm_env_init_child(wp)    ||", " \t    0 > fpm_php_init_child(wp)) {", " ", " \t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);", " \t\texit(FPM_EXIT_SOFTWARE);", " \t}", " }", "  "], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void WebGLRenderingContextBase::linkProgram(WebGLProgram* program) {", "   if (!ValidateWebGLProgramOrShader(\"linkProgram\", program))", "     return;", " ", "   if (program->ActiveTransformFeedbackCount() > 0) {", "     SynthesizeGLError(", "         GL_INVALID_OPERATION, \"linkProgram\",", "         \"program being used by one or more active transform feedback objects\");", "      return;", "    }", "  ", "   GLuint query = 0u;", "   if (ExtensionEnabled(kKHRParallelShaderCompileName)) {", "     ContextGL()->GenQueriesEXT(1, &query);", "     ContextGL()->BeginQueryEXT(GL_PROGRAM_COMPLETION_QUERY_CHROMIUM, query);", "   }", "    ContextGL()->LinkProgram(ObjectOrZero(program));", "   if (ExtensionEnabled(kKHRParallelShaderCompileName)) {", "     ContextGL()->EndQueryEXT(GL_PROGRAM_COMPLETION_QUERY_CHROMIUM);", "     addProgramCompletionQuery(program, query);", "   }", " ", "    program->IncreaseLinkCount();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" void WebGL2RenderingContextBase::texSubImage2D(GLenum target,", "                                                GLint level,", "                                                GLint xoffset,", "                                                GLint yoffset,", "                                                GLsizei width,", "                                                GLsizei height,", "                                                GLenum format,", "                                                GLenum type,", "                                                GLintptr offset) {", "   if (isContextLost())", "     return;", "   if (!ValidateTexture2DBinding(\"texSubImage2D\", target))", "     return;", "   if (!bound_pixel_unpack_buffer_) {", "     SynthesizeGLError(GL_INVALID_OPERATION, \"texSubImage2D\",", "                        \"no bound PIXEL_UNPACK_BUFFER\");", "      return;", "    }", "   if (unpack_flip_y_ || unpack_premultiply_alpha_) {", "     SynthesizeGLError(", "         GL_INVALID_OPERATION, \"texSubImage2D\",", "         \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO\");", "     return;", "   }", "    if (!ValidateTexFunc(\"texSubImage2D\", kTexSubImage, kSourceUnpackBuffer,", "                         target, level, 0, width, height, 1, 0, format, type,", "                         xoffset, yoffset, 0))", "     return;", "   if (!ValidateValueFitNonNegInt32(\"texSubImage2D\", \"offset\", offset))", "     return;", " ", "   ContextGL()->TexSubImage2D(target, level, xoffset, yoffset, width, height,", "                              format, type,", "                              reinterpret_cast<const void*>(offset));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,", "char *buf, u_int8_t client_hash) {", "u_int16_t offset = 22, buf_out_len = 0;", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "offset += 4;", "", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "", "strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);", "buf[buf_out_len++] = ';';", "offset += len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "offset += 4 + len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "offset += len;", "} else", "offset += 4 + len;", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "offset += len;", "} else", "offset += 4 + len;", "", "", "", "", "", "#ifdef SSH_DEBUG", "printf(\"[SSH] %s\\n\", buf);", "#endif", "", "return(buf_out_len);", "", "invalid_payload:", "", "#ifdef SSH_DEBUG", "printf(\"[SSH] Invalid packet payload\\n\");", "#endif", "", "return(0);", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,", "   const size_t quantum)", " {", "    size_t", "      extent;", "  ", "  if (CheckMemoryOverflow(count,quantum) != MagickFalse)", "   if (HeapOverflowSanityCheck(count,quantum) != MagickFalse)", "      {", "        memory=RelinquishMagickMemory(memory);", "        return((void *) NULL);", "     }", "   extent=count*quantum;", "   return(ResizeMagickMemory(memory,extent));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" image_transform_png_set_strip_alpha_set(PNG_CONST image_transform *this,", " image_transform_png_set_strip_alpha_set(const image_transform *this,", "      transform_display *that, png_structp pp, png_infop pi)", "  {", "     png_set_strip_alpha(pp);", "  this->next->set(this->next, that, pp, pi);", " ", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int jp2_box_put(jp2_box_t *box, jas_stream_t *out)", " {", " \tjas_stream_t *tmpstream;", " \tbool extlen;", " \tbool dataflag;", " ", " \ttmpstream = 0;", " ", " \tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));", " ", " \tif (dataflag) {", " \t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {", " \t\t\tgoto error;", " \t\t}", " \t\tif (box->ops->putdata) {", " \t\t\tif ((*box->ops->putdata)(box, tmpstream)) {", " \t\t\t\tgoto error;", " \t\t\t}", " \t\t}", " \t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);", " \t\tjas_stream_rewind(tmpstream);", " \t}", " \textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;", " \tif (jp2_putuint32(out, extlen ? 1 : box->len)) {", " \t\tgoto error;", " \t}", " \tif (jp2_putuint32(out, box->type)) {", " \t\tgoto error;", " \t}", " \tif (extlen) {", " \t\tif (jp2_putuint64(out, box->len)) {", " \t\t\tgoto error;", " \t\t}", "  \t}", "  ", "  \tif (dataflag) {", "\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {", " \t\tif (jas_stream_copy(out, tmpstream, box->len -", " \t\t  JP2_BOX_HDRLEN(false))) {", " \t\t\tjas_eprintf(\"cannot copy box data\\n\");", "  \t\t\tgoto error;", "  \t\t}", "  \t\tjas_stream_close(tmpstream);", " \t}", " ", " \treturn 0;", " ", " error:", " ", " \tif (tmpstream) {", " \t\tjas_stream_close(tmpstream);", " \t}", " \treturn -1;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   tt_cmap8_validate( FT_Byte*      table,", "                      FT_Validator  valid )", "   {", "     FT_Byte*   p = table + 4;", "     FT_Byte*   is32;", "     FT_UInt32  length;", "     FT_UInt32  num_groups;", " ", " ", "     if ( table + 16 + 8192 > valid->limit )", "       FT_INVALID_TOO_SHORT;", " ", "     length = TT_NEXT_ULONG( p );", "     if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )", "       FT_INVALID_TOO_SHORT;", " ", "     is32       = table + 12;", "      p          = is32  + 8192;           ", "      num_groups = TT_NEXT_ULONG( p );", "  ", "    if ( p + num_groups * 12 > valid->limit )", "      ", "     if ( num_groups > (FT_UInt32)( valid->limit - p ) / 12 )", "        FT_INVALID_TOO_SHORT;", "  ", "       ", "       FT_UInt32  n, start, end, start_id, count, last = 0;", " ", " ", "       for ( n = 0; n < num_groups; n++ )", "       {", "         FT_UInt   hi, lo;", " ", " ", "         start    = TT_NEXT_ULONG( p );", "         end      = TT_NEXT_ULONG( p );", "         start_id = TT_NEXT_ULONG( p );", " ", "         if ( start > end )", "           FT_INVALID_DATA;", " ", "         if ( n > 0 && start <= last )", "           FT_INVALID_DATA;", " ", "  ", "          if ( valid->level >= FT_VALIDATE_TIGHT )", "          {", "          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )", "           FT_UInt32  d = end - start;", " ", " ", "            ", "           if ( d > TT_VALID_GLYPH_COUNT( valid )             ||", "                start_id >= TT_VALID_GLYPH_COUNT( valid ) - d )", "              FT_INVALID_GLYPH_ID;", "  ", "            count = (FT_UInt32)( end - start + 1 );", "             {", "               hi = (FT_UInt)( start >> 16 );", "               lo = (FT_UInt)( start & 0xFFFFU );", " ", "               if ( (is32[hi >> 3] & ( 0x80 >> ( hi & 7 ) ) ) == 0 )", "                 FT_INVALID_DATA;", " ", "               if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) == 0 )", "                 FT_INVALID_DATA;", "             }", "           }", "           else", "           {", "              ", "              ", " ", "              ", "             if ( end & ~0xFFFFU )", "               FT_INVALID_DATA;", " ", "             for ( ; count > 0; count--, start++ )", "             {", "               lo = (FT_UInt)( start & 0xFFFFU );", " ", "               if ( (is32[lo >> 3] & ( 0x80 >> ( lo & 7 ) ) ) != 0 )", "                 FT_INVALID_DATA;", "             }", "           }", "         }", " ", "         last = end;", "       }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void call_console_drivers(unsigned start, unsigned end)", " {", " \tunsigned cur_index, start_print;", " \tstatic int msg_level = -1;", " ", " \tBUG_ON(((int)(start - end)) > 0);", " ", " \tcur_index = start;", "  \tstart_print = start;", "  \twhile (cur_index != end) {", "  \t\tif (msg_level < 0 && ((end - cur_index) > 2)) {", " \t\t\t ", " \t\t\tchar buf_prefix[SYSLOG_PRI_MAX_LENGTH+1];", " \t\t\tunsigned i;", " \t\t\tfor (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) {", " \t\t\t\tbuf_prefix[i] = LOG_BUF(cur_index + i);", " \t\t\t}", " \t\t\tbuf_prefix[i] = '\\0';  ", " ", "  \t\t\t ", "\t\t\tcur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);", " \t\t\tcur_index += log_prefix((const char *)&buf_prefix, &msg_level, NULL);", "  \t\t\tstart_print = cur_index;", "  \t\t}", "  \t\twhile (cur_index != end) {", " \t\t\tchar c = LOG_BUF(cur_index);", " ", " \t\t\tcur_index++;", " \t\t\tif (c == '\\n') {", " \t\t\t\tif (msg_level < 0) {", " \t\t\t\t\t ", " \t\t\t\t\tmsg_level = default_message_loglevel;", " \t\t\t\t}", " \t\t\t\t_call_console_drivers(start_print, cur_index, msg_level);", " \t\t\t\tmsg_level = -1;", " \t\t\t\tstart_print = cur_index;", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t}", " \t_call_console_drivers(start_print, end, msg_level);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE SoftAVCEncoder::internalGetParameter(", "         OMX_INDEXTYPE index, OMX_PTR params) {", "  switch (index) {", "  case OMX_IndexParamVideoBitrate:", "  {", " ", "              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =", "                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;", "  ", "             if (!isValidOMXParam(bitRate)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (bitRate->nPortIndex != 1) {", "                  return OMX_ErrorUndefined;", "              }", " ", "             bitRate->eControlRate = OMX_Video_ControlRateVariable;", "             bitRate->nTargetBitrate = mBitrate;", "  return OMX_ErrorNone;", "  }", " ", "  case OMX_IndexParamVideoAvc:", "  {", " ", "              OMX_VIDEO_PARAM_AVCTYPE *avcParams =", "                  (OMX_VIDEO_PARAM_AVCTYPE *)params;", "  ", "             if (!isValidOMXParam(avcParams)) {", "                 return OMX_ErrorBadParameter;", "             }", " ", "              if (avcParams->nPortIndex != 1) {", "                  return OMX_ErrorUndefined;", "              }", " ", "             avcParams->eProfile = OMX_VIDEO_AVCProfileBaseline;", "             OMX_U32 omxLevel = AVC_LEVEL2;", "  if (OMX_ErrorNone !=", "  ConvertAvcSpecLevelToOmxAvcLevel(mAVCEncLevel, &omxLevel)) {", "  return OMX_ErrorUndefined;", "  }", " ", "             avcParams->eLevel = (OMX_VIDEO_AVCLEVELTYPE) omxLevel;", "             avcParams->nRefFrames = 1;", "             avcParams->nBFrames = 0;", "             avcParams->bUseHadamard = OMX_TRUE;", "             avcParams->nAllowedPictureTypes =", "  (OMX_VIDEO_PictureTypeI | OMX_VIDEO_PictureTypeP);", "             avcParams->nRefIdx10ActiveMinus1 = 0;", "             avcParams->nRefIdx11ActiveMinus1 = 0;", "             avcParams->bWeightedPPrediction = OMX_FALSE;", "             avcParams->bEntropyCodingCABAC = OMX_FALSE;", "             avcParams->bconstIpred = OMX_FALSE;", "             avcParams->bDirect8x8Inference = OMX_FALSE;", "             avcParams->bDirectSpatialTemporal = OMX_FALSE;", "             avcParams->nCabacInitIdc = 0;", "  return OMX_ErrorNone;", "  }", " ", "  default:", "  return SoftVideoEncoderOMXComponent::internalGetParameter(index, params);", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static ssize_t generic_perform_write(struct file *file,", " \t\t\t\tstruct iov_iter *i, loff_t pos)", " {", " \tstruct address_space *mapping = file->f_mapping;", " \tconst struct address_space_operations *a_ops = mapping->a_ops;", " \tlong status = 0;", " \tssize_t written = 0;", " \tunsigned int flags = 0;", " ", " \t ", " \tif (segment_eq(get_fs(), KERNEL_DS))", " \t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;", " ", " \tdo {", " \t\tstruct page *page;", " \t\tpgoff_t index;\t\t ", " \t\tunsigned long offset;\t ", " \t\tunsigned long bytes;\t ", " \t\tsize_t copied;\t\t ", " \t\tvoid *fsdata;", " ", " \t\toffset = (pos & (PAGE_CACHE_SIZE - 1));", " \t\tindex = pos >> PAGE_CACHE_SHIFT;", " \t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,", " \t\t\t\t\t\tiov_iter_count(i));", " ", " again:", " ", " \t\t ", " \t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {", " \t\t\tstatus = -EFAULT;", " \t\t\tbreak;", " \t\t}", " ", " \t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,", " \t\t\t\t\t\t&page, &fsdata);", " \t\tif (unlikely(status))", " \t\t\tbreak;", " ", " \t\tpagefault_disable();", " \t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);", " \t\tpagefault_enable();", " \t\tflush_dcache_page(page);", " ", " \t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,", " \t\t\t\t\t\tpage, fsdata);", " \t\tif (unlikely(status < 0))", " \t\t\tbreak;", " \t\tcopied = status;", "  ", "  \t\tcond_resched();", "  ", " \t\tiov_iter_advance(i, copied);", "  \t\tif (unlikely(copied == 0)) {", "  \t\t\t ", " \t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,", "  \t\t\t\t\t\tiov_iter_single_seg_count(i));", "  \t\t\tgoto again;", "  \t\t}", "\t\tiov_iter_advance(i, copied);", "  \t\tpos += copied;", "  \t\twritten += copied;", "  ", " \t\tbalance_dirty_pages_ratelimited(mapping);", " ", " \t} while (iov_iter_count(i));", " ", " \treturn written ? written : status;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" status_t DRMSource::read(MediaBuffer **buffer, const ReadOptions *options) {", "  Mutex::Autolock autoLock(mDRMLock);", "  status_t err;", "  if ((err = mOriginalMediaSource->read(buffer, options)) != OK) {", "  return err;", "  }", " ", "  size_t len = (*buffer)->range_length();", " ", "  char *src = (char *)(*buffer)->data() + (*buffer)->range_offset();", " ", "  DrmBuffer encryptedDrmBuffer(src, len);", "  DrmBuffer decryptedDrmBuffer;", "     decryptedDrmBuffer.length = len;", "     decryptedDrmBuffer.data = new char[len];", "  DrmBuffer *pDecryptedDrmBuffer = &decryptedDrmBuffer;", " ", "  if ((err = mDrmManagerClient->decrypt(mDecryptHandle, mTrackId,", "  &encryptedDrmBuffer, &pDecryptedDrmBuffer)) != NO_ERROR) {", " ", "  if (decryptedDrmBuffer.data) {", "  delete [] decryptedDrmBuffer.data;", "             decryptedDrmBuffer.data = NULL;", "  }", " ", "  return err;", "  }", "     CHECK(pDecryptedDrmBuffer == &decryptedDrmBuffer);", " ", "  const char *mime;", "     CHECK(getFormat()->findCString(kKeyMIMEType, &mime));", " ", "  if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) && !mWantsNALFragments) {", "  uint8_t *dstData = (uint8_t*)src;", "  size_t srcOffset = 0;", "  size_t dstOffset = 0;", " ", "         len = decryptedDrmBuffer.length;", "  while (srcOffset < len) {", "             CHECK(srcOffset + mNALLengthSize <= len);", "  size_t nalLength = 0;", "  const uint8_t* data = (const uint8_t*)(&decryptedDrmBuffer.data[srcOffset]);", " ", "  switch (mNALLengthSize) {", "  case 1:", "                     nalLength = *data;", "  break;", "  case 2:", "                     nalLength = U16_AT(data);", "  break;", "  case 3:", "                     nalLength = ((size_t)data[0] << 16) | U16_AT(&data[1]);", "  break;", "  case 4:", "                     nalLength = U32_AT(data);", "  break;", "  default:", "                     CHECK(!\"Should not be here.\");", "  break;", "  }", " ", "             srcOffset += mNALLengthSize;", " ", "  size_t end = srcOffset + nalLength;", "  if (end > len || end < srcOffset) {", "  if (decryptedDrmBuffer.data) {", "  delete [] decryptedDrmBuffer.data;", "                     decryptedDrmBuffer.data = NULL;", "  }", " ", "  return ERROR_MALFORMED;", "  }", " ", "  if (nalLength == 0) {", " ", "                  continue;", "              }", "  ", "            CHECK(dstOffset + 4 <= (*buffer)->size());", "             if (dstOffset > SIZE_MAX - 4 ||", "                 dstOffset + 4 > SIZE_MAX - nalLength ||", "                 dstOffset + 4 + nalLength > (*buffer)->size()) {", "                 (*buffer)->release();", "                 (*buffer) = NULL;", "                 if (decryptedDrmBuffer.data) {", "                     delete [] decryptedDrmBuffer.data;", "                     decryptedDrmBuffer.data = NULL;", "                 }", "                 return ERROR_MALFORMED;", "             }", "  ", "              dstData[dstOffset++] = 0;", "              dstData[dstOffset++] = 0;", "             dstData[dstOffset++] = 0;", "             dstData[dstOffset++] = 1;", "             memcpy(&dstData[dstOffset], &decryptedDrmBuffer.data[srcOffset], nalLength);", "             srcOffset += nalLength;", "             dstOffset += nalLength;", "  }", " ", "         CHECK_EQ(srcOffset, len);", "  (*buffer)->set_range((*buffer)->range_offset(), dstOffset);", " ", "  } else {", "         memcpy(src, decryptedDrmBuffer.data, decryptedDrmBuffer.length);", "  (*buffer)->set_range((*buffer)->range_offset(), decryptedDrmBuffer.length);", "  }", " ", "  if (decryptedDrmBuffer.data) {", "  delete [] decryptedDrmBuffer.data;", "         decryptedDrmBuffer.data = NULL;", "  }", " ", "  return OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  DXVAVideoDecodeAccelerator::DXVAVideoDecodeAccelerator(", "    media::VideoDecodeAccelerator::Client* client,", "    base::ProcessHandle renderer_process)", "     media::VideoDecodeAccelerator::Client* client)", "      : client_(client),", "        egl_config_(NULL),", "        state_(kUninitialized),", "        pictures_requested_(false),", "      renderer_process_(renderer_process),", "        last_input_buffer_id_(-1),", "        inputs_before_decode_(0) {", "    memset(&input_stream_info_, 0, sizeof(input_stream_info_));", "   memset(&output_stream_info_, 0, sizeof(output_stream_info_));", " }"], "ner_tags": [0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" main (int argc, char *argv[])", " {", "   struct gengetopt_args_info args_info;", "   char *line = NULL;", "   size_t linelen = 0;", "   char *p, *r;", "   uint32_t *q;", "   unsigned cmdn = 0;", "   int rc;", " ", "   setlocale (LC_ALL, \"\");", "   set_program_name (argv[0]);", "   bindtextdomain (PACKAGE, LOCALEDIR);", "   textdomain (PACKAGE);", " ", "   if (cmdline_parser (argc, argv, &args_info) != 0)", "     return EXIT_FAILURE;", " ", "   if (args_info.version_given)", "     {", "       version_etc (stdout, \"idn\", PACKAGE_NAME, VERSION,", " \t\t   \"Simon Josefsson\", (char *) NULL);", "       return EXIT_SUCCESS;", "     }", " ", "   if (args_info.help_given)", "     usage (EXIT_SUCCESS);", " ", "    ", "   if (args_info.hidden_nfkc_given)", "     args_info.nfkc_given = 1;", " ", "   if (!args_info.stringprep_given &&", "       !args_info.punycode_encode_given && !args_info.punycode_decode_given &&", "       !args_info.idna_to_ascii_given && !args_info.idna_to_unicode_given &&", "       !args_info.nfkc_given)", "     args_info.idna_to_ascii_given = 1;", " ", "   if ((args_info.stringprep_given ? 1 : 0) +", "       (args_info.punycode_encode_given ? 1 : 0) +", "       (args_info.punycode_decode_given ? 1 : 0) +", "       (args_info.idna_to_ascii_given ? 1 : 0) +", "       (args_info.idna_to_unicode_given ? 1 : 0) +", "       (args_info.nfkc_given ? 1 : 0) != 1)", "     {", "       error (0, 0, _(\"only one of -s, -e, -d, -a, -u or -n can be specified\"));", "       usage (EXIT_FAILURE);", "     }", " ", "   if (!args_info.quiet_given", "       && args_info.inputs_num == 0", "       && isatty (fileno (stdin)))", "     fprintf (stderr, \"%s %s\\n\" GREETING, PACKAGE, VERSION);", " ", "   if (args_info.debug_given)", "     fprintf (stderr, _(\"Charset `%s'.\\n\"), stringprep_locale_charset ());", " ", "   if (!args_info.quiet_given", "       && args_info.inputs_num == 0", "       && isatty (fileno (stdin)))", "     fprintf (stderr, _(\"Type each input string on a line by itself, \"", " \t\t       \"terminated by a newline character.\\n\"));", " ", "   do", "     {", "       if (cmdn < args_info.inputs_num)", " \tline = strdup (args_info.inputs[cmdn++]);", "       else if (getline (&line, &linelen, stdin) == -1)", " \t{", " \t  if (feof (stdin))", " \t    break;", " ", "  \t  error (EXIT_FAILURE, errno, _(\"input error\"));", "  \t}", "  ", "      if (line[strlen (line) - 1] == '\\n')", "\tline[strlen (line) - 1] = '\\0';", "       if (strlen (line) > 0)", " \tif (line[strlen (line) - 1] == '\\n')", " \t  line[strlen (line) - 1] = '\\0';", "  ", "        if (args_info.stringprep_given)", "  \t{", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  q = stringprep_utf8_to_ucs4 (p, -1, NULL);", " \t  if (!q)", " \t    {", " \t      free (p);", " \t      error (EXIT_FAILURE, 0,", " \t\t     _(\"could not convert from UTF-8 to UCS-4\"));", " \t    }", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"input[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " \t  free (q);", " ", " \t  rc = stringprep_profile (p, &r,", " \t\t\t\t   args_info.profile_given ?", " \t\t\t\t   args_info.profile_arg : \"Nameprep\", 0);", " \t  free (p);", " \t  if (rc != STRINGPREP_OK)", " \t    error (EXIT_FAILURE, 0, _(\"stringprep_profile: %s\"),", " \t\t   stringprep_strerror (rc));", " ", " \t  q = stringprep_utf8_to_ucs4 (r, -1, NULL);", " \t  if (!q)", " \t    {", " \t      free (r);", " \t      error (EXIT_FAILURE, 0,", " \t\t     _(\"could not convert from UTF-8 to UCS-4\"));", " \t    }", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"output[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " \t  free (q);", " ", " \t  p = stringprep_utf8_to_locale (r);", " \t  free (r);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       if (args_info.punycode_encode_given)", " \t{", " \t  char encbuf[BUFSIZ];", " \t  size_t len, len2;", " ", " \t  p = stringprep_locale_to_utf8 (line);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  q = stringprep_utf8_to_ucs4 (p, -1, &len);", " \t  free (p);", " \t  if (!q)", " \t    error (EXIT_FAILURE, 0,", " \t\t   _(\"could not convert from UTF-8 to UCS-4\"));", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; i < len; i++)", " \t\tfprintf (stderr, \"input[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " ", " \t  len2 = BUFSIZ - 1;", " \t  rc = punycode_encode (len, q, NULL, &len2, encbuf);", " \t  free (q);", " \t  if (rc != PUNYCODE_SUCCESS)", " \t    error (EXIT_FAILURE, 0, _(\"punycode_encode: %s\"),", " \t\t   punycode_strerror (rc));", " ", " \t  encbuf[len2] = '\\0';", " ", " \t  p = stringprep_utf8_to_locale (encbuf);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       if (args_info.punycode_decode_given)", " \t{", " \t  size_t len;", " ", " \t  len = BUFSIZ;", " \t  q = (uint32_t *) malloc (len * sizeof (q[0]));", " \t  if (!q)", " \t    error (EXIT_FAILURE, ENOMEM, N_(\"malloc\"));", " ", " \t  rc = punycode_decode (strlen (line), line, &len, q, NULL);", " \t  if (rc != PUNYCODE_SUCCESS)", " \t    {", " \t      free (q);", " \t      error (EXIT_FAILURE, 0, _(\"punycode_decode: %s\"),", " \t\t     punycode_strerror (rc));", " \t    }", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; i < len; i++)", " \t\tfprintf (stderr, \"output[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " ", " \t  q[len] = 0;", " \t  r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL);", " \t  free (q);", " \t  if (!r)", " \t    error (EXIT_FAILURE, 0,", " \t\t   _(\"could not convert from UCS-4 to UTF-8\"));", " ", " \t  p = stringprep_utf8_to_locale (r);", " \t  free (r);", " \t  if (!r)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       if (args_info.idna_to_ascii_given)", " \t{", " \t  p = stringprep_locale_to_utf8 (line);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  q = stringprep_utf8_to_ucs4 (p, -1, NULL);", " \t  free (p);", " \t  if (!q)", " \t    error (EXIT_FAILURE, 0,", " \t\t   _(\"could not convert from UCS-4 to UTF-8\"));", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"input[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " ", " \t  rc = idna_to_ascii_4z (q, &p,", " \t\t\t\t (args_info.allow_unassigned_given ?", " \t\t\t\t  IDNA_ALLOW_UNASSIGNED : 0) |", " \t\t\t\t (args_info.usestd3asciirules_given ?", " \t\t\t\t  IDNA_USE_STD3_ASCII_RULES : 0));", " \t  free (q);", " \t  if (rc != IDNA_SUCCESS)", " \t    error (EXIT_FAILURE, 0, _(\"idna_to_ascii_4z: %s\"),", " \t\t   idna_strerror (rc));", " ", " #ifdef WITH_TLD", " \t  if (args_info.tld_flag && !args_info.no_tld_flag)", " \t    {", " \t      size_t errpos;", " ", " \t      rc = idna_to_unicode_8z4z (p, &q,", " \t\t\t\t\t (args_info.allow_unassigned_given ?", " \t\t\t\t\t  IDNA_ALLOW_UNASSIGNED : 0) |", " \t\t\t\t\t (args_info.usestd3asciirules_given ?", " \t\t\t\t\t  IDNA_USE_STD3_ASCII_RULES : 0));", " \t      if (rc != IDNA_SUCCESS)", " \t\terror (EXIT_FAILURE, 0, _(\"idna_to_unicode_8z4z (TLD): %s\"),", " \t\t       idna_strerror (rc));", " ", " \t      if (args_info.debug_given)", " \t\t{", " \t\t  size_t i;", " \t\t  for (i = 0; q[i]; i++)", " \t\t    fprintf (stderr, \"tld[%lu] = U+%04x\\n\",", " \t\t\t     (unsigned long) i, q[i]);", " \t\t}", " ", " \t      rc = tld_check_4z (q, &errpos, NULL);", " \t      free (q);", " \t      if (rc == TLD_INVALID)", " \t\terror (EXIT_FAILURE, 0, _(\"tld_check_4z (position %lu): %s\"),", " \t\t       (unsigned long) errpos, tld_strerror (rc));", " \t      if (rc != TLD_SUCCESS)", " \t\terror (EXIT_FAILURE, 0, _(\"tld_check_4z: %s\"),", " \t\t       tld_strerror (rc));", " \t    }", " #endif", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; p[i]; i++)", " \t\tfprintf (stderr, \"output[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, p[i]);", " \t    }", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       if (args_info.idna_to_unicode_given)", " \t{", " \t  p = stringprep_locale_to_utf8 (line);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  q = stringprep_utf8_to_ucs4 (p, -1, NULL);", " \t  if (!q)", " \t    {", " \t      free (p);", " \t      error (EXIT_FAILURE, 0,", " \t\t     _(\"could not convert from UCS-4 to UTF-8\"));", " \t    }", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"input[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " \t  free (q);", " ", " \t  rc = idna_to_unicode_8z4z (p, &q,", " \t\t\t\t     (args_info.allow_unassigned_given ?", " \t\t\t\t      IDNA_ALLOW_UNASSIGNED : 0) |", " \t\t\t\t     (args_info.usestd3asciirules_given ?", " \t\t\t\t      IDNA_USE_STD3_ASCII_RULES : 0));", " \t  free (p);", " \t  if (rc != IDNA_SUCCESS)", " \t    error (EXIT_FAILURE, 0, _(\"idna_to_unicode_8z4z: %s\"),", " \t\t   idna_strerror (rc));", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"output[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " \t    }", " ", " #ifdef WITH_TLD", " \t  if (args_info.tld_flag)", " \t    {", " \t      size_t errpos;", " ", " \t      rc = tld_check_4z (q, &errpos, NULL);", " \t      if (rc == TLD_INVALID)", " \t\t{", " \t\t  free (q);", " \t\t  error (EXIT_FAILURE, 0,", " \t\t\t _(\"tld_check_4z (position %lu): %s\"),", " \t\t\t (unsigned long) errpos, tld_strerror (rc));", " \t\t}", " \t      if (rc != TLD_SUCCESS)", " \t\t{", " \t\t  free (q);", " \t\t  error (EXIT_FAILURE, 0, _(\"tld_check_4z: %s\"),", " \t\t\t tld_strerror (rc));", " \t\t}", " \t    }", " #endif", " ", " \t  r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL);", " \t  free (q);", " \t  if (!r)", " \t    error (EXIT_FAILURE, 0,", " \t\t   _(\"could not convert from UTF-8 to UCS-4\"));", " ", " \t  p = stringprep_utf8_to_locale (r);", " \t  free (r);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       if (args_info.nfkc_given)", " \t{", " \t  p = stringprep_locale_to_utf8 (line);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " ", " \t      q = stringprep_utf8_to_ucs4 (p, -1, NULL);", " \t      if (!q)", " \t\t{", " \t\t  free (p);", " \t\t  error (EXIT_FAILURE, 0,", " \t\t\t _(\"could not convert from UTF-8 to UCS-4\"));", " \t\t}", " ", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"input[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " ", " \t      free (q);", " \t    }", " ", " \t  r = stringprep_utf8_nfkc_normalize (p, -1);", " \t  free (p);", " \t  if (!r)", " \t    error (EXIT_FAILURE, 0, _(\"could not do NFKC normalization\"));", " ", " \t  if (args_info.debug_given)", " \t    {", " \t      size_t i;", " ", " \t      q = stringprep_utf8_to_ucs4 (r, -1, NULL);", " \t      if (!q)", " \t\t{", " \t\t  free (r);", " \t\t  error (EXIT_FAILURE, 0,", " \t\t\t _(\"could not convert from UTF-8 to UCS-4\"));", " \t\t}", " ", " \t      for (i = 0; q[i]; i++)", " \t\tfprintf (stderr, \"output[%lu] = U+%04x\\n\",", " \t\t\t (unsigned long) i, q[i]);", " ", " \t      free (q);", " \t    }", " ", " \t  p = stringprep_utf8_to_locale (r);", " \t  free (r);", " \t  if (!p)", " \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),", " \t\t   stringprep_locale_charset ());", " ", " \t  fprintf (stdout, \"%s\\n\", p);", " ", " \t  free (p);", " \t}", " ", "       fflush (stdout);", "     }", "   while (!feof (stdin) && !ferror (stdin) && (args_info.inputs_num == 0 ||", " \t\t\t\t\t      cmdn < args_info.inputs_num));", " ", "   free (line);", " ", "   return EXIT_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_mark_err_slice_skip(dec_struct_t * ps_dec,", "                                 WORD32 num_mb_skip,", "                                 UWORD8 u1_is_idr_slice,", "                                 UWORD16 u2_frame_num,", "  pocstruct_t *ps_cur_poc,", "                                 WORD32 prev_slice_err)", " {", "     WORD32 i2_cur_mb_addr;", "     UWORD32 u1_num_mbs, u1_num_mbsNby2;", "     UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;", "     UWORD32 i2_mb_skip_run;", " ", "     UWORD32 u1_num_mbs_next, u1_end_of_row;", "  const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;", "     UWORD32 u1_slice_end;", "     UWORD32 u1_tfr_n_mb;", "     UWORD32 u1_decode_nmb;", "  dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;", "  dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", "     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;", "  deblk_mb_t *ps_cur_deblk_mb;", "  dec_mb_info_t *ps_cur_mb_info;", "  parse_pmbarams_t *ps_parse_mb_data;", "     UWORD32 u1_inter_mb_type;", "     UWORD32 u1_deblk_mb_type;", "     UWORD16 u2_total_mbs_coded;", "     UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;", "  parse_part_params_t *ps_part_info;", "     WORD32 ret;", " ", " ", "  if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)", "  {", "         ih264d_err_pic_dispbuf_mgr(ps_dec);", "  return 0;", "  }", " ", "  if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (num_mb_skip & 1))", "  {", "         num_mb_skip++;", "  }", "     ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;", "  if(prev_slice_err == 1)", "  {", "   ", "         ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;", " ", " ", "  if(!ps_dec->u1_first_slice_in_stream)", "  {", "             ih264d_end_of_pic(ps_dec, u1_is_idr_slice,", "                 ps_dec->ps_cur_slice->u2_frame_num);", "             ps_dec->s_cur_pic_poc.u2_frame_num =", "                 ps_dec->ps_cur_slice->u2_frame_num;", "  }", " ", "  {", "             WORD32 i, j, poc = 0;", " ", "             ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;", " ", "             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;", "             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;", "             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;", " ", "  if(ps_dec->ps_cur_pic != NULL)", "                 poc = ps_dec->ps_cur_pic->i4_poc + 2;", " ", "             j = -1;", "  for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)", "  {", "  if(ps_dec->ps_pps[i].u1_is_valid == TRUE)", "  {", "  if(ps_dec->ps_pps[i].ps_sps->u1_is_valid == TRUE)", "  {", "                            j = i;", "  break;", "  }", "  }", "  }", " ", " ", "              if(j == -1)", "              {", "                return ERROR_INV_SPS_PPS_T;", "                 return ERROR_INV_SLICE_HDR_T;", "              }", "  ", "               ", "  if(ps_dec->u4_pic_buf_got == 0)", "  {", "                 ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "                 ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;", "                 ps_dec->ps_cur_slice->u1_nal_unit_type = 1;", "                 ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,", "                         ps_dec->ps_cur_slice->u2_frame_num,", "  &ps_dec->ps_pps[j]);", " ", "  if(ret != OK)", "  {", "  return ret;", "  }", "  }", " ", "             ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;", " ", "             ps_dec->u4_output_present = 0;", " ", "  {", "                 ih264d_get_next_display_field(ps_dec,", "                                               ps_dec->ps_out_buffer,", "  &(ps_dec->s_disp_op));", "   ", " ", "  if(0 != ps_dec->s_disp_op.u4_error_code)", "  {", "                     ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;", "  }", "  else", "                     ps_dec->u4_output_present = 1;", "  }", " ", "  if(ps_dec->u1_separate_parse == 1)", "  {", "  if(ps_dec->u4_dec_thread_created == 0)", "  {", "                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,", "  (void *)ih264d_decode_picture_thread,", "  (void *)ps_dec);", " ", "                     ps_dec->u4_dec_thread_created = 1;", "  }", " ", "  if((ps_dec->u4_num_cores == 3) &&", "  ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)", "  && (ps_dec->u4_bs_deblk_thread_created == 0))", "  {", "                     ps_dec->u4_start_recon_deblk = 0;", "                     ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,", "  (void *)ih264d_recon_deblk_thread,", "  (void *)ps_dec);", "                     ps_dec->u4_bs_deblk_thread_created = 1;", "  }", "  }", "  }", "         ps_dec->u4_first_slice_in_pic = 0;", "  }", "  else", "  {", " ", "  dec_slice_struct_t *ps_parse_cur_slice;", "         ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;", " ", "  if(ps_dec->u1_slice_header_done", "  && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)", "  {", "  if((u1_mbaff) && (ps_dec->u4_num_mbs_cur_nmb & 1))", "  {", "                 ps_dec->u4_num_mbs_cur_nmb = ps_dec->u4_num_mbs_cur_nmb - 1;", "                 ps_dec->u2_cur_mb_addr--;", "  }", " ", "             u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;", "  if(u1_num_mbs)", "  {", "                 ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;", "  }", "  else", "  {", "  if(ps_dec->u1_separate_parse)", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info;", "  }", "  else", "  {", "                     ps_cur_mb_info = ps_dec->ps_nmb_info", "  + ps_dec->u4_num_mbs_prev_nmb - 1;", "  }", "  }", " ", "             ps_dec->u2_mby = ps_cur_mb_info->u2_mby;", "             ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;", " ", "             ps_dec->u1_mb_ngbr_availablity =", "                     ps_cur_mb_info->u1_mb_ngbr_availablity;", " ", "  if(u1_num_mbs)", "  {", "                 ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;", "                 ps_dec->u2_cur_mb_addr--;", "                 ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;", " ", "  if (ps_dec->u1_pr_sl_type == P_SLICE", "  || ps_dec->u1_pr_sl_type == B_SLICE)", "  {", "                     ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);", "                     ps_dec->ps_part = ps_dec->ps_parse_part_params;", "  }", " ", "                 u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "                 u1_end_of_row = (!u1_num_mbs_next)", "  && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "                 u1_slice_end = 1;", "                 u1_tfr_n_mb = 1;", "                 ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                     ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                     ps_dec->ps_nmb_info += u1_num_mbs;", "  }", "  else", "  {", "                     ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                             u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "  }", "                 ps_dec->u2_total_mbs_coded += u1_num_mbs;", "                 ps_dec->u1_mb_idx = 0;", "                 ps_dec->u4_num_mbs_cur_nmb = 0;", "  }", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "                 ps_dec->u1_pic_decode_done = 1;", "  return 0;", "  }", " ", "   ", "  if(ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <", "  (UWORD32)(ps_dec->u2_total_mbs_coded >> ps_slice->u1_mbaff_frame_flag))", "  {", "                 ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "                 ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", "                 ps_dec->u2_cur_slice_num++;", "                 ps_dec->ps_parse_cur_slice++;", "  }", " ", "  }", "  else", "  {", "             ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf", "  + ps_dec->u2_cur_slice_num;", "  }", "  }", " ", "   ", "   ", "   ", "  {", "         WORD32 num_entries;", "         WORD32 size;", "         UWORD8 *pu1_buf;", " ", "         num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);", "         num_entries = 2 * ((2 * num_entries) + 1);", " ", "         size = num_entries * sizeof(void *);", "         size += PAD_MAP_IDX_POC * sizeof(void *);", " ", "         pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;", "         pu1_buf += size * ps_dec->u2_cur_slice_num;", "         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;", "  }", " ", "     ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;", "     ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;", "     ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;", " ", "  if(ps_dec->ps_cur_slice->u1_field_pic_flag)", "         ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;", " ", "     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded >> u1_mbaff;", "     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;", " ", " ", "  if(ps_dec->u1_separate_parse)", "  {", "         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;", "  }", "  else", "  {", "         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;", "  }", " ", "   ", "   ", "   ", "     u1_inter_mb_type = P_MB;", "     u1_deblk_mb_type = D_INTER_MB;", " ", "     ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;", "     ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;", "     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;", "     ps_dec->ps_part = ps_dec->ps_parse_part_params;", "     ps_dec->u2_mbx =", "  (MOD(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));", "     ps_dec->u2_mby =", "  (DIV(ps_dec->ps_cur_slice->u2_first_mb_in_slice - 1, ps_dec->u2_frm_wd_in_mbs));", "     ps_dec->u2_mby <<= u1_mbaff;", " ", "   ", "   ", "   ", "     ps_dec->u1_slice_header_done = 2;", "     ps_dec->u1_qp = ps_slice->u1_slice_qp;", "     ih264d_update_qp(ps_dec, 0);", "     u1_mb_idx = ps_dec->u1_mb_idx;", "     ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "     u1_num_mbs = u1_mb_idx;", " ", "     u1_slice_end = 0;", "     u1_tfr_n_mb = 0;", "     u1_decode_nmb = 0;", "     u1_num_mbsNby2 = 0;", "     i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;", "     i2_mb_skip_run = num_mb_skip;", " ", "  while(!u1_slice_end)", "  {", "         UWORD8 u1_mb_type;", " ", "  if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)", "  break;", " ", "         ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;", "         ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;", " ", "         ps_cur_mb_info->u1_Mux = 0;", "         ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);", "         ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;", " ", "         ps_cur_mb_info->u1_end_of_slice = 0;", " ", "   ", "         ps_parse_mb_data->u1_num_part = 1;", "         ps_parse_mb_data->u1_isI_mb = 0;", " ", "   ", "   ", "   ", "   ", "  if (u1_mbaff)", "             ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", "  else", "             ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);", " ", "   ", "  if(ps_dec->u4_app_disable_deblk_frm == 0)", "  {", "             ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,", "                                              ps_dec->u1_mb_ngbr_availablity,", "                                              ps_dec->u1_cur_mb_fld_dec_flag);", "  }", " ", "   ", "         ps_dec->i1_prev_mb_qp_delta = 0;", "         ps_dec->u1_sub_mb_num = 0;", "         ps_cur_mb_info->u1_mb_type = MB_SKIP;", "         ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;", "         ps_cur_mb_info->u1_cbp = 0;", " ", "   ", "         ps_part_info = ps_dec->ps_part;", "         ps_part_info->u1_is_direct = PART_DIRECT_16x16;", "         ps_part_info->u1_sub_mb_num = 0;", "         ps_dec->ps_part++;", " ", "   ", "         ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);", " ", "         ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;", "         ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;", " ", "         i2_mb_skip_run--;", " ", "         ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;", " ", "  if (u1_mbaff)", "  {", "             ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);", "  }", " ", "   ", "   ", "   ", "         i2_cur_mb_addr++;", " ", "         u1_num_mbs++;", "         u1_num_mbsNby2++;", "         ps_parse_mb_data++;", " ", "   ", "   ", "   ", "   ", "   ", "         u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;", "         u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));", "         u1_slice_end = !i2_mb_skip_run;", "         u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row", "  || u1_slice_end;", "         u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;", "         ps_cur_mb_info->u1_end_of_slice = u1_slice_end;", " ", "  if(u1_decode_nmb)", "  {", "             ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);", "             u1_num_mbsNby2 = 0;", " ", "             ps_parse_mb_data = ps_dec->ps_parse_mb_data;", "             ps_dec->ps_part = ps_dec->ps_parse_part_params;", " ", "  if(ps_dec->u1_separate_parse)", "  {", "                 ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,", "                                      u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);", "                 ps_dec->ps_nmb_info +=  u1_num_mbs;", "  }", "  else", "  {", "                 ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,", "                                             u1_tfr_n_mb, u1_end_of_row);", "  }", "             ps_dec->u2_total_mbs_coded += u1_num_mbs;", "  if(u1_tfr_n_mb)", "                 u1_num_mbs = 0;", "             u1_mb_idx = u1_num_mbs;", "             ps_dec->u1_mb_idx = u1_num_mbs;", "  }", "  }", " ", "     ps_dec->u4_num_mbs_cur_nmb = 0;", "     ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr", "  - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;", " ", "     H264_DEC_DEBUG_PRINT(\"Mbs in slice: %d\\n\", ps_dec->ps_cur_slice->u4_mbs_in_slice);", " ", " ", "   ", "  if(ps_dec->u4_first_slice_in_pic != 0)", "  {", "         ps_dec->ps_parse_cur_slice++;", "         ps_dec->u2_cur_slice_num++;", "  }", " ", "     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;", "     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;", " ", "  if(ps_dec->u2_total_mbs_coded", "  >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)", "  {", "         ps_dec->u1_pic_decode_done = 1;", "  }", " ", "  return 0;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool CopyDirectory(const FilePath& from_path,", "                    const FilePath& to_path,", "                    bool recursive) {", "   base::ThreadRestrictions::AssertIOAllowed();", "   DCHECK(to_path.value().find('*') == std::string::npos);", "   DCHECK(from_path.value().find('*') == std::string::npos);", " ", "   char top_dir[PATH_MAX];", "   if (base::strlcpy(top_dir, from_path.value().c_str(),", "                     arraysize(top_dir)) >= arraysize(top_dir)) {", "     return false;", "   }", " ", "   FilePath real_to_path = to_path;", "   if (PathExists(real_to_path)) {", "     if (!AbsolutePath(&real_to_path))", "       return false;", "   } else {", "     real_to_path = real_to_path.DirName();", "     if (!AbsolutePath(&real_to_path))", "       return false;", "   }", "   FilePath real_from_path = from_path;", "   if (!AbsolutePath(&real_from_path))", "     return false;", "   if (real_to_path.value().size() >= real_from_path.value().size() &&", "       real_to_path.value().compare(0, real_from_path.value().size(),", "       real_from_path.value()) == 0)", "     return false;", " ", "   bool success = true;", "   int traverse_type = FileEnumerator::FILES | FileEnumerator::SHOW_SYM_LINKS;", "   if (recursive)", "     traverse_type |= FileEnumerator::DIRECTORIES;", "   FileEnumerator traversal(from_path, recursive, traverse_type);", " ", "   FileEnumerator::FindInfo info;", "   FilePath current = from_path;", "   if (stat(from_path.value().c_str(), &info.stat) < 0) {", "     DLOG(ERROR) << \"CopyDirectory() couldn't stat source directory: \"", "                 << from_path.value() << \" errno = \" << errno;", "     success = false;", "   }", "   struct stat to_path_stat;", "   FilePath from_path_base = from_path;", "   if (recursive && stat(to_path.value().c_str(), &to_path_stat) == 0 &&", "       S_ISDIR(to_path_stat.st_mode)) {", "     from_path_base = from_path.DirName();", "   }", " ", "    DCHECK(recursive || S_ISDIR(info.stat.st_mode));", "  ", "    while (success && !current.empty()) {", "    std::string suffix(&current.value().c_str()[from_path_base.value().size()]);", "    if (!suffix.empty()) {", "      DCHECK_EQ('/', suffix[0]);", "      suffix.erase(0, 1);", "      ", "      ", "     FilePath target_path(to_path);", "     if (from_path_base != current) {", "       if (!from_path_base.AppendRelativePath(current, &target_path)) {", "         success = false;", "         break;", "       }", "      }", "    const FilePath target_path = to_path.Append(suffix);", "  ", "      if (S_ISDIR(info.stat.st_mode)) {", "        if (mkdir(target_path.value().c_str(), info.stat.st_mode & 01777) != 0 &&", "           errno != EEXIST) {", "         DLOG(ERROR) << \"CopyDirectory() couldn't create directory: \"", "                     << target_path.value() << \" errno = \" << errno;", "         success = false;", "       }", "     } else if (S_ISREG(info.stat.st_mode)) {", "       if (!CopyFile(current, target_path)) {", "         DLOG(ERROR) << \"CopyDirectory() couldn't create file: \"", "                     << target_path.value();", "         success = false;", "       }", "     } else {", "       DLOG(WARNING) << \"CopyDirectory() skipping non-regular file: \"", "                     << current.value();", "     }", " ", "     current = traversal.Next();", "     traversal.GetFindInfo(&info);", "   }", " ", "   return success;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int64_t TensorByteSize(const TensorProto& t) {", "", "int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();", "return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());", "}"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": [" static Image *ReadJPEGImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   char", "     value[MaxTextExtent];", " ", "   const char", "     *option;", " ", "   ErrorManager", "     error_manager;", " ", "   Image", "     *image;", " ", "   IndexPacket", "     index;", " ", "   JSAMPLE", "     *volatile jpeg_pixels;", " ", "   JSAMPROW", "     scanline[1];", " ", "   MagickBooleanType", "     debug,", "     status;", " ", "   MagickSizeType", "     number_pixels;", " ", "   MemoryInfo", "     *memory_info;", " ", "   register ssize_t", "     i;", " ", "   struct jpeg_decompress_struct", "     jpeg_info;", " ", "   struct jpeg_error_mgr", "     jpeg_error;", " ", "   register JSAMPLE", "     *p;", " ", "   size_t", "     units;", " ", "   ssize_t", "     y;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   debug=IsEventLogging();", "   (void) debug;", "   image=AcquireImage(image_info);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   (void) ResetMagickMemory(&error_manager,0,sizeof(error_manager));", "   (void) ResetMagickMemory(&jpeg_info,0,sizeof(jpeg_info));", "   (void) ResetMagickMemory(&jpeg_error,0,sizeof(jpeg_error));", "   jpeg_info.err=jpeg_std_error(&jpeg_error);", "   jpeg_info.err->emit_message=(void (*)(j_common_ptr,int)) JPEGWarningHandler;", "   jpeg_info.err->error_exit=(void (*)(j_common_ptr)) JPEGErrorHandler;", "   memory_info=(MemoryInfo *) NULL;", "   error_manager.image=image;", "   if (setjmp(error_manager.error_recovery) != 0)", "     {", "       jpeg_destroy_decompress(&jpeg_info);", "       if (error_manager.profile != (StringInfo *) NULL)", "         error_manager.profile=DestroyStringInfo(error_manager.profile);", "       (void) CloseBlob(image);", "       number_pixels=(MagickSizeType) image->columns*image->rows;", "       if (number_pixels != 0)", "         return(GetFirstImageInList(image));", "       InheritException(exception,&image->exception);", "       return(DestroyImage(image));", "     }", "   jpeg_info.client_data=(void *) &error_manager;", "   jpeg_create_decompress(&jpeg_info);", "   JPEGSourceManager(&jpeg_info,image);", "   jpeg_set_marker_processor(&jpeg_info,JPEG_COM,ReadComment);", "   option=GetImageOption(image_info,\"profile:skip\");", "   if (IsOptionMember(\"ICC\",option) == MagickFalse)", "     jpeg_set_marker_processor(&jpeg_info,ICC_MARKER,ReadICCProfile);", "   if (IsOptionMember(\"IPTC\",option) == MagickFalse)", "     jpeg_set_marker_processor(&jpeg_info,IPTC_MARKER,ReadIPTCProfile);", "   for (i=1; i < 16; i++)", "     if ((i != 2) && (i != 13) && (i != 14))", "       if (IsOptionMember(\"APP\",option) == MagickFalse)", "         jpeg_set_marker_processor(&jpeg_info,(int) (JPEG_APP0+i),ReadProfile);", "   i=(ssize_t) jpeg_read_header(&jpeg_info,TRUE);", "   if ((image_info->colorspace == YCbCrColorspace) ||", "       (image_info->colorspace == Rec601YCbCrColorspace) ||", "       (image_info->colorspace == Rec709YCbCrColorspace))", "     jpeg_info.out_color_space=JCS_YCbCr;", "    ", "   units=0;", "   if ((jpeg_info.saw_JFIF_marker != 0) && (jpeg_info.X_density != 1) &&", "       (jpeg_info.Y_density != 1))", "     {", "       image->x_resolution=(double) jpeg_info.X_density;", "       image->y_resolution=(double) jpeg_info.Y_density;", "       units=(size_t) jpeg_info.density_unit;", "     }", "   if (units == 1)", "     image->units=PixelsPerInchResolution;", "   if (units == 2)", "     image->units=PixelsPerCentimeterResolution;", "   number_pixels=(MagickSizeType) image->columns*image->rows;", "   option=GetImageOption(image_info,\"jpeg:size\");", "   if ((option != (const char *) NULL) &&", "       (jpeg_info.out_color_space != JCS_YCbCr))", "     {", "       double", "         scale_factor;", " ", "       GeometryInfo", "         geometry_info;", " ", "       MagickStatusType", "         flags;", " ", "        ", "       flags=ParseGeometry(option,&geometry_info);", "       if ((flags & SigmaValue) == 0)", "         geometry_info.sigma=geometry_info.rho;", "       jpeg_calc_output_dimensions(&jpeg_info);", "       image->magick_columns=jpeg_info.output_width;", "       image->magick_rows=jpeg_info.output_height;", "       scale_factor=1.0;", "       if (geometry_info.rho != 0.0)", "         scale_factor=jpeg_info.output_width/geometry_info.rho;", "       if ((geometry_info.sigma != 0.0) &&", "           (scale_factor > (jpeg_info.output_height/geometry_info.sigma)))", "         scale_factor=jpeg_info.output_height/geometry_info.sigma;", "       jpeg_info.scale_num=1U;", "       jpeg_info.scale_denom=(unsigned int) scale_factor;", "       jpeg_calc_output_dimensions(&jpeg_info);", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Scale factor: %.20g\",(double) scale_factor);", "     }", " #if (JPEG_LIB_VERSION >= 61) && defined(D_PROGRESSIVE_SUPPORTED)", " #if defined(D_LOSSLESS_SUPPORTED)", "   image->interlace=jpeg_info.process == JPROC_PROGRESSIVE ?", "     JPEGInterlace : NoInterlace;", "   image->compression=jpeg_info.process == JPROC_LOSSLESS ?", "     LosslessJPEGCompression : JPEGCompression;", "   if (jpeg_info.data_precision > 8)", "     (void) ThrowMagickException(exception,GetMagickModule(),OptionError,", "       \"12-bit JPEG not supported. Reducing pixel data to 8 bits\",\"`%s'\",", "       image->filename);", "   if (jpeg_info.data_precision == 16)", "     jpeg_info.data_precision=12;", " #else", "   image->interlace=jpeg_info.progressive_mode != 0 ? JPEGInterlace :", "     NoInterlace;", "   image->compression=JPEGCompression;", " #endif", " #else", "   image->compression=JPEGCompression;", "   image->interlace=JPEGInterlace;", " #endif", "   option=GetImageOption(image_info,\"jpeg:colors\");", "   if (option != (const char *) NULL)", "     {", "        ", "       jpeg_info.quantize_colors=TRUE;", "       jpeg_info.desired_number_of_colors=(int) StringToUnsignedLong(option);", "     }", "   option=GetImageOption(image_info,\"jpeg:block-smoothing\");", "   if (option != (const char *) NULL)", "     jpeg_info.do_block_smoothing=IsStringTrue(option) != MagickFalse ? TRUE :", "       FALSE;", "   jpeg_info.dct_method=JDCT_FLOAT;", "   option=GetImageOption(image_info,\"jpeg:dct-method\");", "   if (option != (const char *) NULL)", "     switch (*option)", "     {", "       case 'D':", "       case 'd':", "       {", "         if (LocaleCompare(option,\"default\") == 0)", "           jpeg_info.dct_method=JDCT_DEFAULT;", "         break;", "       }", "       case 'F':", "       case 'f':", "       {", "         if (LocaleCompare(option,\"fastest\") == 0)", "           jpeg_info.dct_method=JDCT_FASTEST;", "         if (LocaleCompare(option,\"float\") == 0)", "           jpeg_info.dct_method=JDCT_FLOAT;", "         break;", "       }", "       case 'I':", "       case 'i':", "       {", "         if (LocaleCompare(option,\"ifast\") == 0)", "           jpeg_info.dct_method=JDCT_IFAST;", "         if (LocaleCompare(option,\"islow\") == 0)", "           jpeg_info.dct_method=JDCT_ISLOW;", "         break;", "       }", "     }", "   option=GetImageOption(image_info,\"jpeg:fancy-upsampling\");", "   if (option != (const char *) NULL)", "     jpeg_info.do_fancy_upsampling=IsStringTrue(option) != MagickFalse ? TRUE :", "       FALSE;", "   (void) jpeg_start_decompress(&jpeg_info);", "   image->columns=jpeg_info.output_width;", "   image->rows=jpeg_info.output_height;", "   image->depth=(size_t) jpeg_info.data_precision;", "   switch (jpeg_info.out_color_space)", "   {", "     case JCS_RGB:", "     default:", "     {", "       (void) SetImageColorspace(image,sRGBColorspace);", "       break;", "     }", "     case JCS_GRAYSCALE:", "     {", "       (void) SetImageColorspace(image,GRAYColorspace);", "       break;", "     }", "     case JCS_YCbCr:", "     {", "       (void) SetImageColorspace(image,YCbCrColorspace);", "       break;", "     }", "     case JCS_CMYK:", "     {", "       (void) SetImageColorspace(image,CMYKColorspace);", "       break;", "     }", "   }", "   if (IsITUFaxImage(image) != MagickFalse)", "     {", "       (void) SetImageColorspace(image,LabColorspace);", "       jpeg_info.out_color_space=JCS_YCbCr;", "     }", "    if (option != (const char *) NULL)", "      if (AcquireImageColormap(image,StringToUnsignedLong(option)) == MagickFalse)", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "  if ((jpeg_info.output_components == 1) &&", "      (jpeg_info.quantize_colors == 0))", "   if ((jpeg_info.output_components == 1) && (jpeg_info.quantize_colors == 0))", "      {", "        size_t", "          colors;", " ", "       colors=(size_t) GetQuantumRange(image->depth)+1;", "       if (AcquireImageColormap(image,colors) == MagickFalse)", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     }", "   if (image->debug != MagickFalse)", "     {", "       if (image->interlace != NoInterlace)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Interlace: progressive\");", "       else", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"Interlace: nonprogressive\");", "       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Data precision: %d\",", "         (int) jpeg_info.data_precision);", "       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"Geometry: %dx%d\",", "         (int) jpeg_info.output_width,(int) jpeg_info.output_height);", "     }", "   JPEGSetImageQuality(&jpeg_info,image);", "   JPEGSetImageSamplingFactor(&jpeg_info,image);", "   (void) FormatLocaleString(value,MaxTextExtent,\"%.20g\",(double)", "     jpeg_info.out_color_space);", "   (void) SetImageProperty(image,\"jpeg:colorspace\",value);", "   if (image_info->ping != MagickFalse)", "     {", "       jpeg_destroy_decompress(&jpeg_info);", "       (void) CloseBlob(image);", "       return(GetFirstImageInList(image));", "     }", "   status=SetImageExtent(image,image->columns,image->rows);", "   if (status == MagickFalse)", "     {", "       jpeg_destroy_decompress(&jpeg_info);", "       InheritException(exception,&image->exception);", "       return(DestroyImageList(image));", "     }", "   if ((jpeg_info.output_components != 1) &&", "       (jpeg_info.output_components != 3) && (jpeg_info.output_components != 4))", "     {", "       jpeg_destroy_decompress(&jpeg_info);", "       ThrowReaderException(CorruptImageError,\"ImageTypeNotSupported\");", "     }", "   memory_info=AcquireVirtualMemory((size_t) image->columns,", "     jpeg_info.output_components*sizeof(*jpeg_pixels));", "   if (memory_info == (MemoryInfo *) NULL)", "     {", "       jpeg_destroy_decompress(&jpeg_info);", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     }", "   jpeg_pixels=(JSAMPLE *) GetVirtualMemoryBlob(memory_info);", "    ", "   if (setjmp(error_manager.error_recovery) != 0)", "     {", "       if (memory_info != (MemoryInfo *) NULL)", "         memory_info=RelinquishVirtualMemory(memory_info);", "       jpeg_destroy_decompress(&jpeg_info);", "       (void) CloseBlob(image);", "       number_pixels=(MagickSizeType) image->columns*image->rows;", "       if (number_pixels != 0)", "         return(GetFirstImageInList(image));", "       return(DestroyImage(image));", "     }", "   if (jpeg_info.quantize_colors != 0)", "     {", "       image->colors=(size_t) jpeg_info.actual_number_of_colors;", "       if (jpeg_info.out_color_space == JCS_GRAYSCALE)", "         for (i=0; i < (ssize_t) image->colors; i++)", "         {", "           image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);", "           image->colormap[i].green=image->colormap[i].red;", "           image->colormap[i].blue=image->colormap[i].red;", "           image->colormap[i].opacity=OpaqueOpacity;", "         }", "       else", "         for (i=0; i < (ssize_t) image->colors; i++)", "         {", "           image->colormap[i].red=ScaleCharToQuantum(jpeg_info.colormap[0][i]);", "           image->colormap[i].green=ScaleCharToQuantum(jpeg_info.colormap[1][i]);", "           image->colormap[i].blue=ScaleCharToQuantum(jpeg_info.colormap[2][i]);", "           image->colormap[i].opacity=OpaqueOpacity;", "         }", "     }", "   scanline[0]=(JSAMPROW) jpeg_pixels;", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     register IndexPacket", "       *magick_restrict indexes;", " ", "     register ssize_t", "       x;", " ", "     register PixelPacket", "       *magick_restrict q;", " ", "     if (jpeg_read_scanlines(&jpeg_info,scanline,1) != 1)", "       {", "         (void) ThrowMagickException(exception,GetMagickModule(),", "           CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);", "         continue;", "       }", "     p=jpeg_pixels;", "     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "     if (q == (PixelPacket *) NULL)", "       break;", "     indexes=GetAuthenticIndexQueue(image);", "     if (jpeg_info.data_precision > 8)", "       {", "         unsigned short", "           scale;", " ", "         scale=65535/(unsigned short) GetQuantumRange((size_t)", "           jpeg_info.data_precision);", "         if (jpeg_info.output_components == 1)", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             size_t", "               pixel;", " ", "             pixel=(size_t) (scale*GETJSAMPLE(*p));", "             index=ConstrainColormapIndex(image,pixel);", "             SetPixelIndex(indexes+x,index);", "             SetPixelRGBO(q,image->colormap+(ssize_t) index);", "             p++;", "             q++;", "           }", "         else", "           if (image->colorspace != CMYKColorspace)", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               SetPixelRed(q,ScaleShortToQuantum((unsigned short)", "                 (scale*GETJSAMPLE(*p++))));", "               SetPixelGreen(q,ScaleShortToQuantum((unsigned short)", "                 (scale*GETJSAMPLE(*p++))));", "               SetPixelBlue(q,ScaleShortToQuantum((unsigned short)", "                 (scale*GETJSAMPLE(*p++))));", "               SetPixelOpacity(q,OpaqueOpacity);", "               q++;", "             }", "           else", "             for (x=0; x < (ssize_t) image->columns; x++)", "             {", "               SetPixelCyan(q,QuantumRange-ScaleShortToQuantum(", "                 (unsigned short) (scale*GETJSAMPLE(*p++))));", "               SetPixelMagenta(q,QuantumRange-ScaleShortToQuantum(", "                 (unsigned short) (scale*GETJSAMPLE(*p++))));", "               SetPixelYellow(q,QuantumRange-ScaleShortToQuantum(", "                 (unsigned short) (scale*GETJSAMPLE(*p++))));", "               SetPixelBlack(indexes+x,QuantumRange-ScaleShortToQuantum(", "                 (unsigned short) (scale*GETJSAMPLE(*p++))));", "               SetPixelOpacity(q,OpaqueOpacity);", "               q++;", "             }", "       }", "     else", "       if (jpeg_info.output_components == 1)", "         for (x=0; x < (ssize_t) image->columns; x++)", "         {", "           index=ConstrainColormapIndex(image,(size_t) GETJSAMPLE(*p));", "           SetPixelIndex(indexes+x,index);", "           SetPixelRGBO(q,image->colormap+(ssize_t) index);", "           p++;", "           q++;", "         }", "       else", "         if (image->colorspace != CMYKColorspace)", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelRed(q,ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelGreen(q,ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelBlue(q,ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelOpacity(q,OpaqueOpacity);", "             q++;", "           }", "         else", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             SetPixelCyan(q,QuantumRange-ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelMagenta(q,QuantumRange-ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelYellow(q,QuantumRange-ScaleCharToQuantum((unsigned char)", "               GETJSAMPLE(*p++)));", "             SetPixelBlack(indexes+x,QuantumRange-ScaleCharToQuantum(", "               (unsigned char) GETJSAMPLE(*p++)));", "             SetPixelOpacity(q,OpaqueOpacity);", "             q++;", "           }", "     if (SyncAuthenticPixels(image,exception) == MagickFalse)", "       break;", "     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "       image->rows);", "     if (status == MagickFalse)", "       {", "         jpeg_abort_decompress(&jpeg_info);", "         break;", "       }", "   }", "   if (status != MagickFalse)", "     {", "       error_manager.finished=MagickTrue;", "       if (setjmp(error_manager.error_recovery) == 0)", "         (void) jpeg_finish_decompress(&jpeg_info);", "     }", "    ", "   jpeg_destroy_decompress(&jpeg_info);", "   memory_info=RelinquishVirtualMemory(memory_info);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)", "  {", "  \t ", " \t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;", " \tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);", " \tint nr_regs = sizeof(*regs) / sizeof(__u32);", " \tu32 off;", " ", " \t ", " \toff = core_reg_offset_from_id(reg->id);", " \tif (off >= nr_regs ||", "  \t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)", "  \t\treturn -ENOENT;", "  ", " \tif (validate_core_offset(reg))", " \t\treturn -EINVAL;", " ", "  \tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))", "  \t\treturn -EFAULT;", "  ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize)", " {", "     SCPRContext *s = avctx->priv_data;", "     GetByteContext *gb = &s->gb;", "     int cx = 0, cx1 = 0, k = 0, clr = 0;", "     int run, r, g, b, off, y = 0, x = 0, z, ret;", "     unsigned backstep = linesize - avctx->width;", "     const int cxshift = s->cxshift;", "     unsigned lx, ly, ptype;", " ", "     reinit_tables(s);", "     bytestream2_skip(gb, 2);", "     init_rangecoder(&s->rc, gb);", " ", "     while (k < avctx->width + 1) {", "         ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);", "         if (ret < 0)", "             return ret;", " ", "         cx1 = (cx << 6) & 0xFC0;", "         cx = r >> cxshift;", "         ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);", "         if (ret < 0)", "             return ret;", " ", "         cx1 = (cx << 6) & 0xFC0;", "         cx = g >> cxshift;", "         ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);", "         if (ret < 0)", "             return ret;", " ", "         cx1 = (cx << 6) & 0xFC0;", "         cx = b >> cxshift;", " ", "         ret = decode_value(s, s->run_model[0], 256, 400, &run);", "         if (ret < 0)", "             return ret;", " ", "          clr = (b << 16) + (g << 8) + r;", "          k += run;", "          while (run-- > 0) {", "             if (y >= avctx->height)", "                 return AVERROR_INVALIDDATA;", " ", "              dst[y * linesize + x] = clr;", "              lx = x;", "              ly = y;", "             x++;", "             if (x >= avctx->width) {", "                 x = 0;", "                 y++;", "             }", "         }", "     }", "     off = -linesize - 1;", "     ptype = 0;", " ", "     while (x < avctx->width && y < avctx->height) {", "         ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);", "         if (ret < 0)", "             return ret;", "         if (ptype == 0) {", "             ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);", "             if (ret < 0)", "                 return ret;", " ", "             cx1 = (cx << 6) & 0xFC0;", "             cx = r >> cxshift;", "             ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);", "             if (ret < 0)", "                 return ret;", " ", "             cx1 = (cx << 6) & 0xFC0;", "             cx = g >> cxshift;", "             ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);", "             if (ret < 0)", "                 return ret;", " ", "             clr = (b << 16) + (g << 8) + r;", "         }", "         if (ptype > 5)", "             return AVERROR_INVALIDDATA;", "         ret = decode_value(s, s->run_model[ptype], 256, 400, &run);", "         if (ret < 0)", "             return ret;", " ", "         switch (ptype) {", "         case 0:", "             while (run-- > 0) {", "                 if (y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", " ", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 1:", "             while (run-- > 0) {", "                 if (y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", " ", "                 dst[y * linesize + x] = dst[ly * linesize + lx];", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             clr = dst[ly * linesize + lx];", "             break;", "         case 2:", "             while (run-- > 0) {", "                 if (y < 1 || y >= avctx->height)", "                     return AVERROR_INVALIDDATA;", " ", "                 clr = dst[y * linesize + x + off + 1];", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 4:", "             while (run-- > 0) {", "                 uint8_t *odst = (uint8_t *)dst;", " ", "                 if (y < 1 || y >= avctx->height ||", "                     (y == 1 && x == 0))", "                     return AVERROR_INVALIDDATA;", " ", "                 if (x == 0) {", "                     z = backstep;", "                 } else {", "                     z = 0;", "                 }", " ", "                 r = odst[(ly * linesize + lx) * 4] +", "                     odst[((y * linesize + x) + off - z) * 4 + 4] -", "                     odst[((y * linesize + x) + off - z) * 4];", "                 g = odst[(ly * linesize + lx) * 4 + 1] +", "                     odst[((y * linesize + x) + off - z) * 4 + 5] -", "                     odst[((y * linesize + x) + off - z) * 4 + 1];", "                 b = odst[(ly * linesize + lx) * 4 + 2] +", "                     odst[((y * linesize + x) + off - z) * 4 + 6] -", "                     odst[((y * linesize + x) + off - z) * 4 + 2];", "                 clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF);", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         case 5:", "             while (run-- > 0) {", "                 if (y < 1 || y >= avctx->height ||", "                     (y == 1 && x == 0))", "                     return AVERROR_INVALIDDATA;", " ", "                 if (x == 0) {", "                     z = backstep;", "                 } else {", "                     z = 0;", "                 }", " ", "                 clr = dst[y * linesize + x + off - z];", "                 dst[y * linesize + x] = clr;", "                 lx = x;", "                 ly = y;", "                 x++;", "                 if (x >= avctx->width) {", "                     x = 0;", "                     y++;", "                 }", "             }", "             break;", "         }", " ", "         if (avctx->bits_per_coded_sample == 16) {", "             cx1 = (clr & 0x3F00) >> 2;", "             cx = (clr & 0xFFFFFF) >> 16;", "         } else {", "             cx1 = (clr & 0xFC00) >> 4;", "             cx = (clr & 0xFFFFFF) >> 18;", "         }", "     }", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xsltShallowCopyElem(xsltTransformContextPtr ctxt, xmlNodePtr node,", " \t\t    xmlNodePtr insert, int isLRE)", " {", "     xmlNodePtr copy;", " ", "     if ((node->type == XML_DTD_NODE) || (insert == NULL))", " \treturn(NULL);", "     if ((node->type == XML_TEXT_NODE) ||", " \t(node->type == XML_CDATA_SECTION_NODE))", " \treturn(xsltCopyText(ctxt, insert, node, 0));", " ", "     copy = xmlDocCopyNode(node, insert->doc, 0);", "      if (copy != NULL) {", "  \tcopy->doc = ctxt->output;", "  \tcopy = xsltAddChild(insert, copy);", "         if (copy == NULL) {", "              xsltTransformError(ctxt, NULL, node,", "                 \"xsltShallowCopyElem: copy failed\\n\");", "              return (copy);", "         }", "  ", "  \tif (node->type == XML_ELEMENT_NODE) {", "  \t     ", " \t    if (node->nsDef != NULL) {", " \t\t ", " \t\tif (isLRE)", " \t\t    xsltCopyNamespaceList(ctxt, copy, node->nsDef);", " \t\telse", " \t\t    xsltCopyNamespaceListInternal(copy, node->nsDef);", " \t    }", " ", " \t     ", " \t    if (node->ns != NULL) {", " \t\tif (isLRE) {", " \t\t     ", " \t\t    copy->ns = xsltGetNamespace(ctxt, node, node->ns, copy);", " \t\t} else {", " \t\t    copy->ns = xsltGetSpecialNamespace(ctxt,", " \t\t\tnode, node->ns->href, node->ns->prefix, copy);", " ", " \t\t}", " \t    } else if ((insert->type == XML_ELEMENT_NODE) &&", " \t\t       (insert->ns != NULL))", " \t    {", " \t\t ", " \t\txsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);", " \t    }", " \t}", "     } else {", " \txsltTransformError(ctxt, NULL, node,", " \t\t\"xsltShallowCopyElem: copy %s failed\\n\", node->name);", "     }", "     return(copy);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,", " \t\t\t      struct msghdr *msg, size_t len)", " {", " \tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);", " \tstruct sock *sk = sock->sk;", " \tstruct net *net = sock_net(sk);", " \tstruct unix_sock *u = unix_sk(sk);", " \tstruct sockaddr_un *sunaddr = msg->msg_name;", " \tstruct sock *other = NULL;", " \tint namelen = 0;  ", " \tint err;", " \tunsigned int hash;", " \tstruct sk_buff *skb;", " \tlong timeo;", " \tstruct scm_cookie tmp_scm;", " \tint max_level;", " \tint data_len = 0;", " ", "  \tif (NULL == siocb->scm)", "  \t\tsiocb->scm = &tmp_scm;", "  \twait_for_unix_gc();", "\terr = scm_send(sock, msg, siocb->scm);", " \terr = scm_send(sock, msg, siocb->scm, false);", "  \tif (err < 0)", "  \t\treturn err;", "  ", " \terr = -EOPNOTSUPP;", " \tif (msg->msg_flags&MSG_OOB)", " \t\tgoto out;", " ", " \tif (msg->msg_namelen) {", " \t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);", " \t\tif (err < 0)", " \t\t\tgoto out;", " \t\tnamelen = err;", " \t} else {", " \t\tsunaddr = NULL;", " \t\terr = -ENOTCONN;", " \t\tother = unix_peer_get(sk);", " \t\tif (!other)", " \t\t\tgoto out;", " \t}", " ", " \tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr", " \t    && (err = unix_autobind(sock)) != 0)", " \t\tgoto out;", " ", " \terr = -EMSGSIZE;", " \tif (len > sk->sk_sndbuf - 32)", " \t\tgoto out;", " ", " \tif (len > SKB_MAX_ALLOC)", " \t\tdata_len = min_t(size_t,", " \t\t\t\t len - SKB_MAX_ALLOC,", " \t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);", " ", " \tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,", " \t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err);", " \tif (skb == NULL)", " \t\tgoto out;", " ", " \terr = unix_scm_to_skb(siocb->scm, skb, true);", " \tif (err < 0)", " \t\tgoto out_free;", " \tmax_level = err + 1;", " \tunix_get_secdata(siocb->scm, skb);", " ", " \tskb_put(skb, len - data_len);", " \tskb->data_len = data_len;", " \tskb->len = len;", " \terr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);", " \tif (err)", " \t\tgoto out_free;", " ", " \ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);", " ", " restart:", " \tif (!other) {", " \t\terr = -ECONNRESET;", " \t\tif (sunaddr == NULL)", " \t\t\tgoto out_free;", " ", " \t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,", " \t\t\t\t\thash, &err);", " \t\tif (other == NULL)", " \t\t\tgoto out_free;", " \t}", " ", " \tif (sk_filter(other, skb) < 0) {", " \t\t ", " \t\terr = len;", " \t\tgoto out_free;", " \t}", " ", " \tunix_state_lock(other);", " \terr = -EPERM;", " \tif (!unix_may_send(sk, other))", " \t\tgoto out_unlock;", " ", " \tif (sock_flag(other, SOCK_DEAD)) {", " \t\t ", " \t\tunix_state_unlock(other);", " \t\tsock_put(other);", " ", " \t\terr = 0;", " \t\tunix_state_lock(sk);", " \t\tif (unix_peer(sk) == other) {", " \t\t\tunix_peer(sk) = NULL;", " \t\t\tunix_state_unlock(sk);", " ", " \t\t\tunix_dgram_disconnected(sk, other);", " \t\t\tsock_put(other);", " \t\t\terr = -ECONNREFUSED;", " \t\t} else {", " \t\t\tunix_state_unlock(sk);", " \t\t}", " ", " \t\tother = NULL;", " \t\tif (err)", " \t\t\tgoto out_free;", " \t\tgoto restart;", " \t}", " ", " \terr = -EPIPE;", " \tif (other->sk_shutdown & RCV_SHUTDOWN)", " \t\tgoto out_unlock;", " ", " \tif (sk->sk_type != SOCK_SEQPACKET) {", " \t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);", " \t\tif (err)", " \t\t\tgoto out_unlock;", " \t}", " ", " \tif (unix_peer(other) != sk && unix_recvq_full(other)) {", " \t\tif (!timeo) {", " \t\t\terr = -EAGAIN;", " \t\t\tgoto out_unlock;", " \t\t}", " ", " \t\ttimeo = unix_wait_for_peer(other, timeo);", " ", " \t\terr = sock_intr_errno(timeo);", " \t\tif (signal_pending(current))", " \t\t\tgoto out_free;", " ", " \t\tgoto restart;", " \t}", " ", " \tif (sock_flag(other, SOCK_RCVTSTAMP))", " \t\t__net_timestamp(skb);", " \tmaybe_add_creds(skb, sock, other);", " \tskb_queue_tail(&other->sk_receive_queue, skb);", " \tif (max_level > unix_sk(other)->recursion_level)", " \t\tunix_sk(other)->recursion_level = max_level;", " \tunix_state_unlock(other);", " \tother->sk_data_ready(other, len);", " \tsock_put(other);", " \tscm_destroy(siocb->scm);", " \treturn len;", " ", " out_unlock:", " \tunix_state_unlock(other);", " out_free:", " \tkfree_skb(skb);", " out:", " \tif (other)", " \t\tsock_put(other);", " \tscm_destroy(siocb->scm);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {", "  const size_t kNGroupsOffset = 12;", "  const size_t kFirstGroupOffset = 16;", " ", "      const size_t kGroupSize = 12;", "      const size_t kStartCharCodeOffset = 0;", "      const size_t kEndCharCodeOffset = 4;", "     const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;   ", "      ", "      if (kFirstGroupOffset > size) {", "          return false;", "      }", "      uint32_t nGroups = readU32(data, kNGroupsOffset);", "    if (kFirstGroupOffset + nGroups * kGroupSize > size) {", "     if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) {", "          return false;", "      }", "      for (uint32_t i = 0; i < nGroups; i++) {", "  uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;", "  uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);", "  uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);", "         addRange(coverage, start, end + 1);  ", "  }", "  return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)", " {", "     zip_uint8_t buf[CDENTRYSIZE];", "     zip_uint16_t dostime, dosdate;", "     zip_uint32_t size, variable_size;", "     zip_uint16_t filename_len, comment_len, ef_len;", " ", "     bool from_buffer = (buffer != NULL);", " ", "     size = local ? LENTRYSIZE : CDENTRYSIZE;", " ", "     if (buffer) {", "         if (_zip_buffer_left(buffer) < size) {", "             zip_error_set(error, ZIP_ER_NOZIP, 0);", "             return -1;", "         }", "     }", "     else {", "         if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {", "             return -1;", "         }", "     }", " ", "     if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {", " \tzip_error_set(error, ZIP_ER_NOZIP, 0);", "         if (!from_buffer) {", "             _zip_buffer_free(buffer);", "         }", " \treturn -1;", "     }", " ", "      ", " ", "     _zip_dirent_init(zde);", "     if (!local)", " \tzde->version_madeby = _zip_buffer_get_16(buffer);", "     else", " \tzde->version_madeby = 0;", "     zde->version_needed = _zip_buffer_get_16(buffer);", "     zde->bitflags = _zip_buffer_get_16(buffer);", "     zde->comp_method = _zip_buffer_get_16(buffer);", " ", "      ", "     dostime = _zip_buffer_get_16(buffer);", "     dosdate = _zip_buffer_get_16(buffer);", "     zde->last_mod = _zip_d2u_time(dostime, dosdate);", " ", "     zde->crc = _zip_buffer_get_32(buffer);", "     zde->comp_size = _zip_buffer_get_32(buffer);", "     zde->uncomp_size = _zip_buffer_get_32(buffer);", " ", "     filename_len = _zip_buffer_get_16(buffer);", "     ef_len = _zip_buffer_get_16(buffer);", " ", "     if (local) {", " \tcomment_len = 0;", " \tzde->disk_number = 0;", " \tzde->int_attrib = 0;", " \tzde->ext_attrib = 0;", " \tzde->offset = 0;", "     } else {", " \tcomment_len = _zip_buffer_get_16(buffer);", " \tzde->disk_number = _zip_buffer_get_16(buffer);", " \tzde->int_attrib = _zip_buffer_get_16(buffer);", " \tzde->ext_attrib = _zip_buffer_get_32(buffer);", " \tzde->offset = _zip_buffer_get_32(buffer);", "     }", " ", "     if (!_zip_buffer_ok(buffer)) {", "         zip_error_set(error, ZIP_ER_INTERNAL, 0);", "         if (!from_buffer) {", "             _zip_buffer_free(buffer);", "         }", "         return -1;", "     }", " ", "     if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {", " \tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {", " \t     ", " \t    zde->encryption_method = ZIP_EM_UNKNOWN;", " \t}", " \telse {", " \t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;", " \t}", "     }", "     else {", " \tzde->encryption_method = ZIP_EM_NONE;", "     }", " ", "     zde->filename = NULL;", "     zde->extra_fields = NULL;", "     zde->comment = NULL;", " ", "     variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;", " ", "     if (from_buffer) {", "         if (_zip_buffer_left(buffer) < variable_size) {", "             zip_error_set(error, ZIP_ER_INCONS, 0);", "             return -1;", "         }", "     }", "     else {", "         _zip_buffer_free(buffer);", " ", "         if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {", "             return -1;", "         }", "     }", " ", "     if (filename_len) {", " \tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);", "         if (!zde->filename) {", "             if (zip_error_code_zip(error) == ZIP_ER_EOF) {", "                 zip_error_set(error, ZIP_ER_INCONS, 0);", "             }", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", " \t    return -1;", "         }", " ", " \tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {", " \t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {", " \t\tzip_error_set(error, ZIP_ER_INCONS, 0);", "                 if (!from_buffer) {", "                     _zip_buffer_free(buffer);", "                 }", " \t\treturn -1;", " \t    }", " \t}", "     }", " ", "     if (ef_len) {", " \tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);", " ", "         if (ef == NULL) {", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", " \t    return -1;", "         }", "         if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {", " \t    free(ef);", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", " \t    return -1;", " \t}", " \tfree(ef);", " \tif (local)", " \t    zde->local_extra_fields_read = 1;", "     }", " ", "     if (comment_len) {", " \tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);", "         if (!zde->comment) {", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", " \t    return -1;", "         }", " \tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {", " \t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {", " \t\tzip_error_set(error, ZIP_ER_INCONS, 0);", "                 if (!from_buffer) {", "                     _zip_buffer_free(buffer);", "                 }", " \t\treturn -1;", " \t    }", " \t}", "     }", " ", "     zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);", "     zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);", " ", "      ", " ", "     if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {", " \tzip_uint16_t got_len;", "         zip_buffer_t *ef_buffer;", " \tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);", " \t ", "         if (ef == NULL) {", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", " \t    return -1;", "         }", " ", "         if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {", "             zip_error_set(error, ZIP_ER_MEMORY, 0);", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", "             return -1;", "         }", " ", " \tif (zde->uncomp_size == ZIP_UINT32_MAX)", " \t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);", " \telse if (local) {", " \t     ", "             (void)_zip_buffer_skip(ef_buffer, 8);  ", " \t}", " \tif (zde->comp_size == ZIP_UINT32_MAX)", " \t    zde->comp_size = _zip_buffer_get_64(ef_buffer);", " \tif (!local) {", " \t    if (zde->offset == ZIP_UINT32_MAX)", " \t\tzde->offset = _zip_buffer_get_64(ef_buffer);", " \t    if (zde->disk_number == ZIP_UINT16_MAX)", " \t\tzde->disk_number = _zip_buffer_get_32(buffer);", " \t}", " ", "         if (!_zip_buffer_eof(ef_buffer)) {", "             zip_error_set(error, ZIP_ER_INCONS, 0);", "             _zip_buffer_free(ef_buffer);", "             if (!from_buffer) {", "                 _zip_buffer_free(buffer);", "             }", "             return -1;", "         }", "         _zip_buffer_free(ef_buffer);", "     }", " ", "     if (!_zip_buffer_ok(buffer)) {", "         zip_error_set(error, ZIP_ER_INTERNAL, 0);", "         if (!from_buffer) {", "             _zip_buffer_free(buffer);", "         }", "         return -1;", "     }", "     if (!from_buffer) {", "         _zip_buffer_free(buffer);", "     }", " ", "      ", "     if (zde->offset > ZIP_INT64_MAX) {", " \tzip_error_set(error, ZIP_ER_SEEK, EFBIG);", " \treturn -1;", "      }", "  ", "      if (!_zip_dirent_process_winzip_aes(zde, error)) {", "\tif (!from_buffer) {", "\t    _zip_buffer_free(buffer);", "\t}", "  \treturn -1;", "      }", "  ", "     zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);", " ", "     return (zip_int64_t)(size + variable_size);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" status_t OMXNodeInstance::updateGraphicBufferInMeta(", "         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,", "         OMX::buffer_id buffer) {", "  Mutex::Autolock autoLock(mLock);", "     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);", " ", "      return updateGraphicBufferInMeta_l(", "              portIndex, graphicBuffer, buffer, header,", "            portIndex == kPortIndexOutput  );", "             true  );", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" int writepng_init(mainprog_info *mainprog_ptr)", " {", "     png_structp  png_ptr;  ", "     png_infop  info_ptr;", "  int color_type, interlace_type;", " ", " ", "  ", "       ", "  ", "    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,", "     png_ptr = png_create_write_struct(png_get_libpng_ver(NULL), mainprog_ptr,", "        writepng_error_handler, NULL);", "      if (!png_ptr)", "          return 4;    ", " ", "     info_ptr = png_create_info_struct(png_ptr);", "  if (!info_ptr) {", "         png_destroy_write_struct(&png_ptr, NULL);", "  return 4;  ", "  }", " ", " ", "   ", " ", "  if (setjmp(mainprog_ptr->jmpbuf)) {", "         png_destroy_write_struct(&png_ptr, &info_ptr);", "  return 2;", "  }", " ", " ", "   ", " ", "     png_init_io(png_ptr, mainprog_ptr->outfile);", " ", " ", "   ", " ", "     png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);", "  ", " ", " ", "   ", " ", "  if (mainprog_ptr->pnmtype == 5)", "         color_type = PNG_COLOR_TYPE_GRAY;", "  else if (mainprog_ptr->pnmtype == 6)", "         color_type = PNG_COLOR_TYPE_RGB;", "  else if (mainprog_ptr->pnmtype == 8)", "         color_type = PNG_COLOR_TYPE_RGB_ALPHA;", "  else {", "         png_destroy_write_struct(&png_ptr, &info_ptr);", "  return 11;", "  }", " ", "     interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :", "                                                PNG_INTERLACE_NONE;", " ", "     png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,", "       mainprog_ptr->sample_depth, color_type, interlace_type,", "       PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);", " ", "  if (mainprog_ptr->gamma > 0.0)", "         png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);", " ", "  if (mainprog_ptr->have_bg) {  ", "         png_color_16  background;", " ", "         background.red = mainprog_ptr->bg_red;", "         background.green = mainprog_ptr->bg_green;", "         background.blue = mainprog_ptr->bg_blue;", "         png_set_bKGD(png_ptr, info_ptr, &background);", "  }", " ", "  if (mainprog_ptr->have_time) {", "         png_time  modtime;", " ", "  png_convert_from_time_t(&modtime, mainprog_ptr->modtime);", "         png_set_tIME(png_ptr, info_ptr, &modtime);", "  }", " ", "  if (mainprog_ptr->have_text) {", "         png_text  text[6];", "  int  num_text = 0;", " ", "  if (mainprog_ptr->have_text & TEXT_TITLE) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"Title\";", "             text[num_text].text = mainprog_ptr->title;", "  ++num_text;", "  }", "  if (mainprog_ptr->have_text & TEXT_AUTHOR) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"Author\";", "             text[num_text].text = mainprog_ptr->author;", "  ++num_text;", "  }", "  if (mainprog_ptr->have_text & TEXT_DESC) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"Description\";", "             text[num_text].text = mainprog_ptr->desc;", "  ++num_text;", "  }", "  if (mainprog_ptr->have_text & TEXT_COPY) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"Copyright\";", "             text[num_text].text = mainprog_ptr->copyright;", "  ++num_text;", "  }", "  if (mainprog_ptr->have_text & TEXT_EMAIL) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"E-mail\";", "             text[num_text].text = mainprog_ptr->email;", "  ++num_text;", "  }", "  if (mainprog_ptr->have_text & TEXT_URL) {", "             text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;", "             text[num_text].key = \"URL\";", "             text[num_text].text = mainprog_ptr->url;", "  ++num_text;", "  }", "         png_set_text(png_ptr, info_ptr, text, num_text);", "  }", " ", " ", "   ", " ", "     png_write_info(png_ptr, info_ptr);", " ", " ", "   ", " ", " ", "   ", " ", "     png_set_packing(png_ptr);", "  ", " ", " ", "   ", " ", "     mainprog_ptr->png_ptr = png_ptr;", "     mainprog_ptr->info_ptr = info_ptr;", " ", " ", "   ", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static struct port_buffer *get_inbuf(struct port *port)", "{", "struct port_buffer *buf;", "unsigned int len;", "", "if (port->inbuf)", "return port->inbuf;", "", "buf = virtqueue_get_buf(port->in_vq, &len);", "if (buf) {", "buf->len = len;", "buf->offset = 0;", "port->stats.bytes_received += len;", "}", "return buf;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["   InstalledBubbleContent(Browser* browser,", "                          const Extension* extension,", "                          ExtensionInstalledBubble::BubbleType type,", "                          SkBitmap* icon,", "                          ExtensionInstalledBubble* bubble)", "       : browser_(browser),", "         extension_id_(extension->id()),", "         bubble_(bubble),", "         type_(type),", "         info_(NULL) {", "     ResourceBundle& rb = ResourceBundle::GetSharedInstance();", "     const gfx::Font& font = rb.GetFont(ResourceBundle::BaseFont);", " ", "     gfx::Size size(icon->width(), icon->height());", "     if (size.width() > kIconSize || size.height() > kIconSize)", "       size = gfx::Size(kIconSize, kIconSize);", "     icon_ = new views::ImageView();", "     icon_->SetImageSize(size);", "     icon_->SetImage(*icon);", "     AddChildView(icon_);", " ", "      string16 extension_name = UTF8ToUTF16(extension->name());", "      base::i18n::AdjustStringForLocaleDirection(&extension_name);", "      heading_ = new views::Label(l10n_util::GetStringFUTF16(", "        IDS_EXTENSION_INSTALLED_HEADING,", "        extension_name,", "        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME)));", "         IDS_EXTENSION_INSTALLED_HEADING, extension_name));", "      heading_->SetFont(rb.GetFont(ResourceBundle::MediumFont));", "      heading_->SetMultiLine(true);", "      heading_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);", "     AddChildView(heading_);", " ", "     switch (type_) {", "       case ExtensionInstalledBubble::PAGE_ACTION: {", "         info_ = new views::Label(l10n_util::GetStringUTF16(", "             IDS_EXTENSION_INSTALLED_PAGE_ACTION_INFO));", "         info_->SetFont(font);", "         info_->SetMultiLine(true);", "         info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);", "         AddChildView(info_);", "         break;", "       }", "       case ExtensionInstalledBubble::OMNIBOX_KEYWORD: {", "         info_ = new views::Label(l10n_util::GetStringFUTF16(", "             IDS_EXTENSION_INSTALLED_OMNIBOX_KEYWORD_INFO,", "             UTF8ToUTF16(extension->omnibox_keyword())));", "         info_->SetFont(font);", "         info_->SetMultiLine(true);", "         info_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);", "         AddChildView(info_);", "         break;", "       }", "       case ExtensionInstalledBubble::APP: {", "         views::Link* link = new views::Link(", "             l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_APP_INFO));", "         link->set_listener(this);", "         manage_ = link;", "         manage_->SetFont(font);", "         manage_->SetMultiLine(true);", "         manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);", "         AddChildView(manage_);", "         break;", "       }", "       default:", "         break;", "     }", " ", "     if (type_ != ExtensionInstalledBubble::APP) {", "       manage_ = new views::Label(", "           l10n_util::GetStringUTF16(IDS_EXTENSION_INSTALLED_MANAGE_INFO));", "       manage_->SetFont(font);", "       manage_->SetMultiLine(true);", "       manage_->SetHorizontalAlignment(views::Label::ALIGN_LEFT);", "       AddChildView(manage_);", "     }", " ", "     close_button_ = new views::ImageButton(this);", "     close_button_->SetImage(views::CustomButton::BS_NORMAL,", "         rb.GetBitmapNamed(IDR_CLOSE_BAR));", "     close_button_->SetImage(views::CustomButton::BS_HOT,", "         rb.GetBitmapNamed(IDR_CLOSE_BAR_H));", "     close_button_->SetImage(views::CustomButton::BS_PUSHED,", "         rb.GetBitmapNamed(IDR_CLOSE_BAR_P));", "     AddChildView(close_button_);", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> methodThatRequiresAllArgsAndThrowsCallback(const v8::Arguments& args)", "  {", "      INC_STATS(\"DOM.TestObj.methodThatRequiresAllArgsAndThrows\");", "      if (args.Length() < 2)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "      TestObj* imp = V8TestObj::toNative(args.Holder());", "      ExceptionCode ec = 0;", "      {", "     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, strArg, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));", "     EXCEPTION_BLOCK(TestObj*, objArg, V8TestObj::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)) ? V8TestObj::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined))) : 0);", "     RefPtr<TestObj> result = imp->methodThatRequiresAllArgsAndThrows(strArg, objArg, ec);", "     if (UNLIKELY(ec))", "         goto fail;", "     return toV8(result.release(), args.GetIsolate());", "     }", "     fail:", "     V8Proxy::setDOMException(ec, args.GetIsolate());", "     return v8::Handle<v8::Value>();", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,", "                              const uint8_t *src, int src_size)", " {", "     int width, height;", "     int hdr, zsize, npal, tidx = -1, ret;", "     int i, j;", "     const uint8_t *src_end = src + src_size;", "     uint8_t pal[768], transp[3];", "     uLongf dlen = (c->tile_width + 1) * c->tile_height;", "     int sub_type;", "     int nblocks, cblocks, bstride;", "     int bits, bitbuf, coded;", "     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +", "                    tile_y * c->tile_height * c->framebuf_stride;", " ", "     if (src_size < 2)", "         return AVERROR_INVALIDDATA;", " ", "     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);", "     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);", " ", "     hdr = *src++;", "     sub_type = hdr >> 5;", "     if (sub_type == 0) {", "         int j;", "         memcpy(transp, src, 3);", "         src += 3;", "         for (j = 0; j < height; j++, dst += c->framebuf_stride)", "             for (i = 0; i < width; i++)", "                 memcpy(dst + i * 3, transp, 3);", "         return 0;", "     } else if (sub_type == 1) {", "         return jpg_decode_data(&c->jc, width, height, src, src_end - src,", "                                dst, c->framebuf_stride, NULL, 0, 0, 0);", "     }", " ", "     if (sub_type != 2) {", "         memcpy(transp, src, 3);", "         src += 3;", "     }", "     npal = *src++ + 1;", "     memcpy(pal, src, npal * 3); src += npal * 3;", "     if (sub_type != 2) {", "         for (i = 0; i < npal; i++) {", "             if (!memcmp(pal + i * 3, transp, 3)) {", "                tidx = i;", "                break;", "             }", "         }", "     }", " ", "     if (src_end - src < 2)", "          return 0;", "      zsize = (src[0] << 8) | src[1]; src += 2;", "  ", "    if (src_end - src < zsize)", "     if (src_end - src < zsize + (sub_type != 2))", "          return AVERROR_INVALIDDATA;", "  ", "      ret = uncompress(c->kempf_buf, &dlen, src, zsize);", "     if (ret)", "         return AVERROR_INVALIDDATA;", "     src += zsize;", " ", "     if (sub_type == 2) {", "         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,", "                           NULL, 0, width, height, pal, npal, tidx);", "         return 0;", "     }", " ", "     nblocks = *src++ + 1;", "     cblocks = 0;", "     bstride = FFALIGN(width, 16) >> 4;", "     bits = 0;", "      for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {", "          for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {", "              if (!bits) {", "                 if (src >= src_end)", "                     return AVERROR_INVALIDDATA;", "                  bitbuf = *src++;", "                  bits   = 8;", "              }", "             coded = bitbuf & 1;", "             bits--;", "             bitbuf >>= 1;", "             cblocks += coded;", "             if (cblocks > nblocks)", "                 return AVERROR_INVALIDDATA;", "             c->kempf_flags[j + i * bstride] = coded;", "         }", "     }", " ", "     memset(c->jpeg_tile, 0, c->tile_stride * height);", "     jpg_decode_data(&c->jc, width, height, src, src_end - src,", "                     c->jpeg_tile, c->tile_stride,", "                     c->kempf_flags, bstride, nblocks, 0);", " ", "     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,", "                       c->jpeg_tile, c->tile_stride,", "                       width, height, pal, npal, tidx);", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void GDataCacheMetadataMap::Initialize(", "     const std::vector<FilePath>& cache_paths) {", "    AssertOnSequencedWorkerPool();", "  ", "    if (cache_paths.size() < GDataCache::NUM_CACHE_TYPES) {", "    LOG(ERROR) << \"Size of cache_paths is invalid.\";", "     DLOG(ERROR) << \"Size of cache_paths is invalid.\";", "      return;", "    }", "  ", "  if (!GDataCache::CreateCacheDirectories(cache_paths))", "   if (!CreateCacheDirectories(cache_paths))", "      return;", "  ", "   if (!ChangeFilePermissions(cache_paths[GDataCache::CACHE_TYPE_PERSISTENT],", "                              S_IRWXU | S_IXGRP | S_IXOTH))", "     return;", " ", "   DVLOG(1) << \"Scanning directories\";", "  ", "  ResourceIdToFilePathMap persistent_file_map;", "  ScanCacheDirectory(cache_paths,", "                     GDataCache::CACHE_TYPE_PERSISTENT,", "                     &cache_map_,", "                     &persistent_file_map);", "  ResourceIdToFilePathMap tmp_file_map;", "  ScanCacheDirectory(cache_paths,", "                     GDataCache::CACHE_TYPE_TMP,", "                     &cache_map_,", "                     &tmp_file_map);", "  ResourceIdToFilePathMap pinned_file_map;", "  ScanCacheDirectory(cache_paths,", "                     GDataCache::CACHE_TYPE_PINNED,", "                     &cache_map_,", "                     &pinned_file_map);", "  ResourceIdToFilePathMap outgoing_file_map;", "  ScanCacheDirectory(cache_paths,", "                     GDataCache::CACHE_TYPE_OUTGOING,", "                     &cache_map_,", "                     &outgoing_file_map);", "  RemoveInvalidFilesFromPersistentDirectory(persistent_file_map,", "                                            outgoing_file_map,", "                                            &cache_map_);", "   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_PERSISTENT,", "                      &cache_map_);", "   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_TMP, &cache_map_);", " ", "    ", "    ", "    ", "    ", "    ", "    ", "    ", "   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_PINNED, &cache_map_);", "   ScanCacheDirectory(cache_paths, GDataCache::CACHE_TYPE_OUTGOING, &cache_map_);", " ", "    DVLOG(1) << \"Directory scan finished\";", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" spnego_gss_pseudo_random(OM_uint32 *minor_status,", " \t\t\t gss_ctx_id_t context,", " \t\t\t int prf_key,", " \t\t\t const gss_buffer_t prf_in,", " \t\t\t ssize_t desired_output_len,", "  \t\t\t gss_buffer_t prf_out)", "  {", "  \tOM_uint32 ret;", " \tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;", " ", " \tif (sc->ctx_handle == GSS_C_NO_CONTEXT)", " \t\treturn (GSS_S_NO_CONTEXT);", " ", "  \tret = gss_pseudo_random(minor_status,", "\t\t\t\tcontext,", " \t\t\t\tsc->ctx_handle,", "  \t\t\t\tprf_key,", "  \t\t\t\tprf_in,", "  \t\t\t\tdesired_output_len,", " \t\t\t\tprf_out);", "         return (ret);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)", " {", "  int i;", " ", "   ", "  for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)", "  {", "   ", "  if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)", "  {", "   ", "  if (check_a2dp_ready(common) == 0)", " ", "                  break;", "  ", "              ERROR(\"error : a2dp not ready, wait 250 ms and retry\");", "            usleep(250000);", "             TEMP_FAILURE_RETRY(usleep(250000));", "              skt_disconnect(common->ctrl_fd);", "              common->ctrl_fd = AUDIO_SKT_DISCONNECTED;", "          }", "  ", "           ", "        usleep(250000);", "         TEMP_FAILURE_RETRY(usleep(250000));", "      }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)", "{", "unsigned char l, n = 0;", "char callsign[11];", "", "do {", "switch (*p & 0xC0) {", "case 0x00:", "p   += 2;", "n   += 2;", "len -= 2;", "break;", "", "case 0x40:", "p   += 3;", "n   += 3;", "len -= 3;", "break;", "", "case 0x80:", "p   += 4;", "n   += 4;", "len -= 4;", "break;", "", "case 0xC0:", "l = p[1];", "if (*p == FAC_CCITT_DEST_NSAP) {", "memcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);", "memcpy(callsign, p + 12,   l - 10);", "callsign[l - 10] = '\\0';", "asc2ax(&facilities->source_call, callsign);", "}", "if (*p == FAC_CCITT_SRC_NSAP) {", "memcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);", "memcpy(callsign, p + 12, l - 10);", "callsign[l - 10] = '\\0';", "asc2ax(&facilities->dest_call, callsign);", "}", "p   += l + 2;", "n   += l + 2;", "len -= l + 2;", "break;", "}", "} while (*p != 0x00 && len > 0);", "", "return n;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void UrlData::MergeFrom(const scoped_refptr<UrlData>& other) {", "   if (ValidateDataOrigin(other->data_origin_)) {", "     DCHECK(thread_checker_.CalledOnValidThread());", "     valid_until_ = std::max(valid_until_, other->valid_until_);", "     set_length(other->length_);", "     cacheable_ |= other->cacheable_;", "     range_supported_ |= other->range_supported_;", "     if (last_modified_.is_null()) {", "        last_modified_ = other->last_modified_;", "      }", "      bytes_read_from_cache_ += other->bytes_read_from_cache_;", "    set_has_opaque_data(other->has_opaque_data_);", "      ", "     set_is_cors_cross_origin(other->is_cors_cross_origin_);", "      multibuffer()->MergeFrom(other->multibuffer());", "    }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" void DevToolsDataSource::StartDataRequest(", "     const std::string& path,", "     const content::ResourceRequestInfo::WebContentsGetter& wc_getter,", "     const content::URLDataSource::GotDataCallback& callback) {", "   std::string bundled_path_prefix(chrome::kChromeUIDevToolsBundledPath);", "   bundled_path_prefix += \"/\";", "   if (base::StartsWith(path, bundled_path_prefix,", "                        base::CompareCase::INSENSITIVE_ASCII)) {", "     StartBundledDataRequest(path.substr(bundled_path_prefix.length()),", "                             callback);", "     return;", "   }", " ", "   std::string empty_path_prefix(chrome::kChromeUIDevToolsBlankPath);", "   if (base::StartsWith(path, empty_path_prefix,", "                        base::CompareCase::INSENSITIVE_ASCII)) {", "     callback.Run(new base::RefCountedStaticMemory());", "     return;", "   }", " ", "   std::string remote_path_prefix(chrome::kChromeUIDevToolsRemotePath);", "   remote_path_prefix += \"/\";", "   if (base::StartsWith(path, remote_path_prefix,", "                        base::CompareCase::INSENSITIVE_ASCII)) {", "     GURL url(kRemoteFrontendBase + path.substr(remote_path_prefix.length()));", " ", "     CHECK_EQ(url.host(), kRemoteFrontendDomain);", "     if (url.is_valid() && DevToolsUIBindings::IsValidRemoteFrontendURL(url)) {", "       StartRemoteDataRequest(url, callback);", "     } else {", "       DLOG(ERROR) << \"Refusing to load invalid remote front-end URL\";", "       callback.Run(new base::RefCountedStaticMemory(kHttpNotFound,", "                                                     strlen(kHttpNotFound)));", "     }", "     return;", "   }", " ", "   std::string custom_frontend_url =", "       base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(", "           switches::kCustomDevtoolsFrontend);", " ", "   if (custom_frontend_url.empty()) {", "     callback.Run(NULL);", "     return;", "   }", " ", "   std::string custom_path_prefix(chrome::kChromeUIDevToolsCustomPath);", "   custom_path_prefix += \"/\";", " ", "   if (base::StartsWith(path, custom_path_prefix,", "                         base::CompareCase::INSENSITIVE_ASCII)) {", "      GURL url = GURL(custom_frontend_url +", "                      path.substr(custom_path_prefix.length()));", "     DCHECK(url.is_valid());", "      StartCustomDataRequest(url, callback);", "      return;", "    }", " ", "   callback.Run(NULL);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet,", "char *buf, u_int8_t client_hash) {", "u_int16_t offset = 22, buf_out_len = 0;", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "offset += 4;", "", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "", "strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);", "buf[buf_out_len++] = ';';", "offset += len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "offset += 4 + len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "buf[buf_out_len++] = ';';", "offset += len;", "} else", "offset += 4 + len;", "", "", "if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)", "goto invalid_payload;", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "offset += len;", "} else", "offset += 4 + len;", "", "", "len = ntohl(*(u_int32_t*)&packet->payload[offset]);", "", "if(!client_hash) {", "offset += 4;", "", "if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))", "goto invalid_payload;", "", "strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);", "buf_out_len += len;", "offset += len;", "} else", "offset += 4 + len;", "", "", "", "", "", "#ifdef SSH_DEBUG", "printf(\"[SSH] %s\\n\", buf);", "#endif", "", "return(buf_out_len);", "", "invalid_payload:", "", "#ifdef SSH_DEBUG", "printf(\"[SSH] Invalid packet payload\\n\");", "#endif", "", "return(0);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,", "const char *option,const char *arg1n,const char *arg2n)", "{", "const char", "*arg1,", "*arg2;", "", "Image", "*new_images;", "", "MagickStatusType", "status;", "", "ssize_t", "parse;", "", "#define _image_info     (cli_wand->wand.image_info)", "#define _images         (cli_wand->wand.images)", "#define _exception      (cli_wand->wand.exception)", "#define _draw_info      (cli_wand->draw_info)", "#define _quantize_info  (cli_wand->quantize_info)", "#define _process_flags  (cli_wand->process_flags)", "#define _option_type    ((CommandOptionFlags) cli_wand->command->flags)", "#define IfNormalOp      (*option=='-')", "#define IfPlusOp        (*option!='-')", "#define IsNormalOp      IfNormalOp ? MagickTrue : MagickFalse", "", "assert(cli_wand != (MagickCLI *) NULL);", "assert(cli_wand->signature == MagickWandSignature);", "assert(cli_wand->wand.signature == MagickWandSignature);", "assert(_images != (Image *) NULL);", "", "if (cli_wand->wand.debug != MagickFalse)", "(void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),", "\"- List Operator: %s \\\"%s\\\" \\\"%s\\\"\", option,", "arg1n == (const char *) NULL ? \"null\" : arg1n,", "arg2n == (const char *) NULL ? \"null\" : arg2n);", "", "arg1 = arg1n;", "arg2 = arg2n;", "", "", "if ( (((_process_flags & ProcessInterpretProperities) != 0 )", "|| ((_option_type & AlwaysInterpretArgsFlag) != 0)", ")  && ((_option_type & NeverInterpretArgsFlag) == 0) ) {", "", "if (arg1n != (char *) NULL) {", "arg1=InterpretImageProperties(_image_info,_images,arg1n,_exception);", "if (arg1 == (char *) NULL) {", "CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);", "arg1=arg1n;", "}", "}", "if (arg2n != (char *) NULL) {", "arg2=InterpretImageProperties(_image_info,_images,arg2n,_exception);", "if (arg2 == (char *) NULL) {", "CLIWandException(OptionWarning,\"InterpretPropertyFailure\",option);", "arg2=arg2n;", "}", "}", "}", "#undef _process_flags", "#undef _option_type", "", "status=MagickTrue;", "new_images=NewImageList();", "", "switch (*(option+1))", "{", "case 'a':", "{", "if (LocaleCompare(\"append\",option+1) == 0)", "{", "new_images=AppendImages(_images,IsNormalOp,_exception);", "break;", "}", "if (LocaleCompare(\"average\",option+1) == 0)", "{", "CLIWandWarnReplaced(\"-evaluate-sequence Mean\");", "(void) CLIListOperatorImages(cli_wand,\"-evaluate-sequence\",\"Mean\",", "NULL);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'c':", "{", "if (LocaleCompare(\"channel-fx\",option+1) == 0)", "{", "new_images=ChannelFxImage(_images,arg1,_exception);", "break;", "}", "if (LocaleCompare(\"clut\",option+1) == 0)", "{", "Image", "*clut_image;", "", "", "", "", "", "new_images=RemoveFirstImageFromList(&_images);", "clut_image=RemoveLastImageFromList(&_images);", "", "if (clut_image == (Image *) NULL)", "break;", "(void) ClutImage(new_images,clut_image,new_images->interpolate,", "_exception);", "clut_image=DestroyImage(clut_image);", "break;", "}", "if (LocaleCompare(\"coalesce\",option+1) == 0)", "{", "new_images=CoalesceImages(_images,_exception);", "break;", "}", "if (LocaleCompare(\"combine\",option+1) == 0)", "{", "parse=(ssize_t) _images->colorspace;", "if (_images->number_channels < GetImageListLength(_images))", "parse=sRGBColorspace;", "if ( IfPlusOp )", "parse=ParseCommandOption(MagickColorspaceOptions,MagickFalse,arg1);", "if (parse < 0)", "CLIWandExceptArgBreak(OptionError,\"UnrecognizedColorspace\",option,", "arg1);", "new_images=CombineImages(_images,(ColorspaceType) parse,_exception);", "break;", "}", "if (LocaleCompare(\"compare\",option+1) == 0)", "{", "double", "distortion;", "", "Image", "*image,", "*reconstruct_image;", "", "MetricType", "metric;", "", "", "", "", "", "image=RemoveFirstImageFromList(&_images);", "reconstruct_image=RemoveFirstImageFromList(&_images);", "", "if (reconstruct_image == (Image *) NULL)", "{", "image=DestroyImage(image);", "break;", "}", "metric=UndefinedErrorMetric;", "option=GetImageOption(_image_info,\"metric\");", "if (option != (const char *) NULL)", "metric=(MetricType) ParseCommandOption(MagickMetricOptions,", "MagickFalse,option);", "new_images=CompareImages(image,reconstruct_image,metric,&distortion,", "_exception);", "(void) distortion;", "reconstruct_image=DestroyImage(reconstruct_image);", "image=DestroyImage(image);", "break;", "}", "if (LocaleCompare(\"complex\",option+1) == 0)", "{", "parse=ParseCommandOption(MagickComplexOptions,MagickFalse,arg1);", "if (parse < 0)", "CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",", "option,arg1);", "new_images=ComplexImages(_images,(ComplexOperator) parse,_exception);", "break;", "}", "if (LocaleCompare(\"composite\",option+1) == 0)", "{", "CompositeOperator", "compose;", "", "const char*", "value;", "", "MagickBooleanType", "clip_to_self;", "", "Image", "*mask_image,", "*source_image;", "", "RectangleInfo", "geometry;", "", "", "value=GetImageOption(_image_info,\"compose\");", "if (value == (const char *) NULL)", "compose=OverCompositeOp;", "else", "compose=(CompositeOperator) ParseCommandOption(MagickComposeOptions,", "MagickFalse,value);", "", "", "clip_to_self=GetCompositeClipToSelf(compose);", "value=GetImageOption(_image_info,\"compose:clip-to-self\");", "if (value != (const char *) NULL)", "clip_to_self=IsStringTrue(value);", "value=GetImageOption(_image_info,\"compose:outside-overlay\");", "if (value != (const char *) NULL)", "clip_to_self=IsStringFalse(value);", "", "new_images=RemoveFirstImageFromList(&_images);", "source_image=RemoveFirstImageFromList(&_images);", "if (source_image == (Image *) NULL)", "break;", "", "", "if (source_image->geometry != (char *) NULL)", "{", "RectangleInfo", "resize_geometry;", "", "(void) ParseRegionGeometry(source_image,source_image->geometry,", "&resize_geometry,_exception);", "if ((source_image->columns != resize_geometry.width) ||", "(source_image->rows != resize_geometry.height))", "{", "Image", "*resize_image;", "", "resize_image=ResizeImage(source_image,resize_geometry.width,", "resize_geometry.height,source_image->filter,_exception);", "if (resize_image != (Image *) NULL)", "{", "source_image=DestroyImage(source_image);", "source_image=resize_image;", "}", "}", "}", "SetGeometry(source_image,&geometry);", "(void) ParseAbsoluteGeometry(source_image->geometry,&geometry);", "GravityAdjustGeometry(new_images->columns,new_images->rows,", "new_images->gravity, &geometry);", "mask_image=RemoveFirstImageFromList(&_images);", "if (mask_image == (Image *) NULL)", "status&=CompositeImage(new_images,source_image,compose,clip_to_self,", "geometry.x,geometry.y,_exception);", "else", "{", "if ((compose == DisplaceCompositeOp) ||", "(compose == DistortCompositeOp))", "{", "status&=CompositeImage(source_image,mask_image,", "CopyGreenCompositeOp,MagickTrue,0,0,_exception);", "status&=CompositeImage(new_images,source_image,compose,", "clip_to_self,geometry.x,geometry.y,_exception);", "}", "else", "{", "Image", "*clone_image;", "", "clone_image=CloneImage(new_images,0,0,MagickTrue,_exception);", "if (clone_image == (Image *) NULL)", "break;", "status&=CompositeImage(new_images,source_image,compose,", "clip_to_self,geometry.x,geometry.y,_exception);", "status&=CompositeImage(new_images,mask_image,", "CopyAlphaCompositeOp,MagickTrue,0,0,_exception);", "status&=CompositeImage(clone_image,new_images,OverCompositeOp,", "clip_to_self,0,0,_exception);", "new_images=DestroyImageList(new_images);", "new_images=clone_image;", "}", "mask_image=DestroyImage(mask_image);", "}", "source_image=DestroyImage(source_image);", "break;", "}", "if (LocaleCompare(\"copy\",option+1) == 0)", "{", "Image", "*source_image;", "", "OffsetInfo", "offset;", "", "RectangleInfo", "geometry;", "", "", "", "", "if (IsGeometry(arg1) == MagickFalse)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "if (IsGeometry(arg2) == MagickFalse)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "(void) ParsePageGeometry(_images,arg2,&geometry,_exception);", "offset.x=geometry.x;", "offset.y=geometry.y;", "source_image=_images;", "if (source_image->next != (Image *) NULL)", "source_image=source_image->next;", "(void) ParsePageGeometry(source_image,arg1,&geometry,_exception);", "(void) CopyImagePixels(_images,source_image,&geometry,&offset,", "_exception);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'd':", "{", "if (LocaleCompare(\"deconstruct\",option+1) == 0)", "{", "CLIWandWarnReplaced(\"-layer CompareAny\");", "(void) CLIListOperatorImages(cli_wand,\"-layer\",\"CompareAny\",NULL);", "break;", "}", "if (LocaleCompare(\"delete\",option+1) == 0)", "{", "if (IfNormalOp)", "DeleteImages(&_images,arg1,_exception);", "else", "DeleteImages(&_images,\"-1\",_exception);", "break;", "}", "if (LocaleCompare(\"duplicate\",option+1) == 0)", "{", "if (IfNormalOp)", "{", "const char", "*p;", "", "size_t", "number_duplicates;", "", "if (IsGeometry(arg1) == MagickFalse)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,", "arg1);", "number_duplicates=(size_t) StringToLong(arg1);", "p=strchr(arg1,',');", "if (p == (const char *) NULL)", "new_images=DuplicateImages(_images,number_duplicates,\"-1\",", "_exception);", "else", "new_images=DuplicateImages(_images,number_duplicates,p,", "_exception);", "}", "else", "new_images=DuplicateImages(_images,1,\"-1\",_exception);", "AppendImageToList(&_images, new_images);", "new_images=(Image *) NULL;", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'e':", "{", "if (LocaleCompare(\"evaluate-sequence\",option+1) == 0)", "{", "parse=ParseCommandOption(MagickEvaluateOptions,MagickFalse,arg1);", "if (parse < 0)", "CLIWandExceptArgBreak(OptionError,\"UnrecognizedEvaluateOperator\",", "option,arg1);", "new_images=EvaluateImages(_images,(MagickEvaluateOperator) parse,", "_exception);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'f':", "{", "if (LocaleCompare(\"fft\",option+1) == 0)", "{", "new_images=ForwardFourierTransformImage(_images,IsNormalOp,", "_exception);", "break;", "}", "if (LocaleCompare(\"flatten\",option+1) == 0)", "{", "", "(void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);", "break;", "}", "if (LocaleCompare(\"fx\",option+1) == 0)", "{", "new_images=FxImage(_images,arg1,_exception);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'h':", "{", "if (LocaleCompare(\"hald-clut\",option+1) == 0)", "{", "", "", "", "Image", "*hald_image;", "", "new_images=RemoveFirstImageFromList(&_images);", "hald_image=RemoveLastImageFromList(&_images);", "if (hald_image == (Image *) NULL)", "break;", "(void) HaldClutImage(new_images,hald_image,_exception);", "hald_image=DestroyImage(hald_image);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'i':", "{", "if (LocaleCompare(\"ift\",option+1) == 0)", "{", "Image", "*magnitude_image,", "*phase_image;", "", "magnitude_image=RemoveFirstImageFromList(&_images);", "phase_image=RemoveFirstImageFromList(&_images);", "", "if (phase_image == (Image *) NULL)", "break;", "new_images=InverseFourierTransformImage(magnitude_image,phase_image,", "IsNormalOp,_exception);", "magnitude_image=DestroyImage(magnitude_image);", "phase_image=DestroyImage(phase_image);", "break;", "}", "if (LocaleCompare(\"insert\",option+1) == 0)", "{", "Image", "*insert_image,", "*index_image;", "", "ssize_t", "index;", "", "if (IfNormalOp && (IsGeometry(arg1) == MagickFalse))", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "index=0;", "insert_image=RemoveLastImageFromList(&_images);", "if (IfNormalOp)", "index=(ssize_t) StringToLong(arg1);", "index_image=insert_image;", "if (index == 0)", "PrependImageToList(&_images,insert_image);", "else if (index == (ssize_t) GetImageListLength(_images))", "AppendImageToList(&_images,insert_image);", "else", "{", "index_image=GetImageFromList(_images,index-1);", "if (index_image == (Image *) NULL)", "CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);", "InsertImageInList(&index_image,insert_image);", "}", "_images=GetFirstImageInList(index_image);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'l':", "{", "if (LocaleCompare(\"layers\",option+1) == 0)", "{", "parse=ParseCommandOption(MagickLayerOptions,MagickFalse,arg1);", "if ( parse < 0 )", "CLIWandExceptArgBreak(OptionError,\"UnrecognizedLayerMethod\",", "option,arg1);", "switch ((LayerMethod) parse)", "{", "case CoalesceLayer:", "{", "new_images=CoalesceImages(_images,_exception);", "break;", "}", "case CompareAnyLayer:", "case CompareClearLayer:", "case CompareOverlayLayer:", "default:", "{", "new_images=CompareImagesLayers(_images,(LayerMethod) parse,", "_exception);", "break;", "}", "case MergeLayer:", "case FlattenLayer:", "case MosaicLayer:", "case TrimBoundsLayer:", "{", "new_images=MergeImageLayers(_images,(LayerMethod) parse,", "_exception);", "break;", "}", "case DisposeLayer:", "{", "new_images=DisposeImages(_images,_exception);", "break;", "}", "case OptimizeImageLayer:", "{", "new_images=OptimizeImageLayers(_images,_exception);", "break;", "}", "case OptimizePlusLayer:", "{", "new_images=OptimizePlusImageLayers(_images,_exception);", "break;", "}", "case OptimizeTransLayer:", "{", "OptimizeImageTransparency(_images,_exception);", "break;", "}", "case RemoveDupsLayer:", "{", "RemoveDuplicateLayers(&_images,_exception);", "break;", "}", "case RemoveZeroLayer:", "{", "RemoveZeroDelayLayers(&_images,_exception);", "break;", "}", "case OptimizeLayer:", "{", "new_images=CoalesceImages(_images,_exception);", "if (new_images == (Image *) NULL)", "break;", "_images=DestroyImageList(_images);", "_images=OptimizeImageLayers(new_images,_exception);", "if (_images == (Image *) NULL)", "break;", "new_images=DestroyImageList(new_images);", "OptimizeImageTransparency(_images,_exception);", "(void) RemapImages(_quantize_info,_images,(Image *) NULL,", "_exception);", "break;", "}", "case CompositeLayer:", "{", "Image", "*source;", "", "RectangleInfo", "geometry;", "", "CompositeOperator", "compose;", "", "const char*", "value;", "", "value=GetImageOption(_image_info,\"compose\");", "compose=OverCompositeOp;", "if (value != (const char *) NULL)", "compose=(CompositeOperator) ParseCommandOption(", "MagickComposeOptions,MagickFalse,value);", "", "", "source=_images;", "while (source != (Image *) NULL)", "{", "source=GetNextImageInList(source);", "if ((source != (Image *) NULL) &&", "(LocaleCompare(source->magick,\"NULL\") == 0))", "break;", "}", "if (source != (Image *) NULL)", "{", "if ((GetPreviousImageInList(source) == (Image *) NULL) ||", "(GetNextImageInList(source) == (Image *) NULL))", "source=(Image *) NULL;", "else", "{", "source=SplitImageList(source->previous);", "DeleteImageFromList(&source);", "}", "}", "if (source == (Image *) NULL)", "{", "(void) ThrowMagickException(_exception,GetMagickModule(),", "OptionError,\"MissingNullSeparator\",\"layers Composite\");", "break;", "}", "", "SetGeometry(_images,&geometry);", "(void) ParseAbsoluteGeometry(_images->geometry,&geometry);", "geometry.width=source->page.width != 0 ?", "source->page.width : source->columns;", "geometry.height=source->page.height != 0 ?", "source->page.height : source->rows;", "GravityAdjustGeometry(_images->page.width != 0 ?", "_images->page.width : _images->columns,", "_images->page.height != 0 ? _images->page.height :", "_images->rows,_images->gravity,&geometry);", "", "", "CompositeLayers(_images,compose,source,geometry.x,geometry.y,", "_exception);", "source=DestroyImageList(source);", "break;", "}", "}", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'm':", "{", "if (LocaleCompare(\"map\",option+1) == 0)", "{", "CLIWandWarnReplaced(\"+remap\");", "(void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);", "break;", "}", "if (LocaleCompare(\"metric\",option+1) == 0)", "{", "(void) SetImageOption(_image_info,option+1,arg1);", "break;", "}", "if (LocaleCompare(\"morph\",option+1) == 0)", "{", "Image", "*morph_image;", "", "if (IsGeometry(arg1) == MagickFalse)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "morph_image=MorphImages(_images,StringToUnsignedLong(arg1),", "_exception);", "if (morph_image == (Image *) NULL)", "break;", "_images=DestroyImageList(_images);", "_images=morph_image;", "break;", "}", "if (LocaleCompare(\"mosaic\",option+1) == 0)", "{", "", "(void) CLIListOperatorImages(cli_wand,\"-layers\",option+1,NULL);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'p':", "{", "if (LocaleCompare(\"poly\",option+1) == 0)", "{", "double", "*args;", "", "ssize_t", "count;", "", "", "args = StringToArrayOfDoubles(arg1,&count,_exception);", "if (args == (double *) NULL )", "CLIWandExceptArgBreak(OptionError,\"InvalidNumberList\",option,arg1);", "new_images=PolynomialImage(_images,(size_t) (count >> 1),args,", "_exception);", "args=(double *) RelinquishMagickMemory(args);", "break;", "}", "if (LocaleCompare(\"process\",option+1) == 0)", "{", "", "char", "**arguments;", "", "int", "j,", "number_arguments;", "", "arguments=StringToArgv(arg1,&number_arguments);", "if (arguments == (char **) NULL)", "break;", "if (strchr(arguments[1],'=') != (char *) NULL)", "{", "char", "breaker,", "quote,", "*token;", "", "const char", "*arguments;", "", "int", "next,", "status;", "", "size_t", "length;", "", "TokenInfo", "*token_info;", "", "", "", "", "assert(arg1 != (const char *) NULL);", "length=strlen(arg1);", "token=(char *) NULL;", "if (~length >= (MagickPathExtent-1))", "token=(char *) AcquireQuantumMemory(length+MagickPathExtent,", "sizeof(*token));", "if (token == (char *) NULL)", "break;", "next=0;", "arguments=arg1;", "token_info=AcquireTokenInfo();", "status=Tokenizer(token_info,0,token,length,arguments,\"\",\"=\",", "\"\\\"\",'\\0',&breaker,&next,&quote);", "token_info=DestroyTokenInfo(token_info);", "if (status == 0)", "{", "const char", "*argv;", "", "argv=(&(arguments[next]));", "(void) InvokeDynamicImageFilter(token,&_images,1,&argv,", "_exception);", "}", "token=DestroyString(token);", "break;", "}", "(void) SubstituteString(&arguments[1],\"-\",\"\");", "(void) InvokeDynamicImageFilter(arguments[1],&_images,", "number_arguments-2,(const char **) arguments+2,_exception);", "for (j=0; j < number_arguments; j++)", "arguments[j]=DestroyString(arguments[j]);", "arguments=(char **) RelinquishMagickMemory(arguments);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 'r':", "{", "if (LocaleCompare(\"remap\",option+1) == 0)", "{", "(void) RemapImages(_quantize_info,_images,(Image *) NULL,_exception);", "break;", "}", "if (LocaleCompare(\"reverse\",option+1) == 0)", "{", "ReverseImageList(&_images);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "case 's':", "{", "if (LocaleCompare(\"smush\",option+1) == 0)", "{", "", "ssize_t", "offset;", "", "if (IsGeometry(arg1) == MagickFalse)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "offset=(ssize_t) StringToLong(arg1);", "new_images=SmushImages(_images,IsNormalOp,offset,_exception);", "break;", "}", "if (LocaleCompare(\"subimage\",option+1) == 0)", "{", "Image", "*base_image,", "*compare_image;", "", "const char", "*value;", "", "MetricType", "metric;", "", "double", "similarity;", "", "RectangleInfo", "offset;", "", "base_image=GetImageFromList(_images,0);", "compare_image=GetImageFromList(_images,1);", "", "", "metric=UndefinedErrorMetric;", "value=GetImageOption(_image_info,\"metric\");", "if (value != (const char *) NULL)", "metric=(MetricType) ParseCommandOption(MagickMetricOptions,", "MagickFalse,value);", "", "new_images=SimilarityImage(base_image,compare_image,metric,0.0,", "&offset,&similarity,_exception);", "", "if (new_images != (Image *) NULL)", "{", "char", "result[MagickPathExtent];", "", "(void) FormatLocaleString(result,MagickPathExtent,\"%lf\",", "similarity);", "(void) SetImageProperty(new_images,\"subimage:similarity\",result,", "_exception);", "(void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)", "offset.x);", "(void) SetImageProperty(new_images,\"subimage:x\",result,", "_exception);", "(void) FormatLocaleString(result,MagickPathExtent,\"%+ld\",(long)", "offset.y);", "(void) SetImageProperty(new_images,\"subimage:y\",result,", "_exception);", "(void) FormatLocaleString(result,MagickPathExtent,", "\"%lux%lu%+ld%+ld\",(unsigned long) offset.width,(unsigned long)", "offset.height,(long) offset.x,(long) offset.y);", "(void) SetImageProperty(new_images,\"subimage:offset\",result,", "_exception);", "}", "break;", "}", "if (LocaleCompare(\"swap\",option+1) == 0)", "{", "Image", "*p,", "*q,", "*swap;", "", "ssize_t", "index,", "swap_index;", "", "index=(-1);", "swap_index=(-2);", "if (IfNormalOp) {", "GeometryInfo", "geometry_info;", "", "MagickStatusType", "flags;", "", "swap_index=(-1);", "flags=ParseGeometry(arg1,&geometry_info);", "if ((flags & RhoValue) == 0)", "CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);", "index=(ssize_t) geometry_info.rho;", "if ((flags & SigmaValue) != 0)", "swap_index=(ssize_t) geometry_info.sigma;", "}", "p=GetImageFromList(_images,index);", "q=GetImageFromList(_images,swap_index);", "if ((p == (Image *) NULL) || (q == (Image *) NULL)) {", "if (IfNormalOp)", "CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1)", "else", "CLIWandExceptionBreak(OptionError,\"TwoOrMoreImagesRequired\",option);", "}", "if (p == q)", "CLIWandExceptArgBreak(OptionError,\"InvalidImageIndex\",option,arg1);", "swap=CloneImage(p,0,0,MagickTrue,_exception);", "if (swap == (Image *) NULL)", "CLIWandExceptArgBreak(ResourceLimitError,\"MemoryAllocationFailed\",", "option,GetExceptionMessage(errno));", "ReplaceImageInList(&p,CloneImage(q,0,0,MagickTrue,_exception));", "ReplaceImageInList(&q,swap);", "_images=GetFirstImageInList(q);", "break;", "}", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "default:", "CLIWandExceptionBreak(OptionError,\"UnrecognizedOption\",option);", "}", "", "", "if (arg1 != arg1n )", "arg1=DestroyString((char *)arg1);", "if (arg2 != arg2n )", "arg2=DestroyString((char *)arg2);", "", "", "if (new_images == (Image *) NULL)", "return(status == 0 ? MagickFalse : MagickTrue);", "_images=DestroyImageList(_images);", "_images=GetFirstImageInList(new_images);", "return(status == 0 ? MagickFalse : MagickTrue);", "", "#undef _image_info", "#undef _images", "#undef _exception", "#undef _draw_info", "#undef _quantize_info", "#undef IfNormalOp", "#undef IfPlusOp", "#undef IsNormalOp", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "const Tensor& input = context->input(0);", "const Tensor& filter = context->input(1);", "const Tensor& out_backprop = context->input(2);", "", "", "int stride_rows = 0, stride_cols = 0;", "int rate_rows = 0, rate_cols = 0;", "int64 pad_top = 0, pad_left = 0;", "int64 out_rows = 0, out_cols = 0;", "ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,", "&rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,", "&out_cols);", "", "", "", "const int batch = input.dim_size(0);", "const int depth = input.dim_size(3);", "OP_REQUIRES(context,", "batch == out_backprop.dim_size(0) &&", "out_rows == out_backprop.dim_size(1) &&", "out_cols == out_backprop.dim_size(2) &&", "depth == out_backprop.dim_size(3),", "errors::InvalidArgument(\"out_backprop has incompatible size.\"));", "", "", "", "Tensor* filter_backprop = nullptr;", "OP_REQUIRES_OK(", "context, context->allocate_output(0, filter.shape(), &filter_backprop));", "", "", "if (filter.shape().num_elements() == 0) {", "return;", "}", "", "functor::DilationBackpropFilter<Device, T>()(", "context->eigen_device<Device>(), input.tensor<T, 4>(),", "filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,", "stride_cols, rate_rows, rate_cols, pad_top, pad_left,", "filter_backprop->tensor<T, 3>());", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["BOOL update_write_cache_bitmap_v2_order(wStream* s, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2,", "BOOL compressed, UINT16* flags)", "{", "BYTE bitsPerPixelId;", "", "if (!Stream_EnsureRemainingCapacity(", "s, update_approximate_cache_bitmap_v2_order(cache_bitmap_v2, compressed, flags)))", "return FALSE;", "", "bitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];", "*flags = (cache_bitmap_v2->cacheId & 0x0003) | (bitsPerPixelId << 3) |", "((cache_bitmap_v2->flags << 7) & 0xFF80);", "", "if (cache_bitmap_v2->flags & CBR2_PERSISTENT_KEY_PRESENT)", "{", "Stream_Write_UINT32(s, cache_bitmap_v2->key1);", "Stream_Write_UINT32(s, cache_bitmap_v2->key2);", "}", "", "if (cache_bitmap_v2->flags & CBR2_HEIGHT_SAME_AS_WIDTH)", "{", "if (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth))", "return FALSE;", "}", "else", "{", "if (!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapWidth) ||", "!update_write_2byte_unsigned(s, cache_bitmap_v2->bitmapHeight))", "return FALSE;", "}", "", "if (cache_bitmap_v2->flags & CBR2_DO_NOT_CACHE)", "cache_bitmap_v2->cacheIndex = BITMAP_CACHE_WAITING_LIST_INDEX;", "", "if (!update_write_4byte_unsigned(s, cache_bitmap_v2->bitmapLength) ||", "!update_write_2byte_unsigned(s, cache_bitmap_v2->cacheIndex))", "return FALSE;", "", "if (compressed)", "{", "if (!(cache_bitmap_v2->flags & CBR2_NO_BITMAP_COMPRESSION_HDR))", "{", "Stream_Write_UINT16(", "s, cache_bitmap_v2->cbCompFirstRowSize);", "Stream_Write_UINT16(", "s, cache_bitmap_v2->cbCompMainBodySize);", "Stream_Write_UINT16(s, cache_bitmap_v2->cbScanWidth);", "Stream_Write_UINT16(", "s, cache_bitmap_v2->cbUncompressedSize);", "cache_bitmap_v2->bitmapLength = cache_bitmap_v2->cbCompMainBodySize;", "}", "", "if (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))", "return FALSE;", "", "Stream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);", "}", "else", "{", "if (!Stream_EnsureRemainingCapacity(s, cache_bitmap_v2->bitmapLength))", "return FALSE;", "", "Stream_Write(s, cache_bitmap_v2->bitmapDataStream, cache_bitmap_v2->bitmapLength);", "}", "", "cache_bitmap_v2->compressed = compressed;", "return TRUE;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["virtual EModRet OnPrivCTCP(CNick& Nick, CString& sMessage) {", "if (sMessage.Equals(\"DCC \", false, 4) && m_pUser->IsUserAttached()) {", "", "CString sType = sMessage.Token(1);", "CString sFile = sMessage.Token(2);", "unsigned long uLongIP = sMessage.Token(3).ToULong();", "unsigned short uPort = sMessage.Token(4).ToUShort();", "unsigned long uFileSize = sMessage.Token(5).ToULong();", "", "if (sType.Equals(\"CHAT\")) {", "CNick FromNick(Nick.GetNickMask());", "unsigned short uBNCPort = CDCCBounce::DCCRequest(FromNick.GetNick(), uLongIP, uPort, \"\", true, this, CUtils::GetIP(uLongIP));", "if (uBNCPort) {", "CString sIP = GetLocalDCCIP();", "m_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC CHAT chat \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \"\\001\");", "}", "} else if (sType.Equals(\"SEND\")) {", "", "unsigned short uBNCPort = CDCCBounce::DCCRequest(Nick.GetNick(), uLongIP, uPort, sFile, false, this, CUtils::GetIP(uLongIP));", "if (uBNCPort) {", "CString sIP = GetLocalDCCIP();", "m_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC SEND \" + sFile + \" \" + CString(CUtils::GetLongIP(sIP)) + \" \" + CString(uBNCPort) + \" \" + CString(uFileSize) + \"\\001\");", "}", "} else if (sType.Equals(\"RESUME\")) {", "", "unsigned short uResumePort = sMessage.Token(3).ToUShort();", "", "set<CSocket*>::const_iterator it;", "for (it = BeginSockets(); it != EndSockets(); ++it) {", "CDCCBounce* pSock = (CDCCBounce*) *it;", "", "if (pSock->GetLocalPort() == uResumePort) {", "m_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetUserPort()) + \" \" + sMessage.Token(4) + \"\\001\");", "}", "}", "} else if (sType.Equals(\"ACCEPT\")) {", "", "set<CSocket*>::const_iterator it;", "for (it = BeginSockets(); it != EndSockets(); ++it) {", "CDCCBounce* pSock = (CDCCBounce*) *it;", "", "if (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {", "m_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetLocalPort()) + \" \" + sMessage.Token(4) + \"\\001\");", "}", "}", "}", "", "return HALTCORE;", "}", "", "return CONTINUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void OneClickSigninSyncStarter::UntrustedSigninConfirmed(", "      StartSyncMode response) {", "    if (response == UNDO_SYNC) {", "      CancelSigninAndDelete();", "      ", "      ", "     if (source_ != SyncPromoUI::SOURCE_UNKNOWN) {", "       EnsureBrowser();", "       chrome::NavigateParams params(browser_, GURL(chrome::kChromeUINewTabURL),", "                                     content::PAGE_TRANSITION_AUTO_TOPLEVEL);", "       params.disposition = CURRENT_TAB;", "       params.window_action = chrome::NavigateParams::SHOW_WINDOW;", "       chrome::Navigate(&params);", "     }", "    } else {", "     if (response == CONFIGURE_SYNC_FIRST)", "       start_mode_ = response;", "     SigninManager* signin = SigninManagerFactory::GetForProfile(profile_);", "     signin->CompletePendingSignin();", "   }", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)", " {", " \tint error = 0;", " ", " \tif (!acl)", " \t\tgoto set_acl;", " ", " \terror = -E2BIG;", " \tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))", "  \t\treturn error;", "  ", "  \tif (type == ACL_TYPE_ACCESS) {", "\t\tumode_t mode = inode->i_mode;", "\t\terror = posix_acl_equiv_mode(acl, &mode);", "\t\tif (error <= 0) {", "\t\t\tacl = NULL;", "\t\t\tif (error < 0)", "\t\t\t\treturn error;", "\t\t}", " \t\tumode_t mode;", "  ", " \t\terror = posix_acl_update_mode(inode, &mode, &acl);", " \t\tif (error)", " \t\t\treturn error;", "  \t\terror = xfs_set_mode(inode, mode);", "  \t\tif (error)", "  \t\t\treturn error;", " \t}", " ", "  set_acl:", " \treturn __xfs_set_acl(inode, type, acl);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" perform_formatting_test(png_store *volatile ps)", " perform_formatting_test(png_store *ps)", "  {", "  #ifdef PNG_TIME_RFC1123_SUPPORTED", "      ", "    context(ps, fault);", " ", "  Try", "  {", "       png_const_charp correct = \"29 Aug 2079 13:53:60 +0000\";", "       png_const_charp result;", " #     if PNG_LIBPNG_VER >= 10600", "  char timestring[29];", " #     endif", "       png_structp pp;", "       png_time pt;", " ", "       pp = set_store_for_write(ps, NULL, \"libpng formatting test\");", " ", "  if (pp == NULL)", "  Throw ps;", " ", " ", "   ", "       pt.year = 2079;", "       pt.month = 8;", "       pt.day = 29;", "       pt.hour = 13;", "       pt.minute = 53;", "       pt.second = 60;  ", " ", " #     if PNG_LIBPNG_VER < 10600", "          result = png_convert_to_rfc1123(pp, &pt);", " #     else", "  if (png_convert_to_rfc1123_buffer(timestring, &pt))", "             result = timestring;", " ", "  else", "             result = NULL;", " #     endif", " ", "  if (result == NULL)", "          png_error(pp, \"png_convert_to_rfc1123 failed\");", " ", "  if (strcmp(result, correct) != 0)", "  {", "  size_t pos = 0;", "  char msg[128];", " ", "          pos = safecat(msg, sizeof msg, pos, \"png_convert_to_rfc1123(\");", "          pos = safecat(msg, sizeof msg, pos, correct);", "          pos = safecat(msg, sizeof msg, pos, \") returned: '\");", "          pos = safecat(msg, sizeof msg, pos, result);", "          pos = safecat(msg, sizeof msg, pos, \"'\");", " ", "          png_error(pp, msg);", "  }", " ", "       store_write_reset(ps);", "  }", " ", "  Catch(fault)", "  {", "       store_write_reset(fault);", "  }", " #else", "    UNUSED(ps)", " #endif", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,", "                int *cs, int *vers, int *fmt, int *ncx, int *ncy,", "                t_chunk_info ** chunkIdx)", " {", " \tint i;", " \tint ch;", " \tchar id[5];", " \tt_chunk_info *cidx;", " \tint sidx;", " \tint nc;", " ", " \tGD2_DBG (printf (\"Reading gd2 header info\\n\"));", " ", " \tfor (i = 0; i < 4; i++) {", " \t\tch = gdGetC (in);", " \t\tif (ch == EOF) {", " \t\t\tgoto fail1;", " \t\t};", " \t\tid[i] = ch;", " \t};", " \tid[4] = 0;", " ", " \tGD2_DBG (printf (\"Got file code: %s\\n\", id));", " ", " \t ", " \tif (strcmp (id, GD2_ID) != 0) {", " \t\tGD2_DBG (printf (\"Not a valid gd2 file\\n\"));", " \t\tgoto fail1;", " \t};", " ", " \t ", " \tif (gdGetWord (vers, in) != 1) {", " \t\tgoto fail1;", " \t};", " \tGD2_DBG (printf (\"Version: %d\\n\", *vers));", " ", " \tif ((*vers != 1) && (*vers != 2)) {", " \t\tGD2_DBG (printf (\"Bad version: %d\\n\", *vers));", " \t\tgoto fail1;", " \t};", " ", " \t ", " \tif (!gdGetWord (sx, in)) {", " \t\tGD2_DBG (printf (\"Could not get x-size\\n\"));", " \t\tgoto fail1;", " \t}", " \tif (!gdGetWord (sy, in)) {", " \t\tGD2_DBG (printf (\"Could not get y-size\\n\"));", " \t\tgoto fail1;", " \t}", " \tGD2_DBG (printf (\"Image is %dx%d\\n\", *sx, *sy));", " ", " \t ", " \tif (gdGetWord (cs, in) != 1) {", " \t\tgoto fail1;", " \t};", " \tGD2_DBG (printf (\"ChunkSize: %d\\n\", *cs));", " ", " \tif ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {", " \t\tGD2_DBG (printf (\"Bad chunk size: %d\\n\", *cs));", " \t\tgoto fail1;", " \t};", " ", " \t ", " \tif (gdGetWord (fmt, in) != 1) {", " \t\tgoto fail1;", " \t};", " \tGD2_DBG (printf (\"Format: %d\\n\", *fmt));", " ", " \tif ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&", " \t        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&", " \t        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {", " \t\tGD2_DBG (printf (\"Bad data format: %d\\n\", *fmt));", " \t\tgoto fail1;", " \t};", " ", " ", " \t ", " \tif (gdGetWord (ncx, in) != 1) {", " \t\tgoto fail1;", " \t};", " \tGD2_DBG (printf (\"%d Chunks Wide\\n\", *ncx));", " ", " \t ", " \tif (gdGetWord (ncy, in) != 1) {", " \t\tgoto fail1;", " \t};", " \tGD2_DBG (printf (\"%d Chunks vertically\\n\", *ncy));", " ", " \tif (gd2_compressed (*fmt)) {", " \t\tnc = (*ncx) * (*ncy);", " \t\tGD2_DBG (printf (\"Reading %d chunk index entries\\n\", nc));", " \t\tsidx = sizeof (t_chunk_info) * nc;", " \t\tcidx = gdCalloc (sidx, 1);", " \t\tif (!cidx) {", " \t\t\tgoto fail1;", " \t\t}", " \t\tfor (i = 0; i < nc; i++) {", " \t\t\tif (gdGetInt (&cidx[i].offset, in) != 1) {", " \t\t\t\tgoto fail2;", " \t\t\t};", "  \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {", "  \t\t\t\tgoto fail2;", "  \t\t\t};", " \t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)", " \t\t\t\tgoto fail2;", "  \t\t};", "  \t\t*chunkIdx = cidx;", "  \t};", " ", " \tGD2_DBG (printf (\"gd2 header complete\\n\"));", " ", " \treturn 1;", " fail2:", " \tgdFree(cidx);", " fail1:", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int g2m_init_buffers(G2MContext *c)", " {", "     int aligned_height;", " ", "     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {", "         c->framebuf_stride = FFALIGN(c->width * 3, 16);", "         aligned_height     = FFALIGN(c->height,    16);", "         av_free(c->framebuf);", "         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);", "         if (!c->framebuf)", "             return AVERROR(ENOMEM);", "     }", "      if (!c->synth_tile || !c->jpeg_tile ||", "          c->old_tile_w < c->tile_width ||", "          c->old_tile_h < c->tile_height) {", "        c->tile_stride = FFALIGN(c->tile_width * 3, 16);", "         c->tile_stride = FFALIGN(c->tile_width, 16) * 3;", "          aligned_height = FFALIGN(c->tile_height,    16);", "          av_free(c->synth_tile);", "          av_free(c->jpeg_tile);", "         av_free(c->kempf_buf);", "         av_free(c->kempf_flags);", "         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);", "         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);", "         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height", "                                     + FF_INPUT_BUFFER_PADDING_SIZE);", "         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);", "         if (!c->synth_tile || !c->jpeg_tile ||", "             !c->kempf_buf || !c->kempf_flags)", "             return AVERROR(ENOMEM);", "     }", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)", "    : ObjectBackedNativeHandler(context) {", "     : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {", "    RouteFunction(", "        \"OnDocumentElementCreated\",", "        base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,", "                   base::Unretained(this)));", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" SPL_METHOD(SplFileObject, fread)", " {", " \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);", " \tlong length = 0;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {", " \t\treturn;", " \t}", " ", " \tif (length <= 0) {", "  \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");", "  \t\tRETURN_FALSE;", "  \t}", " \tif (length > INT_MAX) {", " \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);", " \t\tRETURN_FALSE;", " \t}", "  ", "  \tZ_STRVAL_P(return_value) = emalloc(length + 1);", "  \tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);", " ", " \t ", " \tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;", " \tZ_TYPE_P(return_value) = IS_STRING;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void TextTrack::addCue(TextTrackCue* cue) {", "    DCHECK(cue);", "  ", "  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||", "      cue->startTime() < 0 || cue->endTime() < 0)", "   if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()))", "      return;", "  ", " ", " ", " ", "   if (TextTrack* cue_track = cue->track())", "     cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);", " ", "   cue->SetTrack(this);", "   EnsureTextTrackCueList()->Add(cue);", " ", "   if (GetCueTimeline() && mode_ != DisabledKeyword())", "     GetCueTimeline()->AddCue(this, cue);", " }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)", "{", "return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),", "RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,", "indx, 0, data, size, 500);", "}"], "ner_tags": [0, 0, 1, 1, 1, 0]}
{"tokens": [" m_authenticate(struct Client *client_p, struct Client *source_p,", " \tint parc, const char *parv[])", " {", " \tstruct Client *agent_p = NULL;", " \tstruct Client *saslserv_p = NULL;", " ", " \t ", " \tif(!IsCapable(source_p, CLICAP_SASL))", " \t\treturn 0;", " ", " \tif (strlen(client_p->id) == 3)", " \t{", " \t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");", "  \t\treturn 0;", "  \t}", "  ", " \tif (*parv[1] == ':' || strchr(parv[1], ' '))", " \t{", " \t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");", " \t\treturn 0;", " \t}", " ", "  \tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);", "  \tif (saslserv_p == NULL || !IsService(saslserv_p))", "  \t{", " \t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);", " \t\treturn 0;", " \t}", " ", " \tif(source_p->localClient->sasl_complete)", " \t{", " \t\t*source_p->localClient->sasl_agent = '\\0';", " \t\tsource_p->localClient->sasl_complete = 0;", " \t}", " ", " \tif(strlen(parv[1]) > 400)", " \t{", " \t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);", " \t\treturn 0;", " \t}", " ", " \tif(!*source_p->id)", " \t{", " \t\t ", " \t\tstrcpy(source_p->id, generate_uid());", " \t\tadd_to_id_hash(source_p->id, source_p);", " \t}", " ", " \tif(*source_p->localClient->sasl_agent)", " \t\tagent_p = find_id(source_p->localClient->sasl_agent);", " ", " \tif(agent_p == NULL)", " \t{", " \t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",", " \t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\tsource_p->host, source_p->sockhost);", " ", " \t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)", " \t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",", " \t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\t\tparv[1], source_p->certfp);", " \t\telse", " \t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",", " \t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,", " \t\t\t\t\t\tparv[1]);", " ", " \t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);", " \t}", " \telse", " \t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",", " \t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,", " \t\t\t\tparv[1]);", " \tsource_p->localClient->sasl_out++;", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr)", " {", "  unsigned int index = 0;", "     OMX_U8 *temp_buff ;", " ", "  if (bufferHdr == NULL || m_inp_mem_ptr == NULL) {", "         DEBUG_PRINT_ERROR(\"ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]\",", "                 bufferHdr, m_inp_mem_ptr);", "  return OMX_ErrorBadParameter;", "  }", " ", "     index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);", " #ifdef _ANDROID_ICS_", "  if (meta_mode_enable) {", "  if (index < m_sInPortDef.nBufferCountActual) {", "             memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index]));", "             memset(&meta_buffers[index], 0, sizeof(meta_buffers[index]));", "  }", "  if (!mUseProxyColorFormat)", "  return OMX_ErrorNone;", "  else {", "             c2d_conv.close();", "             opaque_buffer_hdr[index] = NULL;", "  }", "  }", " #endif", "  if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat &&", "             dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {", "         DEBUG_PRINT_LOW(\"ERROR: dev_free_buf() Failed for i/p buf\");", " ", "      }", "  ", "      if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) {", "         auto_lock l(m_lock);", " ", "          if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) {", "              DEBUG_PRINT_LOW(\"FreeBuffer:: i/p AllocateBuffer case\");", "              if(!secure_session) {", "             munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);", " ", "              } else {", "                  free(m_pInput_pmem[index].buffer);", "              }", "             m_pInput_pmem[index].buffer = NULL;", "              close (m_pInput_pmem[index].fd);", "  #ifdef USE_ION", "              free_ion_memory(&m_pInput_ion[index]);", " #endif", "             m_pInput_pmem[index].fd = -1;", "  } else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true &&", "                     m_use_input_pmem == OMX_FALSE)) {", "             DEBUG_PRINT_LOW(\"FreeBuffer:: i/p Heap UseBuffer case\");", "  if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) {", " ", "                  DEBUG_PRINT_ERROR(\"ERROR: dev_free_buf() Failed for i/p buf\");", "              }", "              if(!secure_session) {", "            munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);", "                 munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size);", "                 m_pInput_pmem[index].buffer = NULL;", "              }", "              close (m_pInput_pmem[index].fd);", "  #ifdef USE_ION", "             free_ion_memory(&m_pInput_ion[index]);", " #endif", "             m_pInput_pmem[index].fd = -1;", "  } else {", "             DEBUG_PRINT_ERROR(\"FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case\");", "  }", "  }", "  return OMX_ErrorNone;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int passwd_to_utf16(unsigned char *in_passwd,", "int length,", "int max_length,", "unsigned char *out_passwd)", "{", "#ifdef WIN32", "int ret;", "(void)length;", "ret = MultiByteToWideChar(", "CP_ACP,", "0,", "(LPCSTR)in_passwd,", "-1,", "(LPWSTR)out_passwd,", "max_length / 2", ");", "if (ret == 0)", "return AESCRYPT_READPWD_ICONV;", "return ret * 2;", "#else", "#ifndef ENABLE_ICONV", "", "int i;", "for (i=0;i<length+1;i++) {", "out_passwd[i*2] = in_passwd[i];", "out_passwd[i*2+1] = 0;", "}", "return length*2;", "#else", "unsigned char *ic_outbuf,", "*ic_inbuf;", "iconv_t condesc;", "size_t ic_inbytesleft,", "ic_outbytesleft;", "", "", "", "", "", "max_length *= 2;", "", "ic_inbuf = in_passwd;", "ic_inbytesleft = length;", "ic_outbytesleft = max_length;", "ic_outbuf = out_passwd;", "", "", "setlocale(LC_CTYPE,\"\");", "", "if ((condesc = iconv_open(\"UTF-16LE\", nl_langinfo(CODESET))) ==", "(iconv_t)(-1))", "{", "perror(\"Error in iconv_open\");", "return -1;", "}", "", "if (iconv(condesc,", "(char ** const) &ic_inbuf,", "&ic_inbytesleft,", "(char ** const) &ic_outbuf,", "&ic_outbytesleft) == (size_t) -1)", "{", "switch (errno)", "{", "case E2BIG:", "fprintf(stderr, \"Error: password too long\\n\");", "iconv_close(condesc);", "return -1;", "break;", "default:", "", "", "", "", "", "", "perror(\"Password conversion error\");", "iconv_close(condesc);", "return -1;", "}", "}", "iconv_close(condesc);", "return (max_length - ic_outbytesleft);", "#endif", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,", " \t\t\t    struct msghdr *msg, size_t len, int noblock,", " \t\t\t    int flags, int *addr_len)", " {", " \tstruct ipv6_pinfo *np = inet6_sk(sk);", " \tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;", " \tsize_t copied = 0;", " \tint err = -EOPNOTSUPP;", " \tstruct sk_buff *skb;", " ", " \tif (flags & MSG_OOB)", " \t\tgoto out;", " ", " \tif (addr_len)", " \t\t*addr_len = sizeof(*lsa);", " ", " \tif (flags & MSG_ERRQUEUE)", " \t\treturn ipv6_recv_error(sk, msg, len);", " ", " \tskb = skb_recv_datagram(sk, flags, noblock, &err);", " \tif (!skb)", " \t\tgoto out;", " ", " \tcopied = skb->len;", " \tif (len < copied) {", " \t\tmsg->msg_flags |= MSG_TRUNC;", " \t\tcopied = len;", " \t}", " ", " \terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);", " \tif (err)", " \t\tgoto done;", " ", " \tsock_recv_timestamp(msg, sk, skb);", " ", " \t ", " \tif (lsa) {", " \t\tlsa->l2tp_family = AF_INET6;", " \t\tlsa->l2tp_unused = 0;", "  \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;", "  \t\tlsa->l2tp_flowinfo = 0;", "  \t\tlsa->l2tp_scope_id = 0;", " \t\tlsa->l2tp_conn_id = 0;", "  \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)", "  \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;", "  \t}", " ", " \tif (np->rxopt.all)", " \t\tip6_datagram_recv_ctl(sk, msg, skb);", " ", " \tif (flags & MSG_TRUNC)", " \t\tcopied = skb->len;", " done:", " \tskb_free_datagram(sk, skb);", " out:", " \treturn err ? err : copied;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" CSSStyleSheet* CSSStyleSheet::CreateInline(Node& owner_node,", "                                            const KURL& base_url,", "                                            const TextPosition& start_position,", "                                             const WTF::TextEncoding& encoding) {", "    CSSParserContext* parser_context = CSSParserContext::Create(", "        owner_node.GetDocument(), owner_node.GetDocument().BaseURL(),", "       false  ,", "        owner_node.GetDocument().GetReferrerPolicy(), encoding);", "    StyleSheetContents* sheet =", "        StyleSheetContents::Create(base_url.GetString(), parser_context);", "   return new CSSStyleSheet(sheet, owner_node, true, start_position);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" netscreen_seek_read(wtap *wth, gint64 seek_off,", "  \tstruct wtap_pkthdr *phdr, Buffer *buf,", "  \tint *err, gchar **err_info)", "  {", "\tint\t\tpkt_len;", "  \tchar\t\tline[NETSCREEN_LINE_LENGTH];", "\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];", "\tgboolean\tcap_dir;", "\tchar\t\tcap_dst[13];", "  ", "  \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {", "  \t\treturn FALSE;", " \t}", " ", " \tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {", " \t\t*err = file_error(wth->random_fh, err_info);", " \t\tif (*err == 0) {", " \t\t\t*err = WTAP_ERR_SHORT_READ;", " \t\t}", "  \t\treturn FALSE;", "  \t}", "  ", "\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,", "\t    cap_dst, err, err_info);", "\tif (pkt_len == -1)", "\t\treturn FALSE;", "\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,", "\t    cap_dst, phdr, buf, err, err_info))", "\t\treturn FALSE;", "\treturn TRUE;", " \treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,", " \t    err, err_info);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["codegen(codegen_scope *s, node *tree, int val)", "{", "int nt;", "int rlev = s->rlev;", "", "if (!tree) {", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "return;", "}", "", "s->rlev++;", "if (s->rlev > MRB_CODEGEN_LEVEL_MAX) {", "codegen_error(s, \"too complex expression\");", "}", "if (s->irep && s->filename_index != tree->filename_index) {", "mrb_sym fname = mrb_parser_get_filename(s->parser, s->filename_index);", "const char *filename = mrb_sym_name_len(s->mrb, fname, NULL);", "", "mrb_debug_info_append_file(s->mrb, s->irep->debug_info,", "filename, s->lines, s->debug_start_pos, s->pc);", "s->debug_start_pos = s->pc;", "s->filename_index = tree->filename_index;", "s->filename_sym = mrb_parser_get_filename(s->parser, tree->filename_index);", "}", "", "nt = nint(tree->car);", "s->lineno = tree->lineno;", "tree = tree->cdr;", "switch (nt) {", "case NODE_BEGIN:", "if (val && !tree) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "while (tree) {", "codegen(s, tree->car, tree->cdr ? NOVAL : val);", "tree = tree->cdr;", "}", "break;", "", "case NODE_RESCUE:", "{", "int noexc;", "uint32_t exend, pos1, pos2, tmp;", "struct loopinfo *lp;", "int catch_entry, begin, end;", "", "if (tree->car == NULL) goto exit;", "lp = loop_push(s, LOOP_BEGIN);", "lp->pc0 = new_label(s);", "catch_entry = catch_handler_new(s);", "begin = s->pc;", "codegen(s, tree->car, VAL);", "pop();", "lp->type = LOOP_RESCUE;", "end = s->pc;", "noexc = genjmp_0(s, OP_JMP);", "catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);", "tree = tree->cdr;", "exend = JMPLINK_START;", "pos1 = JMPLINK_START;", "if (tree->car) {", "node *n2 = tree->car;", "int exc = cursp();", "", "genop_1(s, OP_EXCEPT, exc);", "push();", "while (n2) {", "node *n3 = n2->car;", "node *n4 = n3->car;", "", "dispatch(s, pos1);", "pos2 = JMPLINK_START;", "do {", "if (n4 && n4->car && nint(n4->car->car) == NODE_SPLAT) {", "codegen(s, n4->car, VAL);", "gen_move(s, cursp(), exc, 0);", "push_n(2); pop_n(2);", "pop();", "genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);", "}", "else {", "if (n4) {", "codegen(s, n4->car, VAL);", "}", "else {", "genop_2(s, OP_GETCONST, cursp(), new_sym(s, MRB_SYM_2(s->mrb, StandardError)));", "push();", "}", "pop();", "genop_2(s, OP_RESCUE, exc, cursp());", "}", "tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, val);", "pos2 = tmp;", "if (n4) {", "n4 = n4->cdr;", "}", "} while (n4);", "pos1 = genjmp_0(s, OP_JMP);", "dispatch_linked(s, pos2);", "", "pop();", "if (n3->cdr->car) {", "gen_assignment(s, n3->cdr->car, NULL, exc, NOVAL);", "}", "if (n3->cdr->cdr->car) {", "codegen(s, n3->cdr->cdr->car, val);", "if (val) pop();", "}", "tmp = genjmp(s, OP_JMP, exend);", "exend = tmp;", "n2 = n2->cdr;", "push();", "}", "if (pos1 != JMPLINK_START) {", "dispatch(s, pos1);", "genop_1(s, OP_RAISEIF, exc);", "}", "}", "pop();", "tree = tree->cdr;", "dispatch(s, noexc);", "if (tree->car) {", "codegen(s, tree->car, val);", "}", "else if (val) {", "push();", "}", "dispatch_linked(s, exend);", "loop_pop(s, NOVAL);", "}", "break;", "", "case NODE_ENSURE:", "if (!tree->cdr || !tree->cdr->cdr ||", "(nint(tree->cdr->cdr->car) == NODE_BEGIN &&", "tree->cdr->cdr->cdr)) {", "int catch_entry, begin, end, target;", "int idx;", "", "catch_entry = catch_handler_new(s);", "begin = s->pc;", "codegen(s, tree->car, val);", "end = target = s->pc;", "push();", "idx = cursp();", "genop_1(s, OP_EXCEPT, idx);", "push();", "codegen(s, tree->cdr->cdr, NOVAL);", "pop();", "genop_1(s, OP_RAISEIF, idx);", "pop();", "catch_handler_set(s, catch_entry, MRB_CATCH_ENSURE, begin, end, target);", "}", "else {", "codegen(s, tree->car, val);", "}", "break;", "", "case NODE_LAMBDA:", "if (val) {", "int idx = lambda_body(s, tree, 1);", "", "genop_2(s, OP_LAMBDA, cursp(), idx);", "push();", "}", "break;", "", "case NODE_BLOCK:", "if (val) {", "int idx = lambda_body(s, tree, 1);", "", "genop_2(s, OP_BLOCK, cursp(), idx);", "push();", "}", "break;", "", "case NODE_IF:", "{", "uint32_t pos1, pos2;", "mrb_bool nil_p = FALSE;", "node *elsepart = tree->cdr->cdr->car;", "", "if (!tree->car) {", "codegen(s, elsepart, val);", "goto exit;", "}", "if (true_always(tree->car)) {", "codegen(s, tree->cdr->car, val);", "goto exit;", "}", "if (false_always(tree->car)) {", "codegen(s, elsepart, val);", "goto exit;", "}", "if (nint(tree->car->car) == NODE_CALL) {", "node *n = tree->car->cdr;", "mrb_sym mid = nsym(n->cdr->car);", "mrb_sym sym_nil_p = MRB_SYM_Q_2(s->mrb, nil);", "if (mid == sym_nil_p && n->cdr->cdr->car == NULL) {", "nil_p = TRUE;", "codegen(s, n->car, VAL);", "}", "}", "if (!nil_p) {", "codegen(s, tree->car, VAL);", "}", "pop();", "if (val || tree->cdr->car) {", "if (nil_p) {", "pos2 = genjmp2_0(s, OP_JMPNIL, cursp(), val);", "pos1 = genjmp_0(s, OP_JMP);", "dispatch(s, pos2);", "}", "else {", "pos1 = genjmp2_0(s, OP_JMPNOT, cursp(), val);", "}", "codegen(s, tree->cdr->car, val);", "if (val) pop();", "if (elsepart || val) {", "pos2 = genjmp_0(s, OP_JMP);", "dispatch(s, pos1);", "codegen(s, elsepart, val);", "dispatch(s, pos2);", "}", "else {", "dispatch(s, pos1);", "}", "}", "else {", "if (elsepart) {", "if (nil_p) {", "pos1 = genjmp2_0(s, OP_JMPNIL, cursp(), val);", "}", "else {", "pos1 = genjmp2_0(s, OP_JMPIF, cursp(), val);", "}", "codegen(s, elsepart, val);", "dispatch(s, pos1);", "}", "else if (val && !nil_p) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "}", "}", "break;", "", "case NODE_AND:", "{", "uint32_t pos;", "", "if (true_always(tree->car)) {", "codegen(s, tree->cdr, val);", "goto exit;", "}", "if (false_always(tree->car)) {", "codegen(s, tree->car, val);", "goto exit;", "}", "codegen(s, tree->car, VAL);", "pop();", "pos = genjmp2_0(s, OP_JMPNOT, cursp(), val);", "codegen(s, tree->cdr, val);", "dispatch(s, pos);", "}", "break;", "", "case NODE_OR:", "{", "uint32_t pos;", "", "if (true_always(tree->car)) {", "codegen(s, tree->car, val);", "goto exit;", "}", "if (false_always(tree->car)) {", "codegen(s, tree->cdr, val);", "goto exit;", "}", "codegen(s, tree->car, VAL);", "pop();", "pos = genjmp2_0(s, OP_JMPIF, cursp(), val);", "codegen(s, tree->cdr, val);", "dispatch(s, pos);", "}", "break;", "", "case NODE_WHILE:", "case NODE_UNTIL:", "{", "if (true_always(tree->car)) {", "if (nt == NODE_UNTIL) {", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "goto exit;", "}", "}", "else if (false_always(tree->car)) {", "if (nt == NODE_WHILE) {", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "goto exit;", "}", "}", "", "uint32_t pos = JMPLINK_START;", "struct loopinfo *lp = loop_push(s, LOOP_NORMAL);", "", "if (!val) lp->reg = -1;", "lp->pc0 = new_label(s);", "codegen(s, tree->car, VAL);", "pop();", "if (nt == NODE_WHILE) {", "pos = genjmp2_0(s, OP_JMPNOT, cursp(), NOVAL);", "}", "else {", "pos = genjmp2_0(s, OP_JMPIF, cursp(), NOVAL);", "}", "lp->pc1 = new_label(s);", "codegen(s, tree->cdr, NOVAL);", "genjmp(s, OP_JMP, lp->pc0);", "dispatch(s, pos);", "loop_pop(s, val);", "}", "break;", "", "case NODE_FOR:", "for_body(s, tree);", "if (val) push();", "break;", "", "case NODE_CASE:", "{", "int head = 0;", "uint32_t pos1, pos2, pos3, tmp;", "node *n;", "", "pos3 = JMPLINK_START;", "if (tree->car) {", "head = cursp();", "codegen(s, tree->car, VAL);", "}", "tree = tree->cdr;", "while (tree) {", "n = tree->car->car;", "pos1 = pos2 = JMPLINK_START;", "while (n) {", "codegen(s, n->car, VAL);", "if (head) {", "gen_move(s, cursp(), head, 0);", "push(); push(); pop(); pop(); pop();", "if (nint(n->car->car) == NODE_SPLAT) {", "genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, __case_eqq)), 1);", "}", "else {", "genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_OPSYM_2(s->mrb, eqq)), 1);", "}", "}", "else {", "pop();", "}", "tmp = genjmp2(s, OP_JMPIF, cursp(), pos2, NOVAL);", "pos2 = tmp;", "n = n->cdr;", "}", "if (tree->car->car) {", "pos1 = genjmp_0(s, OP_JMP);", "dispatch_linked(s, pos2);", "}", "codegen(s, tree->car->cdr, val);", "if (val) pop();", "tmp = genjmp(s, OP_JMP, pos3);", "pos3 = tmp;", "dispatch(s, pos1);", "tree = tree->cdr;", "}", "if (val) {", "uint32_t pos = cursp();", "genop_1(s, OP_LOADNIL, cursp());", "if (pos3 != JMPLINK_START) dispatch_linked(s, pos3);", "if (head) pop();", "if (cursp() != pos) {", "gen_move(s, cursp(), pos, 0);", "}", "push();", "}", "else {", "if (pos3 != JMPLINK_START) {", "dispatch_linked(s, pos3);", "}", "if (head) {", "pop();", "}", "}", "}", "break;", "", "case NODE_SCOPE:", "scope_body(s, tree, NOVAL);", "break;", "", "case NODE_FCALL:", "case NODE_CALL:", "gen_call(s, tree, val, 0);", "break;", "case NODE_SCALL:", "gen_call(s, tree, val, 1);", "break;", "", "case NODE_DOT2:", "codegen(s, tree->car, val);", "codegen(s, tree->cdr, val);", "if (val) {", "pop(); pop();", "genop_1(s, OP_RANGE_INC, cursp());", "push();", "}", "break;", "", "case NODE_DOT3:", "codegen(s, tree->car, val);", "codegen(s, tree->cdr, val);", "if (val) {", "pop(); pop();", "genop_1(s, OP_RANGE_EXC, cursp());", "push();", "}", "break;", "", "case NODE_COLON2:", "{", "int sym = new_sym(s, nsym(tree->cdr));", "", "codegen(s, tree->car, VAL);", "pop();", "genop_2(s, OP_GETMCNST, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_COLON3:", "{", "int sym = new_sym(s, nsym(tree));", "", "genop_1(s, OP_OCLASS, cursp());", "genop_2(s, OP_GETMCNST, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_ARRAY:", "{", "int n;", "", "n = gen_values(s, tree, val, 0);", "if (val) {", "if (n >= 0) {", "pop_n(n);", "genop_2(s, OP_ARRAY, cursp(), n);", "}", "push();", "}", "}", "break;", "", "case NODE_HASH:", "case NODE_KW_HASH:", "{", "int nk = gen_hash(s, tree, val, GEN_LIT_ARY_MAX);", "if (val && nk >= 0) {", "pop_n(nk*2);", "genop_2(s, OP_HASH, cursp(), nk);", "push();", "}", "}", "break;", "", "case NODE_SPLAT:", "codegen(s, tree, val);", "break;", "", "case NODE_ASGN:", "gen_assignment(s, tree->car, tree->cdr, 0, val);", "break;", "", "case NODE_MASGN:", "{", "int len = 0, n = 0, post = 0;", "node *t = tree->cdr, *p;", "int rhs = cursp();", "", "if (nint(t->car) == NODE_ARRAY && t->cdr && nosplat(t->cdr)) {", "", "t = t->cdr;", "while (t) {", "codegen(s, t->car, VAL);", "len++;", "t = t->cdr;", "}", "tree = tree->car;", "if (tree->car) {", "t = tree->car;", "n = 0;", "while (t) {", "if (n < len) {", "gen_assignment(s, t->car, NULL, rhs+n, NOVAL);", "n++;", "}", "else {", "genop_1(s, OP_LOADNIL, rhs+n);", "gen_assignment(s, t->car, NULL, rhs+n, NOVAL);", "}", "t = t->cdr;", "}", "}", "t = tree->cdr;", "if (t) {", "if (t->cdr) {", "p = t->cdr->car;", "while (p) {", "post++;", "p = p->cdr;", "}", "}", "if (t->car) {", "int rn;", "", "if (len < post + n) {", "rn = 0;", "}", "else {", "rn = len - post - n;", "}", "genop_3(s, OP_ARRAY2, cursp(), rhs+n, rn);", "gen_assignment(s, t->car, NULL, cursp(), NOVAL);", "n += rn;", "}", "if (t->cdr && t->cdr->car) {", "t = t->cdr->car;", "while (n<len) {", "gen_assignment(s, t->car, NULL, rhs+n, NOVAL);", "t = t->cdr;", "n++;", "}", "}", "}", "pop_n(len);", "if (val) {", "genop_2(s, OP_ARRAY, rhs, len);", "push();", "}", "}", "else {", "", "codegen(s, t, VAL);", "gen_vmassignment(s, tree->car, rhs, val);", "if (!val) {", "pop();", "}", "}", "}", "break;", "", "case NODE_OP_ASGN:", "{", "mrb_sym sym = nsym(tree->cdr->car);", "mrb_int len;", "const char *name = mrb_sym_name_len(s->mrb, sym, &len);", "int idx, callargs = -1, vsp = -1;", "", "if ((len == 2 && name[0] == '|' && name[1] == '|') &&", "(nint(tree->car->car) == NODE_CONST ||", "nint(tree->car->car) == NODE_CVAR)) {", "int catch_entry, begin, end;", "int noexc, exc;", "struct loopinfo *lp;", "", "lp = loop_push(s, LOOP_BEGIN);", "lp->pc0 = new_label(s);", "catch_entry = catch_handler_new(s);", "begin = s->pc;", "exc = cursp();", "codegen(s, tree->car, VAL);", "end = s->pc;", "noexc = genjmp_0(s, OP_JMP);", "lp->type = LOOP_RESCUE;", "catch_handler_set(s, catch_entry, MRB_CATCH_RESCUE, begin, end, s->pc);", "genop_1(s, OP_EXCEPT, exc);", "genop_1(s, OP_LOADF, exc);", "dispatch(s, noexc);", "loop_pop(s, NOVAL);", "}", "else if (nint(tree->car->car) == NODE_CALL) {", "node *n = tree->car->cdr;", "int base, i, nargs = 0;", "callargs = 0;", "", "if (val) {", "vsp = cursp();", "push();", "}", "codegen(s, n->car, VAL);", "idx = new_sym(s, nsym(n->cdr->car));", "base = cursp()-1;", "if (n->cdr->cdr->car) {", "nargs = gen_values(s, n->cdr->cdr->car->car, VAL, 13);", "if (nargs >= 0) {", "callargs = nargs;", "}", "else {", "push();", "nargs = 1;", "callargs = CALL_MAXARGS;", "}", "}", "", "gen_move(s, cursp(), base, 1);", "for (i=0; i<nargs; i++) {", "gen_move(s, cursp()+i+1, base+i+1, 1);", "}", "push_n(nargs+2);pop_n(nargs+2);", "genop_3(s, OP_SEND, cursp(), idx, callargs);", "push();", "}", "else {", "codegen(s, tree->car, VAL);", "}", "if (len == 2 &&", "((name[0] == '|' && name[1] == '|') ||", "(name[0] == '&' && name[1] == '&'))) {", "uint32_t pos;", "", "pop();", "if (val) {", "if (vsp >= 0) {", "gen_move(s, vsp, cursp(), 1);", "}", "pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);", "}", "else {", "pos = genjmp2_0(s, name[0]=='|'?OP_JMPIF:OP_JMPNOT, cursp(), val);", "}", "codegen(s, tree->cdr->cdr->car, VAL);", "pop();", "if (val && vsp >= 0) {", "gen_move(s, vsp, cursp(), 1);", "}", "if (nint(tree->car->car) == NODE_CALL) {", "if (callargs == CALL_MAXARGS) {", "pop();", "genop_2(s, OP_ARYPUSH, cursp(), 1);", "}", "else {", "pop_n(callargs);", "callargs++;", "}", "pop();", "idx = new_sym(s, attrsym(s, nsym(tree->car->cdr->cdr->car)));", "genop_3(s, OP_SEND, cursp(), idx, callargs);", "}", "else {", "gen_assignment(s, tree->car, NULL, cursp(), val);", "}", "dispatch(s, pos);", "goto exit;", "}", "codegen(s, tree->cdr->cdr->car, VAL);", "push(); pop();", "pop(); pop();", "", "if (len == 1 && name[0] == '+')  {", "gen_addsub(s, OP_ADD, cursp());", "}", "else if (len == 1 && name[0] == '-')  {", "gen_addsub(s, OP_SUB, cursp());", "}", "else if (len == 1 && name[0] == '*')  {", "genop_1(s, OP_MUL, cursp());", "}", "else if (len == 1 && name[0] == '/')  {", "genop_1(s, OP_DIV, cursp());", "}", "else if (len == 1 && name[0] == '<')  {", "genop_1(s, OP_LT, cursp());", "}", "else if (len == 2 && name[0] == '<' && name[1] == '=')  {", "genop_1(s, OP_LE, cursp());", "}", "else if (len == 1 && name[0] == '>')  {", "genop_1(s, OP_GT, cursp());", "}", "else if (len == 2 && name[0] == '>' && name[1] == '=')  {", "genop_1(s, OP_GE, cursp());", "}", "else {", "idx = new_sym(s, sym);", "genop_3(s, OP_SEND, cursp(), idx, 1);", "}", "if (callargs < 0) {", "gen_assignment(s, tree->car, NULL, cursp(), val);", "}", "else {", "if (val && vsp >= 0) {", "gen_move(s, vsp, cursp(), 0);", "}", "if (callargs == CALL_MAXARGS) {", "pop();", "genop_2(s, OP_ARYPUSH, cursp(), 1);", "}", "else {", "pop_n(callargs);", "callargs++;", "}", "pop();", "idx = new_sym(s, attrsym(s,nsym(tree->car->cdr->cdr->car)));", "genop_3(s, OP_SEND, cursp(), idx, callargs);", "}", "}", "break;", "", "case NODE_SUPER:", "{", "codegen_scope *s2 = s;", "int lv = 0;", "int n = 0, nk = 0, st = 0;", "", "push();", "while (!s2->mscope) {", "lv++;", "s2 = s2->prev;", "if (!s2) break;", "}", "if (tree) {", "node *args = tree->car;", "if (args) {", "st = n = gen_values(s, args, VAL, 14);", "if (n < 0) {", "st = 1; n = 15;", "push();", "}", "}", "", "if (s2 && (s2->ainfo & 0x1) && tree->cdr->car) {", "nk = gen_hash(s, tree->cdr->car->cdr, VAL, 14);", "if (nk < 0) {st++; nk = 15;}", "else st += nk*2;", "n |= nk<<4;", "}", "", "if (tree->cdr->cdr) {", "codegen(s, tree->cdr->cdr, VAL);", "}", "else if (!s2) {", "push();", "}", "else {", "gen_blkmove(s, s2->ainfo, lv);", "}", "st++;", "}", "else {", "if (!s2) push();", "else gen_blkmove(s, s2->ainfo, lv);", "st++;", "}", "pop_n(st+1);", "genop_2(s, OP_SUPER, cursp(), n);", "if (val) push();", "}", "break;", "", "case NODE_ZSUPER:", "{", "codegen_scope *s2 = s;", "int lv = 0;", "uint16_t ainfo = 0;", "int n = CALL_MAXARGS;", "int sp = cursp();", "", "push();", "while (!s2->mscope) {", "lv++;", "s2 = s2->prev;", "if (!s2) break;", "}", "if (s2 && s2->ainfo > 0) {", "ainfo = s2->ainfo;", "}", "if (ainfo > 0) {", "genop_2S(s, OP_ARGARY, cursp(), (ainfo<<4)|(lv & 0xf));", "push(); push(); push();", "pop(); pop(); pop();", "", "if (ainfo & 0x1) {", "n |= CALL_MAXARGS<<4;", "push();", "}", "", "if (tree && tree->cdr && tree->cdr->cdr) {", "push();", "codegen(s, tree->cdr->cdr, VAL);", "}", "}", "else {", "", "if (tree && tree->cdr && tree->cdr->cdr) {", "codegen(s, tree->cdr->cdr, VAL);", "}", "else {", "gen_blkmove(s, 0, lv);", "}", "n = 0;", "}", "s->sp = sp;", "genop_2(s, OP_SUPER, cursp(), n);", "if (val) push();", "}", "break;", "", "case NODE_RETURN:", "if (tree) {", "gen_retval(s, tree);", "}", "else {", "genop_1(s, OP_LOADNIL, cursp());", "}", "if (s->loop) {", "gen_return(s, OP_RETURN_BLK, cursp());", "}", "else {", "gen_return(s, OP_RETURN, cursp());", "}", "if (val) push();", "break;", "", "case NODE_YIELD:", "{", "codegen_scope *s2 = s;", "int lv = 0, ainfo = -1;", "int n = 0, sendv = 0;", "", "while (!s2->mscope) {", "lv++;", "s2 = s2->prev;", "if (!s2) break;", "}", "if (s2) {", "ainfo = (int)s2->ainfo;", "}", "if (ainfo < 0) codegen_error(s, \"invalid yield (SyntaxError)\");", "push();", "if (tree) {", "n = gen_values(s, tree, VAL, 14);", "if (n < 0) {", "n = sendv = 1;", "push();", "}", "}", "push();pop();", "pop_n(n+1);", "genop_2S(s, OP_BLKPUSH, cursp(), (ainfo<<4)|(lv & 0xf));", "if (sendv) n = CALL_MAXARGS;", "genop_3(s, OP_SEND, cursp(), new_sym(s, MRB_SYM_2(s->mrb, call)), n);", "if (val) push();", "}", "break;", "", "case NODE_BREAK:", "loop_break(s, tree);", "if (val) push();", "break;", "", "case NODE_NEXT:", "if (!s->loop) {", "raise_error(s, \"unexpected next\");", "}", "else if (s->loop->type == LOOP_NORMAL) {", "codegen(s, tree, NOVAL);", "genjmp(s, OP_JMPUW, s->loop->pc0);", "}", "else {", "if (tree) {", "codegen(s, tree, VAL);", "pop();", "}", "else {", "genop_1(s, OP_LOADNIL, cursp());", "}", "gen_return(s, OP_RETURN, cursp());", "}", "if (val) push();", "break;", "", "case NODE_REDO:", "if (!s->loop || s->loop->type == LOOP_BEGIN || s->loop->type == LOOP_RESCUE) {", "raise_error(s, \"unexpected redo\");", "}", "else {", "genjmp(s, OP_JMPUW, s->loop->pc1);", "}", "if (val) push();", "break;", "", "case NODE_RETRY:", "{", "const char *msg = \"unexpected retry\";", "const struct loopinfo *lp = s->loop;", "", "while (lp && lp->type != LOOP_RESCUE) {", "lp = lp->prev;", "}", "if (!lp) {", "raise_error(s, msg);", "}", "else {", "genjmp(s, OP_JMPUW, lp->pc0);", "}", "if (val) push();", "}", "break;", "", "case NODE_LVAR:", "if (val) {", "int idx = lv_idx(s, nsym(tree));", "", "if (idx > 0) {", "gen_move(s, cursp(), idx, val);", "}", "else {", "gen_getupvar(s, cursp(), nsym(tree));", "}", "push();", "}", "break;", "", "case NODE_NVAR:", "if (val) {", "int idx = nint(tree);", "", "gen_move(s, cursp(), idx, val);", "", "push();", "}", "break;", "", "case NODE_GVAR:", "{", "int sym = new_sym(s, nsym(tree));", "", "genop_2(s, OP_GETGV, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_IVAR:", "{", "int sym = new_sym(s, nsym(tree));", "", "genop_2(s, OP_GETIV, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_CVAR:", "{", "int sym = new_sym(s, nsym(tree));", "", "genop_2(s, OP_GETCV, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_CONST:", "{", "int sym = new_sym(s, nsym(tree));", "", "genop_2(s, OP_GETCONST, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_BACK_REF:", "if (val) {", "char buf[] = {'$', nchar(tree)};", "int sym = new_sym(s, mrb_intern(s->mrb, buf, sizeof(buf)));", "", "genop_2(s, OP_GETGV, cursp(), sym);", "push();", "}", "break;", "", "case NODE_NTH_REF:", "if (val) {", "mrb_state *mrb = s->mrb;", "mrb_value str;", "int sym;", "", "str = mrb_format(mrb, \"$%d\", nint(tree));", "sym = new_sym(s, mrb_intern_str(mrb, str));", "genop_2(s, OP_GETGV, cursp(), sym);", "push();", "}", "break;", "", "case NODE_ARG:", "", "break;", "", "case NODE_BLOCK_ARG:", "if (!tree) {", "int idx = lv_idx(s, MRB_OPSYM_2(s->mrb, and));", "", "if (idx == 0) {", "codegen_error(s, \"no anonymous block argument\");", "}", "gen_move(s, cursp(), idx, val);", "}", "else {", "codegen(s, tree, val);", "}", "break;", "", "case NODE_INT:", "if (val) {", "char *p = (char*)tree->car;", "int base = nint(tree->cdr->car);", "mrb_int i;", "mrb_bool overflow;", "", "i = readint(s, p, base, FALSE, &overflow);", "if (overflow) {", "int off = new_litbn(s, p, base, FALSE);", "genop_2(s, OP_LOADL, cursp(), off);", "}", "else {", "gen_int(s, cursp(), i);", "}", "push();", "}", "break;", "", "#ifndef MRB_NO_FLOAT", "case NODE_FLOAT:", "if (val) {", "char *p = (char*)tree;", "mrb_float f = mrb_float_read(p, NULL);", "int off = new_lit(s, mrb_float_value(s->mrb, f));", "", "genop_2(s, OP_LOADL, cursp(), off);", "push();", "}", "break;", "#endif", "", "case NODE_NEGATE:", "{", "nt = nint(tree->car);", "switch (nt) {", "#ifndef MRB_NO_FLOAT", "case NODE_FLOAT:", "if (val) {", "char *p = (char*)tree->cdr;", "mrb_float f = mrb_float_read(p, NULL);", "int off = new_lit(s, mrb_float_value(s->mrb, -f));", "", "genop_2(s, OP_LOADL, cursp(), off);", "push();", "}", "break;", "#endif", "", "case NODE_INT:", "if (val) {", "char *p = (char*)tree->cdr->car;", "int base = nint(tree->cdr->cdr->car);", "mrb_int i;", "mrb_bool overflow;", "", "i = readint(s, p, base, TRUE, &overflow);", "if (overflow) {", "int off = new_litbn(s, p, base, TRUE);", "genop_2(s, OP_LOADL, cursp(), off);", "}", "else {", "gen_int(s, cursp(), i);", "}", "push();", "}", "break;", "", "default:", "if (val) {", "codegen(s, tree, VAL);", "pop();", "push_n(2);pop_n(2);", "mrb_sym minus = MRB_OPSYM_2(s->mrb, minus);", "if (!gen_uniop(s, minus, cursp())) {", "genop_3(s, OP_SEND, cursp(), new_sym(s, minus), 0);", "}", "push();", "}", "else {", "codegen(s, tree, NOVAL);", "}", "break;", "}", "}", "break;", "", "case NODE_STR:", "if (val) {", "char *p = (char*)tree->car;", "size_t len = (intptr_t)tree->cdr;", "int ai = mrb_gc_arena_save(s->mrb);", "int off = new_lit(s, mrb_str_new(s->mrb, p, len));", "", "mrb_gc_arena_restore(s->mrb, ai);", "genop_2(s, OP_STRING, cursp(), off);", "push();", "}", "break;", "", "case NODE_HEREDOC:", "tree = ((struct mrb_parser_heredoc_info *)tree)->doc;", "", "case NODE_DSTR:", "if (val) {", "node *n = tree;", "", "if (!n) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "break;", "}", "codegen(s, n->car, VAL);", "n = n->cdr;", "while (n) {", "codegen(s, n->car, VAL);", "pop(); pop();", "genop_1(s, OP_STRCAT, cursp());", "push();", "n = n->cdr;", "}", "}", "else {", "node *n = tree;", "", "while (n) {", "if (nint(n->car->car) != NODE_STR) {", "codegen(s, n->car, NOVAL);", "}", "n = n->cdr;", "}", "}", "break;", "", "case NODE_WORDS:", "gen_literal_array(s, tree, FALSE, val);", "break;", "", "case NODE_SYMBOLS:", "gen_literal_array(s, tree, TRUE, val);", "break;", "", "case NODE_DXSTR:", "{", "node *n;", "int ai = mrb_gc_arena_save(s->mrb);", "int sym = new_sym(s, MRB_SYM_2(s->mrb, Kernel));", "", "genop_1(s, OP_LOADSELF, cursp());", "push();", "codegen(s, tree->car, VAL);", "n = tree->cdr;", "while (n) {", "if (nint(n->car->car) == NODE_XSTR) {", "n->car->car = (struct mrb_ast_node*)(intptr_t)NODE_STR;", "mrb_assert(!n->cdr);", "}", "codegen(s, n->car, VAL);", "pop(); pop();", "genop_1(s, OP_STRCAT, cursp());", "push();", "n = n->cdr;", "}", "push();", "pop_n(3);", "sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));", "genop_3(s, OP_SEND, cursp(), sym, 1);", "if (val) push();", "mrb_gc_arena_restore(s->mrb, ai);", "}", "break;", "", "case NODE_XSTR:", "{", "char *p = (char*)tree->car;", "size_t len = (intptr_t)tree->cdr;", "int ai = mrb_gc_arena_save(s->mrb);", "int off = new_lit(s, mrb_str_new(s->mrb, p, len));", "int sym;", "", "genop_1(s, OP_LOADSELF, cursp());", "push();", "genop_2(s, OP_STRING, cursp(), off);", "push(); push();", "pop_n(3);", "sym = new_sym(s, MRB_OPSYM_2(s->mrb, tick));", "genop_3(s, OP_SEND, cursp(), sym, 1);", "if (val) push();", "mrb_gc_arena_restore(s->mrb, ai);", "}", "break;", "", "case NODE_REGX:", "if (val) {", "char *p1 = (char*)tree->car;", "char *p2 = (char*)tree->cdr->car;", "char *p3 = (char*)tree->cdr->cdr;", "int ai = mrb_gc_arena_save(s->mrb);", "int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));", "int off = new_lit(s, mrb_str_new_cstr(s->mrb, p1));", "int argc = 1;", "", "genop_1(s, OP_OCLASS, cursp());", "genop_2(s, OP_GETMCNST, cursp(), sym);", "push();", "genop_2(s, OP_STRING, cursp(), off);", "push();", "if (p2 || p3) {", "if (p2) {", "off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));", "genop_2(s, OP_STRING, cursp(), off);", "}", "else {", "genop_1(s, OP_LOADNIL, cursp());", "}", "push();", "argc++;", "if (p3) {", "off = new_lit(s, mrb_str_new(s->mrb, p3, 1));", "genop_2(s, OP_STRING, cursp(), off);", "push();", "argc++;", "}", "}", "push();", "pop_n(argc+2);", "sym = new_sym(s, MRB_SYM_2(s->mrb, compile));", "genop_3(s, OP_SEND, cursp(), sym, argc);", "mrb_gc_arena_restore(s->mrb, ai);", "push();", "}", "break;", "", "case NODE_DREGX:", "if (val) {", "node *n = tree->car;", "int ai = mrb_gc_arena_save(s->mrb);", "int sym = new_sym(s, mrb_intern_lit(s->mrb, REGEXP_CLASS));", "int argc = 1;", "int off;", "char *p;", "", "genop_1(s, OP_OCLASS, cursp());", "genop_2(s, OP_GETMCNST, cursp(), sym);", "push();", "codegen(s, n->car, VAL);", "n = n->cdr;", "while (n) {", "codegen(s, n->car, VAL);", "pop(); pop();", "genop_1(s, OP_STRCAT, cursp());", "push();", "n = n->cdr;", "}", "n = tree->cdr->cdr;", "if (n->car) {", "p = (char*)n->car;", "off = new_lit(s, mrb_str_new_cstr(s->mrb, p));", "codegen(s, tree->car, VAL);", "genop_2(s, OP_STRING, cursp(), off);", "pop();", "genop_1(s, OP_STRCAT, cursp());", "push();", "}", "if (n->cdr->car) {", "char *p2 = (char*)n->cdr->car;", "off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));", "genop_2(s, OP_STRING, cursp(), off);", "push();", "argc++;", "}", "if (n->cdr->cdr) {", "char *p2 = (char*)n->cdr->cdr;", "off = new_lit(s, mrb_str_new_cstr(s->mrb, p2));", "genop_2(s, OP_STRING, cursp(), off);", "push();", "argc++;", "}", "push();", "pop_n(argc+2);", "sym = new_sym(s, MRB_SYM_2(s->mrb, compile));", "genop_3(s, OP_SEND, cursp(), sym, argc);", "mrb_gc_arena_restore(s->mrb, ai);", "push();", "}", "else {", "node *n = tree->car;", "", "while (n) {", "if (nint(n->car->car) != NODE_STR) {", "codegen(s, n->car, NOVAL);", "}", "n = n->cdr;", "}", "}", "break;", "", "case NODE_SYM:", "if (val) {", "int sym = new_sym(s, nsym(tree));", "", "genop_2(s, OP_LOADSYM, cursp(), sym);", "push();", "}", "break;", "", "case NODE_DSYM:", "codegen(s, tree, val);", "if (val) {", "gen_intern(s);", "}", "break;", "", "case NODE_SELF:", "if (val) {", "genop_1(s, OP_LOADSELF, cursp());", "push();", "}", "break;", "", "case NODE_NIL:", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "break;", "", "case NODE_TRUE:", "if (val) {", "genop_1(s, OP_LOADT, cursp());", "push();", "}", "break;", "", "case NODE_FALSE:", "if (val) {", "genop_1(s, OP_LOADF, cursp());", "push();", "}", "break;", "", "case NODE_ALIAS:", "{", "int a = new_sym(s, nsym(tree->car));", "int b = new_sym(s, nsym(tree->cdr));", "", "genop_2(s, OP_ALIAS, a, b);", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "}", "break;", "", "case NODE_UNDEF:", "{", "node *t = tree;", "", "while (t) {", "int symbol = new_sym(s, nsym(t->car));", "genop_1(s, OP_UNDEF, symbol);", "t = t->cdr;", "}", "if (val) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "}", "break;", "", "case NODE_CLASS:", "{", "int idx;", "node *body;", "", "if (tree->car->car == (node*)0) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "else if (tree->car->car == (node*)1) {", "genop_1(s, OP_OCLASS, cursp());", "push();", "}", "else {", "codegen(s, tree->car->car, VAL);", "}", "if (tree->cdr->car) {", "codegen(s, tree->cdr->car, VAL);", "}", "else {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "pop(); pop();", "idx = new_sym(s, nsym(tree->car->cdr));", "genop_2(s, OP_CLASS, cursp(), idx);", "body = tree->cdr->cdr->car;", "if (nint(body->cdr->car) == NODE_BEGIN && body->cdr->cdr == NULL) {", "genop_1(s, OP_LOADNIL, cursp());", "}", "else {", "idx = scope_body(s, body, val);", "genop_2(s, OP_EXEC, cursp(), idx);", "}", "if (val) {", "push();", "}", "}", "break;", "", "case NODE_MODULE:", "{", "int idx;", "", "if (tree->car->car == (node*)0) {", "genop_1(s, OP_LOADNIL, cursp());", "push();", "}", "else if (tree->car->car == (node*)1) {", "genop_1(s, OP_OCLASS, cursp());", "push();", "}", "else {", "codegen(s, tree->car->car, VAL);", "}", "pop();", "idx = new_sym(s, nsym(tree->car->cdr));", "genop_2(s, OP_MODULE, cursp(), idx);", "if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&", "tree->cdr->car->cdr->cdr == NULL) {", "genop_1(s, OP_LOADNIL, cursp());", "}", "else {", "idx = scope_body(s, tree->cdr->car, val);", "genop_2(s, OP_EXEC, cursp(), idx);", "}", "if (val) {", "push();", "}", "}", "break;", "", "case NODE_SCLASS:", "{", "int idx;", "", "codegen(s, tree->car, VAL);", "pop();", "genop_1(s, OP_SCLASS, cursp());", "if (nint(tree->cdr->car->cdr->car) == NODE_BEGIN &&", "tree->cdr->car->cdr->cdr == NULL) {", "genop_1(s, OP_LOADNIL, cursp());", "}", "else {", "idx = scope_body(s, tree->cdr->car, val);", "genop_2(s, OP_EXEC, cursp(), idx);", "}", "if (val) {", "push();", "}", "}", "break;", "", "case NODE_DEF:", "{", "int sym = new_sym(s, nsym(tree->car));", "int idx = lambda_body(s, tree->cdr, 0);", "", "genop_1(s, OP_TCLASS, cursp());", "push();", "genop_2(s, OP_METHOD, cursp(), idx);", "push(); pop();", "pop();", "genop_2(s, OP_DEF, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_SDEF:", "{", "node *recv = tree->car;", "int sym = new_sym(s, nsym(tree->cdr->car));", "int idx = lambda_body(s, tree->cdr->cdr, 0);", "", "codegen(s, recv, VAL);", "pop();", "genop_1(s, OP_SCLASS, cursp());", "push();", "genop_2(s, OP_METHOD, cursp(), idx);", "pop();", "genop_2(s, OP_DEF, cursp(), sym);", "if (val) push();", "}", "break;", "", "case NODE_POSTEXE:", "codegen(s, tree, NOVAL);", "break;", "", "default:", "break;", "}", "exit:", "s->rlev = rlev;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WritePALMImage(const ImageInfo *image_info,", "   Image *image)", " {", "   ExceptionInfo", "     *exception;", " ", "   MagickBooleanType", "     status;", " ", "   MagickOffsetType", "     currentOffset,", "     offset,", "     scene;", " ", "   MagickSizeType", "     cc;", " ", "   PixelPacket", "     transpix;", " ", "   QuantizeInfo", "     *quantize_info;", " ", "   register IndexPacket", "     *indexes;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *p;", " ", "   ssize_t", "     y;", " ", "   size_t", "     count,", "     bits_per_pixel,", "     bytes_per_row,", "     nextDepthOffset,", "     one;", " ", "   unsigned char", "      bit,", "      byte,", "      color,", "    *lastrow,", "     *last_row,", "      *one_row,", "      *ptr,", "      version;", " ", "   unsigned int", "     transparentIndex;", " ", "   unsigned short", "     color16,", "     flags;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "   exception=AcquireExceptionInfo();", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     return(status);", "   quantize_info=AcquireQuantizeInfo(image_info);", "   flags=0;", "   currentOffset=0;", "   transparentIndex=0;", "   transpix.red=0;", "   transpix.green=0;", "   transpix.blue=0;", "   transpix.opacity=0;", "   one=1;", "   version=0;", "   scene=0;", "   do", "   {", "     (void) TransformImageColorspace(image,sRGBColorspace);", "     count=GetNumberColors(image,NULL,exception);", "     for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;", "     if (bits_per_pixel > 16)", "       bits_per_pixel=16;", "     else", "       if (bits_per_pixel < 16)", "         (void) TransformImageColorspace(image,image->colorspace);", "     if (bits_per_pixel < 8)", "       {", "         (void) TransformImageColorspace(image,GRAYColorspace);", "         (void) SetImageType(image,PaletteType);", "         (void) SortColormapByIntensity(image);", "       }", "     if ((image->storage_class == PseudoClass) && (image->colors > 256))", "       (void) SetImageStorageClass(image,DirectClass);", "     if (image->storage_class == PseudoClass)", "       flags|=PALM_HAS_COLORMAP_FLAG;", "     else", "       flags|=PALM_IS_DIRECT_COLOR;", "     (void) WriteBlobMSBShort(image,(unsigned short) image->columns);  ", "     (void) WriteBlobMSBShort(image,(unsigned short) image->rows);   ", "     bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/", "       bits_per_pixel))*2;", "     (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);", "     if ((image_info->compression == RLECompression) ||", "         (image_info->compression == FaxCompression))", "       flags|=PALM_IS_COMPRESSED_FLAG;", "     (void) WriteBlobMSBShort(image, flags);", "     (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);", "     if (bits_per_pixel > 1)", "       version=1;", "     if ((image_info->compression == RLECompression) ||", "         (image_info->compression == FaxCompression))", "       version=2;", "     (void) WriteBlobByte(image,version);", "     (void) WriteBlobMSBShort(image,0);   ", "     (void) WriteBlobByte(image,(unsigned char) transparentIndex);", "     if (image_info->compression == RLECompression)", "       (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);", "     else", "       if (image_info->compression == FaxCompression)", "         (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);", "       else", "         (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);", "     (void) WriteBlobMSBShort(image,0);   ", "     offset=16;", "     if (bits_per_pixel == 16)", "       {", "         (void) WriteBlobByte(image,5);   ", "         (void) WriteBlobByte(image,6);   ", "         (void) WriteBlobByte(image,5);   ", "         (void) WriteBlobByte(image,0);   ", "         (void) WriteBlobMSBLong(image,0);   ", "         offset+=8;", "       }", "     if (bits_per_pixel == 8)", "       {", "         if (flags & PALM_HAS_COLORMAP_FLAG)   ", "           {", "             quantize_info->dither=IsPaletteImage(image,&image->exception);", "             quantize_info->number_colors=image->colors;", "             (void) QuantizeImage(quantize_info,image);", "             (void) WriteBlobMSBShort(image,(unsigned short) image->colors);", "             for (count = 0; count < image->colors; count++)", "             {", "               (void) WriteBlobByte(image,(unsigned char) count);", "               (void) WriteBlobByte(image,ScaleQuantumToChar(", "                 image->colormap[count].red));", "               (void) WriteBlobByte(image,", "                 ScaleQuantumToChar(image->colormap[count].green));", "               (void) WriteBlobByte(image,", "                 ScaleQuantumToChar(image->colormap[count].blue));", "             }", "             offset+=2+count*4;", "           }", "       else   ", "         {", "           Image", "             *affinity_image;", " ", "           affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,", "             exception);", "           (void) TransformImageColorspace(affinity_image,", "             affinity_image->colorspace);", "           (void) RemapImage(quantize_info,image,affinity_image);", "           for (y=0; y < (ssize_t) image->rows; y++)", "           {", "             p=GetAuthenticPixels(image,0,y,image->columns,1,exception);", "             indexes=GetAuthenticIndexQueue(image);", "             for (x=0; x < (ssize_t) image->columns; x++)", "               SetPixelIndex(indexes+x,FindColor(&image->colormap[", "                 (ssize_t) GetPixelIndex(indexes+x)]));", "           }", "           affinity_image=DestroyImage(affinity_image);", "         }", "        }", "      if (flags & PALM_IS_COMPRESSED_FLAG)", "        (void) WriteBlobMSBShort(image,0);   ", "    lastrow=(unsigned char *) NULL;", "     last_row=(unsigned char *) NULL;", "      if (image_info->compression == FaxCompression)", "      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,", "        sizeof(*lastrow));", "       ", "       {", "         last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,", "           sizeof(*last_row));", "         if (last_row == (unsigned char *) NULL)", "           {", "             quantize_info=DestroyQuantizeInfo(quantize_info);", "             ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "           }", "       }", "      one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,", "        sizeof(*one_row));", "      if (one_row == (unsigned char *) NULL)", "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       {", "         quantize_info=DestroyQuantizeInfo(quantize_info);", "         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");", "       }", "      for (y=0; y < (ssize_t) image->rows; y++)", "      {", "        ptr=one_row;", "       (void) ResetMagickMemory(ptr,0,bytes_per_row);", "       p=GetAuthenticPixels(image,0,y,image->columns,1,exception);", "       if (p == (PixelPacket *) NULL)", "         break;", "       indexes=GetAuthenticIndexQueue(image);", "       if (bits_per_pixel == 16)", "         {", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/", "               (size_t) QuantumRange) << 11) |", "               (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) |", "               ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange));", "             if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)", "               {", "                 transpix.red=GetPixelRed(p);", "                 transpix.green=GetPixelGreen(p);", "                 transpix.blue=GetPixelBlue(p);", "                 transpix.opacity=GetPixelOpacity(p);", "                 flags|=PALM_HAS_TRANSPARENCY_FLAG;", "               }", "             *ptr++=(unsigned char) ((color16 >> 8) & 0xff);", "             *ptr++=(unsigned char) (color16 & 0xff);", "             p++;", "           }", "         }", "       else", "         {", "           byte=0x00;", "           bit=(unsigned char) (8-bits_per_pixel);", "           for (x=0; x < (ssize_t) image->columns; x++)", "           {", "             if (bits_per_pixel >= 8)", "               color=(unsigned char) GetPixelIndex(indexes+x);", "             else", "               color=(unsigned char) (GetPixelIndex(indexes+x)*", "                 ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));", "             byte|=color << bit;", "             if (bit != 0)", "               bit-=(unsigned char) bits_per_pixel;", "             else", "               {", "                 *ptr++=byte;", "                 byte=0x00;", "                 bit=(unsigned char) (8-bits_per_pixel);", "               }", "           }", "           if ((image->columns % (8/bits_per_pixel)) != 0)", "             *ptr++=byte;", "         }", "       if (image_info->compression == RLECompression)", "         {", "           x=0;", "           while (x < (ssize_t) bytes_per_row)", "           {", "             byte=one_row[x];", "             count=1;", "             while ((one_row[++x] == byte) && (count < 255) &&", "                    (x < (ssize_t) bytes_per_row))", "               count++;", "             (void) WriteBlobByte(image,(unsigned char) count);", "             (void) WriteBlobByte(image,(unsigned char) byte);", "           }", "         }", "       else", "         if (image_info->compression == FaxCompression)", "           {", "             char", "               tmpbuf[8],", "               *tptr;", " ", "             for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)", "             {", "                tptr = tmpbuf;", "                for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)", "                {", "                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))", "                 if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))", "                    {", "                      byte |= (1 << (7 - bit));", "                      *tptr++ = (char) one_row[x + bit];", "                   }", "               }", "                (void) WriteBlobByte(image, byte);", "                (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);", "              }", "            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);", "             (void) CopyMagickMemory(last_row,one_row,bytes_per_row);", "            }", "          else", "            (void) WriteBlob(image,bytes_per_row,one_row);", "       }", "     if (flags & PALM_HAS_TRANSPARENCY_FLAG)", "       {", "         offset=SeekBlob(image,currentOffset+6,SEEK_SET);", "         (void) WriteBlobMSBShort(image,flags);", "         offset=SeekBlob(image,currentOffset+12,SEEK_SET);", "         (void) WriteBlobByte(image,(unsigned char) transparentIndex);   ", "       }", "     if (bits_per_pixel == 16)", "        {", "          offset=SeekBlob(image,currentOffset+20,SEEK_SET);", "          (void) WriteBlobByte(image,0);   ", "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));", "        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));", "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));", "         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/", "           QuantumRange));", "         (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/", "           QuantumRange));", "         (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/", "           QuantumRange));", "        }", "      if (flags & PALM_IS_COMPRESSED_FLAG)   ", "        {", "         offset=SeekBlob(image,currentOffset+offset,SEEK_SET);", "         (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-", "           currentOffset-offset));", "        }", "      if (one_row != (unsigned char *) NULL)", "        one_row=(unsigned char *) RelinquishMagickMemory(one_row);", "    if (lastrow != (unsigned char *) NULL)", "      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);", "     if (last_row != (unsigned char *) NULL)", "       last_row=(unsigned char *) RelinquishMagickMemory(last_row);", "      if (GetNextImageInList(image) == (Image *) NULL)", "        break;", "       ", "     for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)", "       (void) WriteBlobByte(image,0);", "      ", "     (void) SeekBlob(image,currentOffset+10,SEEK_SET);", "     nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);", "     (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);", "     currentOffset=(MagickOffsetType) GetBlobSize(image);", "     (void) SeekBlob(image,currentOffset,SEEK_SET);", "     image=SyncNextImageInList(image);", "     status=SetImageProgress(image,SaveImagesTag,scene++,", "       GetImageListLength(image));", "     if (status == MagickFalse)", "       break;", "   } while (image_info->adjoin != MagickFalse);", "   quantize_info=DestroyQuantizeInfo(quantize_info);", "   (void) CloseBlob(image);", "   (void) DestroyExceptionInfo(exception);", "   return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int xfrm6_tunnel_rcv(struct sk_buff *skb)", " {", " \tstruct ipv6hdr *iph = ipv6_hdr(skb);", "  \t__be32 spi;", "  ", "  \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);", "\treturn xfrm6_rcv_spi(skb, spi);", " \treturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,", "  \t\t\t\t   u16 selector, int seg)", "  {", "  \tu8 cpl = ctxt->ops->cpl(ctxt);", " ", " \t ", " \tif (seg == VCPU_SREG_SS && selector == 3 &&", " \t    ctxt->mode == X86EMUL_MODE_PROT64)", " \t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);", " ", "  \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,", "  \t\t\t\t\t X86_TRANSFER_NONE, NULL);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" PHP_FUNCTION(imagecrop)", " {", " \tzval *IM;", " \tgdImagePtr im;", " \tgdImagePtr im_crop;", " \tgdRect rect;", " \tzval *z_rect;", " \tzval **tmp;", " ", " \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &z_rect) == FAILURE)  {", " \t\treturn;", " \t}", " ", "  \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);", "  ", "  \tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {", "\t\trect.x = Z_LVAL_PP(tmp);", " \t\tif (Z_TYPE_PP(tmp) != IS_LONG) {", " \t\t\tzval lval;", " \t\t\tlval = **tmp;", " \t\t\tzval_copy_ctor(&lval);", " \t\t\tconvert_to_long(&lval);", " \t\t\trect.x = Z_LVAL(lval);", " \t\t} else {", " \t\t\trect.x = Z_LVAL_PP(tmp);", " \t\t}", "  \t} else {", "  \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");", "  \t\tRETURN_FALSE;", "  \t}", "  ", "  \tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {", "\t\trect.y = Z_LVAL_PP(tmp);", " \t\tif (Z_TYPE_PP(tmp) != IS_LONG) {", " \t\t\tzval lval;", " \t\t\tlval = **tmp;", " \t\t\tzval_copy_ctor(&lval);", " \t\t\tconvert_to_long(&lval);", " \t\t\trect.y = Z_LVAL(lval);", " \t\t} else {", " \t\t\trect.y = Z_LVAL_PP(tmp);", " \t\t}", "  \t} else {", "  \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");", "  \t\tRETURN_FALSE;", "  \t}", "  ", "  \tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {", "\t\trect.width = Z_LVAL_PP(tmp);", " \t\tif (Z_TYPE_PP(tmp) != IS_LONG) {", " \t\t\tzval lval;", " \t\t\tlval = **tmp;", " \t\t\tzval_copy_ctor(&lval);", " \t\t\tconvert_to_long(&lval);", " \t\t\trect.width = Z_LVAL(lval);", " \t\t} else {", " \t\t\trect.width = Z_LVAL_PP(tmp);", " \t\t}", "  \t} else {", "  \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");", "  \t\tRETURN_FALSE;", "  \t}", "  ", "  \tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {", "\t\trect.height = Z_LVAL_PP(tmp);", " \t\tif (Z_TYPE_PP(tmp) != IS_LONG) {", " \t\t\tzval lval;", " \t\t\tlval = **tmp;", " \t\t\tzval_copy_ctor(&lval);", " \t\t\tconvert_to_long(&lval);", " \t\t\trect.height = Z_LVAL(lval);", " \t\t} else {", " \t\t\trect.height = Z_LVAL_PP(tmp);", " \t\t}", "  \t} else {", "  \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");", "  \t\tRETURN_FALSE;", " \t}", " ", " \tim_crop = gdImageCrop(im, &rect);", " ", " \tif (im_crop == NULL) {", " \t\tRETURN_FALSE;", " \t} else {", " \t\tZEND_REGISTER_RESOURCE(return_value, im_crop, le_gd);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["proc_wizkit_line(buf)", "char *buf;", "{", "struct obj *otmp = readobjnam(buf, (struct obj *) 0);", "", "if (otmp) {", "if (otmp != &zeroobj)", "wizkit_addinv(otmp);", "} else {", "", "config_error_add(\"Bad wizkit item: \\\"%.60s\\\"\", buf);", "return FALSE;", "}", "return TRUE;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    void TestPlaybackRate(double playback_rate) {", "    static const int kDefaultBufferSize = kSamplesPerSecond / 10;", "    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;", "     const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;", "     const int kDefaultFramesRequested = 2 * algorithm_.samples_per_second();", "  ", "      TestPlaybackRate(playback_rate, kDefaultBufferSize,", "                       kDefaultFramesRequested);", "   }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["    void CloseTabsAndExpectNotifications(", "        TabStripModel* tab_strip_model,", "        std::vector<LifecycleUnit*> lifecycle_units) {", "    std::vector<std::unique_ptr<testing::StrictMock<MockLifecycleUnitObserver>>>", "     std::vector<", "         std::unique_ptr<::testing::StrictMock<MockLifecycleUnitObserver>>>", "          observers;", "      for (LifecycleUnit* lifecycle_unit : lifecycle_units) {", "        observers.emplace_back(", "          std::make_unique<testing::StrictMock<MockLifecycleUnitObserver>>());", "           std::make_unique<::testing::StrictMock<MockLifecycleUnitObserver>>());", "        lifecycle_unit->AddObserver(observers.back().get());", "        EXPECT_CALL(*observers.back().get(),", "                    OnLifecycleUnitDestroyed(lifecycle_unit));", "     }", "     tab_strip_model->CloseAllTabs();", "   }"], "ner_tags": [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static String HHVM_FUNCTION(bcadd, const String& left, const String& right,", "int64_t scale           ) {", "if (scale < 0) scale = BCG(bc_precision);", "bc_num first, second, result;", "bc_init_num(&first);", "bc_init_num(&second);", "bc_init_num(&result);", "php_str2num(&first, (char*)left.data());", "php_str2num(&second, (char*)right.data());", "bc_add(first, second, &result, scale);", "if (result->n_scale > scale) {", "result->n_scale = scale;", "}", "String ret(bc_num2str(result), AttachString);", "bc_free_num(&first);", "bc_free_num(&second);", "bc_free_num(&result);", "return ret;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void GTextFieldSave(GTextField *gt,int utf8) {", "unichar_t *ret;", "char *cret;", "FILE *file;", "unichar_t *pt;", "", "if ( _ggadget_use_gettext ) {", "char *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);", "ret = utf82u_copy(temp);", "free(temp);", "} else", "ret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,", "txt,NULL,NULL);", "", "if ( ret==NULL )", "return;", "cret = u2def_copy(ret);", "free(ret);", "file = fopen(cret,\"w\");", "if ( file==NULL ) {", "if ( _ggadget_use_gettext )", "GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);", "else", "GWidgetError(errort,error,cret);", "free(cret);", "return;", "}", "free(cret);", "", "if ( utf8 ) {", "putc(0xef,file);", "putc(0xbb,file);", "putc(0xbf,file);", "for ( pt = gt->text ; *pt; ++pt ) {", "if ( *pt<0x80 )", "putc(*pt,file);", "else if ( *pt<0x800 ) {", "putc(0xc0 | (*pt>>6), file);", "putc(0x80 | (*pt&0x3f), file);", "} else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {", "int u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);", "putc( 0xf0 | (u>>2),file );", "putc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );", "putc( 0x80 | y,file );", "putc( 0x80 | (pt[1]&0x3f),file );", "} else {", "putc( 0xe0 | (*pt>>12),file );", "putc( 0x80 | ((*pt>>6)&0x3f),file );", "putc( 0x80 | (*pt&0x3f),file );", "}", "}", "} else {", "putc(0xfeff>>8,file);", "putc(0xfeff&0xff,file);", "for ( pt = gt->text ; *pt; ++pt ) {", "putc(*pt>>8,file);", "putc(*pt&0xff,file);", "}", "}", "fclose(file);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  void ChromeContentBrowserClient::OpenURL(", "    content::BrowserContext* browser_context,", "     content::SiteInstance* site_instance,", "      const content::OpenURLParams& params,", "    const base::Callback<void(content::WebContents*)>& callback) {", "     const base::RepeatingCallback<void(content::WebContents*)>& callback) {", "    DCHECK_CURRENTLY_ON(BrowserThread::UI);", "   DCHECK(ShouldAllowOpenURL(site_instance, params.url));", " ", "   content::BrowserContext* browser_context = site_instance->GetBrowserContext();", "  ", "  #if defined(OS_ANDROID)", "    ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,", "                                                callback);", " #else", "   NavigateParams nav_params(Profile::FromBrowserContext(browser_context),", "                             params.url, params.transition);", "   nav_params.FillNavigateParamsFromOpenURLParams(params);", "   nav_params.user_gesture = params.user_gesture;", " ", "   Navigate(&nav_params);", "   callback.Run(nav_params.navigated_or_inserted_contents);", " #endif", " }"], "ner_tags": [0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void DelayedExecutor::delayedExecute(const QString &udi)", " {", "     Solid::Device device(udi);", "  ", "      QString exec = m_service.exec();", "      MacroExpander mx(device);", "    mx.expandMacros(exec);", "     mx.expandMacrosShellQuote(exec);", "  ", "      KRun::runCommand(exec, QString(), m_service.icon(), 0);", "      deleteLater();", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["enum sctp_disposition sctp_sf_discard_chunk(struct net *net,", "const struct sctp_endpoint *ep,", "const struct sctp_association *asoc,", "const union sctp_subtype type,", "void *arg,", "struct sctp_cmd_seq *commands)", "{", "struct sctp_chunk *chunk = arg;", "", "", "", "", "", "if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))", "return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,", "commands);", "", "pr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);", "", "return SCTP_DISPOSITION_DISCARD;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PHP_METHOD(Phar, __construct)", " {", " #if !HAVE_SPL", " \tzend_throw_exception_ex(zend_exception_get_default(TSRMLS_C), 0 TSRMLS_CC, \"Cannot instantiate Phar object without SPL extension\");", " #else", " \tchar *fname, *alias = NULL, *error, *arch = NULL, *entry = NULL, *save_fname;", " \tint fname_len, alias_len = 0, arch_len, entry_len, is_data;", " #if PHP_VERSION_ID < 50300", " \tlong flags = 0;", " #else", " \tlong flags = SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS;", " #endif", " \tlong format = 0;", " \tphar_archive_object *phar_obj;", " \tphar_archive_data   *phar_data;", " \tzval *zobj = getThis(), arg1, arg2;", " ", " \tphar_obj = (phar_archive_object*)zend_object_store_get_object(getThis() TSRMLS_CC);", " ", " \tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data TSRMLS_CC);", " ", " \tif (is_data) {", " \t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {", " \t\t\treturn;", " \t\t}", " \t} else {", " \t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {", " \t\t\treturn;", " \t\t}", " \t}", " ", " \tif (phar_obj->arc.archive) {", " \t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"Cannot call constructor twice\");", " \t\treturn;", " \t}", " ", " \tsave_fname = fname;", " \tif (SUCCESS == phar_split_fname(fname, fname_len, &arch, &arch_len, &entry, &entry_len, !is_data, 2 TSRMLS_CC)) {", " \t\t ", " \t\t ", " #ifdef PHP_WIN32", " \t\tphar_unixify_path_separators(arch, arch_len);", " #endif", " \t\tfname = arch;", " \t\tfname_len = arch_len;", " #ifdef PHP_WIN32", " \t} else {", " \t\tarch = estrndup(fname, fname_len);", " \t\tarch_len = fname_len;", " \t\tfname = arch;", " \t\tphar_unixify_path_separators(arch, arch_len);", " #endif", " \t}", " ", " \tif (phar_open_or_create_filename(fname, fname_len, alias, alias_len, is_data, REPORT_ERRORS, &phar_data, &error TSRMLS_CC) == FAILURE) {", " ", " \t\tif (fname == arch && fname != save_fname) {", " \t\t\tefree(arch);", " \t\t\tfname = save_fname;", " \t\t}", " ", " \t\tif (entry) {", " \t\t\tefree(entry);", " \t\t}", " ", " \t\tif (error) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"%s\", error);", " \t\t\tefree(error);", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Phar creation or opening failed\");", " \t\t}", " ", " \t\treturn;", " \t}", " ", " \tif (is_data && phar_data->is_tar && phar_data->is_brandnew && format == PHAR_FORMAT_ZIP) {", " \t\tphar_data->is_zip = 1;", " \t\tphar_data->is_tar = 0;", " \t}", " ", " \tif (fname == arch) {", " \t\tefree(arch);", " \t\tfname = save_fname;", " \t}", " ", " \tif ((is_data && !phar_data->is_data) || (!is_data && phar_data->is_data)) {", " \t\tif (is_data) {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"PharData class can only be used for non-executable tar and zip archives\");", " \t\t} else {", " \t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC,", " \t\t\t\t\"Phar class can only be used for executable tar and zip archives\");", " \t\t}", " \t\tefree(entry);", " \t\treturn;", " \t}", " ", " \tis_data = phar_data->is_data;", " ", " \tif (!phar_data->is_persistent) {", " \t\t++(phar_data->refcount);", " \t}", " ", " \tphar_obj->arc.archive = phar_data;", " \tphar_obj->spl.oth_handler = &phar_spl_foreign_handler;", " ", " \tif (entry) {", " \t\tfname_len = spprintf(&fname, 0, \"phar:%s%s\", phar_data->fname, entry);", " \t\tefree(entry);", " \t} else {", " \t\tfname_len = spprintf(&fname, 0, \"phar:%s\", phar_data->fname);", " \t}", " ", " \tINIT_PZVAL(&arg1);", " \tZVAL_STRINGL(&arg1, fname, fname_len, 0);", "         INIT_PZVAL(&arg2);", "         ZVAL_LONG(&arg2, flags);", "  ", "       zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), ", "        zend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),", "                 &spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);", "  ", "         if (!phar_data->is_persistent) {", " \t\tphar_obj->arc.archive->is_data = is_data;", " \t} else if (!EG(exception)) {", " \t\t ", " \t\tzend_hash_add(&PHAR_GLOBALS->phar_persist_map, (const char *) phar_obj->arc.archive, sizeof(phar_obj->arc.archive), (void *) &phar_obj, sizeof(phar_archive_object **), NULL);", " \t}", " ", " \tphar_obj->spl.info_class = phar_ce_entry;", " \tefree(fname);", " #endif  ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long Track::ParseContentEncodingsEntry(long long start, long long size) {", "  IMkvReader* const pReader = m_pSegment->m_pReader;", "   assert(pReader);", " ", "  long long pos = start;", "  const long long stop = start + size;", " ", "  int count = 0;", "  while (pos < stop) {", "  long long id, size;", "  const long status = ParseElementHeader(pReader, pos, stop, id, size);", "  if (status < 0)  ", "  return status;", " ", "  if (id == 0x2240)  ", " ", "        ++count;", "  ", "      pos += size;   ", "    assert(pos <= stop);", "     if (pos > stop)", "       return E_FILE_FORMAT_INVALID;", "    }", "  ", "    if (count <= 0)", "      return -1;", "  ", "  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];", "   content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];", "    if (!content_encoding_entries_)", "      return -1;", "  ", "   content_encoding_entries_end_ = content_encoding_entries_;", " ", "   pos = start;", "  while (pos < stop) {", "  long long id, size;", "  long status = ParseElementHeader(pReader, pos, stop, id, size);", "  if (status < 0)  ", "  return status;", " ", "  if (id == 0x2240) {  ", "  ContentEncoding* const content_encoding =", "  new (std::nothrow) ContentEncoding();", "  if (!content_encoding)", "  return -1;", " ", "       status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);", "  if (status) {", "  delete content_encoding;", "  return status;", "  }", " ", "  *content_encoding_entries_end_++ = content_encoding;", " ", "      }", "  ", "      pos += size;   ", "    assert(pos <= stop);", "     if (pos > stop)", "       return E_FILE_FORMAT_INVALID;", "    }", "  ", "  assert(pos == stop);", "   if (pos != stop)", "     return E_FILE_FORMAT_INVALID;", "  ", "    return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": ["enum sctp_disposition sctp_sf_do_9_1_abort(", "struct net *net,", "const struct sctp_endpoint *ep,", "const struct sctp_association *asoc,", "const union sctp_subtype type,", "void *arg,", "struct sctp_cmd_seq *commands)", "{", "struct sctp_chunk *chunk = arg;", "", "if (!sctp_vtag_verify_either(chunk, asoc))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "", "", "", "", "", "", "", "", "", "", "if (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "", "", "", "", "", "if (SCTP_ADDR_DEL ==", "sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))", "return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);", "", "if (!sctp_err_chunk_valid(chunk))", "return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);", "", "return __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool TabLifecycleUnitSource::TabLifecycleUnit::CanFreeze(", "     DecisionDetails* decision_details) const {", "   DCHECK(decision_details->reasons().empty());", " ", " ", "   if (!IsValidStateChange(GetState(), LifecycleUnitState::PENDING_FREEZE,", "                           StateChangeReason::BROWSER_INITIATED)) {", "     return false;", "   }", " ", "   if (TabLoadTracker::Get()->GetLoadingState(GetWebContents()) !=", "       TabLoadTracker::LoadingState::LOADED) {", "      return false;", "    }", "  ", " ", "   if (GetWebContents()->GetVisibility() == content::Visibility::VISIBLE)", "     decision_details->AddReason(DecisionFailureReason::LIVE_STATE_VISIBLE);", " ", "    IsMediaTabImpl(decision_details);", "  ", "    ", "    ", "    ", "   CheckIfTabCanCommunicateWithUserWhileInBackground(GetWebContents(),", "                                                     decision_details);", " ", "    if (decision_details->reasons().empty()) {", "      decision_details->AddReason(", "          DecisionSuccessReason::HEURISTIC_OBSERVED_TO_BE_SAFE);", "    DCHECK(decision_details->IsPositive());", "    }", " ", "    return decision_details->IsPositive();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0]}
{"tokens": [" int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)", " {", " \tint status = 0, size_change;", " \tint inode_locked = 0;", " \tstruct inode *inode = d_inode(dentry);", " \tstruct super_block *sb = inode->i_sb;", " \tstruct ocfs2_super *osb = OCFS2_SB(sb);", " \tstruct buffer_head *bh = NULL;", " \thandle_t *handle = NULL;", " \tstruct dquot *transfer_to[MAXQUOTAS] = { };", " \tint qtype;", " \tint had_lock;", " \tstruct ocfs2_lock_holder oh;", " ", " \ttrace_ocfs2_setattr(inode, dentry,", " \t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,", " \t\t\t    dentry->d_name.len, dentry->d_name.name,", " \t\t\t    attr->ia_valid, attr->ia_mode,", " \t\t\t    from_kuid(&init_user_ns, attr->ia_uid),", " \t\t\t    from_kgid(&init_user_ns, attr->ia_gid));", " ", " \t ", " \tif (S_ISLNK(inode->i_mode))", " \t\tattr->ia_valid &= ~ATTR_SIZE;", " ", " #define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\", " \t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)", " \tif (!(attr->ia_valid & OCFS2_VALID_ATTRS))", " \t\treturn 0;", " ", " \tstatus = setattr_prepare(dentry, attr);", " \tif (status)", " \t\treturn status;", " ", " \tif (is_quota_modification(inode, attr)) {", " \t\tstatus = dquot_initialize(inode);", " \t\tif (status)", " \t\t\treturn status;", "  \t}", "  \tsize_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;", "  \tif (size_change) {", " \t\t ", " \t\tinode_dio_wait(inode);", " ", "  \t\tstatus = ocfs2_rw_lock(inode, 1);", "  \t\tif (status < 0) {", "  \t\t\tmlog_errno(status);", " \t\t\tgoto bail;", " \t\t}", " \t}", " ", " \thad_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh);", " \tif (had_lock < 0) {", " \t\tstatus = had_lock;", " \t\tgoto bail_unlock_rw;", " \t} else if (had_lock) {", " \t\t ", " \t\tmlog(ML_ERROR, \"Another case of recursive locking:\\n\");", " \t\tdump_stack();", " \t}", " \tinode_locked = 1;", " ", " \tif (size_change) {", " \t\tstatus = inode_newsize_ok(inode, attr->ia_size);", "  \t\tif (status)", "  \t\t\tgoto bail_unlock;", "  ", "\t\tinode_dio_wait(inode);", "  \t\tif (i_size_read(inode) >= attr->ia_size) {", "  \t\t\tif (ocfs2_should_order_data(inode)) {", "  \t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,", " \t\t\t\t\t\t\t\t      attr->ia_size);", " \t\t\t\tif (status)", " \t\t\t\t\tgoto bail_unlock;", " \t\t\t}", " \t\t\tstatus = ocfs2_truncate_file(inode, bh, attr->ia_size);", " \t\t} else", " \t\t\tstatus = ocfs2_extend_file(inode, bh, attr->ia_size);", " \t\tif (status < 0) {", " \t\t\tif (status != -ENOSPC)", " \t\t\t\tmlog_errno(status);", " \t\t\tstatus = -ENOSPC;", " \t\t\tgoto bail_unlock;", " \t\t}", " \t}", " ", " \tif ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||", " \t    (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {", " \t\t ", " \t\tif (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)", " \t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,", " \t\t    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {", " \t\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));", " \t\t\tif (IS_ERR(transfer_to[USRQUOTA])) {", " \t\t\t\tstatus = PTR_ERR(transfer_to[USRQUOTA]);", " \t\t\t\tgoto bail_unlock;", " \t\t\t}", " \t\t}", " \t\tif (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)", " \t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,", " \t\t    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {", " \t\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));", " \t\t\tif (IS_ERR(transfer_to[GRPQUOTA])) {", " \t\t\t\tstatus = PTR_ERR(transfer_to[GRPQUOTA]);", " \t\t\t\tgoto bail_unlock;", " \t\t\t}", " \t\t}", " \t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +", " \t\t\t\t\t   2 * ocfs2_quota_trans_credits(sb));", " \t\tif (IS_ERR(handle)) {", " \t\t\tstatus = PTR_ERR(handle);", " \t\t\tmlog_errno(status);", " \t\t\tgoto bail_unlock;", " \t\t}", " \t\tstatus = __dquot_transfer(inode, transfer_to);", " \t\tif (status < 0)", " \t\t\tgoto bail_commit;", " \t} else {", " \t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);", " \t\tif (IS_ERR(handle)) {", " \t\t\tstatus = PTR_ERR(handle);", " \t\t\tmlog_errno(status);", " \t\t\tgoto bail_unlock;", " \t\t}", " \t}", " ", " \tsetattr_copy(inode, attr);", " \tmark_inode_dirty(inode);", " ", " \tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);", " \tif (status < 0)", " \t\tmlog_errno(status);", " ", " bail_commit:", " \tocfs2_commit_trans(osb, handle);", " bail_unlock:", " \tif (status && inode_locked) {", " \t\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);", " \t\tinode_locked = 0;", " \t}", " bail_unlock_rw:", " \tif (size_change)", " \t\tocfs2_rw_unlock(inode, 1);", " bail:", " ", " \t ", " \tfor (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)", " \t\tdqput(transfer_to[qtype]);", " ", " \tif (!status && attr->ia_valid & ATTR_MODE) {", " \t\tstatus = ocfs2_acl_chmod(inode, bh);", " \t\tif (status < 0)", " \t\t\tmlog_errno(status);", " \t}", " \tif (inode_locked)", " \t\tocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock);", " ", " \tbrelse(bh);", " \treturn status;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,", "ValueRange shapes, Location loc,", "OpBuilder* builder) {", "", "SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;", "size_t maxRank = 0;", "for (const auto &shape : llvm::enumerate(shapes)) {", "auto found_shape = analysis.GetValueInfo(shape.value());", "if (!found_shape) return {};", "shapes_found.push_back(*found_shape);", "maxRank = std::max(maxRank, found_shape->size());", "}", "", "SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(", "maxRank);", "SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);", "for (const auto &shape : llvm::enumerate(shapes_found)) {", "for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {", "", "if (dim.value().isConstant(1)) continue;", "", "", "auto index = maxRank - dim.index() - 1;", "if (!joined_dimensions[index]) {", "joined_dimensions[index] = &dim.value();", "shape_and_rank_for_dim[index] =", "std::make_pair(shapes[shape.index()], shape.value().size());", "continue;", "}", "", "if (*joined_dimensions[index] != dim.value()) return {};", "}", "}", "", "if (llvm::is_splat(shape_and_rank_for_dim) &&", "shape_and_rank_for_dim[0].first) {", "return shape_and_rank_for_dim[0].first;", "}", "", "SmallVector<Value> elements;", "for (int i = 0; i != maxRank; ++i) {", "", "if (!shape_and_rank_for_dim[i].first) {", "auto one = builder->getIntegerAttr(", "shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);", "elements.push_back(builder->create<ConstantOp>(loc, one));", "continue;", "}", "", "", "Value index = builder->create<ConstantIndexOp>(", "loc, i - maxRank + shape_and_rank_for_dim[i].second);", "elements.push_back(builder->create<tensor::ExtractOp>(", "loc, shape_and_rank_for_dim[i].first, index));", "}", "return Value(builder->create<tensor::FromElementsOp>(loc, elements));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int __ref online_pages(unsigned long pfn, unsigned long nr_pages)", " {", " \tunsigned long onlined_pages = 0;", " \tstruct zone *zone;", " \tint need_zonelists_rebuild = 0;", " \tint nid;", " \tint ret;", " \tstruct memory_notify arg;", " ", " \tlock_memory_hotplug();", " \targ.start_pfn = pfn;", " \targ.nr_pages = nr_pages;", " \targ.status_change_nid = -1;", " ", " \tnid = page_to_nid(pfn_to_page(pfn));", " \tif (node_present_pages(nid) == 0)", " \t\targ.status_change_nid = nid;", " ", " \tret = memory_notify(MEM_GOING_ONLINE, &arg);", " \tret = notifier_to_errno(ret);", " \tif (ret) {", " \t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);", " \t\tunlock_memory_hotplug();", " \t\treturn ret;", " \t}", " \t ", " \tzone = page_zone(pfn_to_page(pfn));", " \t ", " \tmutex_lock(&zonelists_mutex);", " \tif (!populated_zone(zone))", " \t\tneed_zonelists_rebuild = 1;", " ", " \tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,", " \t\tonline_pages_range);", " \tif (ret) {", " \t\tmutex_unlock(&zonelists_mutex);", " \t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",", " \t\t       (unsigned long long) pfn << PAGE_SHIFT,", " \t\t       (((unsigned long long) pfn + nr_pages)", " \t\t\t    << PAGE_SHIFT) - 1);", " \t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);", " \t\tunlock_memory_hotplug();", " \t\treturn ret;", " \t}", "  ", "  \tzone->present_pages += onlined_pages;", "  \tzone->zone_pgdat->node_present_pages += onlined_pages;", "\tif (need_zonelists_rebuild)", "\t\tbuild_all_zonelists(NULL, zone);", "\telse", "\t\tzone_pcp_update(zone);", " \tif (onlined_pages) {", " \t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);", " \t\tif (need_zonelists_rebuild)", " \t\t\tbuild_all_zonelists(NULL, zone);", " \t\telse", " \t\t\tzone_pcp_update(zone);", " \t}", "  ", "  \tmutex_unlock(&zonelists_mutex);", "  ", "  \tinit_per_zone_wmark_min();", "  ", "\tif (onlined_pages) {", " \tif (onlined_pages)", "  \t\tkswapd_run(zone_to_nid(zone));", "\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);", "\t}", "  ", "  \tvm_total_pages = nr_free_pagecache_pages();", "  ", " \twriteback_set_ratelimit();", " ", " \tif (onlined_pages)", " \t\tmemory_notify(MEM_ONLINE, &arg);", " \tunlock_memory_hotplug();", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   void ProcessControlLaunched() {", "   void ProcessControlLaunched(base::OnceClosure on_done) {", "      base::ScopedAllowBlockingForTesting allow_blocking;", "      base::ProcessId service_pid;", "      EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));", "     EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);", " #if defined(OS_WIN)", "     service_process_ =", "         base::Process::OpenWithAccess(service_pid,", "                                       SYNCHRONIZE | PROCESS_QUERY_INFORMATION);", " #else", "      service_process_ = base::Process::Open(service_pid);", "  #endif", "      EXPECT_TRUE(service_process_.IsValid());", "    base::ThreadTaskRunnerHandle::Get()->PostTask(", "        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());", "     std::move(on_done).Run();", "    }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" acc_ctx_cont(OM_uint32 *minstat,", " \t     gss_buffer_t buf,", " \t     gss_ctx_id_t *ctx,", " \t     gss_buffer_t *responseToken,", " \t     gss_buffer_t *mechListMIC,", " \t     OM_uint32 *negState,", " \t     send_token_flag *return_token)", " {", " \tOM_uint32 ret, tmpmin;", " \tgss_OID supportedMech;", " \tspnego_gss_ctx_id_t sc;", " \tunsigned int len;", " \tunsigned char *ptr, *bufstart;", " ", " \tsc = (spnego_gss_ctx_id_t)*ctx;", " \tret = GSS_S_DEFECTIVE_TOKEN;", " \t*negState = REJECT;", " \t*minstat = 0;", " \tsupportedMech = GSS_C_NO_OID;", " \t*return_token = ERROR_TOKEN_SEND;", " \t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;", "  ", "  \tptr = bufstart = buf->value;", "  #define REMAIN (buf->length - (ptr - bufstart))", "\tif (REMAIN > INT_MAX)", " \tif (REMAIN == 0 || REMAIN > INT_MAX)", "  \t\treturn GSS_S_DEFECTIVE_TOKEN;", "  ", "  \t ", " \tif (*ptr == HEADER_ID) {", " \t\tret = g_verify_token_header(gss_mech_spnego,", " \t\t\t\t\t    &len, &ptr, 0, REMAIN);", " \t\tif (ret) {", " \t\t\t*minstat = ret;", " \t\t\treturn GSS_S_DEFECTIVE_TOKEN;", " \t\t}", " \t}", " \tif (*ptr != (CONTEXT | 0x01)) {", " \t\treturn GSS_S_DEFECTIVE_TOKEN;", " \t}", " \tret = get_negTokenResp(minstat, ptr, REMAIN,", " \t\t\t       negState, &supportedMech,", " \t\t\t       responseToken, mechListMIC);", " \tif (ret != GSS_S_COMPLETE)", " \t\tgoto cleanup;", " ", " \tif (*responseToken == GSS_C_NO_BUFFER &&", " \t    *mechListMIC == GSS_C_NO_BUFFER) {", " ", " \t\tret = GSS_S_DEFECTIVE_TOKEN;", " \t\tgoto cleanup;", " \t}", " \tif (supportedMech != GSS_C_NO_OID) {", " \t\tret = GSS_S_DEFECTIVE_TOKEN;", " \t\tgoto cleanup;", " \t}", " \tsc->firstpass = 0;", " \t*negState = ACCEPT_INCOMPLETE;", " \t*return_token = CONT_TOKEN_SEND;", " cleanup:", " \tif (supportedMech != GSS_C_NO_OID) {", " \t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);", " \t}", " \treturn ret;", " #undef REMAIN", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,", "  ExceptionInfo *exception)", " static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image)", "  {", "    MagickBooleanType", "      status;", " ", "   int", "     bit;", " ", "   register const PixelPacket", "     *p;", " ", "   register ssize_t", "     x;", " ", "   ssize_t", "     y;", " ", "   unsigned char", "     byte;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   assert(image != (Image *) NULL);", "    assert(image->signature == MagickSignature);", "    if (image->debug != MagickFalse)", "      (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);", "  assert(exception != (ExceptionInfo *) NULL);", "  assert(exception->signature == MagickSignature);", "  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);", "   status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);", "    if (status == MagickFalse)", "      return(status);", "    (void) TransformImageColorspace(image,sRGBColorspace);", "   if((image->columns > 255L) || (image->rows > 255L))", "     ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");", "    ", "   (void) WriteBlobByte(image,image->columns & 0xff);", "   (void) WriteBlobByte(image,image->rows & 0xff);", "    ", "   (void) SetImageType(image,BilevelType);", "   x=0;", "    y=0;", "    for (y=0; y < (ssize_t) image->rows; y++)", "    {", "    p=GetVirtualPixels(image,0,y,image->columns,1,exception);", "     p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);", "      if (p == (const PixelPacket *) NULL)", "        break;", "      bit=0;", "     byte=0;", "     for (x=0; x < (ssize_t) image->columns; x++)", "     {", "       byte>>=1;", "       if (GetPixelLuma(image,p) < (QuantumRange/2.0))", "         byte|=0x80;", "       bit++;", "       if (bit == 8)", "         {", "            ", "        \t  (void) WriteBlobByte(image,byte);", "           bit=0;", "           byte=0;", "         }", "       p++;", "     }", "     if (bit != 0)", "       (void) WriteBlobByte(image,byte);", "     status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,", "       image->rows);", "     if (status == MagickFalse)", "       break;", "   }", "   (void) CloseBlob(image);", "   return(MagickTrue);", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int a2dp_command(struct a2dp_stream_common *common, char cmd)", " {", "  char ack;", " ", " ", "      DEBUG(\"A2DP COMMAND %s\", dump_a2dp_ctrl_event(cmd));", "  ", "       ", "    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)", "     if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)", "      {", "          ERROR(\"cmd failed (%s)\", strerror(errno));", "          skt_disconnect(common->ctrl_fd);", "         common->ctrl_fd = AUDIO_SKT_DISCONNECTED;", "  return -1;", "  }", " ", "   ", "  if (a2dp_ctrl_receive(common, &ack, 1) < 0)", "  return -1;", " ", "     DEBUG(\"A2DP COMMAND %s DONE STATUS %d\", dump_a2dp_ctrl_event(cmd), ack);", " ", "  if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)", "  return ack;", "  if (ack != A2DP_CTRL_ACK_SUCCESS)", "  return -1;", " ", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize)", " {", " \tBYTE c;", " \tBYTE flags;", " \tUINT32 extra = 0;", " \tint opIndex;", " \tint haveBits;", " \tint inPrefix;", "  \tUINT32 count;", "  \tUINT32 distance;", "  \tBYTE* pbSegment;", "\tsize_t cbSegment = segmentSize - 1;", " \tsize_t cbSegment;", "  ", "\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))", " \tif (!zgfx || !stream)", " \t\treturn FALSE;", " ", " \tcbSegment = segmentSize - 1;", " ", " \tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||", " \t    (segmentSize > UINT32_MAX))", "  \t\treturn FALSE;", "  ", "  \tStream_Read_UINT8(stream, flags);  ", " \tzgfx->OutputCount = 0;", " \tpbSegment = Stream_Pointer(stream);", " \tStream_Seek(stream, cbSegment);", " ", "  \tif (!(flags & PACKET_COMPRESSED))", "  \t{", "  \t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);", " ", " \t\tif (cbSegment > sizeof(zgfx->OutputBuffer))", " \t\t\treturn FALSE;", " ", "  \t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);", "  \t\tzgfx->OutputCount = cbSegment;", "  \t\treturn TRUE;", " \t}", " ", " \tzgfx->pbInputCurrent = pbSegment;", " \tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];", " \t ", " \tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;", " \tzgfx->cBitsCurrent = 0;", " \tzgfx->BitsCurrent = 0;", " ", " \twhile (zgfx->cBitsRemaining)", " \t{", " \t\thaveBits = 0;", " \t\tinPrefix = 0;", " ", " \t\tfor (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++)", " \t\t{", " \t\t\twhile (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)", " \t\t\t{", " \t\t\t\tzgfx_GetBits(zgfx, 1);", " \t\t\t\tinPrefix = (inPrefix << 1) + zgfx->bits;", " \t\t\t\thaveBits++;", " \t\t\t}", " ", " \t\t\tif (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode)", " \t\t\t{", " \t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)", " \t\t\t\t{", " \t\t\t\t\t ", " \t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);", " \t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);", " \t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;", " ", "  \t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)", "  \t\t\t\t\t\tzgfx->HistoryIndex = 0;", "  ", " \t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))", " \t\t\t\t\t\treturn FALSE;", " ", "  \t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;", "  \t\t\t\t}", "  \t\t\t\telse", " \t\t\t\t{", " \t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);", " \t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;", " ", " \t\t\t\t\tif (distance != 0)", " \t\t\t\t\t{", " \t\t\t\t\t\t ", " \t\t\t\t\t\tzgfx_GetBits(zgfx, 1);", " ", " \t\t\t\t\t\tif (zgfx->bits == 0)", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tcount = 3;", " \t\t\t\t\t\t}", " \t\t\t\t\t\telse", " \t\t\t\t\t\t{", " \t\t\t\t\t\t\tcount = 4;", " \t\t\t\t\t\t\textra = 2;", " \t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);", " ", " \t\t\t\t\t\t\twhile (zgfx->bits == 1)", " \t\t\t\t\t\t\t{", " \t\t\t\t\t\t\t\tcount *= 2;", " \t\t\t\t\t\t\t\textra++;", " \t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);", " \t\t\t\t\t\t\t}", " ", " \t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);", "  \t\t\t\t\t\t\tcount += zgfx->bits;", "  \t\t\t\t\t\t}", "  ", " \t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)", " \t\t\t\t\t\t\treturn FALSE;", " ", "  \t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);", "  \t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);", "  \t\t\t\t\t\tzgfx->OutputCount += count;", " \t\t\t\t\t}", " \t\t\t\t\telse", " \t\t\t\t\t{", " \t\t\t\t\t\t ", " \t\t\t\t\t\tzgfx_GetBits(zgfx, 15);", " \t\t\t\t\t\tcount = zgfx->bits;", "  \t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;", "  \t\t\t\t\t\tzgfx->cBitsCurrent = 0;", "  \t\t\t\t\t\tzgfx->BitsCurrent = 0;", " ", " \t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)", " \t\t\t\t\t\t\treturn FALSE;", " ", "  \t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);", "  \t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);", "  \t\t\t\t\t\tzgfx->pbInputCurrent += count;", " \t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);", " \t\t\t\t\t\tzgfx->OutputCount += count;", " \t\t\t\t\t}", " \t\t\t\t}", " ", " \t\t\t\tbreak;", " \t\t\t}", " \t\t}", " \t}", " ", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" GF_Err gf_bin128_parse(const char *string, bin128 value)", " {", " \tu32 len;", " \tu32\ti=0;", " \tif (!strnicmp(string, \"0x\", 2)) string += 2;", " \tlen = (u32) strlen(string);", " \tif (len >= 32) {", " \t\tu32 j;", " \t\tfor (j=0; j<len; j+=2) {", " \t\t\tu32 v;", " \t\t\tchar szV[5];", " ", " \t\t\twhile (string[j] && !isalnum(string[j]))", " \t\t\t\tj++;", " \t\t\tif (!string[j])", " \t\t\t\tbreak;", " \t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);", "  \t\t\tsscanf(szV, \"%x\", &v);", "  \t\t\tvalue[i] = v;", "  \t\t\ti++;", " \t\t\tif (i > 15) {", " \t\t\t\t ", " \t\t\t\ti++;", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t}", "  \t}", "  \tif (i != 16) {", " \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));", " \t\treturn GF_BAD_PARAM;", " \t}", " \treturn GF_OK;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool PrintWebViewHelper::UpdatePrintSettings(", "     WebKit::WebFrame* frame, const WebKit::WebNode& node,", "     const DictionaryValue& passed_job_settings) {", "   DCHECK(is_preview_enabled_);", "   const DictionaryValue* job_settings = &passed_job_settings;", "   DictionaryValue modified_job_settings;", "   if (job_settings->empty()) {", "     if (!print_for_preview_)", "       print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);", "     return false;", "   }", " ", "   bool source_is_html = true;", "   if (print_for_preview_) {", "     if (!job_settings->GetBoolean(printing::kSettingPreviewModifiable,", "                                   &source_is_html)) {", "       NOTREACHED();", "     }", "   } else {", "     source_is_html = !PrintingNodeOrPdfFrame(frame, node);", "   }", " ", "   if (print_for_preview_ || !source_is_html) {", "     modified_job_settings.MergeDictionary(job_settings);", "     modified_job_settings.SetBoolean(printing::kSettingHeaderFooterEnabled,", "                                      false);", "     modified_job_settings.SetInteger(printing::kSettingMarginsType,", "                                      printing::NO_MARGINS);", "     job_settings = &modified_job_settings;", "   }", " ", "   int cookie = print_pages_params_.get() ?", "       print_pages_params_->params.document_cookie : 0;", "   PrintMsg_PrintPages_Params settings;", "   Send(new PrintHostMsg_UpdatePrintSettings(routing_id(),", "       cookie, *job_settings, &settings));", "   print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));", " ", "   if (!PrintMsg_Print_Params_IsValid(settings.params)) {", "     if (!print_for_preview_) {", "       print_preview_context_.set_error(PREVIEW_ERROR_INVALID_PRINTER_SETTINGS);", "     } else {", "       WebKit::WebFrame* print_frame = NULL;", "       GetPrintFrame(&print_frame);", "       if (print_frame) {", "         render_view()->RunModalAlertDialog(", "             print_frame,", "             l10n_util::GetStringUTF16(", "                 IDS_PRINT_PREVIEW_INVALID_PRINTER_SETTINGS));", "       }", "     }", "     return false;", "   }", " ", "   if (settings.params.dpi < kMinDpi || !settings.params.document_cookie) {", "     print_preview_context_.set_error(PREVIEW_ERROR_UPDATING_PRINT_SETTINGS);", "     return false;", "   }", "  ", "    if (!print_for_preview_) {", "    if (!job_settings->GetString(printing::kPreviewUIAddr,", "                                 &(settings.params.preview_ui_addr)) ||", "     if (!job_settings->GetInteger(printing::kPreviewUIID,", "                                   &(settings.params.preview_ui_id)) ||", "          !job_settings->GetInteger(printing::kPreviewRequestID,", "                                    &(settings.params.preview_request_id)) ||", "          !job_settings->GetBoolean(printing::kIsFirstRequest,", "                                   &(settings.params.is_first_request))) {", "       NOTREACHED();", "       print_preview_context_.set_error(PREVIEW_ERROR_BAD_SETTING);", "       return false;", "     }", " ", "     settings.params.print_to_pdf = IsPrintToPdfRequested(*job_settings);", "     UpdateFrameMarginsCssInfo(*job_settings);", "     settings.params.print_scaling_option = GetPrintScalingOption(", "         source_is_html, *job_settings, settings.params);", " ", "     if (settings.params.display_header_footer) {", "       header_footer_info_.reset(new DictionaryValue());", "       header_footer_info_->SetString(printing::kSettingHeaderFooterDate,", "                                      settings.params.date);", "       header_footer_info_->SetString(printing::kSettingHeaderFooterURL,", "                                      settings.params.url);", "       header_footer_info_->SetString(printing::kSettingHeaderFooterTitle,", "                                      settings.params.title);", "     }", "   }", " ", "   print_pages_params_.reset(new PrintMsg_PrintPages_Params(settings));", "   Send(new PrintHostMsg_DidGetDocumentCookie(routing_id(),", "                                              settings.params.document_cookie));", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ssl3_get_record(SSL *s)", " {", "     int ssl_major, ssl_minor, al;", "     int enc_err, n, i, ret = -1;", "     SSL3_RECORD *rr;", "     SSL3_BUFFER *rbuf;", "     SSL_SESSION *sess;", "     unsigned char *p;", "     unsigned char md[EVP_MAX_MD_SIZE];", "     short version;", "     unsigned mac_size;", "     unsigned int num_recs = 0;", "     unsigned int max_recs;", "     unsigned int j;", " ", "     rr = RECORD_LAYER_get_rrec(&s->rlayer);", "     rbuf = RECORD_LAYER_get_rbuf(&s->rlayer);", "     max_recs = s->max_pipelines;", "     if (max_recs == 0)", "         max_recs = 1;", "     sess = s->session;", " ", "     do {", "          ", "         if ((RECORD_LAYER_get_rstate(&s->rlayer) != SSL_ST_READ_BODY) ||", "             (RECORD_LAYER_get_packet_length(&s->rlayer)", "              < SSL3_RT_HEADER_LENGTH)) {", "             n = ssl3_read_n(s, SSL3_RT_HEADER_LENGTH,", "                             SSL3_BUFFER_get_len(rbuf), 0,", "                             num_recs == 0 ? 1 : 0);", "             if (n <= 0)", "                 return (n);      ", "             RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_BODY);", " ", "             p = RECORD_LAYER_get_packet(&s->rlayer);", " ", "              ", "             if (s->server && RECORD_LAYER_is_first_record(&s->rlayer)", "                 && (p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) {", "                  ", "                 rr[num_recs].type = SSL3_RT_HANDSHAKE;", "                 rr[num_recs].rec_version = SSL2_VERSION;", " ", "                 rr[num_recs].length = ((p[0] & 0x7f) << 8) | p[1];", " ", "                 if (rr[num_recs].length > SSL3_BUFFER_get_len(rbuf)", "                     - SSL2_RT_HEADER_LENGTH) {", "                     al = SSL_AD_RECORD_OVERFLOW;", "                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);", "                     goto f_err;", "                 }", " ", "                 if (rr[num_recs].length < MIN_SSL2_RECORD_LEN) {", "                     al = SSL_AD_HANDSHAKE_FAILURE;", "                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);", "                     goto f_err;", "                 }", "             } else {", "                  ", "                 if (s->msg_callback)", "                     s->msg_callback(0, 0, SSL3_RT_HEADER, p, 5, s,", "                                     s->msg_callback_arg);", " ", "                  ", "                 rr[num_recs].type = *(p++);", "                 ssl_major = *(p++);", "                 ssl_minor = *(p++);", "                 version = (ssl_major << 8) | ssl_minor;", "                 rr[num_recs].rec_version = version;", "                 n2s(p, rr[num_recs].length);", " ", "                  ", "                 if (!s->first_packet && version != s->version) {", "                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_WRONG_VERSION_NUMBER);", "                     if ((s->version & 0xFF00) == (version & 0xFF00)", "                         && !s->enc_write_ctx && !s->write_hash) {", "                         if (rr->type == SSL3_RT_ALERT) {", "                              ", "                             goto err;", "                         }", "                          ", "                         s->version = (unsigned short)version;", "                     }", "                     al = SSL_AD_PROTOCOL_VERSION;", "                     goto f_err;", "                 }", " ", "                 if ((version >> 8) != SSL3_VERSION_MAJOR) {", "                     if (RECORD_LAYER_is_first_record(&s->rlayer)) {", "                          ", "                         p = RECORD_LAYER_get_packet(&s->rlayer);", "                         if (strncmp((char *)p, \"GET \", 4) == 0 ||", "                             strncmp((char *)p, \"POST \", 5) == 0 ||", "                             strncmp((char *)p, \"HEAD \", 5) == 0 ||", "                             strncmp((char *)p, \"PUT \", 4) == 0) {", "                             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_HTTP_REQUEST);", "                             goto err;", "                         } else if (strncmp((char *)p, \"CONNE\", 5) == 0) {", "                             SSLerr(SSL_F_SSL3_GET_RECORD,", "                                    SSL_R_HTTPS_PROXY_REQUEST);", "                             goto err;", "                         }", " ", "                          ", "                         SSLerr(SSL_F_SSL3_GET_RECORD,", "                                SSL_R_WRONG_VERSION_NUMBER);", "                         goto err;", "                     } else {", "                         SSLerr(SSL_F_SSL3_GET_RECORD,", "                                SSL_R_WRONG_VERSION_NUMBER);", "                         al = SSL_AD_PROTOCOL_VERSION;", "                         goto f_err;", "                     }", "                 }", " ", "                 if (rr[num_recs].length >", "                     SSL3_BUFFER_get_len(rbuf) - SSL3_RT_HEADER_LENGTH) {", "                     al = SSL_AD_RECORD_OVERFLOW;", "                     SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_PACKET_LENGTH_TOO_LONG);", "                     goto f_err;", "                 }", "             }", " ", "              ", "         }", " ", "          ", "         if (rr[num_recs].rec_version == SSL2_VERSION) {", "             i = rr[num_recs].length + SSL2_RT_HEADER_LENGTH", "                 - SSL3_RT_HEADER_LENGTH;", "         } else {", "             i = rr[num_recs].length;", "         }", "         if (i > 0) {", "              ", " ", "             n = ssl3_read_n(s, i, i, 1, 0);", "             if (n <= 0)", "                 return (n);      ", "         }", " ", "          ", "         RECORD_LAYER_set_rstate(&s->rlayer, SSL_ST_READ_HEADER);", " ", "          ", "         if (rr[num_recs].rec_version == SSL2_VERSION) {", "             rr[num_recs].input =", "                 &(RECORD_LAYER_get_packet(&s->rlayer)[SSL2_RT_HEADER_LENGTH]);", "         } else {", "             rr[num_recs].input =", "                 &(RECORD_LAYER_get_packet(&s->rlayer)[SSL3_RT_HEADER_LENGTH]);", "         }", " ", "          ", " ", "          ", " ", "          ", "         if (rr[num_recs].length > SSL3_RT_MAX_ENCRYPTED_LENGTH) {", "             al = SSL_AD_RECORD_OVERFLOW;", "             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_ENCRYPTED_LENGTH_TOO_LONG);", "             goto f_err;", "         }", " ", "          ", "         rr[num_recs].data = rr[num_recs].input;", "         rr[num_recs].orig_len = rr[num_recs].length;", " ", "          ", "         rr[num_recs].read = 0;", " ", "         num_recs++;", " ", "          ", "         RECORD_LAYER_reset_packet_length(&s->rlayer);", "         RECORD_LAYER_clear_first_record(&s->rlayer);", "     } while (num_recs < max_recs", "              && rr[num_recs - 1].type == SSL3_RT_APPLICATION_DATA", "              && SSL_USE_EXPLICIT_IV(s)", "              && s->enc_read_ctx != NULL", "              && (EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_read_ctx))", "                  & EVP_CIPH_FLAG_PIPELINE)", "              && ssl3_record_app_data_waiting(s));", " ", "      ", "    if (SSL_USE_ETM(s) && s->read_hash) {", "     if (SSL_READ_ETM(s) && s->read_hash) {", "          unsigned char *mac;", "          mac_size = EVP_MD_CTX_size(s->read_hash);", "          OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);", "         for (j = 0; j < num_recs; j++) {", "             if (rr[j].length < mac_size) {", "                 al = SSL_AD_DECODE_ERROR;", "                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);", "                 goto f_err;", "             }", "             rr[j].length -= mac_size;", "             mac = rr[j].data + rr[j].length;", "             i = s->method->ssl3_enc->mac(s, &rr[j], md, 0   );", "             if (i < 0 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0) {", "                 al = SSL_AD_BAD_RECORD_MAC;", "                 SSLerr(SSL_F_SSL3_GET_RECORD,", "                        SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);", "                 goto f_err;", "             }", "         }", "     }", " ", "     enc_err = s->method->ssl3_enc->enc(s, rr, num_recs, 0);", "      ", "     if (enc_err == 0) {", "         al = SSL_AD_DECRYPTION_FAILED;", "         SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BLOCK_CIPHER_PAD_IS_WRONG);", "         goto f_err;", "     }", " #ifdef SSL_DEBUG", "     printf(\"dec %d\\n\", rr->length);", "     {", "         unsigned int z;", "         for (z = 0; z < rr->length; z++)", "             printf(\"%02X%c\", rr->data[z], ((z + 1) % 16) ? ' ' : '\\n');", "     }", "     printf(\"\\n\");", " #endif", " ", "       ", "      if ((sess != NULL) &&", "          (s->enc_read_ctx != NULL) &&", "        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {", "         (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {", "           ", "          unsigned char *mac = NULL;", "          unsigned char mac_tmp[EVP_MAX_MD_SIZE];", " ", "         mac_size = EVP_MD_CTX_size(s->read_hash);", "         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);", " ", "         for (j = 0; j < num_recs; j++) {", "              ", "             if (rr[j].orig_len < mac_size ||", "                  ", "                 (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&", "                  rr[j].orig_len < mac_size + 1)) {", "                 al = SSL_AD_DECODE_ERROR;", "                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_LENGTH_TOO_SHORT);", "                 goto f_err;", "             }", " ", "             if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE) {", "                  ", "                 mac = mac_tmp;", "                 ssl3_cbc_copy_mac(mac_tmp, &rr[j], mac_size);", "                 rr[j].length -= mac_size;", "             } else {", "                  ", "                 rr[j].length -= mac_size;", "                 mac = &rr[j].data[rr[j].length];", "             }", " ", "             i = s->method->ssl3_enc->mac(s, &rr[j], md, 0   );", "             if (i < 0 || mac == NULL", "                 || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)", "                 enc_err = -1;", "             if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size)", "                 enc_err = -1;", "         }", "     }", " ", "     if (enc_err < 0) {", "          ", "         al = SSL_AD_BAD_RECORD_MAC;", "         SSLerr(SSL_F_SSL3_GET_RECORD,", "                SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC);", "         goto f_err;", "     }", " ", "     for (j = 0; j < num_recs; j++) {", "          ", "         if (s->expand != NULL) {", "             if (rr[j].length > SSL3_RT_MAX_COMPRESSED_LENGTH) {", "                 al = SSL_AD_RECORD_OVERFLOW;", "                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_COMPRESSED_LENGTH_TOO_LONG);", "                 goto f_err;", "             }", "             if (!ssl3_do_uncompress(s, &rr[j])) {", "                 al = SSL_AD_DECOMPRESSION_FAILURE;", "                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_BAD_DECOMPRESSION);", "                 goto f_err;", "             }", "         }", " ", "         if (rr[j].length > SSL3_RT_MAX_PLAIN_LENGTH) {", "             al = SSL_AD_RECORD_OVERFLOW;", "             SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_DATA_LENGTH_TOO_LONG);", "             goto f_err;", "         }", " ", "         rr[j].off = 0;", "          ", " ", "          ", "         if (rr[j].length == 0) {", "             RECORD_LAYER_inc_empty_record_count(&s->rlayer);", "             if (RECORD_LAYER_get_empty_record_count(&s->rlayer)", "                 > MAX_EMPTY_RECORDS) {", "                 al = SSL_AD_UNEXPECTED_MESSAGE;", "                 SSLerr(SSL_F_SSL3_GET_RECORD, SSL_R_RECORD_TOO_SMALL);", "                 goto f_err;", "             }", "         } else {", "             RECORD_LAYER_reset_empty_record_count(&s->rlayer);", "         }", "     }", " ", "     RECORD_LAYER_set_numrpipes(&s->rlayer, num_recs);", "     return 1;", " ", "  f_err:", "     ssl3_send_alert(s, SSL3_AL_FATAL, al);", "  err:", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)", "  {", "\tulonglong tmp;", " \tjas_ulonglong tmp;", "  \tif (jas_iccgetuint(in, 4, &tmp))", "  \t\treturn -1;", "  \t*val = tmp;", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  void DelegatedFrameHost::CopyFromCompositingSurface(", "      const gfx::Rect& src_subrect,", "    const gfx::Size& dst_size,", "     const gfx::Size& output_size,", "      const base::Callback<void(bool, const SkBitmap&)>& callback,", "      const SkColorType color_type) {", "   bool format_support = ((color_type == kRGB_565_SkColorType) ||", "                          (color_type == kN32_SkColorType));", "   DCHECK(format_support);", "   if (!CanCopyToBitmap()) {", "     callback.Run(false, SkBitmap());", "      return;", "    }", "  ", "  const gfx::Size& dst_size_in_pixel =", "      client_->ConvertViewSizeToPixel(dst_size);", "    scoped_ptr<cc::CopyOutputRequest> request =", "        cc::CopyOutputRequest::CreateRequest(base::Bind(", "            &DelegatedFrameHost::CopyFromCompositingSurfaceHasResult,", "          dst_size_in_pixel,", "           output_size,", "            color_type,", "            callback));", "  gfx::Rect src_subrect_in_pixel =", "      ConvertRectToPixel(client_->CurrentDeviceScaleFactor(), src_subrect);", "  request->set_area(src_subrect_in_pixel);", "   request->set_area(src_subrect);", "    client_->RequestCopyOfOutput(request.Pass());", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" status_t OMXNodeInstance::updateGraphicBufferInMeta(", " ", "          OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,", "          OMX::buffer_id buffer) {", "      Mutex::Autolock autoLock(mLock);", "    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);", "     OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);", "      return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)", "  {\tsf_count_t total = 0 ;", "  \tssize_t\tcount ;", "  ", " \tif (bytes == 0 || items == 0)", " \t\treturn 0 ;", " ", "  \tif (psf->virtual_io)", "  \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;", "  ", " \titems *= bytes ;", " ", " \t ", " \tif (items <= 0)", " \t\treturn 0 ;", " ", " \twhile (items > 0)", " \t{\t ", " \t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;", " ", " \t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;", " ", " \t\tif (count == -1)", " \t\t{\tif (errno == EINTR)", " \t\t\t\tcontinue ;", " ", " \t\t\tpsf_log_syserr (psf, errno) ;", " \t\t\tbreak ;", " \t\t\t} ;", " ", " \t\tif (count == 0)", " \t\t\tbreak ;", " ", " \t\ttotal += count ;", " \t\titems -= count ;", " \t\t} ;", " ", " \tif (psf->is_pipe)", " \t\tpsf->pipeoffset += total ;", " ", " \treturn total / bytes ;", " }  "], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void DisconnectWindowLinux::Show(remoting::ChromotingHost* host,", "                                   const std::string& username) {", "  NOTIMPLEMENTED();", "   host_ = host;", "   CreateWindow();", "   gtk_label_set_text(GTK_LABEL(user_label_), username.c_str());", "   gtk_window_present(GTK_WINDOW(disconnect_window_));", "  }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0]}
{"tokens": [" int BN_hex2bn(BIGNUM **bn, const char *a)", " {", "     BIGNUM *ret = NULL;", "     BN_ULONG l = 0;", "     int neg = 0, h, m, i, j, k, c;", "     int num;", " ", "     if ((a == NULL) || (*a == '\\0'))", "         return (0);", " ", "     if (*a == '-') {", "         neg = 1;", "         a++;", "          a++;", "      }", "  ", "    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;", "     for (i = 0; i <= (INT_MAX/4) && isxdigit((unsigned char)a[i]); i++)", "         continue;", " ", "     if (i > INT_MAX/4)", "         goto err;", "  ", "      num = i + neg;", "      if (bn == NULL)", "             return (0);", "     } else {", "         ret = *bn;", "         BN_zero(ret);", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)", " {", "  if(h < 0 || h >= MAX_THREAD)", "  {", "         APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);", "  return FALSE;", "  }", "  if(ts[h].cmd_fdw == -1)", "  {", "         APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");", "  return FALSE;", "  }", "  sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};", "     APPL_TRACE_DEBUG(\"post cmd type:%d, size:%d, h:%d, \", type, size, h);", "  sock_cmd_t* cmd_send = &cmd;", "  int size_send = sizeof(cmd);", "  if(data && size)", "  {", "         size_send = sizeof(cmd) + size;", "         cmd_send = (sock_cmd_t*)alloca(size_send);", "  if(cmd_send)", "  {", "  *cmd_send = cmd;", "             memcpy(cmd_send + 1, data, size);", "  }", "  else", "  {", "             APPL_TRACE_ERROR(\"alloca failed at h:%d, cmd type:%d, size:%d\", h, type, size_send);", " ", "              return FALSE;", "          }", "      }", "    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;", "     return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,", "struct nlattr **attrs)", "{", "struct net *net = sock_net(in_skb->sk);", "struct crypto_user_alg *p = nlmsg_data(in_nlh);", "struct crypto_alg *alg;", "struct sk_buff *skb;", "struct crypto_dump_info info;", "int err;", "", "if (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))", "return -EINVAL;", "", "alg = crypto_alg_match(p, 0);", "if (!alg)", "return -ENOENT;", "", "err = -ENOMEM;", "skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);", "if (!skb)", "goto drop_alg;", "", "info.in_skb = in_skb;", "info.out_skb = skb;", "info.nlmsg_seq = in_nlh->nlmsg_seq;", "info.nlmsg_flags = 0;", "", "err = crypto_reportstat_alg(alg, &info);", "", "drop_alg:", "crypto_mod_put(alg);", "", "if (err)", "return err;", "", "return nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]}
{"tokens": ["   bool Get(const std::string& addr, int* out_value) {", "    ", "    ", "   bool Get(int32 preview_id, int* out_value) {", "      base::AutoLock lock(lock_);", "    PrintPreviewRequestIdMap::const_iterator it = map_.find(addr);", "     PrintPreviewRequestIdMap::const_iterator it = map_.find(preview_id);", "      if (it == map_.end())", "        return false;", "      *out_value = it->second;", "      return true;", "    }"], "ner_tags": [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  void uwbd_start(struct uwb_rc *rc)", "  {", "\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");", "\tif (rc->uwbd.task == NULL)", " \tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");", " \tif (IS_ERR(task)) {", " \t\trc->uwbd.task = NULL;", "  \t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"", "  \t\t       \"UWB won't work\\n\");", "\telse", " \t} else {", " \t\trc->uwbd.task = task;", "  \t\trc->uwbd.pid = rc->uwbd.task->pid;", " \t}", "  }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0]}
{"tokens": ["QPDFObjectHandle::parseContentStream_internal(PointerHolder<Buffer> stream_data,", "std::string const& description,", "ParserCallbacks* callbacks)", "{", "size_t length = stream_data->getSize();", "PointerHolder<InputSource> input =", "new BufferInputSource(description, stream_data.getPointer());", "QPDFTokenizer tokenizer;", "tokenizer.allowEOF();", "bool empty = false;", "while (static_cast<size_t>(input->tell()) < length)", "{", "QPDFObjectHandle obj =", "parseInternal(input, \"content\", tokenizer, empty,", "0, 0, false, false, true);", "if (! obj.isInitialized())", "{", "", "break;", "}", "", "callbacks->handleObject(obj);", "if (obj.isOperator() && (obj.getOperatorValue() == \"ID\"))", "{", "", "", "char ch;", "input->read(&ch, 1);", "char buf[4];", "memset(buf, '\\0', sizeof(buf));", "bool done = false;", "std::string inline_image;", "while (! done)", "{", "if (input->read(&ch, 1) == 0)", "{", "QTC::TC(\"qpdf\", \"QPDFObjectHandle EOF in inline image\");", "throw QPDFExc(qpdf_e_damaged_pdf, input->getName(),", "\"stream data\", input->tell(),", "\"EOF found while reading inline image\");", "}", "inline_image += ch;", "memmove(buf, buf + 1, sizeof(buf) - 1);", "buf[sizeof(buf) - 1] = ch;", "if (strchr(\" \\t\\n\\v\\f\\r\", buf[0]) &&", "(buf[1] == 'E') &&", "(buf[2] == 'I') &&", "strchr(\" \\t\\n\\v\\f\\r\", buf[3]))", "{", "", "done = true;", "input->seek(-3, SEEK_CUR);", "for (int i = 0; i < 4; ++i)", "{", "if (inline_image.length() > 0)", "{", "inline_image.erase(inline_image.length() - 1);", "}", "}", "}", "}", "QTC::TC(\"qpdf\", \"QPDFObjectHandle inline image token\");", "callbacks->handleObject(", "QPDFObjectHandle::newInlineImage(inline_image));", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xsltElement(xsltTransformContextPtr ctxt, xmlNodePtr node,", " \t    xmlNodePtr inst, xsltStylePreCompPtr castedComp) {", " #ifdef XSLT_REFACTORED", "     xsltStyleItemElementPtr comp = (xsltStyleItemElementPtr) castedComp;", " #else", "     xsltStylePreCompPtr comp = castedComp;", " #endif", "     xmlChar *prop = NULL;", "     const xmlChar *name, *prefix = NULL, *nsName = NULL;", "     xmlNodePtr copy;", "     xmlNodePtr oldInsert;", " ", "     if (ctxt->insert == NULL)", " \treturn;", " ", "      ", "     if (!comp->has_name)", "         return;", " ", "      ", "     oldInsert = ctxt->insert;", " ", "     if (comp->name == NULL) {", " \t ", "         prop = xsltEvalAttrValueTemplate(ctxt, inst,", " \t    (const xmlChar *) \"name\", XSLT_NAMESPACE);", "         if (prop == NULL) {", "             xsltTransformError(ctxt, NULL, inst,", " \t\t\"xsl:element: The attribute 'name' is missing.\\n\");", "             goto error;", "         }", " \tif (xmlValidateQName(prop, 0)) {", " \t    xsltTransformError(ctxt, NULL, inst,", " \t\t\"xsl:element: The effective name '%s' is not a \"", " \t\t\"valid QName.\\n\", prop);", " \t     ", " \t}", " \tname = xsltSplitQName(ctxt->dict, prop, &prefix);", " \txmlFree(prop);", "     } else {", " \t ", " #ifdef XSLT_REFACTORED", " \tprefix = comp->nsPrefix;", " \tname = comp->name;", " #else", " \tname = xsltSplitQName(ctxt->dict, comp->name, &prefix);", " #endif", "     }", " ", "      ", "     if (ctxt->output->dict == ctxt->dict) {", " \tcopy = xmlNewDocNodeEatName(ctxt->output, NULL, (xmlChar *)name, NULL);", "     } else {", " \tcopy = xmlNewDocNode(ctxt->output, NULL, (xmlChar *)name, NULL);", "     }", "     if (copy == NULL) {", " \txsltTransformError(ctxt, NULL, inst,", " \t    \"xsl:element : creation of %s failed\\n\", name);", "  \treturn;", "      }", "      copy = xsltAddChild(ctxt->insert, copy);", "     if (copy == NULL) {", "         xsltTransformError(ctxt, NULL, inst,", "             \"xsl:element : xsltAddChild failed\\n\");", "         return;", "     }", "  ", "       ", "     if (comp->has_ns) {", " \tif (comp->ns != NULL) {", " \t     ", " \t    if (comp->ns[0] != 0)", " \t\tnsName = comp->ns;", " \t} else {", " \t    xmlChar *tmpNsName;", " \t     ", " \t     ", " \t    tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,", " \t\t(const xmlChar *) \"namespace\", XSLT_NAMESPACE);", " \t     ", " \t    if ((tmpNsName != NULL) && (tmpNsName[0] != 0))", " \t\tnsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);", " \t    xmlFree(tmpNsName);", " \t}", " ", "         if (xmlStrEqual(nsName, BAD_CAST \"http:www.w3.org/2000/xmlns/\")) {", "             xsltTransformError(ctxt, NULL, inst,", "                 \"xsl:attribute: Namespace http:www.w3.org/2000/xmlns/ \"", "                 \"forbidden.\\n\");", "             goto error;", "         }", "         if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {", "             prefix = BAD_CAST \"xml\";", "         } else if (xmlStrEqual(prefix, BAD_CAST \"xml\")) {", "             prefix = NULL;", "         }", "     } else {", " \txmlNsPtr ns;", " \t ", " \tns = xmlSearchNs(inst->doc, inst, prefix);", " \tif (ns == NULL) {", " \t     ", "             if (prefix != NULL) {", "                 xsltTransformError(ctxt, NULL, inst,", "                     \"xsl:element: The QName '%s:%s' has no \"", "                     \"namespace binding in scope in the stylesheet; \"", "                     \"this is an error, since the namespace was not \"", "                     \"specified by the instruction itself.\\n\", prefix, name);", "             }", " \t} else", " \t    nsName = ns->href;", "     }", "      ", "     if (nsName != NULL) {", " \tif (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {", "              ", " \t    xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");", " ", " \t    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);", " ", " \t    xmlFree(pref);", " \t} else {", " \t    copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,", " \t\tcopy);", " \t}", "     } else if ((copy->parent != NULL) &&", " \t(copy->parent->type == XML_ELEMENT_NODE) &&", " \t(copy->parent->ns != NULL))", "     {", " \t ", " \txsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);", "     }", " ", "     ctxt->insert = copy;", " ", "     if (comp->has_use) {", " \tif (comp->use != NULL) {", " \t    xsltApplyAttributeSet(ctxt, node, inst, comp->use);", " \t} else {", " \t    xmlChar *attrSets = NULL;", " \t     ", " \t    attrSets = xsltEvalAttrValueTemplate(ctxt, inst,", " \t\t(const xmlChar *)\"use-attribute-sets\", NULL);", " \t    if (attrSets != NULL) {", " \t\txsltApplyAttributeSet(ctxt, node, inst, attrSets);", " \t\txmlFree(attrSets);", " \t    }", " \t}", "     }", "      ", "     if (inst->children != NULL)", " \txsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,", " \t    NULL);", " ", " error:", "     ctxt->insert = oldInsert;", "     return;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static void cstm(JF, js_Ast *stm)", "{", "js_Ast *target;", "int loop, cont, then, end;", "", "emitline(J, F, stm);", "", "switch (stm->type) {", "case AST_FUNDEC:", "break;", "", "case STM_BLOCK:", "cstmlist(J, F, stm->a);", "break;", "", "case STM_EMPTY:", "if (F->script) {", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "emit(J, F, OP_UNDEF);", "}", "break;", "", "case STM_VAR:", "cvarinit(J, F, stm->a);", "break;", "", "case STM_IF:", "if (stm->c) {", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "then = emitjump(J, F, OP_JTRUE);", "cstm(J, F, stm->c);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JUMP);", "label(J, F, then);", "cstm(J, F, stm->b);", "label(J, F, end);", "} else {", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "cstm(J, F, stm->b);", "label(J, F, end);", "}", "break;", "", "case STM_DO:", "loop = here(J, F);", "cstm(J, F, stm->a);", "cont = here(J, F);", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JTRUE, loop);", "labeljumps(J, F, stm->jumps, here(J,F), cont);", "break;", "", "case STM_WHILE:", "loop = here(J, F);", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "cstm(J, F, stm->b);", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), loop);", "break;", "", "case STM_FOR:", "case STM_FOR_VAR:", "if (stm->type == STM_FOR_VAR) {", "cvarinit(J, F, stm->a);", "} else {", "if (stm->a) {", "cexp(J, F, stm->a);", "emit(J, F, OP_POP);", "}", "}", "loop = here(J, F);", "if (stm->b) {", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "end = emitjump(J, F, OP_JFALSE);", "} else {", "end = 0;", "}", "cstm(J, F, stm->d);", "cont = here(J, F);", "if (stm->c) {", "cexp(J, F, stm->c);", "emit(J, F, OP_POP);", "}", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "if (end)", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), cont);", "break;", "", "case STM_FOR_IN:", "case STM_FOR_IN_VAR:", "cexp(J, F, stm->b);", "emitline(J, F, stm);", "emit(J, F, OP_ITERATOR);", "loop = here(J, F);", "{", "emitline(J, F, stm);", "emit(J, F, OP_NEXTITER);", "end = emitjump(J, F, OP_JFALSE);", "cassignforin(J, F, stm);", "if (F->script) {", "emit(J, F, OP_ROT2);", "cstm(J, F, stm->c);", "emit(J, F, OP_ROT2);", "} else {", "cstm(J, F, stm->c);", "}", "emitline(J, F, stm);", "emitjumpto(J, F, OP_JUMP, loop);", "}", "label(J, F, end);", "labeljumps(J, F, stm->jumps, here(J,F), loop);", "break;", "", "case STM_SWITCH:", "cswitch(J, F, stm->a, stm->b);", "labeljumps(J, F, stm->jumps, here(J,F), 0);", "break;", "", "case STM_LABEL:", "cstm(J, F, stm->b);", "", "while (stm->type == STM_LABEL)", "stm = stm->b;", "", "if (!isloop(stm->type) && stm->type != STM_SWITCH)", "labeljumps(J, F, stm->jumps, here(J,F), 0);", "break;", "", "case STM_BREAK:", "if (stm->a) {", "checkfutureword(J, F, stm->a);", "target = breaktarget(J, F, stm->parent, stm->a->string);", "if (!target)", "jsC_error(J, stm, \"break label '%s' not found\", stm->a->string);", "} else {", "target = breaktarget(J, F, stm->parent, NULL);", "if (!target)", "jsC_error(J, stm, \"unlabelled break must be inside loop or switch\");", "}", "cexit(J, F, STM_BREAK, stm, target);", "emitline(J, F, stm);", "addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));", "break;", "", "case STM_CONTINUE:", "if (stm->a) {", "checkfutureword(J, F, stm->a);", "target = continuetarget(J, F, stm->parent, stm->a->string);", "if (!target)", "jsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);", "} else {", "target = continuetarget(J, F, stm->parent, NULL);", "if (!target)", "jsC_error(J, stm, \"continue must be inside loop\");", "}", "cexit(J, F, STM_CONTINUE, stm, target);", "emitline(J, F, stm);", "addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));", "break;", "", "case STM_RETURN:", "if (stm->a)", "cexp(J, F, stm->a);", "else", "emit(J, F, OP_UNDEF);", "target = returntarget(J, F, stm->parent);", "if (!target)", "jsC_error(J, stm, \"return not in function\");", "cexit(J, F, STM_RETURN, stm, target);", "emitline(J, F, stm);", "emit(J, F, OP_RETURN);", "break;", "", "case STM_THROW:", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "emit(J, F, OP_THROW);", "break;", "", "case STM_WITH:", "F->lightweight = 0;", "if (F->strict)", "jsC_error(J, stm->a, \"'with' statements are not allowed in strict mode\");", "cexp(J, F, stm->a);", "emitline(J, F, stm);", "emit(J, F, OP_WITH);", "cstm(J, F, stm->b);", "emitline(J, F, stm);", "emit(J, F, OP_ENDWITH);", "break;", "", "case STM_TRY:", "emitline(J, F, stm);", "if (stm->b && stm->c) {", "F->lightweight = 0;", "if (stm->d)", "ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);", "else", "ctrycatch(J, F, stm->a, stm->b, stm->c);", "} else {", "ctryfinally(J, F, stm->a, stm->d);", "}", "break;", "", "case STM_DEBUGGER:", "emitline(J, F, stm);", "emit(J, F, OP_DEBUGGER);", "break;", "", "default:", "if (F->script) {", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "cexp(J, F, stm);", "} else {", "cexp(J, F, stm);", "emitline(J, F, stm);", "emit(J, F, OP_POP);", "}", "break;", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)", "{", "#ifndef PB_ENABLE_MALLOC", "PB_UNUSED(wire_type);", "PB_UNUSED(iter);", "PB_RETURN_ERROR(stream, \"no malloc support\");", "#else", "pb_type_t type;", "pb_decoder_t func;", "", "type = iter->pos->type;", "func = PB_DECODERS[PB_LTYPE(type)];", "", "switch (PB_HTYPE(type))", "{", "case PB_HTYPE_REQUIRED:", "case PB_HTYPE_OPTIONAL:", "case PB_HTYPE_ONEOF:", "if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&", "*(void**)iter->pData != NULL)", "{", "", "pb_release_single_field(iter);", "}", "", "if (PB_HTYPE(type) == PB_HTYPE_ONEOF)", "{", "*(pb_size_t*)iter->pSize = iter->pos->tag;", "}", "", "if (PB_LTYPE(type) == PB_LTYPE_STRING ||", "PB_LTYPE(type) == PB_LTYPE_BYTES)", "{", "return func(stream, iter->pos, iter->pData);", "}", "else", "{", "if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))", "return false;", "", "initialize_pointer_field(*(void**)iter->pData, iter);", "return func(stream, iter->pos, *(void**)iter->pData);", "}", "", "case PB_HTYPE_REPEATED:", "if (wire_type == PB_WT_STRING", "&& PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)", "{", "", "bool status = true;", "pb_size_t *size = (pb_size_t*)iter->pSize;", "size_t allocated_size = *size;", "void *pItem;", "pb_istream_t substream;", "", "if (!pb_make_string_substream(stream, &substream))", "return false;", "", "while (substream.bytes_left)", "{", "if ((size_t)*size + 1 > allocated_size)", "{", "", "", "", "allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;", "", "if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))", "{", "status = false;", "break;", "}", "}", "", "", "pItem = *(char**)iter->pData + iter->pos->data_size * (*size);", "initialize_pointer_field(pItem, iter);", "if (!func(&substream, iter->pos, pItem))", "{", "status = false;", "break;", "}", "", "if (*size == PB_SIZE_MAX)", "{", "#ifndef PB_NO_ERRMSG", "stream->errmsg = \"too many array entries\";", "#endif", "status = false;", "break;", "}", "", "(*size)++;", "}", "if (!pb_close_string_substream(stream, &substream))", "return false;", "", "return status;", "}", "else", "{", "", "pb_size_t *size = (pb_size_t*)iter->pSize;", "void *pItem;", "", "if (*size == PB_SIZE_MAX)", "PB_RETURN_ERROR(stream, \"too many array entries\");", "", "(*size)++;", "if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))", "return false;", "", "pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);", "initialize_pointer_field(pItem, iter);", "return func(stream, iter->pos, pItem);", "}", "", "default:", "PB_RETURN_ERROR(stream, \"invalid field type\");", "}", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)", "{", "struct sk_buff *skb = (struct sk_buff *)(long) ctx;", "struct nlattr *nla;", "", "if (skb_is_nonlinear(skb))", "return 0;", "", "if (A > skb->len - sizeof(struct nlattr))", "return 0;", "", "nla = (struct nlattr *) &skb->data[A];", "if (nla->nla_len > A - skb->len)", "return 0;", "", "nla = nla_find_nested(nla, X);", "if (nla)", "return (void *) nla - (void *) skb->data;", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["SetFormatAndEncodings(rfbClient* client)", "{", "rfbSetPixelFormatMsg spf;", "char buf[sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4];", "", "rfbSetEncodingsMsg *se = (rfbSetEncodingsMsg *)buf;", "uint32_t *encs = (uint32_t *)(&buf[sz_rfbSetEncodingsMsg]);", "int len = 0;", "rfbBool requestCompressLevel = FALSE;", "rfbBool requestQualityLevel = FALSE;", "rfbBool requestLastRectEncoding = FALSE;", "rfbClientProtocolExtension* e;", "", "if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;", "", "spf.type = rfbSetPixelFormat;", "spf.pad1 = 0;", "spf.pad2 = 0;", "spf.format = client->format;", "spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);", "spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);", "spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);", "", "if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))", "return FALSE;", "", "", "if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;", "", "se->type = rfbSetEncodings;", "se->pad = 0;", "se->nEncodings = 0;", "", "if (client->appData.encodingsString) {", "const char *encStr = client->appData.encodingsString;", "int encStrLen;", "do {", "const char *nextEncStr = strchr(encStr, ' ');", "if (nextEncStr) {", "encStrLen = nextEncStr - encStr;", "nextEncStr++;", "} else {", "encStrLen = strlen(encStr);", "}", "", "if (strncasecmp(encStr,\"raw\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);", "} else if (strncasecmp(encStr,\"copyrect\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);", "#ifdef LIBVNCSERVER_HAVE_LIBZ", "#ifdef LIBVNCSERVER_HAVE_LIBJPEG", "} else if (strncasecmp(encStr,\"tight\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);", "requestLastRectEncoding = TRUE;", "if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)", "requestCompressLevel = TRUE;", "if (client->appData.enableJPEG)", "requestQualityLevel = TRUE;", "#endif", "#endif", "} else if (strncasecmp(encStr,\"hextile\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);", "#ifdef LIBVNCSERVER_HAVE_LIBZ", "} else if (strncasecmp(encStr,\"zlib\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);", "if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)", "requestCompressLevel = TRUE;", "} else if (strncasecmp(encStr,\"zlibhex\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlibHex);", "if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)", "requestCompressLevel = TRUE;", "} else if (strncasecmp(encStr,\"trle\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTRLE);", "} else if (strncasecmp(encStr,\"zrle\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);", "} else if (strncasecmp(encStr,\"zywrle\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);", "requestQualityLevel = TRUE;", "#endif", "} else if ((strncasecmp(encStr,\"ultra\",encStrLen) == 0) || (strncasecmp(encStr,\"ultrazip\",encStrLen) == 0)) {", "", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);", "} else if (strncasecmp(encStr,\"corre\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);", "} else if (strncasecmp(encStr,\"rre\",encStrLen) == 0) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);", "} else {", "rfbClientLog(\"Unknown encoding '%.*s'\\n\",encStrLen,encStr);", "}", "", "encStr = nextEncStr;", "} while (encStr && se->nEncodings < MAX_ENCODINGS);", "", "if (se->nEncodings < MAX_ENCODINGS && requestCompressLevel) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +", "rfbEncodingCompressLevel0);", "}", "", "if (se->nEncodings < MAX_ENCODINGS && requestQualityLevel) {", "if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)", "client->appData.qualityLevel = 5;", "encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +", "rfbEncodingQualityLevel0);", "}", "}", "else {", "if (SameMachine(client->sock)) {", "", "", "", "rfbClientLog(\"Same machine: preferring raw encoding\\n\");", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);", "", "", "", "", "", "}", "", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);", "#ifdef LIBVNCSERVER_HAVE_LIBZ", "#ifdef LIBVNCSERVER_HAVE_LIBJPEG", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);", "requestLastRectEncoding = TRUE;", "#endif", "#endif", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);", "#ifdef LIBVNCSERVER_HAVE_LIBZ", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);", "#endif", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);", "", "if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {", "encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +", "rfbEncodingCompressLevel0);", "} else                             {", "", "", "", "", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);", "}", "", "if (client->appData.enableJPEG) {", "if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)", "client->appData.qualityLevel = 5;", "encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +", "rfbEncodingQualityLevel0);", "}", "}", "", "", "", "", "if (client->appData.useRemoteCursor) {", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);", "}", "", "", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);", "", "", "if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);", "", "", "if (se->nEncodings < MAX_ENCODINGS && requestLastRectEncoding)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);", "", "", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);", "", "", "if (se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);", "", "", "for(e = rfbClientExtensions; e; e = e->next)", "if(e->encodings) {", "int* enc;", "for(enc = e->encodings; *enc; enc++)", "if(se->nEncodings < MAX_ENCODINGS)", "encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);", "}", "", "len = sz_rfbSetEncodingsMsg + se->nEncodings * 4;", "", "se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);", "", "if (!WriteToRFBServer(client, buf, len)) return FALSE;", "", "return TRUE;", "}"], "ner_tags": [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": [" xps_parse_path(xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root)", " {", " \tfz_xml *node;", " ", " \tchar *fill_uri;", " \tchar *stroke_uri;", " \tchar *opacity_mask_uri;", " ", " \tchar *transform_att;", " \tchar *clip_att;", " \tchar *data_att;", " \tchar *fill_att;", " \tchar *stroke_att;", " \tchar *opacity_att;", " \tchar *opacity_mask_att;", " ", " \tfz_xml *transform_tag = NULL;", " \tfz_xml *clip_tag = NULL;", " \tfz_xml *data_tag = NULL;", " \tfz_xml *fill_tag = NULL;", " \tfz_xml *stroke_tag = NULL;", " \tfz_xml *opacity_mask_tag = NULL;", " ", " \tchar *fill_opacity_att = NULL;", " \tchar *stroke_opacity_att = NULL;", " ", " \tchar *stroke_dash_array_att;", " \tchar *stroke_dash_cap_att;", " \tchar *stroke_dash_offset_att;", " \tchar *stroke_end_line_cap_att;", " \tchar *stroke_start_line_cap_att;", " \tchar *stroke_line_join_att;", " \tchar *stroke_miter_limit_att;", " \tchar *stroke_thickness_att;", " \tchar *navigate_uri_att;", "  ", "         fz_stroke_state *stroke = NULL;", "         fz_matrix transform;", "       float samples[32];", "        float samples[FZ_MAX_COLORS];", "         fz_colorspace *colorspace;", "         fz_path *path = NULL;", "         fz_path *stroke_path = NULL;", " \tfz_rect area;", " \tint fill_rule;", " \tint dash_len = 0;", " \tfz_matrix local_ctm;", " ", " \t ", " ", " \ttransform_att = fz_xml_att(root, \"RenderTransform\");", " \tclip_att = fz_xml_att(root, \"Clip\");", " \tdata_att = fz_xml_att(root, \"Data\");", " \tfill_att = fz_xml_att(root, \"Fill\");", " \tstroke_att = fz_xml_att(root, \"Stroke\");", " \topacity_att = fz_xml_att(root, \"Opacity\");", " \topacity_mask_att = fz_xml_att(root, \"OpacityMask\");", " ", " \tstroke_dash_array_att = fz_xml_att(root, \"StrokeDashArray\");", " \tstroke_dash_cap_att = fz_xml_att(root, \"StrokeDashCap\");", " \tstroke_dash_offset_att = fz_xml_att(root, \"StrokeDashOffset\");", " \tstroke_end_line_cap_att = fz_xml_att(root, \"StrokeEndLineCap\");", " \tstroke_start_line_cap_att = fz_xml_att(root, \"StrokeStartLineCap\");", " \tstroke_line_join_att = fz_xml_att(root, \"StrokeLineJoin\");", " \tstroke_miter_limit_att = fz_xml_att(root, \"StrokeMiterLimit\");", " \tstroke_thickness_att = fz_xml_att(root, \"StrokeThickness\");", " \tnavigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");", " ", " \tfor (node = fz_xml_down(root); node; node = fz_xml_next(node))", " \t{", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.RenderTransform\"))", " \t\t\ttransform_tag = fz_xml_down(node);", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.OpacityMask\"))", " \t\t\topacity_mask_tag = fz_xml_down(node);", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.Clip\"))", " \t\t\tclip_tag = fz_xml_down(node);", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.Fill\"))", " \t\t\tfill_tag = fz_xml_down(node);", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.Stroke\"))", " \t\t\tstroke_tag = fz_xml_down(node);", " \t\tif (!strcmp(fz_xml_tag(node), \"Path.Data\"))", " \t\t\tdata_tag = fz_xml_down(node);", " \t}", " ", " \tfill_uri = base_uri;", " \tstroke_uri = base_uri;", " \topacity_mask_uri = base_uri;", " ", " \txps_resolve_resource_reference(doc, dict, &data_att, &data_tag, NULL);", " \txps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);", " \txps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);", " \txps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);", " \txps_resolve_resource_reference(doc, dict, &stroke_att, &stroke_tag, &stroke_uri);", " \txps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);", " ", " \t ", " ", " \tif (!data_att && !data_tag)", " \t\treturn;", " ", " \tif (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))", " \t{", " \t\tfill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");", " \t\tfill_att = fz_xml_att(fill_tag, \"Color\");", " \t\tfill_tag = NULL;", " \t}", " ", " \tif (stroke_tag && !strcmp(fz_xml_tag(stroke_tag), \"SolidColorBrush\"))", " \t{", " \t\tstroke_opacity_att = fz_xml_att(stroke_tag, \"Opacity\");", " \t\tstroke_att = fz_xml_att(stroke_tag, \"Color\");", " \t\tstroke_tag = NULL;", " \t}", " ", " \tif (stroke_att || stroke_tag)", " \t{", " \t\tif (stroke_dash_array_att)", " \t\t{", " \t\t\tchar *s = stroke_dash_array_att;", " ", " \t\t\twhile (*s)", " \t\t\t{", " \t\t\t\twhile (*s == ' ')", " \t\t\t\t\ts++;", " \t\t\t\tif (*s)  ", " \t\t\t\t\tdash_len++;", " ", " \t\t\t\twhile (*s && *s != ' ')", " \t\t\t\t\ts++;", " \t\t\t}", " \t\t}", " \t\tstroke = fz_new_stroke_state_with_dash_len(doc->ctx, dash_len);", " \t\tstroke->start_cap = xps_parse_line_cap(stroke_start_line_cap_att);", " \t\tstroke->dash_cap = xps_parse_line_cap(stroke_dash_cap_att);", " \t\tstroke->end_cap = xps_parse_line_cap(stroke_end_line_cap_att);", " ", " \t\tstroke->linejoin = FZ_LINEJOIN_MITER_XPS;", " \t\tif (stroke_line_join_att)", " \t\t{", " \t\t\tif (!strcmp(stroke_line_join_att, \"Miter\")) stroke->linejoin = FZ_LINEJOIN_MITER_XPS;", " \t\t\tif (!strcmp(stroke_line_join_att, \"Round\")) stroke->linejoin = FZ_LINEJOIN_ROUND;", " \t\t\tif (!strcmp(stroke_line_join_att, \"Bevel\")) stroke->linejoin = FZ_LINEJOIN_BEVEL;", " \t\t}", " ", " \t\tstroke->miterlimit = 10;", " \t\tif (stroke_miter_limit_att)", " \t\t\tstroke->miterlimit = fz_atof(stroke_miter_limit_att);", " ", " \t\tstroke->linewidth = 1;", " \t\tif (stroke_thickness_att)", " \t\t\tstroke->linewidth = fz_atof(stroke_thickness_att);", " ", " \t\tstroke->dash_phase = 0;", " \t\tstroke->dash_len = 0;", " \t\tif (stroke_dash_array_att)", " \t\t{", " \t\t\tchar *s = stroke_dash_array_att;", " ", " \t\t\tif (stroke_dash_offset_att)", " \t\t\t\tstroke->dash_phase = fz_atof(stroke_dash_offset_att) * stroke->linewidth;", " ", " \t\t\twhile (*s)", " \t\t\t{", " \t\t\t\twhile (*s == ' ')", " \t\t\t\t\ts++;", " \t\t\t\tif (*s)  ", " \t\t\t\t\tstroke->dash_list[stroke->dash_len++] = fz_atof(s) * stroke->linewidth;", " \t\t\t\twhile (*s && *s != ' ')", " \t\t\t\t\ts++;", " \t\t\t}", " \t\t\tstroke->dash_len = dash_len;", " \t\t}", " \t}", " ", " \ttransform = fz_identity;", " \tif (transform_att)", " \t\txps_parse_render_transform(doc, transform_att, &transform);", " \tif (transform_tag)", " \t\txps_parse_matrix_transform(doc, transform_tag, &transform);", " \tfz_concat(&local_ctm, &transform, ctm);", " ", " \tif (clip_att || clip_tag)", " \t\txps_clip(doc, &local_ctm, dict, clip_att, clip_tag);", " ", " \tfill_rule = 0;", " \tif (data_att)", " \t\tpath = xps_parse_abbreviated_geometry(doc, data_att, &fill_rule);", " \telse if (data_tag)", " \t{", " \t\tpath = xps_parse_path_geometry(doc, dict, data_tag, 0, &fill_rule);", " \t\tif (stroke_att || stroke_tag)", " \t\t\tstroke_path = xps_parse_path_geometry(doc, dict, data_tag, 1, &fill_rule);", " \t}", " \tif (!stroke_path)", " \t\tstroke_path = path;", " ", " \tif (stroke_att || stroke_tag)", " \t{", " \t\tfz_bound_path(doc->ctx, stroke_path, stroke, &local_ctm, &area);", " \t\tif (stroke_path != path && (fill_att || fill_tag)) {", " \t\t\tfz_rect bounds;", " \t\t\tfz_bound_path(doc->ctx, path, NULL, &local_ctm, &bounds);", " \t\t\tfz_union_rect(&area, &bounds);", " \t\t}", " \t}", " \telse", " \t\tfz_bound_path(doc->ctx, path, NULL, &local_ctm, &area);", " ", " \tif (navigate_uri_att)", " \t\txps_add_link(doc, &area, base_uri, navigate_uri_att);", " ", " \txps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);", " ", " \tif (fill_att)", " \t{", " \t\txps_parse_color(doc, base_uri, fill_att, &colorspace, samples);", " \t\tif (fill_opacity_att)", " \t\t\tsamples[0] *= fz_atof(fill_opacity_att);", " \t\txps_set_color(doc, colorspace, samples);", " ", " \t\tfz_fill_path(doc->dev, path, fill_rule == 0, &local_ctm,", " \t\t\tdoc->colorspace, doc->color, doc->alpha);", " \t}", " ", " \tif (fill_tag)", " \t{", " \t\tfz_clip_path(doc->dev, path, &area, fill_rule == 0, &local_ctm);", " \t\txps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);", " \t\tfz_pop_clip(doc->dev);", " \t}", " ", " \tif (stroke_att)", " \t{", " \t\txps_parse_color(doc, base_uri, stroke_att, &colorspace, samples);", " \t\tif (stroke_opacity_att)", " \t\t\tsamples[0] *= fz_atof(stroke_opacity_att);", " \t\txps_set_color(doc, colorspace, samples);", " ", " \t\tfz_stroke_path(doc->dev, stroke_path, stroke, &local_ctm,", " \t\t\tdoc->colorspace, doc->color, doc->alpha);", " \t}", " ", " \tif (stroke_tag)", " \t{", " \t\tfz_clip_stroke_path(doc->dev, stroke_path, &area, stroke, &local_ctm);", " \t\txps_parse_brush(doc, &local_ctm, &area, stroke_uri, dict, stroke_tag);", " \t\tfz_pop_clip(doc->dev);", " \t}", " ", " \txps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);", " ", " \tif (stroke_path != path)", " \t\tfz_free_path(doc->ctx, stroke_path);", " \tfz_free_path(doc->ctx, path);", " \tpath = NULL;", " \tfz_drop_stroke_state(doc->ctx, stroke);", " ", " \tif (clip_att || clip_tag)", " \t\tfz_pop_clip(doc->dev);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int xen_netbk_get_extras(struct xenvif *vif,", " \t\t\t\tstruct xen_netif_extra_info *extras,", " \t\t\t\tint work_to_do)", " {", " \tstruct xen_netif_extra_info extra;", " \tRING_IDX cons = vif->tx.req_cons;", "  ", "  \tdo {", "  \t\tif (unlikely(work_to_do-- <= 0)) {", "\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");", " \t\t\tnetdev_err(vif->dev, \"Missing extra info\\n\");", " \t\t\tnetbk_fatal_tx_err(vif);", "  \t\t\treturn -EBADR;", "  \t\t}", "  ", " \t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),", " \t\t       sizeof(extra));", "  \t\tif (unlikely(!extra.type ||", "  \t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {", "  \t\t\tvif->tx.req_cons = ++cons;", "\t\t\tnetdev_dbg(vif->dev,", " \t\t\tnetdev_err(vif->dev,", "  \t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);", " \t\t\tnetbk_fatal_tx_err(vif);", "  \t\t\treturn -EINVAL;", "  \t\t}", "  ", " \t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));", " \t\tvif->tx.req_cons = ++cons;", " \t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);", " ", " \treturn work_to_do;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,", "const std::vector<int> &desired,", "const char *cwd,", "const std::vector<std::string> &env) {", "int id = GetId();", "Lock lock(g_procs[id].m_procMutex);", "always_assert(Available());", "always_assert(created.size() == desired.size());", "", "if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {", "Logger::Error(\"Failed to send command proc_open\");", "return -1;", "}", "fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());", "for (unsigned int i = 0; i < env.size(); i++) {", "fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());", "}", "", "fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());", "", "for (unsigned int i = 0; i < desired.size(); i++) {", "fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);", "}", "fflush(g_procs[id].m_fout);", "bool error_send = false;", "int save_errno = 0;", "for (unsigned int i = 0; i < created.size(); i++) {", "if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {", "error_send = true;", "save_errno = errno;", "break;", "}", "}", "", "char buf[BUFFER_SIZE];", "read_buf(g_procs[id].m_fin, buf);", "if (strncmp(buf, \"error\", 5) == 0) {", "read_buf(g_procs[id].m_fin, buf);", "sscanf(buf, \"%d\", &errno);", "if (error_send) {", "", "", "errno = save_errno;", "}", "return -1;", "}", "int64_t pid = -1;", "sscanf(buf, \"%\" PRId64, &pid);", "assert(pid);", "return (pid_t)pid;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": [" omx_vdec::omx_vdec(): m_error_propogated(false),", "     m_state(OMX_StateInvalid),", "     m_app_data(NULL),", "     m_inp_mem_ptr(NULL),", "     m_out_mem_ptr(NULL),", "     input_flush_progress (false),", "     output_flush_progress (false),", "     input_use_buffer (false),", "     output_use_buffer (false),", "     ouput_egl_buffers(false),", "     m_use_output_pmem(OMX_FALSE),", "     m_out_mem_region_smi(OMX_FALSE),", "     m_out_pvt_entry_pmem(OMX_FALSE),", "     pending_input_buffers(0),", "     pending_output_buffers(0),", "     m_out_bm_count(0),", "     m_inp_bm_count(0),", "     m_inp_bPopulated(OMX_FALSE),", "     m_out_bPopulated(OMX_FALSE),", "     m_flags(0),", " #ifdef _ANDROID_", "     m_heap_ptr(NULL),", " #endif", "     m_inp_bEnabled(OMX_TRUE),", "     m_out_bEnabled(OMX_TRUE),", "     m_in_alloc_cnt(0),", "     m_platform_list(NULL),", "     m_platform_entry(NULL),", "     m_pmem_info(NULL),", "     h264_parser(NULL),", "     arbitrary_bytes (true),", "     psource_frame (NULL),", "     pdest_frame (NULL),", "     m_inp_heap_ptr (NULL),", "     m_phdr_pmem_ptr(NULL),", "     m_heap_inp_bm_count (0),", "     codec_type_parse ((codec_type)0),", "     first_frame_meta (true),", "     frame_count (0),", "     nal_count (0),", "     nal_length(0),", "     look_ahead_nal (false),", "     first_frame(0),", "     first_buffer(NULL),", "     first_frame_size (0),", "     m_device_file_ptr(NULL),", "     m_vc1_profile((vc1_profile_type)0),", "     h264_last_au_ts(LLONG_MAX),", "     h264_last_au_flags(0),", "     m_disp_hor_size(0),", "     m_disp_vert_size(0),", "     prev_ts(LLONG_MAX),", "     rst_prev_ts(true),", "     frm_int(0),", "     in_reconfig(false),", "     m_display_id(NULL),", "     client_extradata(0),", "     m_reject_avc_1080p_mp (0),", " #ifdef _ANDROID_", "     m_enable_android_native_buffers(OMX_FALSE),", "     m_use_android_native_buffers(OMX_FALSE),", "     iDivXDrmDecrypt(NULL),", " #endif", "     m_desc_buffer_ptr(NULL),", "     secure_mode(false),", "     m_other_extradata(NULL),", "     m_profile(0),", "     client_set_fps(false),", "     m_last_rendered_TS(-1),", "     m_queued_codec_config_count(0),", "     secure_scaling_to_non_secure_opb(false)", " {", "   ", "     DEBUG_PRINT_HIGH(\"In %u bit OMX vdec Constructor\", (unsigned int)sizeof(long) * 8);", "     memset(&m_debug,0,sizeof(m_debug));", " #ifdef _ANDROID_", "  char property_value[PROPERTY_VALUE_MAX] = {0};", "     property_get(\"vidc.debug.level\", property_value, \"1\");", "     debug_level = atoi(property_value);", "     property_value[0] = '\\0';", " ", "     DEBUG_PRINT_HIGH(\"In OMX vdec Constructor\");", " ", "     property_get(\"vidc.dec.debug.perf\", property_value, \"0\");", "     perf_flag = atoi(property_value);", "  if (perf_flag) {", "         DEBUG_PRINT_HIGH(\"vidc.dec.debug.perf is %d\", perf_flag);", "         dec_time.start();", "         proc_frms = latency = 0;", "  }", "     prev_n_filled_len = 0;", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.debug.ts\", property_value, \"0\");", "     m_debug_timestamp = atoi(property_value);", "     DEBUG_PRINT_HIGH(\"vidc.dec.debug.ts value is %d\",m_debug_timestamp);", "  if (m_debug_timestamp) {", "         time_stamp_dts.set_timestamp_reorder_mode(true);", "         time_stamp_dts.enable_debug_print(true);", "  }", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.debug.concealedmb\", property_value, \"0\");", "     m_debug_concealedmb = atoi(property_value);", "     DEBUG_PRINT_HIGH(\"vidc.dec.debug.concealedmb value is %d\",m_debug_concealedmb);", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.profile.check\", property_value, \"0\");", "     m_reject_avc_1080p_mp = atoi(property_value);", "     DEBUG_PRINT_HIGH(\"vidc.dec.profile.check value is %d\",m_reject_avc_1080p_mp);", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.log.in\", property_value, \"0\");", "     m_debug.in_buffer_log = atoi(property_value);", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.log.out\", property_value, \"0\");", "     m_debug.out_buffer_log = atoi(property_value);", "     sprintf(m_debug.log_loc, \"%s\", BUFFER_LOG_LOC);", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.log.loc\", property_value, \"\");", "  if (*property_value)", "         strlcpy(m_debug.log_loc, property_value, PROPERTY_VALUE_MAX);", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.120fps.enabled\", property_value, \"0\");", " ", "  if(atoi(property_value)) {", "         DEBUG_PRINT_LOW(\"feature 120 FPS decode enabled\");", "         m_last_rendered_TS = 0;", "  }", " ", "     property_value[0] = '\\0';", "     property_get(\"vidc.dec.debug.dyn.disabled\", property_value, \"0\");", "     m_disable_dynamic_buf_mode = atoi(property_value);", "     DEBUG_PRINT_HIGH(\"vidc.dec.debug.dyn.disabled value is %d\",m_disable_dynamic_buf_mode);", " ", " #endif", "     memset(&m_cmp,0,sizeof(m_cmp));", "     memset(&m_cb,0,sizeof(m_cb));", "     memset (&drv_ctx,0,sizeof(drv_ctx));", "     memset (&h264_scratch,0,sizeof (OMX_BUFFERHEADERTYPE));", "     memset (m_hwdevice_name,0,sizeof(m_hwdevice_name));", "     memset(m_demux_offsets, 0, ( sizeof(OMX_U32) * 8192) );", "     memset(&m_custom_buffersize, 0, sizeof(m_custom_buffersize));", "     m_demux_entries = 0;", "     msg_thread_id = 0;", "     async_thread_id = 0;", "     msg_thread_created = false;", "     async_thread_created = false;", " #ifdef _ANDROID_ICS_", "     memset(&native_buffer, 0 ,(sizeof(struct nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS));", " #endif", "     memset(&drv_ctx.extradata_info, 0, sizeof(drv_ctx.extradata_info));", " ", "   ", "     memset(&m_frame_pack_arrangement, 0, sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));", "     m_frame_pack_arrangement.cancel_flag = 1;", " ", "     drv_ctx.timestamp_adjust = false;", "     drv_ctx.video_driver_fd = -1;", " ", "      m_vendor_config.pData = NULL;", "      pthread_mutex_init(&m_lock, NULL);", "      pthread_mutex_init(&c_lock, NULL);", "     pthread_mutex_init(&buf_lock, NULL);", "      sem_init(&m_cmd_lock,0,0);", "      sem_init(&m_safe_flush, 0, 0);", "      streaming[CAPTURE_PORT] =", "         streaming[OUTPUT_PORT] = false;", " #ifdef _ANDROID_", "  char extradata_value[PROPERTY_VALUE_MAX] = {0};", "     property_get(\"vidc.dec.debug.extradata\", extradata_value, \"0\");", "     m_debug_extradata = atoi(extradata_value);", "     DEBUG_PRINT_HIGH(\"vidc.dec.debug.extradata value is %d\",m_debug_extradata);", " #endif", "     m_fill_output_msg = OMX_COMPONENT_GENERATE_FTB;", "     client_buffers.set_vdec_client(this);", "     dynamic_buf_mode = false;", "     out_dynamic_list = NULL;", "     is_down_scalar_enabled = false;", "     m_smoothstreaming_mode = false;", "     m_smoothstreaming_width = 0;", "     m_smoothstreaming_height = 0;", "     is_q6_platform = false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {", "  #if WRITE_COMPRESSED_STREAM", "   virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {", "      ++out_frames_;", "  ", "  if (pkt->data.frame.pts == 0)", "       write_ivf_file_header(&cfg_, 0, outfile_);", " ", " ", "      write_ivf_frame_header(pkt, outfile_);", "      (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);", "#endif", "    }"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" DevToolsClient::DevToolsClient(", "     RenderFrame* main_render_frame,", "     const std::string& compatibility_script)", "     : RenderFrameObserver(main_render_frame),", "        compatibility_script_(compatibility_script),", "        web_tools_frontend_(", "            WebDevToolsFrontend::create(main_render_frame->GetWebFrame(), this)) {", "   compatibility_script_ += \"\\n# sourceURL=devtools_compatibility.js\";", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" void DragController::PerformDrag(DragData* drag_data, LocalFrame& local_root) {", "   DCHECK(drag_data);", "   document_under_mouse_ =", "       local_root.DocumentAtPoint(LayoutPoint(drag_data->ClientPosition()));", "   std::unique_ptr<UserGestureIndicator> gesture = Frame::NotifyUserActivation(", "       document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr,", "       UserGestureToken::kNewGesture);", "   if ((drag_destination_action_ & kDragDestinationActionDHTML) &&", "       document_is_handling_drag_) {", "     bool prevented_default = false;", "     if (local_root.View()) {", "       DataTransfer* data_transfer =", "           CreateDraggingDataTransfer(kDataTransferReadable, drag_data);", "       data_transfer->SetSourceOperation(", "           drag_data->DraggingSourceOperationMask());", "       EventHandler& event_handler = local_root.GetEventHandler();", "       prevented_default = event_handler.PerformDragAndDrop(", "                               CreateMouseEvent(drag_data), data_transfer) !=", "                           WebInputEventResult::kNotHandled;", "       if (!prevented_default) {", "         const LayoutPoint point = local_root.View()->RootFrameToContents(", "             LayoutPoint(drag_data->ClientPosition()));", "         const HitTestResult result = event_handler.HitTestResultAtPoint(point);", "         prevented_default |=", "             IsHTMLPlugInElement(*result.InnerNode()) &&", "             ToHTMLPlugInElement(result.InnerNode())->CanProcessDrag();", "       }", " ", "       data_transfer->SetAccessPolicy(kDataTransferNumb);", "     }", "     if (prevented_default) {", "       document_under_mouse_ = nullptr;", "       CancelDrag();", "       return;", "     }", "   }", " ", "   if ((drag_destination_action_ & kDragDestinationActionEdit) &&", "       ConcludeEditDrag(drag_data)) {", "     document_under_mouse_ = nullptr;", "     return;", "   }", " ", "   document_under_mouse_ = nullptr;", " ", "   if (OperationForLoad(drag_data, local_root) != kDragOperationNone) {", "     if (page_->GetSettings().GetNavigateOnDragDrop()) {", "       ResourceRequest resource_request(drag_data->AsURL());", "        resource_request.SetRequestorOrigin(", "            SecurityOrigin::Create(KURL(drag_data->AsURL())));", "       resource_request.SetHasUserGesture(Frame::HasTransientUserActivation(", "           document_under_mouse_ ? document_under_mouse_->GetFrame() : nullptr));", "        page_->MainFrame()->Navigate(FrameLoadRequest(nullptr, resource_request));", "      }", "  ", "     local_root.GetEventHandler().ClearDragState();", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)", " {", " \tconst struct k_clock *kc = timr->kclock;", " \tktime_t now, remaining, iv;", " \tstruct timespec64 ts64;", " \tbool sig_none;", " ", " \tsig_none = timr->it_sigev_notify == SIGEV_NONE;", " \tiv = timr->it_interval;", " ", " \t ", " \tif (iv) {", " \t\tcur_setting->it_interval = ktime_to_timespec64(iv);", " \t} else if (!timr->it_active) {", " \t\t ", " \t\tif (!sig_none)", " \t\t\treturn;", " \t}", " ", " \t ", " \tkc->clock_get(timr->it_clock, &ts64);", " \tnow = timespec64_to_ktime(ts64);", " ", " \t ", "  \tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))", "\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);", " \t\ttimr->it_overrun += kc->timer_forward(timr, now);", "  ", "  \tremaining = kc->timer_remaining(timr, now);", "  \t ", " \tif (remaining <= 0) {", " \t\t ", " \t\tif (!sig_none)", " \t\t\tcur_setting->it_value.tv_nsec = 1;", " \t} else {", " \t\tcur_setting->it_value = ktime_to_timespec64(remaining);", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" create_watching_parent (void)", " {", "   pid_t child;", "   sigset_t ourset;", "   struct sigaction oldact[3];", "   int status = 0;", "   int retval;", " ", "   retval = pam_open_session (pamh, 0);", "   if (is_pam_failure(retval))", "     {", "       cleanup_pam (retval);", "       errx (EXIT_FAILURE, _(\"cannot open session: %s\"),", " \t     pam_strerror (pamh, retval));", "     }", "   else", "     _pam_session_opened = 1;", " ", "   memset(oldact, 0, sizeof(oldact));", " ", "   child = fork ();", "   if (child == (pid_t) -1)", "     {", "       cleanup_pam (PAM_ABORT);", "       err (EXIT_FAILURE, _(\"cannot create child process\"));", "     }", " ", "    ", "   if (child == 0)", "     return;", " ", "    ", " ", "    ", "   if (chdir (\"/\") != 0)", "     warn (_(\"cannot change directory to %s\"), \"/\");", " ", "   sigfillset (&ourset);", "   if (sigprocmask (SIG_BLOCK, &ourset, NULL))", "     {", "       warn (_(\"cannot block signals\"));", "       caught_signal = true;", "     }", "   if (!caught_signal)", "     {", "       struct sigaction action;", "       action.sa_handler = su_catch_sig;", "       sigemptyset (&action.sa_mask);", "       action.sa_flags = 0;", "       sigemptyset (&ourset);", "     if (!same_session)", "       {", "         if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))", "           {", "             warn (_(\"cannot set signal handler\"));", "             caught_signal = true;", "           }", "       }", "     if (!caught_signal && (sigaddset(&ourset, SIGTERM)", "                     || sigaddset(&ourset, SIGALRM)", "                     || sigaction(SIGTERM, &action, &oldact[0])", "                     || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {", " \t  warn (_(\"cannot set signal handler\"));", " \t  caught_signal = true;", " \t}", "     if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])", "                                      || sigaction(SIGQUIT, &action, &oldact[2])))", "       {", "         warn (_(\"cannot set signal handler\"));", "         caught_signal = true;", "       }", "     }", "   if (!caught_signal)", "     {", "       pid_t pid;", "       for (;;)", " \t{", " \t  pid = waitpid (child, &status, WUNTRACED);", " ", " \t  if (pid != (pid_t)-1 && WIFSTOPPED (status))", " \t    {", " \t      kill (getpid (), SIGSTOP);", " \t       ", " \t      kill (pid, SIGCONT);", " \t    }", " \t  else", " \t    break;", " \t}", "       if (pid != (pid_t)-1)", "         {", "           if (WIFSIGNALED (status))", "             {", "               fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),", "                        WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");", "               status = WTERMSIG (status) + 128;", "              }", "            else", "              status = WEXITSTATUS (status);", " ", " \t   ", " \t  child = (pid_t) -1;", "          }", "        else if (caught_signal)", "          status = caught_signal + 128;", "       else", "         status = 1;", "     }", "    else", "      status = 1;", "  ", "  if (caught_signal)", "   if (caught_signal && child != (pid_t)-1)", "      {", "        fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));", "        kill (child, SIGTERM);", "     }", " ", "   cleanup_pam (PAM_SUCCESS);", "  ", "    if (caught_signal)", "      {", "      sleep (2);", "      kill (child, SIGKILL);", "      fprintf (stderr, _(\" ...killed.\\n\"));", "       if (child != (pid_t)-1)", " \t{", " \t  sleep (2);", " \t  kill (child, SIGKILL);", " \t  fprintf (stderr, _(\" ...killed.\\n\"));", " \t}", "  ", "         ", "       switch (caught_signal) {", "         case SIGTERM:", "           sigaction(SIGTERM, &oldact[0], NULL);", "           break;", "         case SIGINT:", "           sigaction(SIGINT, &oldact[1], NULL);", "           break;", "         case SIGQUIT:", "           sigaction(SIGQUIT, &oldact[2], NULL);", "           break;", "         default:", " \t   ", "           caught_signal = SIGKILL;", "           break;", "       }", "       kill(getpid(), caught_signal);", "     }", "   exit (status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  VaapiVideoDecodeAccelerator::VaapiVP8Accelerator::CreateVP8Picture() {", "   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);", "    scoped_refptr<VaapiDecodeSurface> va_surface = vaapi_dec_->CreateSurface();", "    if (!va_surface)", "      return nullptr;", " ", "   return new VaapiVP8Picture(std::move(va_surface));", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": ["int ZLIB_INTERNAL _tr_tally (s, dist, lc)", "deflate_state *s;", "unsigned dist;", "unsigned lc;", "{", "s->d_buf[s->last_lit] = (ush)dist;", "s->l_buf[s->last_lit++] = (uch)lc;", "if (dist == 0) {", "", "s->dyn_ltree[lc].Freq++;", "} else {", "s->matches++;", "", "dist--;", "Assert((ush)dist < (ush)MAX_DIST(s) &&", "(ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&", "(ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");", "", "s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;", "s->dyn_dtree[d_code(dist)].Freq++;", "}", "", "#ifdef TRUNCATE_BLOCK", "", "if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {", "", "ulg out_length = (ulg)s->last_lit*8L;", "ulg in_length = (ulg)((long)s->strstart - s->block_start);", "int dcode;", "for (dcode = 0; dcode < D_CODES; dcode++) {", "out_length += (ulg)s->dyn_dtree[dcode].Freq *", "(5L+extra_dbits[dcode]);", "}", "out_length >>= 3;", "Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",", "s->last_lit, in_length, out_length,", "100L - out_length*100L/in_length));", "if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;", "}", "#endif", "return (s->last_lit == s->lit_bufsize-1);", "", "", "", "", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["static int read_header(FFV1Context *f)", "{", "uint8_t state[CONTEXT_SIZE];", "int i, j, context_count = -1;", "RangeCoder *const c = &f->slice_context[0]->c;", "", "memset(state, 128, sizeof(state));", "", "if (f->version < 2) {", "int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;", "unsigned v= get_symbol(c, state, 0);", "if (v >= 2) {", "av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);", "return AVERROR_INVALIDDATA;", "}", "f->version = v;", "f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);", "if (f->ac > 1) {", "for (i = 1; i < 256; i++)", "f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];", "}", "", "colorspace          = get_symbol(c, state, 0);", "bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;", "chroma_planes       = get_rac(c, state);", "chroma_h_shift      = get_symbol(c, state, 0);", "chroma_v_shift      = get_symbol(c, state, 0);", "transparency        = get_rac(c, state);", "", "if (f->plane_count) {", "if (colorspace          != f->colorspace                 ||", "bits_per_raw_sample != f->avctx->bits_per_raw_sample ||", "chroma_planes       != f->chroma_planes              ||", "chroma_h_shift      != f->chroma_h_shift             ||", "chroma_v_shift      != f->chroma_v_shift             ||", "transparency        != f->transparency) {", "av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");", "return AVERROR_INVALIDDATA;", "}", "}", "", "if (chroma_h_shift > 4U || chroma_v_shift > 4U) {", "av_log(f->avctx, AV_LOG_ERROR, \"chroma shift parameters %d %d are invalid\\n\",", "chroma_h_shift, chroma_v_shift);", "return AVERROR_INVALIDDATA;", "}", "", "f->colorspace                 = colorspace;", "f->avctx->bits_per_raw_sample = bits_per_raw_sample;", "f->chroma_planes              = chroma_planes;", "f->chroma_h_shift             = chroma_h_shift;", "f->chroma_v_shift             = chroma_v_shift;", "f->transparency               = transparency;", "", "f->plane_count    = 2 + f->transparency;", "}", "", "if (f->colorspace == 0) {", "if (f->avctx->skip_alpha) f->transparency = 0;", "if (!f->transparency && !f->chroma_planes) {", "if (f->avctx->bits_per_raw_sample <= 8)", "f->avctx->pix_fmt = AV_PIX_FMT_GRAY8;", "else", "f->avctx->pix_fmt = AV_PIX_FMT_GRAY16;", "} else if (f->avctx->bits_per_raw_sample<=8 && !f->transparency) {", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P; break;", "case 0x01: f->avctx->pix_fmt = AV_PIX_FMT_YUV440P; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P; break;", "case 0x20: f->avctx->pix_fmt = AV_PIX_FMT_YUV411P; break;", "case 0x22: f->avctx->pix_fmt = AV_PIX_FMT_YUV410P; break;", "}", "} else if (f->avctx->bits_per_raw_sample <= 8 && f->transparency) {", "switch(16*f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 9 && !f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P9; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P9; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P9; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 9 && f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P9; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P9; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P9; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 10 && !f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P10; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P10; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P10; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 10 && f->transparency) {", "f->packed_at_lsb = 1;", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P10; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P10; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P10; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 16 && !f->transparency){", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUV444P16; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUV422P16; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUV420P16; break;", "}", "} else if (f->avctx->bits_per_raw_sample == 16 && f->transparency){", "switch(16 * f->chroma_h_shift + f->chroma_v_shift) {", "case 0x00: f->avctx->pix_fmt = AV_PIX_FMT_YUVA444P16; break;", "case 0x10: f->avctx->pix_fmt = AV_PIX_FMT_YUVA422P16; break;", "case 0x11: f->avctx->pix_fmt = AV_PIX_FMT_YUVA420P16; break;", "}", "}", "} else if (f->colorspace == 1) {", "if (f->chroma_h_shift || f->chroma_v_shift) {", "av_log(f->avctx, AV_LOG_ERROR,", "\"chroma subsampling not supported in this colorspace\\n\");", "return AVERROR(ENOSYS);", "}", "if (     f->avctx->bits_per_raw_sample ==  9)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP9;", "else if (f->avctx->bits_per_raw_sample == 10)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP10;", "else if (f->avctx->bits_per_raw_sample == 12)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP12;", "else if (f->avctx->bits_per_raw_sample == 14)", "f->avctx->pix_fmt = AV_PIX_FMT_GBRP14;", "else", "if (f->transparency) f->avctx->pix_fmt = AV_PIX_FMT_RGB32;", "else                 f->avctx->pix_fmt = AV_PIX_FMT_0RGB32;", "} else {", "av_log(f->avctx, AV_LOG_ERROR, \"colorspace not supported\\n\");", "return AVERROR(ENOSYS);", "}", "if (f->avctx->pix_fmt == AV_PIX_FMT_NONE) {", "av_log(f->avctx, AV_LOG_ERROR, \"format not supported\\n\");", "return AVERROR(ENOSYS);", "}", "", "av_dlog(f->avctx, \"%d %d %d\\n\",", "f->chroma_h_shift, f->chroma_v_shift, f->avctx->pix_fmt);", "if (f->version < 2) {", "context_count = read_quant_tables(c, f->quant_table);", "if (context_count < 0) {", "av_log(f->avctx, AV_LOG_ERROR, \"read_quant_table error\\n\");", "return AVERROR_INVALIDDATA;", "}", "f->slice_count = f->max_slice_count;", "} else if (f->version < 3) {", "f->slice_count = get_symbol(c, state, 0);", "} else {", "const uint8_t *p = c->bytestream_end;", "for (f->slice_count = 0;", "f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;", "f->slice_count++) {", "int trailer = 3 + 5*!!f->ec;", "int size = AV_RB24(p-trailer);", "if (size + trailer > p - c->bytestream_start)", "break;", "p -= size + trailer;", "}", "}", "if (f->slice_count > (unsigned)MAX_SLICES || f->slice_count <= 0 || f->slice_count > f->max_slice_count) {", "av_log(f->avctx, AV_LOG_ERROR, \"slice count %d is invalid (max=%d)\\n\", f->slice_count, f->max_slice_count);", "return AVERROR_INVALIDDATA;", "}", "", "for (j = 0; j < f->slice_count; j++) {", "FFV1Context *fs = f->slice_context[j];", "fs->ac            = f->ac;", "fs->packed_at_lsb = f->packed_at_lsb;", "", "fs->slice_damaged = 0;", "", "if (f->version == 2) {", "fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;", "fs->slice_y      =  get_symbol(c, state, 0)      * f->height;", "fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width  + fs->slice_x;", "fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;", "", "fs->slice_x     /= f->num_h_slices;", "fs->slice_y     /= f->num_v_slices;", "fs->slice_width  = fs->slice_width  / f->num_h_slices - fs->slice_x;", "fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;", "if ((unsigned)fs->slice_width  > f->width ||", "(unsigned)fs->slice_height > f->height)", "return AVERROR_INVALIDDATA;", "if (   (unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width", "|| (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)", "return AVERROR_INVALIDDATA;", "}", "", "for (i = 0; i < f->plane_count; i++) {", "PlaneContext *const p = &fs->plane[i];", "", "if (f->version == 2) {", "int idx = get_symbol(c, state, 0);", "if (idx > (unsigned)f->quant_table_count) {", "av_log(f->avctx, AV_LOG_ERROR,", "\"quant_table_index out of range\\n\");", "return AVERROR_INVALIDDATA;", "}", "p->quant_table_index = idx;", "memcpy(p->quant_table, f->quant_tables[idx],", "sizeof(p->quant_table));", "context_count = f->context_count[idx];", "} else {", "memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));", "}", "", "if (f->version <= 2) {", "av_assert0(context_count >= 0);", "if (p->context_count < context_count) {", "av_freep(&p->state);", "av_freep(&p->vlc_state);", "}", "p->context_count = context_count;", "}", "}", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static ssize_t fuse_fill_write_pages(struct fuse_req *req,", " \t\t\t       struct address_space *mapping,", " \t\t\t       struct iov_iter *ii, loff_t pos)", " {", " \tstruct fuse_conn *fc = get_fuse_conn(mapping->host);", " \tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);", " \tsize_t count = 0;", " \tint err;", " ", " \treq->in.argpages = 1;", " \treq->page_descs[0].offset = offset;", " ", " \tdo {", " \t\tsize_t tmp;", " \t\tstruct page *page;", " \t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;", " \t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,", " \t\t\t\t     iov_iter_count(ii));", " ", " \t\tbytes = min_t(size_t, bytes, fc->max_write - count);", " ", "  again:", " \t\terr = -EFAULT;", " \t\tif (iov_iter_fault_in_readable(ii, bytes))", " \t\t\tbreak;", " ", " \t\terr = -ENOMEM;", " \t\tpage = grab_cache_page_write_begin(mapping, index, 0);", " \t\tif (!page)", " \t\t\tbreak;", " ", " \t\tif (mapping_writably_mapped(mapping))", " \t\t\tflush_dcache_page(page);", " ", "  \t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);", "  \t\tflush_dcache_page(page);", "  ", " \t\tiov_iter_advance(ii, tmp);", "  \t\tif (!tmp) {", "  \t\t\tunlock_page(page);", "  \t\t\tpage_cache_release(page);", " \t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));", " \t\t\tgoto again;", " \t\t}", " ", " \t\terr = 0;", " \t\treq->pages[req->num_pages] = page;", "  \t\treq->page_descs[req->num_pages].length = tmp;", "  \t\treq->num_pages++;", "  ", "\t\tiov_iter_advance(ii, tmp);", "  \t\tcount += tmp;", "  \t\tpos += tmp;", "  \t\toffset += tmp;", " \t\tif (offset == PAGE_CACHE_SIZE)", " \t\t\toffset = 0;", " ", " \t\tif (!fc->big_writes)", " \t\t\tbreak;", " \t} while (iov_iter_count(ii) && count < fc->max_write &&", " \t\t req->num_pages < req->max_pages && offset == 0);", " ", " \treturn count > 0 ? count : err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool NaClProcessHost::OnMessageReceived(const IPC::Message& msg) {", "   bool handled = true;", "   IPC_BEGIN_MESSAGE_MAP(NaClProcessHost, msg)", "     IPC_MESSAGE_HANDLER(NaClProcessMsg_QueryKnownToValidate,", "                         OnQueryKnownToValidate)", "     IPC_MESSAGE_HANDLER(NaClProcessMsg_SetKnownToValidate,", "                         OnSetKnownToValidate)", " #if defined(OS_WIN)", "      IPC_MESSAGE_HANDLER_DELAY_REPLY(NaClProcessMsg_AttachDebugExceptionHandler,", "                                      OnAttachDebugExceptionHandler)", "  #endif", "    IPC_MESSAGE_HANDLER(NaClProcessHostMsg_PpapiChannelCreated,", "                        OnPpapiChannelCreated)", "      IPC_MESSAGE_UNHANDLED(handled = false)", "    IPC_END_MESSAGE_MAP()", "    return handled;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)", " {", " \tstruct sock *sk = sock->sk;", " \tstruct bt_security sec;", " \tint len, err = 0;", " ", " \tBT_DBG(\"sk %p\", sk);", " ", " \tif (level == SOL_RFCOMM)", " \t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);", " ", " \tif (level != SOL_BLUETOOTH)", " \t\treturn -ENOPROTOOPT;", " ", " \tif (get_user(len, optlen))", " \t\treturn -EFAULT;", " ", " \tlock_sock(sk);", " ", " \tswitch (optname) {", " \tcase BT_SECURITY:", " \t\tif (sk->sk_type != SOCK_STREAM) {", " \t\t\terr = -EINVAL;", " \t\t\tbreak;", "  \t\t}", "  ", "  \t\tsec.level = rfcomm_pi(sk)->sec_level;", " \t\tsec.key_size = 0;", "  ", "  \t\tlen = min_t(unsigned int, len, sizeof(sec));", "  \t\tif (copy_to_user(optval, (char *) &sec, len))", " \t\t\terr = -EFAULT;", " ", " \t\tbreak;", " ", " \tcase BT_DEFER_SETUP:", " \t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {", " \t\t\terr = -EINVAL;", " \t\t\tbreak;", " \t\t}", " ", " \t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),", " \t\t\t     (u32 __user *) optval))", " \t\t\terr = -EFAULT;", " ", " \t\tbreak;", " ", " \tdefault:", " \t\terr = -ENOPROTOOPT;", " \t\tbreak;", " \t}", " ", " \trelease_sock(sk);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int may_create_in_sticky(struct dentry * const dir,", "struct inode * const inode)", "{", "if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||", "(!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||", "likely(!(dir->d_inode->i_mode & S_ISVTX)) ||", "uid_eq(inode->i_uid, dir->d_inode->i_uid) ||", "uid_eq(current_fsuid(), inode->i_uid))", "return 0;", "", "if (likely(dir->d_inode->i_mode & 0002) ||", "(dir->d_inode->i_mode & 0020 &&", "((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||", "(sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {", "const char *operation = S_ISFIFO(inode->i_mode) ?", "\"sticky_create_fifo\" :", "\"sticky_create_regular\";", "audit_log_path_denied(AUDIT_ANOM_CREAT, operation);", "return -EACCES;", "}", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int get_default_root(pool *p, int allow_symlinks, char **root) {", "    config_rec *c = NULL;", "    char *dir = NULL;", "   int res;", " ", "   c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);", "   while (c) {", "     pr_signals_handle();", " ", "      ", "     if (c->argc < 2) {", "       dir = c->argv[0];", "       break;", "     }", " ", "     res = pr_expr_eval_group_and(((char **) c->argv)+1);", "     if (res) {", "       dir = c->argv[0];", "       break;", "     }", " ", "     c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);", "   }", " ", "   if (dir) {", "     char *new_dir;", " ", "      ", "     new_dir = path_subst_uservar(p, &dir);", "     if (new_dir != NULL) {", "       dir = new_dir;", "     }", " ", "     if (strncmp(dir, \"/\", 2) == 0) {", "       dir = NULL;", " ", "     } else {", "       char *realdir;", "       int xerrno = 0;", "  ", "        if (allow_symlinks == FALSE) {", "          char *path, target_path[PR_TUNABLE_PATH_MAX + 1];", "        struct stat st;", "          size_t pathlen;", "  ", "           ", " ", "         path = dir;", "         if (*path != '/') {", "           if (*path == '~') {", "             if (pr_fs_interpolate(dir, target_path,", "                 sizeof(target_path)-1) < 0) {", "               return -1;", "             }", " ", "             path = target_path;", "           }", "         }", " ", "          ", "         pathlen = strlen(path);", "         if (pathlen > 1 &&", "             path[pathlen-1] == '/') {", "            path[pathlen-1] = '\\0';", "          }", "  ", "        pr_fs_clear_cache();", "        res = pr_fsio_lstat(path, &st);", "         res = is_symlink_path(p, path, pathlen);", "          if (res < 0) {", "          xerrno = errno;", "          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,", "            strerror(xerrno));", "          errno = xerrno;", "          return -1;", "        }", "           if (errno == EPERM) {", "             pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"", "               \"(denied by AllowChrootSymlinks config)\", path);", "           }", "  ", "        if (S_ISLNK(st.st_mode)) {", "          pr_log_pri(PR_LOG_WARNING,", "            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"", "            \"config)\", path);", "            errno = EPERM;", "            return -1;", "          }", "       }", " ", "        ", " ", "       PRIVS_USER", "       realdir = dir_realpath(p, dir);", "       xerrno = errno;", "       PRIVS_RELINQUISH", " ", "       if (realdir) {", "         dir = realdir;", " ", "       } else {", "          ", "         char interp_dir[PR_TUNABLE_PATH_MAX + 1];", " ", "         memset(interp_dir, '\\0', sizeof(interp_dir));", "         (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); ", " ", "         pr_log_pri(PR_LOG_NOTICE,", "           \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",", "           dir, interp_dir, strerror(xerrno));", " ", "         errno = xerrno;", "       }", "     }", "   }", " ", "   *root = dir;", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void DoCompute(OpKernelContext* c) {", "core::RefCountPtr<Var> v;", "OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v));", "Tensor* params = v->tensor();", "const Tensor& indices = c->input(1);", "const Tensor& updates = c->input(2);", "", "", "OP_REQUIRES(c,", "updates.dims() == 0 ||", "updates.dims() == indices.dims() + params->dims() - 1,", "errors::InvalidArgument(", "\"Must have updates.shape = indices.shape + \"", "\"params.shape[1:] or updates.shape = [], got \",", "\"updates.shape \", updates.shape().DebugString(),", "\", indices.shape \", indices.shape().DebugString(),", "\", params.shape \", params->shape().DebugString()));", "", "", "const int64_t N_big = indices.NumElements();", "OP_REQUIRES(", "c, N_big <= std::numeric_limits<Index>::max(),", "errors::InvalidArgument(\"indices has too many elements for \",", "DataTypeString(DataTypeToEnum<Index>::v()),", "\" indexing: \", N_big, \" > \",", "std::numeric_limits<Index>::max()));", "const Index N = static_cast<Index>(N_big);", "OP_REQUIRES(", "c, params->dim_size(0) <= std::numeric_limits<Index>::max(),", "errors::InvalidArgument(\"params.shape[0] too large for \",", "DataTypeString(DataTypeToEnum<Index>::v()),", "\" indexing: \", params->dim_size(0), \" > \",", "std::numeric_limits<Index>::max()));", "", "if (N > 0) {", "auto indices_flat = indices.flat<Index>();", "auto params_flat = params->flat_outer_dims<T>();", "if (TensorShapeUtils::IsScalar(updates.shape())) {", "const auto update = updates.scalar<T>();", "", "functor::ScatterScalarFunctor<Device, T, Index, op> functor;", "const Index bad_i = functor(c, c->template eigen_device<Device>(),", "params_flat, update, indices_flat);", "OP_REQUIRES(c, bad_i < 0,", "errors::InvalidArgument(", "\"indices\", SliceDebugString(indices.shape(), bad_i),", "\" = \", indices_flat(bad_i), \" is not in [0, \",", "params->dim_size(0), \")\"));", "} else {", "int64_t num_updates = updates.NumElements();", "OP_REQUIRES(", "c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),", "errors::InvalidArgument(", "\"The shape of indices (\", indices.shape().DebugString(),", "\") must be a prefix of the shape of updates (\",", "updates.shape().DebugString(), \")\"));", "auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});", "", "functor::ScatterFunctor<Device, T, Index, op> functor;", "const Index bad_i = functor(c, c->template eigen_device<Device>(),", "params_flat, updates_flat, indices_flat);", "OP_REQUIRES(c, bad_i < 0,", "errors::InvalidArgument(", "\"indices\", SliceDebugString(indices.shape(), bad_i),", "\" = \", indices_flat(bad_i), \" is not in [0, \",", "params->dim_size(0), \")\"));", "}", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)", " {", " \t__be32 *p;", "   ", "  \tRESERVE_SPACE(8);", "  \tWRITE32(OP_OPEN);", "  \tWRITE32(arg->seqid->sequence->counter);", "\tencode_share_access(xdr, arg->open_flags);", " \tencode_share_access(xdr, arg->fmode);", "  \tRESERVE_SPACE(28);", "  \tWRITE64(arg->clientid);", "  \tWRITE32(16);", " \tWRITEMEM(\"open id:\", 8);", " \tWRITE64(arg->id);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void encode_frame(vpx_codec_ctx_t *codec,", "                         vpx_image_t *img,", "                         int frame_index,", "                         int flags,", "                         VpxVideoWriter *writer) {", " static int encode_frame(vpx_codec_ctx_t *codec,", "                         vpx_image_t *img,", "                         int frame_index,", "                         int flags,", "                         VpxVideoWriter *writer) {", "   int got_pkts = 0;", "    vpx_codec_iter_t iter = NULL;", "    const vpx_codec_cx_pkt_t *pkt = NULL;", "    const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,", "                                                flags, VPX_DL_GOOD_QUALITY);", "  if (res != VPX_CODEC_OK)", " ", "      die_codec(codec, \"Failed to encode frame\");", "  ", "    while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {", "     got_pkts = 1;", " ", "      if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {", "        const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;", "        if (!vpx_video_writer_write_frame(writer,", "                                         pkt->data.frame.buf,", "                                         pkt->data.frame.sz,", " ", "                                          pkt->data.frame.pts)) {", "          die_codec(codec, \"Failed to write compressed frame\");", "        }", "        printf(keyframe ? \"K\" : \".\");", "        fflush(stdout);", "      }", "    }", " ", "   return got_pkts;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["  long Chapters::Parse() {", "  IMkvReader* const pReader = m_pSegment->m_pReader;", " ", "  long long pos = m_start;  ", "  const long long stop = pos + m_size;  ", " ", "  while (pos < stop) {", "  long long id, size;", " ", "  long status = ParseElementHeader(pReader, pos, stop, id, size);", " ", "  if (status < 0)  ", "  return status;", " ", "  if (size == 0)  ", "  continue;", " ", "  if (id == 0x05B9) {  ", "       status = ParseEdition(pos, size);", " ", "  if (status < 0)  ", "  return status;", " ", "      }", "  ", "      pos += size;", "    assert(pos <= stop);", "     if (pos > stop)", "       return E_FILE_FORMAT_INVALID;", "    }", "  ", "  assert(pos == stop);", "   if (pos != stop)", "     return E_FILE_FORMAT_INVALID;", "    return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0]}
{"tokens": ["parse_exp(Node** np, PToken* tok, int term, UChar** src, UChar* end,", "ScanEnv* env, int group_head)", "{", "int r, len, group = 0;", "Node* qn;", "Node** tp;", "", "*np = NULL;", "if (tok->type == (enum TokenSyms )term)", "goto end_of_token;", "", "switch (tok->type) {", "case TK_ALT:", "case TK_EOT:", "end_of_token:", "*np = node_new_empty();", "CHECK_NULL_RETURN_MEMERR(*np);", "return tok->type;", "break;", "", "case TK_SUBEXP_OPEN:", "r = parse_bag(np, tok, TK_SUBEXP_CLOSE, src, end, env);", "if (r < 0) return r;", "if (r == 1) {", "if (group_head == 0)", "group = 1;", "else {", "Node* target = *np;", "*np = node_new_group(target);", "if (IS_NULL(*np)) {", "onig_node_free(target);", "return ONIGERR_MEMORY;", "}", "group = 2;", "}", "}", "else if (r == 2) {", "Node* target;", "OnigOptionType prev = env->options;", "", "env->options = BAG_(*np)->o.options;", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "r = parse_subexp(&target, tok, term, src, end, env, 0);", "env->options = prev;", "if (r < 0) {", "onig_node_free(target);", "return r;", "}", "NODE_BODY(*np) = target;", "return tok->type;", "}", "break;", "", "case TK_SUBEXP_CLOSE:", "if (! IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_UNMATCHED_CLOSE_SUBEXP))", "return ONIGERR_UNMATCHED_CLOSE_PARENTHESIS;", "", "if (tok->escaped) goto tk_raw_byte;", "else goto tk_byte;", "break;", "", "case TK_STRING:", "tk_byte:", "{", "*np = node_new_str(tok->backp, *src);", "CHECK_NULL_RETURN_MEMERR(*np);", "", "while (1) {", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "if (r != TK_STRING) break;", "", "r = onig_node_str_cat(*np, tok->backp, *src);", "if (r < 0) return r;", "}", "", "string_end:", "tp = np;", "goto repeat;", "}", "break;", "", "case TK_RAW_BYTE:", "tk_raw_byte:", "{", "*np = node_new_str_raw_char((UChar )tok->u.c);", "CHECK_NULL_RETURN_MEMERR(*np);", "len = 1;", "while (1) {", "if (len >= ONIGENC_MBC_MINLEN(env->enc)) {", "if (len == enclen(env->enc, STR_(*np)->s)) {", "r = fetch_token(tok, src, end, env);", "goto tk_raw_byte_end;", "}", "}", "", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "if (r != TK_RAW_BYTE)", "return ONIGERR_TOO_SHORT_MULTI_BYTE_STRING;", "", "r = node_str_cat_char(*np, (UChar )tok->u.c);", "if (r < 0) return r;", "", "len++;", "}", "", "tk_raw_byte_end:", "if (! ONIGENC_IS_VALID_MBC_STRING(env->enc, STR_(*np)->s, STR_(*np)->end))", "return ONIGERR_INVALID_WIDE_CHAR_VALUE;", "", "NODE_STRING_CLEAR_RAW(*np);", "goto string_end;", "}", "break;", "", "case TK_CODE_POINT:", "{", "UChar buf[ONIGENC_CODE_TO_MBC_MAXLEN];", "len = ONIGENC_CODE_TO_MBC(env->enc, tok->u.code, buf);", "if (len < 0) return len;", "#ifdef NUMBERED_CHAR_IS_NOT_CASE_AMBIG", "*np = node_new_str_raw(buf, buf + len);", "#else", "*np = node_new_str(buf, buf + len);", "#endif", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "break;", "", "case TK_QUOTE_OPEN:", "{", "OnigCodePoint end_op[2];", "UChar *qstart, *qend, *nextp;", "", "end_op[0] = (OnigCodePoint )MC_ESC(env->syntax);", "end_op[1] = (OnigCodePoint )'E';", "qstart = *src;", "qend = find_str_position(end_op, 2, qstart, end, &nextp, env->enc);", "if (IS_NULL(qend)) {", "nextp = qend = end;", "}", "*np = node_new_str(qstart, qend);", "CHECK_NULL_RETURN_MEMERR(*np);", "*src = nextp;", "}", "break;", "", "case TK_CHAR_TYPE:", "{", "switch (tok->u.prop.ctype) {", "case ONIGENC_CTYPE_WORD:", "*np = node_new_ctype(tok->u.prop.ctype, tok->u.prop.not, env->options);", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "", "case ONIGENC_CTYPE_SPACE:", "case ONIGENC_CTYPE_DIGIT:", "case ONIGENC_CTYPE_XDIGIT:", "{", "CClassNode* cc;", "", "*np = node_new_cclass();", "CHECK_NULL_RETURN_MEMERR(*np);", "cc = CCLASS_(*np);", "add_ctype_to_cc(cc, tok->u.prop.ctype, 0, env);", "if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);", "}", "break;", "", "default:", "return ONIGERR_PARSER_BUG;", "break;", "}", "}", "break;", "", "case TK_CHAR_PROPERTY:", "r = parse_char_property(np, tok, src, end, env);", "if (r != 0) return r;", "break;", "", "case TK_CC_OPEN:", "{", "CClassNode* cc;", "", "r = parse_char_class(np, tok, src, end, env);", "if (r != 0) return r;", "", "cc = CCLASS_(*np);", "if (IS_IGNORECASE(env->options)) {", "IApplyCaseFoldArg iarg;", "", "iarg.env      = env;", "iarg.cc       = cc;", "iarg.alt_root = NULL_NODE;", "iarg.ptail    = &(iarg.alt_root);", "", "r = ONIGENC_APPLY_ALL_CASE_FOLD(env->enc, env->case_fold_flag,", "i_apply_case_fold, &iarg);", "if (r != 0) {", "onig_node_free(iarg.alt_root);", "return r;", "}", "if (IS_NOT_NULL(iarg.alt_root)) {", "Node* work = onig_node_new_alt(*np, iarg.alt_root);", "if (IS_NULL(work)) {", "onig_node_free(iarg.alt_root);", "return ONIGERR_MEMORY;", "}", "*np = work;", "}", "}", "}", "break;", "", "case TK_ANYCHAR:", "*np = node_new_anychar();", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "", "case TK_ANYCHAR_ANYTIME:", "*np = node_new_anychar();", "CHECK_NULL_RETURN_MEMERR(*np);", "qn = node_new_quantifier(0, INFINITE_REPEAT, 0);", "CHECK_NULL_RETURN_MEMERR(qn);", "NODE_BODY(qn) = *np;", "*np = qn;", "break;", "", "case TK_BACKREF:", "len = tok->u.backref.num;", "*np = node_new_backref(len,", "(len > 1 ? tok->u.backref.refs : &(tok->u.backref.ref1)),", "tok->u.backref.by_name,", "#ifdef USE_BACKREF_WITH_LEVEL", "tok->u.backref.exist_level,", "tok->u.backref.level,", "#endif", "env);", "CHECK_NULL_RETURN_MEMERR(*np);", "break;", "", "#ifdef USE_CALL", "case TK_CALL:", "{", "int gnum = tok->u.call.gnum;", "", "*np = node_new_call(tok->u.call.name, tok->u.call.name_end,", "gnum, tok->u.call.by_number);", "CHECK_NULL_RETURN_MEMERR(*np);", "env->num_call++;", "if (tok->u.call.by_number != 0 && gnum == 0) {", "env->has_call_zero = 1;", "}", "}", "break;", "#endif", "", "case TK_ANCHOR:", "{", "int ascii_mode =", "IS_WORD_ASCII(env->options) && IS_WORD_ANCHOR_TYPE(tok->u.anchor) ? 1 : 0;", "*np = onig_node_new_anchor(tok->u.anchor, ascii_mode);", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "break;", "", "case TK_REPEAT:", "case TK_INTERVAL:", "if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INDEP_REPEAT_OPS)) {", "if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_CONTEXT_INVALID_REPEAT_OPS))", "return ONIGERR_TARGET_OF_REPEAT_OPERATOR_NOT_SPECIFIED;", "else {", "*np = node_new_empty();", "CHECK_NULL_RETURN_MEMERR(*np);", "}", "}", "else {", "goto tk_byte;", "}", "break;", "", "case TK_KEEP:", "r = node_new_keep(np, env);", "if (r < 0) return r;", "break;", "", "case TK_GENERAL_NEWLINE:", "r = node_new_general_newline(np, env);", "if (r < 0) return r;", "break;", "", "case TK_NO_NEWLINE:", "r = node_new_no_newline(np, env);", "if (r < 0) return r;", "break;", "", "case TK_TRUE_ANYCHAR:", "r = node_new_true_anychar(np, env);", "if (r < 0) return r;", "break;", "", "case TK_TEXT_SEGMENT:", "r = make_text_segment(np, env);", "if (r < 0) return r;", "break;", "", "default:", "return ONIGERR_PARSER_BUG;", "break;", "}", "", "{", "tp = np;", "", "re_entry:", "r = fetch_token(tok, src, end, env);", "if (r < 0) return r;", "", "repeat:", "if (r == TK_REPEAT || r == TK_INTERVAL) {", "Node* target;", "", "if (is_invalid_quantifier_target(*tp))", "return ONIGERR_TARGET_OF_REPEAT_OPERATOR_INVALID;", "", "qn = node_new_quantifier(tok->u.repeat.lower, tok->u.repeat.upper,", "r == TK_INTERVAL);", "CHECK_NULL_RETURN_MEMERR(qn);", "QUANT_(qn)->greedy = tok->u.repeat.greedy;", "if (group == 2) {", "target = node_drop_group(*tp);", "*tp = NULL_NODE;", "}", "else {", "target = *tp;", "}", "r = set_quantifier(qn, target, group, env);", "if (r < 0) {", "onig_node_free(qn);", "return r;", "}", "", "if (tok->u.repeat.possessive != 0) {", "Node* en;", "en = node_new_bag(BAG_STOP_BACKTRACK);", "if (IS_NULL(en)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "NODE_BODY(en) = qn;", "qn = en;", "}", "", "if (r == 0) {", "*tp = qn;", "}", "else if (r == 1) {", "onig_node_free(qn);", "*tp = target;", "}", "else if (r == 2) {", "Node *tmp;", "", "*tp = node_new_list(*tp, NULL);", "if (IS_NULL(*tp)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "tmp = NODE_CDR(*tp) = node_new_list(qn, NULL);", "if (IS_NULL(tmp)) {", "onig_node_free(qn);", "return ONIGERR_MEMORY;", "}", "tp = &(NODE_CAR(tmp));", "}", "group = 0;", "goto re_entry;", "}", "}", "", "return r;", "}"], "ner_tags": [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" PrintMsg_Print_Params::PrintMsg_Print_Params()", "     : page_size(),", "       content_size(),", "       printable_area(),", "       margin_top(0),", "       margin_left(0),", "       dpi(0),", "       scale_factor(1.0f),", "       rasterize_pdf(false),", "       document_cookie(0),", "       selection_only(false),", "       supports_alpha_blend(false),", "       preview_ui_id(-1),", "       preview_request_id(0),", "       is_first_request(false),", "       print_scaling_option(blink::kWebPrintScalingOptionSourceSize),", "       print_to_pdf(false),", "        display_header_footer(false),", "        title(),", "        url(),", "       header_template(),", "       footer_template(),", "        should_print_backgrounds(false),", "        printed_doc_type(printing::SkiaDocumentType::PDF) {}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" static Image *ReadUYVYImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   Image", "     *image;", " ", "   MagickBooleanType", "     status;", " ", "   register ssize_t", "     x;", " ", "   register PixelPacket", "     *q;", " ", "   ssize_t", "     y;", " ", "   unsigned char", "     u,", "     v,", "     y1,", "     y2;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickSignature);", "   image=AcquireImage(image_info);", "   if ((image->columns == 0) || (image->rows == 0))", "     ThrowReaderException(OptionError,\"MustSpecifyImageSize\");", "   if ((image->columns % 2) != 0)", "     image->columns++;", "   (void) CopyMagickString(image->filename,image_info->filename,MaxTextExtent);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     return((Image *) NULL);", "   if (DiscardBlobBytes(image,image->offset) == MagickFalse)", "     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "       image->filename);", "   image->depth=8;", "   if (image_info->ping != MagickFalse)", "     {", "        (void) CloseBlob(image);", "        return(GetFirstImageInList(image));", "      }", "   status=SetImageExtent(image,image->columns,image->rows);", "   if (status == MagickFalse)", "     {", "       InheritException(exception,&image->exception);", "       return(DestroyImageList(image));", "     }", "     ", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);", "     if (q == (PixelPacket *) NULL)", "       break;", "     for (x=0; x < (ssize_t) (image->columns >> 1); x++)", "     {", "       u=(unsigned char) ReadBlobByte(image);", "       y1=(unsigned char) ReadBlobByte(image);", "       v=(unsigned char) ReadBlobByte(image);", "       y2=(unsigned char) ReadBlobByte(image);", "       SetPixelRed(q,ScaleCharToQuantum(y1));", "       SetPixelGreen(q,ScaleCharToQuantum(u));", "       SetPixelBlue(q,ScaleCharToQuantum(v));", "       q++;", "       SetPixelRed(q,ScaleCharToQuantum(y2));", "       SetPixelGreen(q,ScaleCharToQuantum(u));", "       SetPixelBlue(q,ScaleCharToQuantum(v));", "       q++;", "     }", "     if (SyncAuthenticPixels(image,exception) == MagickFalse)", "       break;", "     status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,", "       image->rows);", "     if (status == MagickFalse)", "       break;", "   }", "   SetImageColorspace(image,YCbCrColorspace);", "   if (EOFBlob(image) != MagickFalse)", "     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",", "       image->filename);", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)", "{", "UINT16 AvLen;", "", "Data_Read_UINT16(&pAvPair->AvLen, AvLen);", "", "return AvLen;", "}"], "ner_tags": [0, 0, 0, 0, 1, 0, 1, 0]}
{"tokens": [" long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,", "                                  long long size_, char*& str) {", " long UnserializeString(IMkvReader* pReader, long long pos, long long size,", "                        char*& str) {", "    delete[] str;", "    str = NULL;", "  ", "  if (size_ >= LONG_MAX)   ", "   if (size >= LONG_MAX || size < 0)", "      return E_FILE_FORMAT_INVALID;", "  ", "  const long size = static_cast<long>(size_);", "    ", "   const long required_size = static_cast<long>(size) + 1;", "  ", "  str = new (std::nothrow) char[size + 1];", "   str = SafeArrayAlloc<char>(1, required_size);", "    if (str == NULL)", "    return -1;", "     return E_FILE_FORMAT_INVALID;", "  ", "    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);", "  ", "  const long status = pReader->Read(pos, size, buf);", " ", "  if (status) {", "  delete[] str;", "     str = NULL;", " ", " ", "      return status;", "    }", "  ", "  str[size] = '\\0';", "  return 0;   ", "   str[required_size - 1] = '\\0';", "   return 0;", "  }"], "ner_tags": [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0]}
{"tokens": [" void exit_sem(struct task_struct *tsk)", " {", " \tstruct sem_undo_list *ulp;", " ", " \tulp = tsk->sysvsem.undo_list;", " \tif (!ulp)", " \t\treturn;", " \ttsk->sysvsem.undo_list = NULL;", " ", " \tif (!atomic_dec_and_test(&ulp->refcnt))", " \t\treturn;", " ", " \tfor (;;) {", "  \t\tstruct sem_array *sma;", "  \t\tstruct sem_undo *un;", "  \t\tstruct list_head tasks;", "\t\tint semid;", "\t\tint i;", " \t\tint semid, i;", "  ", "  \t\trcu_read_lock();", "  \t\tun = list_entry_rcu(ulp->list_proc.next,", " \t\t\t\t    struct sem_undo, list_proc);", " \t\tif (&un->list_proc == &ulp->list_proc)", "  \t\t\tsemid = -1;", "  \t\t else", "  \t\t\tsemid = un->semid;", "\t\trcu_read_unlock();", "  ", "\t\tif (semid == -1)", " \t\tif (semid == -1) {", " \t\t\trcu_read_unlock();", "  \t\t\tbreak;", " \t\t}", "  ", "\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);", " \t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);", "  \t\t ", "\t\tif (IS_ERR(sma))", " \t\tif (IS_ERR(sma)) {", " \t\t\trcu_read_unlock();", "  \t\t\tcontinue;", " \t\t}", "  ", " \t\tsem_lock(sma, NULL, -1);", "  \t\tun = __lookup_undo(ulp, semid);", "  \t\tif (un == NULL) {", "  \t\t\t ", "\t\t\tsem_unlock(sma);", " \t\t\tsem_unlock(sma, -1);", "  \t\t\tcontinue;", "  \t\t}", "  ", " \t\t ", " \t\tassert_spin_locked(&sma->sem_perm.lock);", " \t\tlist_del(&un->list_id);", " ", " \t\tspin_lock(&ulp->lock);", " \t\tlist_del_rcu(&un->list_proc);", " \t\tspin_unlock(&ulp->lock);", " ", " \t\t ", " \t\tfor (i = 0; i < sma->sem_nsems; i++) {", " \t\t\tstruct sem * semaphore = &sma->sem_base[i];", " \t\t\tif (un->semadj[i]) {", " \t\t\t\tsemaphore->semval += un->semadj[i];", " \t\t\t\t ", " \t\t\t\tif (semaphore->semval < 0)", " \t\t\t\t\tsemaphore->semval = 0;", " \t\t\t\tif (semaphore->semval > SEMVMX)", " \t\t\t\t\tsemaphore->semval = SEMVMX;", " \t\t\t\tsemaphore->sempid = task_tgid_vnr(current);", " \t\t\t}", " \t\t}", "  \t\t ", "  \t\tINIT_LIST_HEAD(&tasks);", "  \t\tdo_smart_update(sma, NULL, 0, 1, &tasks);", "\t\tsem_unlock(sma);", " \t\tsem_unlock(sma, -1);", "  \t\twake_up_sem_queue_do(&tasks);", "  ", "  \t\tkfree_rcu(un, rcu);", " \t}", " \tkfree(ulp);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,", "                                                        String scriptClassName,", "                                                        const char* source,", "                                                        size_t size) {", "   v8::Isolate* isolate = scriptState->isolate();", "   v8::TryCatch block(isolate);", "   String sourceString(source, size);", "   String fileName = scriptClassName + \".js\";", "  ", "    v8::Local<v8::Context> context = scriptState->context();", "    v8::Local<v8::Object> global = context->Global();", "  v8::Local<v8::Value> privateScriptController =", "      global->Get(context, v8String(isolate, \"privateScriptController\"))", "          .ToLocalChecked();", "  RELEASE_ASSERT(privateScriptController->IsUndefined() ||", "                 privateScriptController->IsObject());", "  if (privateScriptController->IsObject()) {", "   v8::Local<v8::String> key = v8String(isolate, \"privateScriptController\");", " ", "   if (global->HasOwnProperty(context, key).ToChecked()) {", "     v8::Local<v8::Value> privateScriptController =", "         global->Get(context, key).ToLocalChecked();", "     CHECK(privateScriptController->IsObject());", "      v8::Local<v8::Object> privateScriptControllerObject =", "          privateScriptController.As<v8::Object>();", "      v8::Local<v8::Value> importFunctionValue =", "         privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))", "             .ToLocalChecked();", "     if (importFunctionValue->IsUndefined()) {", "       v8::Local<v8::Function> function;", "       if (!v8::FunctionTemplate::New(isolate, importFunction)", "                ->GetFunction(context)", "                .ToLocal(&function) ||", "           !v8CallBoolean(privateScriptControllerObject->Set(", "               context, v8String(isolate, \"import\"), function))) {", "         dumpV8Message(context, block.Message());", "         LOG(FATAL)", "             << \"Private script error: Setting import function failed. (Class \"", "                \"name = \"", "             << scriptClassName.utf8().data() << \")\";", "       }", "     }", "   }", " ", "   v8::Local<v8::Script> script;", "   if (!v8Call(V8ScriptRunner::compileScript(", "                   v8String(isolate, sourceString), fileName, String(),", "                   TextPosition::minimumPosition(), isolate, nullptr, nullptr,", "                   nullptr, NotSharableCrossOrigin),", "               script, block)) {", "     dumpV8Message(context, block.Message());", "     LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"", "                << scriptClassName.utf8().data() << \")\";", "   }", " ", "   v8::Local<v8::Value> result;", "   if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),", "               result, block)) {", "     dumpV8Message(context, block.Message());", "     LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"", "                << scriptClassName.utf8().data() << \")\";", "   }", "   return result;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ec_mul_consttime(const EC_GROUP *group, EC_POINT *r,", "                             const BIGNUM *scalar, const EC_POINT *point,", "                             BN_CTX *ctx)", " {", "     int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;", "     EC_POINT *s = NULL;", "     BIGNUM *k = NULL;", "     BIGNUM *lambda = NULL;", "     BIGNUM *cardinality = NULL;", "     BN_CTX *new_ctx = NULL;", "     int ret = 0;", " ", "     if (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)", "         return 0;", " ", "     BN_CTX_start(ctx);", " ", "     s = EC_POINT_new(group);", "     if (s == NULL)", "         goto err;", " ", "     if (point == NULL) {", "         if (!EC_POINT_copy(s, group->generator))", "             goto err;", "     } else {", "         if (!EC_POINT_copy(s, point))", "             goto err;", "     }", " ", "     EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);", " ", "     cardinality = BN_CTX_get(ctx);", "     lambda = BN_CTX_get(ctx);", "     k = BN_CTX_get(ctx);", "     if (k == NULL || !BN_mul(cardinality, group->order, group->cofactor, ctx))", "         goto err;", " ", "      ", "      cardinality_bits = BN_num_bits(cardinality);", "      group_top = bn_get_top(cardinality);", "    if ((bn_wexpand(k, group_top + 1) == NULL)", "        || (bn_wexpand(lambda, group_top + 1) == NULL))", "     if ((bn_wexpand(k, group_top + 2) == NULL)", "         || (bn_wexpand(lambda, group_top + 2) == NULL)) {", "          goto err;", "  ", "      if (!BN_copy(k, scalar))", "         goto err;", " ", "     BN_set_flags(k, BN_FLG_CONSTTIME);", " ", "     if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {", "          ", "         if (!BN_nnmod(k, k, cardinality, ctx))", "             goto err;", "     }", " ", "     if (!BN_add(lambda, k, cardinality))", "         goto err;", "     BN_set_flags(lambda, BN_FLG_CONSTTIME);", "     if (!BN_add(k, lambda, cardinality))", "         goto err;", "      ", "      kbit = BN_is_bit_set(lambda, cardinality_bits);", "    BN_consttime_swap(kbit, k, lambda, group_top + 1);", "     BN_consttime_swap(kbit, k, lambda, group_top + 2);", "  ", "      group_top = bn_get_top(group->field);", "      if ((bn_wexpand(s->X, group_top) == NULL)", "         || (bn_wexpand(s->Y, group_top) == NULL)", "         || (bn_wexpand(s->Z, group_top) == NULL)", "         || (bn_wexpand(r->X, group_top) == NULL)", "         || (bn_wexpand(r->Y, group_top) == NULL)", "         || (bn_wexpand(r->Z, group_top) == NULL))", "         goto err;", " ", "      ", "     if (!ec_point_blind_coordinates(group, s, ctx))", "         goto err;", " ", "      ", "     if (!EC_POINT_copy(r, s))", "         goto err;", " ", "     EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);", " ", "     if (!EC_POINT_dbl(group, s, s, ctx))", "         goto err;", " ", "     pbit = 0;", " ", " #define EC_POINT_CSWAP(c, a, b, w, t) do {         \\", "         BN_consttime_swap(c, (a)->X, (b)->X, w);   \\", "         BN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\", "         BN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\", "         t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\", "         (a)->Z_is_one ^= (t);                      \\", "         (b)->Z_is_one ^= (t);                      \\", " } while(0)", " ", "      ", " ", "     for (i = cardinality_bits - 1; i >= 0; i--) {", "         kbit = BN_is_bit_set(k, i) ^ pbit;", "         EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);", "         if (!EC_POINT_add(group, s, r, s, ctx))", "             goto err;", "         if (!EC_POINT_dbl(group, r, r, ctx))", "             goto err;", "          ", "         pbit ^= kbit;", "     }", "      ", "     EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);", " #undef EC_POINT_CSWAP", " ", "     ret = 1;", " ", "  err:", "     EC_POINT_free(s);", "     BN_CTX_end(ctx);", "     BN_CTX_free(new_ctx);", " ", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void AutofillManager::OnQueryFormFieldAutofillImpl(", "     int query_id,", "     const FormData& form,", "     const FormFieldData& field,", "     const gfx::RectF& transformed_box,", "     bool autoselect_first_suggestion) {", "   external_delegate_->OnQuery(query_id, form, field, transformed_box);", " ", "   std::vector<Suggestion> suggestions;", "   SuggestionsContext context;", "   GetAvailableSuggestions(form, field, &suggestions, &context);", " ", "   if (context.is_autofill_available) {", "     switch (context.suppress_reason) {", "       case SuppressReason::kNotSuppressed:", "         break;", " ", "       case SuppressReason::kCreditCardsAblation:", "         enable_ablation_logging_ = true;", "         autocomplete_history_manager_->CancelPendingQuery();", "         external_delegate_->OnSuggestionsReturned(query_id, suggestions,", "                                                   autoselect_first_suggestion);", "         return;", " ", "       case SuppressReason::kAutocompleteOff:", "         return;", "     }", " ", "     if (!suggestions.empty()) {", "       if (context.is_filling_credit_card) {", "         AutofillMetrics::LogIsQueriedCreditCardFormSecure(", "             context.is_context_secure);", "       }", " ", "      if (!has_logged_address_suggestions_count_ &&", "          !context.section_has_autofilled_field) {", "       if (!has_logged_address_suggestions_count_) {", "          AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());", "          has_logged_address_suggestions_count_ = true;", "        }", "     }", "   }", " ", "   if (suggestions.empty() && !ShouldShowCreditCardSigninPromo(form, field) &&", "       field.should_autocomplete &&", "       !(context.focused_field &&", "         (IsCreditCardExpirationType(", "              context.focused_field->Type().GetStorableType()) ||", "          context.focused_field->Type().html_type() == HTML_TYPE_UNRECOGNIZED ||", "          context.focused_field->Type().GetStorableType() ==", "              CREDIT_CARD_NUMBER ||", "          context.focused_field->Type().GetStorableType() ==", "              CREDIT_CARD_VERIFICATION_CODE))) {", "     autocomplete_history_manager_->OnGetAutocompleteSuggestions(", "         query_id, field.name, field.value, field.form_control_type);", "     return;", "   }", " ", "   autocomplete_history_manager_->CancelPendingQuery();", "   external_delegate_->OnSuggestionsReturned(query_id, suggestions,", "                                             autoselect_first_suggestion,", "                                             context.is_all_server_suggestions);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {", "if (t.shape() == TensorShape({})) {", "if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||", "(t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {", "*out = PartialTensorShape();", "return OkStatus();", "}", "return errors::InvalidArgument(", "\"The only valid scalar shape tensor is the fully unknown shape \"", "\"specified as -1.\");", "}", "if (t.dtype() == DT_INT32) {", "return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),", "t.NumElements(), out);", "} else if (t.dtype() == DT_INT64) {", "return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),", "t.NumElements(), out);", "}", "return errors::InvalidArgument(", "\"Expected an int32 or int64 shape tensor; found \",", "DataTypeString(t.dtype()));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" sd2_parse_rsrc_fork (SF_PRIVATE *psf)", " {\tSD2_RSRC rsrc ;", " \tint k, marker, error = 0 ;", " ", " \tpsf_use_rsrc (psf, SF_TRUE) ;", " ", " \tmemset (&rsrc, 0, sizeof (rsrc)) ;", " ", " \trsrc.rsrc_len = psf_get_filelen (psf) ;", " \tpsf_log_printf (psf, \"Resource length : %d (0x%04X)\\n\", rsrc.rsrc_len, rsrc.rsrc_len) ;", " ", " \tif (rsrc.rsrc_len > SIGNED_SIZEOF (psf->header))", " \t{\trsrc.rsrc_data = calloc (1, rsrc.rsrc_len) ;", " \t\trsrc.need_to_free_rsrc_data = SF_TRUE ;", " \t\t}", " \telse", " \t{", " \t\trsrc.rsrc_data = psf->header ;", " \t\trsrc.need_to_free_rsrc_data = SF_FALSE ;", " \t\t} ;", " ", " \t ", " \tpsf_fread (rsrc.rsrc_data, rsrc.rsrc_len, 1, psf) ;", " ", " \t ", " \tpsf->headindex = psf->headend = rsrc.rsrc_len ;", " ", " \trsrc.data_offset = read_rsrc_int (&rsrc, 0) ;", " \trsrc.map_offset = read_rsrc_int (&rsrc, 4) ;", " \trsrc.data_length = read_rsrc_int (&rsrc, 8) ;", " \trsrc.map_length = read_rsrc_int (&rsrc, 12) ;", " ", " \tif (rsrc.data_offset == 0x51607 && rsrc.map_offset == 0x20000)", " \t{\tpsf_log_printf (psf, \"Trying offset of 0x52 bytes.\\n\") ;", " \t\trsrc.data_offset = read_rsrc_int (&rsrc, 0x52 + 0) + 0x52 ;", " \t\trsrc.map_offset = read_rsrc_int (&rsrc, 0x52 + 4) + 0x52 ;", " \t\trsrc.data_length = read_rsrc_int (&rsrc, 0x52 + 8) ;", " \t\trsrc.map_length = read_rsrc_int (&rsrc, 0x52 + 12) ;", " \t\t} ;", " ", " \tpsf_log_printf (psf, \"  data offset : 0x%04X\\n  map  offset : 0x%04X\\n\"", " \t\t\t\t\"  data length : 0x%04X\\n  map  length : 0x%04X\\n\",", " \t\t\t\trsrc.data_offset, rsrc.map_offset, rsrc.data_length, rsrc.map_length) ;", " ", " \tif (rsrc.data_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.data_offset (%d, 0x%x) > len\\n\", rsrc.data_offset, rsrc.data_offset) ;", " \t\terror = SFE_SD2_BAD_DATA_OFFSET ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \tif (rsrc.map_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.map_offset > len\\n\") ;", " \t\terror = SFE_SD2_BAD_MAP_OFFSET ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \tif (rsrc.data_length > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.data_length > len\\n\") ;", " \t\terror = SFE_SD2_BAD_DATA_LENGTH ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \tif (rsrc.map_length > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : rsrc.map_length > len\\n\") ;", " \t\terror = SFE_SD2_BAD_MAP_LENGTH ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \tif (rsrc.data_offset + rsrc.data_length != rsrc.map_offset || rsrc.map_offset + rsrc.map_length != rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Error : This does not look like a MacOSX resource fork.\\n\") ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \tif (rsrc.map_offset + 28 >= rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad map offset (%d + 28 > %d).\\n\", rsrc.map_offset, rsrc.rsrc_len) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \trsrc.string_offset = rsrc.map_offset + read_rsrc_short (&rsrc, rsrc.map_offset + 26) ;", " \tif (rsrc.string_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad string offset (%d).\\n\", rsrc.string_offset) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", "  ", "  \trsrc.type_offset = rsrc.map_offset + 30 ;", "  ", " \tif (rsrc.map_offset + 28 > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad map offset.\\n\") ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", "  \trsrc.type_count = read_rsrc_short (&rsrc, rsrc.map_offset + 28) + 1 ;", "  \tif (rsrc.type_count < 1)", "  \t{\tpsf_log_printf (psf, \"Bad type count.\\n\") ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", " ", " \trsrc.item_offset = rsrc.type_offset + rsrc.type_count * 8 ;", " \tif (rsrc.item_offset < 0 || rsrc.item_offset > rsrc.rsrc_len)", " \t{\tpsf_log_printf (psf, \"Bad item offset (%d).\\n\", rsrc.item_offset) ;", " \t\terror = SFE_SD2_BAD_RSRC ;", " \t\tgoto parse_rsrc_fork_cleanup ;", " \t\t} ;", "  ", "  \trsrc.str_index = -1 ;", "  \tfor (k = 0 ; k < rsrc.type_count ; k ++)", "\t{\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;", " \t{\tif (rsrc.type_offset + k * 8 > rsrc.rsrc_len)", " \t\t{\tpsf_log_printf (psf, \"Bad rsrc marker.\\n\") ;", " \t\t\tgoto parse_rsrc_fork_cleanup ;", " \t\t\t} ;", " ", " \t\tmarker = read_rsrc_marker (&rsrc, rsrc.type_offset + k * 8) ;", "  ", "  \t\tif (marker == STR_MARKER)", "  \t\t{\trsrc.str_index = k ;", " \t\t\trsrc.str_count = read_rsrc_short (&rsrc, rsrc.type_offset + k * 8 + 4) + 1 ;", " \t\t\terror = parse_str_rsrc (psf, &rsrc) ;", " \t\t\tgoto parse_rsrc_fork_cleanup ;", " \t\t\t} ;", " \t\t} ;", " ", " \tpsf_log_printf (psf, \"No 'STR ' resource.\\n\") ;", " \terror = SFE_SD2_BAD_RSRC ;", " ", " parse_rsrc_fork_cleanup :", " ", " \tpsf_use_rsrc (psf, SF_FALSE) ;", " ", " \tif (rsrc.need_to_free_rsrc_data)", " \t\tfree (rsrc.rsrc_data) ;", " ", " \treturn error ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" media::mojom::VideoFrameDataPtr MakeVideoFrameData(", "     const scoped_refptr<media::VideoFrame>& input) {", "   if (input->metadata()->IsTrue(media::VideoFrameMetadata::END_OF_STREAM)) {", "     return media::mojom::VideoFrameData::NewEosData(", "         media::mojom::EosVideoFrameData::New());", "   }", " ", "   if (input->storage_type() == media::VideoFrame::STORAGE_MOJO_SHARED_BUFFER) {", "      media::MojoSharedBufferVideoFrame* mojo_frame =", "          static_cast<media::MojoSharedBufferVideoFrame*>(input.get());", "  ", "      ", "      ", "      ", "      mojo::ScopedSharedBufferHandle dup = mojo_frame->Handle().Clone(", "        mojo::SharedBufferHandle::AccessMode::READ_ONLY);", "         mojo::SharedBufferHandle::AccessMode::READ_WRITE);", "      DCHECK(dup.is_valid());", "  ", "      return media::mojom::VideoFrameData::NewSharedBufferData(", "         media::mojom::SharedBufferVideoFrameData::New(", "             std::move(dup), mojo_frame->MappedSize(),", "             mojo_frame->stride(media::VideoFrame::kYPlane),", "             mojo_frame->stride(media::VideoFrame::kUPlane),", "             mojo_frame->stride(media::VideoFrame::kVPlane),", "             mojo_frame->PlaneOffset(media::VideoFrame::kYPlane),", "             mojo_frame->PlaneOffset(media::VideoFrame::kUPlane),", "             mojo_frame->PlaneOffset(media::VideoFrame::kVPlane)));", "   }", " ", "   if (input->HasTextures()) {", "     std::vector<gpu::MailboxHolder> mailbox_holder(", "         media::VideoFrame::kMaxPlanes);", "     size_t num_planes = media::VideoFrame::NumPlanes(input->format());", "     for (size_t i = 0; i < num_planes; i++)", "       mailbox_holder[i] = input->mailbox_holder(i);", "     return media::mojom::VideoFrameData::NewMailboxData(", "         media::mojom::MailboxVideoFrameData::New(std::move(mailbox_holder)));", "   }", " ", "   NOTREACHED() << \"Unsupported VideoFrame conversion\";", "   return nullptr;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void uipc_check_interrupt_locked(void)", " {", "  if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))", " ", "      {", "          char sig_recv = 0;", "        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);", "         TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));", "      }", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", "   Image *image, *image2=NULL,", "    *rotated_image;", "   register Quantum *q;", " ", "   unsigned int status;", "   MATHeader MATLAB_HDR;", "   size_t size;", "   size_t CellType;", "   QuantumInfo *quantum_info;", "   ImageInfo *clone_info;", "   int i;", "   ssize_t ldblk;", "   unsigned char *BImgBuff = NULL;", "   double MinVal, MaxVal;", "   unsigned z, z2;", "   unsigned Frames;", "   int logging;", "   int sample_size;", "   MagickOffsetType filepos=0x80;", "   BlobInfo *blob;", "   size_t one;", " ", "   unsigned int (*ReadBlobXXXLong)(Image *image);", "   unsigned short (*ReadBlobXXXShort)(Image *image);", "   void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);", "   void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);", " ", " ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");", " ", "    ", "   image = AcquireImage(image_info,exception);", " ", "   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   clone_info=CloneImageInfo(image_info);", "   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)", "     {", "       image2=ReadMATImageV4(image_info,image,exception);", "       if (image2  == NULL)", "         goto MATLAB_KO;", "       image=image2;", "       goto END_OF_READING;", "     }", "   MATLAB_HDR.Version = ReadBlobLSBShort(image);", "   if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", " ", "   if (logging)", "     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",", "       MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);", "   if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))", "   {", "     ReadBlobXXXLong = ReadBlobLSBLong;", "     ReadBlobXXXShort = ReadBlobLSBShort;", "     ReadBlobDoublesXXX = ReadBlobDoublesLSB;", "     ReadBlobFloatsXXX = ReadBlobFloatsLSB;", "     image->endian = LSBEndian;", "   }", "   else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))", "   {", "     ReadBlobXXXLong = ReadBlobMSBLong;", "     ReadBlobXXXShort = ReadBlobMSBShort;", "     ReadBlobDoublesXXX = ReadBlobDoublesMSB;", "     ReadBlobFloatsXXX = ReadBlobFloatsMSB;", "     image->endian = MSBEndian;", "   }", "   else", "     goto MATLAB_KO;     ", " ", "   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))", " MATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", " ", "   filepos = TellBlob(image);", "   while(!EOFBlob(image))  ", "   {", "     Frames = 1;", "     (void) SeekBlob(image,filepos,SEEK_SET);", "      ", " ", "     MATLAB_HDR.DataType = ReadBlobXXXLong(image);", "     if(EOFBlob(image)) break;", "     MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);", "     if(EOFBlob(image)) break;", "     filepos += MATLAB_HDR.ObjectSize + 4 + 4;", " ", "     image2 = image;", " #if defined(MAGICKCORE_ZLIB_DELEGATE)", "     if(MATLAB_HDR.DataType == miCOMPRESSED)", "     {", "       image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);", "       if(image2==NULL) continue;", "       MATLAB_HDR.DataType = ReadBlobXXXLong(image2);  ", "     }", " #endif", " ", "     if(MATLAB_HDR.DataType!=miMATRIX) continue;   ", " ", "     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);", "     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);", " ", "     MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);", "     MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;", "     MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;", " ", "     MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);", "     if(image!=image2)", "       MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);   ", "     MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);", "     MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);", "     MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);", "     MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);", " ", " ", "     switch(MATLAB_HDR.DimFlag)", "     {", "       case  8: z2=z=1; break;       ", "       case 12: z2=z = ReadBlobXXXLong(image2);   ", "            (void) ReadBlobXXXLong(image2);", "          if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");", "          break;", "       case 16: z2=z = ReadBlobXXXLong(image2);   ", "          if(z!=3 && z!=1)", "             ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");", "          Frames = ReadBlobXXXLong(image2);", "          if (Frames == 0)", "            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "          break;", "       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");", "     }", " ", "     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);", "     MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);", " ", "     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);", "     if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&", "         MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&     ", "         MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&     ", "         MATLAB_HDR.StructureClass != mxINT8_CLASS &&", "         MATLAB_HDR.StructureClass != mxUINT8_CLASS &&     ", "         MATLAB_HDR.StructureClass != mxINT16_CLASS &&", "         MATLAB_HDR.StructureClass != mxUINT16_CLASS &&     ", "         MATLAB_HDR.StructureClass != mxINT32_CLASS &&", "         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&     ", "         MATLAB_HDR.StructureClass != mxINT64_CLASS &&", "         MATLAB_HDR.StructureClass != mxUINT64_CLASS)     ", "       ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");", " ", "     switch (MATLAB_HDR.NameFlag)", "     {", "       case 0:", "         size = ReadBlobXXXLong(image2);   ", "         size = 4 * (ssize_t) ((size + 3 + 1) / 4);", "         (void) SeekBlob(image2, size, SEEK_CUR);", "         break;", "       case 1:", "       case 2:", "       case 3:", "       case 4:", "         (void) ReadBlob(image2, 4, (unsigned char *) &size);  ", "         break;", "       default:", "         goto MATLAB_KO;", "     }", " ", "     CellType = ReadBlobXXXLong(image2);     ", "     if (logging)", "       (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "         \"MATLAB_HDR.CellType: %.20g\",(double) CellType);", " ", "     (void) ReadBlob(image2, 4, (unsigned char *) &size);      ", " ", "     NEXT_FRAME:", "     switch (CellType)", "     {", "       case miINT8:", "       case miUINT8:", "         sample_size = 8;", "         if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)", "           image->depth = 1;", "         else", "           image->depth = 8;          ", "         ldblk = (ssize_t) MATLAB_HDR.SizeX;", "         break;", "       case miINT16:", "       case miUINT16:", "         sample_size = 16;", "         image->depth = 16;         ", "         ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);", "         break;", "       case miINT32:", "       case miUINT32:", "         sample_size = 32;", "         image->depth = 32;         ", "         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);", "         break;", "       case miINT64:", "       case miUINT64:", "         sample_size = 64;", "         image->depth = 64;         ", "         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);", "         break;", "       case miSINGLE:", "         sample_size = 32;", "         image->depth = 32;         ", "         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");", "         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)", "   {               ", "   }", "         ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);", "         break;", "       case miDOUBLE:", "         sample_size = 64;", "         image->depth = 64;         ", "         (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");", " DisableMSCWarning(4127)", "         if (sizeof(double) != 8)", " RestoreMSCWarning", "           ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");", "         if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)", "   {                          ", "   }", "         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);", "         break;", "       default:", "         ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");", "     }", "     (void) sample_size;", "     image->columns = MATLAB_HDR.SizeX;", "     image->rows = MATLAB_HDR.SizeY;", "     quantum_info=AcquireQuantumInfo(clone_info,image);", "     if (quantum_info == (QuantumInfo *) NULL)", "       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     one=1;", "     image->colors = one << image->depth;", "     if (image->columns == 0 || image->rows == 0)", "       goto MATLAB_KO;", "      ", "     if ((MATLAB_HDR.DimFlag == 8) &&", "         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))", "       {", "         image->type=GrayscaleType;", "         SetImageColorspace(image,GRAYColorspace,exception);", "       }", " ", " ", "      ", "     if (image_info->ping)", "     {", "       size_t temp = image->columns;", "       image->columns = image->rows;", "       image->rows = temp;", "       goto done_reading;  ", "     }", "     status=SetImageExtent(image,image->columns,image->rows,exception);", "     if (status == MagickFalse)", "       return(DestroyImageList(image));", " ", "    ", "      BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));     ", "      if (BImgBuff == NULL)", "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "     (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));", "  ", "      MinVal = 0;", "      MaxVal = 0;", "     if (CellType==miDOUBLE || CellType==miSINGLE)         ", "     {", "       CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);", "     }", " ", "      ", "     if(z==1) z=0;  ", "      ", "     do", "     {", "       for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)", "       {", "         q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);", "         if (q == (Quantum *) NULL)", "   {", "     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),", "               \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));", "     goto done_reading;     ", "   }", "         if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)", "   {", "     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),", "              \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));", "     goto ExitLoop;", "   }", "         if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))", "         {", "           FixLogical((unsigned char *)BImgBuff,ldblk);", "           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)", "     {", " ImportQuantumPixelsFailed:", "       if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),", "               \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));", "       break;", "     }", "         }", "         else", "         {", "           if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)", "       goto ImportQuantumPixelsFailed;", " ", " ", "           if (z<=1 &&        ", "           (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))", "       FixSignedValues(image,q,MATLAB_HDR.SizeX);", "         }", " ", "         if (!SyncAuthenticPixels(image,exception))", "   {", "     if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),", "             \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));", "     goto ExitLoop;", "   }", "       }", "     } while(z-- >= 2);", "     quantum_info=DestroyQuantumInfo(quantum_info);", " ExitLoop:", " ", " ", "      ", "     if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)", "     {         ", "       CellType = ReadBlobXXXLong(image2);     ", "       i = ReadBlobXXXLong(image2);            ", " ", "       if (CellType==miDOUBLE || CellType==miSINGLE)", "       {", "         CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);", "       }", " ", "       if (CellType==miDOUBLE)", "         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)", "   {", "           ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);", "           InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,", "             exception);", "   }", " ", "       if (CellType==miSINGLE)", "         for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)", "   {", "           ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);", "           InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,", "             exception);", "   }", "     }", " ", "        ", "     if ((MATLAB_HDR.DimFlag == 8) &&", "         ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))", "       image->type=GrayscaleType;", "     if (image->depth == 1)", "       image->type=BilevelType;", " ", "     if(image2==image)", "         image2 = NULL;     ", " ", "        ", "     rotated_image = RotateImage(image, 90.0, exception);", "     if (rotated_image != (Image *) NULL)", "     {", "          ", "       rotated_image->page.x=0;", "       rotated_image->page.y=0;", " ", "       blob = rotated_image->blob;", "       rotated_image->blob = image->blob;", "       rotated_image->colors = image->colors;", "       image->blob = blob;", "       AppendImageToList(&image,rotated_image);", "       DeleteImageFromList(&image);", "     }", " ", " done_reading:", " ", "     if(image2!=NULL)", "       if(image2!=image)", "       {", "         DeleteImageFromList(&image2);", "   if(clone_info)", "   {", "           if(clone_info->file)", "     {", "             fclose(clone_info->file);", "             clone_info->file = NULL;", "             (void) remove_utf8(clone_info->filename);", "     }", "         }", "       }", " ", "        ", "     AcquireNextImage(image_info,image,exception);", "     if (image->next == (Image *) NULL) break;", "     image=SyncNextImageInList(image);", "     image->columns=image->rows=0;", "     image->colors=0;", " ", "        ", "     RelinquishMagickMemory(BImgBuff);", "     BImgBuff = NULL;", " ", "     if(--Frames>0)", "     {", "       z = z2;", "       if(image2==NULL) image2 = image;", "       goto NEXT_FRAME;", "     }", "     if ((image2!=NULL) && (image2!=image))    ", "       {", "  ", "         DeleteImageFromList(&image2);", "         if(clone_info)", "         {", "           if(clone_info->file)", "           {", "             fclose(clone_info->file);", "             clone_info->file = NULL;", "             (void) remove_utf8(clone_info->filename);", "           }", "         }", "         }", "   }", " ", "   RelinquishMagickMemory(BImgBuff);", " END_OF_READING:", "   clone_info=DestroyImageInfo(clone_info);", "   CloseBlob(image);", " ", " ", "   {", "     Image *p;", "     ssize_t scene=0;", " ", "      ", "     p=image;", "     image=NULL;", "     while (p != (Image *) NULL)", "       {", "         Image *tmp=p;", "         if ((p->rows == 0) || (p->columns == 0)) {", "           p=p->previous;", "           DeleteImageFromList(&tmp);", "         } else {", "           image=p;", "           p=p->previous;", "         }", "       }", " ", "      ", "     for (p=image; p != (Image *) NULL; p=p->next)", "       p->scene=scene++;", "   }", " ", "   if(clone_info != NULL)   ", "   {", "     if(clone_info->file)", "     {", "       fclose(clone_info->file);", "       clone_info->file = NULL;", "       (void) remove_utf8(clone_info->filename);", "     }", "     DestroyImageInfo(clone_info);", "     clone_info = NULL;", "   }", "   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");", "   if(image==NULL)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   return (image);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static int atusb_get_and_show_revision(struct atusb *atusb)", "  {", "  \tstruct usb_device *usb_dev = atusb->usb_dev;", "\tunsigned char buffer[3];", " \tunsigned char *buffer;", "  \tint ret;", "  ", " \tbuffer = kmalloc(3, GFP_KERNEL);", " \tif (!buffer)", " \t\treturn -ENOMEM;", " ", "  \t ", "  \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),", "  \t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,", " \t\t\t\tbuffer, 3, 1000);", " \tif (ret >= 0) {", " \t\tatusb->fw_ver_maj = buffer[0];", " \t\tatusb->fw_ver_min = buffer[1];", " \t\tatusb->fw_hw_type = buffer[2];", " ", " \t\tdev_info(&usb_dev->dev,", " \t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",", " \t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);", " \t}", " \tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {", " \t\tdev_info(&usb_dev->dev,", " \t\t\t \"Firmware version (%u.%u) predates our first public release.\",", " \t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);", "  \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");", "  \t}", "  ", " \tkfree(buffer);", "  \treturn ret;", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": ["rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)", "{", "rfbClientPtr cl;", "rfbServerCutTextMsg sct;", "rfbClientIteratorPtr iterator;", "", "iterator = rfbGetClientIterator(rfbScreen);", "while ((cl = rfbClientIteratorNext(iterator)) != NULL) {", "sct.type = rfbServerCutText;", "sct.length = Swap32IfLE(len);", "LOCK(cl->sendMutex);", "if (rfbWriteExact(cl, (char *)&sct,", "sz_rfbServerCutTextMsg) < 0) {", "rfbLogPerror(\"rfbSendServerCutText: write\");", "rfbCloseClient(cl);", "UNLOCK(cl->sendMutex);", "continue;", "}", "if (rfbWriteExact(cl, str, len) < 0) {", "rfbLogPerror(\"rfbSendServerCutText: write\");", "rfbCloseClient(cl);", "}", "UNLOCK(cl->sendMutex);", "rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);", "}", "rfbReleaseClientIterator(iterator);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  sec_decrypt(uint8 * data, int length)", "  {", " \tif (length <= 0)", " \t\treturn;", " ", "  \tif (g_sec_decrypt_use_count == 4096)", "  \t{", "  \t\tsec_update(g_sec_decrypt_key, g_sec_decrypt_update_key);", " \t\trdssl_rc4_set_key(&g_rc4_decrypt_key, g_sec_decrypt_key, g_rc4_key_len);", " \t\tg_sec_decrypt_use_count = 0;", " \t}", " ", " \trdssl_rc4_crypt(&g_rc4_decrypt_key, data, data, length);", " \tg_sec_decrypt_use_count++;", " }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int send_event (int fd, uint16_t type, uint16_t code, int32_t value)", " {", "  struct uinput_event event;", "     BTIF_TRACE_DEBUG(\"%s type:%u code:%u value:%d\", __FUNCTION__,", "         type, code, value);", "     memset(&event, 0, sizeof(event));", "     event.type  = type;", " ", "      event.code  = code;", "      event.value = value;", "  ", "    return write(fd, &event, sizeof(event));", "     return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoArray *array, MonoClassField *field_handle)", "{", "MonoClass *klass = array->obj.vtable->klass;", "guint32 size = mono_array_element_size (klass);", "MonoType *type = mono_type_get_underlying_type (&klass->element_class->byval_arg);", "int align;", "const char *field_data;", "", "if (MONO_TYPE_IS_REFERENCE (type) ||", "(type->type == MONO_TYPE_VALUETYPE &&", "(!mono_type_get_class (type) ||", "mono_type_get_class (type)->has_references))) {", "MonoException *exc = mono_get_exception_argument(\"array\",", "\"Cannot initialize array containing references\");", "mono_raise_exception (exc);", "}", "", "if (!(field_handle->type->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA)) {", "MonoException *exc = mono_get_exception_argument(\"field_handle\",", "\"Field doesn't have an RVA\");", "mono_raise_exception (exc);", "}", "", "size *= array->max_length;", "field_data = mono_field_get_data (field_handle);", "", "if (size > mono_type_size (field_handle->type, &align)) {", "MonoException *exc = mono_get_exception_argument(\"field_handle\",", "\"Field not large enough to fill array\");", "mono_raise_exception (exc);", "}", "", "#if G_BYTE_ORDER != G_LITTLE_ENDIAN", "#define SWAP(n) {\\", "\tguint ## n *data = (guint ## n *) mono_array_addr (array, char, 0); \\", "\tguint ## n *src = (guint ## n *) field_data; \\", "\tguint ## n *end = (guint ## n *)((char*)src + size); \\", "\\", "\tfor (; src < end; data++, src++) { \\", "\t\t*data = read ## n (src); \\", "\t} \\", "}", "", "", "", "switch (type->type) {", "case MONO_TYPE_CHAR:", "case MONO_TYPE_I2:", "case MONO_TYPE_U2:", "SWAP (16);", "break;", "case MONO_TYPE_I4:", "case MONO_TYPE_U4:", "case MONO_TYPE_R4:", "SWAP (32);", "break;", "case MONO_TYPE_I8:", "case MONO_TYPE_U8:", "case MONO_TYPE_R8:", "SWAP (64);", "break;", "default:", "memcpy (mono_array_addr (array, char, 0), field_data, size);", "break;", "}", "#else", "memcpy (mono_array_addr (array, char, 0), field_data, size);", "#ifdef ARM_FPU_FPA", "if (klass->element_class->byval_arg.type == MONO_TYPE_R8) {", "gint i;", "double tmp;", "double *data = (double*)mono_array_addr (array, double, 0);", "", "for (i = 0; i < size; i++, data++) {", "readr8 (data, &tmp);", "*data = tmp;", "}", "}", "#endif", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static PixelChannels **AcquirePixelThreadSet(const Image *image)", " static PixelChannels **AcquirePixelThreadSet(const Image *images)", "  {", "   const Image", "     *next;", " ", "    PixelChannels", "      **pixels;", "  ", "    register ssize_t", "      i;", "  ", "    size_t", "     columns,", "      number_threads;", "  ", "    number_threads=(size_t) GetMagickResourceLimit(ThreadResource);", "   pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,", "     sizeof(*pixels));", "    if (pixels == (PixelChannels **) NULL)", "      return((PixelChannels **) NULL);", "    (void) memset(pixels,0,number_threads*sizeof(*pixels));", "   columns=images->columns;", "   for (next=images; next != (Image *) NULL; next=next->next)", "     columns=MagickMax(next->columns,columns);", "    for (i=0; i < (ssize_t) number_threads; i++)", "    {", "      register ssize_t", "        j;", "  ", "    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,", "      sizeof(**pixels));", "     pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));", "      if (pixels[i] == (PixelChannels *) NULL)", "        return(DestroyPixelThreadSet(pixels));", "    for (j=0; j < (ssize_t) image->columns; j++)", "     for (j=0; j < (ssize_t) columns; j++)", "      {", "        register ssize_t", "          k;", " ", "       for (k=0; k < MaxPixelChannels; k++)", "         pixels[i][j].channel[k]=0.0;", "     }", "   }", "   return(pixels);", " }"], "ner_tags": [0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" produce_output()", " {", " \tchar\t*str;", " \tFILE\t*mailer;", " \tMyString subject,szTmp;", " \tsubject.sprintf(\"condor_preen results %s: %d old file%s found\", ", " \t\tmy_full_hostname(), BadFiles->number(), ", " \t\t(BadFiles->number() > 1)?\"s\":\"\");", " ", " \tif( MailFlag ) {", " \t\tif( (mailer=email_open(PreenAdmin, subject.Value())) == NULL ) {", " \t\t\tEXCEPT( \"Can't do email_open(\\\"%s\\\", \\\"%s\\\")\\n\",PreenAdmin,subject.Value());", " \t\t}", " \t} else {", " \t\tmailer = stdout;", "         }", "  ", "         szTmp.sprintf(\"The condor_preen process has found the following stale condor files on <%s>:\\n\\n\",  get_local_hostname().Value());", "       dprintf(D_ALWAYS, szTmp.Value()); ", "        dprintf(D_ALWAYS, \"%s\", szTmp.Value()); ", "                 ", "         if( MailFlag ) {", "                 fprintf( mailer, \"\\n\" );", "               fprintf( mailer, szTmp.Value());", "                fprintf( mailer, \"%s\", szTmp.Value());", "         }", "  ", "         for( BadFiles->rewind(); (str = BadFiles->next()); ) {", "                 szTmp.sprintf(\"  %s\\n\", str);", "               dprintf(D_ALWAYS, szTmp.Value() );", "               fprintf( mailer, szTmp.Value() );", "                dprintf(D_ALWAYS, \"%s\", szTmp.Value() );", "                fprintf( mailer, \"%s\", szTmp.Value() );", "         }", "  ", "         if( MailFlag ) {", " \t\tconst char *explanation = \"\\n\\nWhat is condor_preen?\\n\\n\"", " \"The condor_preen tool examines the directories belonging to Condor, and\\n\"", " \"removes extraneous files and directories which may be left over from Condor\\n\"", " \"processes which terminated abnormally either due to internal errors or a\\n\"", " \"system crash.  The directories checked are the LOG, EXECUTE, and SPOOL\\n\"", " \"directories as defined in the Condor configuration files.  The condor_preen\\n\"", " \"tool is intended to be run as user root (or user condor) periodically as a\\n\"", " \"backup method to ensure reasonable file system cleanliness in the face of\\n\"", " \"errors. This is done automatically by default by the condor_master daemon.\\n\"", " \"It may also be explicitly invoked on an as needed basis.\\n\\n\"", " \"See the Condor manual section on condor_preen for more details.\\n\";", " ", " \t\tfprintf( mailer, \"%s\\n\", explanation );", " \t\temail_close( mailer );", " \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool CSPSource::schemeMatches(const KURL& url) const", "  {", "      if (m_scheme.isEmpty())", "          return m_policy->protocolMatchesSelf(url);", "     if (equalIgnoringCase(m_scheme, \"http\"))", "         return equalIgnoringCase(url.protocol(), \"http\") || equalIgnoringCase(url.protocol(), \"https\");", "     if (equalIgnoringCase(m_scheme, \"ws\"))", "         return equalIgnoringCase(url.protocol(), \"ws\") || equalIgnoringCase(url.protocol(), \"wss\");", "      return equalIgnoringCase(url.protocol(), m_scheme);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0]}
{"tokens": [" int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)", " {", "  if(h < 0 || h >= MAX_THREAD)", "  {", "         APPL_TRACE_ERROR(\"invalid bt thread handle:%d\", h);", "  return FALSE;", "  }", "  if(ts[h].cmd_fdw == -1)", "  {", "         APPL_TRACE_ERROR(\"cmd socket is not created. socket thread may not initialized\");", "  return FALSE;", "  }", "  if(flags & SOCK_THREAD_ADD_FD_SYNC)", "  {", "  if(ts[h].thread_id == pthread_self())", "  {", "             flags &= ~SOCK_THREAD_ADD_FD_SYNC;", "             add_poll(h, fd, type, flags, user_id);", "  return TRUE;", "  }", "         APPL_TRACE_DEBUG(\"THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async\");", " ", "      }", "      sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};", "      APPL_TRACE_DEBUG(\"adding fd:%d, flags:0x%x\", fd, flags);", "    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);", "     return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)", " {", "   Image", "     *image;", " ", "   MagickBooleanType", "     has_merged_image,", "     skip_layers;", " ", "   MagickOffsetType", "     offset;", " ", "   MagickSizeType", "     length;", " ", "   MagickBooleanType", "     status;", " ", "   PSDInfo", "     psd_info;", " ", "   register ssize_t", "     i;", " ", "   ssize_t", "     count;", " ", "   unsigned char", "     *data;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", " ", "   image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   image->endian=MSBEndian;", "   count=ReadBlob(image,4,(unsigned char *) psd_info.signature);", "   psd_info.version=ReadBlobMSBShort(image);", "   if ((count == 0) || (LocaleNCompare(psd_info.signature,\"8BPS\",4) != 0) ||", "       ((psd_info.version != 1) && (psd_info.version != 2)))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   (void) ReadBlob(image,6,psd_info.reserved);", "   psd_info.channels=ReadBlobMSBShort(image);", "   if (psd_info.channels > MaxPSDChannels)", "     ThrowReaderException(CorruptImageError,\"MaximumChannelsExceeded\");", "   psd_info.rows=ReadBlobMSBLong(image);", "   psd_info.columns=ReadBlobMSBLong(image);", "   if ((psd_info.version == 1) && ((psd_info.rows > 30000) ||", "       (psd_info.columns > 30000)))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   psd_info.depth=ReadBlobMSBShort(image);", "   if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16))", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   psd_info.mode=ReadBlobMSBShort(image);", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "       \"  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s\",", "       (double) psd_info.columns,(double) psd_info.rows,(double)", "       psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType)", "       psd_info.mode));", "    ", "   image->depth=psd_info.depth;", "   image->columns=psd_info.columns;", "   image->rows=psd_info.rows;", "   status=SetImageExtent(image,image->columns,image->rows,exception);", "   if (status == MagickFalse)", "     return(DestroyImageList(image));", "   if (SetImageBackgroundColor(image,exception) == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "   if (psd_info.mode == LabMode)", "     SetImageColorspace(image,LabColorspace,exception);", "   if (psd_info.mode == CMYKMode)", "     {", "       SetImageColorspace(image,CMYKColorspace,exception);", "       image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait :", "         UndefinedPixelTrait;", "     }", "   else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) ||", "       (psd_info.mode == DuotoneMode))", "     {", "       status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536,", "         exception);", "       if (status == MagickFalse)", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"  Image colormap allocated\");", "       SetImageColorspace(image,GRAYColorspace,exception);", "       image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait :", "         UndefinedPixelTrait;", "     }", "   else", "     image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait :", "       UndefinedPixelTrait;", "    ", "   length=ReadBlobMSBLong(image);", "   if (length != 0)", "     {", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"  reading colormap\");", "       if (psd_info.mode == DuotoneMode)", "         {", "            ", "           data=(unsigned char *) AcquireQuantumMemory((size_t) length,", "             sizeof(*data));", "           if (data == (unsigned char *) NULL)", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           (void) ReadBlob(image,(size_t) length,data);", "           data=(unsigned char *) RelinquishMagickMemory(data);", "         }", "       else", "         {", "           size_t", "             number_colors;", " ", "            ", "           number_colors=length/3;", "           if (number_colors > 65536)", "             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "           if (AcquireImageColormap(image,number_colors,exception) == MagickFalse)", "             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "           for (i=0; i < (ssize_t) image->colors; i++)", "             image->colormap[i].red=ScaleCharToQuantum((unsigned char)", "               ReadBlobByte(image));", "           for (i=0; i < (ssize_t) image->colors; i++)", "             image->colormap[i].green=ScaleCharToQuantum((unsigned char)", "               ReadBlobByte(image));", "           for (i=0; i < (ssize_t) image->colors; i++)", "             image->colormap[i].blue=ScaleCharToQuantum((unsigned char)", "               ReadBlobByte(image));", "            image->alpha_trait=UndefinedPixelTrait;", "          }", "      }", "   if ((image->depth == 1) && (image->storage_class != PseudoClass))", "     ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");", "    has_merged_image=MagickTrue;", "    length=ReadBlobMSBLong(image);", "    if (length != 0)", "     {", "       unsigned char", "         *blocks;", " ", "        ", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"  reading image resource blocks - %.20g bytes\",(double)", "           ((MagickOffsetType) length));", "       blocks=(unsigned char *) AcquireQuantumMemory((size_t) length,", "         sizeof(*blocks));", "       if (blocks == (unsigned char *) NULL)", "         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");", "       count=ReadBlob(image,(size_t) length,blocks);", "       if ((count != (ssize_t) length) ||", "           (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))", "         {", "           blocks=(unsigned char *) RelinquishMagickMemory(blocks);", "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "         }", "       ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image,", "         exception);", "       blocks=(unsigned char *) RelinquishMagickMemory(blocks);", "     }", "    ", "   length=GetPSDSize(&psd_info,image);", "   if (length == 8)", "     {", "       length=ReadBlobMSBLong(image);", "       length=ReadBlobMSBLong(image);", "     }", "   offset=TellBlob(image);", "   skip_layers=MagickFalse;", "   if ((image_info->number_scenes == 1) && (image_info->scene == 0) &&", "       (has_merged_image != MagickFalse))", "     {", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"  read composite only\");", "       skip_layers=MagickTrue;", "     }", "   if (length == 0)", "     {", "       if (image->debug != MagickFalse)", "         (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "           \"  image has no layers\");", "     }", "   else", "     {", "       if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) !=", "           MagickTrue)", "         {", "           (void) CloseBlob(image);", "           image=DestroyImageList(image);", "           return((Image *) NULL);", "         }", " ", "        ", "       SeekBlob(image,offset+length,SEEK_SET);", "     }", "    ", "   if (image_info->ping != MagickFalse)", "     {", "       (void) CloseBlob(image);", "       return(GetFirstImageInList(image));", "     }", "    ", "   if (image->debug != MagickFalse)", "     (void) LogMagickEvent(CoderEvent,GetMagickModule(),", "       \"  reading the precombined layer\");", "   if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1))", "     has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image,", "       &psd_info,exception);", "   if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) &&", "       (length != 0))", "     {", "       SeekBlob(image,offset,SEEK_SET);", "       status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception);", "       if (status != MagickTrue)", "         {", "           (void) CloseBlob(image);", "           image=DestroyImageList(image);", "           return((Image *) NULL);", "         }", "     }", "   if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1))", "     {", "       Image", "         *merged;", " ", "       SetImageAlphaChannel(image,TransparentAlphaChannel,exception);", "       image->background_color.alpha=TransparentAlpha;", "       image->background_color.alpha_trait=BlendPixelTrait;", "       merged=MergeImageLayers(image,FlattenLayer,exception);", "       ReplaceImageInList(&image,merged);", "     }", "   (void) CloseBlob(image);", "   return(GetFirstImageInList(image));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static target_ulong disas_insn(CPUX86State *env, DisasContext *s,", "                                target_ulong pc_start)", " {", "     int b, prefixes;", "     int shift;", "     TCGMemOp ot, aflag, dflag;", "     int modrm, reg, rm, mod, op, opreg, val;", "     target_ulong next_eip, tval;", "     int rex_w, rex_r;", " ", "     s->pc_start = s->pc = pc_start;", "     prefixes = 0;", "     s->override = -1;", "     rex_w = -1;", "     rex_r = 0;", " #ifdef TARGET_X86_64", "     s->rex_x = 0;", "     s->rex_b = 0;", "     x86_64_hregs = 0;", " #endif", "     s->rip_offset = 0;  ", "      s->vex_l = 0;", "      s->vex_v = 0;", "   next_byte:", "      ", "     if (s->pc - pc_start > 14) {", "         goto illegal_op;", "     }", "      b = cpu_ldub_code(env, s->pc);", "      s->pc++;", "       ", "     switch (b) {", "     case 0xf3:", "         prefixes |= PREFIX_REPZ;", "         goto next_byte;", "     case 0xf2:", "         prefixes |= PREFIX_REPNZ;", "         goto next_byte;", "     case 0xf0:", "         prefixes |= PREFIX_LOCK;", "         goto next_byte;", "     case 0x2e:", "         s->override = R_CS;", "         goto next_byte;", "     case 0x36:", "         s->override = R_SS;", "         goto next_byte;", "     case 0x3e:", "         s->override = R_DS;", "         goto next_byte;", "     case 0x26:", "         s->override = R_ES;", "         goto next_byte;", "     case 0x64:", "         s->override = R_FS;", "         goto next_byte;", "     case 0x65:", "         s->override = R_GS;", "         goto next_byte;", "     case 0x66:", "         prefixes |= PREFIX_DATA;", "         goto next_byte;", "     case 0x67:", "         prefixes |= PREFIX_ADR;", "         goto next_byte;", " #ifdef TARGET_X86_64", "     case 0x40 ... 0x4f:", "         if (CODE64(s)) {", "              ", "             rex_w = (b >> 3) & 1;", "             rex_r = (b & 0x4) << 1;", "             s->rex_x = (b & 0x2) << 2;", "             REX_B(s) = (b & 0x1) << 3;", "             x86_64_hregs = 1;  ", "             goto next_byte;", "         }", "         break;", " #endif", "     case 0xc5:  ", "     case 0xc4:  ", "          ", "         if (s->code32 && !s->vm86) {", "             static const int pp_prefix[4] = {", "                 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ", "             };", "             int vex3, vex2 = cpu_ldub_code(env, s->pc);", " ", "             if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) {", "                  ", "                 break;", "             }", "             s->pc++;", " ", "              ", "             if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ", "                             | PREFIX_LOCK | PREFIX_DATA)) {", "                 goto illegal_op;", "             }", " #ifdef TARGET_X86_64", "             if (x86_64_hregs) {", "                 goto illegal_op;", "             }", " #endif", "             rex_r = (~vex2 >> 4) & 8;", "             if (b == 0xc5) {", "                 vex3 = vex2;", "                 b = cpu_ldub_code(env, s->pc++);", "             } else {", " #ifdef TARGET_X86_64", "                 s->rex_x = (~vex2 >> 3) & 8;", "                 s->rex_b = (~vex2 >> 2) & 8;", " #endif", "                 vex3 = cpu_ldub_code(env, s->pc++);", "                 rex_w = (vex3 >> 7) & 1;", "                 switch (vex2 & 0x1f) {", "                 case 0x01:  ", "                     b = cpu_ldub_code(env, s->pc++) | 0x100;", "                     break;", "                 case 0x02:  ", "                     b = 0x138;", "                     break;", "                 case 0x03:  ", "                     b = 0x13a;", "                     break;", "                 default:    ", "                     goto unknown_op;", "                 }", "             }", "             s->vex_v = (~vex3 >> 3) & 0xf;", "             s->vex_l = (vex3 >> 2) & 1;", "             prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX;", "         }", "         break;", "     }", " ", "      ", "     if (CODE64(s)) {", "          ", "         dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32);", "          ", "         aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64);", "     } else {", "          ", "         if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) {", "             dflag = MO_32;", "         } else {", "             dflag = MO_16;", "         }", "          ", "         if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) {", "             aflag = MO_32;", "         }  else {", "             aflag = MO_16;", "         }", "     }", " ", "     s->prefix = prefixes;", "     s->aflag = aflag;", "     s->dflag = dflag;", " ", "      ", "  reswitch:", "     switch(b) {", "     case 0x0f:", "          ", "          ", "         b = cpu_ldub_code(env, s->pc++) | 0x100;", "         goto reswitch;", " ", "          ", "          ", "     case 0x00 ... 0x05:", "     case 0x08 ... 0x0d:", "     case 0x10 ... 0x15:", "     case 0x18 ... 0x1d:", "     case 0x20 ... 0x25:", "     case 0x28 ... 0x2d:", "     case 0x30 ... 0x35:", "     case 0x38 ... 0x3d:", "         {", "             int op, f, val;", "             op = (b >> 3) & 7;", "             f = (b >> 1) & 3;", " ", "             ot = mo_b_d(b, dflag);", " ", "             switch(f) {", "             case 0:  ", "                 modrm = cpu_ldub_code(env, s->pc++);", "                 reg = ((modrm >> 3) & 7) | rex_r;", "                 mod = (modrm >> 6) & 3;", "                 rm = (modrm & 7) | REX_B(s);", "                 if (mod != 3) {", "                     gen_lea_modrm(env, s, modrm);", "                     opreg = OR_TMP0;", "                 } else if (op == OP_XORL && rm == reg) {", "                 xor_zero:", "                      ", "                     set_cc_op(s, CC_OP_CLR);", "                     tcg_gen_movi_tl(cpu_T0, 0);", "                     gen_op_mov_reg_v(ot, reg, cpu_T0);", "                     break;", "                 } else {", "                     opreg = rm;", "                 }", "                 gen_op_mov_v_reg(ot, cpu_T1, reg);", "                 gen_op(s, op, ot, opreg);", "                 break;", "             case 1:  ", "                 modrm = cpu_ldub_code(env, s->pc++);", "                 mod = (modrm >> 6) & 3;", "                 reg = ((modrm >> 3) & 7) | rex_r;", "                 rm = (modrm & 7) | REX_B(s);", "                 if (mod != 3) {", "                     gen_lea_modrm(env, s, modrm);", "                     gen_op_ld_v(s, ot, cpu_T1, cpu_A0);", "                 } else if (op == OP_XORL && rm == reg) {", "                     goto xor_zero;", "                 } else {", "                     gen_op_mov_v_reg(ot, cpu_T1, rm);", "                 }", "                 gen_op(s, op, ot, reg);", "                 break;", "             case 2:  ", "                 val = insn_get(env, s, ot);", "                 tcg_gen_movi_tl(cpu_T1, val);", "                 gen_op(s, op, ot, OR_EAX);", "                 break;", "             }", "         }", "         break;", " ", "     case 0x82:", "         if (CODE64(s))", "             goto illegal_op;", "     case 0x80:  ", "     case 0x81:", "     case 0x83:", "         {", "             int val;", " ", "             ot = mo_b_d(b, dflag);", " ", "             modrm = cpu_ldub_code(env, s->pc++);", "             mod = (modrm >> 6) & 3;", "             rm = (modrm & 7) | REX_B(s);", "             op = (modrm >> 3) & 7;", " ", "             if (mod != 3) {", "                 if (b == 0x83)", "                     s->rip_offset = 1;", "                 else", "                     s->rip_offset = insn_const_size(ot);", "                 gen_lea_modrm(env, s, modrm);", "                 opreg = OR_TMP0;", "             } else {", "                 opreg = rm;", "             }", " ", "             switch(b) {", "             default:", "             case 0x80:", "             case 0x81:", "             case 0x82:", "                 val = insn_get(env, s, ot);", "                 break;", "             case 0x83:", "                 val = (int8_t)insn_get(env, s, MO_8);", "                 break;", "             }", "             tcg_gen_movi_tl(cpu_T1, val);", "             gen_op(s, op, ot, opreg);", "         }", "         break;", " ", "          ", "          ", "     case 0x40 ... 0x47:  ", "         ot = dflag;", "         gen_inc(s, ot, OR_EAX + (b & 7), 1);", "         break;", "     case 0x48 ... 0x4f:  ", "         ot = dflag;", "         gen_inc(s, ot, OR_EAX + (b & 7), -1);", "         break;", "     case 0xf6:  ", "     case 0xf7:", "         ot = mo_b_d(b, dflag);", " ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         rm = (modrm & 7) | REX_B(s);", "         op = (modrm >> 3) & 7;", "         if (mod != 3) {", "             if (op == 0) {", "                 s->rip_offset = insn_const_size(ot);", "             }", "             gen_lea_modrm(env, s, modrm);", "              ", "             if (!(s->prefix & PREFIX_LOCK)", "                 || op != 2) {", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "             }", "         } else {", "             gen_op_mov_v_reg(ot, cpu_T0, rm);", "         }", " ", "         switch(op) {", "         case 0:  ", "             val = insn_get(env, s, ot);", "             tcg_gen_movi_tl(cpu_T1, val);", "             gen_op_testl_T0_T1_cc();", "             set_cc_op(s, CC_OP_LOGICB + ot);", "             break;", "         case 2:  ", "             if (s->prefix & PREFIX_LOCK) {", "                 if (mod == 3) {", "                     goto illegal_op;", "                 }", "                 tcg_gen_movi_tl(cpu_T0, ~0);", "                 tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0,", "                                             s->mem_index, ot | MO_LE);", "             } else {", "                 tcg_gen_not_tl(cpu_T0, cpu_T0);", "                 if (mod != 3) {", "                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "                 } else {", "                     gen_op_mov_reg_v(ot, rm, cpu_T0);", "                 }", "             }", "             break;", "         case 3:  ", "             if (s->prefix & PREFIX_LOCK) {", "                 TCGLabel *label1;", "                 TCGv a0, t0, t1, t2;", " ", "                 if (mod == 3) {", "                     goto illegal_op;", "                 }", "                 a0 = tcg_temp_local_new();", "                 t0 = tcg_temp_local_new();", "                 label1 = gen_new_label();", " ", "                 tcg_gen_mov_tl(a0, cpu_A0);", "                 tcg_gen_mov_tl(t0, cpu_T0);", " ", "                 gen_set_label(label1);", "                 t1 = tcg_temp_new();", "                 t2 = tcg_temp_new();", "                 tcg_gen_mov_tl(t2, t0);", "                 tcg_gen_neg_tl(t1, t0);", "                 tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1,", "                                           s->mem_index, ot | MO_LE);", "                 tcg_temp_free(t1);", "                 tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1);", " ", "                 tcg_temp_free(t2);", "                 tcg_temp_free(a0);", "                 tcg_gen_mov_tl(cpu_T0, t0);", "                 tcg_temp_free(t0);", "             } else {", "                 tcg_gen_neg_tl(cpu_T0, cpu_T0);", "                 if (mod != 3) {", "                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "                 } else {", "                     gen_op_mov_reg_v(ot, rm, cpu_T0);", "                 }", "             }", "             gen_op_update_neg_cc();", "             set_cc_op(s, CC_OP_SUBB + ot);", "             break;", "         case 4:  ", "             switch(ot) {", "             case MO_8:", "                 gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);", "                 tcg_gen_ext8u_tl(cpu_T0, cpu_T0);", "                 tcg_gen_ext8u_tl(cpu_T1, cpu_T1);", "                  ", "                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);", "                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "                 tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00);", "                 set_cc_op(s, CC_OP_MULB);", "                 break;", "             case MO_16:", "                 gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);", "                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);", "                 tcg_gen_ext16u_tl(cpu_T1, cpu_T1);", "                  ", "                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);", "                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "                 tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);", "                 gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);", "                 tcg_gen_mov_tl(cpu_cc_src, cpu_T0);", "                 set_cc_op(s, CC_OP_MULW);", "                 break;", "             default:", "             case MO_32:", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);", "                 tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32,", "                                   cpu_tmp2_i32, cpu_tmp3_i32);", "                 tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);", "                 tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);", "                 tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);", "                 set_cc_op(s, CC_OP_MULL);", "                 break;", " #ifdef TARGET_X86_64", "             case MO_64:", "                 tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],", "                                   cpu_T0, cpu_regs[R_EAX]);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);", "                 tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]);", "                 set_cc_op(s, CC_OP_MULQ);", "                 break;", " #endif", "             }", "             break;", "         case 5:  ", "             switch(ot) {", "             case MO_8:", "                 gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX);", "                 tcg_gen_ext8s_tl(cpu_T0, cpu_T0);", "                 tcg_gen_ext8s_tl(cpu_T1, cpu_T1);", "                  ", "                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);", "                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "                 tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0);", "                 tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);", "                 set_cc_op(s, CC_OP_MULB);", "                 break;", "             case MO_16:", "                 gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX);", "                 tcg_gen_ext16s_tl(cpu_T0, cpu_T0);", "                 tcg_gen_ext16s_tl(cpu_T1, cpu_T1);", "                  ", "                 tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);", "                 gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "                 tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);", "                 tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);", "                 tcg_gen_shri_tl(cpu_T0, cpu_T0, 16);", "                 gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);", "                 set_cc_op(s, CC_OP_MULW);", "                 break;", "             default:", "             case MO_32:", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]);", "                 tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,", "                                   cpu_tmp2_i32, cpu_tmp3_i32);", "                 tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32);", "                 tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32);", "                 tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);", "                 tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);", "                 tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);", "                 set_cc_op(s, CC_OP_MULL);", "                 break;", " #ifdef TARGET_X86_64", "             case MO_64:", "                 tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX],", "                                   cpu_T0, cpu_regs[R_EAX]);", "                 tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]);", "                 tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63);", "                 tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]);", "                 set_cc_op(s, CC_OP_MULQ);", "                 break;", " #endif", "             }", "             break;", "         case 6:  ", "             switch(ot) {", "             case MO_8:", "                 gen_helper_divb_AL(cpu_env, cpu_T0);", "                 break;", "             case MO_16:", "                 gen_helper_divw_AX(cpu_env, cpu_T0);", "                 break;", "             default:", "             case MO_32:", "                 gen_helper_divl_EAX(cpu_env, cpu_T0);", "                 break;", " #ifdef TARGET_X86_64", "             case MO_64:", "                 gen_helper_divq_EAX(cpu_env, cpu_T0);", "                 break;", " #endif", "             }", "             break;", "         case 7:  ", "             switch(ot) {", "             case MO_8:", "                 gen_helper_idivb_AL(cpu_env, cpu_T0);", "                 break;", "             case MO_16:", "                 gen_helper_idivw_AX(cpu_env, cpu_T0);", "                 break;", "             default:", "             case MO_32:", "                 gen_helper_idivl_EAX(cpu_env, cpu_T0);", "                 break;", " #ifdef TARGET_X86_64", "             case MO_64:", "                 gen_helper_idivq_EAX(cpu_env, cpu_T0);", "                 break;", " #endif", "             }", "             break;", "         default:", "             goto unknown_op;", "         }", "         break;", " ", "     case 0xfe:  ", "     case 0xff:  ", "         ot = mo_b_d(b, dflag);", " ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         rm = (modrm & 7) | REX_B(s);", "         op = (modrm >> 3) & 7;", "         if (op >= 2 && b == 0xfe) {", "             goto unknown_op;", "         }", "         if (CODE64(s)) {", "             if (op == 2 || op == 4) {", "                  ", "                 ot = MO_64;", "             } else if (op == 3 || op == 5) {", "                 ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16;", "             } else if (op == 6) {", "                  ", "                 ot = mo_pushpop(s, dflag);", "             }", "         }", "         if (mod != 3) {", "             gen_lea_modrm(env, s, modrm);", "             if (op >= 2 && op != 3 && op != 5)", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "         } else {", "             gen_op_mov_v_reg(ot, cpu_T0, rm);", "         }", " ", "         switch(op) {", "         case 0:  ", "             if (mod != 3)", "                 opreg = OR_TMP0;", "             else", "                 opreg = rm;", "             gen_inc(s, ot, opreg, 1);", "             break;", "         case 1:  ", "             if (mod != 3)", "                 opreg = OR_TMP0;", "             else", "                 opreg = rm;", "             gen_inc(s, ot, opreg, -1);", "             break;", "         case 2:  ", "              ", "             if (dflag == MO_16) {", "                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);", "             }", "             next_eip = s->pc - s->cs_base;", "             tcg_gen_movi_tl(cpu_T1, next_eip);", "             gen_push_v(s, cpu_T1);", "             gen_op_jmp_v(cpu_T0);", "             gen_bnd_jmp(s);", "             gen_eob(s);", "             break;", "         case 3:  ", "             gen_op_ld_v(s, ot, cpu_T1, cpu_A0);", "             gen_add_A0_im(s, 1 << ot);", "             gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);", "         do_lcall:", "             if (s->pe && !s->vm86) {", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1,", "                                            tcg_const_i32(dflag - 1),", "                                            tcg_const_tl(s->pc - s->cs_base));", "             } else {", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1,", "                                       tcg_const_i32(dflag - 1),", "                                       tcg_const_i32(s->pc - s->cs_base));", "             }", "             gen_eob(s);", "             break;", "         case 4:  ", "             if (dflag == MO_16) {", "                 tcg_gen_ext16u_tl(cpu_T0, cpu_T0);", "             }", "             gen_op_jmp_v(cpu_T0);", "             gen_bnd_jmp(s);", "             gen_eob(s);", "             break;", "         case 5:  ", "             gen_op_ld_v(s, ot, cpu_T1, cpu_A0);", "             gen_add_A0_im(s, 1 << ot);", "             gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);", "         do_ljmp:", "             if (s->pe && !s->vm86) {", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1,", "                                           tcg_const_tl(s->pc - s->cs_base));", "             } else {", "                 gen_op_movl_seg_T0_vm(R_CS);", "                 gen_op_jmp_v(cpu_T1);", "             }", "             gen_eob(s);", "             break;", "         case 6:  ", "             gen_push_v(s, cpu_T0);", "             break;", "         default:", "             goto unknown_op;", "         }", "         break;", " ", "     case 0x84:  ", "     case 0x85:", "         ot = mo_b_d(b, dflag);", " ", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", " ", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);", "         gen_op_mov_v_reg(ot, cpu_T1, reg);", "         gen_op_testl_T0_T1_cc();", "         set_cc_op(s, CC_OP_LOGICB + ot);", "         break;", " ", "     case 0xa8:  ", "     case 0xa9:", "         ot = mo_b_d(b, dflag);", "         val = insn_get(env, s, ot);", " ", "         gen_op_mov_v_reg(ot, cpu_T0, OR_EAX);", "         tcg_gen_movi_tl(cpu_T1, val);", "         gen_op_testl_T0_T1_cc();", "         set_cc_op(s, CC_OP_LOGICB + ot);", "         break;", " ", "     case 0x98:  ", "         switch (dflag) {", " #ifdef TARGET_X86_64", "         case MO_64:", "             gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);", "             tcg_gen_ext32s_tl(cpu_T0, cpu_T0);", "             gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0);", "             break;", " #endif", "         case MO_32:", "             gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);", "             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);", "             gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0);", "             break;", "         case MO_16:", "             gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX);", "             tcg_gen_ext8s_tl(cpu_T0, cpu_T0);", "             gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "             break;", "         default:", "             tcg_abort();", "         }", "         break;", "     case 0x99:  ", "         switch (dflag) {", " #ifdef TARGET_X86_64", "         case MO_64:", "             gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX);", "             tcg_gen_sari_tl(cpu_T0, cpu_T0, 63);", "             gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0);", "             break;", " #endif", "         case MO_32:", "             gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX);", "             tcg_gen_ext32s_tl(cpu_T0, cpu_T0);", "             tcg_gen_sari_tl(cpu_T0, cpu_T0, 31);", "             gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0);", "             break;", "         case MO_16:", "             gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX);", "             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);", "             tcg_gen_sari_tl(cpu_T0, cpu_T0, 15);", "             gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0);", "             break;", "         default:", "             tcg_abort();", "         }", "         break;", "     case 0x1af:  ", "     case 0x69:  ", "     case 0x6b:", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         if (b == 0x69)", "             s->rip_offset = insn_const_size(ot);", "         else if (b == 0x6b)", "             s->rip_offset = 1;", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);", "         if (b == 0x69) {", "             val = insn_get(env, s, ot);", "             tcg_gen_movi_tl(cpu_T1, val);", "         } else if (b == 0x6b) {", "             val = (int8_t)insn_get(env, s, MO_8);", "             tcg_gen_movi_tl(cpu_T1, val);", "         } else {", "             gen_op_mov_v_reg(ot, cpu_T1, reg);", "         }", "         switch (ot) {", " #ifdef TARGET_X86_64", "         case MO_64:", "             tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1);", "             tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);", "             tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63);", "             tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1);", "             break;", " #endif", "         case MO_32:", "             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "             tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);", "             tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32,", "                               cpu_tmp2_i32, cpu_tmp3_i32);", "             tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32);", "             tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31);", "             tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]);", "             tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32);", "             tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32);", "             break;", "         default:", "             tcg_gen_ext16s_tl(cpu_T0, cpu_T0);", "             tcg_gen_ext16s_tl(cpu_T1, cpu_T1);", "              ", "             tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1);", "             tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "             tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0);", "             tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0);", "             gen_op_mov_reg_v(ot, reg, cpu_T0);", "             break;", "         }", "         set_cc_op(s, CC_OP_MULB + ot);", "         break;", "     case 0x1c0:", "     case 0x1c1:  ", "         ot = mo_b_d(b, dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         mod = (modrm >> 6) & 3;", "         gen_op_mov_v_reg(ot, cpu_T0, reg);", "         if (mod == 3) {", "             rm = (modrm & 7) | REX_B(s);", "             gen_op_mov_v_reg(ot, cpu_T1, rm);", "             tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);", "             gen_op_mov_reg_v(ot, reg, cpu_T1);", "             gen_op_mov_reg_v(ot, rm, cpu_T0);", "         } else {", "             gen_lea_modrm(env, s, modrm);", "             if (s->prefix & PREFIX_LOCK) {", "                 tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0,", "                                             s->mem_index, ot | MO_LE);", "                 tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);", "             } else {", "                 gen_op_ld_v(s, ot, cpu_T1, cpu_A0);", "                 tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1);", "                 gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "             }", "             gen_op_mov_reg_v(ot, reg, cpu_T1);", "         }", "         gen_op_update2_cc();", "         set_cc_op(s, CC_OP_ADDB + ot);", "         break;", "     case 0x1b0:", "     case 0x1b1:  ", "         {", "             TCGv oldv, newv, cmpv;", " ", "             ot = mo_b_d(b, dflag);", "             modrm = cpu_ldub_code(env, s->pc++);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             mod = (modrm >> 6) & 3;", "             oldv = tcg_temp_new();", "             newv = tcg_temp_new();", "             cmpv = tcg_temp_new();", "             gen_op_mov_v_reg(ot, newv, reg);", "             tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]);", " ", "             if (s->prefix & PREFIX_LOCK) {", "                 if (mod == 3) {", "                     goto illegal_op;", "                 }", "                 gen_lea_modrm(env, s, modrm);", "                 tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv,", "                                           s->mem_index, ot | MO_LE);", "                 gen_op_mov_reg_v(ot, R_EAX, oldv);", "             } else {", "                 if (mod == 3) {", "                     rm = (modrm & 7) | REX_B(s);", "                     gen_op_mov_v_reg(ot, oldv, rm);", "                 } else {", "                     gen_lea_modrm(env, s, modrm);", "                     gen_op_ld_v(s, ot, oldv, cpu_A0);", "                     rm = 0;  ", "                 }", "                 gen_extu(ot, oldv);", "                 gen_extu(ot, cmpv);", "                  ", "                 tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv);", "                 if (mod == 3) {", "                     gen_op_mov_reg_v(ot, R_EAX, oldv);", "                     gen_op_mov_reg_v(ot, rm, newv);", "                 } else {", "                      ", "                     gen_op_st_v(s, ot, newv, cpu_A0);", "                     gen_op_mov_reg_v(ot, R_EAX, oldv);", "                 }", "             }", "             tcg_gen_mov_tl(cpu_cc_src, oldv);", "             tcg_gen_mov_tl(cpu_cc_srcT, cmpv);", "             tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv);", "             set_cc_op(s, CC_OP_SUBB + ot);", "             tcg_temp_free(oldv);", "             tcg_temp_free(newv);", "             tcg_temp_free(cmpv);", "         }", "         break;", "     case 0x1c7:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         if ((mod == 3) || ((modrm & 0x38) != 0x8))", "             goto illegal_op;", " #ifdef TARGET_X86_64", "         if (dflag == MO_64) {", "             if (!(s->cpuid_ext_features & CPUID_EXT_CX16))", "                 goto illegal_op;", "             gen_lea_modrm(env, s, modrm);", "             if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {", "                 gen_helper_cmpxchg16b(cpu_env, cpu_A0);", "             } else {", "                 gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0);", "             }", "         } else", " #endif        ", "         {", "             if (!(s->cpuid_features & CPUID_CX8))", "                 goto illegal_op;", "             gen_lea_modrm(env, s, modrm);", "             if ((s->prefix & PREFIX_LOCK) && parallel_cpus) {", "                 gen_helper_cmpxchg8b(cpu_env, cpu_A0);", "             } else {", "                 gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0);", "             }", "         }", "         set_cc_op(s, CC_OP_EFLAGS);", "         break;", " ", "          ", "          ", "     case 0x50 ... 0x57:  ", "         gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s));", "         gen_push_v(s, cpu_T0);", "         break;", "     case 0x58 ... 0x5f:  ", "         ot = gen_pop_T0(s);", "          ", "         gen_pop_update(s, ot);", "         gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0);", "         break;", "     case 0x60:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_pusha(s);", "         break;", "     case 0x61:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_popa(s);", "         break;", "     case 0x68:  ", "     case 0x6a:", "         ot = mo_pushpop(s, dflag);", "         if (b == 0x68)", "             val = insn_get(env, s, ot);", "         else", "             val = (int8_t)insn_get(env, s, MO_8);", "         tcg_gen_movi_tl(cpu_T0, val);", "         gen_push_v(s, cpu_T0);", "         break;", "     case 0x8f:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         ot = gen_pop_T0(s);", "         if (mod == 3) {", "              ", "             gen_pop_update(s, ot);", "             rm = (modrm & 7) | REX_B(s);", "             gen_op_mov_reg_v(ot, rm, cpu_T0);", "         } else {", "              ", "             s->popl_esp_hack = 1 << ot;", "             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);", "             s->popl_esp_hack = 0;", "             gen_pop_update(s, ot);", "         }", "         break;", "     case 0xc8:  ", "         {", "             int level;", "             val = cpu_lduw_code(env, s->pc);", "             s->pc += 2;", "             level = cpu_ldub_code(env, s->pc++);", "             gen_enter(s, val, level);", "         }", "         break;", "     case 0xc9:  ", "         gen_leave(s);", "         break;", "     case 0x06:  ", "     case 0x0e:  ", "     case 0x16:  ", "     case 0x1e:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_op_movl_T0_seg(b >> 3);", "         gen_push_v(s, cpu_T0);", "         break;", "     case 0x1a0:  ", "     case 0x1a8:  ", "         gen_op_movl_T0_seg((b >> 3) & 7);", "         gen_push_v(s, cpu_T0);", "         break;", "     case 0x07:  ", "     case 0x17:  ", "     case 0x1f:  ", "         if (CODE64(s))", "             goto illegal_op;", "         reg = b >> 3;", "         ot = gen_pop_T0(s);", "         gen_movl_seg_T0(s, reg);", "         gen_pop_update(s, ot);", "          ", "         if (s->is_jmp) {", "             gen_jmp_im(s->pc - s->cs_base);", "             if (reg == R_SS) {", "                 s->tf = 0;", "                 gen_eob_inhibit_irq(s, true);", "             } else {", "                 gen_eob(s);", "             }", "         }", "         break;", "     case 0x1a1:  ", "     case 0x1a9:  ", "         ot = gen_pop_T0(s);", "         gen_movl_seg_T0(s, (b >> 3) & 7);", "         gen_pop_update(s, ot);", "         if (s->is_jmp) {", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "         }", "         break;", " ", "          ", "          ", "     case 0x88:", "     case 0x89:  ", "         ot = mo_b_d(b, dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", " ", "          ", "         gen_ldst_modrm(env, s, modrm, ot, reg, 1);", "         break;", "     case 0xc6:", "     case 0xc7:  ", "         ot = mo_b_d(b, dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         if (mod != 3) {", "             s->rip_offset = insn_const_size(ot);", "             gen_lea_modrm(env, s, modrm);", "         }", "         val = insn_get(env, s, ot);", "         tcg_gen_movi_tl(cpu_T0, val);", "         if (mod != 3) {", "             gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "         } else {", "             gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0);", "         }", "         break;", "     case 0x8a:", "     case 0x8b:  ", "         ot = mo_b_d(b, dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", " ", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);", "         gen_op_mov_reg_v(ot, reg, cpu_T0);", "         break;", "     case 0x8e:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = (modrm >> 3) & 7;", "         if (reg >= 6 || reg == R_CS)", "             goto illegal_op;", "         gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "         gen_movl_seg_T0(s, reg);", "          ", "         if (s->is_jmp) {", "             gen_jmp_im(s->pc - s->cs_base);", "             if (reg == R_SS) {", "                 s->tf = 0;", "                 gen_eob_inhibit_irq(s, true);", "             } else {", "                 gen_eob(s);", "             }", "         }", "         break;", "     case 0x8c:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = (modrm >> 3) & 7;", "         mod = (modrm >> 6) & 3;", "         if (reg >= 6)", "             goto illegal_op;", "         gen_op_movl_T0_seg(reg);", "         ot = mod == 3 ? dflag : MO_16;", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);", "         break;", " ", "     case 0x1b6:  ", "     case 0x1b7:  ", "     case 0x1be:  ", "     case 0x1bf:  ", "         {", "             TCGMemOp d_ot;", "             TCGMemOp s_ot;", " ", "              ", "             d_ot = dflag;", "              ", "             ot = (b & 1) + MO_8;", "              ", "             s_ot = b & 8 ? MO_SIGN | ot : ot;", " ", "             modrm = cpu_ldub_code(env, s->pc++);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             mod = (modrm >> 6) & 3;", "             rm = (modrm & 7) | REX_B(s);", " ", "             if (mod == 3) {", "                 if (s_ot == MO_SB && byte_reg_is_xH(rm)) {", "                     tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8);", "                 } else {", "                     gen_op_mov_v_reg(ot, cpu_T0, rm);", "                     switch (s_ot) {", "                     case MO_UB:", "                         tcg_gen_ext8u_tl(cpu_T0, cpu_T0);", "                         break;", "                     case MO_SB:", "                         tcg_gen_ext8s_tl(cpu_T0, cpu_T0);", "                         break;", "                     case MO_UW:", "                         tcg_gen_ext16u_tl(cpu_T0, cpu_T0);", "                         break;", "                     default:", "                     case MO_SW:", "                         tcg_gen_ext16s_tl(cpu_T0, cpu_T0);", "                         break;", "                     }", "                 }", "                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);", "             } else {", "                 gen_lea_modrm(env, s, modrm);", "                 gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0);", "                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);", "             }", "         }", "         break;", " ", "     case 0x8d:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         if (mod == 3)", "             goto illegal_op;", "         reg = ((modrm >> 3) & 7) | rex_r;", "         {", "             AddressParts a = gen_lea_modrm_0(env, s, modrm);", "             TCGv ea = gen_lea_modrm_1(a);", "             gen_lea_v_seg(s, s->aflag, ea, -1, -1);", "             gen_op_mov_reg_v(dflag, reg, cpu_A0);", "         }", "         break;", " ", "     case 0xa0:  ", "     case 0xa1:", "     case 0xa2:  ", "     case 0xa3:", "         {", "             target_ulong offset_addr;", " ", "             ot = mo_b_d(b, dflag);", "             switch (s->aflag) {", " #ifdef TARGET_X86_64", "             case MO_64:", "                 offset_addr = cpu_ldq_code(env, s->pc);", "                 s->pc += 8;", "                 break;", " #endif", "             default:", "                 offset_addr = insn_get(env, s, s->aflag);", "                 break;", "             }", "             tcg_gen_movi_tl(cpu_A0, offset_addr);", "             gen_add_A0_ds_seg(s);", "             if ((b & 2) == 0) {", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "                 gen_op_mov_reg_v(ot, R_EAX, cpu_T0);", "             } else {", "                 gen_op_mov_v_reg(ot, cpu_T0, R_EAX);", "                 gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "             }", "         }", "         break;", "     case 0xd7:  ", "         tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]);", "         tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]);", "         tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0);", "         gen_extu(s->aflag, cpu_A0);", "         gen_add_A0_ds_seg(s);", "         gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0);", "         gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);", "         break;", "     case 0xb0 ... 0xb7:  ", "         val = insn_get(env, s, MO_8);", "         tcg_gen_movi_tl(cpu_T0, val);", "         gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0);", "         break;", "     case 0xb8 ... 0xbf:  ", " #ifdef TARGET_X86_64", "         if (dflag == MO_64) {", "             uint64_t tmp;", "              ", "             tmp = cpu_ldq_code(env, s->pc);", "             s->pc += 8;", "             reg = (b & 7) | REX_B(s);", "             tcg_gen_movi_tl(cpu_T0, tmp);", "             gen_op_mov_reg_v(MO_64, reg, cpu_T0);", "         } else", " #endif", "         {", "             ot = dflag;", "             val = insn_get(env, s, ot);", "             reg = (b & 7) | REX_B(s);", "             tcg_gen_movi_tl(cpu_T0, val);", "             gen_op_mov_reg_v(ot, reg, cpu_T0);", "         }", "         break;", " ", "     case 0x91 ... 0x97:  ", "     do_xchg_reg_eax:", "         ot = dflag;", "         reg = (b & 7) | REX_B(s);", "         rm = R_EAX;", "         goto do_xchg_reg;", "     case 0x86:", "     case 0x87:  ", "         ot = mo_b_d(b, dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         mod = (modrm >> 6) & 3;", "         if (mod == 3) {", "             rm = (modrm & 7) | REX_B(s);", "         do_xchg_reg:", "             gen_op_mov_v_reg(ot, cpu_T0, reg);", "             gen_op_mov_v_reg(ot, cpu_T1, rm);", "             gen_op_mov_reg_v(ot, rm, cpu_T0);", "             gen_op_mov_reg_v(ot, reg, cpu_T1);", "         } else {", "             gen_lea_modrm(env, s, modrm);", "             gen_op_mov_v_reg(ot, cpu_T0, reg);", "              ", "             tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0,", "                                    s->mem_index, ot | MO_LE);", "             gen_op_mov_reg_v(ot, reg, cpu_T1);", "         }", "         break;", "     case 0xc4:  ", "          ", "         op = R_ES;", "         goto do_lxx;", "     case 0xc5:  ", "          ", "         op = R_DS;", "         goto do_lxx;", "     case 0x1b2:  ", "         op = R_SS;", "         goto do_lxx;", "     case 0x1b4:  ", "         op = R_FS;", "         goto do_lxx;", "     case 0x1b5:  ", "         op = R_GS;", "     do_lxx:", "         ot = dflag != MO_16 ? MO_32 : MO_16;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         mod = (modrm >> 6) & 3;", "         if (mod == 3)", "             goto illegal_op;", "         gen_lea_modrm(env, s, modrm);", "         gen_op_ld_v(s, ot, cpu_T1, cpu_A0);", "         gen_add_A0_im(s, 1 << ot);", "          ", "         gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0);", "         gen_movl_seg_T0(s, op);", "          ", "         gen_op_mov_reg_v(ot, reg, cpu_T1);", "         if (s->is_jmp) {", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "         }", "         break;", " ", "          ", "          ", "     case 0xc0:", "     case 0xc1:", "          ", "         shift = 2;", "     grp2:", "         {", "             ot = mo_b_d(b, dflag);", "             modrm = cpu_ldub_code(env, s->pc++);", "             mod = (modrm >> 6) & 3;", "             op = (modrm >> 3) & 7;", " ", "             if (mod != 3) {", "                 if (shift == 2) {", "                     s->rip_offset = 1;", "                 }", "                 gen_lea_modrm(env, s, modrm);", "                 opreg = OR_TMP0;", "             } else {", "                 opreg = (modrm & 7) | REX_B(s);", "             }", " ", "              ", "             if (shift == 0) {", "                 gen_shift(s, op, ot, opreg, OR_ECX);", "             } else {", "                 if (shift == 2) {", "                     shift = cpu_ldub_code(env, s->pc++);", "                 }", "                 gen_shifti(s, op, ot, opreg, shift);", "             }", "         }", "         break;", "     case 0xd0:", "     case 0xd1:", "          ", "         shift = 1;", "         goto grp2;", "     case 0xd2:", "     case 0xd3:", "          ", "         shift = 0;", "         goto grp2;", " ", "     case 0x1a4:  ", "         op = 0;", "         shift = 1;", "         goto do_shiftd;", "     case 0x1a5:  ", "         op = 0;", "         shift = 0;", "         goto do_shiftd;", "     case 0x1ac:  ", "         op = 1;", "         shift = 1;", "         goto do_shiftd;", "     case 0x1ad:  ", "         op = 1;", "         shift = 0;", "     do_shiftd:", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         rm = (modrm & 7) | REX_B(s);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         if (mod != 3) {", "             gen_lea_modrm(env, s, modrm);", "             opreg = OR_TMP0;", "         } else {", "             opreg = rm;", "         }", "         gen_op_mov_v_reg(ot, cpu_T1, reg);", " ", "         if (shift) {", "             TCGv imm = tcg_const_tl(cpu_ldub_code(env, s->pc++));", "             gen_shiftd_rm_T1(s, ot, opreg, op, imm);", "             tcg_temp_free(imm);", "         } else {", "             gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]);", "         }", "         break;", " ", "          ", "          ", "     case 0xd8 ... 0xdf:", "         if (s->flags & (HF_EM_MASK | HF_TS_MASK)) {", "              ", "              ", "             gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "             break;", "         }", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         rm = modrm & 7;", "         op = ((b & 7) << 3) | ((modrm >> 3) & 7);", "         if (mod != 3) {", "              ", "             gen_lea_modrm(env, s, modrm);", "             switch(op) {", "             case 0x00 ... 0x07:  ", "             case 0x10 ... 0x17:  ", "             case 0x20 ... 0x27:  ", "             case 0x30 ... 0x37:  ", "                 {", "                     int op1;", "                     op1 = op & 7;", " ", "                     switch(op >> 4) {", "                     case 0:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     case 1:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     case 2:", "                         tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64);", "                         break;", "                     case 3:", "                     default:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LESW);", "                         gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     }", " ", "                     gen_helper_fp_arith_ST0_FT0(op1);", "                     if (op1 == 3) {", "                          ", "                         gen_helper_fpop(cpu_env);", "                     }", "                 }", "                 break;", "             case 0x08:  ", "             case 0x0a:  ", "             case 0x0b:  ", "             case 0x18 ... 0x1b:  ", "             case 0x28 ... 0x2b:  ", "             case 0x38 ... 0x3b:  ", "                 switch(op & 7) {", "                 case 0:", "                     switch(op >> 4) {", "                     case 0:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     case 1:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     case 2:", "                         tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64);", "                         break;", "                     case 3:", "                     default:", "                         tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LESW);", "                         gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32);", "                         break;", "                     }", "                     break;", "                 case 1:", "                      ", "                     switch(op >> 4) {", "                     case 1:", "                         gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env);", "                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         break;", "                     case 2:", "                         gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env);", "                         tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         break;", "                     case 3:", "                     default:", "                         gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env);", "                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUW);", "                         break;", "                     }", "                     gen_helper_fpop(cpu_env);", "                     break;", "                 default:", "                     switch(op >> 4) {", "                     case 0:", "                         gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env);", "                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         break;", "                     case 1:", "                         gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env);", "                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         break;", "                     case 2:", "                         gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env);", "                         tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         break;", "                     case 3:", "                     default:", "                         gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env);", "                         tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                             s->mem_index, MO_LEUW);", "                         break;", "                     }", "                     if ((op & 7) == 3)", "                         gen_helper_fpop(cpu_env);", "                     break;", "                 }", "                 break;", "             case 0x0c:  ", "                 gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));", "                 break;", "             case 0x0d:  ", "                 tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0,", "                                     s->mem_index, MO_LEUW);", "                 gen_helper_fldcw(cpu_env, cpu_tmp2_i32);", "                 break;", "             case 0x0e:  ", "                 gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));", "                 break;", "             case 0x0f:  ", "                 gen_helper_fnstcw(cpu_tmp2_i32, cpu_env);", "                 tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                     s->mem_index, MO_LEUW);", "                 break;", "             case 0x1d:  ", "                 gen_helper_fldt_ST0(cpu_env, cpu_A0);", "                 break;", "             case 0x1f:  ", "                 gen_helper_fstt_ST0(cpu_env, cpu_A0);", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x2c:  ", "                 gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));", "                 break;", "             case 0x2e:  ", "                 gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1));", "                 break;", "             case 0x2f:  ", "                 gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);", "                 tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0,", "                                     s->mem_index, MO_LEUW);", "                 break;", "             case 0x3c:  ", "                 gen_helper_fbld_ST0(cpu_env, cpu_A0);", "                 break;", "             case 0x3e:  ", "                 gen_helper_fbst_ST0(cpu_env, cpu_A0);", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x3d:  ", "                 tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);", "                 gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64);", "                 break;", "             case 0x3f:  ", "                 gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env);", "                 tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ);", "                 gen_helper_fpop(cpu_env);", "                 break;", "             default:", "                 goto unknown_op;", "             }", "         } else {", "              ", "             opreg = rm;", " ", "             switch(op) {", "             case 0x08:  ", "                 gen_helper_fpush(cpu_env);", "                 gen_helper_fmov_ST0_STN(cpu_env,", "                                         tcg_const_i32((opreg + 1) & 7));", "                 break;", "             case 0x09:  ", "             case 0x29:  ", "             case 0x39:  ", "                 gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg));", "                 break;", "             case 0x0a:  ", "                 switch(rm) {", "                 case 0:  ", "                      ", "                     gen_helper_fwait(cpu_env);", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x0c:  ", "                 switch(rm) {", "                 case 0:  ", "                     gen_helper_fchs_ST0(cpu_env);", "                     break;", "                 case 1:  ", "                     gen_helper_fabs_ST0(cpu_env);", "                     break;", "                 case 4:  ", "                     gen_helper_fldz_FT0(cpu_env);", "                     gen_helper_fcom_ST0_FT0(cpu_env);", "                     break;", "                 case 5:  ", "                     gen_helper_fxam_ST0(cpu_env);", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x0d:  ", "                 {", "                     switch(rm) {", "                     case 0:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fld1_ST0(cpu_env);", "                         break;", "                     case 1:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldl2t_ST0(cpu_env);", "                         break;", "                     case 2:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldl2e_ST0(cpu_env);", "                         break;", "                     case 3:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldpi_ST0(cpu_env);", "                         break;", "                     case 4:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldlg2_ST0(cpu_env);", "                         break;", "                     case 5:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldln2_ST0(cpu_env);", "                         break;", "                     case 6:", "                         gen_helper_fpush(cpu_env);", "                         gen_helper_fldz_ST0(cpu_env);", "                         break;", "                     default:", "                         goto unknown_op;", "                     }", "                 }", "                 break;", "             case 0x0e:  ", "                 switch(rm) {", "                 case 0:  ", "                     gen_helper_f2xm1(cpu_env);", "                     break;", "                 case 1:  ", "                     gen_helper_fyl2x(cpu_env);", "                     break;", "                 case 2:  ", "                     gen_helper_fptan(cpu_env);", "                     break;", "                 case 3:  ", "                     gen_helper_fpatan(cpu_env);", "                     break;", "                 case 4:  ", "                     gen_helper_fxtract(cpu_env);", "                     break;", "                 case 5:  ", "                     gen_helper_fprem1(cpu_env);", "                     break;", "                 case 6:  ", "                     gen_helper_fdecstp(cpu_env);", "                     break;", "                 default:", "                 case 7:  ", "                     gen_helper_fincstp(cpu_env);", "                     break;", "                 }", "                 break;", "             case 0x0f:  ", "                 switch(rm) {", "                 case 0:  ", "                     gen_helper_fprem(cpu_env);", "                     break;", "                 case 1:  ", "                     gen_helper_fyl2xp1(cpu_env);", "                     break;", "                 case 2:  ", "                     gen_helper_fsqrt(cpu_env);", "                     break;", "                 case 3:  ", "                     gen_helper_fsincos(cpu_env);", "                     break;", "                 case 5:  ", "                     gen_helper_fscale(cpu_env);", "                     break;", "                 case 4:  ", "                     gen_helper_frndint(cpu_env);", "                     break;", "                 case 6:  ", "                     gen_helper_fsin(cpu_env);", "                     break;", "                 default:", "                 case 7:  ", "                     gen_helper_fcos(cpu_env);", "                     break;", "                 }", "                 break;", "             case 0x00: case 0x01: case 0x04 ... 0x07:  ", "             case 0x20: case 0x21: case 0x24 ... 0x27:  ", "             case 0x30: case 0x31: case 0x34 ... 0x37:  ", "                 {", "                     int op1;", " ", "                     op1 = op & 7;", "                     if (op >= 0x20) {", "                         gen_helper_fp_arith_STN_ST0(op1, opreg);", "                         if (op >= 0x30)", "                             gen_helper_fpop(cpu_env);", "                     } else {", "                         gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                         gen_helper_fp_arith_ST0_FT0(op1);", "                     }", "                 }", "                 break;", "             case 0x02:  ", "             case 0x22:  ", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fcom_ST0_FT0(cpu_env);", "                 break;", "             case 0x03:  ", "             case 0x23:  ", "             case 0x32:  ", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fcom_ST0_FT0(cpu_env);", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x15:  ", "                 switch(rm) {", "                 case 1:  ", "                     gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));", "                     gen_helper_fucom_ST0_FT0(cpu_env);", "                     gen_helper_fpop(cpu_env);", "                     gen_helper_fpop(cpu_env);", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x1c:", "                 switch(rm) {", "                 case 0:  ", "                     break;", "                 case 1:  ", "                     break;", "                 case 2:  ", "                     gen_helper_fclex(cpu_env);", "                     break;", "                 case 3:  ", "                     gen_helper_fninit(cpu_env);", "                     break;", "                 case 4:  ", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x1d:  ", "                 if (!(s->cpuid_features & CPUID_CMOV)) {", "                     goto illegal_op;", "                 }", "                 gen_update_cc_op(s);", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fucomi_ST0_FT0(cpu_env);", "                 set_cc_op(s, CC_OP_EFLAGS);", "                 break;", "             case 0x1e:  ", "                 if (!(s->cpuid_features & CPUID_CMOV)) {", "                     goto illegal_op;", "                 }", "                 gen_update_cc_op(s);", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fcomi_ST0_FT0(cpu_env);", "                 set_cc_op(s, CC_OP_EFLAGS);", "                 break;", "             case 0x28:  ", "                 gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));", "                 break;", "             case 0x2a:  ", "                 gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));", "                 break;", "             case 0x2b:  ", "             case 0x0b:  ", "             case 0x3a:  ", "             case 0x3b:  ", "                 gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x2c:  ", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fucom_ST0_FT0(cpu_env);", "                 break;", "             case 0x2d:  ", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fucom_ST0_FT0(cpu_env);", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x33:  ", "                 switch(rm) {", "                 case 1:  ", "                     gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1));", "                     gen_helper_fcom_ST0_FT0(cpu_env);", "                     gen_helper_fpop(cpu_env);", "                     gen_helper_fpop(cpu_env);", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x38:  ", "                 gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fpop(cpu_env);", "                 break;", "             case 0x3c:  ", "                 switch(rm) {", "                 case 0:", "                     gen_helper_fnstsw(cpu_tmp2_i32, cpu_env);", "                     tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32);", "                     gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0);", "                     break;", "                 default:", "                     goto unknown_op;", "                 }", "                 break;", "             case 0x3d:  ", "                 if (!(s->cpuid_features & CPUID_CMOV)) {", "                     goto illegal_op;", "                 }", "                 gen_update_cc_op(s);", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fucomi_ST0_FT0(cpu_env);", "                 gen_helper_fpop(cpu_env);", "                 set_cc_op(s, CC_OP_EFLAGS);", "                 break;", "             case 0x3e:  ", "                 if (!(s->cpuid_features & CPUID_CMOV)) {", "                     goto illegal_op;", "                 }", "                 gen_update_cc_op(s);", "                 gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg));", "                 gen_helper_fcomi_ST0_FT0(cpu_env);", "                 gen_helper_fpop(cpu_env);", "                 set_cc_op(s, CC_OP_EFLAGS);", "                 break;", "             case 0x10 ... 0x13:  ", "             case 0x18 ... 0x1b:", "                 {", "                     int op1;", "                     TCGLabel *l1;", "                     static const uint8_t fcmov_cc[8] = {", "                         (JCC_B << 1),", "                         (JCC_Z << 1),", "                         (JCC_BE << 1),", "                         (JCC_P << 1),", "                     };", " ", "                     if (!(s->cpuid_features & CPUID_CMOV)) {", "                         goto illegal_op;", "                     }", "                     op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1);", "                     l1 = gen_new_label();", "                     gen_jcc1_noeob(s, op1, l1);", "                     gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg));", "                     gen_set_label(l1);", "                 }", "                 break;", "             default:", "                 goto unknown_op;", "             }", "         }", "         break;", "          ", "          ", " ", "     case 0xa4:  ", "     case 0xa5:", "         ot = mo_b_d(b, dflag);", "         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {", "             gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);", "         } else {", "             gen_movs(s, ot);", "         }", "         break;", " ", "     case 0xaa:  ", "     case 0xab:", "         ot = mo_b_d(b, dflag);", "         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {", "             gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);", "         } else {", "             gen_stos(s, ot);", "         }", "         break;", "     case 0xac:  ", "     case 0xad:", "         ot = mo_b_d(b, dflag);", "         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {", "             gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);", "         } else {", "             gen_lods(s, ot);", "         }", "         break;", "     case 0xae:  ", "     case 0xaf:", "         ot = mo_b_d(b, dflag);", "         if (prefixes & PREFIX_REPNZ) {", "             gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);", "         } else if (prefixes & PREFIX_REPZ) {", "             gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);", "         } else {", "             gen_scas(s, ot);", "         }", "         break;", " ", "     case 0xa6:  ", "     case 0xa7:", "         ot = mo_b_d(b, dflag);", "         if (prefixes & PREFIX_REPNZ) {", "             gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1);", "         } else if (prefixes & PREFIX_REPZ) {", "             gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0);", "         } else {", "             gen_cmps(s, ot);", "         }", "         break;", "     case 0x6c:  ", "     case 0x6d:", "         ot = mo_b_d32(b, dflag);", "         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);", "         gen_check_io(s, ot, pc_start - s->cs_base, ", "                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4);", "         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {", "             gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);", "         } else {", "             gen_ins(s, ot);", "             if (s->tb->cflags & CF_USE_ICOUNT) {", "                 gen_jmp(s, s->pc - s->cs_base);", "             }", "         }", "         break;", "     case 0x6e:  ", "     case 0x6f:", "         ot = mo_b_d32(b, dflag);", "         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);", "         gen_check_io(s, ot, pc_start - s->cs_base,", "                      svm_is_rep(prefixes) | 4);", "         if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) {", "             gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base);", "         } else {", "             gen_outs(s, ot);", "             if (s->tb->cflags & CF_USE_ICOUNT) {", "                 gen_jmp(s, s->pc - s->cs_base);", "             }", "         }", "         break;", " ", "          ", "          ", " ", "     case 0xe4:", "     case 0xe5:", "         ot = mo_b_d32(b, dflag);", "         val = cpu_ldub_code(env, s->pc++);", "         tcg_gen_movi_tl(cpu_T0, val);", "         gen_check_io(s, ot, pc_start - s->cs_base,", "                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_start();", " \t}", "         tcg_gen_movi_i32(cpu_tmp2_i32, val);", "         gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);", "         gen_op_mov_reg_v(ot, R_EAX, cpu_T1);", "         gen_bpt_io(s, cpu_tmp2_i32, ot);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_end();", "             gen_jmp(s, s->pc - s->cs_base);", "         }", "         break;", "     case 0xe6:", "     case 0xe7:", "         ot = mo_b_d32(b, dflag);", "         val = cpu_ldub_code(env, s->pc++);", "         tcg_gen_movi_tl(cpu_T0, val);", "         gen_check_io(s, ot, pc_start - s->cs_base,", "                      svm_is_rep(prefixes));", "         gen_op_mov_v_reg(ot, cpu_T1, R_EAX);", " ", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_start();", " \t}", "         tcg_gen_movi_i32(cpu_tmp2_i32, val);", "         tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);", "         gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);", "         gen_bpt_io(s, cpu_tmp2_i32, ot);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_end();", "             gen_jmp(s, s->pc - s->cs_base);", "         }", "         break;", "     case 0xec:", "     case 0xed:", "         ot = mo_b_d32(b, dflag);", "         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);", "         gen_check_io(s, ot, pc_start - s->cs_base,", "                      SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_start();", " \t}", "         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "         gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32);", "         gen_op_mov_reg_v(ot, R_EAX, cpu_T1);", "         gen_bpt_io(s, cpu_tmp2_i32, ot);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_end();", "             gen_jmp(s, s->pc - s->cs_base);", "         }", "         break;", "     case 0xee:", "     case 0xef:", "         ot = mo_b_d32(b, dflag);", "         tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]);", "         gen_check_io(s, ot, pc_start - s->cs_base,", "                      svm_is_rep(prefixes));", "         gen_op_mov_v_reg(ot, cpu_T1, R_EAX);", " ", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_start();", " \t}", "         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "         tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1);", "         gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);", "         gen_bpt_io(s, cpu_tmp2_i32, ot);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_end();", "             gen_jmp(s, s->pc - s->cs_base);", "         }", "         break;", " ", "          ", "          ", "     case 0xc2:  ", "         val = cpu_ldsw_code(env, s->pc);", "         s->pc += 2;", "         ot = gen_pop_T0(s);", "         gen_stack_update(s, val + (1 << ot));", "          ", "         gen_op_jmp_v(cpu_T0);", "         gen_bnd_jmp(s);", "         gen_eob(s);", "         break;", "     case 0xc3:  ", "         ot = gen_pop_T0(s);", "         gen_pop_update(s, ot);", "          ", "         gen_op_jmp_v(cpu_T0);", "         gen_bnd_jmp(s);", "         gen_eob(s);", "         break;", "     case 0xca:  ", "         val = cpu_ldsw_code(env, s->pc);", "         s->pc += 2;", "     do_lret:", "         if (s->pe && !s->vm86) {", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1),", "                                       tcg_const_i32(val));", "         } else {", "             gen_stack_A0(s);", "              ", "             gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);", "              ", "             gen_op_jmp_v(cpu_T0);", "              ", "             gen_add_A0_im(s, 1 << dflag);", "             gen_op_ld_v(s, dflag, cpu_T0, cpu_A0);", "             gen_op_movl_seg_T0_vm(R_CS);", "              ", "             gen_stack_update(s, val + (2 << dflag));", "         }", "         gen_eob(s);", "         break;", "     case 0xcb:  ", "         val = 0;", "         goto do_lret;", "     case 0xcf:  ", "         gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);", "         if (!s->pe) {", "              ", "             gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));", "             set_cc_op(s, CC_OP_EFLAGS);", "         } else if (s->vm86) {", "             if (s->iopl != 3) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "             } else {", "                 gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1));", "                 set_cc_op(s, CC_OP_EFLAGS);", "             }", "         } else {", "             gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1),", "                                       tcg_const_i32(s->pc - s->cs_base));", "             set_cc_op(s, CC_OP_EFLAGS);", "         }", "         gen_eob(s);", "         break;", "     case 0xe8:  ", "         {", "             if (dflag != MO_16) {", "                 tval = (int32_t)insn_get(env, s, MO_32);", "             } else {", "                 tval = (int16_t)insn_get(env, s, MO_16);", "             }", "             next_eip = s->pc - s->cs_base;", "             tval += next_eip;", "             if (dflag == MO_16) {", "                 tval &= 0xffff;", "             } else if (!CODE64(s)) {", "                 tval &= 0xffffffff;", "             }", "             tcg_gen_movi_tl(cpu_T0, next_eip);", "             gen_push_v(s, cpu_T0);", "             gen_bnd_jmp(s);", "             gen_jmp(s, tval);", "         }", "         break;", "     case 0x9a:  ", "         {", "             unsigned int selector, offset;", " ", "             if (CODE64(s))", "                 goto illegal_op;", "             ot = dflag;", "             offset = insn_get(env, s, ot);", "             selector = insn_get(env, s, MO_16);", " ", "             tcg_gen_movi_tl(cpu_T0, selector);", "             tcg_gen_movi_tl(cpu_T1, offset);", "         }", "         goto do_lcall;", "     case 0xe9:  ", "         if (dflag != MO_16) {", "             tval = (int32_t)insn_get(env, s, MO_32);", "         } else {", "             tval = (int16_t)insn_get(env, s, MO_16);", "         }", "         tval += s->pc - s->cs_base;", "         if (dflag == MO_16) {", "             tval &= 0xffff;", "         } else if (!CODE64(s)) {", "             tval &= 0xffffffff;", "         }", "         gen_bnd_jmp(s);", "         gen_jmp(s, tval);", "         break;", "     case 0xea:  ", "         {", "             unsigned int selector, offset;", " ", "             if (CODE64(s))", "                 goto illegal_op;", "             ot = dflag;", "             offset = insn_get(env, s, ot);", "             selector = insn_get(env, s, MO_16);", " ", "             tcg_gen_movi_tl(cpu_T0, selector);", "             tcg_gen_movi_tl(cpu_T1, offset);", "         }", "         goto do_ljmp;", "     case 0xeb:  ", "         tval = (int8_t)insn_get(env, s, MO_8);", "         tval += s->pc - s->cs_base;", "         if (dflag == MO_16) {", "             tval &= 0xffff;", "         }", "         gen_jmp(s, tval);", "         break;", "     case 0x70 ... 0x7f:  ", "         tval = (int8_t)insn_get(env, s, MO_8);", "         goto do_jcc;", "     case 0x180 ... 0x18f:  ", "         if (dflag != MO_16) {", "             tval = (int32_t)insn_get(env, s, MO_32);", "         } else {", "             tval = (int16_t)insn_get(env, s, MO_16);", "         }", "     do_jcc:", "         next_eip = s->pc - s->cs_base;", "         tval += next_eip;", "         if (dflag == MO_16) {", "             tval &= 0xffff;", "         }", "         gen_bnd_jmp(s);", "         gen_jcc(s, b, tval, next_eip);", "         break;", " ", "     case 0x190 ... 0x19f:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         gen_setcc1(s, b, cpu_T0);", "         gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1);", "         break;", "     case 0x140 ... 0x14f:  ", "         if (!(s->cpuid_features & CPUID_CMOV)) {", "             goto illegal_op;", "         }", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         gen_cmovcc1(env, s, ot, b, modrm, reg);", "         break;", " ", "          ", "          ", "     case 0x9c:  ", "         gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);", "         if (s->vm86 && s->iopl != 3) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_update_cc_op(s);", "             gen_helper_read_eflags(cpu_T0, cpu_env);", "             gen_push_v(s, cpu_T0);", "         }", "         break;", "     case 0x9d:  ", "         gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);", "         if (s->vm86 && s->iopl != 3) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             ot = gen_pop_T0(s);", "             if (s->cpl == 0) {", "                 if (dflag != MO_16) {", "                     gen_helper_write_eflags(cpu_env, cpu_T0,", "                                             tcg_const_i32((TF_MASK | AC_MASK |", "                                                            ID_MASK | NT_MASK |", "                                                            IF_MASK |", "                                                            IOPL_MASK)));", "                 } else {", "                     gen_helper_write_eflags(cpu_env, cpu_T0,", "                                             tcg_const_i32((TF_MASK | AC_MASK |", "                                                            ID_MASK | NT_MASK |", "                                                            IF_MASK | IOPL_MASK)", "                                                           & 0xffff));", "                 }", "             } else {", "                 if (s->cpl <= s->iopl) {", "                     if (dflag != MO_16) {", "                         gen_helper_write_eflags(cpu_env, cpu_T0,", "                                                 tcg_const_i32((TF_MASK |", "                                                                AC_MASK |", "                                                                ID_MASK |", "                                                                NT_MASK |", "                                                                IF_MASK)));", "                     } else {", "                         gen_helper_write_eflags(cpu_env, cpu_T0,", "                                                 tcg_const_i32((TF_MASK |", "                                                                AC_MASK |", "                                                                ID_MASK |", "                                                                NT_MASK |", "                                                                IF_MASK)", "                                                               & 0xffff));", "                     }", "                 } else {", "                     if (dflag != MO_16) {", "                         gen_helper_write_eflags(cpu_env, cpu_T0,", "                                            tcg_const_i32((TF_MASK | AC_MASK |", "                                                           ID_MASK | NT_MASK)));", "                     } else {", "                         gen_helper_write_eflags(cpu_env, cpu_T0,", "                                            tcg_const_i32((TF_MASK | AC_MASK |", "                                                           ID_MASK | NT_MASK)", "                                                          & 0xffff));", "                     }", "                 }", "             }", "             gen_pop_update(s, ot);", "             set_cc_op(s, CC_OP_EFLAGS);", "              ", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "         }", "         break;", "     case 0x9e:  ", "         if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))", "             goto illegal_op;", "         gen_op_mov_v_reg(MO_8, cpu_T0, R_AH);", "         gen_compute_eflags(s);", "         tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);", "         tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C);", "         tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0);", "         break;", "     case 0x9f:  ", "         if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))", "             goto illegal_op;", "         gen_compute_eflags(s);", "          ", "         tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02);", "         gen_op_mov_reg_v(MO_8, R_AH, cpu_T0);", "         break;", "     case 0xf5:  ", "         gen_compute_eflags(s);", "         tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);", "         break;", "     case 0xf8:  ", "         gen_compute_eflags(s);", "         tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);", "         break;", "     case 0xf9:  ", "         gen_compute_eflags(s);", "         tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);", "         break;", "     case 0xfc:  ", "         tcg_gen_movi_i32(cpu_tmp2_i32, 1);", "         tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));", "         break;", "     case 0xfd:  ", "         tcg_gen_movi_i32(cpu_tmp2_i32, -1);", "         tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df));", "         break;", " ", "          ", "          ", "     case 0x1ba:  ", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         op = (modrm >> 3) & 7;", "         mod = (modrm >> 6) & 3;", "         rm = (modrm & 7) | REX_B(s);", "         if (mod != 3) {", "             s->rip_offset = 1;", "             gen_lea_modrm(env, s, modrm);", "             if (!(s->prefix & PREFIX_LOCK)) {", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "             }", "         } else {", "             gen_op_mov_v_reg(ot, cpu_T0, rm);", "         }", "          ", "         val = cpu_ldub_code(env, s->pc++);", "         tcg_gen_movi_tl(cpu_T1, val);", "         if (op < 4)", "             goto unknown_op;", "         op -= 4;", "         goto bt_op;", "     case 0x1a3:  ", "         op = 0;", "         goto do_btx;", "     case 0x1ab:  ", "         op = 1;", "         goto do_btx;", "     case 0x1b3:  ", "         op = 2;", "         goto do_btx;", "     case 0x1bb:  ", "         op = 3;", "     do_btx:", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         mod = (modrm >> 6) & 3;", "         rm = (modrm & 7) | REX_B(s);", "         gen_op_mov_v_reg(MO_32, cpu_T1, reg);", "         if (mod != 3) {", "             AddressParts a = gen_lea_modrm_0(env, s, modrm);", "              ", "             gen_exts(ot, cpu_T1);", "             tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot);", "             tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot);", "             tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0);", "             gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);", "             if (!(s->prefix & PREFIX_LOCK)) {", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "             }", "         } else {", "             gen_op_mov_v_reg(ot, cpu_T0, rm);", "         }", "     bt_op:", "         tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1);", "         tcg_gen_movi_tl(cpu_tmp0, 1);", "         tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1);", "         if (s->prefix & PREFIX_LOCK) {", "             switch (op) {", "             case 0:  ", "                  ", "                 gen_op_ld_v(s, ot, cpu_T0, cpu_A0);", "                 break;", "             case 1:  ", "                 tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0,", "                                            s->mem_index, ot | MO_LE);", "                 break;", "             case 2:  ", "                 tcg_gen_not_tl(cpu_tmp0, cpu_tmp0);", "                 tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0,", "                                             s->mem_index, ot | MO_LE);", "                 break;", "             default:", "             case 3:  ", "                 tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0,", "                                             s->mem_index, ot | MO_LE);", "                 break;", "             }", "             tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);", "         } else {", "             tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1);", "             switch (op) {", "             case 0:  ", "                  ", "                 break;", "             case 1:  ", "                 tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0);", "                 break;", "             case 2:  ", "                 tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0);", "                 break;", "             default:", "             case 3:  ", "                 tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0);", "                 break;", "             }", "             if (op != 0) {", "                 if (mod != 3) {", "                     gen_op_st_v(s, ot, cpu_T0, cpu_A0);", "                 } else {", "                     gen_op_mov_reg_v(ot, rm, cpu_T0);", "                 }", "             }", "         }", " ", "          ", "         switch (s->cc_op) {", "         case CC_OP_MULB ... CC_OP_MULQ:", "         case CC_OP_ADDB ... CC_OP_ADDQ:", "         case CC_OP_ADCB ... CC_OP_ADCQ:", "         case CC_OP_SUBB ... CC_OP_SUBQ:", "         case CC_OP_SBBB ... CC_OP_SBBQ:", "         case CC_OP_LOGICB ... CC_OP_LOGICQ:", "         case CC_OP_INCB ... CC_OP_INCQ:", "         case CC_OP_DECB ... CC_OP_DECQ:", "         case CC_OP_SHLB ... CC_OP_SHLQ:", "         case CC_OP_SARB ... CC_OP_SARQ:", "         case CC_OP_BMILGB ... CC_OP_BMILGQ:", "              ", "             tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4);", "             set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB);", "             break;", "         default:", "              ", "             gen_compute_eflags(s);", "             tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4,", "                                ctz32(CC_C), 1);", "             break;", "         }", "         break;", "     case 0x1bc:  ", "     case 0x1bd:  ", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);", "         gen_extu(ot, cpu_T0);", " ", "          ", "         if ((prefixes & PREFIX_REPZ)", "             && (b & 1", "                 ? s->cpuid_ext3_features & CPUID_EXT3_ABM", "                 : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) {", "             int size = 8 << ot;", "              ", "             tcg_gen_mov_tl(cpu_cc_src, cpu_T0);", "             if (b & 1) {", "                  ", "                 tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS);", "                 tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size);", "             } else {", "                  ", "                 tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size);", "             }", "              ", "             gen_op_update1_cc();", "             set_cc_op(s, CC_OP_BMILGB + ot);", "         } else {", "              ", "             tcg_gen_mov_tl(cpu_cc_dst, cpu_T0);", "             set_cc_op(s, CC_OP_LOGICB + ot);", " ", "              ", "             if (b & 1) {", "                  ", "                 tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1);", "                 tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1);", "                 tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1);", "             } else {", "                 tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]);", "             }", "         }", "         gen_op_mov_reg_v(ot, reg, cpu_T0);", "         break;", "          ", "          ", "     case 0x27:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_helper_daa(cpu_env);", "         set_cc_op(s, CC_OP_EFLAGS);", "         break;", "     case 0x2f:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_helper_das(cpu_env);", "         set_cc_op(s, CC_OP_EFLAGS);", "         break;", "     case 0x37:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_helper_aaa(cpu_env);", "         set_cc_op(s, CC_OP_EFLAGS);", "         break;", "     case 0x3f:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_helper_aas(cpu_env);", "         set_cc_op(s, CC_OP_EFLAGS);", "         break;", "     case 0xd4:  ", "         if (CODE64(s))", "             goto illegal_op;", "         val = cpu_ldub_code(env, s->pc++);", "         if (val == 0) {", "             gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base);", "         } else {", "             gen_helper_aam(cpu_env, tcg_const_i32(val));", "             set_cc_op(s, CC_OP_LOGICB);", "         }", "         break;", "     case 0xd5:  ", "         if (CODE64(s))", "             goto illegal_op;", "         val = cpu_ldub_code(env, s->pc++);", "         gen_helper_aad(cpu_env, tcg_const_i32(val));", "         set_cc_op(s, CC_OP_LOGICB);", "         break;", "          ", "          ", "     case 0x90:  ", "          ", "         if (prefixes & PREFIX_LOCK) {", "             goto illegal_op;", "         }", "          ", "         if (REX_B(s)) {", "             goto do_xchg_reg_eax;", "         }", "         if (prefixes & PREFIX_REPZ) {", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start));", "             s->is_jmp = DISAS_TB_JUMP;", "         }", "         break;", "     case 0x9b:  ", "         if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) ==", "             (HF_MP_MASK | HF_TS_MASK)) {", "             gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "         } else {", "             gen_helper_fwait(cpu_env);", "         }", "         break;", "     case 0xcc:  ", "         gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base);", "         break;", "     case 0xcd:  ", "         val = cpu_ldub_code(env, s->pc++);", "         if (s->vm86 && s->iopl != 3) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base);", "         }", "         break;", "     case 0xce:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_jmp_im(pc_start - s->cs_base);", "         gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start));", "         break;", " #ifdef WANT_ICEBP", "     case 0xf1:  ", "         gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP);", " #if 1", "         gen_debug(s, pc_start - s->cs_base);", " #else", "          ", "         tb_flush(CPU(x86_env_get_cpu(env)));", "         qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM);", " #endif", "         break;", " #endif", "     case 0xfa:  ", "         if (!s->vm86) {", "             if (s->cpl <= s->iopl) {", "                 gen_helper_cli(cpu_env);", "             } else {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "             }", "         } else {", "             if (s->iopl == 3) {", "                 gen_helper_cli(cpu_env);", "             } else {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "             }", "         }", "         break;", "     case 0xfb:  ", "         if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) {", "             gen_helper_sti(cpu_env);", "              ", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob_inhibit_irq(s, true);", "         } else {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         }", "         break;", "     case 0x62:  ", "         if (CODE64(s))", "             goto illegal_op;", "         ot = dflag;", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = (modrm >> 3) & 7;", "         mod = (modrm >> 6) & 3;", "         if (mod == 3)", "             goto illegal_op;", "         gen_op_mov_v_reg(ot, cpu_T0, reg);", "         gen_lea_modrm(env, s, modrm);", "         tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "         if (ot == MO_16) {", "             gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32);", "         } else {", "             gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32);", "         }", "         break;", "     case 0x1c8 ... 0x1cf:  ", "         reg = (b & 7) | REX_B(s);", " #ifdef TARGET_X86_64", "         if (dflag == MO_64) {", "             gen_op_mov_v_reg(MO_64, cpu_T0, reg);", "             tcg_gen_bswap64_i64(cpu_T0, cpu_T0);", "             gen_op_mov_reg_v(MO_64, reg, cpu_T0);", "         } else", " #endif", "         {", "             gen_op_mov_v_reg(MO_32, cpu_T0, reg);", "             tcg_gen_ext32u_tl(cpu_T0, cpu_T0);", "             tcg_gen_bswap32_tl(cpu_T0, cpu_T0);", "             gen_op_mov_reg_v(MO_32, reg, cpu_T0);", "         }", "         break;", "     case 0xd6:  ", "         if (CODE64(s))", "             goto illegal_op;", "         gen_compute_eflags_c(s, cpu_T0);", "         tcg_gen_neg_tl(cpu_T0, cpu_T0);", "         gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0);", "         break;", "     case 0xe0:  ", "     case 0xe1:  ", "     case 0xe2:  ", "     case 0xe3:  ", "         {", "             TCGLabel *l1, *l2, *l3;", " ", "             tval = (int8_t)insn_get(env, s, MO_8);", "             next_eip = s->pc - s->cs_base;", "             tval += next_eip;", "             if (dflag == MO_16) {", "                 tval &= 0xffff;", "             }", " ", "             l1 = gen_new_label();", "             l2 = gen_new_label();", "             l3 = gen_new_label();", "             b &= 3;", "             switch(b) {", "             case 0:  ", "             case 1:  ", "                 gen_op_add_reg_im(s->aflag, R_ECX, -1);", "                 gen_op_jz_ecx(s->aflag, l3);", "                 gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1);", "                 break;", "             case 2:  ", "                 gen_op_add_reg_im(s->aflag, R_ECX, -1);", "                 gen_op_jnz_ecx(s->aflag, l1);", "                 break;", "             default:", "             case 3:  ", "                 gen_op_jz_ecx(s->aflag, l1);", "                 break;", "             }", " ", "             gen_set_label(l3);", "             gen_jmp_im(next_eip);", "             tcg_gen_br(l2);", " ", "             gen_set_label(l1);", "             gen_jmp_im(tval);", "             gen_set_label(l2);", "             gen_eob(s);", "         }", "         break;", "     case 0x130:  ", "     case 0x132:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             if (b & 2) {", "                 gen_helper_rdmsr(cpu_env);", "             } else {", "                 gen_helper_wrmsr(cpu_env);", "             }", "         }", "         break;", "     case 0x131:  ", "         gen_update_cc_op(s);", "         gen_jmp_im(pc_start - s->cs_base);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_start();", " \t}", "         gen_helper_rdtsc(cpu_env);", "         if (s->tb->cflags & CF_USE_ICOUNT) {", "             gen_io_end();", "             gen_jmp(s, s->pc - s->cs_base);", "         }", "         break;", "     case 0x133:  ", "         gen_update_cc_op(s);", "         gen_jmp_im(pc_start - s->cs_base);", "         gen_helper_rdpmc(cpu_env);", "         break;", "     case 0x134:  ", "          ", "         if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)", "             goto illegal_op;", "         if (!s->pe) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_helper_sysenter(cpu_env);", "             gen_eob(s);", "         }", "         break;", "     case 0x135:  ", "          ", "         if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1)", "             goto illegal_op;", "         if (!s->pe) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1));", "             gen_eob(s);", "         }", "         break;", " #ifdef TARGET_X86_64", "     case 0x105:  ", "          ", "         gen_update_cc_op(s);", "         gen_jmp_im(pc_start - s->cs_base);", "         gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start));", "          ", "         gen_eob_worker(s, false, true);", "         break;", "     case 0x107:  ", "         if (!s->pe) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1));", "              ", "             if (s->lma) {", "                 set_cc_op(s, CC_OP_EFLAGS);", "             }", "              ", "             gen_eob_worker(s, false, true);", "         }", "         break;", " #endif", "     case 0x1a2:  ", "         gen_update_cc_op(s);", "         gen_jmp_im(pc_start - s->cs_base);", "         gen_helper_cpuid(cpu_env);", "         break;", "     case 0xf4:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start));", "             s->is_jmp = DISAS_TB_JUMP;", "         }", "         break;", "     case 0x100:", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         op = (modrm >> 3) & 7;", "         switch(op) {", "         case 0:  ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ);", "             tcg_gen_ld32u_tl(cpu_T0, cpu_env,", "                              offsetof(CPUX86State, ldt.selector));", "             ot = mod == 3 ? dflag : MO_16;", "             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);", "             break;", "         case 2:  ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "             } else {", "                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE);", "                 gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 gen_helper_lldt(cpu_env, cpu_tmp2_i32);", "             }", "             break;", "         case 1:  ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ);", "             tcg_gen_ld32u_tl(cpu_T0, cpu_env,", "                              offsetof(CPUX86State, tr.selector));", "             ot = mod == 3 ? dflag : MO_16;", "             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);", "             break;", "         case 3:  ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "             } else {", "                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE);", "                 gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "                 tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);", "                 gen_helper_ltr(cpu_env, cpu_tmp2_i32);", "             }", "             break;", "         case 4:  ", "         case 5:  ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "             gen_update_cc_op(s);", "             if (op == 4) {", "                 gen_helper_verr(cpu_env, cpu_T0);", "             } else {", "                 gen_helper_verw(cpu_env, cpu_T0);", "             }", "             set_cc_op(s, CC_OP_EFLAGS);", "             break;", "         default:", "             goto unknown_op;", "         }", "         break;", " ", "     case 0x101:", "         modrm = cpu_ldub_code(env, s->pc++);", "         switch (modrm) {", "         CASE_MODRM_MEM_OP(0):  ", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ);", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_ld32u_tl(cpu_T0,", "                              cpu_env, offsetof(CPUX86State, gdt.limit));", "             gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);", "             gen_add_A0_im(s, 2);", "             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));", "             if (dflag == MO_16) {", "                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);", "             }", "             gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);", "             break;", " ", "         case 0xc8:  ", "             if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {", "                 goto illegal_op;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]);", "             gen_extu(s->aflag, cpu_A0);", "             gen_add_A0_ds_seg(s);", "             gen_helper_monitor(cpu_env, cpu_A0);", "             break;", " ", "         case 0xc9:  ", "             if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) {", "                 goto illegal_op;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start));", "             gen_eob(s);", "             break;", " ", "         case 0xca:  ", "             if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)", "                 || s->cpl != 0) {", "                 goto illegal_op;", "             }", "             gen_helper_clac(cpu_env);", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         case 0xcb:  ", "             if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP)", "                 || s->cpl != 0) {", "                 goto illegal_op;", "             }", "             gen_helper_stac(cpu_env);", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         CASE_MODRM_MEM_OP(1):  ", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ);", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit));", "             gen_op_st_v(s, MO_16, cpu_T0, cpu_A0);", "             gen_add_A0_im(s, 2);", "             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));", "             if (dflag == MO_16) {", "                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);", "             }", "             gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);", "             break;", " ", "         case 0xd0:  ", "             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0", "                 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA", "                                  | PREFIX_REPZ | PREFIX_REPNZ))) {", "                 goto illegal_op;", "             }", "             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);", "             gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);", "             tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);", "             break;", " ", "         case 0xd1:  ", "             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0", "                 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA", "                                  | PREFIX_REPZ | PREFIX_REPNZ))) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],", "                                   cpu_regs[R_EDX]);", "             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);", "             gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);", "              ", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         case 0xd8:  ", "             if (!(s->flags & HF_SVME_MASK) || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1),", "                              tcg_const_i32(s->pc - pc_start));", "             tcg_gen_exit_tb(0);", "             s->is_jmp = DISAS_TB_JUMP;", "             break;", " ", "         case 0xd9:  ", "             if (!(s->flags & HF_SVME_MASK)) {", "                 goto illegal_op;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_vmmcall(cpu_env);", "             break;", " ", "         case 0xda:  ", "             if (!(s->flags & HF_SVME_MASK) || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1));", "             break;", " ", "         case 0xdb:  ", "             if (!(s->flags & HF_SVME_MASK) || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1));", "             break;", " ", "         case 0xdc:  ", "             if ((!(s->flags & HF_SVME_MASK)", "                    && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))", "                 || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_stgi(cpu_env);", "             break;", " ", "         case 0xdd:  ", "             if (!(s->flags & HF_SVME_MASK) || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_clgi(cpu_env);", "             break;", " ", "         case 0xde:  ", "             if ((!(s->flags & HF_SVME_MASK)", "                  && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT))", "                 || !s->pe) {", "                 goto illegal_op;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_skinit(cpu_env);", "             break;", " ", "         case 0xdf:  ", "             if (!(s->flags & HF_SVME_MASK) || !s->pe) {", "                 goto illegal_op;", "             }", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1));", "             break;", " ", "         CASE_MODRM_MEM_OP(2):  ", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE);", "             gen_lea_modrm(env, s, modrm);", "             gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);", "             gen_add_A0_im(s, 2);", "             gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);", "             if (dflag == MO_16) {", "                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);", "             }", "             tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base));", "             tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit));", "             break;", " ", "         CASE_MODRM_MEM_OP(3):  ", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE);", "             gen_lea_modrm(env, s, modrm);", "             gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0);", "             gen_add_A0_im(s, 2);", "             gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0);", "             if (dflag == MO_16) {", "                 tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff);", "             }", "             tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base));", "             tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit));", "             break;", " ", "         CASE_MODRM_OP(4):  ", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0);", "             tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0]));", "             if (CODE64(s)) {", "                 mod = (modrm >> 6) & 3;", "                 ot = (mod != 3 ? MO_16 : s->dflag);", "             } else {", "                 ot = MO_16;", "             }", "             gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1);", "             break;", "         case 0xee:  ", "             if (prefixes & PREFIX_LOCK) {", "                 goto illegal_op;", "             }", "             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);", "             gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32);", "             tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64);", "             break;", "         case 0xef:  ", "             if (prefixes & PREFIX_LOCK) {", "                 goto illegal_op;", "             }", "             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],", "                                   cpu_regs[R_EDX]);", "             tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]);", "             gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64);", "             break;", "         CASE_MODRM_OP(6):  ", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);", "             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "             gen_helper_lmsw(cpu_env, cpu_T0);", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         CASE_MODRM_MEM_OP(7):  ", "             if (s->cpl != 0) {", "                 gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 break;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             gen_lea_modrm(env, s, modrm);", "             gen_helper_invlpg(cpu_env, cpu_A0);", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         case 0xf8:  ", " #ifdef TARGET_X86_64", "             if (CODE64(s)) {", "                 if (s->cpl != 0) {", "                     gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "                 } else {", "                     tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]);", "                     tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env,", "                                   offsetof(CPUX86State, kernelgsbase));", "                     tcg_gen_st_tl(cpu_T0, cpu_env,", "                                   offsetof(CPUX86State, kernelgsbase));", "                 }", "                 break;", "             }", " #endif", "             goto illegal_op;", " ", "         case 0xf9:  ", "             if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) {", "                 goto illegal_op;", "             }", "             gen_update_cc_op(s);", "             gen_jmp_im(pc_start - s->cs_base);", "             if (s->tb->cflags & CF_USE_ICOUNT) {", "                 gen_io_start();", "             }", "             gen_helper_rdtscp(cpu_env);", "             if (s->tb->cflags & CF_USE_ICOUNT) {", "                 gen_io_end();", "                 gen_jmp(s, s->pc - s->cs_base);", "             }", "             break;", " ", "         default:", "             goto unknown_op;", "         }", "         break;", " ", "     case 0x108:  ", "     case 0x109:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD);", "              ", "         }", "         break;", "     case 0x63:  ", " #ifdef TARGET_X86_64", "         if (CODE64(s)) {", "             int d_ot;", "              ", "             d_ot = dflag;", " ", "             modrm = cpu_ldub_code(env, s->pc++);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             mod = (modrm >> 6) & 3;", "             rm = (modrm & 7) | REX_B(s);", " ", "             if (mod == 3) {", "                 gen_op_mov_v_reg(MO_32, cpu_T0, rm);", "                  ", "                 if (d_ot == MO_64) {", "                     tcg_gen_ext32s_tl(cpu_T0, cpu_T0);", "                 }", "                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);", "             } else {", "                 gen_lea_modrm(env, s, modrm);", "                 gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0);", "                 gen_op_mov_reg_v(d_ot, reg, cpu_T0);", "             }", "         } else", " #endif", "         {", "             TCGLabel *label1;", "             TCGv t0, t1, t2, a0;", " ", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             t0 = tcg_temp_local_new();", "             t1 = tcg_temp_local_new();", "             t2 = tcg_temp_local_new();", "             ot = MO_16;", "             modrm = cpu_ldub_code(env, s->pc++);", "             reg = (modrm >> 3) & 7;", "             mod = (modrm >> 6) & 3;", "             rm = modrm & 7;", "             if (mod != 3) {", "                 gen_lea_modrm(env, s, modrm);", "                 gen_op_ld_v(s, ot, t0, cpu_A0);", "                 a0 = tcg_temp_local_new();", "                 tcg_gen_mov_tl(a0, cpu_A0);", "             } else {", "                 gen_op_mov_v_reg(ot, t0, rm);", "                 TCGV_UNUSED(a0);", "             }", "             gen_op_mov_v_reg(ot, t1, reg);", "             tcg_gen_andi_tl(cpu_tmp0, t0, 3);", "             tcg_gen_andi_tl(t1, t1, 3);", "             tcg_gen_movi_tl(t2, 0);", "             label1 = gen_new_label();", "             tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1);", "             tcg_gen_andi_tl(t0, t0, ~3);", "             tcg_gen_or_tl(t0, t0, t1);", "             tcg_gen_movi_tl(t2, CC_Z);", "             gen_set_label(label1);", "             if (mod != 3) {", "                 gen_op_st_v(s, ot, t0, a0);", "                 tcg_temp_free(a0);", "            } else {", "                 gen_op_mov_reg_v(ot, rm, t0);", "             }", "             gen_compute_eflags(s);", "             tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z);", "             tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2);", "             tcg_temp_free(t0);", "             tcg_temp_free(t1);", "             tcg_temp_free(t2);", "         }", "         break;", "     case 0x102:  ", "     case 0x103:  ", "         {", "             TCGLabel *label1;", "             TCGv t0;", "             if (!s->pe || s->vm86)", "                 goto illegal_op;", "             ot = dflag != MO_16 ? MO_32 : MO_16;", "             modrm = cpu_ldub_code(env, s->pc++);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0);", "             t0 = tcg_temp_local_new();", "             gen_update_cc_op(s);", "             if (b == 0x102) {", "                 gen_helper_lar(t0, cpu_env, cpu_T0);", "             } else {", "                 gen_helper_lsl(t0, cpu_env, cpu_T0);", "             }", "             tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z);", "             label1 = gen_new_label();", "             tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1);", "             gen_op_mov_reg_v(ot, reg, t0);", "             gen_set_label(label1);", "             set_cc_op(s, CC_OP_EFLAGS);", "             tcg_temp_free(t0);", "         }", "         break;", "     case 0x118:", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         op = (modrm >> 3) & 7;", "         switch(op) {", "         case 0:  ", "         case 1:  ", "         case 2:  ", "         case 3:  ", "             if (mod == 3)", "                 goto illegal_op;", "             gen_nop_modrm(env, s, modrm);", "              ", "             break;", "         default:  ", "             gen_nop_modrm(env, s, modrm);", "             break;", "         }", "         break;", "     case 0x11a:", "         modrm = cpu_ldub_code(env, s->pc++);", "         if (s->flags & HF_MPX_EN_MASK) {", "             mod = (modrm >> 6) & 3;", "             reg = ((modrm >> 3) & 7) | rex_r;", "             if (prefixes & PREFIX_REPZ) {", "                  ", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]);", "             } else if (prefixes & PREFIX_REPNZ) {", "                  ", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 TCGv_i64 notu = tcg_temp_new_i64();", "                 tcg_gen_not_i64(notu, cpu_bndu[reg]);", "                 gen_bndck(env, s, modrm, TCG_COND_GTU, notu);", "                 tcg_temp_free_i64(notu);", "             } else if (prefixes & PREFIX_DATA) {", "                  ", "                 if (reg >= 4 || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 if (mod == 3) {", "                     int reg2 = (modrm & 7) | REX_B(s);", "                     if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {", "                         goto illegal_op;", "                     }", "                     if (s->flags & HF_MPX_IU_MASK) {", "                         tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]);", "                         tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]);", "                     }", "                 } else {", "                     gen_lea_modrm(env, s, modrm);", "                     if (CODE64(s)) {", "                         tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);", "                         tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                     } else {", "                         tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);", "                         tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                     }", "                      ", "                     gen_set_hflag(s, HF_MPX_IU_MASK);", "                 }", "             } else if (mod != 3) {", "                  ", "                 AddressParts a = gen_lea_modrm_0(env, s, modrm);", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16", "                     || a.base < -1) {", "                     goto illegal_op;", "                 }", "                 if (a.base >= 0) {", "                     tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);", "                 } else {", "                     tcg_gen_movi_tl(cpu_A0, 0);", "                 }", "                 gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);", "                 if (a.index >= 0) {", "                     tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);", "                 } else {", "                     tcg_gen_movi_tl(cpu_T0, 0);", "                 }", "                 if (CODE64(s)) {", "                     gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0);", "                     tcg_gen_ld_i64(cpu_bndu[reg], cpu_env,", "                                    offsetof(CPUX86State, mmx_t0.MMX_Q(0)));", "                 } else {", "                     gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0);", "                     tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]);", "                     tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32);", "                 }", "                 gen_set_hflag(s, HF_MPX_IU_MASK);", "             }", "         }", "         gen_nop_modrm(env, s, modrm);", "         break;", "     case 0x11b:", "         modrm = cpu_ldub_code(env, s->pc++);", "         if (s->flags & HF_MPX_EN_MASK) {", "             mod = (modrm >> 6) & 3;", "             reg = ((modrm >> 3) & 7) | rex_r;", "             if (mod != 3 && (prefixes & PREFIX_REPZ)) {", "                  ", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 AddressParts a = gen_lea_modrm_0(env, s, modrm);", "                 if (a.base >= 0) {", "                     tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]);", "                     if (!CODE64(s)) {", "                         tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]);", "                     }", "                 } else if (a.base == -1) {", "                      ", "                     tcg_gen_movi_i64(cpu_bndl[reg], 0);", "                 } else {", "                      ", "                     goto illegal_op;", "                 }", "                 tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a));", "                 if (!CODE64(s)) {", "                     tcg_gen_ext32u_tl(cpu_A0, cpu_A0);", "                 }", "                 tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0);", "                  ", "                 gen_set_hflag(s, HF_MPX_IU_MASK);", "                 break;", "             } else if (prefixes & PREFIX_REPNZ) {", "                  ", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]);", "             } else if (prefixes & PREFIX_DATA) {", "                  ", "                 if (reg >= 4 || s->aflag == MO_16) {", "                     goto illegal_op;", "                 }", "                 if (mod == 3) {", "                     int reg2 = (modrm & 7) | REX_B(s);", "                     if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) {", "                         goto illegal_op;", "                     }", "                     if (s->flags & HF_MPX_IU_MASK) {", "                         tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]);", "                         tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]);", "                     }", "                 } else {", "                     gen_lea_modrm(env, s, modrm);", "                     if (CODE64(s)) {", "                         tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 8);", "                         tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,", "                                             s->mem_index, MO_LEQ);", "                     } else {", "                         tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                         tcg_gen_addi_tl(cpu_A0, cpu_A0, 4);", "                         tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0,", "                                             s->mem_index, MO_LEUL);", "                     }", "                 }", "             } else if (mod != 3) {", "                  ", "                 AddressParts a = gen_lea_modrm_0(env, s, modrm);", "                 if (reg >= 4", "                     || (prefixes & PREFIX_LOCK)", "                     || s->aflag == MO_16", "                     || a.base < -1) {", "                     goto illegal_op;", "                 }", "                 if (a.base >= 0) {", "                     tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp);", "                 } else {", "                     tcg_gen_movi_tl(cpu_A0, 0);", "                 }", "                 gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override);", "                 if (a.index >= 0) {", "                     tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]);", "                 } else {", "                     tcg_gen_movi_tl(cpu_T0, 0);", "                 }", "                 if (CODE64(s)) {", "                     gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0,", "                                         cpu_bndl[reg], cpu_bndu[reg]);", "                 } else {", "                     gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0,", "                                         cpu_bndl[reg], cpu_bndu[reg]);", "                 }", "             }", "         }", "         gen_nop_modrm(env, s, modrm);", "         break;", "     case 0x119: case 0x11c ... 0x11f:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         gen_nop_modrm(env, s, modrm);", "         break;", "     case 0x120:  ", "     case 0x122:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             modrm = cpu_ldub_code(env, s->pc++);", "              ", "             rm = (modrm & 7) | REX_B(s);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             if (CODE64(s))", "                 ot = MO_64;", "             else", "                 ot = MO_32;", "             if ((prefixes & PREFIX_LOCK) && (reg == 0) &&", "                 (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) {", "                 reg = 8;", "             }", "             switch(reg) {", "             case 0:", "             case 2:", "             case 3:", "             case 4:", "             case 8:", "                 gen_update_cc_op(s);", "                 gen_jmp_im(pc_start - s->cs_base);", "                 if (b & 2) {", "                     gen_op_mov_v_reg(ot, cpu_T0, rm);", "                     gen_helper_write_crN(cpu_env, tcg_const_i32(reg),", "                                          cpu_T0);", "                     gen_jmp_im(s->pc - s->cs_base);", "                     gen_eob(s);", "                 } else {", "                     gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg));", "                     gen_op_mov_reg_v(ot, rm, cpu_T0);", "                 }", "                 break;", "             default:", "                 goto unknown_op;", "             }", "         }", "         break;", "     case 0x121:  ", "     case 0x123:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             modrm = cpu_ldub_code(env, s->pc++);", "              ", "             rm = (modrm & 7) | REX_B(s);", "             reg = ((modrm >> 3) & 7) | rex_r;", "             if (CODE64(s))", "                 ot = MO_64;", "             else", "                 ot = MO_32;", "             if (reg >= 8) {", "                 goto illegal_op;", "             }", "             if (b & 2) {", "                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg);", "                 gen_op_mov_v_reg(ot, cpu_T0, rm);", "                 tcg_gen_movi_i32(cpu_tmp2_i32, reg);", "                 gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0);", "                 gen_jmp_im(s->pc - s->cs_base);", "                 gen_eob(s);", "             } else {", "                 gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg);", "                 tcg_gen_movi_i32(cpu_tmp2_i32, reg);", "                 gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32);", "                 gen_op_mov_reg_v(ot, rm, cpu_T0);", "             }", "         }", "         break;", "     case 0x106:  ", "         if (s->cpl != 0) {", "             gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);", "         } else {", "             gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0);", "             gen_helper_clts(cpu_env);", "              ", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "         }", "         break;", "      ", "     case 0x1c3:  ", "         if (!(s->cpuid_features & CPUID_SSE2))", "             goto illegal_op;", "         ot = mo_64_32(dflag);", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         if (mod == 3)", "             goto illegal_op;", "         reg = ((modrm >> 3) & 7) | rex_r;", "          ", "         gen_ldst_modrm(env, s, modrm, ot, reg, 1);", "         break;", "     case 0x1ae:", "         modrm = cpu_ldub_code(env, s->pc++);", "         switch (modrm) {", "         CASE_MODRM_MEM_OP(0):  ", "             if (!(s->cpuid_features & CPUID_FXSR)", "                 || (prefixes & PREFIX_LOCK)) {", "                 goto illegal_op;", "             }", "             if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {", "                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "                 break;", "             }", "             gen_lea_modrm(env, s, modrm);", "             gen_helper_fxsave(cpu_env, cpu_A0);", "             break;", " ", "         CASE_MODRM_MEM_OP(1):  ", "             if (!(s->cpuid_features & CPUID_FXSR)", "                 || (prefixes & PREFIX_LOCK)) {", "                 goto illegal_op;", "             }", "             if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) {", "                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "                 break;", "             }", "             gen_lea_modrm(env, s, modrm);", "             gen_helper_fxrstor(cpu_env, cpu_A0);", "             break;", " ", "         CASE_MODRM_MEM_OP(2):  ", "             if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {", "                 goto illegal_op;", "             }", "             if (s->flags & HF_TS_MASK) {", "                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "                 break;", "             }", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL);", "             gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32);", "             break;", " ", "         CASE_MODRM_MEM_OP(3):  ", "             if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) {", "                 goto illegal_op;", "             }", "             if (s->flags & HF_TS_MASK) {", "                 gen_exception(s, EXCP07_PREX, pc_start - s->cs_base);", "                 break;", "             }", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr));", "             gen_op_st_v(s, MO_32, cpu_T0, cpu_A0);", "             break;", " ", "         CASE_MODRM_MEM_OP(4):  ", "             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0", "                 || (prefixes & (PREFIX_LOCK | PREFIX_DATA", "                                 | PREFIX_REPZ | PREFIX_REPNZ))) {", "                 goto illegal_op;", "             }", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],", "                                   cpu_regs[R_EDX]);", "             gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64);", "             break;", " ", "         CASE_MODRM_MEM_OP(5):  ", "             if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0", "                 || (prefixes & (PREFIX_LOCK | PREFIX_DATA", "                                 | PREFIX_REPZ | PREFIX_REPNZ))) {", "                 goto illegal_op;", "             }", "             gen_lea_modrm(env, s, modrm);", "             tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],", "                                   cpu_regs[R_EDX]);", "             gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64);", "              ", "             gen_update_cc_op(s);", "             gen_jmp_im(s->pc - s->cs_base);", "             gen_eob(s);", "             break;", " ", "         CASE_MODRM_MEM_OP(6):  ", "             if (prefixes & PREFIX_LOCK) {", "                 goto illegal_op;", "             }", "             if (prefixes & PREFIX_DATA) {", "                  ", "                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) {", "                     goto illegal_op;", "                 }", "                 gen_nop_modrm(env, s, modrm);", "             } else {", "                  ", "                 if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0", "                     || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0", "                     || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) {", "                     goto illegal_op;", "                 }", "                 gen_lea_modrm(env, s, modrm);", "                 tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX],", "                                       cpu_regs[R_EDX]);", "                 gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64);", "             }", "             break;", " ", "         CASE_MODRM_MEM_OP(7):  ", "             if (prefixes & PREFIX_LOCK) {", "                 goto illegal_op;", "             }", "             if (prefixes & PREFIX_DATA) {", "                  ", "                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) {", "                     goto illegal_op;", "                 }", "             } else {", "                  ", "                 if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ))", "                     || !(s->cpuid_features & CPUID_CLFLUSH)) {", "                     goto illegal_op;", "                 }", "             }", "             gen_nop_modrm(env, s, modrm);", "             break;", " ", "         case 0xc0 ... 0xc7:  ", "         case 0xc8 ... 0xc8:  ", "         case 0xd0 ... 0xd7:  ", "         case 0xd8 ... 0xd8:  ", "             if (CODE64(s)", "                 && (prefixes & PREFIX_REPZ)", "                 && !(prefixes & PREFIX_LOCK)", "                 && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) {", "                 TCGv base, treg, src, dst;", " ", "                  ", "                 tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK);", "                 gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32);", " ", "                 base = cpu_seg_base[modrm & 8 ? R_GS : R_FS];", "                 treg = cpu_regs[(modrm & 7) | REX_B(s)];", " ", "                 if (modrm & 0x10) {", "                      ", "                     dst = base, src = treg;", "                 } else {", "                      ", "                     dst = treg, src = base;", "                 }", " ", "                 if (s->dflag == MO_32) {", "                     tcg_gen_ext32u_tl(dst, src);", "                 } else {", "                     tcg_gen_mov_tl(dst, src);", "                 }", "                 break;", "             }", "             goto unknown_op;", " ", "         case 0xf8:  ", "             if (prefixes & PREFIX_DATA) {", "                  ", "                 if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT)", "                     || (prefixes & PREFIX_LOCK)) {", "                     goto illegal_op;", "                 }", "                 break;", "             }", "              ", "         case 0xf9 ... 0xff:  ", "             if (!(s->cpuid_features & CPUID_SSE)", "                 || (prefixes & PREFIX_LOCK)) {", "                 goto illegal_op;", "             }", "             tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC);", "             break;", "         case 0xe8 ... 0xef:  ", "             if (!(s->cpuid_features & CPUID_SSE)", "                 || (prefixes & PREFIX_LOCK)) {", "                 goto illegal_op;", "             }", "             tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC);", "             break;", "         case 0xf0 ... 0xf7:  ", "             if (!(s->cpuid_features & CPUID_SSE2)", "                 || (prefixes & PREFIX_LOCK)) {", "                 goto illegal_op;", "             }", "             tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC);", "             break;", " ", "         default:", "             goto unknown_op;", "         }", "         break;", " ", "     case 0x10d:  ", "         modrm = cpu_ldub_code(env, s->pc++);", "         mod = (modrm >> 6) & 3;", "         if (mod == 3)", "             goto illegal_op;", "         gen_nop_modrm(env, s, modrm);", "         break;", "     case 0x1aa:  ", "         gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM);", "         if (!(s->flags & HF_SMM_MASK))", "             goto illegal_op;", "         gen_update_cc_op(s);", "         gen_jmp_im(s->pc - s->cs_base);", "         gen_helper_rsm(cpu_env);", "         gen_eob(s);", "         break;", "     case 0x1b8:  ", "         if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) !=", "              PREFIX_REPZ)", "             goto illegal_op;", "         if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))", "             goto illegal_op;", " ", "         modrm = cpu_ldub_code(env, s->pc++);", "         reg = ((modrm >> 3) & 7) | rex_r;", " ", "         if (s->prefix & PREFIX_DATA) {", "             ot = MO_16;", "         } else {", "             ot = mo_64_32(dflag);", "         }", " ", "         gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);", "         gen_extu(ot, cpu_T0);", "         tcg_gen_mov_tl(cpu_cc_src, cpu_T0);", "         tcg_gen_ctpop_tl(cpu_T0, cpu_T0);", "         gen_op_mov_reg_v(ot, reg, cpu_T0);", " ", "         set_cc_op(s, CC_OP_POPCNT);", "         break;", "     case 0x10e ... 0x10f:", "          ", "         s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);", "     case 0x110 ... 0x117:", "     case 0x128 ... 0x12f:", "     case 0x138 ... 0x13a:", "     case 0x150 ... 0x179:", "     case 0x17c ... 0x17f:", "     case 0x1c2:", "     case 0x1c4 ... 0x1c6:", "     case 0x1d0 ... 0x1fe:", "         gen_sse(env, s, b, pc_start, rex_r);", "         break;", "     default:", "         goto unknown_op;", "     }", "     return s->pc;", "  illegal_op:", "     gen_illegal_opcode(s);", "     return s->pc;", "  unknown_op:", "     gen_unknown_opcode(env, s);", "     return s->pc;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static av_cold int vqa_decode_init(AVCodecContext *avctx)", " {", "     VqaContext *s = avctx->priv_data;", "     int i, j, codebook_index;", " ", "     s->avctx = avctx;", "     avctx->pix_fmt = PIX_FMT_PAL8;", " ", "      ", "     if (s->avctx->extradata_size != VQA_HEADER_SIZE) {", "         av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);", "         return -1;", "     }", " ", "      ", "     s->vqa_version = s->avctx->extradata[0];", "     s->width = AV_RL16(&s->avctx->extradata[6]);", "     s->height = AV_RL16(&s->avctx->extradata[8]);", "     if(av_image_check_size(s->width, s->height, 0, avctx)){", "         s->width= s->height= 0;", "         return -1;", "     }", "     s->vector_width = s->avctx->extradata[10];", "     s->vector_height = s->avctx->extradata[11];", "     s->partial_count = s->partial_countdown = s->avctx->extradata[13];", " ", "      ", "     if ((s->vector_width != 4) ||", "         ((s->vector_height != 2) && (s->vector_height != 4))) {", "          ", "          return -1;", "      }", "  ", "     if (s->width  & (s->vector_width  - 1) ||", "         s->height & (s->vector_height - 1)) {", "         av_log(avctx, AV_LOG_ERROR, \"Image size not multiple of block size\\n\");", "         return AVERROR_INVALIDDATA;", "     }", " ", "       ", "      s->codebook_size = MAX_CODEBOOK_SIZE;", "      s->codebook = av_malloc(s->codebook_size);", "      ", "     s->decode_buffer_size = (s->width / s->vector_width) *", "         (s->height / s->vector_height) * 2;", "     s->decode_buffer = av_malloc(s->decode_buffer_size);", "     if (!s->decode_buffer)", "         goto fail;", " ", "      ", "     if (s->vector_height == 4) {", "         codebook_index = 0xFF00 * 16;", "         for (i = 0; i < 256; i++)", "             for (j = 0; j < 16; j++)", "                 s->codebook[codebook_index++] = i;", "     } else {", "         codebook_index = 0xF00 * 8;", "         for (i = 0; i < 256; i++)", "             for (j = 0; j < 8; j++)", "                 s->codebook[codebook_index++] = i;", "     }", "     s->next_codebook_buffer_index = 0;", " ", "     s->frame.data[0] = NULL;", " ", "     return 0;", " fail:", "     av_freep(&s->codebook);", "     av_freep(&s->next_codebook_buffer);", "     av_freep(&s->decode_buffer);", "     return AVERROR(ENOMEM);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void free_user(struct kref *ref)", "  {", "  \tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);", " \tcleanup_srcu_struct(&user->release_barrier);", "  \tkfree(user);", "  }"], "ner_tags": [0, 0, 0, 1, 0, 0]}
{"tokens": ["double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)", "{", "mp4object *mp4 = (mp4object *)handle;", "if (mp4 == NULL) return 0.0;", "", "uint32_t key, insamples;", "uint32_t repeat, outsamples;", "GPMF_stream find_stream;", "", "if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;", "", "key = GPMF_Key(gs);", "repeat = GPMF_Repeat(gs);", "if (rate == 0.0)", "rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);", "", "if (rate == 0.0)", "{", "*in = *out = 0.0;", "return 0.0;", "}", "", "GPMF_CopyState(gs, &find_stream);", "if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))", "{", "outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));", "insamples = outsamples - repeat;", "", "*in = ((double)insamples / (double)rate);", "*out = ((double)outsamples / (double)rate);", "}", "else", "{", "", "*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);", "}", "return rate;", "}"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* ctx) override {", "const Tensor& a = ctx->input(0);", "const Tensor& b = ctx->input(1);", "OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(a.shape()),", "errors::InvalidArgument(\"a is not a matrix\"));", "OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(b.shape()),", "errors::InvalidArgument(\"b is not a matrix\"));", "", "const int m = transpose_a_ ? a.dim_size(1) : a.dim_size(0);", "const int k = transpose_a_ ? a.dim_size(0) : a.dim_size(1);", "const int n = transpose_b_ ? b.dim_size(0) : b.dim_size(1);", "const int k2 = transpose_b_ ? b.dim_size(1) : b.dim_size(0);", "", "OP_REQUIRES(ctx, k == k2,", "errors::InvalidArgument(", "\"Matrix size incompatible: a: \", a.shape().DebugString(),", "\", b: \", b.shape().DebugString()));", "Tensor* output = nullptr;", "OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({m, n}), &output));", "", "if (k == 0) {", "", "", "functor::SetZeroFunctor<CPUDevice, float> f;", "f(ctx->eigen_device<CPUDevice>(), output->flat<float>());", "return;", "}", "", "auto out = output->matrix<float>();", "", "std::unique_ptr<Tensor> a_float;", "std::unique_ptr<Tensor> b_float;", "if (!a_is_sparse_ && !b_is_sparse_) {", "auto left = &a;", "auto right = &b;", "", "if (std::is_same<TL, bfloat16>::value) {", "a_float.reset(new Tensor(DT_FLOAT, a.shape()));", "BFloat16ToFloat(a.flat<bfloat16>().data(),", "a_float->flat<float>().data(), a.NumElements());", "left = a_float.get();", "}", "if (std::is_same<TR, bfloat16>::value) {", "b_float.reset(new Tensor(DT_FLOAT, b.shape()));", "BFloat16ToFloat(b.flat<bfloat16>().data(),", "b_float->flat<float>().data(), b.NumElements());", "right = b_float.get();", "}", "Eigen::array<Eigen::IndexPair<Eigen::DenseIndex>, 1> dim_pair;", "dim_pair[0].first = transpose_a_ ? 0 : 1;", "dim_pair[0].second = transpose_b_ ? 1 : 0;", "", "out.device(ctx->template eigen_device<CPUDevice>()) =", "left->matrix<float>().contract(right->matrix<float>(), dim_pair);", "return;", "}", "", "auto left = &a;", "auto right = &b;", "bool transpose_output = false;", "bool transpose_a = transpose_a_;", "bool transpose_b = transpose_b_;", "if (!a_is_sparse_) {", "", "", "std::swap(left, right);", "std::swap(transpose_a, transpose_b);", "transpose_a = !transpose_a;", "transpose_b = !transpose_b;", "transpose_output = !transpose_output;", "}", "", "std::unique_ptr<Tensor> right_tr;", "if (transpose_b) {", "", "", "OP_REQUIRES(ctx, right->dim_size(0) != 0,", "errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));", "OP_REQUIRES(ctx, right->dim_size(1) != 0,", "errors::InvalidArgument(\"b has an entry 0 in it's shape.\"));", "right_tr.reset(", "new Tensor(right->dtype(),", "TensorShape({right->dim_size(1), right->dim_size(0)})));", "", "const auto perm = dsizes_10();", "if (transpose_output) {", "right_tr->matrix<TL>().device(ctx->template eigen_device<CPUDevice>()) =", "right->matrix<TL>().shuffle(perm);", "} else {", "right_tr->matrix<TR>().device(ctx->template eigen_device<CPUDevice>()) =", "right->matrix<TR>().shuffle(perm);", "}", "right = right_tr.get();", "}", "", "if (transpose_output) {", "DoMatMul<TR, TL>::Compute(&this->cache_tr_, left->matrix<TR>(),", "right->matrix<TL>(), transpose_a,", "ctx->device()->tensorflow_cpu_worker_threads(),", "transpose_output, &out);", "} else {", "DoMatMul<TL, TR>::Compute(&this->cache_nt_, left->matrix<TL>(),", "right->matrix<TR>(), transpose_a,", "ctx->device()->tensorflow_cpu_worker_threads(),", "transpose_output, &out);", "}", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["rb_fiddle_handle_sym(VALUE self, VALUE sym)", "{", "struct dl_handle *fiddle_handle;", "", "TypedData_Get_Struct(self, struct dl_handle, &fiddle_handle_data_type, fiddle_handle);", "if( ! fiddle_handle->open ){", "rb_raise(rb_eFiddleError, \"closed handle\");", "}", "", "return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]}
{"tokens": [" on_unregister_handler(TCMUService1HandlerManager1 *interface,", " \t\t      GDBusMethodInvocation *invocation,", " \t\t      gchar *subtype,", " \t\t      gpointer user_data)", " {", " \tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);", " \tstruct dbus_info *info = handler ? handler->opaque : NULL;", " ", " \tif (!handler) {", " \t\tg_dbus_method_invocation_return_value(invocation,", " \t\t\tg_variant_new(\"(bs)\", FALSE,", "  \t\t\t\t      \"unknown subtype\"));", "  \t\treturn TRUE;", "  \t}", " \telse if (handler->_is_dbus_handler != 1) {", " \t\tg_dbus_method_invocation_return_value(invocation,", " \t\t\tg_variant_new(\"(bs)\", FALSE,", " \t\t\t\t      \"cannot unregister internal handler\"));", " \t\treturn TRUE;", " \t}", " ", "  \tdbus_unexport_handler(handler);", "\ttcmur_unregister_handler(handler);", " \ttcmur_unregister_dbus_handler(handler);", " ", "  \tg_bus_unwatch_name(info->watcher_id);", "  \tg_free(info);", "  \tg_free(handler);", " \tg_dbus_method_invocation_return_value(invocation,", " \t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));", " \treturn TRUE;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int phar_get_entry_data(phar_entry_data **ret, char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC)  ", " {", " \tphar_archive_data *phar;", " \tphar_entry_info *entry;", " \tint for_write  = mode[0] != 'r' || mode[1] == '+';", " \tint for_append = mode[0] == 'a';", " \tint for_create = mode[0] != 'r';", " \tint for_trunc  = mode[0] == 'w';", " ", " \tif (!ret) {", " \t\treturn FAILURE;", " \t}", " ", " \t*ret = NULL;", " ", " \tif (error) {", " \t\t*error = NULL;", " \t}", " ", " \tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \tif (for_write && PHAR_G(readonly) && !phar->is_data) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, disabled by ini setting\", path, fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \tif (!path_len) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: file \\\"\\\" in phar \\\"%s\\\" cannot be empty\", fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " really_get_entry:", " \tif (allow_dir) {", " \t\tif ((entry = phar_get_entry_info_dir(phar, path, path_len, allow_dir, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {", " \t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {", " \t\t\t\treturn SUCCESS;", " \t\t\t}", " \t\t\treturn FAILURE;", " \t\t}", " \t} else {", " \t\tif ((entry = phar_get_entry_info(phar, path, path_len, for_create && !PHAR_G(readonly) && !phar->is_data ? NULL : error, security TSRMLS_CC)) == NULL) {", " \t\t\tif (for_create && (!PHAR_G(readonly) || phar->is_data)) {", " \t\t\t\treturn SUCCESS;", " \t\t\t}", " \t\t\treturn FAILURE;", " \t\t}", " \t}", " ", " \tif (for_write && phar->is_persistent) {", " \t\tif (FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, could not make cached phar writeable\", path, fname);", " \t\t\t}", " \t\t\treturn FAILURE;", " \t\t} else {", " \t\t\tgoto really_get_entry;", " \t\t}", " \t}", " ", " \tif (entry->is_modified && !for_write) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for reading, writable file pointers are open\", path, fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \tif (entry->fp_refcount && for_write) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be opened for writing, readable file pointers are open\", path, fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \tif (entry->is_deleted) {", " \t\tif (!for_create) {", " \t\t\treturn FAILURE;", " \t\t}", " \t\tentry->is_deleted = 0;", " \t}", " ", " \tif (entry->is_dir) {", " \t\t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));", " \t\t(*ret)->position = 0;", " \t\t(*ret)->fp = NULL;", " \t\t(*ret)->phar = phar;", " \t\t(*ret)->for_write = for_write;", " \t\t(*ret)->internal_file = entry;", " \t\t(*ret)->is_zip = entry->is_zip;", " \t\t(*ret)->is_tar = entry->is_tar;", " ", " \t\tif (!phar->is_persistent) {", " \t\t\t++(entry->phar->refcount);", " \t\t\t++(entry->fp_refcount);", " \t\t}", " ", " \t\treturn SUCCESS;", " \t}", " ", " \tif (entry->fp_type == PHAR_MOD) {", " \t\tif (for_trunc) {", " \t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {", " \t\t\t\treturn FAILURE;", " \t\t\t}", " \t\t} else if (for_append) {", " \t\t\tphar_seek_efp(entry, 0, SEEK_END, 0, 0 TSRMLS_CC);", " \t\t}", " \t} else {", " \t\tif (for_write) {", " \t\t\tif (entry->link) {", " \t\t\t\tefree(entry->link);", " \t\t\t\tentry->link = NULL;", " \t\t\t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');", " \t\t\t}", " ", " \t\t\tif (for_trunc) {", " \t\t\t\tif (FAILURE == phar_create_writeable_entry(phar, entry, error TSRMLS_CC)) {", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " \t\t\t} else {", " \t\t\t\tif (FAILURE == phar_separate_entry_fp(entry, error TSRMLS_CC)) {", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " \t\t\t}", " \t\t} else {", " \t\t\tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {", " \t\t\t\treturn FAILURE;", " \t\t\t}", " \t\t}", " \t}", " ", " \t*ret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));", " \t(*ret)->position = 0;", " \t(*ret)->phar = phar;", " \t(*ret)->for_write = for_write;", " \t(*ret)->internal_file = entry;", " \t(*ret)->is_zip = entry->is_zip;", "         (*ret)->is_tar = entry->is_tar;", "         (*ret)->fp = phar_get_efp(entry, 1 TSRMLS_CC);", "         if (entry->link) {", "               (*ret)->zero = phar_get_fp_offset(phar_get_link_source(entry TSRMLS_CC) TSRMLS_CC);", "                phar_entry_info *link = phar_get_link_source(entry TSRMLS_CC);", "                if(!link) {", "                        return FAILURE;", "                }", "                (*ret)->zero = phar_get_fp_offset(link TSRMLS_CC);", "         } else {", "                 (*ret)->zero = phar_get_fp_offset(entry TSRMLS_CC);", "         }", " \t}", " ", " \treturn SUCCESS;", " }", "  ", " ", "  ", " phar_entry_data *phar_get_or_create_entry_data(char *fname, int fname_len, char *path, int path_len, char *mode, char allow_dir, char **error, int security TSRMLS_DC)  ", " {", " \tphar_archive_data *phar;", " \tphar_entry_info *entry, etemp;", " \tphar_entry_data *ret;", " \tconst char *pcr_error;", " \tchar is_dir;", " ", " #ifdef PHP_WIN32", " \tphar_unixify_path_separators(path, path_len);", " #endif", " ", " \tis_dir = (path_len && path[path_len - 1] == '/') ? 1 : 0;", " ", " \tif (FAILURE == phar_get_archive(&phar, fname, fname_len, NULL, 0, error TSRMLS_CC)) {", " \t\treturn NULL;", " \t}", " ", " \tif (FAILURE == phar_get_entry_data(&ret, fname, fname_len, path, path_len, mode, allow_dir, error, security TSRMLS_CC)) {", " \t\treturn NULL;", " \t} else if (ret) {", " \t\treturn ret;", " \t}", " ", " \tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {", " \t\tif (error) {", " \t\t\tspprintf(error, 0, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \tif (phar->is_persistent && FAILURE == phar_copy_on_write(&phar TSRMLS_CC)) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: file \\\"%s\\\" in phar \\\"%s\\\" cannot be created, could not make cached phar writeable\", path, fname);", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \t ", " \tret = (phar_entry_data *) emalloc(sizeof(phar_entry_data));", " ", " \t ", " \tmemset(&etemp, 0, sizeof(phar_entry_info));", " \tetemp.filename_len = path_len;", " \tetemp.fp_type = PHAR_MOD;", " \tetemp.fp = php_stream_fopen_tmpfile();", " ", " \tif (!etemp.fp) {", " \t\tif (error) {", " \t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");", " \t\t}", " \t\tefree(ret);", " \t\treturn NULL;", " \t}", " ", " \tetemp.fp_refcount = 1;", " ", " \tif (allow_dir == 2) {", " \t\tetemp.is_dir = 1;", " \t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_DIR;", " \t} else {", " \t\tetemp.flags = etemp.old_flags = PHAR_ENT_PERM_DEF_FILE;", " \t}", " \tif (is_dir) {", " \t\tetemp.filename_len--;  ", " \t\tpath_len--;", " \t}", " ", " \tphar_add_virtual_dirs(phar, path, path_len TSRMLS_CC);", " \tetemp.is_modified = 1;", " \tetemp.timestamp = time(0);", " \tetemp.is_crc_checked = 1;", " \tetemp.phar = phar;", " \tetemp.filename = estrndup(path, path_len);", " \tetemp.is_zip = phar->is_zip;", " ", " \tif (phar->is_tar) {", " \t\tetemp.is_tar = phar->is_tar;", " \t\tetemp.tar_type = etemp.is_dir ? TAR_DIR : TAR_FILE;", " \t}", " ", " \tif (FAILURE == zend_hash_add(&phar->manifest, etemp.filename, path_len, (void*)&etemp, sizeof(phar_entry_info), (void **) &entry)) {", " \t\tphp_stream_close(etemp.fp);", " \t\tif (error) {", " \t\t\tspprintf(error, 0, \"phar error: unable to add new entry \\\"%s\\\" to phar \\\"%s\\\"\", etemp.filename, phar->fname);", " \t\t}", " \t\tefree(ret);", " \t\tefree(etemp.filename);", " \t\treturn NULL;", " \t}", " ", " \tif (!entry) {", " \t\tphp_stream_close(etemp.fp);", " \t\tefree(etemp.filename);", " \t\tefree(ret);", " \t\treturn NULL;", " \t}", " ", " \t++(phar->refcount);", " \tret->phar = phar;", " \tret->fp = entry->fp;", " \tret->position = ret->zero = 0;", " \tret->for_write = 1;", " \tret->is_zip = entry->is_zip;", " \tret->is_tar = entry->is_tar;", " \tret->internal_file = entry;", " ", " \treturn ret;", " }", "  ", " ", "  ", " int phar_open_archive_fp(phar_archive_data *phar TSRMLS_DC)  ", " {", " \tif (phar_get_pharfp(phar TSRMLS_CC)) {", " \t\treturn SUCCESS;", " \t}", " ", " \tif (php_check_open_basedir(phar->fname TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \tphar_set_pharfp(phar, php_stream_open_wrapper(phar->fname, \"rb\", IGNORE_URL|STREAM_MUST_SEEK|0, NULL) TSRMLS_CC);", " ", " \tif (!phar_get_pharfp(phar TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \treturn SUCCESS;", " }", "  ", " ", "  ", " int phar_copy_entry_fp(phar_entry_info *source, phar_entry_info *dest, char **error TSRMLS_DC)  ", " {", " \tphar_entry_info *link;", " ", " \tif (FAILURE == phar_open_entry_fp(source, error, 1 TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \tif (dest->link) {", " \t\tefree(dest->link);", " \t\tdest->link = NULL;", " \t\tdest->tar_type = (dest->is_tar ? TAR_FILE : '\\0');", " \t}", " ", " \tdest->fp_type = PHAR_MOD;", " \tdest->offset = 0;", " \tdest->is_modified = 1;", " \tdest->fp = php_stream_fopen_tmpfile();", " \tif (dest->fp == NULL) {", " \t\tspprintf(error, 0, \"phar error: unable to create temporary file\");", " \t\treturn EOF;", " \t}", " \tphar_seek_efp(source, 0, SEEK_SET, 0, 1 TSRMLS_CC);", " \tlink = phar_get_link_source(source TSRMLS_CC);", " ", " \tif (!link) {", " \t\tlink = source;", " \t}", " ", " \tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), dest->fp, link->uncompressed_filesize, NULL)) {", " \t\tphp_stream_close(dest->fp);", " \t\tdest->fp_type = PHAR_FP;", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: unable to copy contents of file \\\"%s\\\" to \\\"%s\\\" in phar archive \\\"%s\\\"\", source->filename, dest->filename, source->phar->fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \treturn SUCCESS;", " }", "  ", " ", "  ", " int phar_open_entry_fp(phar_entry_info *entry, char **error, int follow_links TSRMLS_DC)  ", " {", " \tphp_stream_filter *filter;", " \tphar_archive_data *phar = entry->phar;", " \tchar *filtername;", " \toff_t loc;", " \tphp_stream *ufp;", " \tphar_entry_data dummy;", " ", " \tif (follow_links && entry->link) {", " \t\tphar_entry_info *link_entry = phar_get_link_source(entry TSRMLS_CC);", " \t\tif (link_entry && link_entry != entry) {", " \t\t\treturn phar_open_entry_fp(link_entry, error, 1 TSRMLS_CC);", " \t\t}", " \t}", " ", " \tif (entry->is_modified) {", " \t\treturn SUCCESS;", " \t}", " ", " \tif (entry->fp_type == PHAR_TMP) {", " \t\tif (!entry->fp) {", " \t\t\tentry->fp = php_stream_open_wrapper(entry->tmp, \"rb\", STREAM_MUST_SEEK|0, NULL);", " \t\t}", " \t\treturn SUCCESS;", " \t}", " ", " \tif (entry->fp_type != PHAR_FP) {", " \t\t ", " \t\treturn SUCCESS;", " \t}", " ", " \tif (!phar_get_pharfp(phar TSRMLS_CC)) {", " \t\tif (FAILURE == phar_open_archive_fp(phar TSRMLS_CC)) {", " \t\t\tspprintf(error, 4096, \"phar error: Cannot open phar archive \\\"%s\\\" for reading\", phar->fname);", " \t\t\treturn FAILURE;", " \t\t}", " \t}", " ", " \tif ((entry->old_flags && !(entry->old_flags & PHAR_ENT_COMPRESSION_MASK)) || !(entry->flags & PHAR_ENT_COMPRESSION_MASK)) {", " \t\tdummy.internal_file = entry;", " \t\tdummy.phar = phar;", " \t\tdummy.zero = entry->offset;", " \t\tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);", " \t\tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {", " \t\t\treturn FAILURE;", " \t\t}", " \t\treturn SUCCESS;", " \t}", " ", " \tif (!phar_get_entrypufp(entry TSRMLS_CC)) {", " \t\tphar_set_entrypufp(entry, php_stream_fopen_tmpfile() TSRMLS_CC);", " \t\tif (!phar_get_entrypufp(entry TSRMLS_CC)) {", " \t\t\tspprintf(error, 4096, \"phar error: Cannot open temporary file for decompressing phar archive \\\"%s\\\" file \\\"%s\\\"\", phar->fname, entry->filename);", " \t\t\treturn FAILURE;", " \t\t}", " \t}", " ", " \tdummy.internal_file = entry;", " \tdummy.phar = phar;", " \tdummy.zero = entry->offset;", " \tdummy.fp = phar_get_pharfp(phar TSRMLS_CC);", " \tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 1 TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \tufp = phar_get_entrypufp(entry TSRMLS_CC);", " ", " \tif ((filtername = phar_decompress_filter(entry, 0)) != NULL) {", " \t\tfilter = php_stream_filter_create(filtername, NULL, 0 TSRMLS_CC);", " \t} else {", " \t\tfilter = NULL;", " \t}", " ", " \tif (!filter) {", " \t\tspprintf(error, 4096, \"phar error: unable to read phar \\\"%s\\\" (cannot create %s filter while decompressing file \\\"%s\\\")\", phar->fname, phar_decompress_filter(entry, 1), entry->filename);", " \t\treturn FAILURE;", " \t}", " ", " \t ", " \t ", " \tphp_stream_seek(ufp, 0, SEEK_END);", " \tloc = php_stream_tell(ufp);", " \tphp_stream_filter_append(&ufp->writefilters, filter);", " \tphp_stream_seek(phar_get_entrypfp(entry TSRMLS_CC), phar_get_fp_offset(entry TSRMLS_CC), SEEK_SET);", " ", " \tif (entry->uncompressed_filesize) {", " \t\tif (SUCCESS != phar_stream_copy_to_stream(phar_get_entrypfp(entry TSRMLS_CC), ufp, entry->compressed_filesize, NULL)) {", " \t\t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);", " \t\t\tphp_stream_filter_remove(filter, 1 TSRMLS_CC);", " \t\t\treturn FAILURE;", " \t\t}", " \t}", " ", " \tphp_stream_filter_flush(filter, 1);", " \tphp_stream_flush(ufp);", " \tphp_stream_filter_remove(filter, 1 TSRMLS_CC);", " ", " \tif (php_stream_tell(ufp) - loc != (off_t) entry->uncompressed_filesize) {", " \t\tspprintf(error, 4096, \"phar error: internal corruption of phar \\\"%s\\\" (actual filesize mismatch on file \\\"%s\\\")\", phar->fname, entry->filename);", " \t\treturn FAILURE;", " \t}", " ", " \tentry->old_flags = entry->flags;", " ", " \t ", " \tphar_set_fp_type(entry, PHAR_UFP, loc TSRMLS_CC);", " \tdummy.zero = entry->offset;", " \tdummy.fp = ufp;", " \tif (FAILURE == phar_postprocess_file(&dummy, entry->crc32, error, 0 TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " \treturn SUCCESS;", " }", "  ", " ", " int phar_create_writeable_entry(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC)  ", " {", " \tif (entry->fp_type == PHAR_MOD) {", " \t\t ", " \t\tphp_stream_truncate_set_size(entry->fp, 0);", " ", " \t\tentry->old_flags = entry->flags;", " \t\tentry->is_modified = 1;", " \t\tphar->is_modified = 1;", " \t\t ", " \t\tentry->uncompressed_filesize = 0;", " \t\tentry->compressed_filesize = 0;", " \t\tentry->crc32 = 0;", " \t\tentry->flags = PHAR_ENT_PERM_DEF_FILE;", " \t\tentry->fp_type = PHAR_MOD;", " \t\tentry->offset = 0;", " \t\treturn SUCCESS;", " \t}", " ", " \tif (error) {", " \t\t*error = NULL;", " \t}", " ", " \t ", " \tif (entry->link) {", " \t\tefree(entry->link);", " \t\tentry->link = NULL;", " \t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');", " \t}", " ", " \tentry->fp = php_stream_fopen_tmpfile();", " ", " \tif (!entry->fp) {", " \t\tif (error) {", " \t\t\tspprintf(error, 0, \"phar error: unable to create temporary file\");", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \tentry->old_flags = entry->flags;", " \tentry->is_modified = 1;", " \tphar->is_modified = 1;", " \t ", " \tentry->uncompressed_filesize = 0;", " \tentry->compressed_filesize = 0;", " \tentry->crc32 = 0;", " \tentry->flags = PHAR_ENT_PERM_DEF_FILE;", " \tentry->fp_type = PHAR_MOD;", " \tentry->offset = 0;", " \treturn SUCCESS;", " }", "  ", " ", " int phar_separate_entry_fp(phar_entry_info *entry, char **error TSRMLS_DC)  ", " {", " \tphp_stream *fp;", " \tphar_entry_info *link;", " ", " \tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {", " \t\treturn FAILURE;", " \t}", " ", " \tif (entry->fp_type == PHAR_MOD) {", " \t\treturn SUCCESS;", " \t}", " ", " \tfp = php_stream_fopen_tmpfile();", " \tif (fp == NULL) {", " \t\tspprintf(error, 0, \"phar error: unable to create temporary file\");", " \t\treturn FAILURE;", " \t}", " \tphar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC);", " \tlink = phar_get_link_source(entry TSRMLS_CC);", " ", " \tif (!link) {", " \t\tlink = entry;", " \t}", " ", " \tif (SUCCESS != phar_stream_copy_to_stream(phar_get_efp(link, 0 TSRMLS_CC), fp, link->uncompressed_filesize, NULL)) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: cannot separate entry file \\\"%s\\\" contents in phar archive \\\"%s\\\" for write access\", entry->filename, entry->phar->fname);", " \t\t}", " \t\treturn FAILURE;", " \t}", " ", " \tif (entry->link) {", " \t\tefree(entry->link);", " \t\tentry->link = NULL;", " \t\tentry->tar_type = (entry->is_tar ? TAR_FILE : '\\0');", " \t}", " ", " \tentry->offset = 0;", " \tentry->fp = fp;", " \tentry->fp_type = PHAR_MOD;", " \tentry->is_modified = 1;", " \treturn SUCCESS;", " }", "  ", " ", "  ", " phar_entry_info * phar_open_jit(phar_archive_data *phar, phar_entry_info *entry, char **error TSRMLS_DC)  ", " {", " \tif (error) {", " \t\t*error = NULL;", " \t}", " \t ", " \tif (FAILURE == phar_open_entry_fp(entry, error, 1 TSRMLS_CC)) {", " \t\treturn NULL;", " \t}", " \tif (-1 == phar_seek_efp(entry, 0, SEEK_SET, 0, 1 TSRMLS_CC)) {", " \t\tspprintf(error, 4096, \"phar error: cannot seek to start of file \\\"%s\\\" in phar \\\"%s\\\"\", entry->filename, phar->fname);", " \t\treturn NULL;", " \t}", " \treturn entry;", " }", "  ", " ", " PHP_PHAR_API int phar_resolve_alias(char *alias, int alias_len, char **filename, int *filename_len TSRMLS_DC)   {", " \tphar_archive_data **fd_ptr;", " \tif (PHAR_GLOBALS->phar_alias_map.arBuckets", " \t\t\t&& SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void**)&fd_ptr)) {", " \t\t*filename = (*fd_ptr)->fname;", " \t\t*filename_len = (*fd_ptr)->fname_len;", " \t\treturn SUCCESS;", " \t}", " \treturn FAILURE;", " }", "  ", " ", " int phar_free_alias(phar_archive_data *phar, char *alias, int alias_len TSRMLS_DC)  ", " {", " \tif (phar->refcount || phar->is_persistent) {", " \t\treturn FAILURE;", " \t}", " ", " \t ", " \tif (zend_hash_del(&(PHAR_GLOBALS->phar_fname_map), phar->fname, phar->fname_len) != SUCCESS) {", " \t\treturn FAILURE;", " \t}", " ", " \t ", " \tPHAR_G(last_phar) = NULL;", " \tPHAR_G(last_phar_name) = PHAR_G(last_alias) = NULL;", " ", " \treturn SUCCESS;", " }", "  ", " ", "  ", " int phar_get_archive(phar_archive_data **archive, char *fname, int fname_len, char *alias, int alias_len, char **error TSRMLS_DC)  ", " {", " \tphar_archive_data *fd, **fd_ptr;", " \tchar *my_realpath, *save;", " \tint save_len;", " \tulong fhash, ahash = 0;", " ", " \tphar_request_initialize(TSRMLS_C);", " ", " \tif (error) {", " \t\t*error = NULL;", " \t}", " ", " \t*archive = NULL;", " ", " \tif (PHAR_G(last_phar) && fname_len == PHAR_G(last_phar_name_len) && !memcmp(fname, PHAR_G(last_phar_name), fname_len)) {", " \t\t*archive = PHAR_G(last_phar);", " \t\tif (alias && alias_len) {", " ", " \t\t\tif (!PHAR_G(last_phar)->is_temporary_alias && (alias_len != PHAR_G(last_phar)->alias_len || memcmp(PHAR_G(last_phar)->alias, alias, alias_len))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, PHAR_G(last_phar)->fname, fname);", " \t\t\t\t}", " \t\t\t\t*archive = NULL;", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tif (PHAR_G(last_phar)->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len, (void**)&fd_ptr)) {", " \t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), PHAR_G(last_phar)->alias, PHAR_G(last_phar)->alias_len);", " \t\t\t}", " ", " \t\t\tzend_hash_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, (void*)&(*archive), sizeof(phar_archive_data*), NULL);", " \t\t\tPHAR_G(last_alias) = alias;", " \t\t\tPHAR_G(last_alias_len) = alias_len;", " \t\t}", " ", " \t\treturn SUCCESS;", " \t}", " ", " \tif (alias && alias_len && PHAR_G(last_phar) && alias_len == PHAR_G(last_alias_len) && !memcmp(alias, PHAR_G(last_alias), alias_len)) {", " \t\tfd = PHAR_G(last_phar);", " \t\tfd_ptr = &fd;", " \t\tgoto alias_success;", " \t}", " ", " \tif (alias && alias_len) {", " \t\tahash = zend_inline_hash_func(alias, alias_len);", " \t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void**)&fd_ptr)) {", " alias_success:", " \t\t\tif (fname && (fname_len != (*fd_ptr)->fname_len || strncmp(fname, (*fd_ptr)->fname, fname_len))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);", " \t\t\t\t}", " \t\t\t\tif (SUCCESS == phar_free_alias(*fd_ptr, alias, alias_len TSRMLS_CC)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tefree(*error);", " \t\t\t\t\t\t*error = NULL;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\t*archive = *fd_ptr;", " \t\t\tfd = *fd_ptr;", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = alias;", " \t\t\tPHAR_G(last_alias_len) = alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, alias, alias_len, ahash, (void **)&fd_ptr)) {", " \t\t\tgoto alias_success;", " \t\t}", " \t}", " ", " \tfhash = zend_inline_hash_func(fname, fname_len);", " \tmy_realpath = NULL;", " \tsave = fname;", " \tsave_len = fname_len;", " ", " \tif (fname && fname_len) {", " \t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {", " \t\t\t*archive = *fd_ptr;", " \t\t\tfd = *fd_ptr;", " ", " \t\t\tif (alias && alias_len) {", " \t\t\t\tif (!fd->is_temporary_alias && (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len))) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);", " \t\t\t\t\t}", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " ", " \t\t\t\tif (fd->alias_len && SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len, (void**)&fd_ptr)) {", " \t\t\t\t\tzend_hash_del(&(PHAR_GLOBALS->phar_alias_map), fd->alias, fd->alias_len);", " \t\t\t\t}", " ", " \t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);", " \t\t\t}", " ", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = fd->alias;", " \t\t\tPHAR_G(last_alias_len) = fd->alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {", " \t\t\t*archive = *fd_ptr;", " \t\t\tfd = *fd_ptr;", " ", " \t\t\t ", " \t\t\tif (!fd->is_temporary_alias && alias && alias_len) {", " \t\t\t\tif (alias_len != fd->alias_len || memcmp(fd->alias, alias, alias_len)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 0, \"alias \\\"%s\\\" is already used for archive \\\"%s\\\" cannot be overloaded with \\\"%s\\\"\", alias, (*fd_ptr)->fname, fname);", " \t\t\t\t\t}", " \t\t\t\t\treturn FAILURE;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = fd->alias;", " \t\t\tPHAR_G(last_alias_len) = fd->alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_alias_map), save, save_len, fhash, (void**)&fd_ptr)) {", " \t\t\tfd = *archive = *fd_ptr;", " ", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = fd->alias;", " \t\t\tPHAR_G(last_alias_len) = fd->alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_alias, save, save_len, fhash, (void**)&fd_ptr)) {", " \t\t\tfd = *archive = *fd_ptr;", " ", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = fd->alias;", " \t\t\tPHAR_G(last_alias_len) = fd->alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\t ", " \t\tmy_realpath = expand_filepath(fname, my_realpath TSRMLS_CC);", " ", " \t\tif (my_realpath) {", " \t\t\tfname_len = strlen(my_realpath);", " \t\t\tfname = my_realpath;", " \t\t} else {", " \t\t\treturn FAILURE;", " \t\t}", " #ifdef PHP_WIN32", " \t\tphar_unixify_path_separators(fname, fname_len);", " #endif", " \t\tfhash = zend_inline_hash_func(fname, fname_len);", " ", " \t\tif (SUCCESS == zend_hash_quick_find(&(PHAR_GLOBALS->phar_fname_map), fname, fname_len, fhash, (void**)&fd_ptr)) {", " realpath_success:", " \t\t\t*archive = *fd_ptr;", " \t\t\tfd = *fd_ptr;", " ", " \t\t\tif (alias && alias_len) {", " \t\t\t\tzend_hash_quick_add(&(PHAR_GLOBALS->phar_alias_map), alias, alias_len, ahash, (void*)&fd, sizeof(phar_archive_data*), NULL);", " \t\t\t}", " ", " \t\t\tefree(my_realpath);", " ", " \t\t\tPHAR_G(last_phar) = fd;", " \t\t\tPHAR_G(last_phar_name) = fd->fname;", " \t\t\tPHAR_G(last_phar_name_len) = fd->fname_len;", " \t\t\tPHAR_G(last_alias) = fd->alias;", " \t\t\tPHAR_G(last_alias_len) = fd->alias_len;", " ", " \t\t\treturn SUCCESS;", " \t\t}", " ", " \t\tif (PHAR_G(manifest_cached) && SUCCESS == zend_hash_quick_find(&cached_phars, fname, fname_len, fhash, (void**)&fd_ptr)) {", " \t\t\tgoto realpath_success;", " \t\t}", " ", " \t\tefree(my_realpath);", " \t}", " ", " \treturn FAILURE;", " }", "  ", " ", "  ", " char * phar_compress_filter(phar_entry_info * entry, int return_unknown)  ", " {", " \tswitch (entry->flags & PHAR_ENT_COMPRESSION_MASK) {", " \tcase PHAR_ENT_COMPRESSED_GZ:", " \t\treturn \"zlib.deflate\";", " \tcase PHAR_ENT_COMPRESSED_BZ2:", " \t\treturn \"bzip2.compress\";", " \tdefault:", " \t\treturn return_unknown ? \"unknown\" : NULL;", " \t}", " }", "  ", " ", "  ", " char * phar_decompress_filter(phar_entry_info * entry, int return_unknown)  ", " {", " \tphp_uint32 flags;", " ", " \tif (entry->is_modified) {", " \t\tflags = entry->old_flags;", " \t} else {", " \t\tflags = entry->flags;", " \t}", " ", " \tswitch (flags & PHAR_ENT_COMPRESSION_MASK) {", " \t\tcase PHAR_ENT_COMPRESSED_GZ:", " \t\t\treturn \"zlib.inflate\";", " \t\tcase PHAR_ENT_COMPRESSED_BZ2:", " \t\t\treturn \"bzip2.decompress\";", " \t\tdefault:", " \t\t\treturn return_unknown ? \"unknown\" : NULL;", " \t}", " }", "  ", " ", "  ", " phar_entry_info *phar_get_entry_info(phar_archive_data *phar, char *path, int path_len, char **error, int security TSRMLS_DC)  ", " {", " \treturn phar_get_entry_info_dir(phar, path, path_len, 0, error, security TSRMLS_CC);", " }", "  ", "  ", " phar_entry_info *phar_get_entry_info_dir(phar_archive_data *phar, char *path, int path_len, char dir, char **error, int security TSRMLS_DC)  ", " {", " \tconst char *pcr_error;", " \tphar_entry_info *entry;", " \tint is_dir;", " ", " #ifdef PHP_WIN32", " \tphar_unixify_path_separators(path, path_len);", " #endif", " ", " \tis_dir = (path_len && (path[path_len - 1] == '/')) ? 1 : 0;", " ", " \tif (error) {", " \t\t*error = NULL;", " \t}", " ", " \tif (security && path_len >= sizeof(\".phar\")-1 && !memcmp(path, \".phar\", sizeof(\".phar\")-1)) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: cannot directly access magic \\\".phar\\\" directory or files within it\");", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \tif (!path_len && !dir) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" must not be empty\", path);", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \tif (phar_path_check(&path, &path_len, &pcr_error) > pcr_is_ok) {", " \t\tif (error) {", " \t\t\tspprintf(error, 4096, \"phar error: invalid path \\\"%s\\\" contains %s\", path, pcr_error);", " \t\t}", " \t\treturn NULL;", " \t}", " ", " \tif (!phar->manifest.arBuckets) {", " \t\treturn NULL;", " \t}", " ", " \tif (is_dir) {", " \t\tif (!path_len || path_len == 1) {", " \t\t\treturn NULL;", " \t\t}", " \t\tpath_len--;", " \t}", " ", " \tif (SUCCESS == zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {", " \t\tif (entry->is_deleted) {", " \t\t\t ", " \t\t\treturn NULL;", " \t\t}", " \t\tif (entry->is_dir && !dir) {", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);", " \t\t\t}", " \t\t\treturn NULL;", " \t\t}", " \t\tif (!entry->is_dir && dir == 2) {", " \t\t\t ", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);", " \t\t\t}", " \t\t\treturn NULL;", " \t\t}", " \t\treturn entry;", " \t}", " ", " \tif (dir) {", " \t\tif (zend_hash_exists(&phar->virtual_dirs, path, path_len)) {", " \t\t\t ", " \t\t\tentry = (phar_entry_info *) ecalloc(1, sizeof(phar_entry_info));", " \t\t\t ", " \t\t\tentry->is_temp_dir = entry->is_dir = 1;", " \t\t\tentry->filename = (char *) estrndup(path, path_len + 1);", " \t\t\tentry->filename_len = path_len;", " \t\t\tentry->phar = phar;", " \t\t\treturn entry;", " \t\t}", " \t}", " ", " \tif (phar->mounted_dirs.arBuckets && zend_hash_num_elements(&phar->mounted_dirs)) {", " \t\tphar_zstr key;", " \t\tchar *str_key;", " \t\tulong unused;", " \t\tuint keylen;", " ", " \t\tzend_hash_internal_pointer_reset(&phar->mounted_dirs);", " \t\twhile (FAILURE != zend_hash_has_more_elements(&phar->mounted_dirs)) {", " \t\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(&phar->mounted_dirs, &key, &keylen, &unused, 0, NULL)) {", " \t\t\t\tbreak;", " \t\t\t}", " ", " \t\t\tPHAR_STR(key, str_key);", " ", " \t\t\tif ((int)keylen >= path_len || strncmp(str_key, path, keylen)) {", " \t\t\t\tPHAR_STR_FREE(str_key);", " \t\t\t\tcontinue;", " \t\t\t} else {", " \t\t\t\tchar *test;", " \t\t\t\tint test_len;", " \t\t\t\tphp_stream_statbuf ssb;", " ", " \t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, str_key, keylen, (void **) &entry)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" could not be retrieved from manifest\", str_key);", " \t\t\t\t\t}", " \t\t\t\t\tPHAR_STR_FREE(str_key);", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " ", " \t\t\t\tif (!entry->tmp || !entry->is_mounted) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar internal error: mounted path \\\"%s\\\" is not properly initialized as a mounted path\", str_key);", " \t\t\t\t\t}", " \t\t\t\t\tPHAR_STR_FREE(str_key);", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " \t\t\t\tPHAR_STR_FREE(str_key);", " ", " \t\t\t\ttest_len = spprintf(&test, MAXPATHLEN, \"%s%s\", entry->tmp, path + keylen);", " ", " \t\t\t\tif (SUCCESS != php_stream_stat_path(test, &ssb)) {", " \t\t\t\t\tefree(test);", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " ", " \t\t\t\tif (ssb.sb.st_mode & S_IFDIR && !dir) {", " \t\t\t\t\tefree(test);", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" is a directory\", path);", " \t\t\t\t\t}", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " ", " \t\t\t\tif ((ssb.sb.st_mode & S_IFDIR) == 0 && dir) {", " \t\t\t\t\tefree(test);", " \t\t\t\t\t ", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists and is a not a directory\", path);", " \t\t\t\t\t}", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " ", " \t\t\t\t ", " \t\t\t\tif (SUCCESS != phar_mount_entry(phar, test, test_len, path, path_len TSRMLS_CC)) {", " \t\t\t\t\tefree(test);", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be mounted\", path, test);", " \t\t\t\t\t}", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " ", " \t\t\t\tefree(test);", " ", " \t\t\t\tif (SUCCESS != zend_hash_find(&phar->manifest, path, path_len, (void**)&entry)) {", " \t\t\t\t\tif (error) {", " \t\t\t\t\t\tspprintf(error, 4096, \"phar error: path \\\"%s\\\" exists as file \\\"%s\\\" and could not be retrieved after being mounted\", path, test);", " \t\t\t\t\t}", " \t\t\t\t\treturn NULL;", " \t\t\t\t}", " \t\t\t\treturn entry;", " \t\t\t}", " \t\t}", " \t}", " ", " \treturn NULL;", " }", "  ", " ", " static const char hexChars[] = \"0123456789ABCDEF\";", " ", " static int phar_hex_str(const char *digest, size_t digest_len, char **signature TSRMLS_DC)  ", " {", " \tint pos = -1;", " \tsize_t len = 0;", " ", " \t*signature = (char*)safe_pemalloc(digest_len, 2, 1, PHAR_G(persist));", " ", " \tfor (; len < digest_len; ++len) {", " \t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] >> 4];", " \t\t(*signature)[++pos] = hexChars[((const unsigned char *)digest)[len] & 0x0F];", " \t}", " \t(*signature)[++pos] = '\\0';", " \treturn pos;", " }", "  ", " ", " #ifndef PHAR_HAVE_OPENSSL", " static int phar_call_openssl_signverify(int is_sign, php_stream *fp, off_t end, char *key, int key_len, char **signature, int *signature_len TSRMLS_DC)  ", " {", " \tzend_fcall_info fci;", " \tzend_fcall_info_cache fcc;", " \tzval *zdata, *zsig, *zkey, *retval_ptr, **zp[3], *openssl;", " ", " \tMAKE_STD_ZVAL(zdata);", " \tMAKE_STD_ZVAL(openssl);", " \tZVAL_STRINGL(openssl, is_sign ? \"openssl_sign\" : \"openssl_verify\", is_sign ? sizeof(\"openssl_sign\")-1 : sizeof(\"openssl_verify\")-1, 1);", " \tMAKE_STD_ZVAL(zsig);", " \tZVAL_STRINGL(zsig, *signature, *signature_len, 1);", " \tMAKE_STD_ZVAL(zkey);", " \tZVAL_STRINGL(zkey, key, key_len, 1);", " \tzp[0] = &zdata;", " \tzp[1] = &zsig;", " \tzp[2] = &zkey;", " ", " \tphp_stream_rewind(fp);", " \tZ_TYPE_P(zdata) = IS_STRING;", " \tZ_STRLEN_P(zdata) = end;", " ", " \tif (end != (off_t) php_stream_copy_to_mem(fp, &(Z_STRVAL_P(zdata)), (size_t) end, 0)) {", " \t\tzval_dtor(zdata);", " \t\tzval_dtor(zsig);", " \t\tzval_dtor(zkey);", " \t\tzval_dtor(openssl);", " \t\tefree(openssl);", " \t\tefree(zdata);", " \t\tefree(zkey);", " \t\tefree(zsig);", " \t\treturn FAILURE;", " \t}", " ", " \tif (FAILURE == zend_fcall_info_init(openssl, 0, &fci, &fcc, NULL, NULL TSRMLS_CC)) {", " \t\tzval_dtor(zdata);", " \t\tzval_dtor(zsig);", " \t\tzval_dtor(zkey);", " \t\tzval_dtor(openssl);", " \t\tefree(openssl);", " \t\tefree(zdata);", " \t\tefree(zkey);", " \t\tefree(zsig);", " \t\treturn FAILURE;", " \t}", " ", " \tfci.param_count = 3;", " \tfci.params = zp;", " \tZ_ADDREF_P(zdata);", " \tif (is_sign) {", " \t\tZ_SET_ISREF_P(zsig);", " \t} else {", " \t\tZ_ADDREF_P(zsig);", " \t}", " \tZ_ADDREF_P(zkey);", " ", " \tfci.retval_ptr_ptr = &retval_ptr;", " ", " \tif (FAILURE == zend_call_function(&fci, &fcc TSRMLS_CC)) {", " \t\tzval_dtor(zdata);", " \t\tzval_dtor(zsig);", " \t\tzval_dtor(zkey);", " \t\tzval_dtor(openssl);", " \t\tefree(openssl);", " \t\tefree(zdata);", " \t\tefree(zkey);", " \t\tefree(zsig);", " \t\treturn FAILURE;", " \t}", " ", " \tzval_dtor(openssl);", " \tefree(openssl);", " \tZ_DELREF_P(zdata);", " ", " \tif (is_sign) {", " \t\tZ_UNSET_ISREF_P(zsig);", " \t} else {", " \t\tZ_DELREF_P(zsig);", " \t}", " \tZ_DELREF_P(zkey);", " ", " \tzval_dtor(zdata);", " \tefree(zdata);", " \tzval_dtor(zkey);", " \tefree(zkey);", " ", " \tswitch (Z_TYPE_P(retval_ptr)) {", " \t\tdefault:", " \t\tcase IS_LONG:", " \t\t\tzval_dtor(zsig);", " \t\t\tefree(zsig);", " \t\t\tif (1 == Z_LVAL_P(retval_ptr)) {", " \t\t\t\tefree(retval_ptr);", " \t\t\t\treturn SUCCESS;", " \t\t\t}", " \t\t\tefree(retval_ptr);", " \t\t\treturn FAILURE;", " \t\tcase IS_BOOL:", " \t\t\tefree(retval_ptr);", " \t\t\tif (Z_BVAL_P(retval_ptr)) {", " \t\t\t\t*signature = estrndup(Z_STRVAL_P(zsig), Z_STRLEN_P(zsig));", " \t\t\t\t*signature_len = Z_STRLEN_P(zsig);", " \t\t\t\tzval_dtor(zsig);", " \t\t\t\tefree(zsig);", " \t\t\t\treturn SUCCESS;", " \t\t\t}", " \t\t\tzval_dtor(zsig);", " \t\t\tefree(zsig);", " \t\t\treturn FAILURE;", " \t}", " }", "  ", " #endif  ", " ", " int phar_verify_signature(php_stream *fp, size_t end_of_phar, php_uint32 sig_type, char *sig, int sig_len, char *fname, char **signature, int *signature_len, char **error TSRMLS_DC)  ", " {", " \tint read_size, len;", " \toff_t read_len;", " \tunsigned char buf[1024];", " ", " \tphp_stream_rewind(fp);", " ", " \tswitch (sig_type) {", " \t\tcase PHAR_SIG_OPENSSL: {", " #ifdef PHAR_HAVE_OPENSSL", " \t\t\tBIO *in;", " \t\t\tEVP_PKEY *key;", " \t\t\tEVP_MD *mdtype = (EVP_MD *) EVP_sha1();", " \t\t\tEVP_MD_CTX md_ctx;", " #else", " \t\t\tint tempsig;", " #endif", " \t\t\tphp_uint32 pubkey_len;", " \t\t\tchar *pubkey = NULL, *pfile;", " \t\t\tphp_stream *pfp;", " #ifndef PHAR_HAVE_OPENSSL", " \t\t\tif (!zend_hash_exists(&module_registry, \"openssl\", sizeof(\"openssl\"))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"openssl not loaded\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " #endif", " \t\t\t ", " \t\t\tspprintf(&pfile, 0, \"%s.pubkey\", fname);", " \t\t\tpfp = php_stream_open_wrapper(pfile, \"rb\", 0, NULL);", " \t\t\tefree(pfile);", " ", " #if PHP_MAJOR_VERSION > 5", " \t\t\tif (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, (void **) &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {", " #else", " \t\t\tif (!pfp || !(pubkey_len = php_stream_copy_to_mem(pfp, &pubkey, PHP_STREAM_COPY_ALL, 0)) || !pubkey) {", " #endif", " \t\t\t\tif (pfp) {", " \t\t\t\t\tphp_stream_close(pfp);", " \t\t\t\t}", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"openssl public key could not be read\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tphp_stream_close(pfp);", " #ifndef PHAR_HAVE_OPENSSL", " \t\t\ttempsig = sig_len;", " ", " \t\t\tif (FAILURE == phar_call_openssl_signverify(0, fp, end_of_phar, pubkey, pubkey_len, &sig, &tempsig TSRMLS_CC)) {", " \t\t\t\tif (pubkey) {", " \t\t\t\t\tefree(pubkey);", " \t\t\t\t}", " ", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"openssl signature could not be verified\");", " \t\t\t\t}", " ", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tif (pubkey) {", " \t\t\t\tefree(pubkey);", " \t\t\t}", " ", " \t\t\tsig_len = tempsig;", " #else", " \t\t\tin = BIO_new_mem_buf(pubkey, pubkey_len);", " ", " \t\t\tif (NULL == in) {", " \t\t\t\tefree(pubkey);", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tkey = PEM_read_bio_PUBKEY(in, NULL,NULL, NULL);", " \t\t\tBIO_free(in);", " \t\t\tefree(pubkey);", " ", " \t\t\tif (NULL == key) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"openssl signature could not be processed\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tEVP_VerifyInit(&md_ctx, mdtype);", " \t\t\tread_len = end_of_phar;", " ", " \t\t\tif (read_len > sizeof(buf)) {", " \t\t\t\tread_size = sizeof(buf);", " \t\t\t} else {", " \t\t\t\tread_size = (int)read_len;", " \t\t\t}", " ", " \t\t\tphp_stream_seek(fp, 0, SEEK_SET);", " ", " \t\t\twhile (read_size && (len = php_stream_read(fp, (char*)buf, read_size)) > 0) {", " \t\t\t\tEVP_VerifyUpdate (&md_ctx, buf, len);", " \t\t\t\tread_len -= (off_t)len;", " ", " \t\t\t\tif (read_len < read_size) {", " \t\t\t\t\tread_size = (int)read_len;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tif (EVP_VerifyFinal(&md_ctx, (unsigned char *)sig, sig_len, key) != 1) {", " \t\t\t\t ", " \t\t\t\tEVP_MD_CTX_cleanup(&md_ctx);", " ", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"broken openssl signature\");", " \t\t\t\t}", " ", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\tEVP_MD_CTX_cleanup(&md_ctx);", " #endif", " ", " \t\t\t*signature_len = phar_hex_str((const char*)sig, sig_len, signature TSRMLS_CC);", " \t\t}", " \t\tbreak;", " #ifdef PHAR_HASH_OK", " \t\tcase PHAR_SIG_SHA512: {", " \t\t\tunsigned char digest[64];", " \t\t\tPHP_SHA512_CTX context;", " ", " \t\t\tPHP_SHA512Init(&context);", " \t\t\tread_len = end_of_phar;", " ", " \t\t\tif (read_len > sizeof(buf)) {", " \t\t\t\tread_size = sizeof(buf);", " \t\t\t} else {", " \t\t\t\tread_size = (int)read_len;", " \t\t\t}", " ", " \t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {", " \t\t\t\tPHP_SHA512Update(&context, buf, len);", " \t\t\t\tread_len -= (off_t)len;", " \t\t\t\tif (read_len < read_size) {", " \t\t\t\t\tread_size = (int)read_len;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tPHP_SHA512Final(digest, &context);", " ", " \t\t\tif (memcmp(digest, sig, sizeof(digest))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"broken signature\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);", " \t\t\tbreak;", " \t\t}", " \t\tcase PHAR_SIG_SHA256: {", " \t\t\tunsigned char digest[32];", " \t\t\tPHP_SHA256_CTX context;", " ", " \t\t\tPHP_SHA256Init(&context);", " \t\t\tread_len = end_of_phar;", " ", " \t\t\tif (read_len > sizeof(buf)) {", " \t\t\t\tread_size = sizeof(buf);", " \t\t\t} else {", " \t\t\t\tread_size = (int)read_len;", " \t\t\t}", " ", " \t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {", " \t\t\t\tPHP_SHA256Update(&context, buf, len);", " \t\t\t\tread_len -= (off_t)len;", " \t\t\t\tif (read_len < read_size) {", " \t\t\t\t\tread_size = (int)read_len;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tPHP_SHA256Final(digest, &context);", " ", " \t\t\tif (memcmp(digest, sig, sizeof(digest))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"broken signature\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);", " \t\t\tbreak;", " \t\t}", " #else", " \t\tcase PHAR_SIG_SHA512:", " \t\tcase PHAR_SIG_SHA256:", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 0, \"unsupported signature\");", " \t\t\t}", " \t\t\treturn FAILURE;", " #endif", " \t\tcase PHAR_SIG_SHA1: {", " \t\t\tunsigned char digest[20];", " \t\t\tPHP_SHA1_CTX  context;", " ", " \t\t\tPHP_SHA1Init(&context);", " \t\t\tread_len = end_of_phar;", " ", " \t\t\tif (read_len > sizeof(buf)) {", " \t\t\t\tread_size = sizeof(buf);", " \t\t\t} else {", " \t\t\t\tread_size = (int)read_len;", " \t\t\t}", " ", " \t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {", " \t\t\t\tPHP_SHA1Update(&context, buf, len);", " \t\t\t\tread_len -= (off_t)len;", " \t\t\t\tif (read_len < read_size) {", " \t\t\t\t\tread_size = (int)read_len;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tPHP_SHA1Final(digest, &context);", " ", " \t\t\tif (memcmp(digest, sig, sizeof(digest))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"broken signature\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);", " \t\t\tbreak;", " \t\t}", " \t\tcase PHAR_SIG_MD5: {", " \t\t\tunsigned char digest[16];", " \t\t\tPHP_MD5_CTX   context;", " ", " \t\t\tPHP_MD5Init(&context);", " \t\t\tread_len = end_of_phar;", " ", " \t\t\tif (read_len > sizeof(buf)) {", " \t\t\t\tread_size = sizeof(buf);", " \t\t\t} else {", " \t\t\t\tread_size = (int)read_len;", " \t\t\t}", " ", " \t\t\twhile ((len = php_stream_read(fp, (char*)buf, read_size)) > 0) {", " \t\t\t\tPHP_MD5Update(&context, buf, len);", " \t\t\t\tread_len -= (off_t)len;", " \t\t\t\tif (read_len < read_size) {", " \t\t\t\t\tread_size = (int)read_len;", " \t\t\t\t}", " \t\t\t}", " ", " \t\t\tPHP_MD5Final(digest, &context);", " ", " \t\t\tif (memcmp(digest, sig, sizeof(digest))) {", " \t\t\t\tif (error) {", " \t\t\t\t\tspprintf(error, 0, \"broken signature\");", " \t\t\t\t}", " \t\t\t\treturn FAILURE;", " \t\t\t}", " ", " \t\t\t*signature_len = phar_hex_str((const char*)digest, sizeof(digest), signature TSRMLS_CC);", " \t\t\tbreak;", " \t\t}", " \t\tdefault:", " \t\t\tif (error) {", " \t\t\t\tspprintf(error, 0, \"broken or unsupported signature\");", " \t\t\t}", " \t\t\treturn FAILURE;", " \t}", " \treturn SUCCESS;", " }", "  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" user_change_icon_file_authorized_cb (Daemon                *daemon,", "                                      User                  *user,", "                                      GDBusMethodInvocation *context,", "                                      gpointer               data)", " ", " {", "         g_autofree gchar *filename = NULL;", "         g_autoptr(GFile) file = NULL;", "         g_autoptr(GFileInfo) info = NULL;", "         guint32 mode;", "         GFileType type;", "         guint64 size;", " ", "         filename = g_strdup (data);", " ", "         if (filename == NULL ||", "             *filename == '\\0') {", "                 g_autofree gchar *dest_path = NULL;", "                 g_autoptr(GFile) dest = NULL;", "                 g_autoptr(GError) error = NULL;", " ", "                 g_clear_pointer (&filename, g_free);", " ", "                 dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);", "                 dest = g_file_new_for_path (dest_path);", " ", "                 if (!g_file_delete (dest, NULL, &error) &&", "                     !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {", "                         throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);", "                         return;", "                 }", "                 goto icon_saved;", "          }", "  ", "          file = g_file_new_for_path (filename);", "         g_clear_pointer (&filename, g_free);", " ", "          ", "         filename = g_file_get_path (file);", " ", "          info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"", "                                          G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"", "                                          G_FILE_ATTRIBUTE_STANDARD_SIZE,", "                 return;", "         }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  void fe_netjoin_deinit(void)", " {", " \twhile (joinservers != NULL)", " \t\tnetjoin_server_remove(joinservers->data);", " \tif (join_tag != -1) {", " \t\tg_source_remove(join_tag);", " \t\tsignal_remove(\"print starting\", (SIGNAL_FUNC) sig_print_starting);", "  \t}", "  ", "  \tsignal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);", " \tsignal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);", "  ", "  \tsignal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);", "  \tsignal_remove(\"message join\", (SIGNAL_FUNC) msg_join);", " \tsignal_remove(\"message irc mode\", (SIGNAL_FUNC) msg_mode);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" FUNC_DECODER(dissector_postgresql)", " {", "    DECLARE_DISP_PTR(ptr);", "    struct ec_session *s = NULL;", "    void *ident = NULL;", "    char tmp[MAX_ASCII_ADDR_LEN];", "    struct postgresql_status *conn_status;", " ", "     ", "    (void) DECODE_DATA; ", "    (void) DECODE_DATALEN;", "    (void) DECODED_LEN;", "    ", "    if (FROM_CLIENT(\"postgresql\", PACKET)) {", "       if (PACKET->DATA.len < 4)", "          return NULL;", " ", "       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", " ", "        ", "       if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) {", "           ", "          unsigned char *u = memmem(ptr, PACKET->DATA.len, \"user\", 4);", "          unsigned char *d = memmem(ptr, PACKET->DATA.len, \"database\", 8);", "          if (!memcmp(ptr + 4, \"\\x00\\x03\\x00\\x00\", 4) && u && d) {", "              ", "             dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql));", " ", "              ", "             SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status));", " ", "             conn_status = (struct postgresql_status *) s->data;", "             conn_status->status = WAIT_AUTH;", " ", "              ", "             strncpy((char*)conn_status->user, (char*)(u + 5), 65);", "             conn_status->user[64] = 0;", " ", "              ", "             strncpy((char*)conn_status->database, (char*)(d + 9), 65);", "             conn_status->database[64] = 0;", " ", "              ", "             session_put(s);", "          }", "       } else {", "          conn_status = (struct postgresql_status *) s->data;", "          if (conn_status->status == WAIT_RESPONSE) {", " ", "              ", "             if (ptr[0] == 'p' && conn_status->type == MD5) {", "                DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is MD5\");", "                if(memcmp(ptr + 1, \"\\x00\\x00\\x00\\x28\", 4)) {", "                   DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "                   return NULL;", "                }", "                if (PACKET->DATA.len < 40) {", "                   DEBUG_MSG(\"\\tDissector_postgresql BUG, expected length is 40\");", "                   return NULL;", "                }", "                memcpy(conn_status->hash, ptr + 5 + 3, 32);", "                conn_status->hash[32] = 0;", "                DISSECT_MSG(\"%s:$postgres$%s*%s*%s:%s:%d\\n\", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst));", "                dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "             }", "             else if (ptr[0] == 'p' && conn_status->type == CT) {", "                 int length;", "                 DEBUG_MSG(\"\\tDissector_postgresql RESPONSE type is clear-text!\");", "                 GET_ULONG_BE(length, ptr, 1);", "               strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4);", "               conn_status->password[length - 4] = 0;", "                length -= 4;", "                if (length < 0 || length > 65 || PACKET->DATA.len < length+5) {", "                    dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "                    return NULL;", "                }", "                snprintf((char*)conn_status->password, length+1, \"%s\", (char*)(ptr + 5));", "                 DISSECT_MSG(\"PostgreSQL credentials:%s-%d:%s:%s\\n\", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password);", "                 dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql));", "              }", "          }", "       }", "    } else {  ", "       if (PACKET->DATA.len < 9)", "          return NULL;", "       dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql));", " ", "       if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) {", "          conn_status = (struct postgresql_status *) s->data;", "          if (conn_status->status == WAIT_AUTH &&", "                ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x0c\", 4)  &&", "                !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x05\", 4)) {", " ", "             conn_status->status = WAIT_RESPONSE;", " ", "             conn_status->type = MD5;", "             DEBUG_MSG(\"\\tDissector_postgresql AUTH type is MD5\");", "             hex_encode(ptr + 9, 4, conn_status->salt);  ", "          }", "          else if (conn_status->status == WAIT_AUTH &&", "                ptr[0] == 'R' && !memcmp(ptr + 1, \"\\x00\\x00\\x00\\x08\", 4)  &&", "                !memcmp(ptr + 5, \"\\x00\\x00\\x00\\x03\", 4)) {", "             conn_status->status = WAIT_RESPONSE;", "             conn_status->type = CT;", "             DEBUG_MSG(\"\\tDissector_postgresql AUTH type is clear-text!\");", "          }", "       }", "    }", " ", "    SAFE_FREE(ident);", "    return NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" display_sigset( const char *msg, sigset_t *mask )", " {", " \tint\t\t\t\t\tsigno;", "         NameTableIterator       next_sig( SigNames );", "  ", "         if( msg ) {", "               dprintf( D_ALWAYS, msg );", "                dprintf( D_ALWAYS, \"%s\", msg );", "         }", "         while( (signo = next_sig()) != -1 ) {", "                 if( sigismember(mask,signo) ) {", " \t\t\tdprintf( D_ALWAYS | D_NOHEADER, \"%s \", SigNames.get_name(signo) );", " \t\t}", " \t}", " \tdprintf( D_ALWAYS | D_NOHEADER, \"\\n\" );", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void SaveCardBubbleControllerImpl::ShowBubbleForUpload(", "     const CreditCard& card,", "      std::unique_ptr<base::DictionaryValue> legal_message,", "      bool should_cvc_be_requested,", "      const base::Closure& save_card_callback) {", "    ", "   if (save_card_bubble_view_)", "     return;", " ", "    is_uploading_ = true;", "    is_reshow_ = false;", "    should_cvc_be_requested_ = should_cvc_be_requested;", "   AutofillMetrics::LogSaveCardPromptMetric(", "       AutofillMetrics::SAVE_CARD_PROMPT_SHOW_REQUESTED, is_uploading_,", "       is_reshow_,", "       pref_service_->GetInteger(", "           prefs::kAutofillAcceptSaveCreditCardPromptState));", " ", "   if (!LegalMessageLine::Parse(*legal_message, &legal_message_lines_)) {", "     AutofillMetrics::LogSaveCardPromptMetric(", "         AutofillMetrics::SAVE_CARD_PROMPT_END_INVALID_LEGAL_MESSAGE,", "         is_uploading_, is_reshow_,", "         pref_service_->GetInteger(", "             prefs::kAutofillAcceptSaveCreditCardPromptState));", "     return;", "   }", " ", "   card_ = card;", "   save_card_callback_ = save_card_callback;", "   ShowBubble();", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int ssl23_get_client_hello(SSL *s)", " \t{", " \tchar buf_space[11];  ", " \tchar *buf= &(buf_space[0]);", " \tunsigned char *p,*d,*d_len,*dd;", " \tunsigned int i;", " \tunsigned int csl,sil,cl;", " \tint n=0,j;", " \tint type=0;", " \tint v[2];", " ", " \tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)", " \t\t{", " \t\t ", " \t\tv[0]=v[1]=0;", " ", " \t\tif (!ssl3_setup_buffers(s)) goto err;", " ", " \t\tn=ssl23_read_bytes(s, sizeof buf_space);", " \t\tif (n != sizeof buf_space) return(n);  ", " ", " \t\tp=s->packet;", " ", " \t\tmemcpy(buf,p,n);", " ", " \t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))", " \t\t\t{", " \t\t\t ", " \t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))", " \t\t\t\t{", " \t\t\t\tv[0]=p[3]; v[1]=p[4];", " \t\t\t\t ", " \t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))", " \t\t\t\t\ttype=1;", " \t\t\t\t}", " \t\t\telse if (p[3] == SSL3_VERSION_MAJOR)", " \t\t\t\t{", " \t\t\t\tv[0]=p[3]; v[1]=p[4];", " \t\t\t\t ", " \t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)", " \t\t\t\t\t{", " \t\t\t\t\tif (p[4] >= TLS1_2_VERSION_MINOR &&", " \t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_2))", " \t\t\t\t\t\t{", " \t\t\t\t\t\ts->version=TLS1_2_VERSION;", " \t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (p[4] >= TLS1_1_VERSION_MINOR &&", " \t\t\t\t\t   !(s->options & SSL_OP_NO_TLSv1_1))", " \t\t\t\t\t\t{", " \t\t\t\t\t\ts->version=TLS1_1_VERSION;", " \t\t\t\t\t\t   ", " \t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))", " \t\t\t\t\t\t{", " \t\t\t\t\t\ts->version=TLS1_VERSION;", " \t\t\t\t\t\t   ", " \t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))", " \t\t\t\t\t\t{", " \t\t\t\t\t\ts->version=SSL3_VERSION;", " \t\t\t\t\t\t ", " \t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;", " \t\t\t\t\t\t}", " \t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))", " \t\t\t\t\t\t{", " \t\t\t\t\t\ttype=1;", " \t\t\t\t\t\t}", " \t\t\t\t\t}", " \t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=SSL3_VERSION;", " \t\t\t\t\t ", " \t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;", " \t\t\t\t\t}", " \t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))", " \t\t\t\t\ttype=1;", " ", " \t\t\t\t}", " \t\t\t}", " \t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&", " \t\t\t (p[1] == SSL3_VERSION_MAJOR) &&", " \t\t\t (p[5] == SSL3_MT_CLIENT_HELLO) &&", " \t\t\t ((p[3] == 0 && p[4] < 5  )", " \t\t\t\t|| (p[9] >= p[1])))", " \t\t\t{", " \t\t\t ", " \t\t\t", " \t\t\tv[0]=p[1];  ", " \t\t\t ", "                         if (p[3] == 0 && p[4] < 6)", "                                 {", "#if 0", "                                 SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_SMALL);", "                                 goto err;", "#else", "                               v[1] = TLS1_VERSION_MINOR;", "#endif", "                                 }", "                          ", "                       else if (p[9] > SSL3_VERSION_MAJOR)", "                        if (p[9] > SSL3_VERSION_MAJOR)", "                                 v[1]=0xff;", "                         else", "                                 v[1]=p[10];  ", " \t\t\telse if (p[9] > SSL3_VERSION_MAJOR)", " \t\t\t\tv[1]=0xff;", " \t\t\telse", " \t\t\t\tv[1]=p[10];  ", " \t\t\tif (v[1] >= TLS1_VERSION_MINOR)", " \t\t\t\t{", " \t\t\t\tif (v[1] >= TLS1_2_VERSION_MINOR &&", " \t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_2))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=TLS1_2_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\telse if (v[1] >= TLS1_1_VERSION_MINOR &&", " \t\t\t\t\t!(s->options & SSL_OP_NO_TLSv1_1))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=TLS1_1_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=TLS1_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=SSL3_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\telse", " \t\t\t\t{", " \t\t\t\t ", " \t\t\t\tif (!(s->options & SSL_OP_NO_SSLv3))", " \t\t\t\t\t{", " \t\t\t\t\ts->version=SSL3_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\telse if (!(s->options & SSL_OP_NO_TLSv1))", " \t\t\t\t\t{", " \t\t\t\t\t ", " \t\t\t\t\ts->version=TLS1_VERSION;", " \t\t\t\t\ttype=3;", " \t\t\t\t\t}", " \t\t\t\t}", " \t\t\t}", " \t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||", " \t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||", " \t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||", " \t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))", " \t\t\t{", " \t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);", " \t\t\tgoto err;", " \t\t\t}", " \t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)", " \t\t\t{", " \t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);", " \t\t\tgoto err;", " \t\t\t}", " \t\t}", " ", " \tif (s->version < TLS1_2_VERSION && tls1_suiteb(s))", " \t\t{", " \t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,", " \t\t\t\tSSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);", " \t\tgoto err;", " \t\t}", " ", " #ifdef OPENSSL_FIPS", " \tif (FIPS_mode() && (s->version < TLS1_VERSION))", " \t\t{", " \t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,", " \t\t\t\t\tSSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);", " \t\tgoto err;", " \t\t}", " #endif", " ", " \tif (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL))", " \t\t{", " \t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_VERSION_TOO_LOW);", " \t\tgoto err;", " \t\t}", " ", " \tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)", " \t\t{", " \t\t ", "                 v[1] = p[4];", "  ", "                 ", "                 n=((p[0]&0x7f)<<8)|p[1];", "                 if (n > (1024*4))", "                         {", "                         SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);", "                         goto err;", "                         }", "                if (n < 9)", "                        {", "                        SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);", "                        goto err;", "                        }", "  ", "                 j=ssl23_read_bytes(s,n+2);", "                 ", "                 if (j <= 0) return(j);", "  ", "                 ssl3_finish_mac(s, s->packet+2, s->packet_length-2);", " ", " \t\t ", " \t\t*(d++) = SSL3_MT_CLIENT_HELLO;", " \t\t ", " \t\td_len = d;", " \t\td += 3;", " ", " \t\t ", " \t\t*(d++) = SSL3_VERSION_MAJOR;  ", " \t\t*(d++) = v[1];", " ", " \t\t ", " \t\t ", " \t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;", " \t\tmemset(d,0,SSL3_RANDOM_SIZE);", " \t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);", " \t\td+=SSL3_RANDOM_SIZE;", " ", " \t\t ", " \t\t*(d++)=0;", " ", " \t\t ", " \t\tj=0;", " \t\tdd=d;", " \t\td+=2;", " \t\tfor (i=0; i<csl; i+=3)", " \t\t\t{", " \t\t\tif (p[i] != 0) continue;", " \t\t\t*(d++)=p[i+1];", " \t\t\t*(d++)=p[i+2];", " \t\t\tj+=2;", " \t\t\t}", " \t\ts2n(j,dd);", " ", " \t\t ", " \t\t*(d++)=1;", " \t\t*(d++)=0;", " \t\t", " #if 0", "                  ", " \t        p = p+csl+sil+cl;", " \t\twhile (p <  s->packet+s->packet_length)", " \t\t\t{", " \t\t\t*(d++)=*(p++);", " \t\t\t}", " #endif", " ", " \t\ti = (d-(unsigned char *)s->init_buf->data) - 4;", " \t\tl2n3((long)i, d_len);", " ", " \t\t ", " \t\ts->s3->tmp.reuse_message=1;", " \t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;", " \t\ts->s3->tmp.message_size=i;", " \t\t}", " ", " \t ", " \t ", " ", " \tif (type == 1)", " \t\t{", " #ifdef OPENSSL_NO_SSL2", " \t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNSUPPORTED_PROTOCOL);", " \t\tgoto err;", " #else", " \t\t ", " \t\t ", " ", " \t\tif (s->s2 == NULL)", " \t\t\t{", " \t\t\tif (!ssl2_new(s))", " \t\t\t\tgoto err;", " \t\t\t}", " \t\telse", " \t\t\tssl2_clear(s);", " ", " \t\tif (s->s3 != NULL) ssl3_free(s);", " ", " \t\tif (!BUF_MEM_grow_clean(s->init_buf,", " \t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))", " \t\t\t{", " \t\t\tgoto err;", " \t\t\t}", " ", " \t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;", " \t\tif (s->options & SSL_OP_NO_TLSv1 && s->options & SSL_OP_NO_SSLv3)", " \t\t\ts->s2->ssl2_rollback=0;", " \t\telse", " \t\t\t ", " \t\t\ts->s2->ssl2_rollback=1;", " ", " \t\t ", " \t\ts->rstate=SSL_ST_READ_HEADER;", " \t\ts->packet_length=n;", " \t\ts->packet= &(s->s2->rbuf[0]);", " \t\tmemcpy(s->packet,buf,n);", " \t\ts->s2->rbuf_left=n;", " \t\ts->s2->rbuf_offs=0;", " ", " \t\ts->method=SSLv2_server_method();", " \t\ts->handshake_func=s->method->ssl_accept;", " #endif", " \t\t}", " ", " \tif ((type == 2) || (type == 3))", " \t\t{", " \t\t ", " ", " \t\tif (!ssl_init_wbio_buffer(s,1)) goto err;", " ", " \t\t ", " \t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;", " ", " \t\tif (type == 3)", " \t\t\t{", " \t\t\t ", " \t\t\ts->rstate=SSL_ST_READ_HEADER;", " \t\t\ts->packet_length=n;", " \t\t\tif (s->s3->rbuf.buf == NULL)", " \t\t\t\tif (!ssl3_setup_read_buffer(s))", " \t\t\t\t\tgoto err;", " ", " \t\t\ts->packet= &(s->s3->rbuf.buf[0]);", " \t\t\tmemcpy(s->packet,buf,n);", " \t\t\ts->s3->rbuf.left=n;", " \t\t\ts->s3->rbuf.offset=0;", " \t\t\t}", " \t\telse", " \t\t\t{", " \t\t\ts->packet_length=0;", " \t\t\ts->s3->rbuf.left=0;", " \t\t\ts->s3->rbuf.offset=0;", " \t\t\t}", " \t\tif (s->version == TLS1_2_VERSION)", " \t\t\ts->method = TLSv1_2_server_method();", " \t\telse if (s->version == TLS1_1_VERSION)", " \t\t\ts->method = TLSv1_1_server_method();", " \t\telse if (s->version == TLS1_VERSION)", " \t\t\ts->method = TLSv1_server_method();", " \t\telse", " \t\t\ts->method = SSLv3_server_method();", " #if 0  ", " \t\ts->client_version=(v[0]<<8)|v[1];", " #endif", " \t\ts->handshake_func=s->method->ssl_accept;", " \t\t}", " \t", " \tif ((type < 1) || (type > 3))", " \t\t{", " \t\t ", " \t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);", " \t\tgoto err;", " \t\t}", " \ts->init_num=0;", " ", " \tif (buf != buf_space) OPENSSL_free(buf);", " \treturn(SSL_accept(s));", " err:", " \tif (buf != buf_space) OPENSSL_free(buf);", " \treturn(-1);", " \t}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool WebPage::touchEvent(const Platform::TouchEvent& event)", " {", " #if DEBUG_TOUCH_EVENTS", "     BBLOG(LogLevelCritical, \"%s\", event.toString().c_str());", " #endif", " ", " #if ENABLE(TOUCH_EVENTS)", "     if (!d->m_mainFrame)", "         return false;", " ", "     if (d->m_page->defersLoading())", "         return false;", " ", "     PluginView* pluginView = d->m_fullScreenPluginView.get();", "     if (pluginView)", "          return d->dispatchTouchEventToFullScreenPlugin(pluginView, event);", "  ", "      Platform::TouchEvent tEvent = event;", "    for (unsigned i = 0; i < event.m_points.size(); i++) {", "        tEvent.m_points[i].m_pos = d->mapFromTransformed(tEvent.m_points[i].m_pos);", "        tEvent.m_points[i].m_screenPos = tEvent.m_points[i].m_screenPos;", "    }", "      if (event.isSingleTap())", "          d->m_pluginMayOpenNewTab = true;", "      else if (tEvent.m_type == Platform::TouchEvent::TouchStart || tEvent.m_type == Platform::TouchEvent::TouchCancel)", "         d->m_pluginMayOpenNewTab = false;", " ", "     if (tEvent.m_type == Platform::TouchEvent::TouchStart) {", "         d->clearCachedHitTestResult();", "         d->m_touchEventHandler->doFatFingers(tEvent.m_points[0]);", " ", "         Element* elementUnderFatFinger = d->m_touchEventHandler->lastFatFingersResult().nodeAsElementIfApplicable();", "         if (elementUnderFatFinger)", "             d->m_touchEventHandler->drawTapHighlight();", "     }", " ", "     bool handled = false;", " ", "     if (!event.m_type != Platform::TouchEvent::TouchInjected)", "         handled = d->m_mainFrame->eventHandler()->handleTouchEvent(PlatformTouchEvent(&tEvent));", " ", "     if (d->m_preventDefaultOnTouchStart) {", "         if (tEvent.m_type == Platform::TouchEvent::TouchEnd || tEvent.m_type == Platform::TouchEvent::TouchCancel)", "             d->m_preventDefaultOnTouchStart = false;", "         return true;", "     }", " ", "     if (handled) {", "         if (tEvent.m_type == Platform::TouchEvent::TouchStart)", "             d->m_preventDefaultOnTouchStart = true;", "         return true;", "     }", " ", "     if (event.isTouchHold())", "         d->m_touchEventHandler->doFatFingers(tEvent.m_points[0]);", " ", " #endif", " ", "     return false;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void InitializeOriginStatFromOriginRequestSummary(", "      OriginStat* origin,", "      const OriginRequestSummary& summary) {", "  origin->set_origin(summary.origin.spec());", "   origin->set_origin(summary.origin.GetURL().spec());", "    origin->set_number_of_hits(1);", "    origin->set_average_position(summary.first_occurrence + 1);", "    origin->set_always_access_network(summary.always_access_network);", "   origin->set_accessed_network(summary.accessed_network);", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio)", " {", "     int i;", "     BIO *out = NULL, *btmp = NULL;", "     X509_ALGOR *xa = NULL;", "     const EVP_CIPHER *evp_cipher = NULL;", "     STACK_OF(X509_ALGOR) *md_sk = NULL;", "     STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;", "     X509_ALGOR *xalg = NULL;", "      PKCS7_RECIP_INFO *ri = NULL;", "      ASN1_OCTET_STRING *os = NULL;", "  ", "     if (p7 == NULL) {", "         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_INVALID_NULL_POINTER);", "         return NULL;", "     }", "      ", "     if (p7->d.ptr == NULL) {", "         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_NO_CONTENT);", "         return NULL;", "     }", " ", "      i = OBJ_obj2nid(p7->type);", "      p7->state = PKCS7_S_HEADER;", "  ", "         if (evp_cipher == NULL) {", "             PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_CIPHER_NOT_INITIALIZED);", "             goto err;", "         }", "         break;", "     case NID_pkcs7_digest:", "         xa = p7->d.digest->md;", "         os = PKCS7_get_octet_string(p7->d.digest->contents);", "         break;", "     case NID_pkcs7_data:", "         break;", "     default:", "         PKCS7err(PKCS7_F_PKCS7_DATAINIT, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);", "         goto err;", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void * CAPSTONE_API cs_winkernel_malloc(size_t size)", " {", " \tNT_ASSERT(size);", "  ", "  #pragma prefast(suppress : 30030)\t\t ", "\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(", "\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);", " \tsize_t number_of_bytes = 0;", " \tCS_WINKERNEL_MEMBLOCK *block = NULL;", " \t ", " \t ", " \t ", " \tif (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {", " \t\treturn NULL;", " \t}", " \tblock = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(", " \t\t\tNonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);", "  \tif (!block) {", "  \t\treturn NULL;", "  \t}", " \tblock->size = size;", " ", " \treturn block->data;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool LocalFrameClientImpl::NavigateBackForward(int offset) const {", "   WebViewImpl* webview = web_frame_->ViewImpl();", "   if (!webview->Client())", "     return false;", " ", "   DCHECK(offset);", "   if (offset > webview->Client()->HistoryForwardListCount())", "      return false;", "    if (offset < -webview->Client()->HistoryBackListCount())", "      return false;", "  webview->Client()->NavigateBackForwardSoon(offset);", " ", "   bool has_user_gesture =", "       Frame::HasTransientUserActivation(web_frame_->GetFrame());", "   webview->Client()->NavigateBackForwardSoon(offset, has_user_gesture);", "    return true;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["  void LocalFileSystem::fileSystemNotAvailable(", "      PassRefPtrWillBeRawPtr<ExecutionContext> context,", "    PassRefPtr<CallbackWrapper> callbacks)", "     CallbackWrapper* callbacks)", "  {", "      context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));", "  }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" store_current_palette(png_store *ps, int *npalette)", " {", "   ", "     if (ps->current == NULL)", "    {", "        store_log(ps, ps->pread, \"no current stream for palette\", 1);", "       return NULL;", "    }", "  ", "      ", "     *npalette = ps->current->npalette;", "  return ps->current->palette;", " }"], "ner_tags": [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": ["  static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)", "  {", "  \tstruct xen_pcibk_dev_data *dev_data;", "  \tint err;", " \tu16 val;", " \tstruct pci_cmd_info *cmd = data;", "  ", "  \tdev_data = pci_get_drvdata(dev);", "  \tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {", " \t\tif (unlikely(verbose_request))", " \t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable\\n\",", " \t\t\t       pci_name(dev));", " \t\terr = pci_enable_device(dev);", " \t\tif (err)", " \t\t\treturn err;", " \t\tif (dev_data)", " \t\t\tdev_data->enable_intx = 1;", " \t} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {", " \t\tif (unlikely(verbose_request))", " \t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: disable\\n\",", " \t\t\t       pci_name(dev));", " \t\tpci_disable_device(dev);", " \t\tif (dev_data)", " \t\t\tdev_data->enable_intx = 0;", " \t}", " ", " \tif (!dev->is_busmaster && is_master_cmd(value)) {", " \t\tif (unlikely(verbose_request))", " \t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: set bus master\\n\",", " \t\t\t       pci_name(dev));", " \t\tpci_set_master(dev);", " \t}", " ", " \tif (value & PCI_COMMAND_INVALIDATE) {", " \t\tif (unlikely(verbose_request))", " \t\t\tprintk(KERN_DEBUG", " \t\t\t       DRV_NAME \": %s: enable memory-write-invalidate\\n\",", " \t\t\t       pci_name(dev));", " \t\terr = pci_set_mwi(dev);", " \t\tif (err) {", " \t\t\tpr_warn(\"%s: cannot enable memory-write-invalidate (%d)\\n\",", " \t\t\t\tpci_name(dev), err);", " \t\t\tvalue &= ~PCI_COMMAND_INVALIDATE;", "  \t\t}", "  \t}", "  ", " \tcmd->val = value;", " ", " \tif (!permissive && (!dev_data || !dev_data->permissive))", " \t\treturn 0;", " ", " \t ", " \terr = pci_read_config_word(dev, offset, &val);", " \tif (err || val == value)", " \t\treturn err;", " ", " \tvalue &= PCI_COMMAND_GUEST;", " \tvalue |= val & ~PCI_COMMAND_GUEST;", " ", "  \treturn pci_write_config_word(dev, offset, value);", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" EntrySync* WorkerGlobalScopeFileSystem::webkitResolveLocalFileSystemSyncURL(WorkerGlobalScope& worker, const String& url, ExceptionState& exceptionState)", " {", "     KURL completedURL = worker.completeURL(url);", "     ExecutionContext* secureContext = worker.executionContext();", "     if (!secureContext->securityOrigin()->canAccessFileSystem() || !secureContext->securityOrigin()->canRequest(completedURL)) {", "         exceptionState.throwSecurityError(FileError::securityErrorMessage);", "         return 0;", "     }", " ", "     if (!completedURL.isValid()) {", "         exceptionState.throwDOMException(EncodingError, \"the URL '\" + url + \"' is invalid.\");", "          return 0;", "      }", "  ", "    RefPtr<EntrySyncCallbackHelper> resolveURLHelper = EntrySyncCallbackHelper::create();", "     EntrySyncCallbackHelper* resolveURLHelper = EntrySyncCallbackHelper::create();", "      OwnPtr<AsyncFileSystemCallbacks> callbacks = ResolveURICallbacks::create(resolveURLHelper->successCallback(), resolveURLHelper->errorCallback(), &worker);", "      callbacks->setShouldBlockUntilCompletion(true);", "  ", "     LocalFileSystem::from(worker)->resolveURL(&worker, completedURL, callbacks.release());", " ", "     return resolveURLHelper->getResult(exceptionState);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" fr_print(netdissect_options *ndo,", "          register const u_char *p, u_int length)", " {", " \tint ret;", " \tuint16_t extracted_ethertype;", " \tu_int dlci;", " \tu_int addr_len;", " \tuint16_t nlpid;", " \tu_int hdr_len;", " \tuint8_t flags[4];", " ", " \tret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);", " \tif (ret == -1)", " \t\tgoto trunc;", " \tif (ret == 0) {", " \t\tND_PRINT((ndo, \"Q.922, invalid address\"));", " \t\treturn 0;", " \t}", " ", " \tND_TCHECK(p[addr_len]);", " \tif (length < addr_len + 1)", " \t\tgoto trunc;", " ", " \tif (p[addr_len] != LLC_UI && dlci != 0) {", "                  ", " \t\tif (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {", "                          ", "                         ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));", "                 } else {", "                         extracted_ethertype = EXTRACT_16BITS(p+addr_len);", " ", "                         if (ndo->ndo_eflag)", "                                 fr_hdr_print(ndo, length, addr_len, dlci,", "                                     flags, extracted_ethertype);", " ", "                         if (ethertype_print(ndo, extracted_ethertype,", "                                             p+addr_len+ETHERTYPE_LEN,", "                                             length-addr_len-ETHERTYPE_LEN,", "                                             ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,", "                                             NULL, NULL) == 0)", "                                  ", "                                 ND_PRINT((ndo, \"UI %02x! \", p[addr_len]));", "                         else", "                                 return addr_len + 2;", "                 }", "         }", " ", " \tND_TCHECK(p[addr_len+1]);", " \tif (length < addr_len + 2)", " \t\tgoto trunc;", " ", " \tif (p[addr_len + 1] == 0) {", " \t\t ", " \t\tif (addr_len != 3)", " \t\t\tND_PRINT((ndo, \"Pad! \"));", " \t\thdr_len = addr_len + 1   + 1   + 1  ;", " \t} else {", " \t\t ", " \t\tif (addr_len == 3)", " \t\t\tND_PRINT((ndo, \"No pad! \"));", " \t\thdr_len = addr_len + 1   + 1  ;", " \t}", " ", "         ND_TCHECK(p[hdr_len - 1]);", " \tif (length < hdr_len)", " \t\tgoto trunc;", " \tnlpid = p[hdr_len - 1];", " ", " \tif (ndo->ndo_eflag)", " \t\tfr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);", " \tp += hdr_len;", " \tlength -= hdr_len;", " ", " \tswitch (nlpid) {", " \tcase NLPID_IP:", " \t        ip_print(ndo, p, length);", " \t\tbreak;", " ", " \tcase NLPID_IP6:", " \t\tip6_print(ndo, p, length);", " \t\tbreak;", " ", "  \tcase NLPID_CLNP:", "  \tcase NLPID_ESIS:", "  \tcase NLPID_ISIS:", "\t\tisoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1);  ", " \t\tisoclns_print(ndo, p - 1, length + 1);  ", "  \t\tbreak;", "  ", "  \tcase NLPID_SNAP:", " \t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {", " \t\t\t ", "                         if (!ndo->ndo_eflag)", "                             fr_hdr_print(ndo, length + hdr_len, hdr_len,", "                                          dlci, flags, nlpid);", " \t\t\tif (!ndo->ndo_suppress_default_print)", " \t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);", " \t\t}", " \t\tbreak;", " ", "         case NLPID_Q933:", " \t\tq933_print(ndo, p, length);", " \t\tbreak;", " ", "         case NLPID_MFR:", "                 frf15_print(ndo, p, length);", "                 break;", " ", "         case NLPID_PPP:", "                 ppp_print(ndo, p, length);", "                 break;", " ", " \tdefault:", " \t\tif (!ndo->ndo_eflag)", "                     fr_hdr_print(ndo, length + hdr_len, addr_len,", " \t\t\t\t     dlci, flags, nlpid);", " \t\tif (!ndo->ndo_xflag)", " \t\t\tND_DEFAULTPRINT(p, length);", " \t}", " ", " \treturn hdr_len;", " ", "  trunc:", "         ND_PRINT((ndo, \"[|fr]\"));", "         return 0;", " ", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void snd_timer_check_master(struct snd_timer_instance *master)", " {", " \tstruct snd_timer_instance *slave, *tmp;", " ", " \t ", " \tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {", " \t\tif (slave->slave_class == master->slave_class &&", "  \t\t    slave->slave_id == master->slave_id) {", "  \t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);", "  \t\t\tspin_lock_irq(&slave_active_lock);", " \t\t\tspin_lock(&master->timer->lock);", "  \t\t\tslave->master = master;", "  \t\t\tslave->timer = master->timer;", "  \t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)", "  \t\t\t\tlist_add_tail(&slave->active_list,", "  \t\t\t\t\t      &master->slave_active_head);", " \t\t\tspin_unlock(&master->timer->lock);", "  \t\t\tspin_unlock_irq(&slave_active_lock);", "  \t\t}", "  \t}", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]}
{"tokens": ["  int ras_validate(jas_stream_t *in)", "  {", "\tuchar buf[RAS_MAGICLEN];", " \tjas_uchar buf[RAS_MAGICLEN];", "  \tint i;", "  \tint n;", "  \tuint_fast32_t magic;", " ", " \tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);", " ", " \t ", " \tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {", " \t\treturn -1;", " \t}", " ", " \t ", " \tfor (i = n - 1; i >= 0; --i) {", " \t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {", " \t\t\treturn -1;", " \t\t}", " \t}", " ", " \t ", " \tif (n < RAS_MAGICLEN) {", " \t\treturn -1;", " \t}", " ", " \tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |", " \t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |", " \t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |", " \t  buf[3];", " ", " \t ", " \tif (magic != RAS_MAGIC) {", " \t\treturn -1;", " \t}", " \treturn 0;", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["fetch_token_in_cc(OnigToken* tok, UChar** src, UChar* end, ScanEnv* env)", "{", "int num;", "OnigCodePoint c, c2;", "OnigSyntaxType* syn = env->syntax;", "OnigEncoding enc = env->enc;", "UChar* prev;", "UChar* p = *src;", "PFETCH_READY;", "", "if (PEND) {", "tok->type = TK_EOT;", "return tok->type;", "}", "", "PFETCH(c);", "tok->type = TK_CHAR;", "tok->base = 0;", "tok->u.c  = c;", "tok->escaped = 0;", "", "if (c == ']') {", "tok->type = TK_CC_CLOSE;", "}", "else if (c == '-') {", "tok->type = TK_CC_RANGE;", "}", "else if (c == MC_ESC(syn)) {", "if (! IS_SYNTAX_BV(syn, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC))", "goto end;", "", "if (PEND) return ONIGERR_END_PATTERN_AT_ESCAPE;", "", "PFETCH(c);", "tok->escaped = 1;", "tok->u.c = c;", "switch (c) {", "case 'w':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 0;", "break;", "case 'W':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_WORD;", "tok->u.prop.not   = 1;", "break;", "case 'd':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'D':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_DIGIT;", "tok->u.prop.not   = 1;", "break;", "case 's':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 0;", "break;", "case 'S':", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_SPACE;", "tok->u.prop.not   = 1;", "break;", "case 'h':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 0;", "break;", "case 'H':", "if (! IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_H_XDIGIT)) break;", "tok->type = TK_CHAR_TYPE;", "tok->u.prop.ctype = ONIGENC_CTYPE_XDIGIT;", "tok->u.prop.not   = 1;", "break;", "", "case 'p':", "case 'P':", "if (PEND) break;", "", "c2 = PPEEK;", "if (c2 == '{' &&", "IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY)) {", "PINC;", "tok->type = TK_CHAR_PROPERTY;", "tok->u.prop.not = (c == 'P' ? 1 : 0);", "", "if (!PEND && IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT)) {", "PFETCH(c2);", "if (c2 == '^') {", "tok->u.prop.not = (tok->u.prop.not == 0 ? 1 : 0);", "}", "else", "PUNFETCH;", "}", "}", "break;", "", "case 'x':", "if (PEND) break;", "", "prev = p;", "if (PPEEK_IS('{') && IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_BRACE_HEX8)) {", "PINC;", "num = scan_unsigned_hexadecimal_number(&p, end, 8, enc);", "if (num < 0) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;", "if (!PEND) {", "c2 = PPEEK;", "if (ONIGENC_IS_CODE_XDIGIT(enc, c2))", "return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE;", "}", "", "if (p > prev + enclen(enc, prev) && !PEND && (PPEEK_IS('}'))) {", "PINC;", "tok->type   = TK_CODE_POINT;", "tok->base   = 16;", "tok->u.code = (OnigCodePoint )num;", "}", "else {", "", "p = prev;", "}", "}", "else if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_X_HEX2)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 2, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 16;", "tok->u.c  = num;", "}", "break;", "", "case 'u':", "if (PEND) break;", "", "prev = p;", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_ESC_U_HEX4)) {", "num = scan_unsigned_hexadecimal_number(&p, end, 4, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type   = TK_CODE_POINT;", "tok->base   = 16;", "tok->u.code = (OnigCodePoint )num;", "}", "break;", "", "case '0':", "case '1': case '2': case '3': case '4': case '5': case '6': case '7':", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {", "PUNFETCH;", "prev = p;", "num = scan_unsigned_octal_number(&p, end, 3, enc);", "if (num < 0) return ONIGERR_TOO_BIG_NUMBER;", "if (p == prev) {", "num = 0;", "}", "tok->type = TK_RAW_BYTE;", "tok->base = 8;", "tok->u.c  = num;", "}", "break;", "", "default:", "PUNFETCH;", "num = fetch_escaped_value(&p, end, env, &c2);", "if (num < 0) return num;", "if (tok->u.c != c2) {", "tok->u.code = c2;", "tok->type   = TK_CODE_POINT;", "}", "break;", "}", "}", "else if (c == '[') {", "if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_POSIX_BRACKET) && (PPEEK_IS(':'))) {", "OnigCodePoint send[] = { (OnigCodePoint )':', (OnigCodePoint )']' };", "tok->backp = p;", "PINC;", "if (str_exist_check_with_esc(send, 2, p, end,", "(OnigCodePoint )']', enc, syn)) {", "tok->type = TK_POSIX_BRACKET_OPEN;", "}", "else {", "PUNFETCH;", "goto cc_in_cc;", "}", "}", "else {", "cc_in_cc:", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP)) {", "tok->type = TK_CC_CC_OPEN;", "}", "else {", "CC_ESC_WARN(env, (UChar* )\"[\");", "}", "}", "}", "else if (c == '&') {", "if (IS_SYNTAX_OP2(syn, ONIG_SYN_OP2_CCLASS_SET_OP) &&", "!PEND && (PPEEK_IS('&'))) {", "PINC;", "tok->type = TK_CC_AND;", "}", "}", "", "end:", "*src = p;", "return tok->type;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" long join_session_keyring(const char *name)", " {", " \tconst struct cred *old;", " \tstruct cred *new;", " \tstruct key *keyring;", " \tlong ret, serial;", " ", " \tnew = prepare_creds();", " \tif (!new)", " \t\treturn -ENOMEM;", " \told = current_cred();", " ", " \t ", " \tif (!name) {", " \t\tret = install_session_keyring_to_cred(new, NULL);", " \t\tif (ret < 0)", " \t\t\tgoto error;", " ", " \t\tserial = new->session_keyring->serial;", " \t\tret = commit_creds(new);", " \t\tif (ret == 0)", " \t\t\tret = serial;", " \t\tgoto okay;", " \t}", " ", " \t ", " \tmutex_lock(&key_session_mutex);", " ", " \t ", " \tkeyring = find_keyring_by_name(name, false);", " \tif (PTR_ERR(keyring) == -ENOKEY) {", " \t\t ", " \t\tkeyring = keyring_alloc(", " \t\t\tname, old->uid, old->gid, old,", " \t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,", " \t\t\tKEY_ALLOC_IN_QUOTA, NULL);", " \t\tif (IS_ERR(keyring)) {", " \t\t\tret = PTR_ERR(keyring);", " \t\t\tgoto error2;", " \t\t}", " \t} else if (IS_ERR(keyring)) {", "  \t\tret = PTR_ERR(keyring);", "  \t\tgoto error2;", "  \t} else if (keyring == new->session_keyring) {", " \t\tkey_put(keyring);", "  \t\tret = 0;", "  \t\tgoto error2;", "  \t}", " ", " \t ", " \tret = install_session_keyring_to_cred(new, keyring);", " \tif (ret < 0)", " \t\tgoto error2;", " ", " \tcommit_creds(new);", " \tmutex_unlock(&key_session_mutex);", " ", " \tret = keyring->serial;", " \tkey_put(keyring);", " okay:", " \treturn ret;", " ", " error2:", " \tmutex_unlock(&key_session_mutex);", " error:", " \tabort_creds(new);", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xsltIf(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,", " \t           xmlNodePtr inst, xsltStylePreCompPtr castedComp)", " {", "     int res = 0;", " ", " #ifdef XSLT_REFACTORED", "     xsltStyleItemIfPtr comp = (xsltStyleItemIfPtr) castedComp;", " #else", "     xsltStylePreCompPtr comp = castedComp;", " #endif", " ", "     if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL))", " \treturn;", "     if ((comp == NULL) || (comp->test == NULL) || (comp->comp == NULL)) {", " \txsltTransformError(ctxt, NULL, inst,", " \t    \"Internal error in xsltIf(): \"", " \t    \"The XSLT 'if' instruction was not compiled.\\n\");", " \treturn;", "     }", " ", " #ifdef WITH_XSLT_DEBUG_PROCESS", "     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,", " \t \"xsltIf: test %s\\n\", comp->test));", " #endif", "  ", "  #ifdef XSLT_FAST_IF", "      {", "\txmlXPathContextPtr xpctxt = ctxt->xpathCtxt;", "\txmlDocPtr oldXPContextDoc = xpctxt->doc;", "\txmlNsPtr *oldXPNamespaces = xpctxt->namespaces;", "\txmlNodePtr oldXPContextNode = xpctxt->node;", "\tint oldXPProximityPosition = xpctxt->proximityPosition;", "\tint oldXPContextSize = xpctxt->contextSize;", "\tint oldXPNsNr = xpctxt->nsNr;", "  \txmlDocPtr oldLocalFragmentTop = ctxt->localRVT;", "  ", "\txpctxt->node = contextNode;", "\tif (comp != NULL) {", "#ifdef XSLT_REFACTORED", "\t    if (comp->inScopeNs != NULL) {", "\t\txpctxt->namespaces = comp->inScopeNs->list;", "\t\txpctxt->nsNr = comp->inScopeNs->xpathNumber;", "\t    } else {", "\t\txpctxt->namespaces = NULL;", "\t\txpctxt->nsNr = 0;", "\t    }", "#else", "\t    xpctxt->namespaces = comp->nsList;", "\t    xpctxt->nsNr = comp->nsNr;", "#endif", "\t} else {", "\t    xpctxt->namespaces = NULL;", "\t    xpctxt->nsNr = 0;", "\t}", "\t ", "\tres = xmlXPathCompiledEvalToBoolean(comp->comp, xpctxt);", " \tres = xsltPreCompEvalToBoolean(ctxt, contextNode, comp);", "  ", "  \t ", "  \tif (oldLocalFragmentTop != ctxt->localRVT)", "  \t    xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);", "\txpctxt->doc = oldXPContextDoc;", "\txpctxt->node = oldXPContextNode;", "\txpctxt->contextSize = oldXPContextSize;", "\txpctxt->proximityPosition = oldXPProximityPosition;", "\txpctxt->nsNr = oldXPNsNr;", "\txpctxt->namespaces = oldXPNamespaces;", "      }", "  ", "  #ifdef WITH_XSLT_DEBUG_PROCESS", "     XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,", " \t\"xsltIf: test evaluate to %d\\n\", res));", " #endif", " ", "     if (res == -1) {", " \tctxt->state = XSLT_STATE_STOPPED;", " \tgoto error;", "     }", "     if (res == 1) {", " \t ", " \txsltApplySequenceConstructor(ctxt,", " \t    contextNode, inst->children, NULL);", "     }", "  ", "  #else  ", "      {", "\txmlXPathObjectPtr xpobj = NULL;", "  \t ", "\t{", "\t    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;", "\t    xmlDocPtr oldXPContextDoc = xpctxt->doc;", "\t    xmlNsPtr *oldXPNamespaces = xpctxt->namespaces;", "\t    xmlNodePtr oldXPContextNode = xpctxt->node;", "\t    int oldXPProximityPosition = xpctxt->proximityPosition;", "\t    int oldXPContextSize = xpctxt->contextSize;", "\t    int oldXPNsNr = xpctxt->nsNr;", "\t    xpctxt->node = contextNode;", "\t    if (comp != NULL) {", "#ifdef XSLT_REFACTORED", "\t\tif (comp->inScopeNs != NULL) {", "\t\t    xpctxt->namespaces = comp->inScopeNs->list;", "\t\t    xpctxt->nsNr = comp->inScopeNs->xpathNumber;", "\t\t} else {", "\t\t    xpctxt->namespaces = NULL;", "\t\t    xpctxt->nsNr = 0;", "\t\t}", "#else", "\t\txpctxt->namespaces = comp->nsList;", "\t\txpctxt->nsNr = comp->nsNr;", "#endif", "\t    } else {", "\t\txpctxt->namespaces = NULL;", "\t\txpctxt->nsNr = 0;", "\t    }", "\t     ", "\t    xpobj = xmlXPathCompiledEval(comp->comp, xpctxt);", "\t    xpctxt->doc = oldXPContextDoc;", "\t    xpctxt->node = oldXPContextNode;", "\t    xpctxt->contextSize = oldXPContextSize;", "\t    xpctxt->proximityPosition = oldXPProximityPosition;", "\t    xpctxt->nsNr = oldXPNsNr;", "\t    xpctxt->namespaces = oldXPNamespaces;", "\t}", " \txmlXPathObjectPtr xpobj = xsltPreCompEval(ctxt, contextNode, comp);", "  \tif (xpobj != NULL) {", "  \t    if (xpobj->type != XPATH_BOOLEAN)", "  \t\txpobj = xmlXPathConvertBoolean(xpobj);", " \t    if (xpobj->type == XPATH_BOOLEAN) {", " \t\tres = xpobj->boolval;", " ", " #ifdef WITH_XSLT_DEBUG_PROCESS", " \t\tXSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,", " \t\t    \"xsltIf: test evaluate to %d\\n\", res));", " #endif", " \t\tif (res) {", " \t\t    xsltApplySequenceConstructor(ctxt,", " \t\t\tcontextNode, inst->children, NULL);", " \t\t}", " \t    } else {", " ", " #ifdef WITH_XSLT_DEBUG_PROCESS", " \t\tXSLT_TRACE(ctxt, XSLT_TRACE_IF,", " \t\t    xsltGenericDebug(xsltGenericDebugContext,", " \t\t    \"xsltIf: test didn't evaluate to a boolean\\n\"));", " #endif", " \t\tctxt->state = XSLT_STATE_STOPPED;", " \t    }", " \t    xmlXPathFreeObject(xpobj);", " \t} else {", " \t    ctxt->state = XSLT_STATE_STOPPED;", " \t}", "     }", " #endif  ", " ", " error:", "     return;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void update_logging() {", "  bool should_log = module_started &&", "  (logging_enabled_via_api || stack_config->get_btsnoop_turned_on());", " ", "  if (should_log == is_logging)", "  return;", " ", "   is_logging = should_log;", "  if (should_log) {", "     btsnoop_net_open();", " ", "  const char *log_path = stack_config->get_btsnoop_log_path();", " ", "  if (stack_config->get_btsnoop_should_save_last()) {", "  char last_log_path[PATH_MAX];", "       snprintf(last_log_path, PATH_MAX, \"%s.%llu\", log_path, btsnoop_timestamp());", "  if (!rename(log_path, last_log_path) && errno != ENOENT)", " ", "          LOG_ERROR(\"%s unable to rename '%s' to '%s': %s\", __func__, log_path, last_log_path, strerror(errno));", "      }", "  ", "    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);", "     logfile_fd = TEMP_FAILURE_RETRY(open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));", "      if (logfile_fd == INVALID_FD) {", "        LOG_ERROR(\"%s unable to open '%s': %s\", __func__, log_path, strerror(errno));", "        is_logging = false;", "        return;", "      }", "  ", "    write(logfile_fd, \"btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\", 16);", "     TEMP_FAILURE_RETRY(write(logfile_fd, \"btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\", 16));", "    } else {", "      if (logfile_fd != INVALID_FD)", "        close(logfile_fd);", " ", "     logfile_fd = INVALID_FD;", "     btsnoop_net_close();", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType SetGrayscaleImage(Image *image)", " {", "   CacheView", "     *image_view;", " ", "   ExceptionInfo", "     *exception;", " ", "   MagickBooleanType", "     status;", " ", "   PixelPacket", "     *colormap;", " ", "   register ssize_t", "     i;", " ", "   ssize_t", "     *colormap_index,", "     j,", "     y;", " ", "   assert(image != (Image *) NULL);", "   assert(image->signature == MagickSignature);", "   if (image->type != GrayscaleType)", "     (void) TransformImageColorspace(image,GRAYColorspace);", "   colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,", "     sizeof(*colormap_index));", "   if (colormap_index == (ssize_t *) NULL)", "     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",", "       image->filename);", "   if (image->storage_class != PseudoClass)", "     {", "       ExceptionInfo", "         *exception;", " ", "        (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*", "          sizeof(*colormap_index));", "        if (AcquireImageColormap(image,MaxColormapSize) == MagickFalse)", "        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",", "          image->filename);", "         {", "           colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);", "           ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",", "             image->filename);", "         }", "        image->colors=0;", "        status=MagickTrue;", "        exception=(&image->exception);", "       image_view=AcquireAuthenticCacheView(image,exception);", " #if defined(MAGICKCORE_OPENMP_SUPPORT)", "       #pragma omp parallel for schedule(static,4) shared(status) \\", "         magick_threads(image,image,image->rows,1)", " #endif", "       for (y=0; y < (ssize_t) image->rows; y++)", "       {", "         register IndexPacket", "           *magick_restrict indexes;", " ", "         register PixelPacket", "           *magick_restrict q;", " ", "         register ssize_t", "           x;", " ", "         if (status == MagickFalse)", "           continue;", "         q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,", "           exception);", "         if (q == (PixelPacket *) NULL)", "           {", "             status=MagickFalse;", "             continue;", "           }", "         indexes=GetCacheViewAuthenticIndexQueue(image_view);", "         for (x=0; x < (ssize_t) image->columns; x++)", "         {", "           register size_t", "             intensity;", " ", "           intensity=ScaleQuantumToMap(GetPixelRed(q));", "           if (colormap_index[intensity] < 0)", "             {", " #if defined(MAGICKCORE_OPENMP_SUPPORT)", "               #pragma omp critical (MagickCore_SetGrayscaleImage)", " #endif", "               if (colormap_index[intensity] < 0)", "                 {", "                   colormap_index[intensity]=(ssize_t) image->colors;", "                   image->colormap[image->colors].red=GetPixelRed(q);", "                   image->colormap[image->colors].green=GetPixelGreen(q);", "                   image->colormap[image->colors].blue=GetPixelBlue(q);", "                   image->colors++;", "                }", "             }", "           SetPixelIndex(indexes+x,colormap_index[intensity]);", "           q++;", "         }", "         if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)", "           status=MagickFalse;", "       }", "       image_view=DestroyCacheView(image_view);", "     }", "   for (i=0; i < (ssize_t) image->colors; i++)", "     image->colormap[i].opacity=(unsigned short) i;", "   qsort((void *) image->colormap,image->colors,sizeof(PixelPacket),", "     IntensityCompare);", "   colormap=(PixelPacket *) AcquireQuantumMemory(image->colors,", "     sizeof(*colormap));", "   if (colormap == (PixelPacket *) NULL)", "     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",", "       image->filename);", "   j=0;", "   colormap[j]=image->colormap[0];", "   for (i=0; i < (ssize_t) image->colors; i++)", "   {", "     if (IsSameColor(image,&colormap[j],&image->colormap[i]) == MagickFalse)", "       {", "         j++;", "         colormap[j]=image->colormap[i];", "       }", "     colormap_index[(ssize_t) image->colormap[i].opacity]=j;", "   }", "   image->colors=(size_t) (j+1);", "   image->colormap=(PixelPacket *) RelinquishMagickMemory(image->colormap);", "   image->colormap=colormap;", "   status=MagickTrue;", "   exception=(&image->exception);", "   image_view=AcquireAuthenticCacheView(image,exception);", " #if defined(MAGICKCORE_OPENMP_SUPPORT)", "   #pragma omp parallel for schedule(static,4) shared(status) \\", "     magick_threads(image,image,image->rows,1)", " #endif", "   for (y=0; y < (ssize_t) image->rows; y++)", "   {", "     register IndexPacket", "       *magick_restrict indexes;", " ", "     register const PixelPacket", "       *magick_restrict q;", " ", "     register ssize_t", "       x;", " ", "     if (status == MagickFalse)", "       continue;", "     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);", "     if (q == (PixelPacket *) NULL)", "       {", "         status=MagickFalse;", "         continue;", "       }", "     indexes=GetCacheViewAuthenticIndexQueue(image_view);", "     for (x=0; x < (ssize_t) image->columns; x++)", "       SetPixelIndex(indexes+x,colormap_index[ScaleQuantumToMap(GetPixelIndex(", "         indexes+x))]);", "     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)", "       status=MagickFalse;", "   }", "   image_view=DestroyCacheView(image_view);", "   colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);", "   image->type=GrayscaleType;", "   if (SetImageMonochrome(image,&image->exception) != MagickFalse)", "     image->type=BilevelType;", "   return(status);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void GDataFileSystem::OnCopyDocumentCompleted(", "     const FilePath& dir_path,", "     const FileOperationCallback& callback,", "     GDataErrorCode status,", "     scoped_ptr<base::Value> data) {", "   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));", "   DCHECK(!callback.is_null());", " ", "   GDataFileError error = util::GDataToGDataFileError(status);", "   if (error != GDATA_FILE_OK) {", "     callback.Run(error);", "     return;", "   }", " ", "   scoped_ptr<DocumentEntry> doc_entry(DocumentEntry::ExtractAndParse(*data));", "   if (!doc_entry.get()) {", "     callback.Run(GDATA_FILE_ERROR_FAILED);", "      return;", "    }", "  ", "  GDataEntry* entry = GDataEntry::FromDocumentEntry(", "      NULL, doc_entry.get(), directory_service_.get());", "   GDataEntry* entry = directory_service_->FromDocumentEntry(doc_entry.get());", "    if (!entry) {", "      callback.Run(GDATA_FILE_ERROR_FAILED);", "      return;", "   }", " ", "   directory_service_->root()->AddEntry(entry);", "   MoveEntryFromRootDirectory(dir_path,", "                              callback,", "                              GDATA_FILE_OK,", "                              entry->GetFilePath());", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" main(int argc,", "      char **argv)", " {", "    int i, gn;", "    int test = 0;", "    char *action = NULL, *cmd;", "    char *output = NULL;", " #ifdef HAVE_EEZE_MOUNT", "    Eina_Bool mnt = EINA_FALSE;", "    const char *act;", " #endif", "    gid_t gid, gl[65536], egid;", "    int pid = 0;", " ", "    for (i = 1; i < argc; i++)", "     const char *act;", "  #endif", "     gid_t gid, gl[65536], egid;", "   int pid = 0;", "  ", "     for (i = 1; i < argc; i++)", "       {", "                \"This is an internal tool for Enlightenment.\\n\"", "                \"do not use it.\\n\"", "                );", "              exit(0);", "           }", "      }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,", " \t      const struct isakmp_gen *ext, u_int item_len,", " \t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,", " \t      uint32_t proto0 _U_, int depth _U_)", " {", " \tconst struct ikev1_pl_n *p;", " \tstruct ikev1_pl_n n;", " \tconst u_char *cp;", " \tconst u_char *ep2;", " \tuint32_t doi;", " \tuint32_t proto;", " \tstatic const char *notify_error_str[] = {", " \t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",", " \t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",", " \t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",", " \t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",", " \t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",", " \t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",", " \t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",", " \t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",", " \t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",", " \t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",", " \t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",", " \t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",", " \t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",", " \t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",", " \t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",", " \t\t\"UNEQUAL-PAYLOAD-LENGTHS\",", " \t};", " \tstatic const char *ipsec_notify_error_str[] = {", " \t\t\"RESERVED\",", " \t};", " \tstatic const char *notify_status_str[] = {", " \t\t\"CONNECTED\",", " \t};", " \tstatic const char *ipsec_notify_status_str[] = {", " \t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",", " \t\t\"INITIAL-CONTACT\",", " \t};", "  ", " ", "  ", " #define NOTIFY_ERROR_STR(x) \\", " \tSTR_OR_ID((x), notify_error_str)", " ", "  ", " #define IPSEC_NOTIFY_ERROR_STR(x) \\", " \tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)", " ", "  ", " #define NOTIFY_STATUS_STR(x) \\", " \tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)", " ", "  ", " #define IPSEC_NOTIFY_STATUS_STR(x) \\", " \tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)", " ", " \tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));", " ", " \tp = (const struct ikev1_pl_n *)ext;", " \tND_TCHECK(*p);", " \tUNALIGNED_MEMCPY(&n, ext, sizeof(n));", " \tdoi = ntohl(n.doi);", " \tproto = n.prot_id;", " \tif (doi != 1) {", " \t\tND_PRINT((ndo,\" doi=%d\", doi));", " \t\tND_PRINT((ndo,\" proto=%d\", proto));", " \t\tif (ntohs(n.type) < 8192)", " \t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));", " \t\telse if (ntohs(n.type) < 16384)", " \t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));", " \t\telse if (ntohs(n.type) < 24576)", " \t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));", " \t\telse", " \t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));", " \t\tif (n.spi_size) {", " \t\t\tND_PRINT((ndo,\" spi=\"));", " \t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))", " \t\t\t\tgoto trunc;", " \t\t}", " \t\treturn (const u_char *)(p + 1) + n.spi_size;", " \t}", " ", " \tND_PRINT((ndo,\" doi=ipsec\"));", " \tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));", " \tif (ntohs(n.type) < 8192)", " \t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));", " \telse if (ntohs(n.type) < 16384)", " \t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));", " \telse if (ntohs(n.type) < 24576)", " \t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));", " \telse if (ntohs(n.type) < 32768)", " \t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));", " \telse", " \t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));", " \tif (n.spi_size) {", " \t\tND_PRINT((ndo,\" spi=\"));", " \t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))", " \t\t\tgoto trunc;", " \t}", " ", " \tcp = (const u_char *)(p + 1) + n.spi_size;", " \tep2 = (const u_char *)p + item_len;", " ", " \tif (cp < ep) {", " \t\tswitch (ntohs(n.type)) {", " \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:", " \t\t    {", " \t\t\tconst struct attrmap *map = oakley_t_map;", " \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);", " \t\t\tND_PRINT((ndo,\" attrs=(\"));", " \t\t\twhile (cp < ep && cp < ep2) {", " \t\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);", " \t\t\t\tif (cp == NULL) {", " \t\t\t\t\tND_PRINT((ndo,\")\"));", " \t\t\t\t\tgoto trunc;", " \t\t\t\t}", " \t\t\t}", " \t\t\tND_PRINT((ndo,\")\"));", " \t\t\tbreak;", "  \t\t    }", "  \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:", "  \t\t\tND_PRINT((ndo,\" status=(\"));", " \t\t\tND_TCHECK_32BITS(cp);", "  \t\t\tND_PRINT((ndo,\"replay detection %sabled\",", "  \t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));", "  \t\t\tND_PRINT((ndo,\")\"));", " \t\t\tbreak;", " \t\tdefault:", " \t\t\t ", " \t\t\tif (ndo->ndo_vflag > 3) {", " \t\t\t\tND_PRINT((ndo,\" data=(\"));", " \t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))", " \t\t\t\t\tgoto trunc;", " \t\t\t\tND_PRINT((ndo,\")\"));", " \t\t\t} else {", " \t\t\t\tif (!ike_show_somedata(ndo, cp, ep))", " \t\t\t\t\tgoto trunc;", " \t\t\t}", " \t\t\tbreak;", " \t\t}", " \t}", " \treturn (const u_char *)ext + item_len;", " trunc:", " \tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));", " \treturn NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)", "  {", "      static gprincs_ret              ret;", "      char                            *prime_arg;", "    gss_buffer_desc                 client_name,", "        service_name;", "     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;", "     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;", "      OM_uint32                       minor_stat;", "      kadm5_server_handle_t           handle;", "      const char                      *errmsg = NULL;", " ", "     xdr_free(xdr_gprincs_ret, &ret);", " ", "     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))", "         goto exit_func;", " ", "     if ((ret.code = check_handle((void *)handle)))", "         goto exit_func;", " ", "     ret.api_version = handle->api_version;", " ", "     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {", "         ret.code = KADM5_FAILURE;", "         goto exit_func;", "     }", "     prime_arg = arg->exp;", "     if (prime_arg == NULL)", "         prime_arg = \"*\";", " ", "     if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,", "                                                        rqst2name(rqstp),", "                                                        ACL_LIST,", "                                                        NULL,", "                                                        NULL)) {", "         ret.code = KADM5_AUTH_LIST;", "         log_unauth(\"kadm5_get_principals\", prime_arg,", "                    &client_name, &service_name, rqstp);", "     } else {", "         ret.code  = kadm5_get_principals((void *)handle,", "                                          arg->exp, &ret.princs,", "                                          &ret.count);", "         if( ret.code != 0 )", "             errmsg = krb5_get_error_message(handle->context, ret.code);", " ", "         log_done(\"kadm5_get_principals\", prime_arg, errmsg,", "                  &client_name, &service_name, rqstp);", " ", "         if (errmsg != NULL)", "              krb5_free_error_message(handle->context, errmsg);", "  ", "      }", " exit_func:", "      gss_release_buffer(&minor_stat, &client_name);", "      gss_release_buffer(&minor_stat, &service_name);", "exit_func:", "      free_server_handle(handle);", "      return &ret;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"tokens": [" void RenderMessageFilter::OnCreateWindow(", "     const ViewHostMsg_CreateWindow_Params& params,", "     int* route_id,", "     int* surface_id,", "     int64* cloned_session_storage_namespace_id) {", "    bool no_javascript_access;", "    bool can_create_window =", "        GetContentClient()->browser()->CanCreateWindow(", "          GURL(params.opener_url),", "          GURL(params.opener_security_origin),", "           params.opener_url,", "           params.opener_security_origin,", "            params.window_container_type,", "            resource_context_,", "            render_process_id_,", "           &no_javascript_access);", " ", "   if (!can_create_window) {", "     *route_id = MSG_ROUTING_NONE;", "     *surface_id = 0;", "     return;", "   }", " ", "   scoped_refptr<SessionStorageNamespaceImpl> cloned_namespace =", "       new SessionStorageNamespaceImpl(dom_storage_context_,", "                                       params.session_storage_namespace_id);", "   *cloned_session_storage_namespace_id = cloned_namespace->id();", " ", "   render_widget_helper_->CreateNewWindow(params,", "                                          no_javascript_access,", "                                          peer_handle(),", "                                          route_id,", "                                          surface_id,", "                                          cloned_namespace);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,", " \t\t\t       struct pipe_inode_info *opipe,", " \t\t\t       size_t len, unsigned int flags)", " {", " \tstruct pipe_buffer *ibuf, *obuf;", " \tint ret = 0, nbuf;", " \tbool input_wakeup = false;", " ", " ", " retry:", " \tret = ipipe_prep(ipipe, flags);", " \tif (ret)", " \t\treturn ret;", " ", " \tret = opipe_prep(opipe, flags);", " \tif (ret)", " \t\treturn ret;", " ", " \t ", " \tpipe_double_lock(ipipe, opipe);", " ", " \tdo {", " \t\tif (!opipe->readers) {", " \t\t\tsend_sig(SIGPIPE, current, 0);", " \t\t\tif (!ret)", " \t\t\t\tret = -EPIPE;", " \t\t\tbreak;", " \t\t}", " ", " \t\tif (!ipipe->nrbufs && !ipipe->writers)", " \t\t\tbreak;", " ", " \t\t ", " \t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {", " \t\t\t ", " \t\t\tif (ret)", " \t\t\t\tbreak;", " ", " \t\t\tif (flags & SPLICE_F_NONBLOCK) {", " \t\t\t\tret = -EAGAIN;", " \t\t\t\tbreak;", " \t\t\t}", " ", " \t\t\t ", " \t\t\tpipe_unlock(ipipe);", " \t\t\tpipe_unlock(opipe);", " \t\t\tgoto retry;", " \t\t}", " ", " \t\tibuf = ipipe->bufs + ipipe->curbuf;", " \t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);", " \t\tobuf = opipe->bufs + nbuf;", " ", " \t\tif (len >= ibuf->len) {", " \t\t\t ", " \t\t\t*obuf = *ibuf;", " \t\t\tibuf->ops = NULL;", " \t\t\topipe->nrbufs++;", " \t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);", " \t\t\tipipe->nrbufs--;", " \t\t\tinput_wakeup = true;", " \t\t} else {", " \t\t\t ", "\t\t\tpipe_buf_get(ipipe, ibuf);", " \t\t\tif (!pipe_buf_get(ipipe, ibuf)) {", " \t\t\t\tif (ret == 0)", " \t\t\t\t\tret = -EFAULT;", " \t\t\t\tbreak;", " \t\t\t}", "  \t\t\t*obuf = *ibuf;", "  ", "  \t\t\t ", " \t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;", " ", " \t\t\tobuf->len = len;", " \t\t\topipe->nrbufs++;", " \t\t\tibuf->offset += obuf->len;", " \t\t\tibuf->len -= obuf->len;", " \t\t}", " \t\tret += obuf->len;", " \t\tlen -= obuf->len;", " \t} while (len);", " ", " \tpipe_unlock(ipipe);", " \tpipe_unlock(opipe);", " ", " \t ", " \tif (ret > 0)", " \t\twakeup_pipe_readers(opipe);", " ", " \tif (input_wakeup)", " \t\twakeup_pipe_writers(ipipe);", " ", " \treturn ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)", "  {", "      static gstrings_ret             ret;", "      char                            *prime_arg;", "    gss_buffer_desc                 client_name,", "        service_name;", "     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;", "     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;", "      OM_uint32                       minor_stat;", "      kadm5_server_handle_t           handle;", "      const char                      *errmsg = NULL;", " ", "     xdr_free(xdr_gstrings_ret, &ret);", " ", "     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))", "         goto exit_func;", " ", "     if ((ret.code = check_handle((void *)handle)))", "         goto exit_func;", " ", "     ret.api_version = handle->api_version;", " ", "     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {", "         ret.code = KADM5_FAILURE;", "         goto exit_func;", "     }", "     if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {", "         ret.code = KADM5_BAD_PRINCIPAL;", "         goto exit_func;", "     }", " ", "     if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&", "         (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,", "                                                         rqst2name(rqstp),", "                                                         ACL_INQUIRE,", "                                                         arg->princ,", "                                                         NULL))) {", "         ret.code = KADM5_AUTH_GET;", "         log_unauth(\"kadm5_get_strings\", prime_arg,", "                    &client_name, &service_name, rqstp);", "     } else {", "         ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,", "                                      &ret.count);", "         if (ret.code != 0)", "             errmsg = krb5_get_error_message(handle->context, ret.code);", " ", "         log_done(\"kadm5_get_strings\", prime_arg, errmsg,", "                  &client_name, &service_name, rqstp);", " ", "         if (errmsg != NULL)", "              krb5_free_error_message(handle->context, errmsg);", "      }", "      free(prime_arg);", " exit_func:", "      gss_release_buffer(&minor_stat, &client_name);", "      gss_release_buffer(&minor_stat, &service_name);", "exit_func:", "      free_server_handle(handle);", "      return &ret;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"tokens": [" read_png(struct control *control)", "   ", " ", "  {", "     png_structp png_ptr;", "     png_infop info_ptr = NULL;", "   volatile png_bytep row = NULL, display = NULL;", "     volatile int rc;", "  ", "     png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, control,", "       error_handler, warning_handler);", " ", "  if (png_ptr == NULL)", "  {", "   ", "       log_error(&control->file, LIBPNG_ERROR_CODE, \"OOM allocating png_struct\");", "       control->file.status_code |= INTERNAL_ERROR;", "  return LIBPNG_ERROR_CODE;", "  }", " ", " ", "     rc = setjmp(control->file.jmpbuf);", "     if (rc == 0)", "     {", " #     ifdef PNG_SET_USER_LIMITS_SUPPORTED", "           ", "          png_set_user_limits(png_ptr, 0x7fffffff, 0x7fffffff);", "          png_set_chunk_cache_max(png_ptr, 0);", "          png_set_chunk_malloc_max(png_ptr, 0);", " #     endif", " ", "        png_set_read_fn(png_ptr, control, read_callback);", "  ", "        info_ptr = png_create_info_struct(png_ptr);", "  if (info_ptr == NULL)", "          png_error(png_ptr, \"OOM allocating info structure\");", " ", "  if (control->file.global->verbose)", "          fprintf(stderr, \" INFO\\n\");", " ", " ", "        png_read_info(png_ptr, info_ptr);", "  ", "        {", "         png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);", "         png_uint_32 height = png_get_image_height(png_ptr, info_ptr);", "         int passes = png_set_interlace_handling(png_ptr);", "         int pass;", "  ", "         row = png_voidcast(png_byte*, malloc(rowbytes));", "         display = png_voidcast(png_byte*, malloc(rowbytes));", "         png_start_read_image(png_ptr);", "  ", "         if (row == NULL || display == NULL)", "            png_error(png_ptr, \"OOM allocating row buffers\");", "         for (pass = 0; pass < passes; ++pass)", "         {", "            png_uint_32 y = height;", "  ", "         {", "            png_uint_32 height = png_get_image_height(png_ptr, info_ptr);", "            int passes = png_set_interlace_handling(png_ptr);", "            int pass;", "            png_start_read_image(png_ptr);", "            for (pass = 0; pass < passes; ++pass)", "            {", "               png_uint_32 y = height;", "                ", "               while (y-- > 0)", "                  png_read_row(png_ptr, row, display);", "            }", "         }", "             ", "            while (y-- > 0)", "               png_read_row(png_ptr, NULL, NULL);", "         }", "        }", "  ", "        if (control->file.global->verbose)", "          fprintf(stderr, \" END\\n\");", " ", "   ", "       png_read_end(png_ptr, info_ptr);", " ", "     }", "  ", "     png_destroy_read_struct(&png_ptr, &info_ptr, NULL);", "   if (row != NULL) free(row);", "   if (display != NULL) free(display);", "     return rc;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": ["void recovery_cipher_finalize(void)", "{", "static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";", "static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];", "volatile bool auto_completed = true;", "", "", "char *tok = strtok(mnemonic, \" \");", "", "while(tok) {", "strlcpy(temp_word, tok, CURRENT_WORD_BUF);", "", "auto_completed &= attempt_auto_complete(temp_word);", "", "strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);", "strlcat(new_mnemonic, \" \", MNEMONIC_BUF);", "", "tok = strtok(NULL, \" \");", "}", "memzero(temp_word, sizeof(temp_word));", "", "if (!auto_completed && !enforce_wordlist) {", "if (!dry_run) {", "storage_reset();", "}", "fsm_sendFailure(FailureType_Failure_SyntaxError,", "\"Words were not entered correctly. Make sure you are using the substition cipher.\");", "awaiting_character = false;", "layoutHome();", "return;", "}", "", "", "new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';", "", "if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {", "storage_setMnemonic(new_mnemonic);", "memzero(new_mnemonic, sizeof(new_mnemonic));", "if (!enforce_wordlist) {", "", "storage_setImported(true);", "}", "storage_commit();", "fsm_sendSuccess(\"Device recovered\");", "} else if (dry_run) {", "bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);", "if (match) {", "review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",", "\"The seed is valid and MATCHES the one in the device.\");", "fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");", "} else if (mnemonic_check(new_mnemonic)) {", "review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",", "\"The seed is valid, but DOES NOT MATCH the one in the device.\");", "fsm_sendFailure(FailureType_Failure_Other,", "\"The seed is valid, but does not match the one in the device.\");", "} else {", "review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",", "\"The seed is INVALID, and DOES NOT MATCH the one in the device.\");", "fsm_sendFailure(FailureType_Failure_Other,", "\"The seed is invalid, and does not match the one in the device.\");", "}", "memzero(new_mnemonic, sizeof(new_mnemonic));", "} else {", "session_clear(true);", "fsm_sendFailure(FailureType_Failure_SyntaxError,", "\"Invalid mnemonic, are words in correct order?\");", "recovery_abort();", "}", "", "memzero(new_mnemonic, sizeof(new_mnemonic));", "awaiting_character = false;", "memzero(mnemonic, sizeof(mnemonic));", "memzero(cipher, sizeof(cipher));", "layoutHome();", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)", "{", "struct elo_priv *priv;", "int ret;", "struct usb_device *udev;", "", "if (!hid_is_usb(hdev))", "return -EINVAL;", "", "priv = kzalloc(sizeof(*priv), GFP_KERNEL);", "if (!priv)", "return -ENOMEM;", "", "INIT_DELAYED_WORK(&priv->work, elo_work);", "udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));", "priv->usbdev = usb_get_dev(udev);", "", "hid_set_drvdata(hdev, priv);", "", "ret = hid_parse(hdev);", "if (ret) {", "hid_err(hdev, \"parse failed\\n\");", "goto err_free;", "}", "", "ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);", "if (ret) {", "hid_err(hdev, \"hw start failed\\n\");", "goto err_free;", "}", "", "if (elo_broken_firmware(priv->usbdev)) {", "hid_info(hdev, \"broken firmware found, installing workaround\\n\");", "queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);", "}", "", "return 0;", "err_free:", "kfree(priv);", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" static int cypress_generic_port_probe(struct usb_serial_port *port)", " {", "  \tstruct usb_serial *serial = port->serial;", "  \tstruct cypress_private *priv;", "  ", " \tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {", " \t\tdev_err(&port->dev, \"required endpoint is missing\\n\");", " \t\treturn -ENODEV;", " \t}", " ", "  \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);", "  \tif (!priv)", "  \t\treturn -ENOMEM;", " ", " \tpriv->comm_is_ok = !0;", " \tspin_lock_init(&priv->lock);", " \tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {", " \t\tkfree(priv);", " \t\treturn -ENOMEM;", " \t}", " ", " \t ", " \tif (!is_frwd(serial->dev))", " \t\tusb_reset_configuration(serial->dev);", " ", " \tpriv->cmd_ctrl = 0;", " \tpriv->line_control = 0;", " \tpriv->termios_initialized = 0;", " \tpriv->rx_flags = 0;", " \t ", " \tif (port->interrupt_out_size > 9)", " \t\tpriv->pkt_fmt = packet_format_1;", " \telse", " \t\tpriv->pkt_fmt = packet_format_2;", " ", " \tif (interval > 0) {", " \t\tpriv->write_urb_interval = interval;", " \t\tpriv->read_urb_interval = interval;", " \t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",", " \t\t\t__func__, interval);", " \t} else {", " \t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;", " \t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;", " \t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",", " \t\t\t__func__, priv->read_urb_interval,", " \t\t\tpriv->write_urb_interval);", " \t}", " \tusb_set_serial_port_data(port, priv);", " ", " \tport->port.drain_delay = 256;", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ghash_final(struct shash_desc *desc, u8 *dst)", " {", " \tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);", "  \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);", "  \tu8 *buf = dctx->buffer;", "  ", " \tif (!ctx->gf128)", " \t\treturn -ENOKEY;", " ", "  \tghash_flush(ctx, dctx);", "  \tmemcpy(dst, buf, GHASH_BLOCK_SIZE);", "  ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" smb_fdata(netdissect_options *ndo,", "           const u_char *buf, const char *fmt, const u_char *maxbuf,", "           int unicodestr)", " {", "     static int depth = 0;", "     char s[128];", "     char *p;", " ", "     while (*fmt) {", " \tswitch (*fmt) {", " \tcase '*':", " \t    fmt++;", "  \t    while (buf < maxbuf) {", "  \t\tconst u_char *buf2;", "  \t\tdepth++;", "\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);", " \t\t ", " \t\tif (depth == 10)", " \t\t\tND_PRINT((ndo, \"(too many nested levels, not recursing)\"));", " \t\telse", " \t\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);", "  \t\tdepth--;", "  \t\tif (buf2 == NULL)", "  \t\t    return(NULL);", " \t\tif (buf2 == buf)", " \t\t    return(buf);", " \t\tbuf = buf2;", " \t    }", " \t    return(buf);", " ", " \tcase '|':", " \t    fmt++;", " \t    if (buf >= maxbuf)", " \t\treturn(buf);", " \t    break;", " ", " \tcase '%':", " \t    fmt++;", " \t    buf = maxbuf;", " \t    break;", " ", " \tcase '#':", " \t    fmt++;", " \t    return(buf);", " \t    break;", " ", " \tcase '[':", " \t    fmt++;", " \t    if (buf >= maxbuf)", " \t\treturn(buf);", " \t    memset(s, 0, sizeof(s));", " \t    p = strchr(fmt, ']');", " \t    if ((size_t)(p - fmt + 1) > sizeof(s)) {", " \t\t ", " \t\treturn(buf);", " \t    }", " \t    strncpy(s, fmt, p - fmt);", " \t    s[p - fmt] = '\\0';", " \t    fmt = p + 1;", " \t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);", " \t    if (buf == NULL)", " \t\treturn(NULL);", " \t    break;", " ", " \tdefault:", " \t    ND_PRINT((ndo, \"%c\", *fmt));", " \t    fmt++;", " \t    break;", " \t}", "     }", "     if (!depth && buf < maxbuf) {", " \tsize_t len = PTR_DIFF(maxbuf, buf);", " \tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));", " \tsmb_print_data(ndo, buf, len);", " \treturn(buf + len);", "     }", "     return(buf);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool IsSmartVirtualKeyboardEnabled() {", "   if (base::CommandLine::ForCurrentProcess()->HasSwitch(", "            keyboard::switches::kEnableVirtualKeyboard)) {", "      return false;", "    }", "  return !base::CommandLine::ForCurrentProcess()->HasSwitch(", "      keyboard::switches::kDisableSmartVirtualKeyboard);", "   return keyboard::IsSmartDeployEnabled();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": ["    void CheckSADs() {", "      unsigned int reference_sad, exp_sad[4];", "  ", "      SADs(exp_sad);", "    for (int block = 0; block < 4; block++) {", "      reference_sad = ReferenceSAD(UINT_MAX, block);", "     for (int block = 0; block < 4; ++block) {", "       reference_sad = ReferenceSAD(block);", "  ", "      EXPECT_EQ(exp_sad[block], reference_sad) << \"block \" << block;", "       EXPECT_EQ(reference_sad, exp_sad[block]) << \"block \" << block;", "      }", "    }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0]}
{"tokens": [" float SVGLayoutSupport::calculateScreenFontSizeScalingFactor(const LayoutObject* layoutObject)", " {", "     ASSERT(layoutObject);", " ", "      AffineTransform ctm = deprecatedCalculateTransformToLayer(layoutObject) * SubtreeContentTransformScope::currentContentTransformation();", "      ctm.scale(layoutObject->document().frameHost()->deviceScaleFactorDeprecated());", "  ", "    return narrowPrecisionToFloat(sqrt((pow(ctm.xScale(), 2) + pow(ctm.yScale(), 2)) / 2));", "     return narrowPrecisionToFloat(sqrt((ctm.xScaleSquared() + ctm.yScaleSquared()) / 2));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["    void CleanUp(DownloadId id) {", "     MockDownloadFile* file = download_file_factory_->GetExistingFile(id);", "     ASSERT_TRUE(file != NULL);", " ", "     EXPECT_CALL(*file, Cancel());", "  ", "      download_file_manager_->CancelDownload(id);", "  ", "    EXPECT_TRUE(NULL == download_file_manager_->GetDownloadFile(id));", "     EXPECT_EQ(NULL, download_file_manager_->GetDownloadFile(id));", "    }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" _kdc_as_rep(kdc_request_t r,", " \t    krb5_data *reply,", " \t    const char *from,", " \t    struct sockaddr *from_addr,", " \t    int datagram_reply)", " {", "     krb5_context context = r->context;", "     krb5_kdc_configuration *config = r->config;", "     KDC_REQ *req = &r->req;", "     KDC_REQ_BODY *b = NULL;", "     AS_REP rep;", "     KDCOptions f;", "     krb5_enctype setype;", "     krb5_error_code ret = 0;", "     Key *skey;", "     int found_pa = 0;", "     int i, flags = HDB_F_FOR_AS_REQ;", "     METHOD_DATA error_method;", "     const PA_DATA *pa;", " ", "     memset(&rep, 0, sizeof(rep));", "     error_method.len = 0;", "     error_method.val = NULL;", " ", "      ", "     ret = _kdc_fast_unwrap_request(r);", "     if (ret) {", " \t_kdc_r_log(r, 0, \"FAST unwrap request from %s failed: %d\", from, ret);", " \tgoto out;", "     }", " ", "     b = &req->req_body;", "     f = b->kdc_options;", " ", "     if (f.canonicalize)", " \tflags |= HDB_F_CANON;", " ", "     if(b->sname == NULL){", " \tret = KRB5KRB_ERR_GENERIC;", " \t_kdc_set_e_text(r, \"No server in request\");", "     } else{", " \tret = _krb5_principalname2krb5_principal (context,", " \t\t\t\t\t\t  &r->server_princ,", " \t\t\t\t\t\t  *(b->sname),", " \t\t\t\t\t\t  b->realm);", " \tif (ret == 0)", " \t    ret = krb5_unparse_name(context, r->server_princ, &r->server_name);", "     }", "     if (ret) {", " \tkdc_log(context, config, 0,", " \t\t\"AS-REQ malformed server name from %s\", from);", " \tgoto out;", "     }", "     if(b->cname == NULL){", " \tret = KRB5KRB_ERR_GENERIC;", " \t_kdc_set_e_text(r, \"No client in request\");", "     } else {", " \tret = _krb5_principalname2krb5_principal (context,", " \t\t\t\t\t\t  &r->client_princ,", " \t\t\t\t\t\t  *(b->cname),", " \t\t\t\t\t\t  b->realm);", " \tif (ret)", " \t    goto out;", " ", " \tret = krb5_unparse_name(context, r->client_princ, &r->client_name);", "     }", "     if (ret) {", " \tkdc_log(context, config, 0,", " \t\t\"AS-REQ malformed client name from %s\", from);", " \tgoto out;", "     }", " ", "     kdc_log(context, config, 0, \"AS-REQ %s from %s for %s\",", " \t    r->client_name, from, r->server_name);", " ", "      ", " ", "     if (_kdc_is_anonymous(context, r->client_princ)) {", " \tif (!_kdc_is_anon_request(b)) {", " \t    kdc_log(context, config, 0, \"Anonymous ticket w/o anonymous flag\");", " \t    ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;", " \t    goto out;", " \t}", "     } else if (_kdc_is_anon_request(b)) {", " \tkdc_log(context, config, 0,", " \t\t\"Request for a anonymous ticket with non \"", " \t\t\"anonymous client name: %s\", r->client_name);", " \tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;", " \tgoto out;", "     }", " ", "      ", " ", "     ret = _kdc_db_fetch(context, config, r->client_princ,", " \t\t\tHDB_F_GET_CLIENT | flags, NULL,", " \t\t\t&r->clientdb, &r->client);", "     if(ret == HDB_ERR_NOT_FOUND_HERE) {", " \tkdc_log(context, config, 5, \"client %s does not have secrets at this KDC, need to proxy\",", " \t\tr->client_name);", " \tgoto out;", "     } else if (ret == HDB_ERR_WRONG_REALM) {", " \tchar *fixed_client_name = NULL;", " ", " \tret = krb5_unparse_name(context, r->client->entry.principal,", " \t\t\t\t&fixed_client_name);", " \tif (ret) {", " \t    goto out;", " \t}", " ", " \tkdc_log(context, config, 0, \"WRONG_REALM - %s -> %s\",", " \t\tr->client_name, fixed_client_name);", " \tfree(fixed_client_name);", " ", " \tret = _kdc_fast_mk_error(context, r,", " \t\t\t\t &error_method,", " \t\t\t\t r->armor_crypto,", " \t\t\t\t &req->req_body,", " \t\t\t\t KRB5_KDC_ERR_WRONG_REALM,", " \t\t\t\t NULL,", " \t\t\t\t r->server_princ,", " \t\t\t\t NULL,", " \t\t\t\t &r->client->entry.principal->realm,", " \t\t\t\t NULL, NULL,", " \t\t\t\t reply);", " \tgoto out;", "     } else if(ret){", " \tconst char *msg = krb5_get_error_message(context, ret);", " \tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->client_name, msg);", " \tkrb5_free_error_message(context, msg);", " \tret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;", " \tgoto out;", "     }", "     ret = _kdc_db_fetch(context, config, r->server_princ,", " \t\t\tHDB_F_GET_SERVER|HDB_F_GET_KRBTGT | flags,", " \t\t\tNULL, NULL, &r->server);", "     if(ret == HDB_ERR_NOT_FOUND_HERE) {", " \tkdc_log(context, config, 5, \"target %s does not have secrets at this KDC, need to proxy\",", " \t\tr->server_name);", " \tgoto out;", "     } else if(ret){", " \tconst char *msg = krb5_get_error_message(context, ret);", " \tkdc_log(context, config, 0, \"UNKNOWN -- %s: %s\", r->server_name, msg);", " \tkrb5_free_error_message(context, msg);", " \tret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;", " \tgoto out;", "     }", " ", "      ", " ", "     ret = _kdc_find_etype(context,", " \t\t\t  krb5_principal_is_krbtgt(context, r->server_princ) ?", " \t\t\t  config->tgt_use_strongest_session_key :", " \t\t\t  config->svc_use_strongest_session_key, FALSE,", " \t\t\t  r->client, b->etype.val, b->etype.len, &r->sessionetype,", " \t\t\t  NULL);", "     if (ret) {", " \tkdc_log(context, config, 0,", " \t\t\"Client (%s) from %s has no common enctypes with KDC \"", " \t\t\"to use for the session key\",", " \t\tr->client_name, from);", " \tgoto out;", "     }", " ", "      ", " ", "     if(req->padata){", " \tunsigned int n;", " ", " \tlog_patypes(context, config, req->padata);", " ", " \t ", " ", " \tfor (n = 0; !found_pa && n < sizeof(pat) / sizeof(pat[0]); n++) {", " \t    if (pat[n].validate == NULL)", " \t\tcontinue;", " \t    if (r->armor_crypto == NULL && (pat[n].flags & PA_REQ_FAST))", " \t\tcontinue;", " ", " \t    kdc_log(context, config, 5,", " \t\t    \"Looking for %s pa-data -- %s\", pat[n].name, r->client_name);", " \t    i = 0;", " \t    pa = _kdc_find_padata(req, &i, pat[n].type);", " \t    if (pa) {", " \t\tret = pat[n].validate(r, pa);", " \t\tif (ret != 0) {", " \t\t    goto out;", " \t\t}", " \t\tkdc_log(context, config, 0,", " \t\t\t\"%s pre-authentication succeeded -- %s\",", " \t\t\tpat[n].name, r->client_name);", " \t\tfound_pa = 1;", " \t\tr->et.flags.pre_authent = 1;", " \t    }", " \t}", "     }", " ", "     if (found_pa == 0) {", " \tKey *ckey = NULL;", " \tsize_t n;", " ", " \tfor (n = 0; n < sizeof(pat) / sizeof(pat[0]); n++) {", " \t    if ((pat[n].flags & PA_ANNOUNCE) == 0)", " \t\tcontinue;", " \t    ret = krb5_padata_add(context, &error_method,", " \t\t\t\t  pat[n].type, NULL, 0);", " \t    if (ret)", " \t\tgoto out;", " \t}", " ", " \t ", " \tret = _kdc_find_etype(context,", " \t\t\t      config->preauth_use_strongest_session_key, TRUE,", " \t\t\t      r->client, b->etype.val, b->etype.len, NULL, &ckey);", " \tif (ret == 0) {", " ", " \t     ", " ", " \t    if (older_enctype(ckey->key.keytype)) {", " \t\tret = get_pa_etype_info(context, config,", " \t\t\t\t\t&error_method, ckey);", " \t\tif (ret)", " \t\t    goto out;", " \t    }", " \t    ret = get_pa_etype_info2(context, config,", " \t\t\t\t     &error_method, ckey);", " \t    if (ret)", " \t\tgoto out;", " \t}", " ", " \t ", " \tif (require_preauth_p(r) || _kdc_is_anon_request(b)) {", " \t    ret = KRB5KDC_ERR_PREAUTH_REQUIRED;", " \t    _kdc_set_e_text(r, \"Need to use PA-ENC-TIMESTAMP/PA-PK-AS-REQ\");", " \t    goto out;", " \t}", " ", " \tif (ckey == NULL) {", " \t    ret = KRB5KDC_ERR_CLIENT_NOTYET;", " \t    _kdc_set_e_text(r, \"Doesn't have a client key available\");", " \t    goto out;", " \t}", " \tkrb5_free_keyblock_contents(r->context,  &r->reply_key);", " \tret = krb5_copy_keyblock_contents(r->context, &ckey->key, &r->reply_key);", " \tif (ret)", " \t    goto out;", "     }", " ", "     if (r->clientdb->hdb_auth_status) {", " \tr->clientdb->hdb_auth_status(context, r->clientdb, r->client, ", " \t\t\t\t     HDB_AUTH_SUCCESS);", "     }", " ", "      ", " ", "     ret = _kdc_check_access(context, config, r->client, r->client_name,", " \t\t\t    r->server, r->server_name,", " \t\t\t    req, &error_method);", "     if(ret)", " \tgoto out;", " ", "      ", " ", "     ret = _kdc_get_preferred_key(context, config,", " \t\t\t\t r->server, r->server_name,", " \t\t\t\t &setype, &skey);", "     if(ret)", " \tgoto out;", " ", "     if(f.renew || f.validate || f.proxy || f.forwarded || f.enc_tkt_in_skey", "        || (_kdc_is_anon_request(b) && !config->allow_anonymous)) {", " \tret = KRB5KDC_ERR_BADOPTION;", " \t_kdc_set_e_text(r, \"Bad KDC options\");", " \tgoto out;", "     }", " ", "      ", " ", "     rep.pvno = 5;", "     rep.msg_type = krb_as_rep;", " ", "     if (_kdc_is_anonymous(context, r->client_princ)) {", " \tRealm anon_realm=KRB5_ANON_REALM;", " \tret = copy_Realm(&anon_realm, &rep.crealm);", "     } else", " \tret = copy_Realm(&r->client->entry.principal->realm, &rep.crealm);", "     if (ret)", " \tgoto out;", "     ret = _krb5_principal2principalname(&rep.cname, r->client->entry.principal);", "     if (ret)", " \tgoto out;", " ", "     rep.ticket.tkt_vno = 5;", "     ret = copy_Realm(&r->server->entry.principal->realm, &rep.ticket.realm);", "     if (ret)", " \tgoto out;", "     _krb5_principal2principalname(&rep.ticket.sname,", " \t\t\t\t  r->server->entry.principal);", "      ", " #define CNT(sp,t) (((sp)->sname->name_type) == KRB5_NT_##t)", "     if (CNT(b, UNKNOWN) || CNT(b, PRINCIPAL) || CNT(b, SRV_INST) || CNT(b, SRV_HST) || CNT(b, SRV_XHST))", " \trep.ticket.sname.name_type = b->sname->name_type;", " #undef CNT", " ", "     r->et.flags.initial = 1;", "     if(r->client->entry.flags.forwardable && r->server->entry.flags.forwardable)", " \tr->et.flags.forwardable = f.forwardable;", "     else if (f.forwardable) {", " \t_kdc_set_e_text(r, \"Ticket may not be forwardable\");", " \tret = KRB5KDC_ERR_POLICY;", " \tgoto out;", "     }", "     if(r->client->entry.flags.proxiable && r->server->entry.flags.proxiable)", " \tr->et.flags.proxiable = f.proxiable;", "     else if (f.proxiable) {", " \t_kdc_set_e_text(r, \"Ticket may not be proxiable\");", " \tret = KRB5KDC_ERR_POLICY;", " \tgoto out;", "     }", "     if(r->client->entry.flags.postdate && r->server->entry.flags.postdate)", " \tr->et.flags.may_postdate = f.allow_postdate;", "     else if (f.allow_postdate){", " \t_kdc_set_e_text(r, \"Ticket may not be postdate\");", " \tret = KRB5KDC_ERR_POLICY;", " \tgoto out;", "     }", " ", "      ", "     if(!_kdc_check_addresses(context, config, b->addresses, from_addr)) {", " \t_kdc_set_e_text(r, \"Bad address list in requested\");", " \tret = KRB5KRB_AP_ERR_BADADDR;", " \tgoto out;", "     }", " ", "     ret = copy_PrincipalName(&rep.cname, &r->et.cname);", "     if (ret)", " \tgoto out;", "     ret = copy_Realm(&rep.crealm, &r->et.crealm);", "     if (ret)", " \tgoto out;", " ", "     {", " \ttime_t start;", " \ttime_t t;", " \t", " \tstart = r->et.authtime = kdc_time;", " ", " \tif(f.postdated && req->req_body.from){", " \t    ALLOC(r->et.starttime);", " \t    start = *r->et.starttime = *req->req_body.from;", " \t    r->et.flags.invalid = 1;", " \t    r->et.flags.postdated = 1;  ", " \t}", " \t_kdc_fix_time(&b->till);", " \tt = *b->till;", " ", " \t ", " ", " \tif(r->client->entry.max_life)", " \t    t = start + min(t - start, *r->client->entry.max_life);", " \tif(r->server->entry.max_life)", " \t    t = start + min(t - start, *r->server->entry.max_life);", " #if 0", " \tt = min(t, start + realm->max_life);", " #endif", " \tr->et.endtime = t;", " \tif(f.renewable_ok && r->et.endtime < *b->till){", " \t    f.renewable = 1;", " \t    if(b->rtime == NULL){", " \t\tALLOC(b->rtime);", " \t\t*b->rtime = 0;", " \t    }", " \t    if(*b->rtime < *b->till)", " \t\t*b->rtime = *b->till;", " \t}", " \tif(f.renewable && b->rtime){", " \t    t = *b->rtime;", " \t    if(t == 0)", " \t\tt = MAX_TIME;", " \t    if(r->client->entry.max_renew)", " \t\tt = start + min(t - start, *r->client->entry.max_renew);", " \t    if(r->server->entry.max_renew)", " \t\tt = start + min(t - start, *r->server->entry.max_renew);", " #if 0", " \t    t = min(t, start + realm->max_renew);", " #endif", " \t    ALLOC(r->et.renew_till);", " \t    *r->et.renew_till = t;", " \t    r->et.flags.renewable = 1;", " \t}", "     }", " ", "     if (_kdc_is_anon_request(b))", " \tr->et.flags.anonymous = 1;", " ", "     if(b->addresses){", " \tALLOC(r->et.caddr);", " \tcopy_HostAddresses(b->addresses, r->et.caddr);", "     }", " ", "     r->et.transited.tr_type = DOMAIN_X500_COMPRESS;", "     krb5_data_zero(&r->et.transited.contents);", " ", "      ", "     r->ek.last_req.val = malloc(2 * sizeof(*r->ek.last_req.val));", "     if (r->ek.last_req.val == NULL) {", " \tret = ENOMEM;", " \tgoto out;", "     }", "     r->ek.last_req.len = 0;", "     if (r->client->entry.pw_end", " \t&& (config->kdc_warn_pwexpire == 0", " \t    || kdc_time + config->kdc_warn_pwexpire >= *r->client->entry.pw_end)) {", " \tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_PW_EXPTIME;", " \tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.pw_end;", " \t++r->ek.last_req.len;", "     }", "     if (r->client->entry.valid_end) {", " \tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_ACCT_EXPTIME;", " \tr->ek.last_req.val[r->ek.last_req.len].lr_value = *r->client->entry.valid_end;", " \t++r->ek.last_req.len;", "     }", "     if (r->ek.last_req.len == 0) {", " \tr->ek.last_req.val[r->ek.last_req.len].lr_type  = LR_NONE;", " \tr->ek.last_req.val[r->ek.last_req.len].lr_value = 0;", " \t++r->ek.last_req.len;", "     }", "     r->ek.nonce = b->nonce;", "     if (r->client->entry.valid_end || r->client->entry.pw_end) {", " \tALLOC(r->ek.key_expiration);", " \tif (r->client->entry.valid_end) {", " \t    if (r->client->entry.pw_end)", " \t\t*r->ek.key_expiration = min(*r->client->entry.valid_end,", " \t\t\t\t\t *r->client->entry.pw_end);", " \t    else", " \t\t*r->ek.key_expiration = *r->client->entry.valid_end;", " \t} else", " \t    *r->ek.key_expiration = *r->client->entry.pw_end;", "     } else", " \tr->ek.key_expiration = NULL;", "     r->ek.flags = r->et.flags;", "     r->ek.authtime = r->et.authtime;", "     if (r->et.starttime) {", " \tALLOC(r->ek.starttime);", " \t*r->ek.starttime = *r->et.starttime;", "     }", "     r->ek.endtime = r->et.endtime;", "     if (r->et.renew_till) {", " \tALLOC(r->ek.renew_till);", " \t*r->ek.renew_till = *r->et.renew_till;", "     }", "     ret = copy_Realm(&rep.ticket.realm, &r->ek.srealm);", "     if (ret)", " \tgoto out;", "     ret = copy_PrincipalName(&rep.ticket.sname, &r->ek.sname);", "     if (ret)", " \tgoto out;", "     if(r->et.caddr){", " \tALLOC(r->ek.caddr);", " \tcopy_HostAddresses(r->et.caddr, r->ek.caddr);", "     }", " ", "      ", " ", "     if (r->session_key.keytype == ETYPE_NULL) {", " \tret = krb5_generate_random_keyblock(context, r->sessionetype, &r->session_key);", " \tif (ret)", " \t    goto out;", "     }", " ", "     if (r->reply_key.keytype == ETYPE_NULL) {", " \t_kdc_set_e_text(r, \"Client have no reply key\");", " \tret = KRB5KDC_ERR_CLIENT_NOTYET;", " \tgoto out;", "     }", " ", "     ret = copy_EncryptionKey(&r->session_key, &r->et.key);", "     if (ret)", " \tgoto out;", " ", "     ret = copy_EncryptionKey(&r->session_key, &r->ek.key);", "     if (ret)", " \tgoto out;", " ", "     if (r->outpadata.len) {", " ", " \tALLOC(rep.padata);", " \tif (rep.padata == NULL) {", " \t    ret = ENOMEM;", " \t    goto out;", " \t}", " \tret = copy_METHOD_DATA(&r->outpadata, rep.padata);", " \tif (ret)", " \t    goto out;", "     }", " ", "      ", "     if (send_pac_p(context, req)) {", " \tgenerate_pac(r, skey);", "     }", " ", "     _kdc_log_timestamp(context, config, \"AS-REQ\", r->et.authtime, r->et.starttime,", " \t\t       r->et.endtime, r->et.renew_till);", " ", "      ", "     ret = _kdc_add_KRB5SignedPath(context,", " \t\t\t\t  config,", " \t\t\t\t  r->server,", " \t\t\t\t  setype,", " \t\t\t\t  r->client->entry.principal,", " \t\t\t\t  NULL,", " \t\t\t\t  NULL,", " \t\t\t\t  &r->et);", "     if (ret)", " \tgoto out;", " ", "     log_as_req(context, config, r->reply_key.keytype, setype, b);", " ", "      ", " ", "     r->et.flags.enc_pa_rep = r->ek.flags.enc_pa_rep = 1;", " ", "      ", " ", "     i = 0;", "     pa = _kdc_find_padata(req, &i, KRB5_PADATA_REQ_ENC_PA_REP);", "     if (pa) {", " ", " \tret = add_enc_pa_rep(r);", " \tif (ret) {", " \t    const char *msg = krb5_get_error_message(r->context, ret);", " \t    _kdc_r_log(r, 0, \"add_enc_pa_rep failed: %s: %d\", msg, ret);", " \t    krb5_free_error_message(r->context, msg);", " \t    goto out;", " \t}", "     }", " ", "      ", " ", "     ret = _kdc_encode_reply(context, config,", " \t\t\t    r->armor_crypto, req->req_body.nonce,", " \t\t\t    &rep, &r->et, &r->ek, setype, r->server->entry.kvno,", " \t\t\t    &skey->key, r->client->entry.kvno,", " \t\t\t    &r->reply_key, 0, &r->e_text, reply);", "     if (ret)", " \tgoto out;", " ", "      ", "     if (datagram_reply && reply->length > config->max_datagram_reply_length) {", " \tkrb5_data_free(reply);", " \tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;", " \t_kdc_set_e_text(r, \"Reply packet too large\");", "     }", " ", " out:", "     free_AS_REP(&rep);", " ", "       ", "    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {", "     if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {", "  \tret = _kdc_fast_mk_error(context, r,", "  \t\t\t\t &error_method,", "  \t\t\t\t r->armor_crypto,", "  \t\t\t\t &req->req_body,", "  \t\t\t\t ret, r->e_text,", "  \t\t\t\t r->server_princ,", "\t\t\t\t &r->client_princ->name,", "\t\t\t\t &r->client_princ->realm,", " \t\t\t\t r->client_princ ?", "                                      &r->client_princ->name : NULL,", " \t\t\t\t r->client_princ ?", "                                      &r->client_princ->realm : NULL,", "  \t\t\t\t NULL, NULL,", "  \t\t\t\t reply);", "  \tif (ret)", " \t    goto out2;", "     }", " out2:", "     free_EncTicketPart(&r->et);", "     free_EncKDCRepPart(&r->ek);", "     free_KDCFastState(&r->fast);", " ", "     if (error_method.len)", " \tfree_METHOD_DATA(&error_method);", "     if (r->outpadata.len)", " \tfree_METHOD_DATA(&r->outpadata);", "     if (r->client_princ) {", " \tkrb5_free_principal(context, r->client_princ);", " \tr->client_princ = NULL;", "     }", "     if (r->client_name) {", " \tfree(r->client_name);", " \tr->client_name = NULL;", "     }", "     if (r->server_princ){", " \tkrb5_free_principal(context, r->server_princ);", " \tr->server_princ = NULL;", "     }", "     if (r->server_name) {", " \tfree(r->server_name);", " \tr->server_name = NULL;", "     }", "     if (r->client)", " \t_kdc_free_ent(context, r->client);", "     if (r->server)", " \t_kdc_free_ent(context, r->server);", "     if (r->armor_crypto) {", " \tkrb5_crypto_destroy(r->context, r->armor_crypto);", " \tr->armor_crypto = NULL;", "     }", "     krb5_free_keyblock_contents(r->context, &r->reply_key);", "     krb5_free_keyblock_contents(r->context, &r->session_key);", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" TIFFNumberOfStrips(TIFF* tif)", " {", "  \tTIFFDirectory *td = &tif->tif_dir;", "  \tuint32 nstrips;", "  ", "     ", "    if( td->td_nstrips )", "        return td->td_nstrips;", "  \tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :", "  \t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));", "  \tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)", " \t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,", " \t\t    \"TIFFNumberOfStrips\");", " \treturn (nstrips);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)", "{", "  assert(pSegment);", "  assert(off >= 0);", " Cluster* Cluster::Create(Segment* pSegment, long idx, long long off) {", "   if (!pSegment || off < 0)", "     return NULL;", "  ", "    const long long element_start = pSegment->m_start + off;", "  ", "  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);", "  assert(pCluster);", "   Cluster* const pCluster =", "       new (std::nothrow) Cluster(pSegment, idx, element_start);", "  ", "    return pCluster;", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0]}
{"tokens": [" static v8::Handle<v8::Value> strictFunctionCallback(const v8::Arguments& args)", "  {", "      INC_STATS(\"DOM.TestObj.strictFunction\");", "      if (args.Length() < 3)", "        return V8Proxy::throwNotEnoughArgumentsError();", "         return V8Proxy::throwNotEnoughArgumentsError(args.GetIsolate());", "      TestObj* imp = V8TestObj::toNative(args.Holder());", "      ExceptionCode ec = 0;", "      {", "     STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, str, MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined));", "     EXCEPTION_BLOCK(float, a, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)->NumberValue()));", "     EXCEPTION_BLOCK(int, b, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, DefaultIsUndefined))) : 0);", "     RefPtr<bool> result = imp->strictFunction(str, a, b, ec);", "     if (UNLIKELY(ec))", "         goto fail;", "     return toV8(result.release(), args.GetIsolate());", "     }", "     fail:", "     V8Proxy::setDOMException(ec, args.GetIsolate());", "     return v8::Handle<v8::Value>();", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" const BlockEntry* Cluster::GetEntry(", "    const Track* pTrack,", "    long long time_ns) const", "{", "    assert(pTrack);", "    if (m_pSegment == NULL)   ", "        return pTrack->GetEOS();", "   if (m_pSegment == NULL)   ", "     return pTrack->GetEOS();", "  ", "  #if 0", "  ", "  LoadBlockEntries();", " ", "  if ((m_entries == NULL) || (m_entries_count <= 0))", "  return NULL;  ", " ", "  const BlockEntry* pResult = pTrack->GetEOS();", " ", "  BlockEntry** i = m_entries;", "     assert(i);", " ", "  BlockEntry** const j = i + m_entries_count;", " ", "  while (i != j)", "  {", "  const BlockEntry* const pEntry = *i++;", "         assert(pEntry);", "         assert(!pEntry->EOS());", " ", "  const Block* const pBlock = pEntry->GetBlock();", "         assert(pBlock);", " ", "  if (pBlock->GetTrackNumber() != pTrack->GetNumber())", "  continue;", " ", "  if (pTrack->VetEntry(pEntry))", "  {", "  if (time_ns < 0)  ", "  return pEntry;", " ", "  const long long ns = pBlock->GetTime(this);", " ", "  if (ns > time_ns)", "  break;", " ", "             pResult = pEntry;", "  }", "  else if (time_ns >= 0)", "  {", "  const long long ns = pBlock->GetTime(this);", " ", "  if (ns > time_ns)", "  break;", "  }", "  }", " ", "  return pResult;", " ", "  ", "  #else", "  ", "    const BlockEntry* pResult = pTrack->GetEOS();", "   const BlockEntry* pResult = pTrack->GetEOS();", "  ", "    long index = 0;", "   long index = 0;", "  ", "    for (;;)", "    {", "        if (index >= m_entries_count)", "        {", "            long long pos;", "            long len;", "   for (;;) {", "     if (index >= m_entries_count) {", "       long long pos;", "       long len;", "  ", "            const long status = Parse(pos, len);", "            assert(status >= 0);", "       const long status = Parse(pos, len);", "       assert(status >= 0);", "  ", "            if (status > 0)   ", "                return pResult;", "       if (status > 0)   ", "         return pResult;", "  ", "            if (status < 0)   ", "                return 0;", "       if (status < 0)   ", "         return 0;", "  ", "            assert(m_entries);", "            assert(index < m_entries_count);", "        }", "        const BlockEntry* const pEntry = m_entries[index];", "        assert(pEntry);", "        assert(!pEntry->EOS());", "        const Block* const pBlock = pEntry->GetBlock();", "        assert(pBlock);", "        if (pBlock->GetTrackNumber() != pTrack->GetNumber())", "        {", "            ++index;", "            continue;", "        }", "        if (pTrack->VetEntry(pEntry))", "        {", "            if (time_ns < 0)   ", "                return pEntry;", "            const long long ns = pBlock->GetTime(this);", "            if (ns > time_ns)", "                return pResult;", "            pResult = pEntry;   ", "        }", "        else if (time_ns >= 0)", "        {", "            const long long ns = pBlock->GetTime(this);", "            if (ns > time_ns)", "                return pResult;", "        }", "        ++index;", "       assert(m_entries);", "       assert(index < m_entries_count);", "      }", "  ", "     const BlockEntry* const pEntry = m_entries[index];", "     assert(pEntry);", "     assert(!pEntry->EOS());", " ", "     const Block* const pBlock = pEntry->GetBlock();", "     assert(pBlock);", " ", "     if (pBlock->GetTrackNumber() != pTrack->GetNumber()) {", "       ++index;", "       continue;", "     }", " ", "     if (pTrack->VetEntry(pEntry)) {", "       if (time_ns < 0)   ", "         return pEntry;", " ", "       const long long ns = pBlock->GetTime(this);", " ", "       if (ns > time_ns)", "         return pResult;", " ", "       pResult = pEntry;   ", "     } else if (time_ns >= 0) {", "       const long long ns = pBlock->GetTime(this);", " ", "       if (ns > time_ns)", "         return pResult;", "     }", " ", "     ++index;", "   }", " ", "  #endif", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": [" OMX_ERRORTYPE  omx_vdec::set_config(OMX_IN OMX_HANDLETYPE      hComp,", "         OMX_IN OMX_INDEXTYPE configIndex,", "         OMX_IN OMX_PTR        configData)", " {", "  (void) hComp;", "  if (m_state == OMX_StateInvalid) {", "         DEBUG_PRINT_ERROR(\"Get Config in Invalid State\");", "  return OMX_ErrorInvalidState;", "  }", " ", "     OMX_ERRORTYPE ret = OMX_ErrorNone;", "     OMX_VIDEO_CONFIG_NALSIZE *pNal;", " ", "     DEBUG_PRINT_LOW(\"Set Config Called\");", " ", "  if (configIndex == (OMX_INDEXTYPE)OMX_IndexVendorVideoExtraData) {", "         OMX_VENDOR_EXTRADATATYPE *config = (OMX_VENDOR_EXTRADATATYPE *) configData;", "         DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData called\");", "  if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\") ||", "  !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mvc\")) {", "             DEBUG_PRINT_LOW(\"Index OMX_IndexVendorVideoExtraData AVC\");", "             OMX_U32 extra_size;", " ", "             nal_length = (config->pData[4] & 0x03) + 1;", " ", "             extra_size = 0;", "  if (nal_length > 2) {", "   ", "                 extra_size = (nal_length - 2) * 2;", "  }", " ", "             OMX_U8 *pSrcBuf = (OMX_U8 *) (&config->pData[6]);", "             OMX_U8 *pDestBuf;", "             m_vendor_config.nPortIndex = config->nPortIndex;", " ", "             m_vendor_config.nDataSize = config->nDataSize - 6 - 1 + extra_size;", "             m_vendor_config.pData = (OMX_U8 *) malloc(m_vendor_config.nDataSize);", "             OMX_U32 len;", "             OMX_U8 index = 0;", "             pDestBuf = m_vendor_config.pData;", " ", "             DEBUG_PRINT_LOW(\"Rxd SPS+PPS nPortIndex[%u] len[%u] data[%p]\",", "  (unsigned int)m_vendor_config.nPortIndex,", "  (unsigned int)m_vendor_config.nDataSize,", "                     m_vendor_config.pData);", "  while (index < 2) {", "  uint8 *psize;", "                 len = *pSrcBuf;", "                 len = len << 8;", "                 len |= *(pSrcBuf + 1);", "                 psize = (uint8 *) & len;", "                 memcpy(pDestBuf + nal_length, pSrcBuf + 2,len);", "  for (unsigned int i = 0; i < nal_length; i++) {", "                     pDestBuf[i] = psize[nal_length - 1 - i];", "  }", "                 pDestBuf += len + nal_length;", "                 pSrcBuf += len + 2;", "                 index++;", "                 pSrcBuf++;  ", "                 len = 0;", "  }", "  } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg4\") ||", "  !strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.mpeg2\")) {", "             m_vendor_config.nPortIndex = config->nPortIndex;", "             m_vendor_config.nDataSize = config->nDataSize;", "             m_vendor_config.pData = (OMX_U8 *) malloc((config->nDataSize));", "             memcpy(m_vendor_config.pData, config->pData,config->nDataSize);", "  } else if (!strcmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vc1\")) {", "  if (m_vendor_config.pData) {", "                 free(m_vendor_config.pData);", "                 m_vendor_config.pData = NULL;", "                 m_vendor_config.nDataSize = 0;", "  }", " ", "  if (((*((OMX_U32 *) config->pData)) &", "                         VC1_SP_MP_START_CODE_MASK) ==", "                     VC1_SP_MP_START_CODE) {", "                 DEBUG_PRINT_LOW(\"set_config - VC1 simple/main profile\");", "                 m_vendor_config.nPortIndex = config->nPortIndex;", "                 m_vendor_config.nDataSize = config->nDataSize;", "                 m_vendor_config.pData =", "  (OMX_U8 *) malloc(config->nDataSize);", "                 memcpy(m_vendor_config.pData, config->pData,", "                         config->nDataSize);", "                 m_vc1_profile = VC1_SP_MP_RCV;", "  } else if (*((OMX_U32 *) config->pData) == VC1_AP_SEQ_START_CODE) {", "                 DEBUG_PRINT_LOW(\"set_config - VC1 Advance profile\");", "                 m_vendor_config.nPortIndex = config->nPortIndex;", "                 m_vendor_config.nDataSize = config->nDataSize;", "                 m_vendor_config.pData =", "  (OMX_U8 *) malloc((config->nDataSize));", "                 memcpy(m_vendor_config.pData, config->pData,", "                         config->nDataSize);", "                 m_vc1_profile = VC1_AP;", "  } else if ((config->nDataSize == VC1_STRUCT_C_LEN)) {", "                 DEBUG_PRINT_LOW(\"set_config - VC1 Simple/Main profile struct C only\");", "                 m_vendor_config.nPortIndex = config->nPortIndex;", "                 m_vendor_config.nDataSize  = config->nDataSize;", "                 m_vendor_config.pData = (OMX_U8*)malloc(config->nDataSize);", "                 memcpy(m_vendor_config.pData,config->pData,config->nDataSize);", "                 m_vc1_profile = VC1_SP_MP_RCV;", "  } else {", "                 DEBUG_PRINT_LOW(\"set_config - Error: Unknown VC1 profile\");", "  }", "  }", "  return ret;", "  } else if (configIndex == OMX_IndexConfigVideoNalSize) {", " ", "          struct v4l2_control temp;", "          temp.id = V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT;", "  ", "         VALIDATE_OMX_PARAM_DATA(configData, OMX_VIDEO_CONFIG_NALSIZE);", "          pNal = reinterpret_cast < OMX_VIDEO_CONFIG_NALSIZE * >(configData);", "          switch (pNal->nNaluBytes) {", "              case 0:", "                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_STARTCODES;", "  break;", "  case 2:", "                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_TWO_BYTE_LENGTH;", "  break;", "  case 4:", "                 temp.value = V4L2_MPEG_VIDC_VIDEO_NAL_FORMAT_FOUR_BYTE_LENGTH;", "  break;", "  default:", "  return OMX_ErrorUnsupportedSetting;", "  }", " ", "  if (!arbitrary_bytes) {", "   ", "  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &temp)) {", "                 DEBUG_PRINT_ERROR(\"Failed to set V4L2_CID_MPEG_VIDC_VIDEO_STREAM_FORMAT\");", "  return OMX_ErrorHardware;", "  }", "  }", " ", "         nal_length = pNal->nNaluBytes;", "         m_frame_parser.init_nal_length(nal_length);", " ", "         DEBUG_PRINT_LOW(\"OMX_IndexConfigVideoNalSize called with Size %d\", nal_length);", "  return ret;", "  } else if ((int)configIndex == (int)OMX_IndexVendorVideoFrameRate) {", "         OMX_VENDOR_VIDEOFRAMERATE *config = (OMX_VENDOR_VIDEOFRAMERATE *) configData;", "         DEBUG_PRINT_HIGH(\"Index OMX_IndexVendorVideoFrameRate %u\", (unsigned int)config->nFps);", " ", "  if (config->nPortIndex == OMX_CORE_INPUT_PORT_INDEX) {", "  if (config->bEnabled) {", "  if ((config->nFps >> 16) > 0) {", "                     DEBUG_PRINT_HIGH(\"set_config: frame rate set by omx client : %u\",", "  (unsigned int)config->nFps >> 16);", "                     Q16ToFraction(config->nFps, drv_ctx.frame_rate.fps_numerator,", "                             drv_ctx.frame_rate.fps_denominator);", " ", "  if (!drv_ctx.frame_rate.fps_numerator) {", "                         DEBUG_PRINT_ERROR(\"Numerator is zero setting to 30\");", "                         drv_ctx.frame_rate.fps_numerator = 30;", "  }", " ", "  if (drv_ctx.frame_rate.fps_denominator) {", "                         drv_ctx.frame_rate.fps_numerator = (int)", "                             drv_ctx.frame_rate.fps_numerator / drv_ctx.frame_rate.fps_denominator;", "  }", " ", "                     drv_ctx.frame_rate.fps_denominator = 1;", "                     frm_int = drv_ctx.frame_rate.fps_denominator * 1e6 /", "                         drv_ctx.frame_rate.fps_numerator;", " ", "  struct v4l2_outputparm oparm;", "   ", "                     oparm.timeperframe.numerator = drv_ctx.frame_rate.fps_denominator;", "                     oparm.timeperframe.denominator = drv_ctx.frame_rate.fps_numerator;", " ", "  struct v4l2_streamparm sparm;", "                     sparm.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;", "                     sparm.parm.output = oparm;", "  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_PARM, &sparm)) {", "                         DEBUG_PRINT_ERROR(\"Unable to convey fps info to driver, \\", "                                 performance might be affected\");", "                         ret = OMX_ErrorHardware;", "  }", "                     client_set_fps = true;", "  } else {", "                     DEBUG_PRINT_ERROR(\"Frame rate not supported.\");", "                     ret = OMX_ErrorUnsupportedSetting;", "  }", "  } else {", "                 DEBUG_PRINT_HIGH(\"set_config: Disabled client's frame rate\");", "                 client_set_fps = false;", "  }", "  } else {", "             DEBUG_PRINT_ERROR(\" Set_config: Bad Port idx %d\",", "  (int)config->nPortIndex);", "             ret = OMX_ErrorBadPortIndex;", "  }", " ", "  return ret;", "  } else if ((int)configIndex == (int)OMX_QcomIndexConfigPerfLevel) {", "         OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =", "  (OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;", "  struct v4l2_control control;", " ", "         DEBUG_PRINT_LOW(\"Set perf level: %d\", perf->ePerfLevel);", " ", "         control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;", " ", "  switch (perf->ePerfLevel) {", "  case OMX_QCOM_PerfLevelNominal:", "                 control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL;", "  break;", "  case OMX_QCOM_PerfLevelTurbo:", "                 control.value = V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO;", "  break;", "  default:", "                 ret = OMX_ErrorUnsupportedSetting;", "  break;", "  }", " ", "  if (ret == OMX_ErrorNone) {", "             ret = (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control) < 0) ?", "                 OMX_ErrorUnsupportedSetting : OMX_ErrorNone;", "  }", " ", "  return ret;", "  } else if ((int)configIndex == (int)OMX_IndexConfigPriority) {", "         OMX_PARAM_U32TYPE *priority = (OMX_PARAM_U32TYPE *)configData;", "         DEBUG_PRINT_LOW(\"Set_config: priority %d\", priority->nU32);", " ", "  struct v4l2_control control;", " ", "         control.id = V4L2_CID_MPEG_VIDC_VIDEO_PRIORITY;", "  if (priority->nU32 == 0)", "             control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_ENABLE;", "  else", "             control.value = V4L2_MPEG_VIDC_VIDEO_PRIORITY_REALTIME_DISABLE;", " ", "  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {", "             DEBUG_PRINT_ERROR(\"Failed to set Priority\");", "             ret = OMX_ErrorUnsupportedSetting;", "  }", "  return ret;", "  } else if ((int)configIndex == (int)OMX_IndexConfigOperatingRate) {", "         OMX_PARAM_U32TYPE *rate = (OMX_PARAM_U32TYPE *)configData;", "         DEBUG_PRINT_LOW(\"Set_config: operating-rate %u fps\", rate->nU32 >> 16);", " ", "  struct v4l2_control control;", " ", "         control.id = V4L2_CID_MPEG_VIDC_VIDEO_OPERATING_RATE;", "         control.value = rate->nU32;", " ", "  if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {", "             ret = errno == -EBUSY ? OMX_ErrorInsufficientResources :", "                     OMX_ErrorUnsupportedSetting;", "             DEBUG_PRINT_ERROR(\"Failed to set operating rate %u fps (%s)\",", "                     rate->nU32 >> 16, errno == -EBUSY ? \"HW Overload\" : strerror(errno));", "  }", "  return ret;", "  }", " ", "  return OMX_ErrorNotImplemented;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,", "                      struct grub_ext4_extent_header *ext_block,", "                      grub_uint32_t fileblock)", " {", "   struct grub_ext4_extent_idx *index;", " ", "   while (1)", "     {", "       int i;", "       grub_disk_addr_t block;", " ", "       index = (struct grub_ext4_extent_idx *) (ext_block + 1);", " ", "       if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)", "         return 0;", " ", "       if (ext_block->depth == 0)", "         return ext_block;", " ", "       for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)", "         {", "           if (fileblock < grub_le_to_cpu32(index[i].block))", "             break;", "         }", " ", "       if (--i < 0)", "         return 0;", " ", "       block = grub_le_to_cpu16 (index[i].leaf_hi);", "        block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);", "        if (grub_disk_read (data->disk,", "                            block << LOG2_EXT2_BLOCK_SIZE (data),", "                          0, EXT2_BLOCK_SIZE(data), buf))", "                           0, EXT2_BLOCK_SIZE(data), buf)) {", "          return 0;", "       }", "  ", "        ext_block = (struct grub_ext4_extent_header *) buf;", "      }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0]}
{"tokens": [" int hashtable_init(hashtable_t *hashtable)", " {", "      size_t i;", "  ", "      hashtable->size = 0;", "    hashtable->num_buckets = 0;   ", "    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));", "     hashtable->order = 3;", "     hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));", "      if(!hashtable->buckets)", "          return -1;", "  ", "      list_init(&hashtable->list);", "  ", "    for(i = 0; i < num_buckets(hashtable); i++)", "     for(i = 0; i < hashsize(hashtable->order); i++)", "      {", "          hashtable->buckets[i].first = hashtable->buckets[i].last =", "              &hashtable->list;", "     }", " ", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void jbd2_journal_wait_updates(journal_t *journal)", "{", "transaction_t *commit_transaction = journal->j_running_transaction;", "", "if (!commit_transaction)", "return;", "", "spin_lock(&commit_transaction->t_handle_lock);", "while (atomic_read(&commit_transaction->t_updates)) {", "DEFINE_WAIT(wait);", "", "prepare_to_wait(&journal->j_wait_updates, &wait,", "TASK_UNINTERRUPTIBLE);", "if (atomic_read(&commit_transaction->t_updates)) {", "spin_unlock(&commit_transaction->t_handle_lock);", "write_unlock(&journal->j_state_lock);", "schedule();", "write_lock(&journal->j_state_lock);", "spin_lock(&commit_transaction->t_handle_lock);", "}", "finish_wait(&journal->j_wait_updates, &wait);", "}", "spin_unlock(&commit_transaction->t_handle_lock);", "}"], "ner_tags": [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0]}
{"tokens": [" RenderProcessHost* RenderProcessHostImpl::GetProcessHostForSite(", "     BrowserContext* browser_context,", "     const GURL& url) {", "    SiteProcessMap* map =", "        GetSiteProcessMapForBrowserContext(browser_context);", "  ", "    ", "    ", "    std::string site = SiteInstance::GetSiteForURL(browser_context, url)", "        .possibly_invalid_spec();", "  return map->FindProcess(site);", "   RenderProcessHost* host = map->FindProcess(site);", "   if (host && !IsSuitableHost(host, browser_context, url)) {", "      ", "      ", "     RecordAction(UserMetricsAction(\"BindingsMismatch_GetProcessHostPerSite\"));", "     map->RemoveProcess(host);", "     host = NULL;", "   }", " ", "   return host;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" status_t MPEG4Source::read(", "  MediaBuffer **out, const ReadOptions *options) {", "  Mutex::Autolock autoLock(mLock);", " ", "     CHECK(mStarted);", " ", "  if (mFirstMoofOffset > 0) {", "  return fragmentedRead(out, options);", "  }", " ", "  *out = NULL;", " ", "  int64_t targetSampleTimeUs = -1;", " ", "  int64_t seekTimeUs;", "  ReadOptions::SeekMode mode;", "  if (options && options->getSeekTo(&seekTimeUs, &mode)) {", "  uint32_t findFlags = 0;", "  switch (mode) {", "  case ReadOptions::SEEK_PREVIOUS_SYNC:", "                 findFlags = SampleTable::kFlagBefore;", "  break;", "  case ReadOptions::SEEK_NEXT_SYNC:", "                 findFlags = SampleTable::kFlagAfter;", "  break;", "  case ReadOptions::SEEK_CLOSEST_SYNC:", "  case ReadOptions::SEEK_CLOSEST:", "                 findFlags = SampleTable::kFlagClosest;", "  break;", "  default:", "                 CHECK(!\"Should not be here.\");", "  break;", "  }", " ", "  uint32_t sampleIndex;", "  status_t err = mSampleTable->findSampleAtTime(", "                 seekTimeUs, 1000000, mTimescale,", "  &sampleIndex, findFlags);", " ", "  if (mode == ReadOptions::SEEK_CLOSEST) {", "             findFlags = SampleTable::kFlagBefore;", "  }", " ", "  uint32_t syncSampleIndex;", "  if (err == OK) {", "             err = mSampleTable->findSyncSampleNear(", "                     sampleIndex, &syncSampleIndex, findFlags);", "  }", " ", "  uint32_t sampleTime;", "  if (err == OK) {", "             err = mSampleTable->getMetaDataForSample(", "                     sampleIndex, NULL, NULL, &sampleTime);", "  }", " ", "  if (err != OK) {", "  if (err == ERROR_OUT_OF_RANGE) {", "                 err = ERROR_END_OF_STREAM;", "  }", "             ALOGV(\"end of stream\");", "  return err;", "  }", " ", "  if (mode == ReadOptions::SEEK_CLOSEST) {", "             targetSampleTimeUs = (sampleTime * 1000000ll) / mTimescale;", "  }", " ", " #if 0", "  uint32_t syncSampleTime;", "         CHECK_EQ(OK, mSampleTable->getMetaDataForSample(", "                     syncSampleIndex, NULL, NULL, &syncSampleTime));", " ", "         ALOGI(\"seek to time %lld us => sample at time %lld us, \"", "  \"sync sample at time %lld us\",", "              seekTimeUs,", "              sampleTime * 1000000ll / mTimescale,", "              syncSampleTime * 1000000ll / mTimescale);", " #endif", " ", "         mCurrentSampleIndex = syncSampleIndex;", "  if (mBuffer != NULL) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  }", " ", "  off64_t offset;", "  size_t size;", "  uint32_t cts, stts;", "  bool isSyncSample;", "  bool newBuffer = false;", "  if (mBuffer == NULL) {", "         newBuffer = true;", " ", "  status_t err =", "             mSampleTable->getMetaDataForSample(", "                     mCurrentSampleIndex, &offset, &size, &cts, &isSyncSample, &stts);", " ", "  if (err != OK) {", "  return err;", "  }", " ", "         err = mGroup->acquire_buffer(&mBuffer);", " ", "  if (err != OK) {", "             CHECK(mBuffer == NULL);", "  return err;", "  }", "  }", " ", "  if ((!mIsAVC && !mIsHEVC) || mWantsNALFragments) {", "  if (newBuffer) {", "  ssize_t num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);", " ", "  if (num_bytes_read < (ssize_t)size) {", "                 mBuffer->release();", "                 mBuffer = NULL;", " ", "  return ERROR_IO;", "  }", " ", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", "             mBuffer->meta_data()->clear();", "             mBuffer->meta_data()->setInt64(", "                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "             mBuffer->meta_data()->setInt64(", "                     kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "                 mBuffer->meta_data()->setInt64(", "                         kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", "  }", " ", "  if (!mIsAVC && !mIsHEVC) {", "  *out = mBuffer;", "             mBuffer = NULL;", " ", "  return OK;", "  }", " ", " ", "         CHECK(mBuffer->range_length() >= mNALLengthSize);", " ", "  const uint8_t *src =", "  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();", " ", "  size_t nal_size = parseNALSize(src);", "  if (mBuffer->range_length() < mNALLengthSize + nal_size) {", "             ALOGE(\"incomplete NAL unit.\");", " ", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_MALFORMED;", "  }", " ", "  MediaBuffer *clone = mBuffer->clone();", "         CHECK(clone != NULL);", "         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);", " ", "         CHECK(mBuffer != NULL);", "         mBuffer->set_range(", "                 mBuffer->range_offset() + mNALLengthSize + nal_size,", "                 mBuffer->range_length() - mNALLengthSize - nal_size);", " ", "  if (mBuffer->range_length() == 0) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  *out = clone;", " ", "  return OK;", "  } else {", "  ssize_t num_bytes_read = 0;", "  int32_t drm = 0;", "  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);", "  if (usesDRM) {", "             num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);", "  } else {", "             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);", "  }", " ", "  if (num_bytes_read < (ssize_t)size) {", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_IO;", "  }", " ", "  if (usesDRM) {", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", " ", "  } else {", "  uint8_t *dstData = (uint8_t *)mBuffer->data();", "  size_t srcOffset = 0;", " ", "              size_t dstOffset = 0;", "  ", "              while (srcOffset < size) {", "                bool isMalFormed = (srcOffset + mNALLengthSize > size);", "                 bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);", "                  size_t nalLength = 0;", "                  if (!isMalFormed) {", "                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);", "                      srcOffset += mNALLengthSize;", "                    isMalFormed = srcOffset + nalLength > size;", "                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);", "                  }", "  ", "                  if (isMalFormed) {", "                     ALOGE(\"Video is malformed\");", "                     mBuffer->release();", "                     mBuffer = NULL;", "  return ERROR_MALFORMED;", "  }", " ", "  if (nalLength == 0) {", "  continue;", "  }", " ", "                 CHECK(dstOffset + 4 <= mBuffer->size());", " ", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 1;", "                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);", "                 srcOffset += nalLength;", "                 dstOffset += nalLength;", "  }", "             CHECK_EQ(srcOffset, size);", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, dstOffset);", "  }", " ", "         mBuffer->meta_data()->clear();", "         mBuffer->meta_data()->setInt64(", "                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "         mBuffer->meta_data()->setInt64(", "                 kKeyDuration, ((int64_t)stts * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "             mBuffer->meta_data()->setInt64(", "                     kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", " ", "  *out = mBuffer;", "         mBuffer = NULL;", " ", "  return OK;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int __videobuf_mmap_mapper(struct videobuf_queue *q,", " \t\t\t struct vm_area_struct *vma)", " {", " \tstruct videbuf_vmalloc_memory *mem;", " \tstruct videobuf_mapping *map;", " \tunsigned int first;", " \tint retval;", " \tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;", " ", " \tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))", " \t\treturn -EINVAL;", " ", " \t ", " \tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {", " \t\tif (NULL == q->bufs[first])", " \t\t\tcontinue;", " ", " \t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)", " \t\t\tcontinue;", " \t\tif (q->bufs[first]->boff == offset)", " \t\t\tbreak;", " \t}", " \tif (VIDEO_MAX_FRAME == first) {", " \t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",", " \t\t\t(vma->vm_pgoff << PAGE_SHIFT));", " \t\treturn -EINVAL;", "  \t}", "  ", "  \t ", "\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);", " \tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);", "  \tif (NULL == map)", "  \t\treturn -ENOMEM;", "  ", " \tmap->start = vma->vm_start;", " \tmap->end   = vma->vm_end;", " \tmap->q     = q;", " ", " \tq->bufs[first]->baddr = vma->vm_start;", " ", " \tvma->vm_ops          = &videobuf_vm_ops;", " \tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;", " \tvma->vm_private_data = map;", " ", " \tmem=q->bufs[first]->priv;", " \tBUG_ON (!mem);", " \tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);", " ", " \t ", " \tretval=remap_vmalloc_range(vma, mem->vmalloc,0);", " \tif (retval<0) {", " \t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");", " ", " \t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);", " \t\tif (!mem->vma) {", " \t\t\tkfree(map);", " \t\t\tq->bufs[first]->map=NULL;", " \t\t\treturn -ENOMEM;", " \t\t}", " \t\tmemcpy(mem->vma,vma,sizeof(*vma));", " \t}", " ", " \tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",", " \t\tmap,q,vma->vm_start,vma->vm_end,", " \t\t(long int) q->bufs[first]->bsize,", " \t\tvma->vm_pgoff,first);", " ", " \tvideobuf_vm_open(vma);", " ", " \treturn (0);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["bit_write_MC (Bit_Chain *dat, BITCODE_MC val)", "{", "int i, j;", "int negative = 0;", "unsigned char byte[5];", "BITCODE_UMC mask = 0x0000007f;", "BITCODE_UMC value = (BITCODE_UMC)val;", "", "if (val < 0)", "{", "negative = 1;", "value = (BITCODE_UMC)-val;", "}", "for (i = 4, j = 0; i >= 0; i--, j += 7)", "{", "byte[i] = (unsigned char)((value & mask) >> j);", "byte[i] |= 0x80;", "mask = mask << 7;", "}", "for (i = 0; i < 4; i++)", "if (byte[i] & 0x7f)", "break;", "", "if (byte[i] & 0x40)", "i--;", "byte[i] &= 0x7f;", "if (negative)", "byte[i] |= 0x40;", "for (j = 4; j >= i; j--)", "bit_write_RC (dat, byte[j]);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int key_notify_sa_flush(const struct km_event *c)", " {", " \tstruct sk_buff *skb;", " \tstruct sadb_msg *hdr;", " ", " \tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);", " \tif (!skb)", " \t\treturn -ENOBUFS;", " \thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));", " \thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);", " \thdr->sadb_msg_type = SADB_FLUSH;", " \thdr->sadb_msg_seq = c->seq;", " \thdr->sadb_msg_pid = c->portid;", "  \thdr->sadb_msg_version = PF_KEY_V2;", "  \thdr->sadb_msg_errno = (uint8_t) 0;", "  \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));", " \thdr->sadb_msg_reserved = 0;", "  ", "  \tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);", "  ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]}
{"tokens": [" void chain_reply(struct smb_request *req)", " {", " \tsize_t smblen = smb_len(req->inbuf);", " \tsize_t already_used, length_needed;", " \tuint8_t chain_cmd;", " \tuint32_t chain_offset;\t ", " ", " \tuint8_t wct;", " \tuint16_t *vwv;", " \tuint16_t buflen;", " \tuint8_t *buf;", " ", " \tif (IVAL(req->outbuf, smb_rcls) != 0) {", " \t\tfixup_chain_error_packet(req);", " \t}", " ", " \t ", "  ", "         if ((req->wct < 2) || (CVAL(req->outbuf, smb_wct) < 2)) {", "                if (req->chain_outbuf == NULL) {", "                        req->chain_outbuf = TALLOC_REALLOC_ARRAY(", "                                req, req->outbuf, uint8_t,", "                                smb_len(req->outbuf) + 4);", "                        if (req->chain_outbuf == NULL) {", "                                smb_panic(\"talloc failed\");", "                        }", "                }", "                req->outbuf = NULL;", "                 goto error;", "         }", "  ", " ", " \tif (req->chain_outbuf == NULL) {", " \t\t ", " \t\treq->chain_outbuf = TALLOC_REALLOC_ARRAY(", " \t\t\treq, req->outbuf, uint8_t, smb_len(req->outbuf) + 4);", " \t\tif (req->chain_outbuf == NULL) {", " \t\t\tgoto error;", " \t\t}", " \t\treq->outbuf = NULL;", " \t} else {", " \t\t ", " ", " \tchain_cmd = CVAL(req->vwv+0, 0);", " \tchain_offset = SVAL(req->vwv+1, 0);", " ", " \tif (chain_cmd == 0xff) {", " \t\t ", " \t\tsmb_setlen((char *)(req->chain_outbuf),", " \t\t\t   talloc_get_size(req->chain_outbuf) - 4);", " ", " \t\tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,", " \t\t\t\t  true, req->seqnum+1,", " \t\t\t\t  IS_CONN_ENCRYPTED(req->conn)", " \t\t\t\t  ||req->encrypted,", " \t\t\t\t  &req->pcd)) {", " \t\t\texit_server_cleanly(\"chain_reply: srv_send_smb \"", " \t\t\t\t\t    \"failed.\");", " \t\t}", " \t\tTALLOC_FREE(req->chain_outbuf);", " \t\treq->done = true;", " \t\treturn;", " \t}", " ", " \t ", " \tSMB_PERFCOUNT_ADD(&req->pcd);", " \tSMB_PERFCOUNT_SET_OP(&req->pcd, chain_cmd);", " \tSMB_PERFCOUNT_SET_MSGLEN_IN(&req->pcd, smblen);", " ", " \t ", " ", " \talready_used = PTR_DIFF(req->buf+req->buflen, smb_base(req->inbuf));", " \tif (chain_offset < already_used) {", " \t\tgoto error;", " \t}", " ", " \t ", " ", " \tlength_needed = chain_offset+1;\t ", " \tif (length_needed > smblen) {", " \t\tgoto error;", " \t}", " ", " \t ", " ", " \twct = CVAL(smb_base(req->inbuf), chain_offset);", " ", " \t ", " ", " \tlength_needed += (wct+1)*sizeof(uint16_t);  ", " \tif (length_needed > smblen) {", " \t\tgoto error;", " \t}", " \tvwv = (uint16_t *)(smb_base(req->inbuf) + chain_offset + 1);", " ", " \t ", " ", " \tbuflen = SVAL(vwv+wct, 0);", " ", " \t ", " ", " \tlength_needed += buflen;", " \tif (length_needed > smblen) {", " \t\tgoto error;", " \t}", " \tbuf = (uint8_t *)(vwv+wct+1);", " ", " \treq->cmd = chain_cmd;", " \treq->wct = wct;", " \treq->vwv = vwv;", " \treq->buflen = buflen;", " \treq->buf = buf;", " ", " \tswitch_message(chain_cmd, req, smblen);", " ", " \tif (req->outbuf == NULL) {", " \t\t ", " \t\treturn;", " \t}", " ", " \t ", " \tgoto done;", " ", "  error:", " \t ", " \treply_force_doserror(req, ERRSRV, ERRerror);", " \tfixup_chain_error_packet(req);", " ", "  done:", " \t ", " \tSSVAL(req->chain_outbuf, smb_flg2,", " \t      (SVAL(req->chain_outbuf, smb_flg2) & ~FLAGS2_32_BIT_ERROR_CODES)", " \t      | (SVAL(req->outbuf, smb_flg2) & FLAGS2_32_BIT_ERROR_CODES));", " ", " \t ", " \tSSVAL(req->chain_outbuf, smb_rcls, SVAL(req->outbuf, smb_rcls));", " \tSSVAL(req->chain_outbuf, smb_err, SVAL(req->outbuf, smb_err));", " ", " \tif (!smb_splice_chain(&req->chain_outbuf,", " \t\t\t      CVAL(req->outbuf, smb_com),", " \t\t\t      CVAL(req->outbuf, smb_wct),", " \t\t\t      (uint16_t *)(req->outbuf + smb_vwv),", " \t\t\t      0, smb_buflen(req->outbuf),", " \t\t\t      (uint8_t *)smb_buf(req->outbuf))) {", " \t\texit_server_cleanly(\"chain_reply: smb_splice_chain failed\\n\");", " \t}", " \tTALLOC_FREE(req->outbuf);", " ", " \tsmb_setlen((char *)(req->chain_outbuf),", " \t\t   talloc_get_size(req->chain_outbuf) - 4);", " ", " \tshow_msg((char *)(req->chain_outbuf));", " ", " \tif (!srv_send_smb(smbd_server_fd(), (char *)req->chain_outbuf,", " \t\t\t  true, req->seqnum+1,", " \t\t\t  IS_CONN_ENCRYPTED(req->conn)||req->encrypted,", " \t\t\t  &req->pcd)) {", " \t\texit_server_cleanly(\"construct_reply: srv_send_smb failed.\");", " \t}", " \tTALLOC_FREE(req->chain_outbuf);", " \treq->done = true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" raptor_rdfxml_parse_start(raptor_parser* rdf_parser)", " {", "   raptor_uri *uri = rdf_parser->base_uri;", "   raptor_rdfxml_parser* rdf_xml_parser;", " ", "   rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;", " ", "    ", "   if(!uri)", "     return 1;", " ", "    ", "   raptor_sax2_set_option(rdf_xml_parser->sax2,", "                          RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,", "                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));", " ", "    ", "   raptor_sax2_set_option(rdf_xml_parser->sax2, ", "                          RAPTOR_OPTION_NO_NET, NULL,", "                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));", "    raptor_sax2_set_option(rdf_xml_parser->sax2, ", "                           RAPTOR_OPTION_NO_FILE, NULL,", "                           RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));", "   raptor_sax2_set_option(rdf_xml_parser->sax2, ", "                          RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,", "                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));", "    if(rdf_parser->uri_filter)", "      raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,", "                                 rdf_parser->uri_filter_user_data);", " ", "   raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);", " ", "    ", "   if(rdf_xml_parser->id_set) {", "     raptor_free_id_set(rdf_xml_parser->id_set);", "     rdf_xml_parser->id_set = NULL;", "   }", "   ", "    ", "   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {", "     rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);", "     if(!rdf_xml_parser->id_set)", "       return 1;", "   }", "   ", "   return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)", " {", " \tstruct ipv6_pinfo *np = inet6_sk(sk);", " \tstruct tcp_sock *tp;", " \tstruct sk_buff *opt_skb = NULL;", " ", " \t ", " ", "  \tif (skb->protocol == htons(ETH_P_IP))", "  \t\treturn tcp_v4_do_rcv(sk, skb);", "  ", "\tif (sk_filter(sk, skb))", " \tif (tcp_filter(sk, skb))", "  \t\tgoto discard;", "  ", "  \t ", " ", " \t ", " \tif (np->rxopt.all)", " \t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));", " ", " \tif (sk->sk_state == TCP_ESTABLISHED) {  ", " \t\tstruct dst_entry *dst = sk->sk_rx_dst;", " ", " \t\tsock_rps_save_rxhash(sk, skb);", " \t\tsk_mark_napi_id(sk, skb);", " \t\tif (dst) {", " \t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||", " \t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {", " \t\t\t\tdst_release(dst);", " \t\t\t\tsk->sk_rx_dst = NULL;", " \t\t\t}", " \t\t}", " ", " \t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);", " \t\tif (opt_skb)", " \t\t\tgoto ipv6_pktoptions;", " \t\treturn 0;", " \t}", " ", " \tif (tcp_checksum_complete(skb))", " \t\tgoto csum_err;", " ", " \tif (sk->sk_state == TCP_LISTEN) {", " \t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);", " ", " \t\tif (!nsk)", " \t\t\tgoto discard;", " ", " \t\tif (nsk != sk) {", " \t\t\tsock_rps_save_rxhash(nsk, skb);", " \t\t\tsk_mark_napi_id(nsk, skb);", " \t\t\tif (tcp_child_process(sk, nsk, skb))", " \t\t\t\tgoto reset;", " \t\t\tif (opt_skb)", " \t\t\t\t__kfree_skb(opt_skb);", " \t\t\treturn 0;", " \t\t}", " \t} else", " \t\tsock_rps_save_rxhash(sk, skb);", " ", " \tif (tcp_rcv_state_process(sk, skb))", " \t\tgoto reset;", " \tif (opt_skb)", " \t\tgoto ipv6_pktoptions;", " \treturn 0;", " ", " reset:", " \ttcp_v6_send_reset(sk, skb);", " discard:", " \tif (opt_skb)", " \t\t__kfree_skb(opt_skb);", " \tkfree_skb(skb);", " \treturn 0;", " csum_err:", " \tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);", " \tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);", " \tgoto discard;", " ", " ", " ipv6_pktoptions:", " \t ", " \ttp = tcp_sk(sk);", " \tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&", " \t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {", " \t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)", " \t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);", " \t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)", " \t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;", " \t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)", " \t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));", " \t\tif (np->repflow)", " \t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));", " \t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {", " \t\t\tskb_set_owner_r(opt_skb, sk);", " \t\t\ttcp_v6_restore_cb(opt_skb);", " \t\t\topt_skb = xchg(&np->pktoptions, opt_skb);", " \t\t} else {", " \t\t\t__kfree_skb(opt_skb);", " \t\t\topt_skb = xchg(&np->pktoptions, NULL);", " \t\t}", " \t}", " ", " \tkfree_skb(opt_skb);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)", " {", "  struct ifreq ifr;", "  int sk, err;", " ", "     sk = socket(AF_INET, SOCK_DGRAM, 0);", "  if (sk < 0)", "  return -1;", " ", " ", "      memset(&ifr, 0, sizeof(ifr));", "      strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);", "    err = ioctl(sk, SIOCGIFHWADDR, &ifr);", "     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));", "      if (err < 0)", "      {", "          BTIF_TRACE_ERROR(\"Could not get network hardware for interface:%s, errno:%s\", devname, strerror(errno));", "         close(sk);", "  return -1;", "  }", " ", "     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);", "     memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);", " ", "   ", "  if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {", "         BTIF_TRACE_WARNING(\"Not a unicast MAC address, force multicast bit flipping\");", " ", "          ifr.ifr_hwaddr.sa_data[0] &= ~0x01;", "      }", "  ", "    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);", "     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));", "  ", "      if (err < 0) {", "          BTIF_TRACE_ERROR(\"Could not set bt address for interface:%s, errno:%s\", devname, strerror(errno));", "         close(sk);", "  return -1;", "  }", " ", "     memset(&ifr, 0, sizeof(ifr));", "     strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);", " ", " ", "      ifr.ifr_flags |= IFF_UP;", "      ifr.ifr_flags |= IFF_MULTICAST;", "  ", "    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);", "     err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));", "  ", "  ", "      if (err < 0) {", "         BTIF_TRACE_ERROR(\"Could not bring up network interface:%s, errno:%d\", devname, errno);", "         close(sk);", "  return -1;", "  }", "     close(sk);", "     BTIF_TRACE_DEBUG(\"network interface: %s is up\", devname);", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" iasecc_get_serialnr(struct sc_card *card, struct sc_serial_number *serial)", " {", " \tstruct sc_context *ctx = card->ctx;", " \tstruct sc_iin *iin = &card->serialnr.iin;", " \tstruct sc_apdu apdu;", " \tunsigned char rbuf[0xC0];", " \tsize_t ii, offs;", " \tint rv;", " ", " \tLOG_FUNC_CALLED(ctx);", " \tif (card->serialnr.len)", " \t\tgoto end;", " ", " \tmemset(&card->serialnr, 0, sizeof(card->serialnr));", " ", " \tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xB0, 0x80 | IASECC_SFI_EF_SN, 0);", " \tapdu.le = sizeof(rbuf);", " \tapdu.resp = rbuf;", " \tapdu.resplen = sizeof(rbuf);", " ", " \trv = sc_transmit_apdu(card, &apdu);", " \tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");", " \trv = sc_check_sw(card, apdu.sw1, apdu.sw2);", " \tLOG_TEST_RET(ctx, rv, \"Get 'serial number' data failed\");", " ", " \tif (rbuf[0] != ISO7812_PAN_SN_TAG)", " \t\tLOG_TEST_RET(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED, \"serial number parse error\");", " ", " \tiin->mii = (rbuf[2] >> 4) & 0x0F;", " ", " \tiin->country = 0;", " \tfor (ii=5; ii<8; ii++)   {", " \t\tiin->country *= 10;", " \t\tiin->country += (rbuf[ii/2] >> ((ii & 0x01) ? 0 : 4)) & 0x0F;", " \t}", " ", " \tiin->issuer_id = 0;", " \tfor (ii=8; ii<10; ii++)   {", " \t\tiin->issuer_id *= 10;", " \t\tiin->issuer_id += (rbuf[ii/2] >> (ii & 0x01 ? 0 : 4)) & 0x0F;", " \t}", " ", " \toffs = rbuf[1] > 8 ? rbuf[1] - 8 : 0;", "  \tif (card->type == SC_CARD_TYPE_IASECC_SAGEM)   {", "  \t\t ", "  \t\t ", "\t\tfor (ii=0; ii < rbuf[1] - offs; ii++)", " \t\tfor (ii=0; (ii < rbuf[1] - offs) && (ii + offs + 2 < sizeof(rbuf)); ii++)", "  \t\t\t*(card->serialnr.value + ii) = ((rbuf[ii + offs + 1] & 0x0F) << 4)", "  \t\t\t\t+ ((rbuf[ii + offs + 2] & 0xF0) >> 4) ;", "  \t\tcard->serialnr.len = ii;", " \t}", " \telse   {", " \t\tfor (ii=0; ii < rbuf[1] - offs; ii++)", " \t\t\t*(card->serialnr.value + ii) = rbuf[ii + offs + 2];", " \t\tcard->serialnr.len = ii;", " \t}", " ", " \tdo  {", " \t\tchar txt[0x200];", " ", " \t\tfor (ii=0;ii<card->serialnr.len;ii++)", " \t\t\tsprintf(txt + ii*2, \"%02X\", *(card->serialnr.value + ii));", " ", " \t\tsc_log(ctx, \"serial number '%s'; mii %i; country %i; issuer_id %li\", txt, iin->mii, iin->country, iin->issuer_id);", " \t} while(0);", " ", " end:", " \tif (serial)", " \t\tmemcpy(serial, &card->serialnr, sizeof(*serial));", " ", " \tLOG_FUNC_RETURN(ctx, SC_SUCCESS);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void acpi_ns_terminate(void)", "  {", "  \tacpi_status status;", " \tunion acpi_operand_object *prev;", " \tunion acpi_operand_object *next;", "  ", "  \tACPI_FUNCTION_TRACE(ns_terminate);", "  ", "#ifdef ACPI_EXEC_APP", "\t{", "\t\tunion acpi_operand_object *prev;", "\t\tunion acpi_operand_object *next;", " \t ", "  ", "\t\t ", "\t\tnext = acpi_gbl_module_code_list;", "\t\twhile (next) {", "\t\t\tprev = next;", "\t\t\tnext = next->method.mutex;", "\t\t\tprev->method.mutex = NULL;\t ", "\t\t\tacpi_ut_remove_reference(prev);", "\t\t}", " \tnext = acpi_gbl_module_code_list;", " \twhile (next) {", " \t\tprev = next;", " \t\tnext = next->method.mutex;", " \t\tprev->method.mutex = NULL;\t ", " \t\tacpi_ut_remove_reference(prev);", "  \t}", "#endif", "  ", "  \t ", " \tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);", " ", " \t ", " ", " \tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);", " \tif (ACPI_FAILURE(status)) {", " \t\treturn_VOID;", " \t}", " ", " \tacpi_ns_delete_node(acpi_gbl_root_node);", " \t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);", " ", " \tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));", " \treturn_VOID;", " }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void _out_verify(conn_t out, nad_t nad) {", "     int attr, ns;", "     jid_t from, to;", "     conn_t in;", "     char *rkey;", "     int valid;", " ", "     attr = nad_find_attr(nad, 0, -1, \"from\", NULL);", "     if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {", "         log_debug(ZONE, \"missing or invalid from on db verify packet\");", "         nad_free(nad);", "         return;", "     }", " ", "     attr = nad_find_attr(nad, 0, -1, \"to\", NULL);", "     if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {", "         log_debug(ZONE, \"missing or invalid to on db verify packet\");", "         jid_free(from);", "         nad_free(nad);", "         return;", "     }", " ", "     attr = nad_find_attr(nad, 0, -1, \"id\", NULL);", "     if(attr < 0) {", "         log_debug(ZONE, \"missing id on db verify packet\");", "         jid_free(from);", "         jid_free(to);", "         nad_free(nad);", "         return;", "     }", " ", "      ", "     in = xhash_getx(out->s2s->in, NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr));", "     if(in == NULL) {", "         log_debug(ZONE, \"got a verify for incoming conn %.*s, but it doesn't exist, dropping the packet\", NAD_AVAL_L(nad, attr), NAD_AVAL(nad, attr));", "         jid_free(from);", "         jid_free(to);", "         nad_free(nad);", "         return;", "     }", " ", "      rkey = s2s_route_key(NULL, to->domain, from->domain);", "  ", "      attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");", "    if(attr >= 0) {", "     if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {", "          xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);", "          log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");", "          valid = 1;", "     } else {", "         log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now invalid\", in->fd->fd, in->ip, in->port, rkey);", "         valid = 0;", "     }", " ", "     free(rkey);", " ", "     nad_free(nad);", " ", "      ", "     --out->verify;", " ", "      ", "     nad = nad_new();", " ", "     ns = nad_add_namespace(nad, uri_DIALBACK, \"db\");", "     nad_append_elem(nad, ns, \"result\", 0);", "     nad_append_attr(nad, -1, \"to\", from->domain);", "     nad_append_attr(nad, -1, \"from\", to->domain);", "     nad_append_attr(nad, -1, \"type\", valid ? \"valid\" : \"invalid\");", " ", "      ", "     sx_nad_write(in->s, nad);", " ", "      ", "     if (!valid) {", "          ", "         sx_error(in->s, stream_err_INVALID_ID, \"dialback negotiation failed\");", " ", "          ", "         sx_close(in->s);", "     }", " ", "     jid_free(from);", "     jid_free(to);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec,", "                          WORD32 i4_poc,", "  pocstruct_t *ps_temp_poc,", "                          UWORD16 u2_frame_num,", "  dec_pic_params_t *ps_pps)", " {", "  pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc;", "  pocstruct_t *ps_cur_poc = ps_temp_poc;", " ", "  pic_buffer_t *pic_buf;", " ", "  ivd_video_decode_op_t * ps_dec_output =", "  (ivd_video_decode_op_t *)ps_dec->pv_dec_out;", "  dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;", "  dec_seq_params_t *ps_seq = ps_pps->ps_sps;", "     UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag;", "     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;", "   ", "  high_profile_tools_t s_high_profile;", "     WORD32 ret;", " ", "     H264_MUTEX_LOCK(&ps_dec->process_disp_mutex);", " ", "     ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;", "     ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;", "     ps_prev_poc->i4_delta_pic_order_cnt_bottom =", "                     ps_cur_poc->i4_delta_pic_order_cnt_bottom;", "     ps_prev_poc->i4_delta_pic_order_cnt[0] =", "                     ps_cur_poc->i4_delta_pic_order_cnt[0];", "     ps_prev_poc->i4_delta_pic_order_cnt[1] =", "                     ps_cur_poc->i4_delta_pic_order_cnt[1];", "     ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag;", "     ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;", "     ps_prev_poc->u2_frame_num = u2_frame_num;", "     ps_dec->i1_prev_mb_qp_delta = 0;", "     ps_dec->i1_next_ctxt_idx = 0;", " ", " ", "     ps_dec->u4_nmb_deblk = 0;", "  if(ps_dec->u4_num_cores == 1)", "        ps_dec->u4_nmb_deblk = 1;", " ", " ", " ", "  if(ps_seq->u1_mb_aff_flag == 1)", "  {", "         ps_dec->u4_nmb_deblk = 0;", "  if(ps_dec->u4_num_cores > 2)", "             ps_dec->u4_num_cores = 2;", "  }", " ", "         ps_dec->u4_use_intrapred_line_copy = 0;", " ", " ", " ", "  if (ps_seq->u1_mb_aff_flag == 0)", "  {", "         ps_dec->u4_use_intrapred_line_copy = 1;", "  }", " ", "     ps_dec->u4_app_disable_deblk_frm = 0;", "   ", "  if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics)", "  {", "         WORD32 degrade_pic;", "         ps_dec->i4_degrade_pic_cnt++;", "         degrade_pic = 0;", " ", "   ", "  switch(ps_dec->i4_degrade_pics)", "  {", "  case 4:", "  {", "                 degrade_pic = 1;", "  break;", "  }", "  case 3:", "  {", "  if(ps_cur_slice->u1_slice_type != I_SLICE)", "                     degrade_pic = 1;", " ", "  break;", "  }", "  case 2:", "  {", " ", "   ", "  if((ps_cur_slice->u1_slice_type != I_SLICE)", "  && (ps_dec->i4_degrade_pic_cnt", "  != ps_dec->i4_nondegrade_interval))", "                     degrade_pic = 1;", " ", "  break;", "  }", "  case 1:", "  {", "   ", "  if(0 == ps_cur_slice->u1_nal_ref_idc)", "  {", "                     degrade_pic = 1;", "  }", "  break;", "  }", " ", "  }", "  if(degrade_pic)", "  {", "  if(ps_dec->i4_degrade_type & 0x2)", "                 ps_dec->u4_app_disable_deblk_frm = 1;", " ", "   ", "  if(0 == ps_cur_slice->u1_nal_ref_idc)", "  {", "  if(ps_dec->i4_degrade_type & 0x4)", "                     ps_dec->i4_mv_frac_mask = 0;", " ", "  if(ps_dec->i4_degrade_type & 0x8)", "                     ps_dec->i4_mv_frac_mask = 0;", "  }", "  }", "  else", "             ps_dec->i4_degrade_pic_cnt = 0;", "  }", " ", "  {", "  dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;", "  if(ps_dec->u1_sl_typ_5_9", "  && ((ps_cur_slice->u1_slice_type == I_SLICE)", "  || (ps_cur_slice->u1_slice_type", "  == SI_SLICE)))", "             ps_err->u1_cur_pic_type = PIC_TYPE_I;", "  else", "             ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN;", " ", "  if(ps_err->u1_pic_aud_i == PIC_TYPE_I)", "  {", "             ps_err->u1_cur_pic_type = PIC_TYPE_I;", "             ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN;", "  }", " ", "  if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)", "  {", "  if(ps_err->u1_err_flag)", "                 ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr);", "             ps_err->u1_err_flag = ACCEPT_ALL_PICS;", "  }", "  }", " ", "  if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending)", "  {", "   ", "         WORD32 j;", "  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)", "  {", " ", "             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                   j,", "                                   BUF_MGR_REF);", "             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,", "                                   ps_dec->au1_pic_buf_id_mv_buf_id_map[j],", "                                   BUF_MGR_REF);", "             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                   j,", "                                   BUF_MGR_IO);", "  }", " ", "   ", "         ps_dec->u1_second_field = 0;", "         ps_dec->i4_cur_display_seq = 0;", " ", "   ", "   ", "   ", "   ", " ", "         ps_dec->s_prev_seq_params.u1_eoseq_pending = 0;", "  }", "     ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps);", "  if(ret != OK)", "  return ret;", " ", "     ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data;", "     ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data;", "     ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info;", "  if(ps_dec->u1_separate_parse)", "  {", "         UWORD16 pic_wd = ps_dec->u4_width_at_init;", "         UWORD16 pic_ht = ps_dec->u4_height_at_init;", "         UWORD32 num_mbs;", " ", "  if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))", "  {", "             pic_wd = ps_dec->u2_pic_wd;", "             pic_ht = ps_dec->u2_pic_ht;", "  }", "         num_mbs = (pic_wd * pic_ht) >> 8;", " ", "  if(ps_dec->pu1_dec_mb_map)", "  {", "             memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs);", "  }", " ", "  if(ps_dec->pu1_recon_mb_map)", "  {", " ", "             memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs);", "  }", " ", "  if(ps_dec->pu2_slice_num_map)", "  {", "             memset((void *)ps_dec->pu2_slice_num_map, 0,", "  (num_mbs * sizeof(UWORD16)));", "  }", " ", "  }", " ", "     ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);", "     ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);", "     ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]);", "     ps_dec->u2_cur_slice_num = 0;", " ", "   ", "     ps_dec->s_high_profile.u1_scaling_present = 0;", "     ps_dec->s_high_profile.u1_transform8x8_present = 0;", " ", "   ", "  if(1 == ps_dec->u4_share_disp_buf)", "  {", "         UWORD32 i;", "   ", "  for(i = 0; i < MAX_DISP_BUFS_NEW; i++)", "  {", "  if(0 == ps_dec->u4_disp_buf_to_be_freed[i])", "  continue;", "             ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i,", "             BUF_MGR_IO);", "             ps_dec->u4_disp_buf_to_be_freed[i] = 0;", "             ps_dec->u4_disp_buf_mapping[i] = 0;", " ", "  }", "  }", "  if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))  ", "  {", "  pic_buffer_t *ps_cur_pic;", "         WORD32 cur_pic_buf_id, cur_mv_buf_id;", "  col_mv_buf_t *ps_col_mv;", "  while(1)", "  {", "             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(", "  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "  &cur_pic_buf_id);", "  if(ps_cur_pic == NULL)", "  {", "                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;", "  return ERROR_UNAVAIL_PICBUF_T;", "  }", "  if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id])", "  {", "  break;", "  }", " ", "  }", "         ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,", "  &cur_mv_buf_id);", "  if(ps_col_mv == NULL)", "  {", "             ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;", "  return ERROR_UNAVAIL_MVBUF_T;", "  }", " ", "         ps_dec->ps_cur_pic = ps_cur_pic;", "         ps_dec->u1_pic_buf_id = cur_pic_buf_id;", "         ps_cur_pic->u4_ts = ps_dec->u4_ts;", " ", " ", "         ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;", "         ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;", " ", "         ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;", "         ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;", "         ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;", " ", "  {", "   ", "             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];", "  *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic;", "   ", "  *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic;", "  }", " ", "  if(!ps_dec->ps_cur_pic)", "  {", "             WORD32 j;", "             H264_DEC_DEBUG_PRINT(\"------- Display Buffers Reset --------\\n\");", "  for(j = 0; j < MAX_DISP_BUFS_NEW; j++)", "  {", " ", "                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                       j,", "                                       BUF_MGR_REF);", "                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,", "                                       ps_dec->au1_pic_buf_id_mv_buf_id_map[j],", "                                       BUF_MGR_REF);", "                 ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "                                       j,", "                                       BUF_MGR_IO);", "  }", " ", "             ps_dec->i4_cur_display_seq = 0;", "             ps_dec->i4_prev_max_display_seq = 0;", "             ps_dec->i4_max_poc = 0;", " ", "             ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free(", "  (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,", "  &cur_pic_buf_id);", "  if(ps_cur_pic == NULL)", "  {", "                 ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T;", "  return ERROR_UNAVAIL_PICBUF_T;", "  }", " ", "             ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr,", "  &cur_mv_buf_id);", "  if(ps_col_mv == NULL)", "  {", "                 ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T;", "  return ERROR_UNAVAIL_MVBUF_T;", "  }", " ", "             ps_dec->ps_cur_pic = ps_cur_pic;", "             ps_dec->u1_pic_buf_id = cur_pic_buf_id;", "             ps_cur_pic->u4_ts = ps_dec->u4_ts;", "             ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic;", " ", "             ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id;", "             ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id;", " ", "             ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag;", "             ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv;", "             ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0;", " ", "  }", " ", "         ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag;", "         ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE;", "         H264_DEC_DEBUG_PRINT(\"got a buffer\\n\");", "  }", "  else", "  {", "         H264_DEC_DEBUG_PRINT(\"did not get a buffer\\n\");", "  }", " ", "     ps_dec->u4_pic_buf_got = 1;", " ", "     ps_dec->ps_cur_pic->i4_poc = i4_poc;", "     ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num;", "     ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num;", "     ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt;", "     ps_dec->ps_cur_pic->i4_bottom_field_order_cnt =", "                     ps_pps->i4_bottom_field_order_cnt;", "     ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc;", "     ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts;", " ", "     ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic);", "  if(u1_field_pic_flag && u1_bottom_field_flag)", "  {", "         WORD32 i4_temp_poc;", "         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;", "   ", "         ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y;", "         ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv;", "         ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv;", "         ps_dec->s_cur_pic.ps_mv +=", "  ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5);", "         ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht", "  * ps_dec->u2_pic_wd) >> 5);", "         ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD;", "         i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;", "         i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;", "         i4_temp_poc = MIN(i4_top_field_order_poc,", "                                  i4_bot_field_order_poc);", "         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;", "  }", " ", "     ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag", "  && (!u1_field_pic_flag);", " ", "     ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag", "  << 2);", " ", "     ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;  ", "     ps_dec->ps_cur_mb_row++;  ", "     ps_dec->ps_top_mb_row =", "                     ps_dec->ps_nbr_mb_row", "  + ((ps_dec->u2_frm_wd_in_mbs + 1)", "  << (1", "  - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag));", "     ps_dec->ps_top_mb_row++;  ", " ", "     ps_dec->pu1_y = ps_dec->pu1_y_scratch[0];", "     ps_dec->pu1_u = ps_dec->pu1_u_scratch[0];", "     ps_dec->pu1_v = ps_dec->pu1_v_scratch[0];", "     ps_dec->u1_yuv_scratch_idx = 0;", "   ", "     ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;", "     ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0];", "   ", "     ps_dec->u1_mv_top_p = 0;", "     ps_dec->u1_mb_idx = 0;", "   ", "     ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv;", "     ps_dec->pu1_yleft = 0;", "     ps_dec->pu1_uleft = 0;", "     ps_dec->pu1_vleft = 0;", "     ps_dec->u1_not_wait_rec = 2;", "     ps_dec->u2_total_mbs_coded = 0;", "     ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE);", "     ps_dec->u4_pred_info_idx = 0;", "     ps_dec->u4_pred_info_pkd_idx = 0;", "     ps_dec->u4_dma_buf_idx = 0;", "     ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv;", "     ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv;", "     ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag;", "     ps_dec->ps_part = ps_dec->ps_parse_part_params;", "     ps_dec->i2_prev_slice_mbx = -1;", "     ps_dec->i2_prev_slice_mby = 0;", "     ps_dec->u2_mv_2mb[0] = 0;", "     ps_dec->u2_mv_2mb[1] = 0;", "     ps_dec->u1_last_pic_not_decoded = 0;", " ", "     ps_dec->u2_cur_slice_num_dec_thread = 0;", "     ps_dec->u2_cur_slice_num_bs = 0;", "     ps_dec->u4_intra_pred_line_ofst = 0;", "     ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line;", "     ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line;", "     ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line;", " ", "     ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line;", "     ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line;", "     ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line;", " ", " ", " ", " ", " ", "     ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line", "  + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE);", " ", "     ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line", "  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR;", "     ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line", "  + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE;", " ", "     ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;", "     ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn;", "     ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp;", "   ", "  {", "  if(ps_cur_slice->u1_mbaff_frame_flag)", "  {", "             ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff;", "             ps_dec->pf_mvpred = ih264d_mvpred_mbaff;", "  }", "  else", "  {", "             ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff;", "             ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag;", "  }", "  }", "   ", "  {", "         UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag;", " ", "         UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag;", " ", "         UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4)", "  % (ps_dec->u1_recon_mb_grp >> u1_mbaff));", "         UWORD16 ui16_lastmbs_widthY =", "  (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp", "  >> u1_mbaff) << 4));", "         UWORD16 ui16_lastmbs_widthUV =", "                         uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp", "  >> u1_mbaff) << 3);", " ", "         ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;", "         ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;", "         ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;", " ", "         ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y", "  << u1_field_pic_flag;", "         ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv", "  << u1_field_pic_flag;", " ", "  if(u1_field_pic_flag)", "  {", "             ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y;", "             ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv;", "  }", " ", "   ", "         ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4)", "  >> u1_mbaff);", "         ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4)", "  >> u1_mbaff);", " ", "   ", "         ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY", "  + (PAD_LEN_Y_H << 1)", "  + ps_dec->s_tran_addrecon.u2_frm_wd_y", "  * ((15 << u1_mbaff) + u1_mbaff));", "         ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV", "  + (PAD_LEN_UV_H << 2)", "  + ps_dec->s_tran_addrecon.u2_frm_wd_uv", "  * ((15 << u1_mbaff) + u1_mbaff));", " ", "   ", "   ", "         ih264d_assign_pic_num(ps_dec);", "         ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp", "  << 2) - 1 - (u1_mbaff << 2);", "         ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp", "  >> u1_mbaff) - 1) << (4 + u1_mbaff);", "  }", "   ", "   ", "   ", "  if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC)", "  {", "  if((ps_seq->i4_seq_scaling_matrix_present_flag)", "  || (ps_pps->i4_pic_scaling_matrix_present_flag))", "  {", "             ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec);", "             ps_dec->s_high_profile.u1_scaling_present = 1;", "  }", "  else", "  {", "             ih264d_form_default_scaling_matrix(ps_dec);", "  }", " ", "  if(ps_pps->i4_transform_8x8_mode_flag)", "  {", "             ps_dec->s_high_profile.u1_transform8x8_present = 1;", "  }", "  }", "  else", "  {", "         ih264d_form_default_scaling_matrix(ps_dec);", "  }", " ", "   ", "     ps_dec->s_high_profile.u1_direct_8x8_inference_flag =", "                     ps_seq->u1_direct_8x8_inference_flag;", "     ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt;", " ", "     ps_dec->i1_recon_in_thread3_flag = 1;", "     ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon;", "  if(ps_dec->u1_separate_parse)", "  {", "         memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon,", "  sizeof(tfr_ctxt_t));", "  if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag)", "  {", "             memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon,", "  sizeof(tfr_ctxt_t));", "             ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon;", "  }", "  }", " ", " ", "     ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon),", "                                ps_dec->u2_frm_wd_in_mbs, 0);", " ", "     ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic;", "     ps_dec->u4_cur_deblk_mb_num = 0;", " ", "     ps_dec->u4_deblk_mb_x = 0;", " ", "      ps_dec->u4_deblk_mb_y = 0;", "      ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;", "  ", "     ps_dec->u4_first_slice_in_pic = 0;", "      H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);", "      return OK;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
{"tokens": ["Status ImportNodes(ValueMapManager value_manager,", "const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {", "Location unknown_loc = builder.getUnknownLoc();", "MLIRContext* context = builder.getContext();", "", "Type placeholder_ty = OpaqueTensorType::get(context);", "Type control_ty = ControlType::get(context);", "TFGraphDialect* tfgDialect =", "cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));", "StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();", "StringAttr name_attr = tfgDialect->getNameAttrIdentifier();", "StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();", "", "for (const NodeDef& node : nodes) {", "DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";", "if (node.op().empty()) return InvalidArgument(\"empty op type\");", "OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));", "", "for (const std::string& input : node.input())", "state.operands.push_back(", "value_manager.GetValueOrCreatePlaceholder(input));", "", "", "state.types.push_back(placeholder_ty);", "state.types.push_back(control_ty);", "", "for (const auto& namedAttr : node.attr()) {", "const std::string& name = namedAttr.first;", "const AttrValue& tf_attr = namedAttr.second;", "TF_ASSIGN_OR_RETURN(Attribute attr,", "ConvertAttributeValue(tf_attr, builder, tfgDialect));", "state.addAttribute(name, attr);", "}", "if (!node.device().empty())", "state.addAttribute(device_attr, StringAttr::get(context, node.device()));", "if (!node.name().empty())", "state.addAttribute(name_attr, StringAttr::get(context, node.name()));", "if (node.has_experimental_type()) {", "TF_ASSIGN_OR_RETURN(", "tf_type::FullTypeAttr type,", "ConvertAttribute(node.experimental_type(), builder, tfgDialect));", "state.addAttribute(fulltype_attr, type);", "}", "", "Operation* op = builder.create(state);", "", "StringRef node_name = node.name();", "{", "size_t colon_sep = node_name.find_first_of(':');", "if (colon_sep != StringRef::npos)", "node_name = node_name.take_front(colon_sep);", "}", "TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));", "}", "", "for (Operation& op : *builder.getInsertionBlock()) {", "if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {", "return InvalidArgument(absl::StrCat(", "\"Couldn't import graph: placeholder left \",", "op.getAttrOfType<StringAttr>(name_attr).getValue().str()));", "}", "}", "return Status::OK();", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static int rename_in_ns(int pid, char *oldname, char **newnamep)", "{", "int fd = -1, ofd = -1, ret, ifindex = -1;", "bool grab_newname = false;", "", "ofd = lxc_preserve_ns(getpid(), \"net\");", "if (ofd < 0) {", "fprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());", "return -1;", "}", "", "fd = lxc_preserve_ns(pid, \"net\");", "if (fd < 0) {", "fprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);", "return -1;", "}", "", "if (setns(fd, 0) < 0) {", "fprintf(stderr, \"setns to container network namespace\\n\");", "goto out_err;", "}", "close(fd); fd = -1;", "if (!*newnamep) {", "grab_newname = true;", "*newnamep = VETH_DEF_NAME;", "if (!(ifindex = if_nametoindex(oldname))) {", "fprintf(stderr, \"failed to get netdev index\\n\");", "goto out_err;", "}", "}", "if ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {", "fprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);", "goto out_err;", "}", "if (grab_newname) {", "char ifname[IFNAMSIZ], *namep = ifname;", "if (!if_indextoname(ifindex, namep)) {", "fprintf(stderr, \"Failed to get new netdev name\\n\");", "goto out_err;", "}", "*newnamep = strdup(namep);", "if (!*newnamep)", "goto out_err;", "}", "if (setns(ofd, 0) < 0) {", "fprintf(stderr, \"Error returning to original netns\\n\");", "close(ofd);", "return -1;", "}", "close(ofd);", "", "return 0;", "", "out_err:", "if (ofd >= 0)", "close(ofd);", "if (setns(ofd, 0) < 0)", "fprintf(stderr, \"Error returning to original network namespace\\n\");", "if (fd >= 0)", "close(fd);", "return -1;", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0]}
{"tokens": ["static int snd_ctl_elem_add(struct snd_ctl_file *file,", "struct snd_ctl_elem_info *info, int replace)", "{", "struct snd_card *card = file->card;", "struct snd_kcontrol kctl, *_kctl;", "unsigned int access;", "long private_size;", "struct user_element *ue;", "int idx, err;", "", "if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)", "return -ENOMEM;", "if (info->count < 1)", "return -EINVAL;", "access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :", "(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|", "SNDRV_CTL_ELEM_ACCESS_INACTIVE|", "SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));", "info->id.numid = 0;", "memset(&kctl, 0, sizeof(kctl));", "down_write(&card->controls_rwsem);", "_kctl = snd_ctl_find_id(card, &info->id);", "err = 0;", "if (_kctl) {", "if (replace)", "err = snd_ctl_remove(card, _kctl);", "else", "err = -EBUSY;", "} else {", "if (replace)", "err = -ENOENT;", "}", "up_write(&card->controls_rwsem);", "if (err < 0)", "return err;", "memcpy(&kctl.id, &info->id, sizeof(info->id));", "kctl.count = info->owner ? info->owner : 1;", "access |= SNDRV_CTL_ELEM_ACCESS_USER;", "if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)", "kctl.info = snd_ctl_elem_user_enum_info;", "else", "kctl.info = snd_ctl_elem_user_info;", "if (access & SNDRV_CTL_ELEM_ACCESS_READ)", "kctl.get = snd_ctl_elem_user_get;", "if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)", "kctl.put = snd_ctl_elem_user_put;", "if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {", "kctl.tlv.c = snd_ctl_elem_user_tlv;", "access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;", "}", "switch (info->type) {", "case SNDRV_CTL_ELEM_TYPE_BOOLEAN:", "case SNDRV_CTL_ELEM_TYPE_INTEGER:", "private_size = sizeof(long);", "if (info->count > 128)", "return -EINVAL;", "break;", "case SNDRV_CTL_ELEM_TYPE_INTEGER64:", "private_size = sizeof(long long);", "if (info->count > 64)", "return -EINVAL;", "break;", "case SNDRV_CTL_ELEM_TYPE_ENUMERATED:", "private_size = sizeof(unsigned int);", "if (info->count > 128 || info->value.enumerated.items == 0)", "return -EINVAL;", "break;", "case SNDRV_CTL_ELEM_TYPE_BYTES:", "private_size = sizeof(unsigned char);", "if (info->count > 512)", "return -EINVAL;", "break;", "case SNDRV_CTL_ELEM_TYPE_IEC958:", "private_size = sizeof(struct snd_aes_iec958);", "if (info->count != 1)", "return -EINVAL;", "break;", "default:", "return -EINVAL;", "}", "private_size *= info->count;", "ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);", "if (ue == NULL)", "return -ENOMEM;", "ue->card = card;", "ue->info = *info;", "ue->info.access = 0;", "ue->elem_data = (char *)ue + sizeof(*ue);", "ue->elem_data_size = private_size;", "if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {", "err = snd_ctl_elem_init_enum_names(ue);", "if (err < 0) {", "kfree(ue);", "return err;", "}", "}", "kctl.private_free = snd_ctl_elem_user_free;", "_kctl = snd_ctl_new(&kctl, access);", "if (_kctl == NULL) {", "kfree(ue->priv_data);", "kfree(ue);", "return -ENOMEM;", "}", "_kctl->private_data = ue;", "for (idx = 0; idx < _kctl->count; idx++)", "_kctl->vd[idx].owner = file;", "err = snd_ctl_add(card, _kctl);", "if (err < 0)", "return err;", "", "down_write(&card->controls_rwsem);", "card->user_ctl_count++;", "up_write(&card->controls_rwsem);", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void PaymentRequest::CanMakePayment() {", "   if (!IsInitialized()) {", "     log_.Error(\"Attempted canMakePayment without initialization\");", "     OnConnectionTerminated();", "     return;", "   }", " ", "    ", " ", "    if (observer_for_testing_)", "      observer_for_testing_->OnCanMakePaymentCalled();", "  ", "   if (!delegate_->GetPrefService()->GetBoolean(kCanMakePaymentEnabled) ||", "       !state_) {", "     CanMakePaymentCallback( false);", "   } else {", "     state_->CanMakePayment(", "         base::BindOnce(&PaymentRequest::CanMakePaymentCallback,", "                        weak_ptr_factory_.GetWeakPtr()));", "    }", "  }"], "ner_tags": [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE  omx_video::free_buffer(OMX_IN OMX_HANDLETYPE         hComp,", "         OMX_IN OMX_U32                 port,", "         OMX_IN OMX_BUFFERHEADERTYPE* buffer)", " {", "  (void)hComp;", "     OMX_ERRORTYPE eRet = OMX_ErrorNone;", "  unsigned int nPortIndex;", " ", "     DEBUG_PRINT_LOW(\"In for encoder free_buffer\");", " ", "  if (m_state == OMX_StateIdle &&", "  (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {", "         DEBUG_PRINT_LOW(\" free buffer while Component in Loading pending\");", "  } else if ((m_sInPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_IN)||", "  (m_sOutPortDef.bEnabled == OMX_FALSE && port == PORT_INDEX_OUT)) {", "         DEBUG_PRINT_LOW(\"Free Buffer while port %u disabled\", (unsigned int)port);", "  } else if (m_state == OMX_StateExecuting || m_state == OMX_StatePause) {", "         DEBUG_PRINT_ERROR(\"ERROR: Invalid state to free buffer,ports need to be disabled\");", "         post_event(OMX_EventError,", "                 OMX_ErrorPortUnpopulated,", "                 OMX_COMPONENT_GENERATE_EVENT);", "  return eRet;", "  } else {", "         DEBUG_PRINT_ERROR(\"ERROR: Invalid state to free buffer,port lost Buffers\");", "         post_event(OMX_EventError,", "                 OMX_ErrorPortUnpopulated,", "                 OMX_COMPONENT_GENERATE_EVENT);", "  }", " ", "  if (port == PORT_INDEX_IN) {", "         nPortIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);", " ", "  ", "          DEBUG_PRINT_LOW(\"free_buffer on i/p port - Port idx %u, actual cnt %u\",", "                  nPortIndex, (unsigned int)m_sInPortDef.nBufferCountActual);", "        if (nPortIndex < m_sInPortDef.nBufferCountActual) {", "         if (nPortIndex < m_sInPortDef.nBufferCountActual &&", "                 BITMASK_PRESENT(&m_inp_bm_count, nPortIndex)) {", "              BITMASK_CLEAR(&m_inp_bm_count,nPortIndex);", "              free_input_buffer (buffer);", "             m_sInPortDef.bPopulated = OMX_FALSE;", " ", "   ", "  if (release_input_done()", " #ifdef _ANDROID_ICS_", "  && !meta_mode_enable", " #endif", "  ) {", "                 input_use_buffer = false;", "  if (m_inp_mem_ptr) {", "                     DEBUG_PRINT_LOW(\"Freeing m_inp_mem_ptr\");", "                     free (m_inp_mem_ptr);", "                     m_inp_mem_ptr = NULL;", "  }", "  if (m_pInput_pmem) {", "                     DEBUG_PRINT_LOW(\"Freeing m_pInput_pmem\");", "                     free(m_pInput_pmem);", "                     m_pInput_pmem = NULL;", "  }", " #ifdef USE_ION", "  if (m_pInput_ion) {", "                     DEBUG_PRINT_LOW(\"Freeing m_pInput_ion\");", "                     free(m_pInput_ion);", "                     m_pInput_ion = NULL;", "  }", " #endif", "  }", "  } else {", "             DEBUG_PRINT_ERROR(\"ERROR: free_buffer ,Port Index Invalid\");", "             eRet = OMX_ErrorBadPortIndex;", "  }", " ", "  if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING)", "  && release_input_done()) {", "             DEBUG_PRINT_LOW(\"MOVING TO DISABLED STATE\");", "             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_INPUT_DISABLE_PENDING);", "             post_event(OMX_CommandPortDisable,", "                     PORT_INDEX_IN,", "                     OMX_COMPONENT_GENERATE_EVENT);", "  }", "  } else if (port == PORT_INDEX_OUT) {", "         nPortIndex = buffer - (OMX_BUFFERHEADERTYPE*)m_out_mem_ptr;", " ", "  ", "          DEBUG_PRINT_LOW(\"free_buffer on o/p port - Port idx %u, actual cnt %u\",", "                  nPortIndex, (unsigned int)m_sOutPortDef.nBufferCountActual);", "        if (nPortIndex < m_sOutPortDef.nBufferCountActual) {", "         if (nPortIndex < m_sOutPortDef.nBufferCountActual &&", "                 BITMASK_PRESENT(&m_out_bm_count, nPortIndex)) {", "              BITMASK_CLEAR(&m_out_bm_count,nPortIndex);", "              m_sOutPortDef.bPopulated = OMX_FALSE;", "             free_output_buffer (buffer);", " ", "  if (release_output_done()) {", "                 output_use_buffer = false;", "  if (m_out_mem_ptr) {", "                     DEBUG_PRINT_LOW(\"Freeing m_out_mem_ptr\");", "                     free (m_out_mem_ptr);", "                     m_out_mem_ptr = NULL;", "  }", "  if (m_pOutput_pmem) {", "                     DEBUG_PRINT_LOW(\"Freeing m_pOutput_pmem\");", "                     free(m_pOutput_pmem);", "                     m_pOutput_pmem = NULL;", "  }", " #ifdef USE_ION", "  if (m_pOutput_ion) {", "                     DEBUG_PRINT_LOW(\"Freeing m_pOutput_ion\");", "                     free(m_pOutput_ion);", "                     m_pOutput_ion = NULL;", "  }", " #endif", "  }", "  } else {", "             DEBUG_PRINT_ERROR(\"ERROR: free_buffer , Port Index Invalid\");", "             eRet = OMX_ErrorBadPortIndex;", "  }", "  if (BITMASK_PRESENT((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING)", "  && release_output_done() ) {", "             DEBUG_PRINT_LOW(\"FreeBuffer : If any Disable event pending,post it\");", " ", "             DEBUG_PRINT_LOW(\"MOVING TO DISABLED STATE\");", "             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_OUTPUT_DISABLE_PENDING);", "             post_event(OMX_CommandPortDisable,", "                     PORT_INDEX_OUT,", "                     OMX_COMPONENT_GENERATE_EVENT);", " ", "  }", "  } else {", "         eRet = OMX_ErrorBadPortIndex;", "  }", "  if ((eRet == OMX_ErrorNone) &&", "  (BITMASK_PRESENT(&m_flags ,OMX_COMPONENT_LOADING_PENDING))) {", "  if (release_done()) {", "  if (dev_stop() != 0) {", "                 DEBUG_PRINT_ERROR(\"ERROR: dev_stop() FAILED\");", "                 eRet = OMX_ErrorHardware;", "  }", "             BITMASK_CLEAR((&m_flags),OMX_COMPONENT_LOADING_PENDING);", "             post_event(OMX_CommandStateSet, OMX_StateLoaded,", "                     OMX_COMPONENT_GENERATE_EVENT);", "  } else {", "             DEBUG_PRINT_HIGH(\"in free buffer, release not done, need to free more buffers input %\" PRIx64\" output %\" PRIx64,", "                     m_out_bm_count, m_inp_bm_count);", "  }", "  }", " ", "  return eRet;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  bool XmlReader::LoadFile(const std::string& file_path) {", "    const int kParseOptions = XML_PARSE_RECOVER |   ", "                            XML_PARSE_NONET |     ", "                            XML_PARSE_NOXXE;      ", "                             XML_PARSE_NONET;      ", "    reader_ = xmlReaderForFile(file_path.c_str(), NULL, kParseOptions);", "    return reader_ != NULL;", "  }"], "ner_tags": [0, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" int create_user_ns(struct cred *new)", " {", " \tstruct user_namespace *ns, *parent_ns = new->user_ns;", " \tkuid_t owner = new->euid;", "  \tkgid_t group = new->egid;", "  \tint ret;", "  ", " \t ", " \tif (current_chrooted())", " \t\treturn -EPERM;", " ", "  \t ", " \tif (!kuid_has_mapping(parent_ns, owner) ||", " \t    !kgid_has_mapping(parent_ns, group))", " \t\treturn -EPERM;", " ", " \tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);", " \tif (!ns)", " \t\treturn -ENOMEM;", " ", " \tret = proc_alloc_inum(&ns->proc_inum);", " \tif (ret) {", " \t\tkmem_cache_free(user_ns_cachep, ns);", " \t\treturn ret;", " \t}", " ", " \tatomic_set(&ns->count, 1);", " \t ", " \tns->parent = parent_ns;", " \tns->owner = owner;", " \tns->group = group;", " ", " \tset_cred_user_ns(new, ns);", " ", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["zfs_fuid_create(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr,", "zfs_fuid_type_t type, zfs_fuid_info_t **fuidpp)", "{", "#ifdef HAVE_KSID", "const char *domain;", "char *kdomain;", "uint32_t fuid_idx = FUID_INDEX(id);", "uint32_t rid;", "idmap_stat status;", "uint64_t idx = 0;", "zfs_fuid_t *zfuid = NULL;", "zfs_fuid_info_t *fuidp = NULL;", "", "", "", "", "", "", "", "", "", "if (!zfsvfs->z_use_fuids || !IS_EPHEMERAL(id) || fuid_idx != 0)", "return (id);", "", "if (zfsvfs->z_replay) {", "fuidp = zfsvfs->z_fuid_replay;", "", "", "", "", "", "", "", "if (fuidp == NULL)", "return (UID_NOBODY);", "", "VERIFY3U(type, >=, ZFS_OWNER);", "VERIFY3U(type, <=, ZFS_ACE_GROUP);", "", "switch (type) {", "case ZFS_ACE_USER:", "case ZFS_ACE_GROUP:", "zfuid = list_head(&fuidp->z_fuids);", "rid = FUID_RID(zfuid->z_logfuid);", "idx = FUID_INDEX(zfuid->z_logfuid);", "break;", "case ZFS_OWNER:", "rid = FUID_RID(fuidp->z_fuid_owner);", "idx = FUID_INDEX(fuidp->z_fuid_owner);", "break;", "case ZFS_GROUP:", "rid = FUID_RID(fuidp->z_fuid_group);", "idx = FUID_INDEX(fuidp->z_fuid_group);", "break;", "};", "domain = fuidp->z_domain_table[idx - 1];", "} else {", "if (type == ZFS_OWNER || type == ZFS_ACE_USER)", "status = kidmap_getsidbyuid(crgetzone(cr), id,", "&domain, &rid);", "else", "status = kidmap_getsidbygid(crgetzone(cr), id,", "&domain, &rid);", "", "if (status != 0) {", "", "", "", "", "", "rid = UID_NOBODY;", "domain = nulldomain;", "}", "}", "", "idx = zfs_fuid_find_by_domain(zfsvfs, domain, &kdomain, B_TRUE);", "", "if (!zfsvfs->z_replay)", "zfs_fuid_node_add(fuidpp, kdomain,", "rid, idx, id, type);", "else if (zfuid != NULL) {", "list_remove(&fuidp->z_fuids, zfuid);", "kmem_free(zfuid, sizeof (zfs_fuid_t));", "}", "return (FUID_ENCODE(idx, rid));", "#else", "", "", "", "return (id);", "#endif", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void PrintWebViewHelper::OnPrintingDone(bool success) {", "   CHECK_LE(ipc_nesting_level_, 1);", "    notify_browser_of_print_failure_ = false;", "    if (!success)", "      LOG(ERROR) << \"Failure in OnPrintingDone\";", "   DidFinishPrinting(success ? OK : FAIL_PRINT);", " }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0]}
{"tokens": ["static PyObject* get_value(PyObject* self, const char* buffer, int* position,", "int type, int max, PyObject* as_class,", "unsigned char tz_aware, unsigned char uuid_subtype) {", "struct module_state *state = GETSTATE(self);", "", "PyObject* value;", "PyObject* error;", "switch (type) {", "case 1:", "{", "double d;", "if (max < 8) {", "goto invalid;", "}", "memcpy(&d, buffer + *position, 8);", "value = PyFloat_FromDouble(d);", "if (!value) {", "return NULL;", "}", "*position += 8;", "break;", "}", "case 2:", "case 14:", "{", "int value_length = ((int*)(buffer + *position))[0] - 1;", "if (max < value_length) {", "goto invalid;", "}", "*position += 4;", "value = PyUnicode_DecodeUTF8(buffer + *position, value_length, \"strict\");", "if (!value) {", "return NULL;", "}", "*position += value_length + 1;", "break;", "}", "case 3:", "{", "int size;", "memcpy(&size, buffer + *position, 4);", "if (max < size) {", "goto invalid;", "}", "value = elements_to_dict(self, buffer + *position + 4,", "size - 5, as_class, tz_aware, uuid_subtype);", "if (!value) {", "return NULL;", "}", "", "", "if (strcmp(buffer + *position + 5, \"$ref\") == 0) {", "PyObject* dbref;", "PyObject* collection = PyDict_GetItemString(value, \"$ref\");", "PyObject* id = PyDict_GetItemString(value, \"$id\");", "PyObject* database = PyDict_GetItemString(value, \"$db\");", "", "Py_INCREF(collection);", "PyDict_DelItemString(value, \"$ref\");", "Py_INCREF(id);", "PyDict_DelItemString(value, \"$id\");", "", "if (database == NULL) {", "database = Py_None;", "Py_INCREF(database);", "} else {", "Py_INCREF(database);", "PyDict_DelItemString(value, \"$db\");", "}", "", "dbref = PyObject_CallFunctionObjArgs(state->DBRef, collection, id, database, value, NULL);", "Py_DECREF(value);", "value = dbref;", "", "Py_DECREF(id);", "Py_DECREF(collection);", "Py_DECREF(database);", "if (!value) {", "return NULL;", "}", "}", "", "*position += size;", "break;", "}", "case 4:", "{", "int size,", "end;", "", "memcpy(&size, buffer + *position, 4);", "if (max < size) {", "goto invalid;", "}", "end = *position + size - 1;", "*position += 4;", "", "value = PyList_New(0);", "if (!value) {", "return NULL;", "}", "while (*position < end) {", "PyObject* to_append;", "", "int type = (int)buffer[(*position)++];", "int key_size = strlen(buffer + *position);", "*position += key_size + 1;", "to_append = get_value(self, buffer, position, type,", "max - key_size, as_class, tz_aware, uuid_subtype);", "if (!to_append) {", "Py_DECREF(value);", "return NULL;", "}", "PyList_Append(value, to_append);", "Py_DECREF(to_append);", "}", "(*position)++;", "break;", "}", "case 5:", "{", "PyObject* data;", "PyObject* st;", "int length, subtype;", "", "memcpy(&length, buffer + *position, 4);", "if (max < length) {", "goto invalid;", "}", "subtype = (unsigned char)buffer[*position + 4];", "#if PY_MAJOR_VERSION >= 3", "", "if (subtype == 0) {", "value = PyBytes_FromStringAndSize(buffer + *position + 5, length);", "*position += length + 5;", "break;", "}", "if (subtype == 2) {", "data = PyBytes_FromStringAndSize(buffer + *position + 9, length - 4);", "} else {", "data = PyBytes_FromStringAndSize(buffer + *position + 5, length);", "}", "#else", "if (subtype == 2) {", "data = PyString_FromStringAndSize(buffer + *position + 9, length - 4);", "} else {", "data = PyString_FromStringAndSize(buffer + *position + 5, length);", "}", "#endif", "if (!data) {", "return NULL;", "}", "if ((subtype == 3 || subtype == 4) && state->UUID) {", "PyObject* kwargs;", "PyObject* args = PyTuple_New(0);", "if (!args) {", "Py_DECREF(data);", "return NULL;", "}", "kwargs = PyDict_New();", "if (!kwargs) {", "Py_DECREF(data);", "Py_DECREF(args);", "return NULL;", "}", "", "assert(length == 16);", "", "if (uuid_subtype == CSHARP_LEGACY) {", "", "PyDict_SetItemString(kwargs, \"bytes_le\", data);", "}", "else {", "if (uuid_subtype == JAVA_LEGACY) {", "", "char big_endian[16];", "_fix_java(buffer + *position + 5, big_endian);", "", "Py_DECREF(data);", "#if PY_MAJOR_VERSION >= 3", "data = PyBytes_FromStringAndSize(big_endian, length);", "#else", "data = PyString_FromStringAndSize(big_endian, length);", "#endif", "}", "PyDict_SetItemString(kwargs, \"bytes\", data);", "}", "value = PyObject_Call(state->UUID, args, kwargs);", "", "Py_DECREF(args);", "Py_DECREF(kwargs);", "Py_DECREF(data);", "if (!value) {", "return NULL;", "}", "", "*position += length + 5;", "break;", "}", "", "#if PY_MAJOR_VERSION >= 3", "st = PyLong_FromLong(subtype);", "#else", "st = PyInt_FromLong(subtype);", "#endif", "if (!st) {", "Py_DECREF(data);", "return NULL;", "}", "value = PyObject_CallFunctionObjArgs(state->Binary, data, st, NULL);", "Py_DECREF(st);", "Py_DECREF(data);", "if (!value) {", "return NULL;", "}", "*position += length + 5;", "break;", "}", "case 6:", "case 10:", "{", "value = Py_None;", "Py_INCREF(value);", "break;", "}", "case 7:", "{", "if (max < 12) {", "goto invalid;", "}", "#if PY_MAJOR_VERSION >= 3", "value = PyObject_CallFunction(state->ObjectId, \"y#\", buffer + *position, 12);", "#else", "value = PyObject_CallFunction(state->ObjectId, \"s#\", buffer + *position, 12);", "#endif", "if (!value) {", "return NULL;", "}", "*position += 12;", "break;", "}", "case 8:", "{", "value = buffer[(*position)++] ? Py_True : Py_False;", "Py_INCREF(value);", "break;", "}", "case 9:", "{", "PyObject* naive;", "PyObject* replace;", "PyObject* args;", "PyObject* kwargs;", "if (max < 8) {", "goto invalid;", "}", "naive = datetime_from_millis(*(long long*)(buffer + *position));", "*position += 8;", "if (!tz_aware) {", "value = naive;", "break;", "}", "", "if (!naive) {", "return NULL;", "}", "replace = PyObject_GetAttrString(naive, \"replace\");", "Py_DECREF(naive);", "if (!replace) {", "return NULL;", "}", "args = PyTuple_New(0);", "if (!args) {", "Py_DECREF(replace);", "return NULL;", "}", "kwargs = PyDict_New();", "if (!kwargs) {", "Py_DECREF(replace);", "Py_DECREF(args);", "return NULL;", "}", "if (PyDict_SetItemString(kwargs, \"tzinfo\", state->UTC) == -1) {", "Py_DECREF(replace);", "Py_DECREF(args);", "Py_DECREF(kwargs);", "return NULL;", "}", "value = PyObject_Call(replace, args, kwargs);", "Py_DECREF(replace);", "Py_DECREF(args);", "Py_DECREF(kwargs);", "break;", "}", "case 11:", "{", "PyObject* pattern;", "int flags_length,", "flags,", "i;", "int pattern_length = strlen(buffer + *position);", "if (max < pattern_length) {", "goto invalid;", "}", "pattern = PyUnicode_DecodeUTF8(buffer + *position, pattern_length, \"strict\");", "if (!pattern) {", "return NULL;", "}", "*position += pattern_length + 1;", "flags_length = strlen(buffer + *position);", "if (max < pattern_length + flags_length) {", "Py_DECREF(pattern);", "goto invalid;", "}", "flags = 0;", "for (i = 0; i < flags_length; i++) {", "if (buffer[*position + i] == 'i') {", "flags |= 2;", "} else if (buffer[*position + i] == 'l') {", "flags |= 4;", "} else if (buffer[*position + i] == 'm') {", "flags |= 8;", "} else if (buffer[*position + i] == 's') {", "flags |= 16;", "} else if (buffer[*position + i] == 'u') {", "flags |= 32;", "} else if (buffer[*position + i] == 'x') {", "flags |= 64;", "}", "}", "*position += flags_length + 1;", "value = PyObject_CallFunction(state->RECompile, \"Oi\", pattern, flags);", "Py_DECREF(pattern);", "break;", "}", "case 12:", "{", "int collection_length;", "PyObject* collection;", "PyObject* id;", "", "*position += 4;", "collection_length = strlen(buffer + *position);", "if (max < collection_length) {", "goto invalid;", "}", "collection = PyUnicode_DecodeUTF8(buffer + *position, collection_length, \"strict\");", "if (!collection) {", "return NULL;", "}", "*position += collection_length + 1;", "if (max < collection_length + 12) {", "Py_DECREF(collection);", "goto invalid;", "}", "id = PyObject_CallFunction(state->ObjectId, \"s#\", buffer + *position, 12);", "if (!id) {", "Py_DECREF(collection);", "return NULL;", "}", "*position += 12;", "value = PyObject_CallFunctionObjArgs(state->DBRef, collection, id, NULL);", "Py_DECREF(collection);", "Py_DECREF(id);", "break;", "}", "case 13:", "{", "PyObject* code;", "int value_length = ((int*)(buffer + *position))[0] - 1;", "if (max < value_length) {", "goto invalid;", "}", "*position += 4;", "code = PyUnicode_DecodeUTF8(buffer + *position, value_length, \"strict\");", "if (!code) {", "return NULL;", "}", "*position += value_length + 1;", "value = PyObject_CallFunctionObjArgs(state->Code, code, NULL, NULL);", "Py_DECREF(code);", "break;", "}", "case 15:", "{", "int code_length,", "scope_size;", "PyObject* code;", "PyObject* scope;", "", "*position += 8;", "code_length = strlen(buffer + *position);", "if (max < 8 + code_length) {", "goto invalid;", "}", "code = PyUnicode_DecodeUTF8(buffer + *position, code_length, \"strict\");", "if (!code) {", "return NULL;", "}", "*position += code_length + 1;", "", "memcpy(&scope_size, buffer + *position, 4);", "scope = elements_to_dict(self, buffer + *position + 4, scope_size - 5,", "(PyObject*)&PyDict_Type, tz_aware, uuid_subtype);", "if (!scope) {", "Py_DECREF(code);", "return NULL;", "}", "*position += scope_size;", "", "value = PyObject_CallFunctionObjArgs(state->Code, code, scope, NULL);", "Py_DECREF(code);", "Py_DECREF(scope);", "break;", "}", "case 16:", "{", "int i;", "if (max < 4) {", "goto invalid;", "}", "memcpy(&i, buffer + *position, 4);", "#if PY_MAJOR_VERSION >= 3", "value = PyLong_FromLong(i);", "#else", "value = PyInt_FromLong(i);", "#endif", "if (!value) {", "return NULL;", "}", "*position += 4;", "break;", "}", "case 17:", "{", "unsigned int time, inc;", "if (max < 8) {", "goto invalid;", "}", "memcpy(&inc, buffer + *position, 4);", "memcpy(&time, buffer + *position + 4, 4);", "value = PyObject_CallFunction(state->Timestamp, \"II\", time, inc);", "if (!value) {", "return NULL;", "}", "*position += 8;", "break;", "}", "case 18:", "{", "long long ll;", "if (max < 8) {", "goto invalid;", "}", "memcpy(&ll, buffer + *position, 8);", "value = PyLong_FromLongLong(ll);", "if (!value) {", "return NULL;", "}", "*position += 8;", "break;", "}", "case -1:", "{", "value = PyObject_CallFunctionObjArgs(state->MinKey, NULL);", "break;", "}", "case 127:", "{", "value = PyObject_CallFunctionObjArgs(state->MaxKey, NULL);", "break;", "}", "default:", "{", "PyObject* InvalidDocument = _error(\"InvalidDocument\");", "PyErr_SetString(InvalidDocument, \"no c decoder for this type yet\");", "Py_DECREF(InvalidDocument);", "return NULL;", "}", "}", "return value;", "", "invalid:", "", "error = _error(\"InvalidBSON\");", "PyErr_SetNone(error);", "Py_DECREF(error);", "return NULL;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["PJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,", "unsigned slot)", "{", "vconf_port *cport;", "", "PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);", "", "pj_mutex_lock(vid_conf->mutex);", "", "", "cport = vid_conf->ports[slot];", "if (cport == NULL) {", "pj_mutex_unlock(vid_conf->mutex);", "return PJ_EINVAL;", "}", "", "", "while (cport->listener_cnt) {", "pjmedia_vid_conf_disconnect_port(vid_conf, slot,", "cport->listener_slots[0]);", "}", "", "", "while (cport->transmitter_cnt) {", "pjmedia_vid_conf_disconnect_port(vid_conf,", "cport->transmitter_slots[0], slot);", "}", "", "", "vid_conf->ports[slot] = NULL;", "--vid_conf->port_cnt;", "", "PJ_LOG(4,(THIS_FILE,\"Removed port %d (%.*s)\",", "slot, (int)cport->name.slen, cport->name.ptr));", "", "", "pj_pool_safe_release(&cport->pool);", "", "if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {", "pj_status_t status;", "", "", "status = pjmedia_clock_stop(vid_conf->clock);", "if (status != PJ_SUCCESS) {", "PJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));", "return status;", "}", "}", "", "pj_mutex_unlock(vid_conf->mutex);", "", "return PJ_SUCCESS;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" err_t verify_signed_hash(const struct RSA_public_key *k", "                          , u_char *s, unsigned int s_max_octets", "                          , u_char **psig", "                          , size_t hash_len", "                          , const u_char *sig_val, size_t sig_len)", " {", "     unsigned int padlen;", " ", "      ", "     {", " \tchunk_t temp_s;", " \tMP_INT c;", " ", " \tn_to_mpz(&c, sig_val, sig_len);", " \toswcrypto.mod_exp(&c, &c, &k->e, &k->n);", " ", " \ttemp_s = mpz_to_n(&c, sig_len);\t ", "         if(s_max_octets < sig_len) {", "             return \"2\"\"exponentiation failed; too many octets\";", "         }", " \tmemcpy(s, temp_s.ptr, sig_len);", " \tpfree(temp_s.ptr);", " \tmpz_clear(&c);", "     }", " ", "      ", "      ", "     padlen = sig_len - 3 - hash_len;", "      ", " ", "     DBG(DBG_CRYPT,", " \tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));", "     DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));", " ", "      ", "     if(s[0]    != 0x00", "        || s[1] != 0x01", "        || s[padlen+2] != 0x00) {", "  \treturn \"3\"\"SIG padding does not check out\";", "      }", "  ", "    s += padlen + 3;", "    (*psig) = s;", "      ", "     (*psig) = s + padlen + 3;", " ", "      ", "     {", "         const u_char *p;", "         size_t cnt_ffs = 0;", " ", "         for (p = s+2; p < s+padlen+2; p++)", "             if (*p == 0xFF)", "                 cnt_ffs ++;", " ", "         if (cnt_ffs != padlen)", "             return \"4\" \"invalid Padding String\";", "     }", "  ", "       ", "      return NULL;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["static Bool hevc_parse_vps_extension(HEVC_VPS *vps, GF_BitStream *bs)", "{", "u8 splitting_flag, vps_nuh_layer_id_present_flag, view_id_len;", "u32 i, j, num_scalability_types, num_add_olss, num_add_layer_set, num_indepentdent_layers, nb_bits, default_output_layer_idc = 0;", "u8 dimension_id_len[16], dim_bit_offset[16];", "u8                          NumLayerSets,                                           rep_format_idx_present_flag, ols_ids_to_ls_idx;", "u8 layer_set_idx_for_ols_minus1[MAX_LHVC_LAYERS];", "u8 nb_output_layers_in_output_layer_set[MAX_LHVC_LAYERS + 1];", "u8 ols_highest_output_layer_id[MAX_LHVC_LAYERS + 1];", "", "u32 k, d, r, p, iNuhLId, jNuhLId;", "u8 num_direct_ref_layers[64], num_pred_layers[64], num_layers_in_tree_partition[MAX_LHVC_LAYERS];", "u8 dependency_flag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS], id_pred_layers[64][MAX_LHVC_LAYERS];", "", "", "", "", "u8 layer_id_in_list_flag[64];", "Bool OutputLayerFlag[MAX_LHVC_LAYERS][MAX_LHVC_LAYERS];", "", "vps->vps_extension_found = 1;", "if ((vps->max_layers > 1) && vps->base_layer_internal_flag)", "hevc_profile_tier_level(bs, 0, vps->max_sub_layers - 1, &vps->ext_ptl[0], 0);", "", "splitting_flag = gf_bs_read_int_log(bs, 1, \"splitting_flag\");", "num_scalability_types = 0;", "for (i = 0; i < 16; i++) {", "vps->scalability_mask[i] = gf_bs_read_int_log_idx(bs, 1, \"scalability_mask\", i);", "num_scalability_types += vps->scalability_mask[i];", "}", "if (num_scalability_types >= 16) {", "num_scalability_types = 16;", "}", "dimension_id_len[0] = 0;", "for (i = 0; i < (num_scalability_types - splitting_flag); i++) {", "dimension_id_len[i] = 1 + gf_bs_read_int_log_idx(bs, 3, \"dimension_id_len_minus1\", i);", "}", "", "if (splitting_flag) {", "for (i = 0; i < num_scalability_types; i++) {", "dim_bit_offset[i] = 0;", "for (j = 0; j < i; j++)", "dim_bit_offset[i] += dimension_id_len[j];", "}", "dimension_id_len[num_scalability_types - 1] = 1 + (5 - dim_bit_offset[num_scalability_types - 1]);", "dim_bit_offset[num_scalability_types] = 6;", "}", "", "vps_nuh_layer_id_present_flag = gf_bs_read_int_log(bs, 1, \"vps_nuh_layer_id_present_flag\");", "vps->layer_id_in_nuh[0] = 0;", "vps->layer_id_in_vps[0] = 0;", "for (i = 1; i < vps->max_layers; i++) {", "if (vps_nuh_layer_id_present_flag) {", "vps->layer_id_in_nuh[i] = gf_bs_read_int_log_idx(bs, 6, \"layer_id_in_nuh\", i);", "}", "else {", "vps->layer_id_in_nuh[i] = i;", "}", "vps->layer_id_in_vps[vps->layer_id_in_nuh[i]] = i;", "", "if (!splitting_flag) {", "for (j = 0; j < num_scalability_types; j++) {", "vps->dimension_id[i][j] = gf_bs_read_int_log_idx2(bs, dimension_id_len[j], \"dimension_id\", i, j);", "}", "}", "}", "", "if (splitting_flag) {", "for (i = 0; i < vps->max_layers; i++)", "for (j = 0; j < num_scalability_types; j++)", "vps->dimension_id[i][j] = ((vps->layer_id_in_nuh[i] & ((1 << dim_bit_offset[j + 1]) - 1)) >> dim_bit_offset[j]);", "}", "else {", "for (j = 0; j < num_scalability_types; j++)", "vps->dimension_id[0][j] = 0;", "}", "", "view_id_len = gf_bs_read_int_log(bs, 4, \"view_id_len\");", "if (view_id_len > 0) {", "for (i = 0; i < lhvc_get_num_views(vps); i++) {", "gf_bs_read_int_log_idx(bs, view_id_len, \"view_id_val\", i);", "}", "}", "", "for (i = 1; i < vps->max_layers; i++) {", "for (j = 0; j < i; j++) {", "vps->direct_dependency_flag[i][j] = gf_bs_read_int_log_idx(bs, 1, \"direct_dependency_flag\", i);", "}", "}", "", "", "for (i = 0; i < MAX_LHVC_LAYERS; i++) {", "if (i >= vps->max_layers) break;", "for (j = 0; j < vps->max_layers; j++) {", "dependency_flag[i][j] = vps->direct_dependency_flag[i][j];", "for (k = 0; k < i; k++)", "if (vps->direct_dependency_flag[i][k] && vps->direct_dependency_flag[k][j])", "dependency_flag[i][j] = 1;", "}", "}", "", "for (i = 0; i < vps->max_layers; i++) {", "iNuhLId = vps->layer_id_in_nuh[i];", "d = r = p = 0;", "for (j = 0; j < vps->max_layers; j++) {", "jNuhLId = vps->layer_id_in_nuh[j];", "if (vps->direct_dependency_flag[i][j]) {", "", "d++;", "}", "if (dependency_flag[i][j]) {", "", "r++;", "}", "", "if (dependency_flag[j][i])", "id_pred_layers[iNuhLId][p++] = jNuhLId;", "}", "num_direct_ref_layers[iNuhLId] = d;", "", "num_pred_layers[iNuhLId] = p;", "}", "", "memset(layer_id_in_list_flag, 0, 64 * sizeof(u8));", "k = 0;", "for (i = 0; i < vps->max_layers; i++) {", "iNuhLId = vps->layer_id_in_nuh[i];", "if (!num_direct_ref_layers[iNuhLId]) {", "u32 h = 1;", "", "for (j = 0; j < num_pred_layers[iNuhLId]; j++) {", "u32 predLId = id_pred_layers[iNuhLId][j];", "if (!layer_id_in_list_flag[predLId]) {", "", "layer_id_in_list_flag[predLId] = 1;", "}", "}", "num_layers_in_tree_partition[k++] = h;", "}", "}", "num_indepentdent_layers = k;", "", "num_add_layer_set = 0;", "if (num_indepentdent_layers > 1)", "num_add_layer_set = gf_bs_read_ue_log(bs, \"num_add_layer_set\");", "", "for (i = 0; i < num_add_layer_set; i++)", "for (j = 1; j < num_indepentdent_layers; j++) {", "nb_bits = 1;", "while ((1 << nb_bits) < (num_layers_in_tree_partition[j] + 1))", "nb_bits++;", "gf_bs_read_int_log_idx2(bs, nb_bits, \"highest_layer_idx_plus1\", i, j);", "}", "", "", "if (gf_bs_read_int_log(bs, 1, \"vps_sub_layers_max_minus1_present_flag\")) {", "for (i = 0; i < vps->max_layers; i++) {", "gf_bs_read_int_log_idx(bs, 3, \"sub_layers_vps_max_minus1\", i);", "}", "}", "", "if (gf_bs_read_int_log(bs, 1, \"max_tid_ref_present_flag\")) {", "for (i = 0; i < (vps->max_layers - 1); i++) {", "for (j = i + 1; j < vps->max_layers; j++) {", "if (vps->direct_dependency_flag[j][i])", "gf_bs_read_int_log_idx2(bs, 3, \"max_tid_il_ref_pics_plus1\", i, j);", "}", "}", "}", "gf_bs_read_int_log(bs, 1, \"default_ref_layers_active_flag\");", "", "vps->num_profile_tier_level = 1 + gf_bs_read_ue_log(bs, \"num_profile_tier_level\");", "if (vps->num_profile_tier_level > MAX_LHVC_LAYERS) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of PTLs in VPS %d\\n\", vps->num_profile_tier_level));", "vps->num_profile_tier_level = 1;", "return GF_FALSE;", "}", "", "for (i = vps->base_layer_internal_flag ? 2 : 1; i < vps->num_profile_tier_level; i++) {", "Bool vps_profile_present_flag = gf_bs_read_int_log_idx(bs, 1, \"vps_profile_present_flag\", i);", "hevc_profile_tier_level(bs, vps_profile_present_flag, vps->max_sub_layers - 1, &vps->ext_ptl[i - 1], i-1);", "}", "", "NumLayerSets = vps->num_layer_sets + num_add_layer_set;", "num_add_olss = 0;", "", "if (NumLayerSets > 1) {", "num_add_olss = gf_bs_read_ue_log(bs, \"num_add_olss\");", "default_output_layer_idc = gf_bs_read_int_log(bs, 2, \"default_output_layer_idc\");", "default_output_layer_idc = default_output_layer_idc < 2 ? default_output_layer_idc : 2;", "}", "vps->num_output_layer_sets = num_add_olss + NumLayerSets;", "", "", "layer_set_idx_for_ols_minus1[0] = 1;", "vps->output_layer_flag[0][0] = 1;", "", "for (i = 0; i < vps->num_output_layer_sets; i++) {", "if ((NumLayerSets > 2) && (i >= NumLayerSets)) {", "nb_bits = 1;", "while ((1 << nb_bits) < (NumLayerSets - 1))", "nb_bits++;", "layer_set_idx_for_ols_minus1[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"layer_set_idx_for_ols_minus1\", i);", "}", "else", "layer_set_idx_for_ols_minus1[i] = 0;", "ols_ids_to_ls_idx = i < NumLayerSets ? i : layer_set_idx_for_ols_minus1[i] + 1;", "", "if ((i > (vps->num_layer_sets - 1)) || (default_output_layer_idc == 2)) {", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)", "vps->output_layer_flag[i][j] = gf_bs_read_int_log_idx2(bs, 1, \"output_layer_flag\", i, j);", "}", "", "if ((default_output_layer_idc == 0) || (default_output_layer_idc == 1)) {", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if ((default_output_layer_idc == 0) || (vps->LayerSetLayerIdList[i][j] == vps->LayerSetLayerIdListMax[i]))", "OutputLayerFlag[i][j] = GF_TRUE;", "else", "OutputLayerFlag[i][j] = GF_FALSE;", "}", "}", "", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if (OutputLayerFlag[i][j]) {", "u32 curLayerID;", "vps->necessary_layers_flag[i][j] = GF_TRUE;", "curLayerID = vps->LayerSetLayerIdList[i][j];", "for (k = 0; k < j; k++) {", "u32 refLayerId = vps->LayerSetLayerIdList[i][k];", "if (dependency_flag[vps->layer_id_in_vps[curLayerID]][vps->layer_id_in_vps[refLayerId]])", "vps->necessary_layers_flag[i][k] = GF_TRUE;", "}", "}", "}", "vps->num_necessary_layers[i] = 0;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "if (vps->necessary_layers_flag[i][j])", "vps->num_necessary_layers[i] += 1;", "}", "", "if (i == 0) {", "if (vps->base_layer_internal_flag) {", "if (vps->max_layers > 1)", "vps->profile_tier_level_idx[0][0] = 1;", "else", "vps->profile_tier_level_idx[0][0] = 0;", "}", "continue;", "}", "nb_bits = 1;", "while ((u32)(1 << nb_bits) < vps->num_profile_tier_level)", "nb_bits++;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++)", "if (vps->necessary_layers_flag[i][j] && vps->num_profile_tier_level)", "vps->profile_tier_level_idx[i][j] = gf_bs_read_int_log_idx2(bs, nb_bits, \"profile_tier_level_idx\", i, j);", "else", "vps->profile_tier_level_idx[i][j] = 0;", "", "", "nb_output_layers_in_output_layer_set[i] = 0;", "for (j = 0; j < vps->num_layers_in_id_list[ols_ids_to_ls_idx]; j++) {", "nb_output_layers_in_output_layer_set[i] += OutputLayerFlag[i][j];", "if (OutputLayerFlag[i][j]) {", "ols_highest_output_layer_id[i] = vps->LayerSetLayerIdList[ols_ids_to_ls_idx][j];", "}", "}", "if (nb_output_layers_in_output_layer_set[i] == 1 && ols_highest_output_layer_id[i] > 0)", "vps->alt_output_layer_flag[i] = gf_bs_read_int_log_idx(bs, 1, \"alt_output_layer_flag\", i);", "}", "", "vps->num_rep_formats = 1 + gf_bs_read_ue_log(bs, \"num_rep_formats_minus1\");", "if (vps->num_rep_formats > 16) {", "GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[HEVC] Wrong number of rep formats in VPS %d\\n\", vps->num_rep_formats));", "vps->num_rep_formats = 0;", "return GF_FALSE;", "}", "", "for (i = 0; i < vps->num_rep_formats; i++) {", "lhvc_parse_rep_format(&vps->rep_formats[i], bs, i);", "}", "if (vps->num_rep_formats > 1)", "rep_format_idx_present_flag = gf_bs_read_int_log(bs, 1, \"rep_format_idx_present_flag\");", "else", "rep_format_idx_present_flag = 0;", "", "vps->rep_format_idx[0] = 0;", "nb_bits = 1;", "while ((u32)(1 << nb_bits) < vps->num_rep_formats)", "nb_bits++;", "for (i = vps->base_layer_internal_flag ? 1 : 0; i < vps->max_layers; i++) {", "if (rep_format_idx_present_flag) {", "vps->rep_format_idx[i] = gf_bs_read_int_log_idx(bs, nb_bits, \"rep_format_idx\", i);", "}", "else {", "vps->rep_format_idx[i] = i < vps->num_rep_formats - 1 ? i : vps->num_rep_formats - 1;", "}", "}", "", "", "return GF_TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" xsltResolveSASCallback(xsltAttrElemPtr values, xsltStylesheetPtr style,", " xsltResolveSASCallbackInt(xsltAttrElemPtr values, xsltStylesheetPtr style,", "  \t               const xmlChar *name, const xmlChar *ns,", "\t\t       ATTRIBUTE_UNUSED const xmlChar *ignored) {", " \t\t       int depth) {", "      xsltAttrElemPtr tmp;", "      xsltAttrElemPtr refs;", "  ", "      tmp = values;", "     if ((name == NULL) || (name[0] == 0))", "         return;", "     if (depth > 100) {", " \txsltGenericError(xsltGenericErrorContext,", " \t\"xsl:attribute-set : use-attribute-sets recursion detected on %s\\n\",", " \t\t\t name);", " \treturn;", "     }", "      while (tmp != NULL) {", "  \tif (tmp->set != NULL) {", "  \t     ", " \t    if ((xmlStrEqual(name, tmp->set)) && (xmlStrEqual(ns, tmp->ns))) {", " \t\txsltGenericError(xsltGenericErrorContext,", "      \"xsl:attribute-set : use-attribute-sets recursion detected on %s\\n\",", "                                  name);", " \t    } else {", " #ifdef WITH_XSLT_DEBUG_ATTRIBUTES", " \t\txsltGenericDebug(xsltGenericDebugContext,", " \t\t\t\"Importing attribute list %s\\n\", tmp->set);", " #endif", " ", " \t\trefs = xsltGetSAS(style, tmp->set, tmp->ns);", " \t\tif (refs == NULL) {", " \t\t    xsltGenericError(xsltGenericErrorContext,", "      \"xsl:attribute-set : use-attribute-sets %s reference missing %s\\n\",", " \t\t\t\t     name, tmp->set);", " \t\t} else {", "  \t\t     ", "\t\t    xsltResolveSASCallback(refs, style, name, ns, NULL);", " \t\t    xsltResolveSASCallbackInt(refs, style, name, ns, depth + 1);", "  \t\t     ", " \t\t    xsltMergeAttrElemList(style, values, refs);", " \t\t     ", " \t\t    tmp->set = NULL;", " \t\t    tmp->ns = NULL;", " \t\t}", " \t    }", " \t}", " \ttmp = tmp->next;", "      }", "  }"], "ner_tags": [0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)", " {", "     if (!g_teredo_enabled)", "         return TM_ECODE_FAILED;", " ", "     uint8_t *start = pkt;", " ", "      ", "     if (len < IPV6_HEADER_LEN)", "         return TM_ECODE_FAILED;", " ", "      ", "     if (start[0] == 0x0) {", "         switch (start[1]) {", "              ", "             case 0x0:", "                  ", "                 if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)", "                     start += TEREDO_ORIG_INDICATION_LENGTH;", "                 else", "                     return TM_ECODE_FAILED;", "                 break;", "              ", "             case 0x1:", "                 return TM_ECODE_FAILED;", "              ", "             default:", "                 return TM_ECODE_FAILED;", "         }", "     }", " ", "       ", "      if (IP_GET_RAW_VER(start) == 6) {", "          IPV6Hdr *thdr = (IPV6Hdr *)start;", " ", "          ", "         if (IPV6_GET_RAW_HLIM(thdr) == 0)", "             return TM_ECODE_FAILED;", " ", "          ", "         if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)", "             return TM_ECODE_FAILED;", " ", "          if (len ==  IPV6_HEADER_LEN +", "                  IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {", "              if (pq != NULL) {", "                  int blen = len - (start - pkt);", "                   ", "                  Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,", "                                                  DECODE_TUNNEL_IPV6, pq);", "                                                   DECODE_TUNNEL_IPV6_TEREDO, pq);", "                  if (tp != NULL) {", "                      PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);", "                       ", "                     PacketEnqueue(pq,tp);", "                     StatsIncr(tv, dtv->counter_teredo);", "                     return TM_ECODE_OK;", "                 }", "             }", "         }", "         return TM_ECODE_FAILED;", "     }", " ", "     return TM_ECODE_FAILED;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)", "  {", "      if (m_errorCallback)", "        m_errorCallback->handleEvent(error);", "         m_errorCallback->handleEvent(error, m_owner.get());", "  ", "      clear();", "  }"], "ner_tags": [0, 0, 0, 1, 1, 0, 0, 0]}
{"tokens": [" SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)", " {", " \tstruct fs_struct *fs, *new_fs = NULL;", " \tstruct files_struct *fd, *new_fd = NULL;", " \tstruct cred *new_cred = NULL;", " \tstruct nsproxy *new_nsproxy = NULL;", " \tint do_sysvsem = 0;", " \tint err;", " ", " \t ", "  \tif (unshare_flags & CLONE_NEWUSER)", "\t\tunshare_flags |= CLONE_THREAD;", " \t\tunshare_flags |= CLONE_THREAD | CLONE_FS;", "  \t ", " \tif (unshare_flags & CLONE_NEWPID)", " \t\tunshare_flags |= CLONE_THREAD;", " \t ", " \tif (unshare_flags & CLONE_THREAD)", " \t\tunshare_flags |= CLONE_VM;", " \t ", " \tif (unshare_flags & CLONE_VM)", " \t\tunshare_flags |= CLONE_SIGHAND;", " \t ", " \tif (unshare_flags & CLONE_NEWNS)", " \t\tunshare_flags |= CLONE_FS;", " ", " \terr = check_unshare_flags(unshare_flags);", " \tif (err)", " \t\tgoto bad_unshare_out;", " \t ", " \tif (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))", " \t\tdo_sysvsem = 1;", " \terr = unshare_fs(unshare_flags, &new_fs);", " \tif (err)", " \t\tgoto bad_unshare_out;", " \terr = unshare_fd(unshare_flags, &new_fd);", " \tif (err)", " \t\tgoto bad_unshare_cleanup_fs;", " \terr = unshare_userns(unshare_flags, &new_cred);", " \tif (err)", " \t\tgoto bad_unshare_cleanup_fd;", " \terr = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,", " \t\t\t\t\t new_cred, new_fs);", " \tif (err)", " \t\tgoto bad_unshare_cleanup_cred;", " ", " \tif (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {", " \t\tif (do_sysvsem) {", " \t\t\t ", " \t\t\texit_sem(current);", " \t\t}", " ", " \t\tif (new_nsproxy)", " \t\t\tswitch_task_namespaces(current, new_nsproxy);", " ", " \t\ttask_lock(current);", " ", " \t\tif (new_fs) {", " \t\t\tfs = current->fs;", " \t\t\tspin_lock(&fs->lock);", " \t\t\tcurrent->fs = new_fs;", " \t\t\tif (--fs->users)", " \t\t\t\tnew_fs = NULL;", " \t\t\telse", " \t\t\t\tnew_fs = fs;", " \t\t\tspin_unlock(&fs->lock);", " \t\t}", " ", " \t\tif (new_fd) {", " \t\t\tfd = current->files;", " \t\t\tcurrent->files = new_fd;", " \t\t\tnew_fd = fd;", " \t\t}", " ", " \t\ttask_unlock(current);", " ", " \t\tif (new_cred) {", " \t\t\t ", " \t\t\tcommit_creds(new_cred);", " \t\t\tnew_cred = NULL;", " \t\t}", " \t}", " ", " bad_unshare_cleanup_cred:", " \tif (new_cred)", " \t\tput_cred(new_cred);", " bad_unshare_cleanup_fd:", " \tif (new_fd)", " \t\tput_files_struct(new_fd);", " ", " bad_unshare_cleanup_fs:", " \tif (new_fs)", " \t\tfree_fs_struct(new_fs);", " ", " bad_unshare_out:", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int __f2fs_set_acl(struct inode *inode, int type,", " \t\t\tstruct posix_acl *acl, struct page *ipage)", " {", " \tint name_index;", " \tvoid *value = NULL;", " \tsize_t size = 0;", " \tint error;", " ", " \tswitch (type) {", "  \tcase ACL_TYPE_ACCESS:", "  \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;", "  \t\tif (acl) {", "\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);", "\t\t\tif (error < 0)", " \t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);", " \t\t\tif (error)", "  \t\t\t\treturn error;", "  \t\t\tset_acl_inode(inode, inode->i_mode);", "\t\t\tif (error == 0)", "\t\t\t\tacl = NULL;", "  \t\t}", "  \t\tbreak;", "  ", " \tcase ACL_TYPE_DEFAULT:", " \t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;", " \t\tif (!S_ISDIR(inode->i_mode))", " \t\t\treturn acl ? -EACCES : 0;", " \t\tbreak;", " ", " \tdefault:", " \t\treturn -EINVAL;", " \t}", " ", " \tif (acl) {", " \t\tvalue = f2fs_acl_to_disk(acl, &size);", " \t\tif (IS_ERR(value)) {", " \t\t\tclear_inode_flag(inode, FI_ACL_MODE);", " \t\t\treturn (int)PTR_ERR(value);", " \t\t}", " \t}", " ", " \terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);", " ", " \tkfree(value);", " \tif (!error)", " \t\tset_cached_acl(inode, type, acl);", " ", " \tclear_inode_flag(inode, FI_ACL_MODE);", " \treturn error;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["void ModuleSQL::init()", "{", "Dispatcher = new DispatcherThread(this);", "ServerInstance->Threads.Start(Dispatcher);", "}"], "ner_tags": [0, 0, 1, 0, 0]}
{"tokens": ["  struct bpf_map *bpf_map_get_with_uref(u32 ufd)", " {", " \tstruct fd f = fdget(ufd);", " \tstruct bpf_map *map;", " ", " \tmap = __bpf_map_get(f);", "  \tif (IS_ERR(map))", "  \t\treturn map;", "  ", "\tbpf_map_inc(map, true);", " \tmap = bpf_map_inc(map, true);", "  \tfdput(f);", "  ", "  \treturn map;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["void Compute(OpKernelContext* ctx) override {", "const Tensor& handle = ctx->input(0);", "const string& name = handle.scalar<tstring>()();", "auto session_state = ctx->session_state();", "OP_REQUIRES(ctx, session_state != nullptr,", "errors::FailedPrecondition(", "\"DeleteSessionTensor called on null session state\"));", "OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));", "}"], "ner_tags": [0, 0, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void GpuProcessHost::EstablishChannelError(", "     const EstablishChannelCallback& callback,", "      const IPC::ChannelHandle& channel_handle,", "      base::ProcessHandle renderer_process_for_gpu,", "      const content::GPUInfo& gpu_info) {", "  callback.Run(channel_handle, renderer_process_for_gpu, gpu_info);", "   callback.Run(channel_handle, gpu_info);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": [" int hugetlb_reserve_pages(struct inode *inode,", " \t\t\t\t\tlong from, long to,", " \t\t\t\t\tstruct vm_area_struct *vma,", " \t\t\t\t\tvm_flags_t vm_flags)", "  {", "  \tlong ret, chg;", "  \tstruct hstate *h = hstate_inode(inode);", " \tstruct hugepage_subpool *spool = subpool_inode(inode);", "  ", "  \t ", "  \tif (vm_flags & VM_NORESERVE)", "  \t\treturn 0;", " ", " \t ", " \tif (!vma || vma->vm_flags & VM_MAYSHARE)", " \t\tchg = region_chg(&inode->i_mapping->private_list, from, to);", " \telse {", " \t\tstruct resv_map *resv_map = resv_map_alloc();", " \t\tif (!resv_map)", " \t\t\treturn -ENOMEM;", " ", " \t\tchg = to - from;", " ", " \t\tset_vma_resv_map(vma, resv_map);", " \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);", " \t}", " ", "  \tif (chg < 0)", "  \t\treturn chg;", "  ", " \t ", "\tif (hugetlb_get_quota(inode->i_mapping, chg))", " \tif (hugepage_subpool_get_pages(spool, chg))", "  \t\treturn -ENOSPC;", "  ", "  \t ", "  \tret = hugetlb_acct_memory(h, chg);", "  \tif (ret < 0) {", "\t\thugetlb_put_quota(inode->i_mapping, chg);", " \t\thugepage_subpool_put_pages(spool, chg);", "  \t\treturn ret;", "  \t}", "  ", " \t ", " \tif (!vma || vma->vm_flags & VM_MAYSHARE)", " \t\tregion_add(&inode->i_mapping->private_list, from, to);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)", " {", "  stream_t *ps_stream;", " ", "      ps_stream = &ps_dec->s_bit_stream;", "      impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);", "  ", "    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)", "        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))", "     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&", "             (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))", "      {", "  ", "          if (impeg2d_bit_stream_get(ps_stream,8) != 0)", "  {", "   ", "  }", " ", "  }", "  return;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  MediaStreamDispatcherHost::MediaStreamDispatcherHost(", "      int render_process_id,", "      int render_frame_id,", "      MediaStreamManager* media_stream_manager)", "      : render_process_id_(render_process_id),", "        render_frame_id_(render_frame_id),", "       requester_id_(next_requester_id_++),", "        media_stream_manager_(media_stream_manager),", "        salt_and_origin_callback_(", "            base::BindRepeating(&GetMediaDeviceSaltAndOrigin)),", "        weak_factory_(this) {", "    DCHECK_CURRENTLY_ON(BrowserThread::IO);", "  bindings_.set_connection_error_handler(", "      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,", "                 weak_factory_.GetWeakPtr()));", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0]}
{"tokens": [" static void destroy_super(struct super_block *s)", " {", "  \tint i;", "  \tlist_lru_destroy(&s->s_dentry_lru);", "  \tlist_lru_destroy(&s->s_inode_lru);", "#ifdef CONFIG_SMP", "\tfree_percpu(s->s_files);", "#endif", "  \tfor (i = 0; i < SB_FREEZE_LEVELS; i++)", "  \t\tpercpu_counter_destroy(&s->s_writers.counter[i]);", "  \tsecurity_sb_free(s);", " \tWARN_ON(!list_empty(&s->s_mounts));", " \tkfree(s->s_subtype);", " \tkfree(s->s_options);", " \tkfree_rcu(s, rcu);", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void Sp_search(js_State *J)", " {", " \tjs_Regexp *re;", " \tconst char *text;", " \tResub m;", " ", " \ttext = checkstring(J, 0);", " ", " \tif (js_isregexp(J, 1))", " \t\tjs_copy(J, 1);", " \telse if (js_isundefined(J, 1))", " \t\tjs_newregexp(J, \"\", 0);", " \telse", " \t\tjs_newregexp(J, js_tostring(J, 1), 0);", "  ", "  \tre = js_toregexp(J, -1);", "  ", "\tif (!js_regexec(re->prog, text, &m, 0))", " \tif (!js_doregexec(J, re->prog, text, &m, 0))", "  \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));", "  \telse", "  \t\tjs_pushnumber(J, -1);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]}
{"tokens": ["mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,", "struct devlink_fmsg *fmsg, void *priv_ctx)", "{", "struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);", "u32 crdump_size = dev->priv.health.crdump_size;", "u32 *cr_data;", "u32 data_size;", "u32 offset;", "int err;", "", "if (!mlx5_core_is_pf(dev))", "return -EPERM;", "", "cr_data = kvmalloc(crdump_size, GFP_KERNEL);", "if (!cr_data)", "return -ENOMEM;", "err = mlx5_crdump_collect(dev, cr_data);", "if (err)", "return err;", "", "if (priv_ctx) {", "struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;", "", "err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);", "if (err)", "goto free_data;", "}", "", "err = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");", "if (err)", "goto free_data;", "for (offset = 0; offset < crdump_size; offset += data_size) {", "if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)", "data_size = crdump_size - offset;", "else", "data_size = MLX5_CR_DUMP_CHUNK_SIZE;", "err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,", "data_size);", "if (err)", "goto free_data;", "}", "err = devlink_fmsg_arr_pair_nest_end(fmsg);", "", "free_data:", "kvfree(cr_data);", "return err;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  static void sycc420_to_rgb(opj_image_t *img)", "  {", "  \tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;", "  \tconst int *y, *cb, *cr, *ny;", "\tunsigned int maxw, maxh, max;", " \tsize_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;", "  \tint offset, upb;", "\tunsigned int i, j;", " \tsize_t i;", "  ", "  \tupb = (int)img->comps[0].prec;", "  \toffset = 1<<(upb - 1); upb = (1<<upb)-1;", "  ", "\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;", " \tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;", "  \tmax = maxw * maxh;", "  ", "  \ty = img->comps[0].data;", "  \tcb = img->comps[1].data;", "  \tcr = img->comps[2].data;", "  ", "\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);", "\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);", "\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);", "\tif(r == NULL || g == NULL || b == NULL) goto fails;", " \td0 = r = (int*)malloc(sizeof(int) * max);", " \td1 = g = (int*)malloc(sizeof(int) * max);", " \td2 = b = (int*)malloc(sizeof(int) * max);", " \t", " \tif (r == NULL || g == NULL || b == NULL) goto fails;", " \t", " \t ", " \toffx = img->x0 & 1U;", " \tloopmaxw = maxw - offx;", " \t ", " \toffy = img->y0 & 1U;", " \tloopmaxh = maxh - offy;", " \t", " \tif (offy > 0U) {", " \t\tsize_t j;", " \t\t", " \t\tfor(j=0; j < maxw; ++j)", " \t\t{", " \t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);", " \t\t\t++y; ++r; ++g; ++b;", " \t\t}", " \t}", "  ", "\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)", " \tfor(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)", "  \t{", " \t\tsize_t j;", " \t\t", "  \t\tny = y + maxw;", "  \t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;", " \t\t", " \t\tif (offx > 0U) {", " \t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);", " \t\t\t++y; ++r; ++g; ++b;", " \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);", " \t\t\t++ny; ++nr; ++ng; ++nb;", " \t\t}", "  ", "\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)", " \t\tfor(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)", "  \t\t{", "  \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", "  \t\t\t++y; ++r; ++g; ++b;", " \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", " \t\t\t++y; ++r; ++g; ++b;", " ", " \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);", " \t\t\t++ny; ++nr; ++ng; ++nb;", "  \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);", "  \t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;", "  \t\t}", "\t\tif(j < maxw)", " \t\tif(j < loopmaxw)", "  \t\t{", "  \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", "  \t\t\t++y; ++r; ++g; ++b;", " ", " \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);", " \t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;", "  \t\t}", "  \t\ty += maxw; r += maxw; g += maxw; b += maxw;", "  \t}", "\tif(i < maxh)", " \tif(i < loopmaxh)", "  \t{", "\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)", " \t\tsize_t j;", " \t\t", " \t\tfor(j=0U; j < (maxw & ~(size_t)1U); j += 2U)", "  \t\t{", "  \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", "  ", " \t\t\t++y; ++r; ++g; ++b;", " ", " \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", " ", " \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;", " \t\t}", " \t\tif(j < maxw)", " \t\t{", " \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);", " \t\t}", " \t}", " ", " \tfree(img->comps[0].data); img->comps[0].data = d0;", "  \tfree(img->comps[1].data); img->comps[1].data = d1;", "  \tfree(img->comps[2].data); img->comps[2].data = d2;", "  ", "#if defined(USE_JPWL) || defined(USE_MJ2)", "\timg->comps[1].w = maxw; img->comps[1].h = maxh;", "\timg->comps[2].w = maxw; img->comps[2].h = maxh;", "#else", "\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;", "\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;", "#endif", "\timg->comps[1].dx = img->comps[0].dx;", "\timg->comps[2].dx = img->comps[0].dx;", "\timg->comps[1].dy = img->comps[0].dy;", "\timg->comps[2].dy = img->comps[0].dy;", " \timg->comps[1].w = img->comps[2].w = img->comps[0].w;", " \timg->comps[1].h = img->comps[2].h = img->comps[0].h;", " \timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;", " \timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;", " \timg->color_space = OPJ_CLRSPC_SRGB;", "  \treturn;", "  ", "  fails:", "\tif(r) free(r);", "\tif(g) free(g);", "\tif(b) free(b);", " \tfree(r);", " \tfree(g);", " \tfree(b);", "  } "], "ner_tags": [0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": [" int tcp_disconnect(struct sock *sk, int flags)", " {", " \tstruct inet_sock *inet = inet_sk(sk);", " \tstruct inet_connection_sock *icsk = inet_csk(sk);", " \tstruct tcp_sock *tp = tcp_sk(sk);", " \tint err = 0;", " \tint old_state = sk->sk_state;", " ", " \tif (old_state != TCP_CLOSE)", " \t\ttcp_set_state(sk, TCP_CLOSE);", " ", " \t ", " \tif (old_state == TCP_LISTEN) {", " \t\tinet_csk_listen_stop(sk);", " \t} else if (unlikely(tp->repair)) {", " \t\tsk->sk_err = ECONNABORTED;", " \t} else if (tcp_need_reset(old_state) ||", " \t\t   (tp->snd_nxt != tp->write_seq &&", " \t\t    (1 << old_state) & (TCPF_CLOSING | TCPF_LAST_ACK))) {", " \t\t ", " \t\ttcp_send_active_reset(sk, gfp_any());", " \t\tsk->sk_err = ECONNRESET;", " \t} else if (old_state == TCP_SYN_SENT)", " \t\tsk->sk_err = ECONNRESET;", " ", " \ttcp_clear_xmit_timers(sk);", " \t__skb_queue_purge(&sk->sk_receive_queue);", " \ttcp_write_queue_purge(sk);", " \ttcp_fastopen_active_disable_ofo_check(sk);", " \tskb_rbtree_purge(&tp->out_of_order_queue);", " ", " \tinet->inet_dport = 0;", " ", " \tif (!(sk->sk_userlocks & SOCK_BINDADDR_LOCK))", " \t\tinet_reset_saddr(sk);", " ", " \tsk->sk_shutdown = 0;", " \tsock_reset_flag(sk, SOCK_DONE);", " \ttp->srtt_us = 0;", " \ttp->write_seq += tp->max_window + 2;", " \tif (tp->write_seq == 0)", " \t\ttp->write_seq = 1;", " \ticsk->icsk_backoff = 0;", " \ttp->snd_cwnd = 2;", " \ticsk->icsk_probes_out = 0;", " \ttp->packets_out = 0;", " \ttp->snd_ssthresh = TCP_INFINITE_SSTHRESH;", " \ttp->snd_cwnd_cnt = 0;", " \ttp->window_clamp = 0;", "  \ttcp_set_ca_state(sk, TCP_CA_Open);", "  \ttcp_clear_retrans(tp);", "  \tinet_csk_delack_init(sk);", " \t ", " \ticsk->icsk_ack.rcv_mss = TCP_MIN_MSS;", "  \ttcp_init_send_head(sk);", "  \tmemset(&tp->rx_opt, 0, sizeof(tp->rx_opt));", "  \t__sk_dst_reset(sk);", " \ttcp_saved_syn_free(tp);", " ", " \t ", " \ttcp_free_fastopen_req(tp);", " \tinet->defer_connect = 0;", " ", " \tWARN_ON(inet->inet_num && !icsk->icsk_bind_hash);", " ", " \tsk->sk_error_report(sk);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" status_t MPEG4Source::fragmentedRead(", "  MediaBuffer **out, const ReadOptions *options) {", " ", "     ALOGV(\"MPEG4Source::fragmentedRead\");", " ", "     CHECK(mStarted);", " ", "  *out = NULL;", " ", "  int64_t targetSampleTimeUs = -1;", " ", "  int64_t seekTimeUs;", "  ReadOptions::SeekMode mode;", "  if (options && options->getSeekTo(&seekTimeUs, &mode)) {", " ", "  int numSidxEntries = mSegments.size();", "  if (numSidxEntries != 0) {", "  int64_t totalTime = 0;", "  off64_t totalOffset = mFirstMoofOffset;", "  for (int i = 0; i < numSidxEntries; i++) {", "  const SidxEntry *se = &mSegments[i];", "  if (totalTime + se->mDurationUs > seekTimeUs) {", "  if ((mode == ReadOptions::SEEK_NEXT_SYNC && seekTimeUs > totalTime) ||", "  (mode == ReadOptions::SEEK_CLOSEST_SYNC &&", "  (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) {", "                         totalTime += se->mDurationUs;", "                         totalOffset += se->mSize;", "  }", "  break;", "  }", "                 totalTime += se->mDurationUs;", "                 totalOffset += se->mSize;", "  }", "             mCurrentMoofOffset = totalOffset;", "             mCurrentSamples.clear();", "             mCurrentSampleIndex = 0;", "             parseChunk(&totalOffset);", "             mCurrentTime = totalTime * mTimescale / 1000000ll;", "  } else {", "             mCurrentMoofOffset = mFirstMoofOffset;", "             mCurrentSamples.clear();", "             mCurrentSampleIndex = 0;", "  off64_t tmp = mCurrentMoofOffset;", "             parseChunk(&tmp);", "             mCurrentTime = 0;", "  }", " ", "  if (mBuffer != NULL) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  }", " ", "  off64_t offset = 0;", "  size_t size = 0;", "  uint32_t cts = 0;", "  bool isSyncSample = false;", "  bool newBuffer = false;", "  if (mBuffer == NULL) {", "         newBuffer = true;", " ", "  if (mCurrentSampleIndex >= mCurrentSamples.size()) {", "  if (mNextMoofOffset <= mCurrentMoofOffset) {", "  return ERROR_END_OF_STREAM;", "  }", "  off64_t nextMoof = mNextMoofOffset;", "             mCurrentMoofOffset = nextMoof;", "             mCurrentSamples.clear();", "             mCurrentSampleIndex = 0;", "             parseChunk(&nextMoof);", "  if (mCurrentSampleIndex >= mCurrentSamples.size()) {", "  return ERROR_END_OF_STREAM;", "  }", "  }", " ", "  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];", "         offset = smpl->offset;", "         size = smpl->size;", "         cts = mCurrentTime + smpl->compositionOffset;", "         mCurrentTime += smpl->duration;", "         isSyncSample = (mCurrentSampleIndex == 0);  ", " ", "  status_t err = mGroup->acquire_buffer(&mBuffer);", " ", "  if (err != OK) {", "             CHECK(mBuffer == NULL);", "             ALOGV(\"acquire_buffer returned %d\", err);", "  return err;", "  }", "  }", " ", "  const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];", "  const sp<MetaData> bufmeta = mBuffer->meta_data();", "     bufmeta->clear();", "  if (smpl->encryptedsizes.size()) {", "         bufmeta->setData(kKeyPlainSizes, 0,", "                 smpl->clearsizes.array(), smpl->clearsizes.size() * 4);", "         bufmeta->setData(kKeyEncryptedSizes, 0,", "                 smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4);", "         bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16);  ", "         bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize);", "         bufmeta->setInt32(kKeyCryptoMode, mCryptoMode);", "         bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16);", "  }", " ", "  if ((!mIsAVC && !mIsHEVC)|| mWantsNALFragments) {", "  if (newBuffer) {", "  ssize_t num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);", " ", "  if (num_bytes_read < (ssize_t)size) {", "                 mBuffer->release();", "                 mBuffer = NULL;", " ", "                 ALOGV(\"i/o error\");", "  return ERROR_IO;", "  }", " ", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", "             mBuffer->meta_data()->setInt64(", "                     kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "             mBuffer->meta_data()->setInt64(", "                     kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "                 mBuffer->meta_data()->setInt64(", "                         kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "                 mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", "  }", " ", "  if (!mIsAVC && !mIsHEVC) {", "  *out = mBuffer;", "             mBuffer = NULL;", " ", "  return OK;", "  }", " ", " ", "         CHECK(mBuffer->range_length() >= mNALLengthSize);", " ", "  const uint8_t *src =", "  (const uint8_t *)mBuffer->data() + mBuffer->range_offset();", " ", "  size_t nal_size = parseNALSize(src);", "  if (mBuffer->range_length() < mNALLengthSize + nal_size) {", "             ALOGE(\"incomplete NAL unit.\");", " ", "             mBuffer->release();", "             mBuffer = NULL;", " ", "  return ERROR_MALFORMED;", "  }", " ", "  MediaBuffer *clone = mBuffer->clone();", "         CHECK(clone != NULL);", "         clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size);", " ", "         CHECK(mBuffer != NULL);", "         mBuffer->set_range(", "                 mBuffer->range_offset() + mNALLengthSize + nal_size,", "                 mBuffer->range_length() - mNALLengthSize - nal_size);", " ", "  if (mBuffer->range_length() == 0) {", "             mBuffer->release();", "             mBuffer = NULL;", "  }", " ", "  *out = clone;", " ", "  return OK;", "  } else {", "         ALOGV(\"whole NAL\");", "  ssize_t num_bytes_read = 0;", "  int32_t drm = 0;", "  bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);", "  if (usesDRM) {", "             num_bytes_read =", "                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);", "  } else {", "             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);", "  }", " ", "  if (num_bytes_read < (ssize_t)size) {", "             mBuffer->release();", "             mBuffer = NULL;", " ", "             ALOGV(\"i/o error\");", "  return ERROR_IO;", "  }", " ", "  if (usesDRM) {", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, size);", " ", "  } else {", "  uint8_t *dstData = (uint8_t *)mBuffer->data();", "  size_t srcOffset = 0;", " ", "              size_t dstOffset = 0;", "  ", "              while (srcOffset < size) {", "                bool isMalFormed = (srcOffset + mNALLengthSize > size);", "                 bool isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);", "                  size_t nalLength = 0;", "                  if (!isMalFormed) {", "                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);", "                      srcOffset += mNALLengthSize;", "                    isMalFormed = srcOffset + nalLength > size;", "                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength);", "                  }", "  ", "                  if (isMalFormed) {", "                     ALOGE(\"Video is malformed\");", "                     mBuffer->release();", "                     mBuffer = NULL;", "  return ERROR_MALFORMED;", "  }", " ", "  if (nalLength == 0) {", "  continue;", "  }", " ", "                 CHECK(dstOffset + 4 <= mBuffer->size());", " ", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 0;", "                 dstData[dstOffset++] = 1;", "                 memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength);", "                 srcOffset += nalLength;", "                 dstOffset += nalLength;", "  }", "             CHECK_EQ(srcOffset, size);", "             CHECK(mBuffer != NULL);", "             mBuffer->set_range(0, dstOffset);", "  }", " ", "         mBuffer->meta_data()->setInt64(", "                 kKeyTime, ((int64_t)cts * 1000000) / mTimescale);", "         mBuffer->meta_data()->setInt64(", "                 kKeyDuration, ((int64_t)smpl->duration * 1000000) / mTimescale);", " ", "  if (targetSampleTimeUs >= 0) {", "             mBuffer->meta_data()->setInt64(", "                     kKeyTargetTime, targetSampleTimeUs);", "  }", " ", "  if (isSyncSample) {", "             mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1);", "  }", " ", "  ++mCurrentSampleIndex;", " ", "  *out = mBuffer;", "         mBuffer = NULL;", " ", "  return OK;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)", "  {", "      static generic_ret              ret;", "      char                            *prime_arg;", "    gss_buffer_desc                 client_name,", "        service_name;", "     gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;", "     gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;", "      OM_uint32                       minor_stat;", "      kadm5_server_handle_t           handle;", "      restriction_t                   *rp;", "     const char                      *errmsg = NULL;", " ", "     xdr_free(xdr_generic_ret, &ret);", " ", "     if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))", "         goto exit_func;", " ", "     if ((ret.code = check_handle((void *)handle)))", "         goto exit_func;", " ", "     if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {", "         ret.code = KADM5_FAILURE;", "         goto exit_func;", "     }", "     if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {", "         ret.code = KADM5_BAD_PRINCIPAL;", "         goto exit_func;", "     }", " ", "     if (CHANGEPW_SERVICE(rqstp)", "         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,", "                                arg->rec.principal, &rp)", "         || kadm5int_acl_impose_restrictions(handle->context,", "                                             &arg->rec, &arg->mask, rp)) {", "         ret.code = KADM5_AUTH_MODIFY;", "         log_unauth(\"kadm5_modify_principal\", prime_arg,", "                    &client_name, &service_name, rqstp);", "     } else {", "         ret.code = kadm5_modify_principal((void *)handle, &arg->rec,", "                                           arg->mask);", "         if( ret.code != 0 )", "             errmsg = krb5_get_error_message(handle->context, ret.code);", " ", "         log_done(\"kadm5_modify_principal\", prime_arg, errmsg,", "                  &client_name, &service_name, rqstp);", " ", "         if (errmsg != NULL)", "              krb5_free_error_message(handle->context, errmsg);", "      }", "      free(prime_arg);", " exit_func:", "      gss_release_buffer(&minor_stat, &client_name);", "      gss_release_buffer(&minor_stat, &service_name);", "exit_func:", "      free_server_handle(handle);", "      return &ret;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]}
{"tokens": [" static int do_remount(struct path *path, int flags, int mnt_flags,", " \t\t      void *data)", " {", " \tint err;", " \tstruct super_block *sb = path->mnt->mnt_sb;", " \tstruct mount *mnt = real_mount(path->mnt);", " ", " \tif (!check_mnt(mnt))", " \t\treturn -EINVAL;", " ", " \tif (path->dentry != path->mnt->mnt_root)", " \t\treturn -EINVAL;", " ", " \t ", " \tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&", "  \t    !(mnt_flags & MNT_READONLY)) {", "  \t\treturn -EPERM;", "  \t}", " \tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&", " \t    !(mnt_flags & MNT_NODEV)) {", " \t\treturn -EPERM;", " \t}", " \tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&", " \t    !(mnt_flags & MNT_NOSUID)) {", " \t\treturn -EPERM;", " \t}", " \tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&", " \t    !(mnt_flags & MNT_NOEXEC)) {", " \t\treturn -EPERM;", " \t}", " \tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&", " \t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {", " \t\treturn -EPERM;", " \t}", " ", "  \terr = security_sb_remount(sb, data);", "  \tif (err)", "  \t\treturn err;", " ", " \tdown_write(&sb->s_umount);", " \tif (flags & MS_BIND)", " \t\terr = change_mount_flags(path->mnt, flags);", " \telse if (!capable(CAP_SYS_ADMIN))", " \t\terr = -EPERM;", " \telse", " \t\terr = do_remount_sb(sb, flags, data, 0);", " \tif (!err) {", " \t\tlock_mount_hash();", " \t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;", " \t\tmnt->mnt.mnt_flags = mnt_flags;", " \t\ttouch_mnt_namespace(mnt->mnt_ns);", " \t\tunlock_mount_hash();", " \t}", " \tup_write(&sb->s_umount);", " \treturn err;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int main(int argc, char **argv) {", "  FILE *infile = NULL;", "  vpx_codec_ctx_t codec;", "  vpx_codec_enc_cfg_t cfg;", "  int frame_count = 0;", "  vpx_image_t raw;", "  vpx_codec_err_t res;", "  VpxVideoInfo info = {0};", "  VpxVideoWriter *writer = NULL;", "  const VpxInterface *encoder = NULL;", "  const int fps = 30;  ", "  const int bitrate = 200;  ", "  int keyframe_interval = 0;", " ", "  const char *codec_arg = NULL;", "  const char *width_arg = NULL;", "  const char *height_arg = NULL;", "  const char *infile_arg = NULL;", "  const char *outfile_arg = NULL;", "  const char *keyframe_interval_arg = NULL;", " ", "   exec_name = argv[0];", " ", "  if (argc < 7)", "     die(\"Invalid number of arguments\");", " ", "   codec_arg = argv[1];", "   width_arg = argv[2];", "   height_arg = argv[3];", "   infile_arg = argv[4];", "   outfile_arg = argv[5];", "   keyframe_interval_arg = argv[6];", " ", "   encoder = get_vpx_encoder_by_name(codec_arg);", "  if (!encoder)", "      die(\"Unsupported codec.\");", " ", "   info.codec_fourcc = encoder->fourcc;", "   info.frame_width = strtol(width_arg, NULL, 0);", "   info.frame_height = strtol(height_arg, NULL, 0);", "   info.time_base.numerator = 1;", "   info.time_base.denominator = fps;", " ", "  if (info.frame_width <= 0 ||", "       info.frame_height <= 0 ||", "  (info.frame_width % 2) != 0 ||", "  (info.frame_height % 2) != 0) {", "     die(\"Invalid frame size: %dx%d\", info.frame_width, info.frame_height);", "  }", " ", "  if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,", "                                              info.frame_height, 1)) {", "     die(\"Failed to allocate image.\");", "  }", " ", "   keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);", " ", "    if (keyframe_interval < 0)", "      die(\"Invalid keyframe interval value.\");", "  ", "  printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->interface()));", "   printf(\"Using %s\\n\", vpx_codec_iface_name(encoder->codec_interface()));", "  ", "  res = vpx_codec_enc_config_default(encoder->interface(), &cfg, 0);", "   res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);", "    if (res)", "      die_codec(&codec, \"Failed to get default codec config.\");", "  ", "   cfg.g_w = info.frame_width;", "   cfg.g_h = info.frame_height;", "   cfg.g_timebase.num = info.time_base.numerator;", "   cfg.g_timebase.den = info.time_base.denominator;", "   cfg.rc_target_bitrate = bitrate;", "   cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;", " ", "   writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);", "  if (!writer)", "     die(\"Failed to open %s for writing.\", outfile_arg);", " ", " ", "    if (!(infile = fopen(infile_arg, \"rb\")))", "      die(\"Failed to open %s for reading.\", infile_arg);", "  ", "  if (vpx_codec_enc_init(&codec, encoder->interface(), &cfg, 0))", "   if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))", "      die_codec(&codec, \"Failed to initialize encoder\");", "  ", "    ", "    while (vpx_img_read(&raw, infile)) {", "      int flags = 0;", "      if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)", "        flags |= VPX_EFLAG_FORCE_KF;", "      encode_frame(&codec, &raw, frame_count++, flags, writer);", "    }", "  encode_frame(&codec, NULL, -1, 0, writer);   ", " ", "    ", "   while (encode_frame(&codec, NULL, -1, 0, writer)) {};", "  ", "    printf(\"\\n\");", "    fclose(infile);", "   printf(\"Processed %d frames.\\n\", frame_count);", " ", "   vpx_img_free(&raw);", "  if (vpx_codec_destroy(&codec))", "     die_codec(&codec, \"Failed to destroy codec.\");", " ", "   vpx_video_writer_close(writer);", " ", "  return EXIT_SUCCESS;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)", "  {", "  \tint result;", "  \thandle_t *handle = NULL;", "\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;", " \tstruct inode *inode = file_inode(vma->vm_file);", " \tstruct super_block *sb = inode->i_sb;", "  \tbool write = vmf->flags & FAULT_FLAG_WRITE;", "  ", "  \tif (write) {", "  \t\tsb_start_pagefault(sb);", "  \t\tfile_update_time(vma->vm_file);", " \t\tdown_read(&EXT4_I(inode)->i_mmap_sem);", "  \t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,", "  \t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));", "\t}", " \t} else", " \t\tdown_read(&EXT4_I(inode)->i_mmap_sem);", "  ", "  \tif (IS_ERR(handle))", "  \t\tresult = VM_FAULT_SIGBUS;", " \telse", " \t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,", " \t\t\t\t\t\text4_end_io_unwritten);", " ", "  \tif (write) {", "  \t\tif (!IS_ERR(handle))", "  \t\t\text4_journal_stop(handle);", " \t\tup_read(&EXT4_I(inode)->i_mmap_sem);", "  \t\tsb_end_pagefault(sb);", "\t}", " \t} else", " \t\tup_read(&EXT4_I(inode)->i_mmap_sem);", "  ", "  \treturn result;", "  }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0]}
{"tokens": [" gss_export_sec_context(minor_status,", "                        context_handle,", "                        interprocess_token)", " ", " OM_uint32 *\t\tminor_status;", " gss_ctx_id_t *\t\tcontext_handle;", " gss_buffer_t\t\tinterprocess_token;", " ", " {", "     OM_uint32\t\tstatus;", "     OM_uint32 \t\tlength;", "     gss_union_ctx_id_t\tctx = NULL;", "     gss_mechanism\tmech;", "     gss_buffer_desc\ttoken = GSS_C_EMPTY_BUFFER;", "     char\t\t*buf;", " ", "     status = val_exp_sec_ctx_args(minor_status,", " \t\t\t\t  context_handle, interprocess_token);", "     if (status != GSS_S_COMPLETE)", " \treturn (status);", " ", "      ", "  ", "      ctx = (gss_union_ctx_id_t) *context_handle;", "     if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)", " \treturn (GSS_S_NO_CONTEXT);", "      mech = gssint_get_mechanism (ctx->mech_type);", "      if (!mech)", "  \treturn GSS_S_BAD_MECH;", "     if (!mech->gss_export_sec_context)", " \treturn (GSS_S_UNAVAILABLE);", " ", "     status = mech->gss_export_sec_context(minor_status,", " \t\t\t\t\t  &ctx->internal_ctx_id, &token);", "     if (status != GSS_S_COMPLETE) {", " \tmap_error(minor_status, mech);", " \tgoto cleanup;", "     }", " ", "     length = token.length + 4 + ctx->mech_type->length;", "     interprocess_token->length = length;", "     interprocess_token->value = malloc(length);", "     if (interprocess_token->value == 0) {", " \t*minor_status = ENOMEM;", " \tstatus = GSS_S_FAILURE;", " \tgoto cleanup;", "     }", "     buf = interprocess_token->value;", "     length = ctx->mech_type->length;", "     buf[3] = (unsigned char) (length & 0xFF);", "     length >>= 8;", "     buf[2] = (unsigned char) (length & 0xFF);", "     length >>= 8;", "     buf[1] = (unsigned char) (length & 0xFF);", "     length >>= 8;", "     buf[0] = (unsigned char) (length & 0xFF);", "     memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);", "     memcpy(buf+4+ctx->mech_type->length, token.value, token.length);", " ", "     status = GSS_S_COMPLETE;", " ", " cleanup:", "     (void) gss_release_buffer(minor_status, &token);", "     if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {", " \t ", " \tfree(ctx->mech_type->elements);", " \tfree(ctx->mech_type);", " \tfree(ctx);", " \t*context_handle = GSS_C_NO_CONTEXT;", "     }", "     return status;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["    virtual bool SetImeConfig(const std::string& section,", "                              const std::string& config_name,", "                            const ImeConfigValue& value) {", "                             const input_method::ImeConfigValue& value) {", "      return false;", "    }"], "ner_tags": [0, 0, 1, 1, 0, 0]}
{"tokens": [" void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,", "                                         const VisiblePosition& extent_position,", "                                         TextGranularity granularity) {", "   SelectionInDOMTree new_selection =", "       SelectionInDOMTree::Builder()", "            .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),", "                                        extent_position.DeepEquivalent())", "            .SetAffinity(base_position.Affinity())", "          .SetIsHandleVisible(IsHandleVisible())", "            .Build();", "  ", "    if (new_selection.IsNone())", "     return;", " ", "   const VisibleSelection& visible_selection =", "       CreateVisibleSelectionWithGranularity(new_selection, granularity);", "   if (visible_selection.IsNone())", "     return;", " ", "   SelectionInDOMTree::Builder builder;", "   if (visible_selection.IsBaseFirst()) {", "     builder.SetBaseAndExtent(visible_selection.Start(),", "                              visible_selection.End());", "   } else {", "     builder.SetBaseAndExtent(visible_selection.End(),", "                               visible_selection.Start());", "    }", "    builder.SetAffinity(visible_selection.Affinity());", "  builder.SetIsHandleVisible(IsHandleVisible());", "    SetSelection(builder.Build(), SetSelectionData::Builder()", "                                      .SetShouldCloseTyping(true)", "                                      .SetShouldClearTypingStyle(true)", "                                      .SetGranularity(granularity)", "                                     .SetShouldShowHandle(IsHandleVisible())", "                                      .Build());", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]}
{"tokens": [" int iscsi_decode_text_input(", " \tu8 phase,", " \tu8 sender,", " \tchar *textbuf,", " \tu32 length,", " \tstruct iscsi_conn *conn)", " {", " \tstruct iscsi_param_list *param_list = conn->param_list;", " \tchar *tmpbuf, *start = NULL, *end = NULL;", " ", " \ttmpbuf = kzalloc(length + 1, GFP_KERNEL);", " \tif (!tmpbuf) {", " \t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");", " \t\treturn -1;", " \t}", " ", " \tmemcpy(tmpbuf, textbuf, length);", " \ttmpbuf[length] = '\\0';", " \tstart = tmpbuf;", " \tend = (start + length);", " ", " \twhile (start < end) {", " \t\tchar *key, *value;", " \t\tstruct iscsi_param *param;", " ", " \t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {", " \t\t\tkfree(tmpbuf);", " \t\t\treturn -1;", " \t\t}", " ", " \t\tpr_debug(\"Got key: %s=%s\\n\", key, value);", "  ", "  \t\tif (phase & PHASE_SECURITY) {", "  \t\t\tif (iscsi_check_for_auth_key(key) > 0) {", "\t\t\t\tchar *tmpptr = key + strlen(key);", "\t\t\t\t*tmpptr = '=';", "  \t\t\t\tkfree(tmpbuf);", "  \t\t\t\treturn 1;", "  \t\t\t}", " \t\t}", " ", " \t\tparam = iscsi_check_key(key, phase, sender, param_list);", " \t\tif (!param) {", " \t\t\tif (iscsi_add_notunderstood_response(key,", " \t\t\t\t\tvalue, param_list) < 0) {", " \t\t\t\tkfree(tmpbuf);", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t\tstart += strlen(key) + strlen(value) + 2;", " \t\t\tcontinue;", " \t\t}", " \t\tif (iscsi_check_value(param, value) < 0) {", " \t\t\tkfree(tmpbuf);", " \t\t\treturn -1;", " \t\t}", " ", " \t\tstart += strlen(key) + strlen(value) + 2;", " ", " \t\tif (IS_PSTATE_PROPOSER(param)) {", " \t\t\tif (iscsi_check_proposer_state(param, value) < 0) {", " \t\t\t\tkfree(tmpbuf);", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t\tSET_PSTATE_RESPONSE_GOT(param);", " \t\t} else {", " \t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {", " \t\t\t\tkfree(tmpbuf);", " \t\t\t\treturn -1;", " \t\t\t}", " \t\t\tSET_PSTATE_ACCEPTOR(param);", " \t\t}", " \t}", " ", " \tkfree(tmpbuf);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,", " \t\t\t     struct msghdr *msg, size_t len, int flags)", " {", " \tint noblock = flags & MSG_DONTWAIT;", " \tstruct sock *sk = sock->sk;", " \tunsigned int copied, rlen;", " \tstruct sk_buff *skb, *cskb;", " \tint err = 0;", "  ", "  \tpr_debug(\"%p %zu\\n\", sk, len);", "  ", " \tmsg->msg_namelen = 0;", " ", "  \tlock_sock(sk);", "  ", "  \tif (sk->sk_state == LLCP_CLOSED &&", " \t    skb_queue_empty(&sk->sk_receive_queue)) {", " \t\trelease_sock(sk);", " \t\treturn 0;", " \t}", " ", " \trelease_sock(sk);", " ", " \tif (flags & (MSG_OOB))", " \t\treturn -EOPNOTSUPP;", " ", " \tskb = skb_recv_datagram(sk, flags, noblock, &err);", " \tif (!skb) {", " \t\tpr_err(\"Recv datagram failed state %d %d %d\",", " \t\t       sk->sk_state, err, sock_error(sk));", " ", " \t\tif (sk->sk_shutdown & RCV_SHUTDOWN)", " \t\t\treturn 0;", " ", " \t\treturn err;", " \t}", " ", " \trlen = skb->len;\t\t ", " \tcopied = min_t(unsigned int, rlen, len);", " ", " \tcskb = skb;", " \tif (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {", " \t\tif (!(flags & MSG_PEEK))", " \t\t\tskb_queue_head(&sk->sk_receive_queue, skb);", " \t\treturn -EFAULT;", " \t}", " ", " \tsock_recv_timestamp(msg, sk, skb);", " ", " \tif (sk->sk_type == SOCK_DGRAM && msg->msg_name) {", " \t\tstruct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);", " \t\tstruct sockaddr_nfc_llcp *sockaddr =", " \t\t\t(struct sockaddr_nfc_llcp *) msg->msg_name;", " ", " \t\tmsg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);", "  ", "  \t\tpr_debug(\"Datagram socket %d %d\\n\", ui_cb->dsap, ui_cb->ssap);", "  ", " \t\tmemset(sockaddr, 0, sizeof(*sockaddr));", "  \t\tsockaddr->sa_family = AF_NFC;", "  \t\tsockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;", "  \t\tsockaddr->dsap = ui_cb->dsap;", " \t\tsockaddr->ssap = ui_cb->ssap;", " \t}", " ", " \t ", " \tif (!(flags & MSG_PEEK)) {", " ", " \t\t ", " \t\tif (sk->sk_type == SOCK_STREAM ||", " \t\t    sk->sk_type == SOCK_DGRAM ||", " \t\t    sk->sk_type == SOCK_RAW) {", " \t\t\tskb_pull(skb, copied);", " \t\t\tif (skb->len) {", " \t\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);", " \t\t\t\tgoto done;", " \t\t\t}", " \t\t}", " ", " \t\tkfree_skb(skb);", " \t}", " ", " \t ", " ", " done:", " \t ", " \tif (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))", " \t\tcopied = rlen;", " ", " \treturn copied;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void UtilityServiceFactory::RegisterServices(ServiceMap* services) {", "   GetContentClient()->utility()->RegisterServices(services);", " ", "   service_manager::EmbeddedServiceInfo video_capture_info;", "   video_capture_info.factory = base::Bind(&CreateVideoCaptureService);", "   services->insert(", "       std::make_pair(video_capture::mojom::kServiceName, video_capture_info));", "  ", "  #if BUILDFLAG(ENABLE_PEPPER_CDMS)", "    service_manager::EmbeddedServiceInfo info;", "  info.factory = base::Bind(&CreateMediaService);", "  services->insert(std::make_pair(media::mojom::kMediaServiceName, info));", "   info.factory = base::Bind(&CreateCdmService);", "   services->insert(std::make_pair(media::mojom::kCdmServiceName, info));", "  #endif", "  ", "    service_manager::EmbeddedServiceInfo shape_detection_info;", "   shape_detection_info.factory =", "       base::Bind(&shape_detection::ShapeDetectionService::Create);", "   services->insert(std::make_pair(shape_detection::mojom::kServiceName,", "                                   shape_detection_info));", " ", "   service_manager::EmbeddedServiceInfo data_decoder_info;", "   data_decoder_info.factory = base::Bind(&CreateDataDecoderService);", "   services->insert(", "       std::make_pair(data_decoder::mojom::kServiceName, data_decoder_info));", " ", "   if (base::FeatureList::IsEnabled(features::kNetworkService)) {", "     GetContentClient()->utility()->RegisterNetworkBinders(", "         network_registry_.get());", "     service_manager::EmbeddedServiceInfo network_info;", "     network_info.factory = base::Bind(", "         &UtilityServiceFactory::CreateNetworkService, base::Unretained(this));", "     network_info.task_runner = ChildProcess::current()->io_task_runner();", "     services->insert(", "         std::make_pair(content::mojom::kNetworkServiceName, network_info));", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,", "   Image **image,ExceptionInfo *exception)", " {", "   char", "     message[MagickPathExtent];", " ", "   Image", "     *msl_image;", " ", "   int", "     status;", " ", "   ssize_t", "     n;", " ", "   MSLInfo", "     msl_info;", " ", "   xmlSAXHandler", "     sax_modules;", " ", "   xmlSAXHandlerPtr", "     sax_handler;", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   if (image_info->debug != MagickFalse)", "     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",", "       image_info->filename);", "   assert(image != (Image **) NULL);", "   msl_image=AcquireImage(image_info,exception);", "   status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",", "         msl_image->filename);", "       msl_image=DestroyImageList(msl_image);", "       return(MagickFalse);", "     }", "   msl_image->columns=1;", "   msl_image->rows=1;", "    ", "   (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));", "   msl_info.exception=exception;", "   msl_info.image_info=(ImageInfo **) AcquireMagickMemory(", "     sizeof(*msl_info.image_info));", "   msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(", "     sizeof(*msl_info.draw_info));", "    ", "   msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));", "   msl_info.attributes=(Image **) AcquireMagickMemory(", "     sizeof(*msl_info.attributes));", "   msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(", "     sizeof(*msl_info.group_info));", "   if ((msl_info.image_info == (ImageInfo **) NULL) ||", "       (msl_info.image == (Image **) NULL) ||", "       (msl_info.attributes == (Image **) NULL) ||", "       (msl_info.group_info == (MSLGroupInfo *) NULL))", "     ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");", "   *msl_info.image_info=CloneImageInfo(image_info);", "   *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);", "   *msl_info.attributes=AcquireImage(image_info,exception);", "   msl_info.group_info[0].numImages=0;", "    ", "   *msl_info.image=msl_image;", "   if (*image != (Image *) NULL)", "     MSLPushImage(&msl_info,*image);", "   (void) xmlSubstituteEntitiesDefault(1);", "   (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));", "   sax_modules.internalSubset=MSLInternalSubset;", "   sax_modules.isStandalone=MSLIsStandalone;", "   sax_modules.hasInternalSubset=MSLHasInternalSubset;", "   sax_modules.hasExternalSubset=MSLHasExternalSubset;", "   sax_modules.resolveEntity=MSLResolveEntity;", "   sax_modules.getEntity=MSLGetEntity;", "   sax_modules.entityDecl=MSLEntityDeclaration;", "   sax_modules.notationDecl=MSLNotationDeclaration;", "   sax_modules.attributeDecl=MSLAttributeDeclaration;", "   sax_modules.elementDecl=MSLElementDeclaration;", "   sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;", "   sax_modules.setDocumentLocator=MSLSetDocumentLocator;", "   sax_modules.startDocument=MSLStartDocument;", "   sax_modules.endDocument=MSLEndDocument;", "   sax_modules.startElement=MSLStartElement;", "   sax_modules.endElement=MSLEndElement;", "   sax_modules.reference=MSLReference;", "   sax_modules.characters=MSLCharacters;", "   sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;", "   sax_modules.processingInstruction=MSLProcessingInstructions;", "   sax_modules.comment=MSLComment;", "   sax_modules.warning=MSLWarning;", "   sax_modules.error=MSLError;", "   sax_modules.fatalError=MSLError;", "   sax_modules.getParameterEntity=MSLGetParameterEntity;", "   sax_modules.cdataBlock=MSLCDataBlock;", "   sax_modules.externalSubset=MSLExternalSubset;", "   sax_handler=(&sax_modules);", "   msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,", "     msl_image->filename);", "   while (ReadBlobString(msl_image,message) != (char *) NULL)", "   {", "     n=(ssize_t) strlen(message);", "     if (n == 0)", "       continue;", "     status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);", "     if (status != 0)", "       break;", "     (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);", "     if (msl_info.exception->severity >= ErrorException)", "       break;", "    }", "    if (msl_info.exception->severity == UndefinedException)", "      (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);", "    ", "    xmlFreeParserCtxt(msl_info.parser);", "    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");", "    msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(", "      msl_info.group_info);", "    if (*image == (Image *) NULL)", "      *image=(*msl_info.image);", "   *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);", "   msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(", "     msl_info.image_info);", "   *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);", "   msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);", "   msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);", "   *msl_info.attributes=DestroyImage(*msl_info.attributes);", "   msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);", "   msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(", "     msl_info.group_info);", "    if (msl_info.exception->severity != UndefinedException)", "      return(MagickFalse);", "    return(MagickTrue);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": [" static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)", " {", "  \tstruct cp2112_device *dev = gpiochip_get_data(chip);", "  \tstruct hid_device *hdev = dev->hdev;", "  \tu8 *buf = dev->in_out_buffer;", "\tunsigned long flags;", "  \tint ret;", "  ", "\tspin_lock_irqsave(&dev->lock, flags);", " \tmutex_lock(&dev->lock);", "  ", "  \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,", "  \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,", " \t\t\t\t HID_REQ_GET_REPORT);", " \tif (ret != CP2112_GPIO_CONFIG_LENGTH) {", " \t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);", " \t\tgoto exit;", " \t}", " ", " \tbuf[1] &= ~(1 << offset);", " \tbuf[2] = gpio_push_pull;", " ", " \tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,", " \t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,", " \t\t\t\t HID_REQ_SET_REPORT);", " \tif (ret < 0) {", " \t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);", " \t\tgoto exit;", " \t}", " ", "  \tret = 0;", "  ", "  exit:", "\tspin_unlock_irqrestore(&dev->lock, flags);", " \tmutex_unlock(&dev->lock);", "  \treturn ret <= 0 ? ret : -EIO;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" void WebURLLoaderImpl::Context::OnReceivedResponse(", "     const ResourceResponseInfo& info) {", "   if (!client_)", "     return;", " ", "   WebURLResponse response;", "   response.initialize();", "   PopulateURLResponse(request_.url(), info, &response);", " ", "   bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");", " ", "   if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {", "     if (show_raw_listing) {", "       response.setMIMEType(\"text/plain\");", "     } else {", "       response.setMIMEType(\"text/html\");", "      }", "    }", "  ", "   scoped_refptr<Context> protect(this);", "    client_->didReceiveResponse(loader_, response);", "  ", "   if (!client_)", "     return;", " ", "   DCHECK(!ftp_listing_delegate_.get());", "   DCHECK(!multipart_delegate_.get());", "   if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {", "     std::string content_type;", "     info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);", " ", "     std::string mime_type;", "     std::string charset;", "     bool had_charset = false;", "     std::string boundary;", "     net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,", "                                     &had_charset, &boundary);", "     TrimString(boundary, \" \\\"\", &boundary);", " ", "     if (!boundary.empty()) {", "       multipart_delegate_.reset(", "           new MultipartResponseDelegate(client_, loader_, response, boundary));", "     }", "   } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&", "              !show_raw_listing) {", "     ftp_listing_delegate_.reset(", "         new FtpDirectoryListingResponseDelegate(client_, loader_, response));", "   }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static Image *ReadWPGImage(const ImageInfo *image_info,", "   ExceptionInfo *exception)", " {", "   typedef struct", "   {", "     size_t FileId;", "     MagickOffsetType DataOffset;", "     unsigned int ProductType;", "     unsigned int FileType;", "     unsigned char MajorVersion;", "     unsigned char MinorVersion;", "     unsigned int EncryptKey;", "     unsigned int Reserved;", "   } WPGHeader;", " ", "   typedef struct", "   {", "     unsigned char RecType;", "     size_t RecordLength;", "   } WPGRecord;", " ", "   typedef struct", "   {", "     unsigned char Class;", "     unsigned char RecType;", "     size_t Extension;", "     size_t RecordLength;", "   } WPG2Record;", " ", "   typedef struct", "   {", "     unsigned  HorizontalUnits;", "     unsigned  VerticalUnits;", "     unsigned char PosSizePrecision;", "   } WPG2Start;", " ", "   typedef struct", "   {", "     unsigned int Width;", "     unsigned int Height;", "     unsigned int Depth;", "     unsigned int HorzRes;", "     unsigned int VertRes;", "   } WPGBitmapType1;", " ", "   typedef struct", "   {", "     unsigned int Width;", "     unsigned int Height;", "     unsigned char Depth;", "     unsigned char Compression;", "   } WPG2BitmapType1;", " ", "   typedef struct", "   {", "     unsigned int RotAngle;", "     unsigned int LowLeftX;", "     unsigned int LowLeftY;", "     unsigned int UpRightX;", "     unsigned int UpRightY;", "     unsigned int Width;", "     unsigned int Height;", "     unsigned int Depth;", "     unsigned int HorzRes;", "     unsigned int VertRes;", "   } WPGBitmapType2;", " ", "   typedef struct", "   {", "     unsigned int StartIndex;", "     unsigned int NumOfEntries;", "   } WPGColorMapRec;", " ", "    ", " ", "   Image", "     *image;", " ", "   unsigned int", "     status;", " ", "   WPGHeader", "     Header;", " ", "   WPGRecord", "     Rec;", " ", "   WPG2Record", "     Rec2;", " ", "   WPG2Start StartWPG;", " ", "   WPGBitmapType1", "     BitmapHeader1;", " ", "   WPG2BitmapType1", "     Bitmap2Header1;", " ", "   WPGBitmapType2", "     BitmapHeader2;", " ", "   WPGColorMapRec", "     WPG_Palette;", " ", "   int", "     i,", "     bpp,", "     WPG2Flags;", " ", "   ssize_t", "     ldblk;", " ", "   size_t", "     one;", " ", "   unsigned char", "     *BImgBuff;", " ", "   tCTM CTM;          ", " ", "    ", "   assert(image_info != (const ImageInfo *) NULL);", "   assert(image_info->signature == MagickCoreSignature);", "   assert(exception != (ExceptionInfo *) NULL);", "   assert(exception->signature == MagickCoreSignature);", "   one=1;", "   image=AcquireImage(image_info,exception);", "   image->depth=8;", "   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);", "   if (status == MagickFalse)", "     {", "       image=DestroyImageList(image);", "       return((Image *) NULL);", "     }", "    ", "   Header.FileId=ReadBlobLSBLong(image);", "   Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);", "   Header.ProductType=ReadBlobLSBShort(image);", "   Header.FileType=ReadBlobLSBShort(image);", "   Header.MajorVersion=ReadBlobByte(image);", "   Header.MinorVersion=ReadBlobByte(image);", "   Header.EncryptKey=ReadBlobLSBShort(image);", "   Header.Reserved=ReadBlobLSBShort(image);", " ", "   if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)", "     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "   if (Header.EncryptKey!=0)", "     ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");", " ", "   image->columns = 1;", "   image->rows = 1;", "   image->colors = 0;", "   bpp=0;", "   BitmapHeader2.RotAngle=0;", " ", "   switch(Header.FileType)", "     {", "     case 1:      ", "       while(!EOFBlob(image))  ", "         {", "           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);", "           if(EOFBlob(image))", "             break;", " ", "           Rec.RecType=(i=ReadBlobByte(image));", "           if(i==EOF)", "             break;", "           Rd_WP_DWORD(image,&Rec.RecordLength);", "           if(EOFBlob(image))", "             break;", " ", "           Header.DataOffset=TellBlob(image)+Rec.RecordLength;", " ", "           switch(Rec.RecType)", "             {", "             case 0x0B:  ", "               BitmapHeader1.Width=ReadBlobLSBShort(image);", "               BitmapHeader1.Height=ReadBlobLSBShort(image);", "               if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))", "                 ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "               BitmapHeader1.Depth=ReadBlobLSBShort(image);", "               BitmapHeader1.HorzRes=ReadBlobLSBShort(image);", "               BitmapHeader1.VertRes=ReadBlobLSBShort(image);", " ", "               if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)", "                 {", "                   image->units=PixelsPerCentimeterResolution;", "                   image->resolution.x=BitmapHeader1.HorzRes/470.0;", "                   image->resolution.y=BitmapHeader1.VertRes/470.0;", "                 }", "               image->columns=BitmapHeader1.Width;", "               image->rows=BitmapHeader1.Height;", "               bpp=BitmapHeader1.Depth;", " ", "               goto UnpackRaster;", " ", "             case 0x0E:   ", "               WPG_Palette.StartIndex=ReadBlobLSBShort(image);", "               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);", " ", "               image->colors=WPG_Palette.NumOfEntries;", "               if (!AcquireImageColormap(image,image->colors,exception))", "                 goto NoMemory;", "               for (i=WPG_Palette.StartIndex;", "                    i < (int)WPG_Palette.NumOfEntries; i++)", "                 {", "                   image->colormap[i].red=ScaleCharToQuantum((unsigned char)", "                     ReadBlobByte(image));", "                   image->colormap[i].green=ScaleCharToQuantum((unsigned char)", "                     ReadBlobByte(image));", "                   image->colormap[i].blue=ScaleCharToQuantum((unsigned char)", "                     ReadBlobByte(image));", "                 }", "               break;", "      ", "             case 0x11:   ", "               if(Rec.RecordLength > 8)", "                 image=ExtractPostscript(image,image_info,", "                   TellBlob(image)+8,    ", "                   (ssize_t) Rec.RecordLength-8,exception);", "               break;     ", " ", "             case 0x14:   ", "               BitmapHeader2.RotAngle=ReadBlobLSBShort(image);", "               BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);", "               BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);", "               BitmapHeader2.UpRightX=ReadBlobLSBShort(image);", "               BitmapHeader2.UpRightY=ReadBlobLSBShort(image);", "               BitmapHeader2.Width=ReadBlobLSBShort(image);", "               BitmapHeader2.Height=ReadBlobLSBShort(image);", "               if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))", "                 ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "               BitmapHeader2.Depth=ReadBlobLSBShort(image);", "               BitmapHeader2.HorzRes=ReadBlobLSBShort(image);", "               BitmapHeader2.VertRes=ReadBlobLSBShort(image);", " ", "               image->units=PixelsPerCentimeterResolution;", "               image->page.width=(unsigned int)", "                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);", "               image->page.height=(unsigned int)", "                 ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);", "               image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);", "               image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);", "               if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)", "                 {", "                   image->resolution.x=BitmapHeader2.HorzRes/470.0;", "                   image->resolution.y=BitmapHeader2.VertRes/470.0;", "                 }", "               image->columns=BitmapHeader2.Width;", "               image->rows=BitmapHeader2.Height;", "               bpp=BitmapHeader2.Depth;", " ", "             UnpackRaster:      ", "               if ((image->colors == 0) && (bpp != 24))", "                 {", "                   image->colors=one << bpp;", "                   if (!AcquireImageColormap(image,image->colors,exception))", "                     {", "                     NoMemory:", "                       ThrowReaderException(ResourceLimitError,", "                         \"MemoryAllocationFailed\");", "                     }", "                    ", "                   for (i=0; (i < (int) image->colors) && (i < 256); i++)", "                     {               ", "                       image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);", "                       image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);", "                       image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);", "                     }", "                 }", "               else", "                 {", "                   if (bpp < 24)", "                     if ( (image->colors < (one << bpp)) && (bpp != 24) )", "                       image->colormap=(PixelInfo *) ResizeQuantumMemory(", "                         image->colormap,(size_t) (one << bpp),", "                         sizeof(*image->colormap));", "                 }", "           ", "               if (bpp == 1)", "                 {", "                   if(image->colormap[0].red==0 &&", "                      image->colormap[0].green==0 &&", "                      image->colormap[0].blue==0 &&", "                      image->colormap[1].red==0 &&", "                      image->colormap[1].green==0 &&", "                      image->colormap[1].blue==0)", "                     {   ", "                       image->colormap[1].red =", "                         image->colormap[1].green =", "                         image->colormap[1].blue = QuantumRange;", "                     }", "                 }      ", " ", "               if(UnpackWPGRaster(image,bpp,exception) < 0)", "                  ", "                 {", "                 DecompressionFailed:", "                   ThrowReaderException(CoderError,\"UnableToDecompressImage\");", "                     }", " ", "               if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)", "                 {  ", "                    ", "                   if(BitmapHeader2.RotAngle & 0x8000)", "                     {", "                       Image", "                         *flop_image;", " ", "                       flop_image = FlopImage(image, exception);", "                       if (flop_image != (Image *) NULL) {", "                         DuplicateBlob(flop_image,image);", "                         (void) RemoveLastImageFromList(&image);", "                         AppendImageToList(&image,flop_image);", "                       }", "                     }", "                    ", "                   if(BitmapHeader2.RotAngle & 0x2000)", "                     {", "                       Image", "                         *flip_image;", " ", "                       flip_image = FlipImage(image, exception);", "                       if (flip_image != (Image *) NULL) {", "                         DuplicateBlob(flip_image,image);", "                         (void) RemoveLastImageFromList(&image);", "                         AppendImageToList(&image,flip_image);    ", "                       }", "                     }", "     ", "        ", "                   if(BitmapHeader2.RotAngle & 0x0FFF)", "                     {", "                       Image", "                         *rotate_image;", " ", "                       rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &", "                         0x0FFF), exception);", "                       if (rotate_image != (Image *) NULL) {", "                         DuplicateBlob(rotate_image,image);", "                         (void) RemoveLastImageFromList(&image);", "                         AppendImageToList(&image,rotate_image);    ", "                       }", "                     }                ", "                 }", " ", "                ", "               AcquireNextImage(image_info,image,exception);", "               image->depth=8;", "               if (image->next == (Image *) NULL)", "                 goto Finish;", "               image=SyncNextImageInList(image);", "               image->columns=image->rows=0;", "               image->colors=0;", "               break;", " ", "             case 0x1B:   ", "               if(Rec.RecordLength>0x3C)", "                 image=ExtractPostscript(image,image_info,", "                   TellBlob(image)+0x3C,    ", "                   (ssize_t) Rec.RecordLength-0x3C,exception);", "               break;", "             }", "         }", "       break;", " ", "     case 2:   ", "       (void) memset(CTM,0,sizeof(CTM));", "       StartWPG.PosSizePrecision = 0;", "       while(!EOFBlob(image))  ", "         {", "           (void) SeekBlob(image,Header.DataOffset,SEEK_SET);", "           if(EOFBlob(image))", "             break;", " ", "           Rec2.Class=(i=ReadBlobByte(image));", "           if(i==EOF)", "             break;", "           Rec2.RecType=(i=ReadBlobByte(image));", "           if(i==EOF)", "             break;", "           Rd_WP_DWORD(image,&Rec2.Extension);", "           Rd_WP_DWORD(image,&Rec2.RecordLength);", "           if(EOFBlob(image))", "             break;", " ", "           Header.DataOffset=TellBlob(image)+Rec2.RecordLength;", " ", "           switch(Rec2.RecType)", "             {", "       case 1:", "               StartWPG.HorizontalUnits=ReadBlobLSBShort(image);", "               StartWPG.VerticalUnits=ReadBlobLSBShort(image);", "               StartWPG.PosSizePrecision=ReadBlobByte(image);", "               break;", "             case 0x0C:     ", "               WPG_Palette.StartIndex=ReadBlobLSBShort(image);", "               WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);", " ", "               image->colors=WPG_Palette.NumOfEntries;", "               if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)", "                 ThrowReaderException(ResourceLimitError,", "                   \"MemoryAllocationFailed\");", "               for (i=WPG_Palette.StartIndex;", "                    i < (int)WPG_Palette.NumOfEntries; i++)", "                 {", "                   image->colormap[i].red=ScaleCharToQuantum((char)", "                     ReadBlobByte(image));", "                   image->colormap[i].green=ScaleCharToQuantum((char)", "                     ReadBlobByte(image));", "                   image->colormap[i].blue=ScaleCharToQuantum((char)", "                     ReadBlobByte(image));", "                   (void) ReadBlobByte(image);    ", "                 }", "               break;", "             case 0x0E:", "               Bitmap2Header1.Width=ReadBlobLSBShort(image);", "               Bitmap2Header1.Height=ReadBlobLSBShort(image);", "               if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))", "                 ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");", "               Bitmap2Header1.Depth=ReadBlobByte(image);", "               Bitmap2Header1.Compression=ReadBlobByte(image);", " ", "               if(Bitmap2Header1.Compression > 1)", "                 continue;  ", "               switch(Bitmap2Header1.Depth)", "                 {", "                 case 1:", "                   bpp=1;", "                   break;", "                 case 2:", "                   bpp=2;", "                   break;", "                 case 3:", "                   bpp=4;", "                   break;", "                 case 4:", "                   bpp=8;", "                   break;", "                 case 8:", "                   bpp=24;", "                   break;", "                 default:", "                   continue;   ", "                 }", "               image->columns=Bitmap2Header1.Width;", "               image->rows=Bitmap2Header1.Height;  ", " ", "               if ((image->colors == 0) && (bpp != 24))", "                 {", "                   size_t", "                     one;", " ", "                   one=1;", "                   image->colors=one << bpp;", "                   if (!AcquireImageColormap(image,image->colors,exception))", "                     goto NoMemory;", "                 }", "               else", "                 {", "                   if(bpp < 24)", "                     if( image->colors<(one << bpp) && bpp!=24 )", "                       image->colormap=(PixelInfo *) ResizeQuantumMemory(", "                        image->colormap,(size_t) (one << bpp),", "                        sizeof(*image->colormap));", "                 }", " ", " ", "               switch(Bitmap2Header1.Compression)", "                 {", "                 case 0:     ", "                    {", "                      ldblk=(ssize_t) ((bpp*image->columns+7)/8);", "                      BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)", "                      ldblk,sizeof(*BImgBuff));", "                       ldblk+1,sizeof(*BImgBuff));", "                      if (BImgBuff == (unsigned char *) NULL)", "                        goto NoMemory;", "  ", "                     for(i=0; i< (ssize_t) image->rows; i++)", "                       {", "                         (void) ReadBlob(image,ldblk,BImgBuff);", "                         InsertRow(image,BImgBuff,i,bpp,exception);", "                       }", " ", "                     if(BImgBuff)", "                       BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;", "                     break;", "                   }", "                 case 1:     ", "                   {", "                     if( UnpackWPG2Raster(image,bpp,exception) < 0)", "                       goto DecompressionFailed;", "                     break;", "                   }   ", "                 }", " ", "               if(CTM[0][0]<0 && !image_info->ping)", "                 {     ", "                   Image", "                     *flop_image;", " ", "                   flop_image = FlopImage(image, exception);", "                   if (flop_image != (Image *) NULL) {", "                     DuplicateBlob(flop_image,image);", "                     (void) RemoveLastImageFromList(&image);", "                     AppendImageToList(&image,flop_image);", "                   }", "                                      ", "                 }", "               if(CTM[1][1]<0 && !image_info->ping)", "                 {     ", "                   Image", "                     *flip_image;", " ", "                    flip_image = FlipImage(image, exception);", "                    if (flip_image != (Image *) NULL) {", "                      DuplicateBlob(flip_image,image);", "                      (void) RemoveLastImageFromList(&image);", "                      AppendImageToList(&image,flip_image);", "                     }", "                          ", "               }    ", "     ", " ", "                ", "               AcquireNextImage(image_info,image,exception);", "               image->depth=8;", "               if (image->next == (Image *) NULL)", "                 goto Finish;", "               image=SyncNextImageInList(image);", "               image->columns=image->rows=1;", "               image->colors=0;", "               break;", " ", "             case 0x12:   ", "         i=ReadBlobLSBShort(image);", "               if(Rec2.RecordLength > (unsigned int) i)", "                 image=ExtractPostscript(image,image_info,", "                   TellBlob(image)+i,     ", "                   (ssize_t) (Rec2.RecordLength-i-2),exception);", "               break;", " ", "       case 0x1B:           ", "               WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);", "               (void) WPG2Flags;", "               break;", "             }", "         }", " ", "       break;", " ", "     default:", "       {", "          ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");", "       }", "    }", "   status=SetImageExtent(image,image->columns,image->rows,exception);", "   if (status == MagickFalse)", "     return(DestroyImageList(image));", " ", "  Finish:", "   (void) CloseBlob(image);", " ", "   {", "     Image", "       *p;", " ", "     ssize_t", "       scene=0;", " ", "      ", "     p=image;", "     image=NULL;", "     while (p != (Image *) NULL)", "       {", "         Image *tmp=p;", "         if ((p->rows == 0) || (p->columns == 0)) {", "           p=p->previous;", "           DeleteImageFromList(&tmp);", "         } else {", "           image=p;", "           p=p->previous;", "         }", "       }", "      ", "     for (p=image; p != (Image *) NULL; p=p->next)", "       p->scene=(size_t) scene++;", "   }", "   if (image == (Image *) NULL)", "     ThrowReaderException(CorruptImageError,", "       \"ImageFileDoesNotContainAnyImageData\");", "   return(image);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["static bool parseOperands(char* str, ArmOp *op) {", "char *t = strdup (str);", "int operand = 0;", "char *token = t;", "char *x;", "int imm_count = 0;", "int mem_opt = 0;", "if (!token) {", "return false;", "}", "", "while (token) {", "char *next = strchr (token, ',');", "if (next) {", "*next++ = 0;", "}", "while (token[0] == ' ') {", "token++;", "}", "op->operands[operand].type = ARM_NOTYPE;", "op->operands[operand].reg_type = ARM_UNDEFINED;", "op->operands[operand].shift = ARM_NO_SHIFT;", "", "while (token[0] == ' ' || token[0] == '[' || token[0] == ']') {", "token ++;", "}", "", "if (!strncmp (token, \"lsl\", 3)) {", "op->operands[operand].shift = ARM_LSL;", "} else if (!strncmp (token, \"lsr\", 3)) {", "op->operands[operand].shift = ARM_LSR;", "} else if (!strncmp (token, \"asr\", 3)) {", "op->operands[operand].shift = ARM_ASR;", "}", "if (op->operands[operand].shift != ARM_NO_SHIFT) {", "op->operands_count ++;", "op->operands[operand].shift_amount = r_num_math (NULL, token + 4);", "if (op->operands[operand].shift_amount > 63) {", "return false;", "}", "operand ++;", "token = next;", "continue;", "}", "", "switch (token[0]) {", "case 'x':", "x = strchr (token, ',');", "if (x) {", "x[0] = '\\0';", "}", "op->operands_count ++;", "op->operands[operand].type = ARM_GPR;", "op->operands[operand].reg_type = ARM_REG64;", "op->operands[operand].reg = r_num_math (NULL, token + 1);", "if (op->operands[operand].reg > 31) {", "return false;", "}", "break;", "case 'w':", "op->operands_count ++;", "op->operands[operand].type = ARM_GPR;", "op->operands[operand].reg_type = ARM_REG32;", "op->operands[operand].reg = r_num_math (NULL, token + 1);", "if (op->operands[operand].reg > 31) {", "return false;", "}", "break;", "case 'v':", "op->operands_count ++;", "op->operands[operand].type = ARM_FP;", "op->operands[operand].reg = r_num_math (NULL, token + 1);", "break;", "case 's':", "case 'S':", "if (token[1] == 'P' || token [1] == 'p') {", "int i;", "for (i = 0; msr_const[i].name; i++) {", "if (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) {", "op->operands[operand].sp_val = msr_const[i].val;", "break;", "}", "}", "op->operands_count ++;", "op->operands[operand].type = ARM_GPR;", "op->operands[operand].reg_type = ARM_SP | ARM_REG64;", "op->operands[operand].reg = 31;", "break;", "}", "mem_opt = get_mem_option (token);", "if (mem_opt != -1) {", "op->operands_count ++;", "op->operands[operand].type = ARM_MEM_OPT;", "op->operands[operand].mem_option = mem_opt;", "}", "break;", "case 'L':", "case 'l':", "case 'I':", "case 'i':", "case 'N':", "case 'n':", "case 'O':", "case 'o':", "case 'p':", "case 'P':", "mem_opt = get_mem_option (token);", "if (mem_opt != -1) {", "op->operands_count ++;", "op->operands[operand].type = ARM_MEM_OPT;", "op->operands[operand].mem_option = mem_opt;", "}", "break;", "case '-':", "op->operands[operand].sign = -1;", "", "default:", "op->operands_count ++;", "op->operands[operand].type = ARM_CONSTANT;", "op->operands[operand].immediate = r_num_math (NULL, token);", "imm_count++;", "break;", "}", "token = next;", "", "operand ++;", "if (operand > MAX_OPERANDS) {", "free (t);", "return false;", "}", "}", "free (t);", "return true;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int test(char *URL)", "  {", "   int errors = 0;", "   (void)URL;  ", " ", "   errors += test_weird_arguments();", " ", "   errors += test_unsigned_short_formatting();", " ", "   errors += test_signed_short_formatting();", " ", "   errors += test_unsigned_int_formatting();", " ", "   errors += test_signed_int_formatting();", " ", "   errors += test_unsigned_long_formatting();", " ", "   errors += test_signed_long_formatting();", " ", "   errors += test_curl_off_t_formatting();", "  ", "    errors += test_string_formatting();", "  ", "   errors += test_float_formatting();", " ", "    if(errors)", "      return TEST_ERR_MAJOR_BAD;", "    else", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]}
{"tokens": [" PageHandler::PageHandler(EmulationHandler* emulation_handler)", " PageHandler::PageHandler(EmulationHandler* emulation_handler,", "                          bool allow_set_download_behavior)", "      : DevToolsDomainHandler(Page::Metainfo::domainName),", "        enabled_(false),", "        screencast_enabled_(false),", "       screencast_quality_(kDefaultScreenshotQuality),", "       screencast_max_width_(-1),", "       screencast_max_height_(-1),", "       capture_every_nth_frame_(1),", "       capture_retry_count_(0),", "       has_compositor_frame_metadata_(false),", "       session_id_(0),", "       frame_counter_(0),", "       frames_in_flight_(0),", "       video_consumer_(nullptr),", "        last_surface_size_(gfx::Size()),", "        host_(nullptr),", "        emulation_handler_(emulation_handler),", "       allow_set_download_behavior_(allow_set_download_behavior),", "        observer_(this),", "        weak_factory_(this) {", "    bool create_video_consumer = true;", " #ifdef OS_ANDROID", "   if (!CompositorImpl::IsInitialized())", "     create_video_consumer = false;", " #endif", "   if (create_video_consumer) {", "     video_consumer_ = std::make_unique<DevToolsVideoConsumer>(", "         base::BindRepeating(&PageHandler::OnFrameFromVideoConsumer,", "                             weak_factory_.GetWeakPtr()));", "   }", "   DCHECK(emulation_handler_);", " }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void SoftMP3::onQueueFilled(OMX_U32  ) {", "  if (mSignalledError || mOutputPortSettingsChange != NONE) {", "  return;", "  }", " ", "  List<BufferInfo *> &inQueue = getPortQueue(0);", "  List<BufferInfo *> &outQueue = getPortQueue(1);", " ", "  while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {", "  BufferInfo *inInfo = NULL;", "         OMX_BUFFERHEADERTYPE *inHeader = NULL;", "  if (!inQueue.empty()) {", "             inInfo = *inQueue.begin();", "             inHeader = inInfo->mHeader;", "  }", " ", "  BufferInfo *outInfo = *outQueue.begin();", "         OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;", "         outHeader->nFlags = 0;", " ", "  if (inHeader) {", "  if (inHeader->nOffset == 0 && inHeader->nFilledLen) {", "                 mAnchorTimeUs = inHeader->nTimeStamp;", "                 mNumFramesOutput = 0;", "  }", " ", "  if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) {", "                 mSawInputEos = true;", "  }", " ", "             mConfig->pInputBuffer =", "                 inHeader->pBuffer + inHeader->nOffset;", " ", "             mConfig->inputBufferCurrentLength = inHeader->nFilledLen;", "  } else {", "             mConfig->pInputBuffer = NULL;", "             mConfig->inputBufferCurrentLength = 0;", "  }", "         mConfig->inputBufferMaxLength = 0;", " ", "          mConfig->inputBufferUsedLength = 0;", "  ", "          mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);", "         if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {", "             ALOGE(\"input buffer too small: got %lu, expected %u\",", "                 outHeader->nAllocLen, mConfig->outputFrameSize);", "             android_errorWriteLog(0x534e4554, \"27793371\");", "             notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);", "             mSignalledError = true;", "             return;", "         }", "  ", "          mConfig->pOutputBuffer =", "              reinterpret_cast<int16_t *>(outHeader->pBuffer);", " ", "         ERROR_CODE decoderErr;", "  if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf))", "  != NO_DECODING_ERROR) {", "             ALOGV(\"mp3 decoder returned error %d\", decoderErr);", " ", "  if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR", "  && decoderErr != SIDE_INFO_ERROR) {", "                 ALOGE(\"mp3 decoder returned error %d\", decoderErr);", " ", "                 notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);", "                 mSignalledError = true;", "  return;", "  }", " ", "  if (mConfig->outputFrameSize == 0) {", "                 mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);", "  }", " ", "  if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) {", "  if (!mIsFirst) {", "                     outHeader->nOffset = 0;", "                     outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);", " ", "                     memset(outHeader->pBuffer, 0, outHeader->nFilledLen);", "  }", "                 outHeader->nFlags = OMX_BUFFERFLAG_EOS;", "                 mSignalledOutputEos = true;", "  } else {", " ", "                 ALOGV_IF(mIsFirst, \"insufficient data for first frame, sending silence\");", "                 memset(outHeader->pBuffer,", "  0,", "                        mConfig->outputFrameSize * sizeof(int16_t));", " ", "  if (inHeader) {", "                     mConfig->inputBufferUsedLength = inHeader->nFilledLen;", "  }", "  }", "  } else if (mConfig->samplingRate != mSamplingRate", "  || mConfig->num_channels != mNumChannels) {", "             mSamplingRate = mConfig->samplingRate;", "             mNumChannels = mConfig->num_channels;", " ", "             notify(OMX_EventPortSettingsChanged, 1, 0, NULL);", "             mOutputPortSettingsChange = AWAITING_DISABLED;", "  return;", "  }", " ", "  if (mIsFirst) {", "             mIsFirst = false;", "             outHeader->nOffset =", "                 kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);", " ", "             outHeader->nFilledLen =", "                 mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset;", "  } else if (!mSignalledOutputEos) {", "             outHeader->nOffset = 0;", "             outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t);", "  }", " ", "         outHeader->nTimeStamp =", "             mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;", " ", "  if (inHeader) {", "             CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);", " ", "             inHeader->nOffset += mConfig->inputBufferUsedLength;", "             inHeader->nFilledLen -= mConfig->inputBufferUsedLength;", " ", " ", "  if (inHeader->nFilledLen == 0) {", "                 inInfo->mOwnedByUs = false;", "                 inQueue.erase(inQueue.begin());", "                 inInfo = NULL;", "                 notifyEmptyBufferDone(inHeader);", "                 inHeader = NULL;", "  }", "  }", " ", "         mNumFramesOutput += mConfig->outputFrameSize / mNumChannels;", " ", "         outInfo->mOwnedByUs = false;", "         outQueue.erase(outQueue.begin());", "         outInfo = NULL;", "         notifyFillBufferDone(outHeader);", "         outHeader = NULL;", "  }", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" Response ServiceWorkerHandler::DeliverPushMessage(", "     const std::string& origin,", "     const std::string& registration_id,", "      const std::string& data) {", "    if (!enabled_)", "      return CreateDomainNotEnabledErrorResponse();", "  if (!process_)", "   if (!browser_context_)", "      return CreateContextErrorResponse();", "    int64_t id = 0;", "    if (!base::StringToInt64(registration_id, &id))", "      return CreateInvalidVersionIdErrorResponse();", "    PushEventPayload payload;", "    if (data.size() > 0)", "      payload.setData(data);", "  BrowserContext::DeliverPushMessage(process_->GetBrowserContext(),", "                                     GURL(origin), id, payload,", "                                     base::Bind(&PushDeliveryNoOp));", "   BrowserContext::DeliverPushMessage(", "       browser_context_, GURL(origin), id, payload,", "       base::BindRepeating([](mojom::PushDeliveryStatus status) {}));", " ", "    return Response::OK();", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0]}
{"tokens": ["static int smtp_open(struct Connection *conn, bool esmtp)", "{", "int rc;", "", "if (mutt_socket_open(conn))", "return -1;", "", "", "rc = smtp_get_resp(conn);", "if (rc != 0)", "return rc;", "", "rc = smtp_helo(conn, esmtp);", "if (rc != 0)", "return rc;", "", "#ifdef USE_SSL", "enum QuadOption ans = MUTT_NO;", "if (conn->ssf)", "ans = MUTT_NO;", "else if (C_SslForceTls)", "ans = MUTT_YES;", "else if ((Capabilities & SMTP_CAP_STARTTLS) &&", "((ans = query_quadoption(C_SslStarttls,", "_(\"Secure connection with TLS?\"))) == MUTT_ABORT))", "{", "return -1;", "}", "", "if (ans == MUTT_YES)", "{", "if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)", "return SMTP_ERR_WRITE;", "rc = smtp_get_resp(conn);", "if (rc != 0)", "return rc;", "", "if (mutt_ssl_starttls(conn))", "{", "mutt_error(_(\"Could not negotiate TLS connection\"));", "return -1;", "}", "", "", "rc = smtp_helo(conn, esmtp);", "if (rc != 0)", "return rc;", "}", "#endif", "", "if (conn->account.flags & MUTT_ACCT_USER)", "{", "if (!(Capabilities & SMTP_CAP_AUTH))", "{", "mutt_error(_(\"SMTP server does not support authentication\"));", "return -1;", "}", "", "return smtp_auth(conn);", "}", "", "return 0;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,", "                                        mojo::ScopedSharedBufferHandle handle) {", "   DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;", "   DCHECK(io_thread_checker_.CalledOnValidThread());", "   DCHECK(handle.is_valid());", "  ", "    base::SharedMemoryHandle memory_handle;", "    size_t memory_size = 0;", "  bool read_only_flag = false;", "   mojo::UnwrappedSharedMemoryHandleProtection protection;", "  ", "    const MojoResult result = mojo::UnwrapSharedMemoryHandle(", "      std::move(handle), &memory_handle, &memory_size, &read_only_flag);", "       std::move(handle), &memory_handle, &memory_size, &protection);", "    DCHECK_EQ(MOJO_RESULT_OK, result);", "    DCHECK_GT(memory_size, 0u);", "  ", "    ", "    ", "    ", " ", "    std::unique_ptr<base::SharedMemory> shm(", "        new base::SharedMemory(memory_handle, true  ));", "    if (!shm->Map(memory_size)) {", "     DLOG(ERROR) << \"OnBufferCreated: Map failed.\";", "     return;", "   }", "   const bool inserted =", "       client_buffers_", "           .insert(std::make_pair(buffer_id,", "                                  new ClientBuffer(std::move(shm), memory_size)))", "           .second;", "   DCHECK(inserted);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  int res_unpack(vorbis_info_residue *info,", "\t\tvorbis_info *vi,oggpack_buffer *opb){", "                 vorbis_info *vi,oggpack_buffer *opb){", "    int j,k;", "    codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;", "    memset(info,0,sizeof(*info));", " ", "   info->type=oggpack_read(opb,16);", "  if(info->type>2 || info->type<0)goto errout;", "   info->begin=oggpack_read(opb,24);", "   info->end=oggpack_read(opb,24);", "   info->grouping=oggpack_read(opb,24)+1;", "   info->partitions=(char)(oggpack_read(opb,6)+1);", "   info->groupbook=(unsigned char)oggpack_read(opb,8);", "  if(info->groupbook>=ci->books)goto errout;", " ", "   info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));", "   info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));", " ", "  for(j=0;j<info->partitions;j++){", "  int cascade=oggpack_read(opb,3);", "  if(oggpack_read(opb,1))", "       cascade|=(oggpack_read(opb,5)<<3);", "     info->stagemasks[j]=cascade;", "  }", " ", " ", "    for(j=0;j<info->partitions;j++){", "      for(k=0;k<8;k++){", "        if((info->stagemasks[j]>>k)&1){", "\tunsigned char book=(unsigned char)oggpack_read(opb,8);", "\tif(book>=ci->books)goto errout;", "\tinfo->stagebooks[j*8+k]=book;", "\tif(k+1>info->stages)info->stages=k+1;", "         unsigned char book=(unsigned char)oggpack_read(opb,8);", "         if(book>=ci->books)goto errout;", "         info->stagebooks[j*8+k]=book;", "         if(k+1>info->stages)info->stages=k+1;", "        }else", "\tinfo->stagebooks[j*8+k]=0xff;", "         info->stagebooks[j*8+k]=0xff;", "      }", "    }", "  ", "  if(oggpack_eop(opb))goto errout;", " ", "  return 0;", "  errout:", "   res_clear_info(info);", "  return 1;", " ", "  }"], "ner_tags": [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16(UWORD32 u4_isdc,", "                                                 UWORD32 u4_total_coeff_trail_one,  ", "  dec_bit_stream_t *ps_bitstrm )", " {", "     UWORD32 u4_total_zeroes;", "     WORD32 i;", "     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;", " ", "      UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;", "      UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;", "      UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;", "    WORD16 i2_level_arr[16];", "      ", "      ", "      ", "     WORD16 ai2_level_arr[19]; ", "     WORD16 *i2_level_arr = &ai2_level_arr[3];", "  ", "      tu_sblk4x4_coeff_data_t *ps_tu_4x4;", "      WORD16 *pi2_coeff_data;", "  dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;", " ", "     ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;", "     ps_tu_4x4->u2_sig_coeff_map = 0;", "     pi2_coeff_data = &ps_tu_4x4->ai2_level[0];", " ", "     i = u4_total_coeff - 1;", "  if(u4_trailing_ones)", "  {", "   ", "   ", "   ", "   ", "         UWORD32 u4_signs, u4_cnt = u4_trailing_ones;", "         WORD16 (*ppi2_trlone_lkup)[3] =", "  (WORD16 (*)[3])gai2_ih264d_trailing_one_level;", "         WORD16 *pi2_trlone_lkup;", " ", "         GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);", " ", "         pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];", " ", "  while(u4_cnt--)", "             i2_level_arr[i--] = *pi2_trlone_lkup++;", "  }", " ", "   ", "   ", "   ", "  if(i >= 0)", "  {", "   ", "   ", "   ", "   ", "         UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;", "         UWORD16 u2_lev_code, u2_abs_value;", "         UWORD32 u4_lev_prefix;", " ", "  if(u4_trailing_ones < 3)", "  {", "   ", "   ", "   ", "   ", "   ", "   ", "             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,", "                                   pu4_bitstrm_buf);", " ", "             u4_lev_suffix_size =", "  (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : 1;", " ", "             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,", "                     u4_lev_suffix_size);", "             u2_lev_code = 2 + (MIN(u4_lev_prefix,15) << 1) + u4_lev_suffix;", " ", "  if(16 <= u4_lev_prefix)", "  {", "                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);", "  }", "  }", "  else", "  {", "   ", "   ", "   ", "   ", "   ", "   ", "             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,", "                                   pu4_bitstrm_buf);", " ", "   ", "   ", "   ", "             u2_lev_code = MIN(15, u4_lev_prefix);", " ", "             u2_lev_code += (3 == u4_trailing_ones) ? 0 : (2);", " ", "  if(14 == u4_lev_prefix)", "                 u4_lev_suffix_size = 4;", "  else if(15 <= u4_lev_prefix)", "  {", "                 u2_lev_code += 15;", "                 u4_lev_suffix_size = (u4_lev_prefix - 3);", "  }", "  else", "                 u4_lev_suffix_size = 0;", " ", "  if(16 <= u4_lev_prefix)", "  {", "                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);", "  }", "  if(u4_lev_suffix_size)", "  {", "                 GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,", "                         u4_lev_suffix_size);", "                 u2_lev_code += u4_lev_suffix;", "  }", "  }", " ", "         u2_abs_value = (u2_lev_code + 2) >> 1;", "   ", "   ", "   ", "         i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;", " ", "         u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;", " ", "   ", "   ", "   ", "  while(i >= 0)", "  {", " ", "   ", "   ", "   ", "             FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,", "                                   pu4_bitstrm_buf);", " ", "             u4_lev_suffix_size =", "  (15 <= u4_lev_prefix) ?", "  (u4_lev_prefix - 3) : u4_suffix_len;", " ", "   ", "   ", "   ", "             GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,", "                     u4_lev_suffix_size);", "             u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)", "  + u4_lev_suffix;", " ", "  if(16 <= u4_lev_prefix)", "  {", "                 u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);", "  }", "             u2_abs_value = (u2_lev_code + 2) >> 1;", " ", "   ", "   ", "   ", "             i2_level_arr[i--] =", "  (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;", " ", "   ", "   ", "   ", "             u4_suffix_len +=", "  (u4_suffix_len < 6) ?", "  (u2_abs_value", "  > (3", "  << (u4_suffix_len", "  - 1))) :", "  0;", "  }", " ", "   ", "   ", "   ", "  }", " ", "  if(u4_total_coeff < (16 - u4_isdc))", "  {", "         UWORD32 u4_index;", "  const UWORD8 (*ppu1_total_zero_lkup)[16] =", "  (const UWORD8 (*)[16])gau1_ih264d_table_total_zero_11to15;", " ", "         NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 4);", "         u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 11][u4_index];", " ", "         FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));", "         u4_total_zeroes &= 0xf;", "  }", "  else", "         u4_total_zeroes = 0;", " ", "   ", "   ", "   ", "  {", "  const UWORD8 *pu1_table_runbefore;", "         UWORD32 u4_run;", "         WORD32 k;", "         UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;", "         WORD32 u4_zeroes_left = u4_total_zeroes;", "         k = u4_total_coeff - 1;", " ", "   ", "   ", "   ", "         pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;", "  while((u4_zeroes_left > 0) && k)", "  {", "             UWORD32 u4_code;", "             NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);", " ", "             u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];", "             u4_run = u4_code >> 2;", " ", "             FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));", "             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);", "  *pi2_coeff_data++ = i2_level_arr[k--];", "             u4_zeroes_left -= u4_run;", "             u4_scan_pos -= (u4_run + 1);", "  }", "   ", "   ", "   ", " ", "   ", "   ", "   ", "  if(u4_zeroes_left < 0)", "  return -1;", "  while(k >= 0)", "  {", "             SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);", "  *pi2_coeff_data++ = i2_level_arr[k--];", "             u4_scan_pos--;", "  }", "  }", " ", "  {", "         WORD32 offset;", "         offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;", "         offset = ALIGN4(offset);", "         ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);", "  }", " ", "     ps_bitstrm->u4_ofst = u4_bitstream_offset;", "  return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["   MediaStreamManagerTest()", "       : thread_bundle_(content::TestBrowserThreadBundle::IO_MAINLOOP) {", "     audio_manager_ = std::make_unique<MockAudioManager>();", "     audio_system_ =", "         std::make_unique<media::AudioSystemImpl>(audio_manager_.get());", "     auto video_capture_provider = std::make_unique<MockVideoCaptureProvider>();", "     video_capture_provider_ = video_capture_provider.get();", "      media_stream_manager_ = std::make_unique<MediaStreamManager>(", "          audio_system_.get(), audio_manager_->GetTaskRunner(),", "          std::move(video_capture_provider));", "     media_observer_ = std::make_unique<MockMediaObserver>();", "     browser_content_client_ =", "         std::make_unique<TestBrowserClient>(media_observer_.get());", "     SetBrowserClientForTesting(browser_content_client_.get());", "      base::RunLoop().RunUntilIdle();", "  ", "      ON_CALL(*video_capture_provider_, DoGetDeviceInfosAsync(_))", "         .WillByDefault(Invoke(", "             [](VideoCaptureProvider::GetDeviceInfosCallback& result_callback) {", "               std::vector<media::VideoCaptureDeviceInfo> stub_results;", "               base::ResetAndReturn(&result_callback).Run(stub_results);", "             }));", "   }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {", "      if (len > outHeader->nAllocLen) {", "        ALOGE(\"memset buffer too small: got %lu, expected %zu\", outHeader->nAllocLen, len);", "         ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);", "          android_errorWriteLog(0x534e4554, \"29422022\");", "          notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);", "          mSignalledError = true;", "  return NULL;", "  }", "  return memset(outHeader->pBuffer, c, len);", " }"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)", " {", " \tint rlen, remain;", " \tdpIOCtxPtr dctx;", " \tdynamicPtr *dp;", " ", " \tdctx = (dpIOCtxPtr) ctx;", " \tdp = dctx->dp;", " ", " \tremain = dp->logicalSize - dp->pos;", "  \tif(remain >= len) {", "  \t\trlen = len;", "  \t} else {", "\t\tif(remain == 0) {", " \t\tif(remain <= 0) {", "  \t\t\t ", " \t\t\treturn 0;  ", " \t\t}", " ", " \t\trlen = remain;", " \t}", " ", " \tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);", " \tdp->pos += rlen;", " ", " \treturn rlen;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" ossl_cipher_initialize(VALUE self, VALUE str)", " {", "      EVP_CIPHER_CTX *ctx;", "      const EVP_CIPHER *cipher;", "      char *name;", "    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };", "  ", "      name = StringValueCStr(str);", "      GetCipherInit(self, ctx);", "     if (ctx) {", " \tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");", "     }", "     AllocCipher(self, ctx);", "      if (!(cipher = EVP_get_cipherbyname(name))) {", "  \tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);", "      }", "     ", "    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)", "     if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)", "  \tossl_raise(eCipherError, NULL);", "  ", "      return self;", " }"], "ner_tags": [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0]}
{"tokens": ["TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,", "int axis, TfLiteTensor* output) {", "const TfLiteIntArray& input_dims = *input.dims;", "if (axis < 0) {", "axis = input_dims.size + 1 + axis;", "}", "TF_LITE_ENSURE(context, axis <= input_dims.size);", "", "TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);", "for (int i = 0; i < output_dims->size; ++i) {", "if (i < axis) {", "output_dims->data[i] = input_dims.data[i];", "} else if (i == axis) {", "output_dims->data[i] = 1;", "} else {", "output_dims->data[i] = input_dims.data[i - 1];", "}", "}", "", "return context->ResizeTensor(context, output, output_dims);", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  TabsCustomBindings::TabsCustomBindings(ScriptContext* context)", "      : ObjectBackedNativeHandler(context) {", "  RouteFunction(\"OpenChannelToTab\",", "      base::Bind(&TabsCustomBindings::OpenChannelToTab,", "                 base::Unretained(this)));", "   RouteFunction(\"OpenChannelToTab\", \"tabs\",", "                 base::Bind(&TabsCustomBindings::OpenChannelToTab,", "                            base::Unretained(this)));", "  }"], "ner_tags": [0, 0, 1, 1, 1, 1, 1, 1, 0]}
{"tokens": ["void Compute(OpKernelContext* context) override {", "int32_t dim = context->input(0).scalar<int32_t>()();", "int32_t num_results = context->input(1).scalar<int32_t>()();", "int32_t skip = context->input(2).scalar<int32_t>()();", "", "OP_REQUIRES(context, dim >= 1,", "errors::InvalidArgument(\"dim must be at least one\"));", "OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,", "errors::InvalidArgument(\"dim must be at most \",", "sobol_data::kMaxSobolDim));", "OP_REQUIRES(context, num_results >= 1,", "errors::InvalidArgument(\"num_results must be at least one\"));", "OP_REQUIRES(context, skip >= 0,", "errors::InvalidArgument(\"skip must be non-negative\"));", "OP_REQUIRES(context,", "num_results < std::numeric_limits<int32_t>::max() - skip,", "errors::InvalidArgument(\"num_results+skip must be less than \",", "std::numeric_limits<int32_t>::max()));", "", "Tensor* output = nullptr;", "OP_REQUIRES_OK(context,", "context->allocate_output(", "0, TensorShape({num_results, dim}), &output));", "auto output_flat = output->flat<T>();", "const DeviceBase::CpuWorkerThreads& worker_threads =", "*(context->device()->tensorflow_cpu_worker_threads());", "int num_threads = worker_threads.num_threads;", "int block_size = std::max(", "kMinBlockSize, static_cast<int>(std::ceil(", "static_cast<float>(num_results) / num_threads)));", "worker_threads.workers->TransformRangeConcurrently(", "block_size, num_results            ,", "[&dim, &skip, &output_flat](const int start, const int end) {", "CalculateSobolSample<T>(dim, end - start                  , skip,", "start, output_flat);", "});", "}"], "ner_tags": [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int pit_ioport_read(struct kvm_io_device *this,", " \t\t\t   gpa_t addr, int len, void *data)", " {", " \tstruct kvm_pit *pit = dev_to_pit(this);", " \tstruct kvm_kpit_state *pit_state = &pit->pit_state;", " \tstruct kvm *kvm = pit->kvm;", " \tint ret, count;", " \tstruct kvm_kpit_channel_state *s;", " \tif (!pit_in_range(addr))", "  \t\treturn -EOPNOTSUPP;", "  ", "  \taddr &= KVM_PIT_CHANNEL_MASK;", " \tif (addr == 3)", " \t\treturn 0;", " ", "  \ts = &pit_state->channels[addr];", "  ", "  \tmutex_lock(&pit_state->lock);", " ", " \tif (s->status_latched) {", " \t\ts->status_latched = 0;", " \t\tret = s->status;", " \t} else if (s->count_latched) {", " \t\tswitch (s->count_latched) {", " \t\tdefault:", " \t\tcase RW_STATE_LSB:", " \t\t\tret = s->latched_count & 0xff;", " \t\t\ts->count_latched = 0;", " \t\t\tbreak;", " \t\tcase RW_STATE_MSB:", " \t\t\tret = s->latched_count >> 8;", " \t\t\ts->count_latched = 0;", " \t\t\tbreak;", " \t\tcase RW_STATE_WORD0:", " \t\t\tret = s->latched_count & 0xff;", " \t\t\ts->count_latched = RW_STATE_MSB;", " \t\t\tbreak;", " \t\t}", " \t} else {", " \t\tswitch (s->read_state) {", " \t\tdefault:", " \t\tcase RW_STATE_LSB:", " \t\t\tcount = pit_get_count(kvm, addr);", " \t\t\tret = count & 0xff;", " \t\t\tbreak;", " \t\tcase RW_STATE_MSB:", " \t\t\tcount = pit_get_count(kvm, addr);", " \t\t\tret = (count >> 8) & 0xff;", " \t\t\tbreak;", " \t\tcase RW_STATE_WORD0:", " \t\t\tcount = pit_get_count(kvm, addr);", " \t\t\tret = count & 0xff;", " \t\t\ts->read_state = RW_STATE_WORD1;", " \t\t\tbreak;", " \t\tcase RW_STATE_WORD1:", " \t\t\tcount = pit_get_count(kvm, addr);", " \t\t\tret = (count >> 8) & 0xff;", " \t\t\ts->read_state = RW_STATE_WORD0;", " \t\t\tbreak;", " \t\t}", " \t}", " ", " \tif (len > sizeof(ret))", " \t\tlen = sizeof(ret);", " \tmemcpy(data, (char *)&ret, len);", " ", " \tmutex_unlock(&pit_state->lock);", " \treturn 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,", "                                         ScriptContext* context,", "                                         Dispatcher* dispatcher,", "                                         RequestSender* request_sender,", "                                          V8SchemaRegistry* v8_schema_registry) {", "    module_system->RegisterNativeHandler(", "        \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));", "  module_system->RegisterNativeHandler(", "      \"lazy_background_page\",", "      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));", "    module_system->RegisterNativeHandler(", "        \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));", "    module_system->RegisterNativeHandler(\"schema_registry\",", "                                         v8_schema_registry->AsNativeHandler());", "  module_system->RegisterNativeHandler(", "      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));", "    module_system->RegisterNativeHandler(", "        \"test_features\",", "        scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"test_native_handler\",", "       scoped_ptr<NativeHandler>(new TestNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"user_gestures\",", "       scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"utils\", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"v8_context\",", "       scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"event_natives\", scoped_ptr<NativeHandler>(new EventBindings(context)));", "   module_system->RegisterNativeHandler(", "       \"messaging_natives\",", "       scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));", "   module_system->RegisterNativeHandler(", "       \"apiDefinitions\",", "       scoped_ptr<NativeHandler>(", "           new ApiDefinitionsNatives(dispatcher, context)));", "   module_system->RegisterNativeHandler(", "       \"sendRequest\",", "       scoped_ptr<NativeHandler>(", "           new SendRequestNatives(request_sender, context)));", "   module_system->RegisterNativeHandler(", "       \"setIcon\",", "       scoped_ptr<NativeHandler>(new SetIconNatives(context)));", "   module_system->RegisterNativeHandler(", "       \"activityLogger\",", "       scoped_ptr<NativeHandler>(new APIActivityLogger(context)));", "   module_system->RegisterNativeHandler(", "       \"renderFrameObserverNatives\",", "       scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));", " ", "   module_system->RegisterNativeHandler(", "       \"file_system_natives\",", "       scoped_ptr<NativeHandler>(new FileSystemNatives(context)));", " ", "   module_system->RegisterNativeHandler(", "       \"app_window_natives\",", "       scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));", "   module_system->RegisterNativeHandler(", "       \"blob_natives\",", "       scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"context_menus\",", "       scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));", "   module_system->RegisterNativeHandler(", "       \"css_natives\", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));", "   module_system->RegisterNativeHandler(", "       \"document_natives\",", "       scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));", "   module_system->RegisterNativeHandler(", "        \"guest_view_internal\",", "        scoped_ptr<NativeHandler>(", "            new GuestViewInternalCustomBindings(context)));", "  module_system->RegisterNativeHandler(", "      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));", "    module_system->RegisterNativeHandler(", "        \"id_generator\",", "        scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));", "   module_system->RegisterNativeHandler(", "       \"runtime\", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));", "   module_system->RegisterNativeHandler(", "       \"display_source\",", "       scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" bool ResourceLoader::WillFollowRedirect(", "     const WebURL& new_url,", "     const WebURL& new_site_for_cookies,", "     const WebString& new_referrer,", "     WebReferrerPolicy new_referrer_policy,", "     const WebString& new_method,", "     const WebURLResponse& passed_redirect_response,", "     bool& report_raw_headers) {", "   DCHECK(!passed_redirect_response.IsNull());", " ", "   if (is_cache_aware_loading_activated_) {", "     HandleError(", "         ResourceError::CacheMissError(resource_->LastResourceRequest().Url()));", "     return false;", "   }", " ", "   const ResourceRequest& last_request = resource_->LastResourceRequest();", "   ResourceRequest new_request(new_url);", "   new_request.SetSiteForCookies(new_site_for_cookies);", "   new_request.SetDownloadToFile(last_request.DownloadToFile());", "   new_request.SetUseStreamOnResponse(last_request.UseStreamOnResponse());", "   new_request.SetRequestContext(last_request.GetRequestContext());", "   new_request.SetFrameType(last_request.GetFrameType());", "   new_request.SetServiceWorkerMode(", "       passed_redirect_response.WasFetchedViaServiceWorker()", "           ? WebURLRequest::ServiceWorkerMode::kAll", "           : WebURLRequest::ServiceWorkerMode::kNone);", "   new_request.SetShouldResetAppCache(last_request.ShouldResetAppCache());", "   new_request.SetFetchRequestMode(last_request.GetFetchRequestMode());", "   new_request.SetFetchCredentialsMode(last_request.GetFetchCredentialsMode());", "   new_request.SetKeepalive(last_request.GetKeepalive());", "   String referrer =", "       new_referrer.IsEmpty() ? Referrer::NoReferrer() : String(new_referrer);", "   new_request.SetHTTPReferrer(", "       Referrer(referrer, static_cast<ReferrerPolicy>(new_referrer_policy)));", "   new_request.SetPriority(last_request.Priority());", "   new_request.SetHTTPMethod(new_method);", "   if (new_request.HttpMethod() == last_request.HttpMethod())", "     new_request.SetHTTPBody(last_request.HttpBody());", "   new_request.SetCheckForBrowserSideNavigation(", "       last_request.CheckForBrowserSideNavigation());", " ", "   Resource::Type resource_type = resource_->GetType();", " ", "   const ResourceRequest& initial_request = resource_->GetResourceRequest();", "   WebURLRequest::RequestContext request_context =", "       initial_request.GetRequestContext();", "   WebURLRequest::FrameType frame_type = initial_request.GetFrameType();", "   WebURLRequest::FetchRequestMode fetch_request_mode =", "       initial_request.GetFetchRequestMode();", "   WebURLRequest::FetchCredentialsMode fetch_credentials_mode =", "       initial_request.GetFetchCredentialsMode();", " ", "   const ResourceLoaderOptions& options = resource_->Options();", " ", "   const ResourceResponse& redirect_response(", "       passed_redirect_response.ToResourceResponse());", " ", "   new_request.SetRedirectStatus(", "       ResourceRequest::RedirectStatus::kFollowedRedirect);", " ", "   if (!IsManualRedirectFetchRequest(initial_request)) {", "     bool unused_preload = resource_->IsUnusedPreload();", " ", "     SecurityViolationReportingPolicy reporting_policy =", "         unused_preload ? SecurityViolationReportingPolicy::kSuppressReporting", "                        : SecurityViolationReportingPolicy::kReport;", " ", "     Context().CheckCSPForRequest(", "         request_context, new_url, options, reporting_policy,", "         ResourceRequest::RedirectStatus::kFollowedRedirect);", " ", "     ResourceRequestBlockedReason blocked_reason = Context().CanRequest(", "         resource_type, new_request, new_url, options, reporting_policy,", "         FetchParameters::kUseDefaultOriginRestrictionForType,", "         ResourceRequest::RedirectStatus::kFollowedRedirect);", "     if (blocked_reason != ResourceRequestBlockedReason::kNone) {", "       CancelForRedirectAccessCheckError(new_url, blocked_reason);", "       return false;", "     }", " ", "     if (options.cors_handling_by_resource_fetcher ==", "             kEnableCORSHandlingByResourceFetcher &&", "         fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {", "       RefPtr<SecurityOrigin> source_origin = options.security_origin;", "       if (!source_origin.get())", "         source_origin = Context().GetSecurityOrigin();", "       WebSecurityOrigin source_web_origin(source_origin.get());", "       WrappedResourceRequest new_request_wrapper(new_request);", "       WebString cors_error_msg;", "       if (!WebCORS::HandleRedirect(", "               source_web_origin, new_request_wrapper, redirect_response.Url(),", "               redirect_response.HttpStatusCode(),", "               redirect_response.HttpHeaderFields(), fetch_credentials_mode,", "               resource_->MutableOptions(), cors_error_msg)) {", "         resource_->SetCORSStatus(CORSStatus::kFailed);", " ", "         if (!unused_preload) {", "           Context().AddErrorConsoleMessage(cors_error_msg,", "                                            FetchContext::kJSSource);", "         }", " ", "         CancelForRedirectAccessCheckError(new_url,", "                                           ResourceRequestBlockedReason::kOther);", "         return false;", "       }", " ", "       source_origin = source_web_origin;", "     }", "     if (resource_type == Resource::kImage &&", "         fetcher_->ShouldDeferImageLoad(new_url)) {", "       CancelForRedirectAccessCheckError(new_url,", "                                         ResourceRequestBlockedReason::kOther);", "       return false;", "     }", "   }", " ", "   bool cross_origin =", "       !SecurityOrigin::AreSameSchemeHostPort(redirect_response.Url(), new_url);", "   fetcher_->RecordResourceTimingOnRedirect(resource_.Get(), redirect_response,", "                                            cross_origin);", " ", "   if (options.cors_handling_by_resource_fetcher ==", "           kEnableCORSHandlingByResourceFetcher &&", "       fetch_request_mode == WebURLRequest::kFetchRequestModeCORS) {", "     bool allow_stored_credentials = false;", "     switch (fetch_credentials_mode) {", "       case WebURLRequest::kFetchCredentialsModeOmit:", "         break;", "       case WebURLRequest::kFetchCredentialsModeSameOrigin:", "         allow_stored_credentials = !options.cors_flag;", "         break;", "       case WebURLRequest::kFetchCredentialsModeInclude:", "       case WebURLRequest::kFetchCredentialsModePassword:", "         allow_stored_credentials = true;", "         break;", "     }", "     new_request.SetAllowStoredCredentials(allow_stored_credentials);", "   }", " ", " ", "    Context().PrepareRequest(new_request,", "                             FetchContext::RedirectType::kForRedirect);", "    Context().DispatchWillSendRequest(resource_->Identifier(), new_request,", "                                    redirect_response, options.initiator_info);", "                                     redirect_response, resource_->GetType(),", "                                     options.initiator_info);", "  ", "   DCHECK(KURL(new_site_for_cookies) == new_request.SiteForCookies());", " ", "   DCHECK_EQ(new_request.GetRequestContext(), request_context);", "   DCHECK_EQ(new_request.GetFrameType(), frame_type);", "   DCHECK_EQ(new_request.GetFetchRequestMode(), fetch_request_mode);", "   DCHECK_EQ(new_request.GetFetchCredentialsMode(), fetch_credentials_mode);", " ", "   if (new_request.Url() != KURL(new_url)) {", "     CancelForRedirectAccessCheckError(new_request.Url(),", "                                       ResourceRequestBlockedReason::kOther);", "     return false;", "   }", " ", "   if (!resource_->WillFollowRedirect(new_request, redirect_response)) {", "     CancelForRedirectAccessCheckError(new_request.Url(),", "                                       ResourceRequestBlockedReason::kOther);", "     return false;", "   }", " ", "   report_raw_headers = new_request.ReportRawHeaders();", " ", "   return true;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["  long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,", "\t\t\t      long offset,int ch,", "\t\t\t      oggpack_buffer *b,int n,int point){", "                               long offset,int ch,", "                               oggpack_buffer *b,int n,int point){", "    if(book->used_entries>0){", "  ", "      ogg_int32_t *v = book->dec_buf; ", "  long i,j;", "  int chptr=0;", " ", " ", "      if (!v) return -1;", "      for(i=offset;i<offset+n;){", "        if(decode_map(book,b,v,point))return -1;", "      for (j=0;j<book->dim;j++){", "\ta[chptr++][i]+=v[j];", "\tif(chptr==ch){", "\t  chptr=0;", "\t  i++;", "\t}", "       for (j=0;j<book->dim && i < offset + n;j++){", "         a[chptr++][i]+=v[j];", "         if(chptr==ch){", "           chptr=0;", "           i++;", "         }", "        }", "      }", "    }", " ", "  return 0;", " }"], "ner_tags": [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]}
{"tokens": [" OMX_ERRORTYPE  omx_video::allocate_input_buffer(", "         OMX_IN OMX_HANDLETYPE            hComp,", "         OMX_INOUT OMX_BUFFERHEADERTYPE** bufferHdr,", "         OMX_IN OMX_U32                   port,", "         OMX_IN OMX_PTR                   appData,", "         OMX_IN OMX_U32                   bytes)", " {", "  (void)hComp, (void)port;", "     OMX_ERRORTYPE eRet = OMX_ErrorNone;", "  unsigned   i = 0;", " ", "     DEBUG_PRINT_HIGH(\"allocate_input_buffer()::\");", "  if (bytes != m_sInPortDef.nBufferSize) {", "         DEBUG_PRINT_ERROR(\"ERROR: Buffer size mismatch error: bytes[%u] != nBufferSize[%u]\",", "  (unsigned int)bytes, (unsigned int)m_sInPortDef.nBufferSize);", "  return OMX_ErrorBadParameter;", "  }", " ", "  if (!m_inp_mem_ptr) {", "         DEBUG_PRINT_HIGH(\"%s: size = %u, actual cnt %u\", __FUNCTION__,", "  (unsigned int)m_sInPortDef.nBufferSize, (unsigned int)m_sInPortDef.nBufferCountActual);", "         m_inp_mem_ptr = (OMX_BUFFERHEADERTYPE*) \\", "                         calloc( (sizeof(OMX_BUFFERHEADERTYPE)), m_sInPortDef.nBufferCountActual);", "  if (m_inp_mem_ptr == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_inp_mem_ptr\");", "  return OMX_ErrorInsufficientResources;", "  }", " ", "         DEBUG_PRINT_LOW(\"Successfully allocated m_inp_mem_ptr = %p\", m_inp_mem_ptr);", "         m_pInput_pmem = (struct pmem *) calloc(sizeof (struct pmem), m_sInPortDef.nBufferCountActual);", " ", "  if (m_pInput_pmem == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_pmem\");", "  return OMX_ErrorInsufficientResources;", "  }", " #ifdef USE_ION", "         m_pInput_ion = (struct venc_ion *) calloc(sizeof (struct venc_ion), m_sInPortDef.nBufferCountActual);", "  if (m_pInput_ion == NULL) {", "             DEBUG_PRINT_ERROR(\"ERROR: calloc() Failed for m_pInput_ion\");", "  return OMX_ErrorInsufficientResources;", "  }", " #endif", "  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {", "             m_pInput_pmem[i].fd = -1;", " #ifdef USE_ION", "             m_pInput_ion[i].ion_device_fd =-1;", "             m_pInput_ion[i].fd_ion_data.fd =-1;", "             m_pInput_ion[i].ion_alloc_data.handle = 0;", " #endif", "  }", "  }", " ", "  for (i=0; i< m_sInPortDef.nBufferCountActual; i++) {", "  if (BITMASK_ABSENT(&m_inp_bm_count,i)) {", "  break;", "  }", "  }", "  if (i < m_sInPortDef.nBufferCountActual) {", " ", "  *bufferHdr = (m_inp_mem_ptr + i);", "  (*bufferHdr)->nSize             = sizeof(OMX_BUFFERHEADERTYPE);", "  (*bufferHdr)->nVersion.nVersion = OMX_SPEC_VERSION;", "  (*bufferHdr)->nAllocLen         = m_sInPortDef.nBufferSize;", "  (*bufferHdr)->pAppPrivate       = appData;", "  (*bufferHdr)->nInputPortIndex   = PORT_INDEX_IN;", "  (*bufferHdr)->pInputPortPrivate = (OMX_PTR)&m_pInput_pmem[i];", " ", " #ifdef USE_ION", " #ifdef _MSM8974_", "         m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,", "  &m_pInput_ion[i].ion_alloc_data,", "  &m_pInput_ion[i].fd_ion_data,0);", " #else", "         m_pInput_ion[i].ion_device_fd = alloc_map_ion_memory(m_sInPortDef.nBufferSize,", "  &m_pInput_ion[i].ion_alloc_data,", "  &m_pInput_ion[i].fd_ion_data,ION_FLAG_CACHED);", " #endif", "  if (m_pInput_ion[i].ion_device_fd < 0) {", "             DEBUG_PRINT_ERROR(\"ERROR:ION device open() Failed\");", "  return OMX_ErrorInsufficientResources;", "  }", " ", "         m_pInput_pmem[i].fd = m_pInput_ion[i].fd_ion_data.fd;", " #else", "         m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);", " ", "  if (m_pInput_pmem[i].fd == 0) {", "             m_pInput_pmem[i].fd = open (MEM_DEVICE,O_RDWR);", "  }", " ", "  if (m_pInput_pmem[i].fd < 0) {", "             DEBUG_PRINT_ERROR(\"ERROR: /dev/pmem_adsp open() Failed\");", "  return OMX_ErrorInsufficientResources;", "  }", " #endif", "         m_pInput_pmem[i].size = m_sInPortDef.nBufferSize;", "         m_pInput_pmem[i].offset = 0;", " ", "         m_pInput_pmem[i].buffer = (OMX_U8 *)SECURE_BUFPTR;", "  if(!secure_session) {", "             m_pInput_pmem[i].buffer = (unsigned char *)mmap(NULL,", "                 m_pInput_pmem[i].size,PROT_READ|PROT_WRITE,", "                 MAP_SHARED,m_pInput_pmem[i].fd,0);", "  if (m_pInput_pmem[i].buffer == MAP_FAILED) {", "                 DEBUG_PRINT_ERROR(\"ERROR: mmap FAILED= %d\", errno);", "             close(m_pInput_pmem[i].fd);", " #ifdef USE_ION", "             free_ion_memory(&m_pInput_ion[i]);", " #endif", "  return OMX_ErrorInsufficientResources;", "  }", "  } else {", " ", "              m_pInput_pmem[i].buffer = malloc(sizeof(OMX_U32) + sizeof(native_handle_t*));", "             (*bufferHdr)->nAllocLen = sizeof(OMX_U32) + sizeof(native_handle_t*);", "          }", "  ", "          (*bufferHdr)->pBuffer           = (OMX_U8 *)m_pInput_pmem[i].buffer;", "         DEBUG_PRINT_LOW(\"Virtual address in allocate buffer is %p\", m_pInput_pmem[i].buffer);", "         BITMASK_SET(&m_inp_bm_count,i);", "  if (!mUseProxyColorFormat && (dev_use_buf(&m_pInput_pmem[i],PORT_INDEX_IN,i) != true)) {", "             DEBUG_PRINT_ERROR(\"ERROR: dev_use_buf FAILED for i/p buf\");", "  return OMX_ErrorInsufficientResources;", "  }", "  } else {", "         DEBUG_PRINT_ERROR(\"ERROR: All i/p buffers are allocated, invalid allocate buf call\"", "  \"for index [%d]\", i);", "         eRet = OMX_ErrorInsufficientResources;", "  }", " ", "  return eRet;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static void destroy_server_connect(SERVER_CONNECT_REC *conn)", " {", " \tIRC_SERVER_CONNECT_REC *ircconn;", " ", "         ircconn = IRC_SERVER_CONNECT(conn);", " \tif (ircconn == NULL)", " \t\treturn;", "  ", "  \tg_free_not_null(ircconn->usermode);", "  \tg_free_not_null(ircconn->alternate_nick);", " \tg_free_not_null(ircconn->sasl_username);", " \tg_free_not_null(ircconn->sasl_password);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]}
{"tokens": ["static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k,", "OPJ_BYTE * p_data,", "OPJ_UINT32 * p_data_written,", "OPJ_UINT32 p_total_data_size,", "opj_stream_private_t *p_stream,", "struct opj_event_mgr * p_manager", ")", "{", "OPJ_UINT32 tilepartno = 0;", "OPJ_UINT32 l_nb_bytes_written = 0;", "OPJ_UINT32 l_current_nb_bytes_written;", "OPJ_UINT32 l_part_tile_size;", "OPJ_UINT32 tot_num_tp;", "OPJ_UINT32 pino;", "", "OPJ_BYTE * l_begin_data;", "opj_tcp_t *l_tcp = 00;", "opj_tcd_t * l_tcd = 00;", "opj_cp_t * l_cp = 00;", "", "l_tcd = p_j2k->m_tcd;", "l_cp = &(p_j2k->m_cp);", "l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;", "", "", "tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number);", "", "", "++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;", "for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {", "p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;", "l_current_nb_bytes_written = 0;", "l_part_tile_size = 0;", "l_begin_data = p_data;", "", "if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,", "p_manager)) {", "return OPJ_FALSE;", "}", "", "l_nb_bytes_written += l_current_nb_bytes_written;", "p_data += l_current_nb_bytes_written;", "p_total_data_size -= l_current_nb_bytes_written;", "l_part_tile_size += l_current_nb_bytes_written;", "", "l_current_nb_bytes_written = 0;", "if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,", "p_total_data_size, p_stream, p_manager)) {", "return OPJ_FALSE;", "}", "", "p_data += l_current_nb_bytes_written;", "l_nb_bytes_written += l_current_nb_bytes_written;", "p_total_data_size -= l_current_nb_bytes_written;", "l_part_tile_size += l_current_nb_bytes_written;", "", "", "opj_write_bytes(l_begin_data + 6, l_part_tile_size,", "4);", "", "if (OPJ_IS_CINEMA(l_cp->rsiz)) {", "opj_j2k_update_tlm(p_j2k, l_part_tile_size);", "}", "", "++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;", "}", "", "for (pino = 1; pino <= l_tcp->numpocs; ++pino) {", "l_tcd->cur_pino = pino;", "", "", "tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number);", "for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {", "p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;", "l_current_nb_bytes_written = 0;", "l_part_tile_size = 0;", "l_begin_data = p_data;", "", "if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream,", "p_manager)) {", "return OPJ_FALSE;", "}", "", "l_nb_bytes_written += l_current_nb_bytes_written;", "p_data += l_current_nb_bytes_written;", "p_total_data_size -= l_current_nb_bytes_written;", "l_part_tile_size += l_current_nb_bytes_written;", "", "l_current_nb_bytes_written = 0;", "", "if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written,", "p_total_data_size, p_stream, p_manager)) {", "return OPJ_FALSE;", "}", "", "l_nb_bytes_written += l_current_nb_bytes_written;", "p_data += l_current_nb_bytes_written;", "p_total_data_size -= l_current_nb_bytes_written;", "l_part_tile_size += l_current_nb_bytes_written;", "", "", "opj_write_bytes(l_begin_data + 6, l_part_tile_size,", "4);", "", "if (OPJ_IS_CINEMA(l_cp->rsiz)) {", "opj_j2k_update_tlm(p_j2k, l_part_tile_size);", "}", "", "++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;", "}", "}", "", "*p_data_written = l_nb_bytes_written;", "", "return OPJ_TRUE;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)", " {", " \tdouble width_d;", " \tdouble scale_f_d = 1.0;", " \tconst double filter_width_d = DEFAULT_BOX_RADIUS;", " \tint windows_size;", " \tunsigned int u;", " \tLineContribType *res;", " ", " \tif (scale_d < 1.0) {", " \t\twidth_d = filter_width_d / scale_d;", " \t\tscale_f_d = scale_d;", " \t}  else {", " \t\twidth_d= filter_width_d;", " \t}", " ", " \twindows_size = 2 * (int)ceil(width_d) + 1;", " \tres = _gdContributionsAlloc(line_size, windows_size);", " ", " \tfor (u = 0; u < line_size; u++) {", " \t\tconst double dCenter = (double)u / scale_d;", " \t\t ", " \t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));", " \t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);", "  \t\tdouble dTotalWeight = 0.0;", "  \t\tint iSrc;", "  ", "\t\tres->ContribRow[u].Left = iLeft;", "\t\tres->ContribRow[u].Right = iRight;", "  \t\t ", "  \t\tif (iRight - iLeft + 1 > windows_size)  {", "  \t\t\tif (iLeft < ((int)src_size - 1 / 2))  {", " \t\t\t\tiLeft++;", " \t\t\t} else {", " \t\t\t\tiRight--;", "  \t\t\t}", "  \t\t}", "  ", " \t\tres->ContribRow[u].Left = iLeft;", " \t\tres->ContribRow[u].Right = iRight;", " ", "  \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {", "  \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));", "  \t\t}", " ", " \t\tif (dTotalWeight < 0.0) {", " \t\t\t_gdContributionsFree(res);", " \t\t\treturn NULL;", " \t\t}", " ", " \t\tif (dTotalWeight > 0.0) {", " \t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {", " \t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;", " \t\t\t}", " \t\t}", " \t}", " \treturn res;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)", " {\tconst AIFF_CAF_CHANNEL_MAP * map_info ;", " \tunsigned channel_bitmap, channel_decriptions, bytesread ;", " \tint layout_tag ;", " ", " \tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;", " ", " \tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)", " \t\treturn 0 ;", " ", " \tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;", " \tif (map_info)", " \t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;", " ", " \tif (bytesread < dword)", "  \t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;", "  ", "  \tif (map_info->channel_map != NULL)", "\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;", " \t{\tsize_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;", "  ", "  \t\tfree (psf->channel_map) ;", "  ", " \t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)", " \t\t\treturn SFE_MALLOC_FAILED ;", " ", " \t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;", " \t\t} ;", " ", " \treturn 0 ;", " }  "], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": ["md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,", "const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)", "{", "unsigned total_indent = 0;", "int n_parents = 0;", "int n_brothers = 0;", "int n_children = 0;", "MD_CONTAINER container = { 0 };", "int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;", "OFF off = beg;", "OFF hr_killer = 0;", "int ret = 0;", "", "line->indent = md_line_indentation(ctx, total_indent, off, &off);", "total_indent += line->indent;", "line->beg = off;", "", "", "", "while(n_parents < ctx->n_containers) {", "MD_CONTAINER* c = &ctx->containers[n_parents];", "", "if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&", "off < ctx->size  &&  CH(off) == _T('>'))", "{", "", "off++;", "total_indent++;", "line->indent = md_line_indentation(ctx, total_indent, off, &off);", "total_indent += line->indent;", "", "", "if(line->indent > 0)", "line->indent--;", "", "line->beg = off;", "", "} else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {", "", "line->indent -= c->contents_indent;", "} else {", "break;", "}", "", "n_parents++;", "}", "", "if(off >= ctx->size  ||  ISNEWLINE(off)) {", "", "", "if(n_brothers + n_children == 0) {", "while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))", "n_parents++;", "}", "}", "", "while(TRUE) {", "", "if(pivot_line->type == MD_LINE_FENCEDCODE) {", "line->beg = off;", "", "", "", "if(line->indent < ctx->code_indent_offset) {", "if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {", "line->type = MD_LINE_BLANK;", "ctx->last_line_has_list_loosening_effect = FALSE;", "break;", "}", "}", "", "", "if(n_parents == ctx->n_containers) {", "if(line->indent > pivot_line->indent)", "line->indent -= pivot_line->indent;", "else", "line->indent = 0;", "", "line->type = MD_LINE_FENCEDCODE;", "break;", "}", "}", "", "", "if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {", "if(n_parents < ctx->n_containers) {", "", "", "ctx->html_block_type = 0;", "} else {", "int html_block_type;", "", "html_block_type = md_is_html_block_end_condition(ctx, off, &off);", "if(html_block_type > 0) {", "MD_ASSERT(html_block_type == ctx->html_block_type);", "", "", "ctx->html_block_type = 0;", "", "", "if(html_block_type == 6 || html_block_type == 7) {", "line->type = MD_LINE_BLANK;", "line->indent = 0;", "break;", "}", "}", "", "line->type = MD_LINE_HTML;", "n_parents = ctx->n_containers;", "break;", "}", "}", "", "", "if(off >= ctx->size  ||  ISNEWLINE(off)) {", "if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {", "line->type = MD_LINE_INDENTEDCODE;", "if(line->indent > ctx->code_indent_offset)", "line->indent -= ctx->code_indent_offset;", "else", "line->indent = 0;", "ctx->last_line_has_list_loosening_effect = FALSE;", "} else {", "line->type = MD_LINE_BLANK;", "ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&", "n_brothers + n_children == 0  &&", "ctx->containers[n_parents-1].ch != _T('>'));", "", "#if 1", "", "", "", "", "", "", "", "", "", "", "", "if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&", "n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&", "ctx->n_block_bytes > (int) sizeof(MD_BLOCK))", "{", "MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));", "if(top_block->type == MD_BLOCK_LI)", "ctx->last_list_item_starts_with_two_blank_lines = TRUE;", "}", "#endif", "}", "break;", "} else {", "#if 1", "", "", "", "", "ctx->last_line_has_list_loosening_effect = FALSE;", "if(ctx->last_list_item_starts_with_two_blank_lines) {", "if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&", "n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&", "ctx->n_block_bytes > (int) sizeof(MD_BLOCK))", "{", "MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));", "if(top_block->type == MD_BLOCK_LI)", "n_parents--;", "}", "", "ctx->last_list_item_starts_with_two_blank_lines = FALSE;", "}", "#endif", "}", "", "", "if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT", "&&  (CH(off) == _T('=') || CH(off) == _T('-'))", "&&  (n_parents == ctx->n_containers))", "{", "unsigned level;", "", "if(md_is_setext_underline(ctx, off, &off, &level)) {", "line->type = MD_LINE_SETEXTUNDERLINE;", "line->data = level;", "break;", "}", "}", "", "", "if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T(\"-_*\"))  &&  off >= hr_killer) {", "if(md_is_hr_line(ctx, off, &off, &hr_killer)) {", "line->type = MD_LINE_HR;", "break;", "}", "}", "", "", "", "if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {", "OFF tmp;", "", "if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&", "md_is_container_compatible(&ctx->containers[n_parents], &container))", "{", "pivot_line = &md_dummy_blank_line;", "", "off = tmp;", "", "total_indent += container.contents_indent - container.mark_indent;", "line->indent = md_line_indentation(ctx, total_indent, off, &off);", "total_indent += line->indent;", "line->beg = off;", "", "", "if(off >= ctx->size || ISNEWLINE(off)) {", "container.contents_indent++;", "} else if(line->indent <= ctx->code_indent_offset) {", "container.contents_indent += line->indent;", "line->indent = 0;", "} else {", "container.contents_indent += 1;", "line->indent--;", "}", "", "ctx->containers[n_parents].mark_indent = container.mark_indent;", "ctx->containers[n_parents].contents_indent = container.contents_indent;", "", "n_brothers++;", "continue;", "}", "}", "", "", "", "if(line->indent >= ctx->code_indent_offset  &&", "(pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))", "{", "line->type = MD_LINE_INDENTEDCODE;", "MD_ASSERT(line->indent >= ctx->code_indent_offset);", "line->indent -= ctx->code_indent_offset;", "line->data = 0;", "break;", "}", "", "", "if(line->indent < ctx->code_indent_offset  &&", "md_is_container_mark(ctx, line->indent, off, &off, &container))", "{", "if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&", "(off >= ctx->size || ISNEWLINE(off))  &&  container.ch != _T('>'))", "{", "", "} else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&", "(container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)", "{", "", "} else {", "total_indent += container.contents_indent - container.mark_indent;", "line->indent = md_line_indentation(ctx, total_indent, off, &off);", "total_indent += line->indent;", "", "line->beg = off;", "line->data = container.ch;", "", "", "if(off >= ctx->size || ISNEWLINE(off)) {", "container.contents_indent++;", "} else if(line->indent <= ctx->code_indent_offset) {", "container.contents_indent += line->indent;", "line->indent = 0;", "} else {", "container.contents_indent += 1;", "line->indent--;", "}", "", "if(n_brothers + n_children == 0)", "pivot_line = &md_dummy_blank_line;", "", "if(n_children == 0)", "MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));", "", "n_children++;", "MD_CHECK(md_push_container(ctx, &container));", "continue;", "}", "}", "", "", "if(pivot_line->type == MD_LINE_TABLE  &&  n_parents == ctx->n_containers) {", "line->type = MD_LINE_TABLE;", "break;", "}", "", "", "if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {", "unsigned level;", "", "if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {", "line->type = MD_LINE_ATXHEADER;", "line->data = level;", "break;", "}", "}", "", "", "if(CH(off) == _T('`') || CH(off) == _T('~')) {", "if(md_is_opening_code_fence(ctx, off, &off)) {", "line->type = MD_LINE_FENCEDCODE;", "line->data = 1;", "break;", "}", "}", "", "", "if(CH(off) == _T('<')  &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))", "{", "ctx->html_block_type = md_is_html_block_start_condition(ctx, off);", "", "", "if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)", "ctx->html_block_type = 0;", "", "if(ctx->html_block_type > 0) {", "", "if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {", "", "ctx->html_block_type = 0;", "}", "", "line->type = MD_LINE_HTML;", "break;", "}", "}", "", "", "if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&", "(CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&", "n_parents == ctx->n_containers)", "{", "unsigned col_count;", "", "if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&", "md_is_table_underline(ctx, off, &off, &col_count))", "{", "line->data = col_count;", "line->type = MD_LINE_TABLEUNDERLINE;", "break;", "}", "}", "", "", "line->type = MD_LINE_TEXT;", "if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {", "", "n_parents = ctx->n_containers;", "}", "", "", "if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&", "ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T(\"-+*.)\")))", "{", "OFF tmp = off;", "", "while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))", "tmp++;", "if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&", "ISANYOF(tmp+1, _T(\"xX \"))  &&  CH(tmp+2) == _T(']')  &&", "(tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))", "{", "MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);", "task_container->is_task = TRUE;", "task_container->task_mark_off = tmp + 1;", "off = tmp + 3;", "while(ISWHITESPACE(off))", "off++;", "line->beg = off;", "}", "}", "", "break;", "}", "", "", "", "", "", "", "#if defined __linux__ && !defined MD4C_USE_UTF16", "", "", "if(ctx->doc_ends_with_newline  &&  off < ctx->size) {", "while(TRUE) {", "off += (OFF) strcspn(STR(off), \"\\r\\n\");", "", "", "", "if(CH(off) == _T('\\0'))", "off++;", "else", "break;", "}", "} else", "#endif", "{", "", "while(off + 3 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)", "&&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))", "off += 4;", "while(off < ctx->size  &&  !ISNEWLINE(off))", "off++;", "}", "", "", "line->end = off;", "", "", "if(line->type == MD_LINE_ATXHEADER) {", "OFF tmp = line->end;", "while(tmp > line->beg && CH(tmp-1) == _T(' '))", "tmp--;", "while(tmp > line->beg && CH(tmp-1) == _T('#'))", "tmp--;", "if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))", "line->end = tmp;", "}", "", "", "if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {", "while(line->end > line->beg && CH(line->end-1) == _T(' '))", "line->end--;", "}", "", "", "if(off < ctx->size && CH(off) == _T('\\r'))", "off++;", "if(off < ctx->size && CH(off) == _T('\\n'))", "off++;", "", "*p_end = off;", "", "", "if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {", "MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];", "if(c->ch != _T('>')) {", "MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);", "block->flags |= MD_BLOCK_LOOSE_LIST;", "}", "}", "", "", "if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)", "MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));", "", "", "if(n_brothers > 0) {", "MD_ASSERT(n_brothers == 1);", "MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,", "ctx->containers[n_parents].task_mark_off,", "(ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),", "MD_BLOCK_CONTAINER_CLOSER));", "MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,", "container.task_mark_off,", "(container.is_task ? CH(container.task_mark_off) : 0),", "MD_BLOCK_CONTAINER_OPENER));", "ctx->containers[n_parents].is_task = container.is_task;", "ctx->containers[n_parents].task_mark_off = container.task_mark_off;", "}", "", "if(n_children > 0)", "MD_CHECK(md_enter_child_containers(ctx, n_children));", "", "abort:", "return ret;", "}"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void HTMLMediaElement::ProgressEventTimerFired(TimerBase*) {", "    if (network_state_ != kNetworkLoading)", "      return;", "  ", "    ", "    ", "    ", "    ", "   if (MediaShouldBeOpaque())", "     return;", " ", "    double time = WTF::CurrentTime();", "    double timedelta = time - previous_progress_time_;", "  ", "   if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress()) {", "     ScheduleEvent(EventTypeNames::progress);", "     previous_progress_time_ = time;", "     sent_stalled_event_ = false;", "     if (GetLayoutObject())", "       GetLayoutObject()->UpdateFromElement();", "   } else if (timedelta > 3.0 && !sent_stalled_event_) {", "     ScheduleEvent(EventTypeNames::stalled);", "     sent_stalled_event_ = true;", "     SetShouldDelayLoadEvent(false);", "   }", " }"], "ner_tags": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)", " {", "     MXFContext *mxf = arg;", "     int item_num = avio_rb32(pb);", "     int item_len = avio_rb32(pb);", " ", "     if (item_len != 18) {", "          avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);", "          return AVERROR_PATCHWELCOME;", "      }", "    if (item_num > 65536) {", "     if (item_num > 65536 || item_num < 0) {", "          av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);", "          return AVERROR_INVALIDDATA;", "      }", "     if (mxf->local_tags)", "         av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");", "     av_free(mxf->local_tags);", "     mxf->local_tags_count = 0;", "     mxf->local_tags = av_calloc(item_num, item_len);", "     if (!mxf->local_tags)", "         return AVERROR(ENOMEM);", "     mxf->local_tags_count = item_num;", "     avio_read(pb, mxf->local_tags, item_num*item_len);", "     return 0;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" static int __net_init sctp_net_init(struct net *net)", " static int __net_init sctp_defaults_init(struct net *net)", "  {", "  \tint status;", "  ", " \t ", " \t ", " \t ", " \tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;", " \t ", " \tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;", " \t ", " \tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;", " \t ", " \tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;", " \t ", " \tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;", " ", " \t ", " \tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;", " ", " \t ", " \tnet->sctp.cookie_preserve_enable \t= 1;", " ", " \t ", " #if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)", " \tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";", " #elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)", " \tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";", " #else", " \tnet->sctp.sctp_hmac_alg\t\t\t= NULL;", " #endif", " ", " \t ", " \tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;", " ", " \t ", " \tnet->sctp.max_retrans_association\t= 10;", " \tnet->sctp.max_retrans_path\t\t= 5;", " \tnet->sctp.max_retrans_init\t\t= 8;", " ", " \t ", " \tnet->sctp.sndbuf_policy\t\t\t= 0;", " ", " \t ", " \tnet->sctp.rcvbuf_policy\t\t\t= 0;", " ", " \t ", " \tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;", " ", " \t ", " \tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;", " ", " \t ", " \tnet->sctp.addip_enable = 0;", " \tnet->sctp.addip_noauth = 0;", " \tnet->sctp.default_auto_asconf = 0;", " ", " \t ", " \tnet->sctp.prsctp_enable = 1;", " ", " \t ", " \tnet->sctp.auth_enable = 0;", " ", " \t ", " \tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;", " ", " \t ", " \tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;", " ", " \t ", " \tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;", " ", " \tstatus = sctp_sysctl_net_register(net);", " \tif (status)", " \t\tgoto err_sysctl_register;", " ", " \t ", " \tstatus = init_sctp_mibs(net);", " \tif (status)", " \t\tgoto err_init_mibs;", " ", " \t ", " \tstatus = sctp_proc_init(net);", " \tif (status)", " \t\tgoto err_init_proc;", "  ", "  \tsctp_dbg_objcnt_init(net);", "  ", "\t ", "\tif ((status = sctp_ctl_sock_init(net))) {", "\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");", "\t\tgoto err_ctl_sock_init;", "\t}", "  \t ", "  \tINIT_LIST_HEAD(&net->sctp.local_addr_list);", "  \tspin_lock_init(&net->sctp.local_addr_lock);", " \tsctp_get_local_addr_list(net);", " ", " \t ", " \tINIT_LIST_HEAD(&net->sctp.addr_waitq);", " \tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);", " \tspin_lock_init(&net->sctp.addr_wq_lock);", " \tnet->sctp.addr_wq_timer.expires = 0;", " \tsetup_timer(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler,", " \t\t    (unsigned long)net);", "  ", "  \treturn 0;", "  ", "err_ctl_sock_init:", "\tsctp_dbg_objcnt_exit(net);", "\tsctp_proc_exit(net);", "  err_init_proc:", "  \tcleanup_sctp_mibs(net);", "  err_init_mibs:", " \tsctp_sysctl_net_unregister(net);", " err_sysctl_register:", "  \treturn status;", "  }"], "ner_tags": [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" stringprep (char *in,", " \t    size_t maxlen,", " \t    Stringprep_profile_flags flags,", " \t    const Stringprep_profile * profile)", " {", "   int rc;", "   char *utf8 = NULL;", "   uint32_t *ucs4 = NULL;", "   size_t ucs4len, maxucs4len, adducs4len = 50;", " ", "   do", "     {", "       uint32_t *newp;", "  ", "        free (ucs4);", "        ucs4 = stringprep_utf8_to_ucs4 (in, -1, &ucs4len);", "       if (ucs4 == NULL)", " \treturn STRINGPREP_ICONV_ERROR;", "        maxucs4len = ucs4len + adducs4len;", "        newp = realloc (ucs4, maxucs4len * sizeof (uint32_t));", "        if (!newp)", " \t  return STRINGPREP_MALLOC_ERROR;", " \t}", "       ucs4 = newp;", " ", "       rc = stringprep_4i (ucs4, &ucs4len, maxucs4len, flags, profile);", "       adducs4len += 50;", "     }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" krb5_init_creds_step(krb5_context context,", " \t\t     krb5_init_creds_context ctx,", " \t\t     krb5_data *in,", " \t\t     krb5_data *out,", " \t\t     krb5_krbhst_info *hostinfo,", " \t\t     unsigned int *flags)", " {", "     krb5_error_code ret;", "     size_t len = 0;", "     size_t size;", "     AS_REQ req2;", " ", "     krb5_data_zero(out);", " ", "     if (ctx->as_req.req_body.cname == NULL) {", " \tret = init_as_req(context, ctx->flags, &ctx->cred,", " \t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);", " \tif (ret) {", " \t    free_init_creds_ctx(context, ctx);", " \t    return ret;", " \t}", "     }", " ", " #define MAX_PA_COUNTER 10", "     if (ctx->pa_counter > MAX_PA_COUNTER) {", " \tkrb5_set_error_message(context, KRB5_GET_IN_TKT_LOOP,", " \t\t\t       N_(\"Looping %d times while getting \"", " \t\t\t\t  \"initial credentials\", \"\"),", " \t\t\t       ctx->pa_counter);", " \treturn KRB5_GET_IN_TKT_LOOP;", "     }", "     ctx->pa_counter++;", " ", "     _krb5_debug(context, 5, \"krb5_get_init_creds: loop %d\", ctx->pa_counter);", " ", "      ", "     if (in && in->length) {", " \tkrb5_kdc_rep rep;", " ", " \tmemset(&rep, 0, sizeof(rep));", " ", " \t_krb5_debug(context, 5, \"krb5_get_init_creds: processing input\");", " ", " \tret = decode_AS_REP(in->data, in->length, &rep.kdc_rep, &size);", " \tif (ret == 0) {", " \t    unsigned eflags = EXTRACT_TICKET_AS_REQ | EXTRACT_TICKET_TIMESYNC;", " \t    krb5_data data;", " ", " \t     ", " \t    ASN1_MALLOC_ENCODE(Ticket, data.data, data.length,", " \t\t\t       &rep.kdc_rep.ticket, &size, ret);", " \t    if (ret)", " \t\tgoto out;", " \t    heim_assert(data.length == size, \"ASN.1 internal error\");", " ", " \t    ret = fast_unwrap_as_rep(context, ctx->nonce, &data,", " \t\t\t\t     &ctx->fast_state, &rep.kdc_rep);", " \t    krb5_data_free(&data);", " \t    if (ret)", " \t\tgoto out;", " ", " \t     ", " ", " \t    if (ctx->flags.canonicalize) {", " \t\teflags |= EXTRACT_TICKET_ALLOW_SERVER_MISMATCH;", " \t\teflags |= EXTRACT_TICKET_MATCH_REALM;", " \t    }", " \t    if (ctx->ic_flags & KRB5_INIT_CREDS_NO_C_CANON_CHECK)", " \t\teflags |= EXTRACT_TICKET_ALLOW_CNAME_MISMATCH;", " ", " \t    ret = process_pa_data_to_key(context, ctx, &ctx->cred,", " \t\t\t\t\t &ctx->as_req, &rep.kdc_rep,", " \t\t\t\t\t hostinfo, &ctx->fast_state.reply_key);", " \t    if (ret) {", " \t\tfree_AS_REP(&rep.kdc_rep);", " \t\tgoto out;", " \t    }", " ", " \t    _krb5_debug(context, 5, \"krb5_get_init_creds: extracting ticket\");", " ", " \t    ret = _krb5_extract_ticket(context,", " \t\t\t\t       &rep,", " \t\t\t\t       &ctx->cred,", " \t\t\t\t       ctx->fast_state.reply_key,", " \t\t\t\t       NULL,", " \t\t\t\t       KRB5_KU_AS_REP_ENC_PART,", " \t\t\t\t       NULL,", " \t\t\t\t       ctx->nonce,", " \t\t\t\t       eflags,", "  \t\t\t\t       &ctx->req_buffer,", "  \t\t\t\t       NULL,", "  \t\t\t\t       NULL);", " \t    if (ret == 0 && ctx->pk_init_ctx) {", " \t\tPA_DATA *pa_pkinit_kx;", " \t\tint idx = 0;", " ", " \t\tpa_pkinit_kx =", " \t\t    krb5_find_padata(rep.kdc_rep.padata->val,", " \t\t\t\t     rep.kdc_rep.padata->len,", " \t\t\t\t     KRB5_PADATA_PKINIT_KX,", " \t\t\t\t     &idx);", " ", " \t\tret = _krb5_pk_kx_confirm(context, ctx->pk_init_ctx,", " \t\t\t\t\t  ctx->fast_state.reply_key,", " \t\t\t\t\t  &ctx->cred.session,", " \t\t\t\t\t  pa_pkinit_kx);", " \t\tif (ret)", " \t\t    krb5_set_error_message(context, ret,", " \t\t\t\t\t   N_(\"Failed to confirm PA-PKINIT-KX\", \"\"));", " \t\telse if (pa_pkinit_kx != NULL)", " \t\t    ctx->ic_flags |= KRB5_INIT_CREDS_PKINIT_KX_VALID;", " \t    }", "  \t    if (ret == 0)", "  \t\tret = copy_EncKDCRepPart(&rep.enc_part, &ctx->enc_part);", "  ", " \t    krb5_free_keyblock(context, ctx->fast_state.reply_key);", " \t    ctx->fast_state.reply_key = NULL;", " \t    *flags = 0;", " ", " \t    free_AS_REP(&rep.kdc_rep);", " \t    free_EncASRepPart(&rep.enc_part);", " ", " \t    return ret;", " ", " \t} else {", " \t     ", " ", " \t    _krb5_debug(context, 5, \"krb5_get_init_creds: got an error\");", " ", " \t    free_KRB_ERROR(&ctx->error);", " ", " \t    ret = krb5_rd_error(context, in, &ctx->error);", " \t    if(ret && in->length && ((char*)in->data)[0] == 4)", " \t\tret = KRB5KRB_AP_ERR_V4_REPLY;", " \t    if (ret) {", " \t\t_krb5_debug(context, 5, \"krb5_get_init_creds: failed to read error\");", " \t\tgoto out;", " \t    }", " ", " \t     ", " \t    ret = fast_unwrap_error(context, &ctx->fast_state, &ctx->error);", " \t    if (ret)", " \t\tgoto out;", " ", " \t     ", " ", " \t    ret = krb5_error_from_rd_error(context, &ctx->error, &ctx->cred);", " ", " \t    _krb5_debug(context, 5, \"krb5_get_init_creds: KRB-ERROR %d\", ret);", " ", " \t     ", " ", " \t    if (ret == KRB5KDC_ERR_PREAUTH_REQUIRED) {", " ", " \t        free_METHOD_DATA(&ctx->md);", " \t        memset(&ctx->md, 0, sizeof(ctx->md));", " ", " \t\tif (ctx->error.e_data) {", " \t\t    ret = decode_METHOD_DATA(ctx->error.e_data->data,", " \t\t\t\t\t     ctx->error.e_data->length,", " \t\t\t\t\t     &ctx->md,", " \t\t\t\t\t     NULL);", " \t\t    if (ret)", " \t\t\tkrb5_set_error_message(context, ret,", " \t\t\t\t\t       N_(\"Failed to decode METHOD-DATA\", \"\"));", " \t\t} else {", " \t\t    krb5_set_error_message(context, ret,", " \t\t\t\t\t   N_(\"Preauth required but no preauth \"", " \t\t\t\t\t      \"options send by KDC\", \"\"));", " \t\t}", " \t    } else if (ret == KRB5KRB_AP_ERR_SKEW && context->kdc_sec_offset == 0) {", " \t\t ", " \t\tkrb5_set_real_time(context, ctx->error.stime, -1);", " \t\tif (context->kdc_sec_offset)", " \t\t    ret = 0;", " ", " \t\t_krb5_debug(context, 10, \"init_creds: err skew updateing kdc offset to %d\",", " \t\t\t    context->kdc_sec_offset);", " ", " \t\tctx->used_pa_types = 0;", " ", " \t    } else if (ret == KRB5_KDC_ERR_WRONG_REALM && ctx->flags.canonicalize) {", " \t         ", " ", " \t\tif (ctx->error.crealm == NULL) {", " \t\t    krb5_set_error_message(context, ret,", " \t\t\t\t\t   N_(\"Got a client referral, not but no realm\", \"\"));", " \t\t    goto out;", " \t\t}", " \t\t_krb5_debug(context, 5,", " \t\t\t    \"krb5_get_init_creds: got referal to realm %s\",", " \t\t\t    *ctx->error.crealm);", " ", " \t\tret = krb5_principal_set_realm(context,", " \t\t\t\t\t       ctx->cred.client,", " \t\t\t\t\t       *ctx->error.crealm);", " \t\tif (ret)", " \t\t    goto out;", " ", " \t\tif (krb5_principal_is_krbtgt(context, ctx->cred.server)) {", " \t\t    ret = krb5_init_creds_set_service(context, ctx, NULL);", " \t\t    if (ret)", " \t\t\tgoto out;", " \t\t}", " ", " \t\tfree_AS_REQ(&ctx->as_req);", " \t\tmemset(&ctx->as_req, 0, sizeof(ctx->as_req));", " ", " \t\tctx->used_pa_types = 0;", " \t    } else if (ret == KRB5KDC_ERR_KEY_EXP && ctx->runflags.change_password == 0 && ctx->prompter) {", " \t\tchar buf2[1024];", " ", " \t\tctx->runflags.change_password = 1;", " ", " \t\tctx->prompter(context, ctx->prompter_data, NULL, N_(\"Password has expired\", \"\"), 0, NULL);", " ", " ", " \t\t ", " \t\tif (ctx->in_tkt_service != NULL && strcmp(ctx->in_tkt_service, \"kadmin/changepw\") == 0)", " \t\t    goto out;", " ", "                  ", "                 if (ctx->prompter == NULL)", "                     goto out;", " ", " \t\tret = change_password(context,", " \t\t\t\t      ctx->cred.client,", " \t\t\t\t      ctx->password,", " \t\t\t\t      buf2,", " \t\t\t\t      sizeof(buf2),", " \t\t\t\t      ctx->prompter,", " \t\t\t\t      ctx->prompter_data,", " \t\t\t\t      NULL);", " \t\tif (ret)", " \t\t    goto out;", " ", " \t\tkrb5_init_creds_set_password(context, ctx, buf2);", " ", "  \t\tctx->used_pa_types = 0;", " \t\tret = 0;", " ", "  \t    } else if (ret == KRB5KDC_ERR_PREAUTH_FAILED) {", "  ", "  \t\tif (ctx->fast_state.flags & KRB5_FAST_DISABLED)", "  \t\t    goto out;", "  \t\tif (ctx->fast_state.flags & (KRB5_FAST_REQUIRED | KRB5_FAST_EXPECTED))", "  \t\t    goto out;", "  ", "  \t\t_krb5_debug(context, 10, \"preauth failed with FAST, \"", " \t\t\t    \"and told by KD or user, trying w/o FAST\");", "  ", "  \t\tctx->fast_state.flags |= KRB5_FAST_DISABLED;", "  \t\tctx->used_pa_types = 0;", " \t\tret = 0;", " \t    }", " \t    if (ret)", " \t\tgoto out;", " \t}", "     }", " ", "     if (ctx->as_req.req_body.cname == NULL) {", " \tret = init_as_req(context, ctx->flags, &ctx->cred,", " \t\t\t  ctx->addrs, ctx->etypes, &ctx->as_req);", " \tif (ret) {", " \t    free_init_creds_ctx(context, ctx);", " \t    return ret;", " \t}", "     }", " ", "     if (ctx->as_req.padata) {", " \tfree_METHOD_DATA(ctx->as_req.padata);", " \tfree(ctx->as_req.padata);", " \tctx->as_req.padata = NULL;", "     }", " ", "      ", "     ctx->as_req.req_body.nonce = ctx->nonce;", " ", "      ", "     ret = process_pa_data_to_md(context, &ctx->cred, &ctx->as_req, ctx,", " \t\t\t\t&ctx->md, &ctx->as_req.padata,", " \t\t\t\tctx->prompter, ctx->prompter_data);", "     if (ret)", " \tgoto out;", " ", "      ", "     copy_AS_REQ(&ctx->as_req, &req2);", " ", "     ret = fast_wrap_req(context, &ctx->fast_state, &req2);", "     if (ret) {", " \tfree_AS_REQ(&req2);", " \tgoto out;", "     }", " ", "     krb5_data_free(&ctx->req_buffer);", " ", "     ASN1_MALLOC_ENCODE(AS_REQ,", " \t\t       ctx->req_buffer.data, ctx->req_buffer.length,", " \t\t       &req2, &len, ret);", "     free_AS_REQ(&req2);", "     if (ret)", " \tgoto out;", "     if(len != ctx->req_buffer.length)", " \tkrb5_abortx(context, \"internal error in ASN.1 encoder\");", " ", "     out->data = ctx->req_buffer.data;", "     out->length = ctx->req_buffer.length;", " ", "     *flags = KRB5_INIT_CREDS_STEP_FLAG_CONTINUE;", " ", "     return 0;", "  out:", "     return ret;", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" int main(int argc, char **argv)", " {", " #ifdef sgi", "  char tmpline[80];", " #endif", "  char *p;", "  int rc, alen, flen;", "  int error = 0;", "  int have_bg = FALSE;", "  double LUT_exponent;  ", "  double CRT_exponent = 2.2;  ", "  double default_display_exponent;  ", "  XEvent e;", "  KeySym k;", " ", " ", "     displayname = (char *)NULL;", "     filename = (char *)NULL;", " ", " ", "   ", " ", " #if defined(NeXT)", "     LUT_exponent = 1.0 / 2.2;", "   ", " #elif defined(sgi)", "     LUT_exponent = 1.0 / 1.7;", "   ", "     infile = fopen(\"/etc/config/system.glGammaVal\", \"r\");", "  if (infile) {", "  double sgi_gamma;", " ", "         fgets(tmpline, 80, infile);", "         fclose(infile);", "         sgi_gamma = atof(tmpline);", "  if (sgi_gamma > 0.0)", "             LUT_exponent = 1.0 / sgi_gamma;", "  }", " #elif defined(Macintosh)", "     LUT_exponent = 1.8 / 2.61;", "   ", " #else", "     LUT_exponent = 1.0;  ", " #endif", " ", "   ", "     default_display_exponent = LUT_exponent * CRT_exponent;", " ", " ", "   ", " ", "  if ((p = getenv(\"SCREEN_GAMMA\")) != NULL)", "         display_exponent = atof(p);", "  else", "         display_exponent = default_display_exponent;", " ", " ", "   ", " ", "  while (*++argv && !error) {", "  if (!strncmp(*argv, \"-display\", 2)) {", "  if (!*++argv)", "  ++error;", "  else", "                 displayname = *argv;", "  } else if (!strncmp(*argv, \"-gamma\", 2)) {", "  if (!*++argv)", "  ++error;", "  else {", "                 display_exponent = atof(*argv);", "  if (display_exponent <= 0.0)", "  ++error;", "  }", "  } else if (!strncmp(*argv, \"-bgcolor\", 2)) {", "  if (!*++argv)", "  ++error;", "  else {", "                 bgstr = *argv;", "  if (strlen(bgstr) != 7 || bgstr[0] != '#')", "  ++error;", "  else", "                     have_bg = TRUE;", "  }", "  } else {", "  if (**argv != '-') {", "                 filename = *argv;", "  if (argv[1])  ", "  ++error;", "  } else", "  ++error;  ", "  }", "  }", " ", "  if (!filename)", "  ++error;", " ", " ", "   ", " ", "  if (error) {", "         fprintf(stderr, \"\\n%s %s:  %s\\n\", PROGNAME, VERSION, appname);", "         readpng_version_info();", "         fprintf(stderr, \"\\n\"", " ", "            \"Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\\n\"", "            \"    xdpy\\tname of the target X display (e.g., ``hostname:0'')\\n\"", "            \"    exp \\ttransfer-function exponent (``gamma'') of the display\\n\"", "          \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\"", "           \"\\t\\t  system in floating-point format (e.g., ``%.1f''); equal\\n\",", "           PROGNAME, default_display_exponent);", " ", "         fprintf(stderr, \"\\n\"", "            \"\\t\\t  to the product of the lookup-table exponent (varies)\\n\"", "            \"\\t\\t  and the CRT exponent (usually 2.2); must be positive\\n\"", "            \"    bg  \\tdesired background color in 7-character hex RGB format\\n\"", "            \"\\t\\t  (e.g., ``#ff7700'' for orange:  same as HTML colors);\\n\"", "            \"\\t\\t  used with transparent images\\n\"", "            \"\\nPress Q, Esc or mouse button 1 (within image window, after image\\n\"", "          \"is displayed) to quit.\\n\"", "          \"\\n\", PROGNAME, default_display_exponent);", "           \"is displayed) to quit.\\n\");", "          exit(1);", "      }", "  ", " ", "  if (!(infile = fopen(filename, \"rb\"))) {", "         fprintf(stderr, PROGNAME \":  can't open PNG file [%s]\\n\", filename);", "  ++error;", "  } else {", "  if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {", "  switch (rc) {", "  case 1:", "                     fprintf(stderr, PROGNAME", "  \":  [%s] is not a PNG file: incorrect signature\\n\",", "                       filename);", "  break;", "  case 2:", "                     fprintf(stderr, PROGNAME", "  \":  [%s] has bad IHDR (libpng longjmp)\\n\", filename);", "  break;", "  case 4:", "                     fprintf(stderr, PROGNAME \":  insufficient memory\\n\");", "  break;", "  default:", "                     fprintf(stderr, PROGNAME", "  \":  unknown readpng_init() error\\n\");", "  break;", "  }", "  ++error;", "  } else {", "             display = XOpenDisplay(displayname);", "  if (!display) {", "                 readpng_cleanup(TRUE);", "                 fprintf(stderr, PROGNAME \":  can't open X display [%s]\\n\",", "                   displayname? displayname : \"default\");", "  ++error;", "  }", "  }", "  if (error)", "             fclose(infile);", "  }", " ", " ", "  if (error) {", "         fprintf(stderr, PROGNAME \":  aborting.\\n\");", "         exit(2);", "  }", " ", " ", "   ", " ", "     alen = strlen(appname);", "     flen = strlen(filename);", "  if (alen + flen + 3 > 1023)", "         sprintf(titlebar, \"%s:  ...%s\", appname, filename+(alen+flen+6-1023));", "  else", "         sprintf(titlebar, \"%s:  %s\", appname, filename);", " ", " ", "   ", " ", "  if (have_bg) {", "  unsigned r, g, b;  ", " ", "         sscanf(bgstr+1, \"%2x%2x%2x\", &r, &g, &b);", "         bg_red   = (uch)r;", "         bg_green = (uch)g;", "         bg_blue  = (uch)b;", "  } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {", "         readpng_cleanup(TRUE);", "         fprintf(stderr, PROGNAME", "  \":  libpng error while checking for background color\\n\");", "         exit(2);", "  }", " ", " ", "   ", " ", "  if (rpng_x_create_window())", "         exit(2);", " ", " ", "   ", " ", "  Trace((stderr, \"calling readpng_get_image()\\n\"))", "     image_data = readpng_get_image(display_exponent, &image_channels,", "  &image_rowbytes);", "  Trace((stderr, \"done with readpng_get_image()\\n\"))", " ", " ", "   ", " ", "     readpng_cleanup(FALSE);", "     fclose(infile);", " ", "  if (!image_data) {", "         fprintf(stderr, PROGNAME \":  unable to decode PNG image\\n\");", "         exit(3);", "  }", " ", " ", "   ", " ", "  Trace((stderr, \"calling rpng_x_display_image()\\n\"))", "  if (rpng_x_display_image()) {", "         free(image_data);", "         exit(4);", "  }", "  Trace((stderr, \"done with rpng_x_display_image()\\n\"))", " ", " ", "   ", " ", "     printf(", "  \"Done.  Press Q, Esc or mouse button 1 (within image window) to quit.\\n\");", "     fflush(stdout);", " ", "  do", "  XNextEvent(display, &e);", "  while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&", "  !(e.type == KeyPress &&  ", "  ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));", " ", " ", "   ", " ", "  ", "      rpng_x_cleanup();", "  ", "     (void)argc;  ", " ", "      return 0;", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0]}
{"tokens": [" static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)", " {", " \tstruct nlm_rqst\t*req = data;", " \tu32 status = ntohl(req->a_res.status);", " ", " \tif (RPC_ASSASSINATED(task))", " \t\tgoto die;", "  ", "  \tif (task->tk_status < 0) {", "  \t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);", "\t\tgoto retry_rebind;", " \t\tswitch (task->tk_status) {", " \t\tcase -EACCES:", " \t\tcase -EIO:", " \t\t\tgoto die;", " \t\tdefault:", " \t\t\tgoto retry_rebind;", " \t\t}", "  \t}", "  \tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {", "  \t\trpc_delay(task, NLMCLNT_GRACE_WAIT);", " \t\tgoto retry_unlock;", " \t}", " \tif (status != NLM_LCK_GRANTED)", " \t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);", " die:", " \treturn;", "  retry_rebind:", " \tnlm_rebind_host(req->a_host);", "  retry_unlock:", " \trpc_restart_call(task);", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void RenderWidgetHostViewAura::WasHidden() {", "   if (host_->is_hidden())", "     return;", "   host_->WasHidden();", "  ", "    released_front_lock_ = NULL;", "  ", "  if (ShouldReleaseFrontSurface() &&", "      host_->is_accelerated_compositing_active()) {", "    current_surface_ = 0;", "    UpdateExternalTexture();", "  }", "  AdjustSurfaceProtection();", "  #if defined(OS_WIN)", "    aura::RootWindow* root_window = window_->GetRootWindow();", "    if (root_window) {", "     HWND parent = root_window->GetAcceleratedWidget();", "     LPARAM lparam = reinterpret_cast<LPARAM>(this);", " ", "     EnumChildWindows(parent, HideWindowsCallback, lparam);", "   }", " #endif", " }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
{"tokens": [" void Document::InitSecurityContext(const DocumentInit& initializer) {", "   DCHECK(!GetSecurityOrigin());", " ", "   if (!initializer.HasSecurityContext()) {", "     cookie_url_ = KURL(kParsedURLString, g_empty_string);", "     SetSecurityOrigin(SecurityOrigin::CreateUnique());", "     InitContentSecurityPolicy();", "     SetFeaturePolicy(g_empty_string);", "     return;", "   }", " ", "   EnforceSandboxFlags(initializer.GetSandboxFlags());", "   SetInsecureRequestPolicy(initializer.GetInsecureRequestPolicy());", "   if (initializer.InsecureNavigationsToUpgrade()) {", "     for (auto to_upgrade : *initializer.InsecureNavigationsToUpgrade())", "        AddInsecureNavigationUpgrade(to_upgrade);", "    }", "  ", "   ContentSecurityPolicy* policy_to_inherit = nullptr;", " ", "    if (IsSandboxed(kSandboxOrigin)) {", "      cookie_url_ = url_;", "      SetSecurityOrigin(SecurityOrigin::CreateUnique());", "     Document* owner = initializer.OwnerDocument();", "     if (owner) {", "       if (owner->GetSecurityOrigin()->IsPotentiallyTrustworthy())", "          GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);", "        if (owner->GetSecurityOrigin()->CanLoadLocalResources())", "          GetSecurityOrigin()->GrantLoadLocalResources();", "       policy_to_inherit = owner->GetContentSecurityPolicy();", "      }", "    } else if (Document* owner = initializer.OwnerDocument()) {", "      cookie_url_ = owner->CookieURL();", "      SetSecurityOrigin(owner->GetSecurityOrigin());", "     policy_to_inherit = owner->GetContentSecurityPolicy();", "    } else {", "      cookie_url_ = url_;", "      SetSecurityOrigin(SecurityOrigin::Create(url_));", "   }", " ", "   if (initializer.IsHostedInReservedIPRange()) {", "     SetAddressSpace(GetSecurityOrigin()->IsLocalhost()", "                         ? kWebAddressSpaceLocal", "                         : kWebAddressSpacePrivate);", "   } else if (GetSecurityOrigin()->IsLocal()) {", "     SetAddressSpace(kWebAddressSpaceLocal);", "   } else {", "     SetAddressSpace(kWebAddressSpacePublic);", "   }", " ", "   if (ImportsController()) {", "      SetContentSecurityPolicy(", "          ImportsController()->Master()->GetContentSecurityPolicy());", "    } else {", "    InitContentSecurityPolicy();", "     InitContentSecurityPolicy(nullptr, policy_to_inherit);", "    }", "  ", "    if (GetSecurityOrigin()->HasSuborigin())", "     EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());", " ", "   if (Settings* settings = initializer.GetSettings()) {", "     if (!settings->GetWebSecurityEnabled()) {", "       GetSecurityOrigin()->GrantUniversalAccess();", "     } else if (GetSecurityOrigin()->IsLocal()) {", "       if (settings->GetAllowUniversalAccessFromFileURLs()) {", "         GetSecurityOrigin()->GrantUniversalAccess();", "       } else if (!settings->GetAllowFileAccessFromFileURLs()) {", "         GetSecurityOrigin()->BlockLocalAccessFromLocalOrigin();", "       }", "     }", "   }", " ", "   if (GetSecurityOrigin()->IsUnique() &&", "       SecurityOrigin::Create(url_)->IsPotentiallyTrustworthy())", "     GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);", " ", "   if (GetSecurityOrigin()->HasSuborigin())", "     EnforceSuborigin(*GetSecurityOrigin()->GetSuborigin());", " ", "    SetFeaturePolicy(g_empty_string);", "  }"], "ner_tags": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
